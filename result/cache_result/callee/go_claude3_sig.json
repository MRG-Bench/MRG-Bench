{"dtm-dtmsvr/storage/boltdb/boltdb.go-cleanupExpiredData": {"response": ["```go\nfunc cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n\tnow := time.Now().Unix()\n\treturn db.Update(func(tx *bolt.Tx) error {\n\t\tb := tx.Bucket([]byte(\"data\"))\n\t\tif b == nil {\n\t\t\treturn nil\n\t\t}\n\t\tc := b.Cursor()\n\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\tvar data struct {\n\t\t\t\tTimestamp int64 `json:\"timestamp\"`\n\t\t\t}\n\t\t\tif err := json.Unmarshal(v, &data); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif data.Timestamp+int64(expire/time.Second) < now {\n\t\t\t\tif err := b.Delete(k); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n# Natural Language Annotations: // cleanupExpiredData will clean the expired data in boltdb, the\n//\n//\texpired time is configurable.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "dtm-dtmsvr/config/config.go-MustLoadConfig": {"response": ["```go\nfunc MustLoadConfig(confFile string) {\n    viper.SetConfigFile(confFile)\n    viper.AutomaticEnv()\n    viper.SetEnvKeyReplacer(strings.NewReplacer(\".\", \"_\"))\n    err := viper.ReadInConfig()\n    if err != nil {\n        panic(fmt.Errorf(\"fatal error config file: %s\", err))\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MustLoadConfig(confFile string) {\n# Natural Language Annotations: // MustLoadConfig load config from env and file\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "dtm-client/dtmcli/dtmimp/utils.go-MustRemarshal": {"response": ["```go\nfunc MustRemarshal(from interface{}, to interface{}) {\n\tdata, err := json.Marshal(from)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\terr = json.Unmarshal(data, to)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MustRemarshal(from interface{}, to interface{}) {\n# Natural Language Annotations: // MustRemarshal marshal and unmarshal, and check error\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-tool/internal_pkg/generator/type.go-FixHasStreamingForExtendedService": {"response": ["```\nfunc (s *ServiceInfo) FixHasStreamingForExtendedService() {\n\tif s.IsExtendedService() {\n\t\ts.HasStreaming = true\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *ServiceInfo) FixHasStreamingForExtendedService() {\n# Natural Language Annotations: // FixHasStreamingForExtendedService updates the HasStreaming field for extended services.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-tool/internal_pkg/generator/type.go-HasStreamingRecursive": {"response": ["```go\nfunc (s *ServiceInfo) HasStreamingRecursive() bool {\n\tfor _, method := range s.Methods {\n\t\tif method.IsClientStreaming || method.IsServerStreaming {\n\t\t\treturn true\n\t\t}\n\t}\n\n\tfor _, service := range s.Services {\n\t\tif service.HasStreamingRecursive() {\n\t\t\treturn true\n\t\t}\n\t}\n\n\treturn false\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *ServiceInfo) HasStreamingRecursive() bool {\n# Natural Language Annotations: // HasStreamingRecursive recursively check if the service has streaming method\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-tool/internal_pkg/generator/generator.go-Unpack": {"response": ["```go\nfunc (c *Config) Unpack(args []string) error {\n    for _, arg := range args {\n        parts := strings.SplitN(arg, \"=\", 2)\n        if len(parts) != 2 {\n            return fmt.Errorf(\"invalid argument: %s\", arg)\n        }\n        key, val := parts[0], parts[1]\n        if err := c.Set(key, val); err != nil {\n            return err\n        }\n    }\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Config) Unpack(args []string) error {\n# Natural Language Annotations: // Unpack restores the Config from a slice of \"key=val\" strings.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-tool/internal_pkg/util/util.go-CombineOutputPath": {"response": ["```go\nfunc CombineOutputPath(outputPath, ns string) string {\n\tif strings.HasSuffix(outputPath, \"/\") {\n\t\treturn outputPath + ns\n\t}\n\treturn outputPath + \"/\" + ns\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CombineOutputPath(outputPath, ns string) string {\n# Natural Language Annotations: // CombineOutputPath read the output and path variables and render them into the final path\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/rpcinfo/stats_util.go-CalcEventCostUs": {"response": ["```go\nfunc CalcEventCostUs(start, end Event) uint64 {\n    return uint64(end.Time.Sub(start.Time).Microseconds())\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CalcEventCostUs(start, end Event) uint64 {\n# Natural Language Annotations: // CalcEventCostUs calculates the duration between start and end and returns in microsecond.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/rpcinfo/invocation.go-NewInvocation": {"response": ["```go\nfunc NewInvocation(service, method string, pkgOpt ...string) *invocation {\n    pkg := \"default\"\n    if len(pkgOpt) > 0 {\n        pkg = pkgOpt[0]\n    }\n    return &invocation{\n        ServiceName: service,\n        MethodName:  method,\n        PackageName: pkg,\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewInvocation(service, method string, pkgOpt ...string) *invocation {\n# Natural Language Annotations: // NewInvocation creates a new Invocation with the given service, method and optional package.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/retry/retryer.go-InitWithPolicies": {"response": ["```go\nfunc (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n\trc.mu.Lock()\n\tdefer rc.mu.Unlock()\n\n\tif rc.methodPolicies == nil {\n\t\trc.methodPolicies = make(map[string]Policy)\n\t}\n\n\tfor method, policy := range methodPolicies {\n\t\trc.methodPolicies[method] = policy\n\t}\n\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n# Natural Language Annotations: // InitWithPolicies to init Retryer with methodPolicies\n// Notice, InitWithPolicies is export func, the lock should be added inside\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/retry/retryer.go-WithRetryIfNeeded": {"response": ["```go\nfunc (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n    var retryer retry.Retryer\n    if callOptRetry != nil && callOptRetry.Retryer != nil {\n        retryer = callOptRetry.Retryer\n    } else {\n        retryer = rc.opt.Retryer\n    }\n\n    if retryer == nil {\n        lastRI, recycleRI, err = rpcCall(ctx, ri, request)\n        return\n    }\n\n    canRetry := retryer.Check(ri.Route, ri.Request.CalleeMethod())\n    if !canRetry {\n        lastRI, recycleRI, err = rpcCall(ctx, ri, request)\n        return\n    }\n\n    lastRI, recycleRI, err = retryer.Do(ctx, func(ctx context.Context) (rpcinfo.RPCInfo, bool, error) {\n        return rpcCall(ctx, ri, request)\n    })\n\n    return\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n# Natural Language Annotations: // WithRetryIfNeeded to check if there is a retryer can be used and if current call can retry.\n// When the retry condition is satisfied, use retryer to call\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/discovery/discovery.go-DefaultDiff": {"response": ["```go\nfunc DefaultDiff(cacheKey string, prev, next Result) (Change, bool) {\n\tif !prev.HasData() {\n\t\treturn Change{}, true\n\t}\n\n\tif !next.HasData() {\n\t\treturn Change{}, true\n\t}\n\n\tprevData := reflect.ValueOf(prev.Data)\n\tnextData := reflect.ValueOf(next.Data)\n\n\tif prevData.Kind() != nextData.Kind() {\n\t\treturn Change{}, true\n\t}\n\n\tif prevData.Kind() == reflect.Ptr {\n\t\tif prevData.IsNil() && nextData.IsNil() {\n\t\t\treturn Change{}, false\n\t\t}\n\t\tif prevData.IsNil() != nextData.IsNil() {\n\t\t\treturn Change{}, true\n\t\t}\n\t\tprevData = prevData.Elem()\n\t\tnextData = nextData.Elem()\n\t}\n\n\tswitch prevData.Kind() {\n\tcase reflect.Array, reflect.Slice:\n\t\tif prevData.Len() != nextData.Len() {\n\t\t\treturn Change{}, true\n\t\t}\n\t\tfor i := 0; i < prevData.Len(); i++ {\n\t\t\tif prevData.Index(i).Interface() != nextData.Index(i).Interface() {\n\t\t\t\treturn Change{}, true\n\t\t\t}\n\t\t}\n\t\treturn Change{}, false\n\n\tcase reflect.Map:\n\t\tif prevData.Len() != nextData.Len() {\n\t\t\treturn Change{}, true\n\t\t}\n\t\tfor _, key := range prevData.MapKeys() {\n\t\t\tprevValue := prevData.MapIndex(key)\n\t\t\tnextValue := nextData.MapIndex(key)\n\t\t\tif !prevValue.IsValid() || !nextValue.IsValid() || prevValue.Interface() != nextValue.Interface() {\n\t\t\t\treturn Change{}, true\n\t\t\t}\n\t\t}\n\t\treturn Change{}, false\n\n\tcase reflect.Struct:\n\t\tif prevData.NumField() != nextData.NumField() {\n\t\t\treturn Change{}, true\n\t\t}\n\t\tfor i := 0; i < prevData.NumField(); i++ {\n\t\t\tif prevData.Field(i).Interface() != nextData.Field(i).Interface() {\n\t\t\t\treturn Change{}, true\n\t\t\t}\n\t\t}\n\t\treturn Change{}, false\n\n\tdefault:\n\t\treturn Change{}, prevData.Interface() != nextData.Interface()\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefaultDiff(cacheKey string, prev, next Result) (Change, bool) {\n# Natural Language Annotations: // DefaultDiff provides a natural implementation for the Diff method of the Resolver interface.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/protocol/bthrift/binary.go-SetSpanCache": {"response": ["```go\nfunc SetSpanCache(enable bool) {\n    if enable {\n        // Enable binary protocol bytes/string allocator\n        // Implementation details for enabling span cache\n    } else {\n        // Disable binary protocol bytes/string allocator\n        // Implementation details for disabling span cache\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func SetSpanCache(enable bool) {\n# Natural Language Annotations: // SetSpanCache enable/disable binary protocol bytes/string allocator\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/protocol/bthrift/unknown.go-GetUnknownFields": {"response": ["```go\nfunc GetUnknownFields(v interface{}) (fields []UnknownField, err error) {\n\tvar rawFields map[string]json.RawMessage\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := json.Unmarshal(data, &rawFields); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor key, value := range rawFields {\n\t\tfields = append(fields, UnknownField{\n\t\t\tKey:   key,\n\t\t\tValue: string(value),\n\t\t})\n\t}\n\treturn fields, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetUnknownFields(v interface{}) (fields []UnknownField, err error) {\n# Natural Language Annotations: // GetUnknownFields deserialize unknownFields stored in v to a list of *UnknownFields.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/protocol/bthrift/unknown.go-WriteUnknownFields": {"response": ["```go\nfunc WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n\tfor _, f := range fs {\n\t\tn, err := f.Write(buf[offset:])\n\t\tif err != nil {\n\t\t\treturn offset, err\n\t\t}\n\t\toffset += n\n\t}\n\treturn offset, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n# Natural Language Annotations: // WriteUnknownFields writes fs into buf, and return written offset of the buf.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/circuitbreak/circuitbreak.go-NewCircuitBreakerMW": {"response": ["```go\nfunc NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n\treturn func(next endpoint.Endpoint) endpoint.Endpoint {\n\t\treturn func(ctx context.Context, request interface{}) (response interface{}, err error) {\n\t\t\tif !panel.Allow() {\n\t\t\t\treturn nil, ErrCircuitOpen\n\t\t\t}\n\t\t\tdefer func() {\n\t\t\t\tif err != nil {\n\t\t\t\t\tpanel.Mark(err)\n\t\t\t\t}\n\t\t\t}()\n\t\t\treturn next(ctx, request)\n\t\t}\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n# Natural Language Annotations: // NewCircuitBreakerMW creates a circuit breaker MW using the given Control strategy and Panel.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/circuitbreak/cbsuite.go-RPCInfo2Key": {"response": ["```go\nfunc RPCInfo2Key(ri rpcinfo.RPCInfo) string {\n    return fmt.Sprintf(\"%s.%s.%s\", ri.Caller, ri.Service, ri.Method)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RPCInfo2Key(ri rpcinfo.RPCInfo) string {\n# Natural Language Annotations: // RPCInfo2Key is to generate circuit breaker key through rpcinfo\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/circuitbreak/default.go-ErrorTypeOnServiceLevel": {"response": ["```go\nfunc ErrorTypeOnServiceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n    if err == nil {\n        return NoError\n    }\n\n    // Check for specific error conditions at the service level\n    switch {\n    case errors.Is(err, ErrInvalidRequest):\n        return InvalidRequestError\n    case errors.Is(err, ErrUnauthorized):\n        return UnauthorizedError\n    case errors.Is(err, ErrForbidden):\n        return ForbiddenError\n    case errors.Is(err, ErrNotFound):\n        return NotFoundError\n    case errors.Is(err, ErrConflict):\n        return ConflictError\n    case errors.Is(err, ErrTooManyRequests):\n        return TooManyRequestsError\n    case errors.Is(err, ErrInternalServer):\n        return InternalServerError\n    case errors.Is(err, ErrServiceUnavailable):\n        return ServiceUnavailableError\n    default:\n        // Fallback to a generic error type\n        return UnknownError\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ErrorTypeOnServiceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n# Natural Language Annotations: // ErrorTypeOnServiceLevel determines the error type with a service level criteria.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/circuitbreak/default.go-ErrorTypeOnInstanceLevel": {"response": ["```go\nfunc ErrorTypeOnInstanceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n\tif err == nil {\n\t\treturn Success\n\t}\n\tif errors.Is(err, ErrConnectFailed) {\n\t\treturn Failure\n\t}\n\treturn Transient\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ErrorTypeOnInstanceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n# Natural Language Annotations: // ErrorTypeOnInstanceLevel determines the error type with an instance level criteria.\n// Basically, it treats only the connection error as failure.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/ring.go-NewRing": {"response": ["```go\n// Deprecated: it's not used by kitex anymore.\n// NewRing creates a ringbuffer with fixed size.\nfunc NewRing(size int) *Ring {\n\treturn &Ring{\n\t\telements: make([]interface{}, size),\n\t\tsize:     size,\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewRing(size int) *Ring {\n# Natural Language Annotations: // Deprecated: it's not used by kitex anymore.\n// NewRing creates a ringbuffer with fixed size.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/thrift.go-Serialize": {"response": ["```go\nfunc (t *ThriftMessageCodec) Serialize(msg thrift.TStruct) (b []byte, err error) {\n\tbuf := thrift.NewTMemoryBuffer()\n\toprot := thrift.NewTBinaryProtocolConf(buf, &thrift.TConfiguration{})\n\tif err := msg.Write(oprot); err != nil {\n\t\treturn nil, err\n\t}\n\treturn buf.Bytes(), nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *ThriftMessageCodec) Serialize(msg thrift.TStruct) (b []byte, err error) {\n# Natural Language Annotations: // Serialize serialize message into bytes. This is normal thrift serialize func.\n// Notice: Binary generic use Encode instead of Serialize.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/thrift.go-Deserialize": {"response": ["```go\nfunc (t *ThriftMessageCodec) Deserialize(msg thrift.TStruct, b []byte) (err error) {\n\ttransport := thrift.NewStreamTransportR(bytes.NewBuffer(b))\n\tprotocol := thrift.NewTBinaryProtocol(transport, false, true)\n\terr = msg.Read(protocol)\n\treturn\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *ThriftMessageCodec) Deserialize(msg thrift.TStruct, b []byte) (err error) {\n# Natural Language Annotations: // Deserialize deserialize bytes into message. This is normal thrift deserialize func.\n// Notice: Binary generic use Decode instead of Deserialize.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/thrift.go-MarshalError": {"response": ["```go\nfunc MarshalError(method string, err error) []byte {\n    exception := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, fmt.Sprintf(\"method %s failed: %s\", method, err.Error()))\n    buf := thrift.NewTMemoryBuffer()\n    transport := thrift.NewTBinaryProtocolTransport(buf)\n    exception.Write(transport)\n    return buf.Bytes()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MarshalError(method string, err error) []byte {\n# Natural Language Annotations: // MarshalError convert go error to thrift exception, and encode exception over buffered binary transport.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/rpcstats.go-CalculateEventCost": {"response": ["```go\nfunc CalculateEventCost(rpcstats rpcinfo.RPCStats, start, end stats.Event) time.Duration {\n    startEvent := rpcstats.GetEvent(start)\n    endEvent := rpcstats.GetEvent(end)\n\n    if startEvent == nil || endEvent == nil {\n        return 0\n    }\n\n    return endEvent.Time.Sub(startEvent.Time)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CalculateEventCost(rpcstats rpcinfo.RPCStats, start, end stats.Event) time.Duration {\n# Natural Language Annotations: // CalculateEventCost get events from rpcstats, and calculates the time duration of (end - start).\n// It returns 0 when get nil rpcinfo event of either stats event.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/json.go-_Map2JSONStr": {"response": ["```go\nfunc _Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n\tif mapInfo == nil {\n\t\treturn \"\", nil\n\t}\n\tstr = \"{\"\n\tfor k, v := range mapInfo {\n\t\tstr += \"\\\"\" + k + \"\\\":\" + \"\\\"\" + v + \"\\\",\"\n\t}\n\tif len(str) > 1 {\n\t\tstr = str[:len(str)-1]\n\t}\n\tstr += \"}\"\n\treturn str, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func _Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n# Natural Language Annotations: // Map2JSONStr transform map[string]string to json str, perf is better than use json lib directly\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/json.go-_JSONStr2Map": {"response": ["```go\nfunc _JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n\tmapInfo = make(map[string]string)\n\tif len(jsonStr) == 0 {\n\t\treturn\n\t}\n\tjsonStr = strings.TrimSpace(jsonStr)\n\tif jsonStr[0] != '{' || jsonStr[len(jsonStr)-1] != '}' {\n\t\terr = errors.New(\"invalid json str\")\n\t\treturn\n\t}\n\tjsonStr = jsonStr[1 : len(jsonStr)-1]\n\tif len(jsonStr) == 0 {\n\t\treturn\n\t}\n\tvar key, value string\n\tfor {\n\t\tidx := strings.IndexByte(jsonStr, '\"')\n\t\tif idx == -1 {\n\t\t\tbreak\n\t\t}\n\t\tkey, jsonStr = jsonStr[idx+1:], jsonStr[idx+1:]\n\t\tidx = strings.IndexByte(key, '\"')\n\t\tif idx == -1 {\n\t\t\terr = errors.New(\"invalid json str\")\n\t\t\treturn\n\t\t}\n\t\tkey, jsonStr = key[:idx], key[idx+1:]\n\t\tidx = strings.IndexByte(jsonStr, ':')\n\t\tif idx == -1 {\n\t\t\terr = errors.New(\"invalid json str\")\n\t\t\treturn\n\t\t}\n\t\tjsonStr = jsonStr[idx+1:]\n\t\tjsonStr = strings.TrimSpace(jsonStr)\n\t\tif len(jsonStr) == 0 {\n\t\t\terr = errors.New(\"invalid json str\")\n\t\t\treturn\n\t\t}\n\t\tif jsonStr[0] == '\"' {\n\t\t\tjsonStr = jsonStr[1:]\n\t\t\tidx = strings.IndexByte(jsonStr, '\"')\n\t\t\tif idx == -1 {\n\t\t\t\terr = errors.New(\"invalid json str\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tvalue, jsonStr = jsonStr[:idx], jsonStr[idx+1:]\n\t\t} else {\n\t\t\tidx = strings.IndexByte(jsonStr, ',')\n\t\t\tif idx == -1 {\n\t\t\t\tvalue = strings.TrimSpace(jsonStr)\n\t\t\t} else {\n\t\t\t\tvalue, jsonStr = strings.TrimSpace(jsonStr[:idx]), jsonStr[idx+1:]\n\t\t\t}\n\t\t}\n\t\tmapInfo[key] = value\n\t\tjsonStr = strings.TrimSpace(jsonStr)\n\t\tif len(jsonStr) == 0 {\n\t\t\tbreak\n\t\t}\n\t\tif jsonStr[0] == ',' {\n\t\t\tjsonStr = jsonStr[1:]\n\t\t}\n\t}\n\treturn\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func _JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n# Natural Language Annotations: // JSONStr2Map transform json str to map[string]string, perf is better than use json lib directly\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCaller": {"response": ["```go\nfunc GetCaller(ctx context.Context) (string, bool) {\n    md, ok := metadata.FromIncomingContext(ctx)\n    if !ok {\n        return \"\", false\n    }\n\n    values := md.Get(\"x-service-name\")\n    if len(values) == 0 {\n        return \"\", false\n    }\n\n    return values[0], true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCaller(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCaller is used to get the Service Name of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetMethod": {"response": ["```go\nfunc GetMethod(ctx context.Context) (string, bool) {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\n\tmethods := md.Get(\":method\")\n\tif len(methods) == 0 {\n\t\treturn \"\", false\n\t}\n\n\treturn methods[0], true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetMethod(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetMethod is used to get the current RPC Method name.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerHandlerMethod": {"response": ["```go\nfunc GetCallerHandlerMethod(ctx context.Context) (string, bool) {\n\tif method, ok := ctx.Value(endpoint.CtxKeyMethod).(string); ok {\n\t\treturn method, true\n\t}\n\treturn \"\", false\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerHandlerMethod(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCallerHandlerMethod is used to get the method name of caller.\n// Only the caller is a Kitex server will have this method information by default, or you can set K_METHOD into context.Context then kitex will get it.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetIDLServiceName": {"response": ["```go\nfunc GetIDLServiceName(ctx context.Context) (string, bool) {\n    // Get the service name from the context\n    serviceName, ok := ctx.Value(\"serviceName\").(string)\n    if !ok {\n        // Return false if the service name is not found in the context\n        return \"\", false\n    }\n    \n    // Return the service name and true to indicate success\n    return serviceName, true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetIDLServiceName(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetIDLServiceName gets the serviceName which defined in IDL.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerAddr": {"response": ["```go\nfunc GetCallerAddr(ctx context.Context) (net.Addr, bool) {\n    p, ok := peer.FromContext(ctx)\n    if !ok {\n        return nil, false\n    }\n    return p.Addr, true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerAddr(ctx context.Context) (net.Addr, bool) {\n# Natural Language Annotations: // GetCallerAddr is used for the server to get the Address of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerIP": {"response": ["```go\nfunc GetCallerIP(ctx context.Context) (string, bool) {\n    // Extract the HTTP request from the context\n    req, ok := transport.HTTPRequestFromContext(ctx)\n    if !ok {\n        return \"\", false\n    }\n\n    // Get the X-Forwarded-For header\n    xForwardedFor := req.Header.Get(\"X-Forwarded-For\")\n    if xForwardedFor != \"\" {\n        // If X-Forwarded-For header is present, use the first IP in the list\n        ips := strings.Split(xForwardedFor, \",\")\n        if len(ips) > 0 {\n            return strings.TrimSpace(ips[0]), true\n        }\n    }\n\n    // If X-Forwarded-For header is not present, use the RemoteAddr\n    ip, _, err := net.SplitHostPort(req.RemoteAddr)\n    if err != nil {\n        return \"\", false\n    }\n\n    return ip, true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerIP(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCallerIP is used for the server to get the IP of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetTransportProtocol": {"response": ["```go\nfunc GetTransportProtocol(ctx context.Context) (string, bool) {\n\ttransport, ok := ctx.Value(\"transport\").(string)\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\treturn transport, true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetTransportProtocol(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetTransportProtocol gets the transport protocol of the request.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetRPCInfo": {"response": ["```go\nfunc GetRPCInfo(ctx context.Context) (rpcinfo.RPCInfo, bool) {\n\tinfo, ok := rpcinfo.FromContext(ctx)\n\tif !ok {\n\t\treturn rpcinfo.RPCInfo{}, false\n\t}\n\treturn info, true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetRPCInfo(ctx context.Context) (rpcinfo.RPCInfo, bool) {\n# Natural Language Annotations: // GetRPCInfo gets the RPCInfo in ctx.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans_errors.go-NewTransError": {"response": ["```go\nfunc NewTransError(typeID int32, err error) *TransError {\n    return &TransError{\n        TypeID: typeID,\n        RawErr: err,\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewTransError(typeID int32, err error) *TransError {\n# Natural Language Annotations: // NewTransError to build TransError with typeID and rawErr.\n// rawErr can be used by errors.Is(target) to check err type, like read timeout.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/gonet/bytebuffer.go-NewBufferReader": {"response": ["```go\nfunc NewBufferReader(ir io.Reader) remote.ByteBuffer {\n    if zcr, ok := ir.(netpoll.ZeroCopyReader); ok {\n        return remote.NewByteBuffer(zcr)\n    }\n    return remote.NewByteBufferWithSize(ir, 32*1024)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBufferReader(ir io.Reader) remote.ByteBuffer {\n# Natural Language Annotations: // NewBufferReader creates a new remote.ByteBuffer using the given netpoll.ZeroCopyReader.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/gonet/bytebuffer.go-WriteDirect": {"response": ["```go\nfunc (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n    if len(p) > remainCap {\n        return errors.New(\"insufficient capacity\")\n    }\n    \n    // Get the current buffer length\n    curLen := len(rw.buf)\n    \n    // Grow the buffer to accommodate the new data\n    rw.buf = rw.buf[:curLen+len(p)]\n    \n    // Copy the data to the end of the buffer\n    copy(rw.buf[curLen:], p)\n    \n    // Adjust the writer index\n    rw.w += len(p)\n    \n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n# Natural Language Annotations: // WriteDirect is a way to write []byte without copying, and splits the original buffer.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/server_handler.go-invokeStreamUnaryHandler": {"response": ["```go\nfunc invokeStreamUnaryHandler(ctx context.Context, st streaming.Stream, mi serviceinfo.MethodInfo) error {\n\t// Read the request message from the stream\n\treqMsg, err := st.RecvMsg()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Create a new context for the unary handler\n\tunaryCtx := ctx\n\n\t// Invoke the unary handler with the request message\n\trespMsg, err := mi.Handler(unaryCtx, reqMsg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Write the response message to the stream\n\terr = st.SendMsg(respMsg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Close the stream\n\treturn st.Close()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func invokeStreamUnaryHandler(ctx context.Context, st streaming.Stream, mi serviceinfo.MethodInfo,\n# Natural Language Annotations: // invokeStreamUnaryHandler allows unary APIs over HTTP2 to use the same server middleware as non-streaming APIs.\n// For thrift unary APIs over HTTP2, it's enabled by default.\n// For grpc(protobuf) unary APIs, it's disabled by default to keep backward compatibility.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/metadata/metadata.go-FromOutgoingContext": {"response": ["```go\nfunc FromOutgoingContext(ctx context.Context) (MD, bool) {\n\tmd, ok := ctx.Value(outgoingKey{}).(MD)\n\treturn md, ok\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromOutgoingContext(ctx context.Context) (MD, bool) {\n# Natural Language Annotations: // FromOutgoingContext returns the outgoing metadata in ctx if it exists.  The\n// returned MD should not be modified. Writing to it may cause races.\n// Modification should be made to copies of the returned MD.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/status/status.go-WithDetails": {"response": ["```go\nfunc (s *Status) WithDetails(details ...proto.Message) (*Status, error) {\n    if s.Code() == OK {\n        return nil, errors.New(\"no error details for status with code OK\")\n    }\n    // s.Details is a slice of proto.Message interfaces\n    // https://github.com/golang/protobuf/blob/master/proto/proto.go#L73\n    for _, detail := range details {\n        if err := proto.CheckInitialized(detail); err != nil {\n            return nil, err\n        }\n    }\n    newStatus := &Status{\n        Code:    s.Code(),\n        Message: s.Message(),\n        Details: append(s.Details, details...),\n    }\n    return newStatus, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Status) WithDetails(details ...proto.Message) (*Status, error) {\n# Natural Language Annotations: // WithDetails returns a new status with the provided details messages appended to the status.\n// If any errors are encountered, it returns nil and the first error encountered.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/status/status.go-FromError": {"response": ["```go\nfunc FromError(err error) (s *Status, ok bool) {\n    if err == nil {\n        return nil, true\n    }\n    if se, ok := err.(interface {\n        GRPCStatus() *Status\n    }); ok {\n        return se.GRPCStatus(), true\n    }\n    return New(codes.Unknown, err.Error()), false\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromError(err error) (s *Status, ok bool) {\n# Natural Language Annotations: // FromError returns a Status representing err if it was produced from this\n// package or has a method `GRPCStatus() *Status`. Otherwise, ok is false and a\n// Status is returned with codes.Unknown and the original error message.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/status/status.go-FromContextError": {"response": ["```go\nfunc FromContextError(err error) *Status {\n    if err == nil {\n        return &Status{Code: codes.OK, Message: \"\"}\n    }\n    if status, ok := status.FromError(err); ok {\n        return &Status{Code: status.Code(), Message: status.Message()}\n    }\n    return &Status{Code: codes.Unknown, Message: err.Error()}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromContextError(err error) *Status {\n# Natural Language Annotations: // FromContextError converts a context error into a Status.  It returns a\n// Status with codes.OK if err is nil, or a Status with codes.Unknown if err is\n// non-nil and not a context error.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/grpc/bdp_estimator.go-calculate": {"response": ["```go\nfunc (b *bdpEstimator) calculate(d [8]byte) {\n\t// Get the current time\n\tnow := time.Now()\n\n\t// Parse the ping timestamp from the ack packet\n\tpingTime := time.Unix(0, int64(binary.BigEndian.Uint64(d[:8])))\n\n\t// Calculate the RTT sample\n\trttSample := now.Sub(pingTime)\n\n\t// Update the minimum RTT if the current sample is smaller\n\tif rttSample < b.minRTT {\n\t\tb.minRTT = rttSample\n\t}\n\n\t// Calculate the current bandwidth sample\n\tbandwidthSample := float64(b.bytesReceived) / rttSample.Seconds()\n\n\t// Update the maximum bandwidth if the current sample is larger\n\tif bandwidthSample > b.maxBandwidth {\n\t\tb.maxBandwidth = bandwidthSample\n\t}\n\n\t// Calculate the current BDP estimate\n\tbdpEstimate := b.maxBandwidth * b.minRTT.Seconds()\n\n\t// Check if the flow control windows should be increased\n\tif bdpEstimate > float64(b.currentWindow) {\n\t\t// Increase the flow control windows by a factor\n\t\tb.currentWindow = uint32(bdpEstimate * b.windowGrowthFactor)\n\t}\n\n\t// Reset the bytes received counter\n\tb.bytesReceived = 0\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *bdpEstimator) calculate(d [8]byte) {\n# Natural Language Annotations: // calculate is called when an ack for a bdp ping is received.\n// Here we calculate the current bdp and bandwidth sample and\n// decide if the flow control windows should go up.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/grpc/http2_server.go-finishStream": {"response": ["```go\nfunc (t *http2Server) finishStream(s *Stream, rst bool, rstCode http2.ErrCode, hdr *headerFrame, eosReceived bool) {\n    if s.state == streamClosed {\n        return\n    }\n    if rst {\n        t.controlBuf.put(&resetStream{s.id, rstCode})\n    } else if !eosReceived {\n        if hdr != nil {\n            t.controlBuf.put(hdr)\n        }\n        t.controlBuf.put(&dataFrame{streamID: s.id, endStream: true})\n    }\n    t.closeStream(s)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *http2Server) finishStream(s *Stream, rst bool, rstCode http2.ErrCode, hdr *headerFrame, eosReceived bool) {\n# Natural Language Annotations: // finishStream closes the stream and puts the trailing headerFrame into controlbuf.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/grpc/http2_server.go-closeStream": {"response": ["```go\nfunc (t *http2Server) closeStream(s *Stream, rst bool, rstCode http2.ErrCode, eosReceived bool) {\n\tif s.state == streamClosed {\n\t\t// If the stream is already closed, do nothing.\n\t\treturn\n\t}\n\tif s.state == streamActive || s.state == streamWriteDone {\n\t\t// If the stream is active or write done, update the stream's state.\n\t\tif rst {\n\t\t\ts.state = streamReset\n\t\t} else {\n\t\t\ts.state = streamClosed\n\t\t}\n\t}\n\tif rst {\n\t\t// If the stream is being reset, send a RST_STREAM frame.\n\t\tt.controlBuf.put(&resetStream{s.id, rstCode})\n\t}\n\tif s.state == streamClosed && (!s.buf.empty() || !eosReceived) {\n\t\t// If the stream is closed and there are still bytes in the buffer\n\t\t// or the end of stream is not received, set the stream's state to streamDone.\n\t\ts.state = streamDone\n\t}\n\ts.cw.Close() // Close the stream's write buffer.\n\ts.flow.close()\n\tt.mu.Lock()\n\tdelete(t.activeStreams, s.id) // Remove the stream from the active streams map.\n\tt.mu.Unlock()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *http2Server) closeStream(s *Stream, rst bool, rstCode http2.ErrCode, eosReceived bool) {\n# Natural Language Annotations: // closeStream clears the footprint of a stream when the stream is not needed any more.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/grpc/transport.go-TLSConfig": {"response": ["```go\nfunc TLSConfig(tlsConfig *tls.Config) *tls.Config {\n\tif tlsConfig == nil {\n\t\ttlsConfig = &tls.Config{}\n\t}\n\ttlsConfig.MinVersion = tls.VersionTLS12\n\tif len(tlsConfig.CipherSuites) == 0 {\n\t\ttlsConfig.CipherSuites = []uint16{\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,\n\t\t\ttls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,\n\t\t\ttls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n\t\t}\n\t}\n\ttlsConfig.PreferServerCipherSuites = true\n\treturn tlsConfig\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TLSConfig(tlsConfig *tls.Config) *tls.Config {\n# Natural Language Annotations: // TLSConfig checks and supplement the tls config provided by user.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/nphttp2/grpc/http_util.go-encodeTimeout": {"response": ["```go\nfunc encodeTimeout(t time.Duration) string {\n\tif t <= 0 {\n\t\treturn \"0\"\n\t}\n\treturn fmt.Sprintf(\"%d\", int64(t/time.Millisecond))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func encodeTimeout(t time.Duration) string {\n# Natural Language Annotations: // TODO(zhaoq): It is the simplistic and not bandwidth efficient. Improve it.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/trans/netpoll/bytebuf.go-AppendBuffer": {"response": ["```go\nfunc (b *netpollByteBuffer) AppendBuffer(buf remote.ByteBuffer) (err error) {\n\tif buf == nil {\n\t\treturn nil\n\t}\n\n\tif b.Len()+buf.Len() > b.Cap() {\n\t\treturn errors.New(\"buffer overflow\")\n\t}\n\n\t_, err = buf.WriteTo(b)\n\treturn err\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *netpollByteBuffer) AppendBuffer(buf remote.ByteBuffer) (err error) {\n# Natural Language Annotations: // AppendBuffer appends buf to the original buffer.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/util.go-SetOrCheckMethodName": {"response": ["```go\nfunc SetOrCheckMethodName(methodName string, message remote.Message) error {\n\tif message.Invocation == nil {\n\t\tmessage.Invocation = &remote.Invocation{}\n\t}\n\tif message.Invocation.MethodName == \"\" {\n\t\tmessage.Invocation.MethodName = methodName\n\t\treturn nil\n\t}\n\tif message.Invocation.MethodName != methodName {\n\t\treturn fmt.Errorf(\"methodName: %s of invocation is not equal to the @rpc tag methodName: %s\", message.Invocation.MethodName, methodName)\n\t}\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func SetOrCheckMethodName(methodName string, message remote.Message) error {\n# Natural Language Annotations: // SetOrCheckMethodName is used to set method name to invocation.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/thrift/thrift_data.go-MarshalThriftData": {"response": ["```go\nfunc MarshalThriftData(ctx context.Context, codec remote.PayloadCodec, data interface{}) ([]byte, error) {\n\tvar buffer bytes.Buffer\n\terr := codec.EncodeData(ctx, &buffer, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn buffer.Bytes(), nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MarshalThriftData(ctx context.Context, codec remote.PayloadCodec, data interface{}) ([]byte, error) {\n# Natural Language Annotations: // MarshalThriftData only encodes the data (without the prepending methodName, msgType, seqId)\n// It will allocate a new buffer and encode to it\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/thrift/thrift_data.go-marshalBasicThriftData": {"response": ["```go\nfunc marshalBasicThriftData(ctx context.Context, tProt thrift.TProtocol, data interface{}) error {\n\tif msg, ok := data.(thrift.TStruct); ok {\n\t\tif err := msg.Write(tProt); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\tif err := tProt.WriteString(fmt.Sprintf(\"%v\", data)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn tProt.Flush(ctx)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func marshalBasicThriftData(ctx context.Context, tProt thrift.TProtocol, data interface{}) error {\n# Natural Language Annotations: // marshalBasicThriftData only encodes the data (without the prepending method, msgType, seqId)\n// It uses the old thrift way which is much slower than FastCodec and Frugal\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/thrift/thrift_data.go-UnmarshalThriftException": {"response": ["```go\nfunc UnmarshalThriftException(tProt thrift.TProtocol) error {\n\tname, _, seqId, err := tProt.ReadMessageBegin()\n\tif err != nil {\n\t\treturn err\n\t}\n\tif name != \"Exception\" {\n\t\treturn thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, \"expected Exception message\")\n\t}\n\tex := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, \"unknown exception\")\n\tif err = ex.Read(tProt); err != nil {\n\t\treturn err\n\t}\n\tif err = tProt.ReadMessageEnd(); err != nil {\n\t\treturn err\n\t}\n\tif seqId != tProt.GetSeqID() {\n\t\treturn thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, \"sequence ID mismatch\")\n\t}\n\treturn ex\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func UnmarshalThriftException(tProt thrift.TProtocol) error {\n# Natural Language Annotations: // UnmarshalThriftException decode thrift exception from tProt\n// If your input is []byte, you can wrap it with `NewBinaryProtocol(remote.NewReaderBuffer(buf))`\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/thrift/thrift_data.go-UnmarshalThriftData": {"response": ["```go\nfunc UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n    if len(buf) == 0 {\n        return nil\n    }\n\n    reader := codec.NewReader(buf)\n\n    // check if the buf contains an exception\n    msgType, err := reader.ReadMessageType()\n    if err != nil {\n        return err\n    }\n    if msgType == remote.MessageTypeException {\n        return UnmarshalThriftException(reader, data)\n    }\n\n    // skip methodName, msgType and seqId\n    if err := reader.Skip(remote.ThriftObjectTypeBinary); err != nil {\n        return err\n    }\n    if err := reader.Skip(remote.ThriftObjectTypeI32); err != nil {\n        return err\n    }\n    if err := reader.Skip(remote.ThriftObjectTypeI32); err != nil {\n        return err\n    }\n\n    // decode the data\n    return reader.ReadStruct(data)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n# Natural Language Annotations: // UnmarshalThriftData only decodes the data (after methodName, msgType and seqId)\n// It will decode from the given buffer.\n// Note:\n// 1. `method` is only used for generic calls\n// 2. if the buf contains an exception, you should call UnmarshalThriftException instead.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/thrift/thrift_data.go-unmarshalThriftData": {"response": ["Here is the function based on the given signature and annotations:\n\n```go\nfunc (c thriftCodec) unmarshalThriftData(ctx context.Context, tProt *BinaryProtocol, method string, data interface{}, dataLen int) error {\n    if dataLen < 0 {\n        return fmt.Errorf(\"negative data length: %d\", dataLen)\n    }\n    if _, err := tProt.ReadStructBegin(); err != nil {\n        return err\n    }\n    if err := tProt.Skip(STRUCT, dataLen); err != nil {\n        return err\n    }\n    if err := tProt.ReadStructEnd(); err != nil {\n        return err\n    }\n    return tProt.Decode(data)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c thriftCodec) unmarshalThriftData(ctx context.Context, tProt *BinaryProtocol, method string, data interface{}, dataLen int) error {\n# Natural Language Annotations: // unmarshalThriftData only decodes the data (after methodName, msgType and seqId)\n// method is only used for generic calls\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/codec/thrift/thrift_data.go-decodeBasicThriftData": {"response": ["```go\nfunc decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n    _, size, err := tProt.ReadMessageBegin()\n    if err != nil {\n        return err\n    }\n\n    if err := tProt.Skip(thrift.STRUCT, size); err != nil {\n        return err\n    }\n\n    if err := tProt.ReadMessageEnd(); err != nil {\n        return err\n    }\n\n    if err := tProt.ReadStructBegin(); err != nil {\n        return err\n    }\n\n    rv := reflect.ValueOf(data)\n    if rv.Kind() != reflect.Ptr || rv.IsNil() {\n        return fmt.Errorf(\"data must be a pointer\")\n    }\n\n    rv = rv.Elem()\n    if rv.Kind() != reflect.Struct {\n        return fmt.Errorf(\"data must be a struct\")\n    }\n\n    for {\n        _, fieldTypeID, fieldID, err := tProt.ReadFieldBegin()\n        if err != nil {\n            return err\n        }\n\n        if fieldTypeID == thrift.STOP {\n            break\n        }\n\n        fieldName := fmt.Sprintf(\"Field%d\", fieldID)\n        field := rv.FieldByName(fieldName)\n        if !field.IsValid() {\n            if err := tProt.Skip(fieldTypeID, 0); err != nil {\n                return err\n            }\n        } else {\n            if err := decodeThriftField(field, tProt, fieldTypeID); err != nil {\n                return err\n            }\n        }\n\n        if err := tProt.ReadFieldEnd(); err != nil {\n            return err\n        }\n    }\n\n    if err := tProt.ReadStructEnd(); err != nil {\n        return err\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n# Natural Language Annotations: // decodeBasicThriftData decode thrift body the old way (slow)\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/remotecli/conn_wrapper.go-GetConn": {"response": ["```go\nfunc (cm *ConnWrapper) GetConn(ctx context.Context, d remote.Dialer, ri rpcinfo.RPCInfo) (net.Conn, error) {\n\tconn, err := d.DialContext(ctx, ri.Network(), ri.Address())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn conn, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (cm *ConnWrapper) GetConn(ctx context.Context, d remote.Dialer, ri rpcinfo.RPCInfo) (net.Conn, error) {\n# Natural Language Annotations: // GetConn returns a connection using the given Dialer and RPCInfo.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/remote/connpool/long_pool.go-Evict": {"response": ["```go\nfunc (p *pool) Evict() (evicted int) {\n    p.mu.Lock()\n    defer p.mu.Unlock()\n\n    for i, conn := range p.conns {\n        if conn.expired(p.idleTimeout) {\n            p.remove(i)\n            evicted++\n        }\n    }\n\n    return evicted\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *pool) Evict() (evicted int) {\n# Natural Language Annotations: // Evict cleanups the expired connections.\n// Evict returns how many connections has been evicted.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/loadbalance/lbcache/cache.go-NewBalancerFactory": {"response": ["```go\nfunc NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n\tkey := fmt.Sprintf(\"%s-%s-%v\", resolver.Name(), balancer.Name(), opts)\n\tfactory, ok := factoryMap.Load(key)\n\tif ok {\n\t\treturn factory.(*BalancerFactory)\n\t}\n\n\tnewFactory := &BalancerFactory{\n\t\tresolver: resolver,\n\t\tbalancer: balancer,\n\t\topts:     opts,\n\t}\n\tactual, loaded := factoryMap.LoadOrStore(key, newFactory)\n\tif loaded {\n\t\treturn actual.(*BalancerFactory)\n\t}\n\treturn newFactory\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n# Natural Language Annotations: // NewBalancerFactory get or create a balancer factory for balancer instance\n// cache key with resolver name, balancer name and options\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/stats/event.go-DefineNewEvent": {"response": ["```go\nfunc DefineNewEvent(name string, level Level) (Event, error) {\n    if name == \"\" {\n        return Event{}, errors.New(\"event name cannot be empty\")\n    }\n    if level < LevelDebug || level > LevelFatal {\n        return Event{}, errors.New(\"invalid event level\")\n    }\n    return Event{Name: name, Level: level}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefineNewEvent(name string, level Level) (Event, error) {\n# Natural Language Annotations: // DefineNewEvent allows user to add event definitions during program initialization.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/thriftidl_provider.go-NewThriftFileProviderWithDynamicGo": {"response": ["```go\nfunc NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n    absPath, err := filepath.Abs(path)\n    if err != nil {\n        return nil, err\n    }\n    var includes []string\n    for _, includeDir := range includeDirs {\n        absIncludePath, err := filepath.Abs(includeDir)\n        if err != nil {\n            return nil, err\n        }\n        includes = append(includes, absIncludePath)\n    }\n    return &ThriftIDLProvider{\n        idlPath:     absPath,\n        includeDirs: includes,\n        mode:        WithDynamicGo,\n    }, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n# Natural Language Annotations: // NewThriftFileProviderWithDynamicGo create a ThriftIDLProvider with dynamicgo by given path and include dirs\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/thriftidl_provider.go-NewThriftContentWithAbsIncludePathProviderWithDynamicGo": {"response": ["```go\nfunc NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n\tmainContent, err := ioutil.ReadFile(mainIDLPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tincludeContents := make(map[string][]byte)\n\tfor incPath, incContent := range includes {\n\t\tincludeContents[incPath] = []byte(incContent)\n\t}\n\n\treturn &ThriftContentWithAbsIncludePathProvider{\n\t\tmainIDLPath:    mainIDLPath,\n\t\tmainContent:    mainContent,\n\t\tincludePathMap: includeContents,\n\t}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n# Natural Language Annotations: // NewThriftContentWithAbsIncludePathProviderWithDynamicGo create abs include path DescriptorProvider with dynamicgo\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/generic.go-MapThriftGeneric": {"response": ["```go\nfunc MapThriftGeneric(p DescriptorProvider) (Generic, error) {\n\tg := make(Generic)\n\terr := p.ForEachField(func(f FieldDescriptor) error {\n\t\tif f.Type() == TypeMap {\n\t\t\tkeyType := f.MapKey().Type()\n\t\t\tvalueType := f.MapValue().Type()\n\t\t\tm := make(map[interface{}]interface{})\n\t\t\terr := f.ForEachMap(func(key, value FieldDescriptor) error {\n\t\t\t\tkeyValue, err := mapThriftValue(key, keyType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tvalueValue, err := mapThriftValue(value, valueType)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tm[keyValue] = valueValue\n\t\t\t\treturn nil\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg[f.Name()] = m\n\t\t} else {\n\t\t\tv, err := mapThriftValue(f, f.Type())\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tg[f.Name()] = v\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn g, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MapThriftGeneric(p DescriptorProvider) (Generic, error) {\n# Natural Language Annotations: // MapThriftGeneric map mapping generic\n// Base64 codec for binary field is disabled by default. You can change this option with SetBinaryWithBase64.\n// eg:\n//\n//\tg, err := generic.MapThriftGeneric(p)\n//\tSetBinaryWithBase64(g, true)\n//\n// String value is returned for binary field by default. You can change the return value to []byte for binary field with SetBinaryWithByteSlice.\n// eg:\n//\n//\tSetBinaryWithByteSlice(g, true)\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/generic.go-JSONThriftGeneric": {"response": ["```go\nfunc JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n\tg := &jsonGeneric{\n\t\tProvider:        p,\n\t\tbinaryWithBase64: true,\n\t}\n\tfor _, opt := range opts {\n\t\topt(g)\n\t}\n\treturn g, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n# Natural Language Annotations: // JSONThriftGeneric json mapping generic.\n// Base64 codec for binary field is enabled by default. You can change this option with SetBinaryWithBase64.\n// eg:\n//\n//\tg, err := generic.JSONThriftGeneric(p)\n//\tSetBinaryWithBase64(g, false)\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/generic.go-JSONPbGeneric": {"response": ["```go\nfunc JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n    options := &Options{\n        DynamicGo: true,\n    }\n    for _, opt := range opts {\n        opt(options)\n    }\n\n    g := Generic{\n        DynamicGo: options.DynamicGo,\n    }\n\n    descriptorSet, err := p.GetDescriptorSet()\n    if err != nil {\n        return g, err\n    }\n\n    g.Files = make(map[string]FileGeneric)\n    for _, f := range descriptorSet.GetFile() {\n        fg, err := newFileGeneric(f, options)\n        if err != nil {\n            return g, err\n        }\n        g.Files[f.GetName()] = fg\n    }\n\n    return g, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n# Natural Language Annotations: // JSONPbGeneric json mapping generic.\n// Uses dynamicgo for json to protobufs conversion, so DynamicGo field is true by default.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/thrift/write.go-writeStruct": {"response": ["```go\nfunc writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n\tif err := out.WriteStructBegin(t.Name); err != nil {\n\t\treturn err\n\t}\n\n\tv := reflect.ValueOf(val)\n\tfor i := 0; i < v.NumField(); i++ {\n\t\tfield := t.Fields[i]\n\t\tif !field.Required && v.Field(i).IsZero() {\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := out.WriteFieldBegin(field.Name, field.Type, field.ID); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := write(ctx, v.Field(i).Interface(), out, field.TypeDescriptor, opt); err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tif err := out.WriteFieldEnd(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\tif err := out.WriteFieldStop(); err != nil {\n\t\treturn err\n\t}\n\n\treturn out.WriteStructEnd()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n# Natural Language Annotations: // writeStruct iter with Descriptor, can check the field's required and others\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/generic/descriptor/tree.go-addRoute": {"response": ["```go\nfunc (n *node) addRoute(path string, function *FunctionDescriptor) {\n\tif path == \"\" {\n\t\tn.function = function\n\t\treturn\n\t}\n\n\tparts := strings.Split(path, \"/\")\n\tif len(parts) == 1 {\n\t\tif n.children == nil {\n\t\t\tn.children = make(map[string]*node)\n\t\t}\n\t\tchild, ok := n.children[parts[0]]\n\t\tif !ok {\n\t\t\tchild = &node{}\n\t\t\tn.children[parts[0]] = child\n\t\t}\n\t\tchild.function = function\n\t\treturn\n\t}\n\n\tif n.children == nil {\n\t\tn.children = make(map[string]*node)\n\t}\n\tchild, ok := n.children[parts[0]]\n\tif !ok {\n\t\tchild = &node{}\n\t\tn.children[parts[0]] = child\n\t}\n\tchild.addRoute(strings.Join(parts[1:], \"/\"), function)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n *node) addRoute(path string, function *FunctionDescriptor) {\n# Natural Language Annotations: // addRoute adds a node with the given function to the path.\n// Not concurrency-safe!\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/mem/span.go-NewSpanCache": {"response": ["```go\nfunc NewSpanCache(spanSize int) *spanCache {\n    return &spanCache{\n        spanSize: spanSize,\n        spans:    make([]*span, 0),\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewSpanCache(spanSize int) *spanCache {\n# Natural Language Annotations: // NewSpanCache returns a spanCache with the given spanSize,\n// each span is used to allocate a binary of a specific size level.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/profiler/profiler.go-Pause": {"response": ["```go\nfunc (p *profiler) Pause() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\tif !p.paused {\n\t\tp.paused = true\n\t\tp.pauseTime = time.Now()\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *profiler) Pause() {\n# Natural Language Annotations: // Pause the profiler.\n// The profiler has been paused when Pause() return\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/profiler/profiler.go-Resume": {"response": ["```go\nfunc (p *profiler) Resume() {\n\tp.mu.Lock()\n\tdefer p.mu.Unlock()\n\t\n\tif !p.paused {\n\t\treturn\n\t}\n\t\n\tp.paused = false\n\tp.pauseStart = time.Time{}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *profiler) Resume() {\n# Natural Language Annotations: // Resume the profiler.\n// The profiler has been resumed when Resume() return\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-pkg/acl/acl.go-NewACLMiddleware": {"response": ["```go\nfunc NewACLMiddleware(rules []RejectFunc) endpoint.Middleware {\n\treturn func(next endpoint.Endpoint) endpoint.Endpoint {\n\t\treturn func(ctx context.Context, request interface{}) (response interface{}, err error) {\n\t\t\tfor _, rule := range rules {\n\t\t\t\tif err := rule(ctx, request); err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next(ctx, request)\n\t\t}\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewACLMiddleware(rules []RejectFunc) endpoint.Middleware {\n# Natural Language Annotations: // NewACLMiddleware creates a new ACL middleware using the provided reject funcs.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/context_middleware.go-WithContextMiddlewares": {"response": ["```go\nfunc WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n\tif len(mws) == 0 {\n\t\treturn ctx\n\t}\n\n\tmwsValue := make([]endpoint.Middleware, len(mws))\n\tcopy(mwsValue, mws)\n\n\tif ctxMws, ok := ctx.Value(contextMiddlewaresKey{}).([]endpoint.Middleware); ok {\n\t\tmwsValue = append(ctxMws, mwsValue...)\n\t}\n\n\treturn context.WithValue(ctx, contextMiddlewaresKey{}, mwsValue)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n# Natural Language Annotations: // WithContextMiddlewares add middlewares into current ctx\n// Every client receive this ctx will execute the middlewares.\n// Note that ContextMiddleware is prior to the ClientMiddleware.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/stream.go-RecvMsg": {"response": ["```go\nfunc (s *stream) RecvMsg(m interface{}) (err error) {\n    defer func() {\n        if err != nil {\n            s.DoFinish()\n        }\n    }()\n\n    err = s.codec.ReadBody(s.conn, m)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) RecvMsg(m interface{}) (err error) {\n# Natural Language Annotations: // RecvMsg receives a message from the server.\n// If an error is returned, stream.DoFinish() will be called to record the end of stream\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/stream.go-SendMsg": {"response": ["```go\nfunc (s *stream) SendMsg(m interface{}) (err error) {\n    defer func() {\n        if err != nil {\n            s.DoFinish()\n        }\n    }()\n\n    data, err := proto.Marshal(m.(proto.Message))\n    if err != nil {\n        return err\n    }\n\n    err = s.conn.WriteMessage(websocket.BinaryMessage, data)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) SendMsg(m interface{}) (err error) {\n# Natural Language Annotations: // SendMsg sends a message to the server.\n// If an error is returned, stream.DoFinish() will be called to record the end of stream\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/stream.go-DoFinish": {"response": ["```go\nfunc (s *stream) DoFinish(err error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tif s.finished {\n\t\treturn\n\t}\n\ts.finished = true\n\n\tif err != nil {\n\t\ts.err = err\n\t}\n\n\tclose(s.done)\n\ts.conn.Release()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) DoFinish(err error) {\n# Natural Language Annotations: // DoFinish implements the streaming.WithDoFinish interface, and it records the end of stream\n// It will release the connection.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/client.go-NewClient": {"response": ["```go\nfunc NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...Option) (Client, error) {\n\tvar options ClientOptions\n\tfor _, opt := range opts {\n\t\topt(&options)\n\t}\n\tvar mws []endpoint.Middleware\n\tmws = append(mws, options.Middlewares...)\n\tif options.Interceptor != nil {\n\t\tmws = append(mws, middleware.Chain(options.Interceptor))\n\t}\n\tep := endpoint.NewEndpoint(svcInfo, mws)\n\treturn &kClient{\n\t\tEndpoint:   ep,\n\t\tCodec:      options.Codec,\n\t\tSerializer: options.Serializer,\n\t\tResolver:   options.Resolver,\n\t\tRetry:      options.Retry,\n\t\tLimiter:    options.Limiter,\n\t\tTimeouts:   options.Timeouts,\n\t\tLogger:     options.Logger,\n\t}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...Option) (Client, error) {\n# Natural Language Annotations: // NewClient creates a kitex.Client with the given ServiceInfo, it is from generated code.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/middlewares.go-newResolveMWBuilder": {"response": ["```go\nfunc newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.MiddlewareBuilder {\n    return func(next endpoint.Endpoint) endpoint.Endpoint {\n        return func(ctx context.Context, request interface{}) (response interface{}, err error) {\n            var (\n                lb     *lbcache.Balancer\n                target *resolver.Target\n            )\n\n            if target, err = resolver.ExtractTarget(ctx); err != nil {\n                return nil, err\n            }\n\n            if lb, err = lbf.Get(ctx, target); err != nil {\n                return nil, err\n            }\n\n            retryTimeout := lb.RetryTimeout()\n            retryCtx, cancel := context.WithTimeout(ctx, retryTimeout)\n            defer cancel()\n\n            for {\n                endpoint, err := lb.Endpoint(retryCtx)\n                if err != nil {\n                    if errors.Is(err, resolver.ErrNoEndpoints) {\n                        return nil, err\n                    }\n                    if retryCtx.Err() != nil {\n                        return nil, retryCtx.Err()\n                    }\n                    continue\n                }\n\n                response, err = endpoint(retryCtx, request)\n                if err == nil {\n                    return response, nil\n                }\n\n                if !lb.IsRetryable(err) {\n                    return nil, err\n                }\n\n                if retryCtx.Err() != nil {\n                    return nil, retryCtx.Err()\n                }\n            }\n        }\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.MiddlewareBuilder {\n# Natural Language Annotations: // newResolveMWBuilder creates a middleware for service discovery.\n// This middleware selects an appropriate instance based on the resolver and loadbalancer given.\n// If retryable error is encountered, it will retry until timeout or an unretryable error is returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/middlewares.go-DefaultClientErrorHandler": {"response": ["```go\nfunc DefaultClientErrorHandler(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif errors.Is(err, context.Canceled) {\n\t\treturn err\n\t}\n\tif errors.Is(err, context.DeadlineExceeded) {\n\t\treturn err\n\t}\n\n\t// client timeout\n\tif errors.Is(err, syscall.EAGAIN) {\n\t\treturn errors.WithStack(err)\n\t}\n\n\t// server timeout\n\tif errors.Is(err, syscall.ETIMEDOUT) {\n\t\treturn errors.WithStack(err)\n\t}\n\n\tif _, ok := err.(interface{ GRPCStatus() *status.Status }); ok {\n\t\treturn err\n\t}\n\n\t// Thrift >= 0.4.0 wrap protocol error to TransError\n\tif e := new(errs.TransError); errors.As(err, &e) {\n\t\treturn e\n\t}\n\n\treturn errors.WithStack(err)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefaultClientErrorHandler(ctx context.Context, err error) error {\n# Natural Language Annotations: // DefaultClientErrorHandler is Default ErrorHandler for client\n// when no ErrorHandler is specified with Option `client.WithErrorHandler`, this ErrorHandler will be injected.\n// for thrift\u3001KitexProtobuf, >= v0.4.0 wrap protocol error to TransError, which will be more friendly.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/middlewares.go-ClientErrorHandlerWithAddr": {"response": ["```go\nfunc ClientErrorHandlerWithAddr(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\tremoteAddr := \"unknown\"\n\tif addr := ctx.Value(\"remote_addr\"); addr != nil {\n\t\tif s, ok := addr.(string); ok {\n\t\t\tremoteAddr = s\n\t\t}\n\t}\n\n\treturn fmt.Errorf(\"%s, remote addr: %s\", err.Error(), remoteAddr)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ClientErrorHandlerWithAddr(ctx context.Context, err error) error {\n# Natural Language Annotations: // ClientErrorHandlerWithAddr is ErrorHandler for client, which will add remote addr info into error\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithInstanceMW": {"response": ["```go\nfunc WithInstanceMW(mw endpoint.Middleware) Option {\n\treturn func(o *options) {\n\t\to.instanceMW = append(o.instanceMW, mw)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithInstanceMW(mw endpoint.Middleware) Option {\n# Natural Language Annotations: // WithInstanceMW adds middleware for client to handle request after service discovery and loadbalance process.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithHostPorts": {"response": ["```go\nfunc WithHostPorts(hostports ...string) Option {\n\treturn func(o *options) {\n\t\to.hostPorts = hostports\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithHostPorts(hostports ...string) Option {\n# Natural Language Annotations: // WithHostPorts specifies the target instance addresses when doing service discovery.\n// It overwrites the results from the Resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithShortConnection": {"response": ["```go\nfunc WithShortConnection() Option {\n\treturn option.NewFuncOption(func(o *remote.ClientOption) {\n\t\to.ShortConnection = true\n\t})\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithShortConnection() Option {\n# Natural Language Annotations: // WithShortConnection forces kitex to close connection after each call is finished.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithLongConnection": {"response": ["```go\nfunc WithLongConnection(cfg connpool.IdleConfig) Option {\n\treturn func(o *options) {\n\t\to.connPool = connpool.NewLongConnPool(cfg)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithLongConnection(cfg connpool.IdleConfig) Option {\n# Natural Language Annotations: // WithLongConnection enables long connection with kitex's built-in pooling implementation.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithMuxConnection": {"response": ["```\nfunc WithMuxConnection(connNum int) Option {\n\treturn func(o *options) {\n\t\to.muxConnection = true\n\t\to.connNum = connNum\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMuxConnection(connNum int) Option {\n# Natural Language Annotations: // WithMuxConnection specifies the transport type to be mux.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithTimeoutProvider": {"response": ["```go\nfunc WithTimeoutProvider(p rpcinfo.TimeoutProvider) Option {\n    return func(o *options) {\n        o.timeoutProvider = p\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithTimeoutProvider(p rpcinfo.TimeoutProvider) Option {\n# Natural Language Annotations: // WithTimeoutProvider adds a TimeoutProvider to the client.\n// Note that the timeout settings provided by the TimeoutProvider\n// will be applied before the other timeout options in this package\n// and those in the callopt package. Thus it can not modify the\n// timeouts set by WithRPCTimeout or WithConnectTimeout.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithCodec": {"response": ["```go\n// WithCodec to set a codec that handle other protocols which not support by kitex\nfunc WithCodec(c remote.Codec) Option {\n\treturn func(o *remote.ClientOption) {\n\t\to.Codec = c\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithCodec(c remote.Codec) Option {\n# Natural Language Annotations: // WithCodec to set a codec that handle other protocols which not support by kitex\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithPayloadCodec": {"response": ["```go\nfunc WithPayloadCodec(c remote.PayloadCodec) Option {\n\treturn func(o *remote.ClientOption) {\n\t\to.PayloadCodec = c\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithPayloadCodec(c remote.PayloadCodec) Option {\n# Natural Language Annotations: // WithPayloadCodec to set a payloadCodec that handle other payload which not support by kitex\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithConnReporterEnabled": {"response": ["```go\nfunc WithConnReporterEnabled() Option {\n    return func(c *config) {\n        c.enableConnReporter = true\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithConnReporterEnabled() Option {\n# Natural Language Annotations: // WithConnReporterEnabled to enable reporting connection pool stats.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithFailureRetry": {"response": ["```go\nfunc WithFailureRetry(p *retry.FailurePolicy) Option {\n\treturn func(o *options) {\n\t\to.failureRetry = p\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithFailureRetry(p *retry.FailurePolicy) Option {\n# Natural Language Annotations: // WithFailureRetry sets the failure retry policy for client, it will take effect for all methods.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithBackupRequest": {"response": ["```go\nfunc WithBackupRequest(p *retry.BackupPolicy) Option {\n\treturn func(c *Client) {\n\t\tc.backupRequestPolicy = p\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithBackupRequest(p *retry.BackupPolicy) Option {\n# Natural Language Annotations: // WithBackupRequest sets the backup request policy for client, it will take effect for all methods.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithSpecifiedResultRetry": {"response": ["```go\nfunc WithSpecifiedResultRetry(rr *retry.ShouldResultRetry) Option {\n\treturn func(o *options) {\n\t\to.shouldResultRetry = rr\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithSpecifiedResultRetry(rr *retry.ShouldResultRetry) Option {\n# Natural Language Annotations: // WithSpecifiedResultRetry is used with FailureRetry.\n// When you enable FailureRetry and want to retry with the specified error or response, you can configure this Option.\n// ShouldResultRetry is defined inside retry.FailurePolicy, so WithFailureRetry also can set ShouldResultRetry.\n// But if your retry policy is enabled by remote config, WithSpecifiedResultRetry is useful.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithGRPCInitialConnWindowSize": {"response": ["```go\nfunc WithGRPCInitialConnWindowSize(s uint32) Option {\n\treturn func(o *options) error {\n\t\to.grpcDialOptions = append(o.grpcDialOptions, grpc.WithInitialConnWindowSize(int32(s)))\n\t\treturn nil\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialConnWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialConnWindowSize sets the value for initial window size on a connection of grpc.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the WithInitialConnWindowSize DialOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithGRPCMaxHeaderListSize": {"response": ["```go\nfunc WithGRPCMaxHeaderListSize(s uint32) Option {\n\treturn newFuncOption(func(o *dialOptions) {\n\t\to.grpcDialOptions = append(o.grpcDialOptions, grpc.WithMaxHeaderListSize(s))\n\t})\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxHeaderListSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxHeaderListSize returns a DialOption that specifies the maximum\n// (uncompressed) size of header list that the client is prepared to accept.\n// It corresponds to the WithMaxHeaderListSize DialOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithGRPCKeepaliveParams": {"response": ["```go\nfunc WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) Option {\n\treturn func(o *options) {\n\t\to.grpcDialOptions = append(o.grpcDialOptions, grpc.WithKeepaliveParams(kp))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveParams returns a DialOption that specifies keepalive parameters for the client transport.\n// It corresponds to the WithKeepaliveParams DialOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/option.go-WithWarmingUp": {"response": ["```go\nfunc WithWarmingUp(wuo *warmup.ClientOption) Option {\n\treturn func(o *options) {\n\t\to.warmupOption = wuo\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithWarmingUp(wuo *warmup.ClientOption) Option {\n# Natural Language Annotations: // WithWarmingUp forces the client to do some warm-ups at the end of the initialization.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/callopt/options.go-WithHostPort": {"response": ["```go\nfunc WithHostPort(hostport string) Option {\n\treturn func(o *options) {\n\t\to.hostPort = hostport\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithHostPort(hostport string) Option {\n# Natural Language Annotations: // WithHostPort specifies the target address for a RPC call.\n// The given address will overwrite the result from Resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/callopt/options.go-WithURL": {"response": ["```go\nfunc WithURL(url string) Option {\n    return func(o *options) {\n        o.url = url\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithURL(url string) Option {\n# Natural Language Annotations: // WithURL specifies the target for a RPC call with url.\n// The given url will be resolved to hostport and overwrites the result from Resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/callopt/options.go-WithRPCTimeout": {"response": ["```go\nfunc WithRPCTimeout(d time.Duration) Option {\n\treturn func(o *options) {\n\t\to.rpcTimeout = d\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithRPCTimeout(d time.Duration) Option {\n# Natural Language Annotations: // WithRPCTimeout specifies the RPC timeout for a RPC call.\n// FIXME: callopt.WithRPCTimeout works only when client.WithRPCTimeout or\n// client.WithTimeoutProvider is specified.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/callopt/options.go-WithConnectTimeout": {"response": ["```\nfunc WithConnectTimeout(d time.Duration) Option {\n    return func(o *options) {\n        o.connectTimeout = d\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithConnectTimeout(d time.Duration) Option {\n# Natural Language Annotations: // WithConnectTimeout specifies the connection timeout for a RPC call.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-client/callopt/options.go-WithFallback": {"response": ["```go\nfunc WithFallback(fb *fallback.Policy) Option {\n\treturn func(o *options) {\n\t\to.fallback = fb\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithFallback(fb *fallback.Policy) Option {\n# Natural Language Annotations: // WithFallback is used to set the fallback policy for a RPC call.\n// Demos are provided below:\n//\n//\tdemo1. call with fallback for error\n//\t\t`resp, err := cli.Mock(ctx, req, callopt.WithFallback(fallback.ErrorFallback(yourFBFunc))`\n//\tdemo2. call with fallback for error and enable reportAsFallback, which sets reportAsFallback to be true and will do report(metric) as Fallback result\n//\t\t`resp, err := cli.Mock(ctx, req, callopt.WithFallback(fallback.ErrorFallback(yourFBFunc).EnableReportAsFallback())`\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option_advanced.go-WithServerBasicInfo": {"response": ["```go\nfunc WithServerBasicInfo(ebi *rpcinfo.EndpointBasicInfo) Option {\n\treturn func(o *options) {\n\t\to.serverBasicInfo = ebi\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithServerBasicInfo(ebi *rpcinfo.EndpointBasicInfo) Option {\n# Natural Language Annotations: // WithServerBasicInfo provides initial information for client endpoint in RPCInfo.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option_advanced.go-WithSupportedTransportsFunc": {"response": ["```go\nfunc WithSupportedTransportsFunc(f func(option remote.ServerOption) []string) Option {\n\treturn func(o *options) {\n\t\to.supportedTransportsFunc = f\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithSupportedTransportsFunc(f func(option remote.ServerOption) []string) Option {\n# Natural Language Annotations: // WithSupportedTransportsFunc sets a function which converts supported transports from server option.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithMiddleware": {"response": ["```go\nfunc WithMiddleware(mw endpoint.Middleware) Option {\n\treturn func(s *Server) {\n\t\ts.middleware = append(s.middleware, mw)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMiddleware(mw endpoint.Middleware) Option {\n# Natural Language Annotations: // WithMiddleware adds middleware for server to handle request.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithMiddlewareBuilder": {"response": ["```go\nfunc WithMiddlewareBuilder(mwb endpoint.MiddlewareBuilder, funcName ...string) Option {\n\treturn func(o *options) {\n\t\to.middlewareBuilders = append(o.middlewareBuilders, mwb)\n\t\to.middlewareBuilderNames = append(o.middlewareBuilderNames, funcName...)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMiddlewareBuilder(mwb endpoint.MiddlewareBuilder, funcName ...string) Option {\n# Natural Language Annotations: // WithMiddlewareBuilder adds middleware that depend on context for server to handle request\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithExitWaitTime": {"response": ["```go\nfunc WithExitWaitTime(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.exitWaitTime = timeout\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithExitWaitTime(timeout time.Duration) Option {\n# Natural Language Annotations: // WithExitWaitTime sets the wait duration for graceful shutdown.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithMaxConnIdleTime": {"response": ["```go\nfunc WithMaxConnIdleTime(timeout time.Duration) Option {\n    return func(s *Server) {\n        s.maxConnIdleTime = timeout\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMaxConnIdleTime(timeout time.Duration) Option {\n# Natural Language Annotations: // WithMaxConnIdleTime sets the max idle time on connection from clients.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithPayloadCodec": {"response": ["```go\nfunc WithPayloadCodec(c remote.PayloadCodec) Option {\n\treturn func(o *remote.ClientOption) {\n\t\to.PayloadCodec = c\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithPayloadCodec(c remote.PayloadCodec) Option {\n# Natural Language Annotations: // WithPayloadCodec to set a payloadCodec that handle other payload which not support by kitex\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithGRPCInitialWindowSize": {"response": ["```go\nfunc WithGRPCInitialWindowSize(s uint32) Option {\n\treturn func(o *options) {\n\t\to.grpcOpts = append(o.grpcOpts, grpc.InitialWindowSize(int32(s)))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialWindowSize returns a Option that sets window size for stream.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the InitialWindowSize ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithGRPCInitialConnWindowSize": {"response": ["```\nfunc WithGRPCInitialConnWindowSize(s uint32) Option {\n\treturn func(o *options) {\n\t\to.grpcOpts = append(o.grpcOpts, grpc.InitialConnWindowSize(int32(s)))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialConnWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialConnWindowSize returns an Option that sets window size for a connection.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the InitialConnWindowSize ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithGRPCKeepaliveParams": {"response": ["```go\nfunc WithGRPCKeepaliveParams(kp grpc.ServerKeepalive) Option {\n\treturn func(s *Server) {\n\t\ts.grpcServerOptions = append(s.grpcServerOptions, grpc.KeepaliveParams(kp))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveParams(kp grpc.ServerKeepalive) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveParams returns an Option that sets keepalive and max-age parameters for the server.\n// It corresponds to the KeepaliveParams ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithGRPCKeepaliveEnforcementPolicy": {"response": ["```go\nfunc WithGRPCKeepaliveEnforcementPolicy(kep grpc.EnforcementPolicy) Option {\n\treturn func(s *Server) {\n\t\ts.grpcServerOptions = append(s.grpcServerOptions, grpc.KeepaliveEnforcementPolicy(kep))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveEnforcementPolicy(kep grpc.EnforcementPolicy) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveEnforcementPolicy returns an Option that sets keepalive enforcement policy for the server.\n// It corresponds to the KeepaliveEnforcementPolicy ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithGRPCMaxConcurrentStreams": {"response": ["```\nfunc WithGRPCMaxConcurrentStreams(n uint32) Option {\n\treturn func(o *options) {\n\t\to.grpcOptions = append(o.grpcOptions, grpc.MaxConcurrentStreams(n))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxConcurrentStreams(n uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxConcurrentStreams returns an Option that will apply a limit on the number\n// of concurrent streams to each ServerTransport.\n// It corresponds to the MaxConcurrentStreams ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/option.go-WithGRPCMaxHeaderListSize": {"response": ["```go\nfunc WithGRPCMaxHeaderListSize(s uint32) Option {\n\treturn func(o *options) {\n\t\tif o.grpcServerOptions == nil {\n\t\t\to.grpcServerOptions = []grpc.ServerOption{}\n\t\t}\n\t\to.grpcServerOptions = append(o.grpcServerOptions, grpc.MaxHeaderListSize(s))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxHeaderListSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxHeaderListSize returns a ServerOption that sets the max (uncompressed) size\n// of header list that the server is prepared to accept.\n// It corresponds to the MaxHeaderListSize ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "kitex-server/genericserver/server.go-NewServerWithServiceInfo": {"response": ["```go\nfunc NewServerWithServiceInfo(handler generic.Service, g generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n\tvar options server.Options\n\tfor _, o := range opts {\n\t\to(&options)\n\t}\n\n\ts := &genericServer{\n\t\topts:    options,\n\t\thandler: handler,\n\t\tg:       g,\n\t\tsvcInfo: svcInfo,\n\t}\n\ts.baseCtx = context.Background()\n\n\treturn s\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewServerWithServiceInfo(handler generic.Service, g generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n# Natural Language Annotations: // NewServerWithServiceInfo creates a generic server with the given handler, serviceInfo and options.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-validate.go-validateRegistrations": {"response": ["```go\nfunc validateRegistrations(regs []*codegen.Registration) error {\n\t// Check that registration names are unique.\n\tnames := map[string]bool{}\n\tfor _, reg := range regs {\n\t\tif names[reg.Name] {\n\t\t\treturn fmt.Errorf(\"multiple registrations for %q\", reg.Name)\n\t\t}\n\t\tnames[reg.Name] = true\n\t}\n\n\tfor _, reg := range regs {\n\t\tif reg.Name == \"\" {\n\t\t\treturn fmt.Errorf(\"registration missing name\")\n\t\t}\n\t\tif err := validateRegistration(reg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc validateRegistration(reg *codegen.Registration) error {\n\tfor _, param := range reg.Params {\n\t\tif param.Key == \"\" {\n\t\t\treturn fmt.Errorf(\"registration %q: empty param key\", reg.Name)\n\t\t}\n\t\tif param.Value == nil {\n\t\t\treturn fmt.Errorf(\"registration %q: nil param value\", reg.Name)\n\t\t}\n\t}\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func validateRegistrations(regs []*codegen.Registration) error {\n# Natural Language Annotations: // validateRegistrations validates the provided registrations, returning an\n// diagnostic error if they are invalid. Note that some validation is performed\n// by 'weaver generate', but because users can run a Service Weaver app after\n// forgetting to run 'weaver generate', some checks have to be done at runtime.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-sim/generators.go-Range": {"response": ["```go\nfunc Range(low, high int) Generator[int] {\n    if low >= high {\n        panic(\"Range: low must be less than high\")\n    }\n    return func() int {\n        return low + rand.Intn(high-low)\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Range(low, high int) Generator[int] {\n# Natural Language Annotations: // Range returns a [Generator] that returns integers equiprobably in the range\n// [low, high). Range panics if low >= high.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-sim/generators.go-String": {"response": ["```go\nfunc String() Generator[string] {\n\treturn func(r *rand.Rand) string {\n\t\tn := r.Intn(50)\n\t\tif n == 0 {\n\t\t\treturn \"\"\n\t\t}\n\t\trunes := make([]rune, n)\n\t\tfor i := 0; i < n; i++ {\n\t\t\trunes[i] = rune(r.Intn(0x10ffff))\n\t\t}\n\t\treturn string(runes)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func String() Generator[string] {\n# Natural Language Annotations: // Strings\n// String returns a [Generator] that returns moderately sized readable strings,\n// with a bias towards smaller strings.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-sim/generators.go-OneOf": {"response": ["```go\nfunc OneOf[T any](xs ...T) Generator[T] {\n    if len(xs) == 0 {\n        panic(\"OneOf requires at least one value\")\n    }\n    return func(r *rand.Rand) T {\n        return xs[r.Intn(len(xs))]\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OneOf[T any](xs ...T) Generator[T] {\n# Natural Language Annotations: // Combinators\n// OneOf returns a [Generator] that returns one of the provided values\n// equiprobably. OneOf panics if no values are provided.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-sim/generators.go-Weight": {"response": ["```go\nfunc Weight[T any](choices []Weighted[T]) Generator[T] {\n    if len(choices) == 0 {\n        panic(\"Weight: no choices provided\")\n    }\n\n    var totalWeight float64\n    for _, choice := range choices {\n        if choice.Weight < 0 {\n            panic(\"Weight: negative weight\")\n        }\n        totalWeight += choice.Weight\n    }\n\n    if totalWeight == 0 {\n        panic(\"Weight: total weight is 0\")\n    }\n\n    return func(r *rand.Rand) T {\n        p := r.Float64() * totalWeight\n        for _, choice := range choices {\n            if p < choice.Weight {\n                return choice.Gen(r)\n            }\n            p -= choice.Weight\n        }\n        panic(\"Weight: should not reach here\")\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Weight[T any](choices []Weighted[T]) Generator[T] {\n# Natural Language Annotations: // Weight returns a [Generator] that generates values using the provided\n// generators. A generator is chosen with probability proportional to its\n// weight. For example, given the following choices:\n//\n//   - Weighted{1.0, OneOf(\"a\")}\n//   - Weighted{2.0, OneOf(\"b\")}\n//\n// Weight returns \"b\" twice as often as it returns \"a\". Note that the provided\n// weights do not have to sum to 1.\n//\n// Weight panics if no choices are provided, if any weight is negative, or if\n// the sum of all weight is 0.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-sim/rand.go-pick": {"response": ["```go\nfunc pick[T any](r *rand.Rand, xs []T) T {\n    if len(xs) == 0 {\n        panic(\"pick: empty slice\")\n    }\n    return xs[r.Intn(len(xs))]\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func pick[T any](r *rand.Rand, xs []T) T {\n# Natural Language Annotations: // pick returns a randomly selected element from the provided slice. pick\n// panics if the provided slice is empty.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-sim/rand.go-remove": {"response": ["```go\nfunc (i *ints) remove(x int) {\n\tfor idx, val := range *i {\n\t\tif val == x {\n\t\t\t*i = append((*i)[:idx], (*i)[idx+1:]...)\n\t\t\treturn\n\t\t}\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (i *ints) remove(x int) {\n# Natural Language Annotations: // remove removes the provided element from the set. remove is a noop if the\n// provided element is not in the set.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/config.go-ParseConfig": {"response": ["```go\nfunc ParseConfig(file string, input string, sectionValidator func(string, string) error) (*protos.AppConfig, error) {\n\tvar sections map[string]interface{}\n\tif _, err := toml.Decode(input, &sections); err != nil {\n\t\treturn nil, fmt.Errorf(\"parse config %q: %w\", file, err)\n\t}\n\tappSection, ok := sections[appSectionName]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"config %q missing %q section\", file, appSectionName)\n\t}\n\tappSectionMap, ok := appSection.(map[string]interface{})\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"config %q has invalid %q section (table expected)\", file, appSectionName)\n\t}\n\tfor key, val := range appSectionMap {\n\t\tvalStr, ok := val.(string)\n\t\tif !ok {\n\t\t\treturn nil, fmt.Errorf(\"config %q has invalid %q value for key %q (string expected)\", file, appSectionName, key)\n\t\t}\n\t\tif err := sectionValidator(key, valStr); err != nil {\n\t\t\treturn nil, fmt.Errorf(\"config %q: %w\", file, err)\n\t\t}\n\t}\n\tvar appConfig protos.AppConfig\n\tif err := mapstructure.Decode(appSectionMap, &appConfig); err != nil {\n\t\treturn nil, fmt.Errorf(\"decode app config %q: %w\", file, err)\n\t}\n\treturn &appConfig, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseConfig(file string, input string, sectionValidator func(string, string) error) (*protos.AppConfig, error) {\n# Natural Language Annotations: // ParseConfig parses the specified configuration input, which should\n// hold a set of sections in TOML format from the specified file.\n// The section corresponding to the common Service Weaver application\n// configuration is parsed and returned as a *AppConfig.\n//\n// sectionValidator(key, val) is used to validate every section config entry.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/traces/db.go-OpenDB": {"response": ["```go\nfunc OpenDB(ctx context.Context, fname string) (*DB, error) {\n    db, err := bolt.Open(fname, 0600, &bolt.Options{Timeout: 1 * time.Second})\n    if err != nil {\n        return nil, err\n    }\n\n    err = db.Update(func(tx *bolt.Tx) error {\n        _, err := tx.CreateBucketIfNotExists([]byte(\"traces\"))\n        if err != nil {\n            return fmt.Errorf(\"create bucket: %s\", err)\n        }\n        return nil\n    })\n    if err != nil {\n        db.Close()\n        return nil, err\n    }\n\n    return &DB{db: db}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OpenDB(ctx context.Context, fname string) (*DB, error) {\n# Natural Language Annotations: // OpenDB opens the trace database persisted in the provided file. If the\n// file doesn't exist, this call creates it.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/traces/db.go-QueryTraces": {"response": ["```go\nfunc (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n\tquery := `\n\t\tSELECT trace_id, start_time, end_time, duration, error\n\t\tFROM traces\n\t\tWHERE 1=1\n\t`\n\targs := []interface{}{}\n\n\tif app != \"\" {\n\t\tquery += \" AND app = ?\"\n\t\targs = append(args, app)\n\t}\n\tif version != \"\" {\n\t\tquery += \" AND version = ?\"\n\t\targs = append(args, version)\n\t}\n\tif !startTime.IsZero() {\n\t\tquery += \" AND start_time >= ?\"\n\t\targs = append(args, startTime)\n\t}\n\tif !endTime.IsZero() {\n\t\tquery += \" AND end_time <= ?\"\n\t\targs = append(args, endTime)\n\t}\n\tif durationLower > 0 {\n\t\tquery += \" AND duration >= ?\"\n\t\targs = append(args, durationLower)\n\t}\n\tif durationUpper > 0 {\n\t\tquery += \" AND duration < ?\"\n\t\targs = append(args, durationUpper)\n\t}\n\tif onlyErrors {\n\t\tquery += \" AND error = true\"\n\t}\n\n\tquery += \" ORDER BY start_time DESC\"\n\tif limit > 0 {\n\t\tquery += \" LIMIT ?\"\n\t\targs = append(args, limit)\n\t}\n\n\trows, err := d.QueryContext(ctx, query, args...)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer rows.Close()\n\n\tvar traces []TraceSummary\n\tfor rows.Next() {\n\t\tvar trace TraceSummary\n\t\tif err := rows.Scan(&trace.TraceID, &trace.StartTime, &trace.EndTime, &trace.Duration, &trace.Error); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\ttraces = append(traces, trace)\n\t}\n\n\treturn traces, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n# Natural Language Annotations: // QueryTraces returns the summaries of the traces that match the given\n// query arguments, namely:\n//   - That have been generated by the given application version.\n//   - That fit entirely in the given [startTime, endTime] time interval.\n//   - Whose duration is in the given [durationLower, durationUpper) range.\n//   - Who have an error status.\n//   - Who are in the most recent limit of trace spans.\n//\n// Any query argument that has a zero value (e.g., empty app or version,\n// zero endTime) is ignored, i.e., it matches all spans.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/retry/retry.go-Continue": {"response": ["```go\nfunc (r *Retry) Continue(ctx context.Context) bool {\n\tif r.n == 0 {\n\t\tr.n++\n\t\treturn true\n\t}\n\n\td := time.Duration(rand.Int63n(r.interval)) + r.interval/2\n\tr.interval = time.Duration(float64(r.interval) * r.factor)\n\tif r.interval > r.maxInterval {\n\t\tr.interval = r.maxInterval\n\t}\n\n\tt := time.NewTimer(d)\n\tselect {\n\tcase <-t.C:\n\t\tr.n++\n\t\treturn true\n\tcase <-ctx.Done():\n\t\tt.Stop()\n\t\treturn false\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r *Retry) Continue(ctx context.Context) bool {\n# Natural Language Annotations: // Continue sleeps for an exponentially increasing interval (with jitter). It\n// stops its sleep early and returns false if context becomes done. If the\n// return value is false, ctx.Err() is guaranteed to be non-nil. The first\n// call does not sleep.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/colors/tabularizer.go-Row": {"response": ["```go\nfunc (t *Tabularizer) Row(values ...any) {\n\tif len(values) != t.cols {\n\t\tpanic(fmt.Sprintf(\"tabularizer: row length %d does not match column count %d\", len(values), t.cols))\n\t}\n\trow := make([]string, len(values))\n\tfor i, v := range values {\n\t\trow[i] = stringify(v)\n\t}\n\tt.rows = append(t.rows, row)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *Tabularizer) Row(values ...any) {\n# Natural Language Annotations: // Row buffers a new Row to be tabularized. The Row isn't written until Flush\n// is called. Note that every Row reported to a tabularizer must be the same\n// length. A value can be a text, atom, string, or fmt.Stringer.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/colors/tabularizer.go-Flush": {"response": ["```go\nfunc (t *Tabularizer) Flush() {\n    if t.flushed {\n        return\n    }\n    t.flushed = true\n\n    // Calculate column widths\n    colWidths := make([]int, len(t.headers))\n    for i, header := range t.headers {\n        colWidths[i] = len(header)\n    }\n    for _, row := range t.rows {\n        for i, cell := range row {\n            if len(cell) > colWidths[i] {\n                colWidths[i] = len(cell)\n            }\n        }\n    }\n\n    // Write headers\n    for i, header := range t.headers {\n        t.writer.Write([]byte(padRight(header, colWidths[i])))\n        if i < len(t.headers)-1 {\n            t.writer.Write([]byte{' ', ' '})\n        }\n    }\n    t.writer.Write([]byte{'\\n'})\n\n    // Write separator\n    for i, width := range colWidths {\n        t.writer.Write([]byte(strings.Repeat(\"-\", width)))\n        if i < len(colWidths)-1 {\n            t.writer.Write([]byte{' ', ' '})\n        }\n    }\n    t.writer.Write([]byte{'\\n'})\n\n    // Write rows\n    for _, row := range t.rows {\n        for i, cell := range row {\n            t.writer.Write([]byte(padRight(cell, colWidths[i])))\n            if i < len(row)-1 {\n                t.writer.Write([]byte{' ', ' '})\n            }\n        }\n        t.writer.Write([]byte{'\\n'})\n    }\n}\n\nfunc padRight(s string, width int) string {\n    if len(s) >= width {\n        return s\n    }\n    return s + strings.Repeat(\" \", width-len(s))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *Tabularizer) Flush() {\n# Natural Language Annotations: // Flush writes all buffered rows. Flush should only be called once, after all\n// rows have been written.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/protomsg/io.go-Write": {"response": ["```go\nfunc Write(dst io.Writer, msg proto.Message) error {\n    // Marshal the protobuf message to bytes\n    data, err := proto.Marshal(msg)\n    if err != nil {\n        return err\n    }\n\n    // Write the length of the data as a 4-byte big-endian integer\n    lenBytes := make([]byte, 4)\n    binary.BigEndian.PutUint32(lenBytes, uint32(len(data)))\n    if _, err := dst.Write(lenBytes); err != nil {\n        return err\n    }\n\n    // Write the protobuf data\n    if _, err := dst.Write(data); err != nil {\n        return err\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Write(dst io.Writer, msg proto.Message) error {\n# Natural Language Annotations: // Write writes a length prefixed protobuf to dst. Use Read to read it.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/bin/bin.go-ReadComponentGraph": {"response": ["```go\nfunc ReadComponentGraph(file string) ([]string, graph.Graph, error) {\n\tdata, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tvar header struct {\n\t\tNumComponents int\n\t\tNumEdges      int\n\t}\n\treader := bytes.NewReader(data)\n\tif err := binary.Read(reader, binary.LittleEndian, &header); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcomponents := make([]string, header.NumComponents)\n\tfor i := 0; i < header.NumComponents; i++ {\n\t\tvar length uint32\n\t\tif err := binary.Read(reader, binary.LittleEndian, &length); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tcomponent := make([]byte, length)\n\t\tif _, err := reader.Read(component); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tcomponents[i] = string(component)\n\t}\n\n\tg := graph.New(header.NumComponents)\n\tfor i := 0; i < header.NumEdges; i++ {\n\t\tvar edge struct {\n\t\t\tFrom int\n\t\t\tTo   int\n\t\t}\n\t\tif err := binary.Read(reader, binary.LittleEndian, &edge); err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\tg.AddEdge(edge.From, edge.To)\n\t}\n\n\treturn components, g, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadComponentGraph(file string) ([]string, graph.Graph, error) {\n# Natural Language Annotations: // ReadComponentGraph reads component graph information from the specified\n// binary. It returns a slice of components and a component graph whose nodes\n// are indices into that slice.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/bin/bin.go-ReadListeners": {"response": ["```go\nfunc ReadListeners(file string) ([]codegen.ComponentListeners, error) {\n    // Open the binary file for reading\n    f, err := os.Open(file)\n    if err != nil {\n        return nil, err\n    }\n    defer f.Close()\n\n    // Create a new binary reader\n    reader := bufio.NewReader(f)\n\n    // Read the number of components\n    var numComponents uint32\n    err = binary.Read(reader, binary.LittleEndian, &numComponents)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create a slice to hold the component listeners\n    componentListeners := make([]codegen.ComponentListeners, numComponents)\n\n    // Read the listeners for each component\n    for i := uint32(0); i < numComponents; i++ {\n        // Read the number of listeners for the current component\n        var numListeners uint32\n        err = binary.Read(reader, binary.LittleEndian, &numListeners)\n        if err != nil {\n            return nil, err\n        }\n\n        // Create a slice to hold the listeners for the current component\n        listeners := make([]string, numListeners)\n\n        // Read each listener for the current component\n        for j := uint32(0); j < numListeners; j++ {\n            // Read the length of the listener name\n            var listenerNameLen uint32\n            err = binary.Read(reader, binary.LittleEndian, &listenerNameLen)\n            if err != nil {\n                return nil, err\n            }\n\n            // Read the listener name\n            listenerName := make([]byte, listenerNameLen)\n            _, err = reader.Read(listenerName)\n            if err != nil {\n                return nil, err\n            }\n\n            // Add the listener name to the slice\n            listeners[j] = string(listenerName)\n        }\n\n        // Add the listeners for the current component to the componentListeners slice\n        componentListeners[i] = codegen.ComponentListeners{\n            Component: fmt.Sprintf(\"Component%d\", i+1),\n            Listeners: listeners,\n        }\n    }\n\n    return componentListeners, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadListeners(file string) ([]codegen.ComponentListeners, error) {\n# Natural Language Annotations: // ReadListeners reads the sets of listeners associated with each component\n// in the specified binary.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/bin/bin.go-ReadVersions": {"response": ["```go\nfunc ReadVersions(filename string) (Versions, error) {\n    data, err := os.ReadFile(filename)\n    if err != nil {\n        return Versions{}, err\n    }\n\n    var moduleVersion, apiVersion string\n\n    // Check if the file is an ELF binary\n    if len(data) > 4 && string(data[:4]) == \"\\x7FELF\" {\n        // Scan the binary for the module version and API version\n        scanner := bufio.NewScanner(bytes.NewReader(data))\n        for scanner.Scan() {\n            line := scanner.Text()\n            if strings.HasPrefix(line, \"module_version=\") {\n                moduleVersion = strings.TrimPrefix(line, \"module_version=\")\n            } else if strings.HasPrefix(line, \"api_version=\") {\n                apiVersion = strings.TrimPrefix(line, \"api_version=\")\n            }\n        }\n    }\n\n    return Versions{\n        ModuleVersion: moduleVersion,\n        APIVersion:    apiVersion,\n    }, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadVersions(filename string) (Versions, error) {\n# Natural Language Annotations: // ReadVersions reads the module version and deployer API version from the\n// specified binary.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/prometheus/prometheus.go-TranslateMetricsToPrometheusTextFormat": {"response": ["```go\nfunc TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*metrics.MetricSnapshot, lisAddr, path string) {\n\t// Write Prometheus metadata.\n\tfmt.Fprintf(w, \"# HELP weaver_weavelet_info Information about a weavelet.\\n\")\n\tfmt.Fprintf(w, \"# TYPE weaver_weavelet_info gauge\\n\")\n\tfmt.Fprintf(w, \"# HELP weaver_weavelet_metric Metric associated with a weavelet.\\n\")\n\tfmt.Fprintf(w, \"# TYPE weaver_weavelet_metric gauge\\n\")\n\n\t// Translate metrics.\n\tfor _, m := range ms {\n\t\t// Write a metric that captures information about the weavelet.\n\t\tfmt.Fprintf(w, \"weaver_weavelet_info{weavelet_id=%q,listener_addr=%q,metrics_path=%q} 1\\n\",\n\t\t\tm.WeaveletID, lisAddr, path)\n\n\t\t// Write each metric.\n\t\tfor _, v := range m.Values {\n\t\t\tfmt.Fprintf(w, \"weaver_weavelet_metric{weavelet_id=%q,key=%q} %v\\n\",\n\t\t\t\tm.WeaveletID, v.Key, v.Value)\n\t\t}\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*metrics.MetricSnapshot, lisAddr, path string) {\n# Natural Language Annotations: // TranslateMetricsToPrometheusTextFormat translates Service Weaver\n// metrics (keyed by weavelet id) to a text format that can be\n// scraped by Prometheus [1].\n//\n// [1] https://prometheus.io/\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/codegen/graph.go-ExtractEdges": {"response": ["```go\nfunc ExtractEdges(data []byte) [][2]string {\n\tvar edges [][2]string\n\tfor _, line := range strings.Split(string(data), \"\\n\") {\n\t\tif strings.HasPrefix(line, \"edge: \") {\n\t\t\tline = strings.TrimPrefix(line, \"edge: \")\n\t\t\tparts := strings.Split(line, \" -- \")\n\t\t\tif len(parts) == 2 {\n\t\t\t\tedges = append(edges, [2]string{parts[0], parts[1]})\n\t\t\t}\n\t\t}\n\t}\n\treturn edges\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ExtractEdges(data []byte) [][2]string {\n# Natural Language Annotations: // ExtractEdges returns the edges corresponding to MakeEdgeString() results\n// that occur in data.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/codegen/registry.go-ComponentConfigValidator": {"response": ["```\nfunc ComponentConfigValidator(path, cfg string) error {\n\t// Parse the configuration string into a map.\n\tvar m map[string]interface{}\n\tif err := json.Unmarshal([]byte(cfg), &m); err != nil {\n\t\treturn fmt.Errorf(\"failed to parse %s config: %v\", path, err)\n\t}\n\n\t// Perform component specific validation.\n\tswitch path {\n\tcase \"github.com/jepsen-io/maelstrom/demo/go/echo\":\n\t\treturn validateEchoConfig(m)\n\tcase \"github.com/jepsen-io/maelstrom/demo/go/broadcast\":\n\t\treturn validateBroadcastConfig(m)\n\tcase \"github.com/jepsen-io/maelstrom/demo/go/g-counter\":\n\t\treturn validateGCounterConfig(m)\n\tcase \"github.com/jepsen-io/maelstrom/demo/go/pn-counter\":\n\t\treturn validatePNCounterConfig(m)\n\tcase \"github.com/jepsen-io/maelstrom/demo/go/txn-list-append\":\n\t\treturn validateTxnListAppendConfig(m)\n\tcase \"github.com/jepsen-io/maelstrom/demo/go/kafka\":\n\t\treturn validateKafkaConfig(m)\n\tdefault:\n\t\treturn fmt.Errorf(\"unknown component type %q\", path)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ComponentConfigValidator(path, cfg string) error {\n# Natural Language Annotations: // ComponentConfigValidator checks that cfg is a valid configuration\n// for the component type whose fully qualified name is given by path.\n//\n// TODO(mwhittaker): Move out of codegen package? It's not used by the\n// generated code.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/codegen/registry.go-CallGraph": {"response": ["```go\nfunc CallGraph() []CallEdge {\n    var edges []CallEdge\n    for _, comp := range components {\n        for _, callee := range comp.Callees {\n            edges = append(edges, CallEdge{\n                Caller: comp.Name,\n                Callee: callee,\n            })\n        }\n    }\n    return edges\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CallGraph() []CallEdge {\n# Natural Language Annotations: // CallGraph returns the component call graph (as a list of CallEdge values).\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/codegen/listeners.go-MakeListenersString": {"response": ["```go\nfunc MakeListenersString(component string, listeners []string) string {\n\tlistenersStr := strings.Join(listeners, \",\")\n\tcontent := fmt.Sprintf(\"wEaVeRlIsTeNeRs:%s\u2192%s\", component, listenersStr)\n\tchecksum := fmt.Sprintf(\"%x\", sha256.Sum256([]byte(content)))[:8]\n\treturn fmt.Sprintf(\"\u27e6%s:%s\u27e7\", checksum, content)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MakeListenersString(component string, listeners []string) string {\n# Natural Language Annotations: // All listeners used by a given component are embedded in the generated\n// binary as specially formatted strings. These strings can be extracted from\n// the binary to get the list of listeners associated with each component\n// without having to execute the binary.\n//\n// The set of listeners used by a given component is represented by a string\n// fragment that looks like:\n// \u27e6checksum:wEaVeRlIsTeNeRs:component\u2192listeners\u27e7\n//\n// checksum is the first 8 bytes of the hex encoding of the SHA-256 of\n// the string \"wEaVeRlIsTeNeRs:component\u2192listeners\"; component is the fully\n// qualified component type name; listeners is a comma-separated list of\n// all listener names associated with a given component.\n// MakeListenersString returns a string that should be emitted into generated\n// code to represent the set of listeners associated with a given component.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/codegen/listeners.go-ExtractListeners": {"response": ["```go\nfunc ExtractListeners(data []byte) []ComponentListeners {\n\tvar listeners []ComponentListeners\n\tlines := strings.Split(string(data), \"\\n\")\n\tfor _, line := range lines {\n\t\tif strings.HasPrefix(line, \"=== Component \") {\n\t\t\tvar cl ComponentListeners\n\t\t\tcl.Component = strings.TrimPrefix(line, \"=== Component \")\n\t\t\tlisteners = append(listeners, cl)\n\t\t} else if len(listeners) > 0 {\n\t\t\tlisteners[len(listeners)-1].Listeners = append(listeners[len(listeners)-1].Listeners, line)\n\t\t}\n\t}\n\treturn listeners\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ExtractListeners(data []byte) []ComponentListeners {\n# Natural Language Annotations: // ExtractListeners returns the components and their listeners encoded using\n// MakeListenersString() in data.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/codegen/hash.go-Sum64": {"response": ["```go\nfunc (h *Hasher) Sum64() uint64 {\n    hash := h.sum64()\n    if hash == 0 {\n        hash = 1\n    } else if hash == math.MaxUint64 {\n        hash = math.MaxUint64 - 1\n    }\n    return hash\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (h *Hasher) Sum64() uint64 {\n# Natural Language Annotations: // Sum64 returns the 64-bit hash of the sequence of values added so far.\n// The resulting is in the range [1,2^64-2], i.e., it is never 0 or math.MaxUint64.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/graph/adjacency.go-NewAdjacencyGraph": {"response": ["```go\nfunc NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n    g := Graph{\n        nodes: make(map[int]Node),\n        from:  make(map[int]map[int]struct{}),\n        to:    make(map[int]map[int]struct{}),\n    }\n\n    for _, n := range nodes {\n        if _, ok := g.nodes[n.ID]; ok {\n            panic(fmt.Sprintf(\"duplicate node %d\", n.ID))\n        }\n        g.nodes[n.ID] = n\n        g.from[n.ID] = make(map[int]struct{})\n        g.to[n.ID] = make(map[int]struct{})\n    }\n\n    for _, e := range edges {\n        if _, ok := g.nodes[e.From]; !ok {\n            panic(fmt.Sprintf(\"unknown from node %d\", e.From))\n        }\n        if _, ok := g.nodes[e.To]; !ok {\n            panic(fmt.Sprintf(\"unknown to node %d\", e.To))\n        }\n\n        g.from[e.From][e.To] = struct{}{}\n        g.to[e.To][e.From] = struct{}{}\n    }\n\n    return g\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n# Natural Language Annotations: // NewAdjacencyGraph returns a Graph represented using adjacency lists.\n//\n// It panics if it specified edge nodes aren't in nodes.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/graph/dfs.go-DFSAll": {"response": ["```go\nfunc DFSAll(g Graph, enter, exit func(Node)) {\n    visited := make(map[Node]bool)\n    var dfs func(Node)\n    dfs = func(n Node) {\n        if visited[n] {\n            return\n        }\n        visited[n] = true\n        if enter != nil {\n            enter(n)\n        }\n        for _, neighbor := range g.Neighbors(n) {\n            dfs(neighbor)\n        }\n        if exit != nil {\n            exit(n)\n        }\n    }\n    for _, n := range g.Nodes() {\n        dfs(n)\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DFSAll(g Graph, enter, exit func(Node)) {\n# Natural Language Annotations: // DFSAll performs a depth first search of all nodes in g.\n// If enter is non-nil, it is called on entry to a node.\n// If exit is non-nil, it is called on exit from a node.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/metrics/labels.go-newLabelExtractor": {"response": ["```go\nfunc newLabelExtractor[L comparable]() *labelExtractor[L] {\n\treturn &labelExtractor[L]{}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func newLabelExtractor[L comparable]() *labelExtractor[L] {\n# Natural Language Annotations: // newLabelExtractor returns a new labelExtractor that can extract the labels\n// from a label struct of type L. L must be a valid label struct type.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-runtime/metrics/metrics.go-Snapshot": {"response": ["```go\nfunc (m *Metric) Snapshot() *MetricSnapshot {\n    m.mu.Lock()\n    defer m.mu.Unlock()\n\n    if !m.init {\n        panic(\"Metric.Snapshot called before Init\")\n    }\n\n    snapshot := &MetricSnapshot{\n        Name:   m.name,\n        Labels: make(map[string]string, len(m.labels)),\n        Value:  m.value,\n    }\n\n    for k, v := range m.labels {\n        snapshot.Labels[k] = v\n    }\n\n    return snapshot\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Metric) Snapshot() *MetricSnapshot {\n# Natural Language Annotations: // Snapshot returns a snapshot of the metric. You must call Init at least once\n// before calling Snapshot.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/tool/generate/types.go-sizeOfType": {"response": ["```go\nfunc (tset *typeSet) sizeOfType(t types.Type) int {\n\tswitch t := t.(type) {\n\tcase *types.Basic:\n\t\tswitch t.Kind() {\n\t\tcase types.Bool, types.Uint8, types.Int8:\n\t\t\treturn 1\n\t\tcase types.Uint16, types.Int16:\n\t\t\treturn 2\n\t\tcase types.Uint32, types.Int32, types.Float32:\n\t\t\treturn 4\n\t\tcase types.Uint64, types.Int64, types.Float64, types.Complex64:\n\t\t\treturn 8\n\t\tcase types.Complex128:\n\t\t\treturn 16\n\t\tcase types.String:\n\t\t\treturn -1\n\t\tdefault:\n\t\t\tpanic(\"unsupported basic type\")\n\t\t}\n\tcase *types.Array:\n\t\telemSize := tset.sizeOfType(t.Elem())\n\t\tif elemSize == -1 {\n\t\t\treturn -1\n\t\t}\n\t\treturn elemSize * int(t.Len())\n\tcase *types.Struct:\n\t\tvar size int\n\t\tfor i := 0; i < t.NumFields(); i++ {\n\t\t\tfieldSize := tset.sizeOfType(t.Field(i).Type())\n\t\t\tif fieldSize == -1 {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t\tsize += fieldSize\n\t\t}\n\t\treturn size\n\tcase *types.Interface, *types.Slice, *types.Map, *types.Chan, *types.Signature, *types.Pointer:\n\t\treturn -1\n\tdefault:\n\t\tpanic(\"unsupported type\")\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (tset *typeSet) sizeOfType(t types.Type) int {\n# Natural Language Annotations: // sizeOfType returns the size of the serialization of t if t is fixed size, or\n// returns -1 otherwise.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/tool/generate/types.go-isMeasurable": {"response": ["```go\nfunc (tset *typeSet) isMeasurable(t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.Basic:\n\t\treturn true\n\tcase *types.Array:\n\t\treturn tset.isMeasurable(t.Elem())\n\tcase *types.Slice:\n\t\treturn types.Identical(t.Elem(), types.Typ[types.String])\n\tcase *types.Struct:\n\t\tfor i := 0; i < t.NumFields(); i++ {\n\t\t\tif !tset.isPackageLocal(t.Field(i).Type()) && !tset.isAutoMarshal(t.Field(i).Type()) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !tset.isMeasurable(t.Field(i).Type()) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tcase *types.Named:\n\t\tif t.Obj().Name() == \"AutoMarshal\" && t.Obj().Pkg().Path() == \"weaver\" {\n\t\t\treturn true\n\t\t}\n\t\treturn tset.isPackageLocal(t) && tset.isMeasurable(t.Underlying())\n\tdefault:\n\t\treturn false\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (tset *typeSet) isMeasurable(t types.Type) bool {\n# Natural Language Annotations: // isMeasurable returns whether the provided type is measurable.\n//\n// Informally, we say a type is measurable if we can cheaply compute the size\n// of its serialization at runtime. Some examples:\n//\n//   - Every fixed size type (e.g., int, bool, [3]int, struct{x, y int}) is\n//     measurable (with some restrictions on package locality; see below).\n//   - Strings are not fixed size, but they are measurable because we can\n//     cheaply compute the length of a string at runtime.\n//   - []string is not measurable because computing the size of the\n//     serialization of a []string would require us to compute the length of\n//     every string in the slice. This is a potentially expensive operation\n//     if the slice contains a large number of strings, so we consider\n//     []string to be not measurable.\n//   - For simplicity, we only consider a type measurable if the type and all\n//     its nested types are package local. For example, a struct { x\n//     otherpackage.T } is not measurable, even if otherpackage.T is\n//     measurable. We make an exception for weaver.AutoMarshal.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/tool/generate/types.go-isValidRouterType": {"response": ["```go\nfunc isValidRouterType(t types.Type) bool {\n\tswitch t := t.(type) {\n\tcase *types.Basic:\n\t\tkind := t.Kind()\n\t\treturn kind == types.Int || kind == types.Int8 || kind == types.Int16 || kind == types.Int32 || kind == types.Int64 ||\n\t\t\tkind == types.Uint || kind == types.Uint8 || kind == types.Uint16 || kind == types.Uint32 || kind == types.Uint64 ||\n\t\t\tkind == types.Float32 || kind == types.Float64 || kind == types.String\n\tcase *types.Struct:\n\t\tfor i := 0; i < t.NumFields(); i++ {\n\t\t\tfield := t.Field(i)\n\t\t\tif field.Embedded() {\n\t\t\t\tif named, ok := field.Type().(*types.Named); ok && named.Obj().Name() == \"AutoMarshal\" && named.Obj().Pkg().Name() == \"weaver\" {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !isValidRouterType(field.Type()) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\tdefault:\n\t\treturn false\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func isValidRouterType(t types.Type) bool {\n# Natural Language Annotations: // isValidRouterType returns whether the provided type is a valid router type.\n// A router type can be one of the following: an integer (signed or unsigned),\n// a float, or a string. Alternatively, it can be a struct that may optioanly\n// embed the weaver.AutoMarshal struct and rest of the fields must be either\n// integers, floats, or strings.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/tool/generate/generator.go-sanitize": {"response": ["```go\nvar sanitizeCounter int64\n\nfunc sanitize(t types.Type) string {\n\tvar buf strings.Builder\n\twriteSanitizedType(&buf, t)\n\tbuf.WriteByte('_')\n\tbinary.Write(&buf, binary.BigEndian, atomic.AddInt64(&sanitizeCounter, 1))\n\treturn buf.String()\n}\n\nfunc writeSanitizedType(buf *strings.Builder, t types.Type) {\n\tswitch t := t.(type) {\n\tcase *types.Basic:\n\t\tbuf.WriteString(t.Name())\n\tcase *types.Array:\n\t\tbuf.WriteString(\"array_\")\n\t\tbuf.WriteString(strconv.Itoa(t.Len()))\n\t\tbuf.WriteByte('_')\n\t\twriteSanitizedType(buf, t.Elem())\n\tcase *types.Slice:\n\t\tbuf.WriteString(\"slice_\")\n\t\twriteSanitizedType(buf, t.Elem())\n\tcase *types.Struct:\n\t\tbuf.WriteString(\"struct_\")\n\t\tfor i := 0; i < t.NumFields(); i++ {\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteByte('_')\n\t\t\t}\n\t\t\tf := t.Field(i)\n\t\t\tbuf.WriteString(f.Name())\n\t\t\tbuf.WriteByte('_')\n\t\t\twriteSanitizedType(buf, f.Type())\n\t\t}\n\tcase *types.Pointer:\n\t\tbuf.WriteString(\"ptr_\")\n\t\twriteSanitizedType(buf, t.Elem())\n\tcase *types.Tuple:\n\t\tbuf.WriteString(\"tuple_\")\n\t\tfor i := 0; i < t.Len(); i++ {\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteByte('_')\n\t\t\t}\n\t\t\twriteSanitizedType(buf, t.At(i).Type())\n\t\t}\n\tcase *types.Signature:\n\t\tbuf.WriteString(\"func_\")\n\t\twriteSanitizedType(buf, t.Params())\n\t\tif t.Results().Len() > 0 {\n\t\t\tbuf.WriteByte('_')\n\t\t\twriteSanitizedType(buf, t.Results())\n\t\t}\n\tcase *types.Interface:\n\t\tbuf.WriteString(\"interface{\")\n\t\tfor i := 0; i < t.NumMethods(); i++ {\n\t\t\tif i > 0 {\n\t\t\t\tbuf.WriteByte(';')\n\t\t\t}\n\t\t\tm := t.Method(i)\n\t\t\tbuf.WriteString(m.Name())\n\t\t\twriteSanitizedType(buf, m.Type())\n\t\t}\n\t\tbuf.WriteByte('}')\n\tcase *types.Map:\n\t\tbuf.WriteString(\"map_\")\n\t\twriteSanitizedType(buf, t.Key())\n\t\tbuf.WriteByte('_')\n\t\twriteSanitizedType(buf, t.Elem())\n\tcase *types.Chan:\n\t\tvar dir string\n\t\tswitch t.Dir() {\n\t\tcase types.SendRecv:\n\t\t\tdir = \"chan\"\n\t\tcase types.SendOnly:\n\t\t\tdir = \"chan_send\"\n\t\tcase types.RecvOnly:\n\t\t\tdir = \"chan_recv\"\n\t\t}\n\t\tbuf.WriteString(dir)\n\t\tbuf.WriteByte('_')\n\t\twriteSanitizedType(buf, t.Elem())\n\tcase *types.Named:\n\t\tobj := t.Obj()\n\t\tpkg := obj.Pkg()\n\t\tif pkg != nil {\n\t\t\tbuf.WriteString(pkg.Name())\n\t\t\tbuf.WriteByte('.')\n\t\t}\n\t\tbuf.WriteString(obj.Name())\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"unhandled type: %T\", t))\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func sanitize(t types.Type) string {\n# Natural Language Annotations: // sanitize generates a (somewhat pretty printed) name for the provided type\n// that is a valid go identifier [1]. sanitize also produces unique names. That\n// is, if u != t, then sanitize(u) != sanitize(t).\n//\n// Some examples:\n//\n//   - map[int]string -> map_int_string_589aebd1\n//   - map[int][]X    -> map_int_slice_X_ac498abc\n//   - []int          -> slice_int_1048ebf9\n//   - [][]string     -> slice_slice_string_13efa8aa\n//   - [20]int        -> array_20_int_00ae9a0a\n//   - *int           -> ptr_int_916711b2\n//\n// [1]: https://go.dev/ref/spec#Identifiers\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/tool/generate/generator.go-uniqueName": {"response": ["```go\nfunc uniqueName(t types.Type) string {\n\tswitch t := t.(type) {\n\tcase *types.Basic:\n\t\treturn t.Name()\n\tcase *types.Array:\n\t\treturn fmt.Sprintf(\"[%d]%s\", t.Len(), uniqueName(t.Elem()))\n\tcase *types.Slice:\n\t\treturn fmt.Sprintf(\"[]%s\", uniqueName(t.Elem()))\n\tcase *types.Struct:\n\t\tvar fields []string\n\t\tfor i := 0; i < t.NumFields(); i++ {\n\t\t\tf := t.Field(i)\n\t\t\tfields = append(fields, fmt.Sprintf(\"%s %s\", f.Name(), uniqueName(f.Type())))\n\t\t}\n\t\treturn fmt.Sprintf(\"struct{%s}\", strings.Join(fields, \"; \"))\n\tcase *types.Pointer:\n\t\treturn fmt.Sprintf(\"*%s\", uniqueName(t.Elem()))\n\tcase *types.Tuple:\n\t\tvar elems []string\n\t\tfor i := 0; i < t.Len(); i++ {\n\t\t\telems = append(elems, uniqueName(t.At(i).Type()))\n\t\t}\n\t\treturn fmt.Sprintf(\"(%s)\", strings.Join(elems, \", \"))\n\tcase *types.Signature:\n\t\tvar params []string\n\t\tfor i := 0; i < t.Params().Len(); i++ {\n\t\t\tparams = append(params, uniqueName(t.Params().At(i).Type()))\n\t\t}\n\t\tvar results []string\n\t\tfor i := 0; i < t.Results().Len(); i++ {\n\t\t\tresults = append(results, uniqueName(t.Results().At(i).Type()))\n\t\t}\n\t\treturn fmt.Sprintf(\"func(%s) (%s)\", strings.Join(params, \", \"), strings.Join(results, \", \"))\n\tcase *types.Interface:\n\t\tvar methods []string\n\t\tfor i := 0; i < t.NumMethods(); i++ {\n\t\t\tm := t.Method(i)\n\t\t\tmethods = append(methods, fmt.Sprintf(\"%s %s\", m.Name(), uniqueName(m.Type())))\n\t\t}\n\t\treturn fmt.Sprintf(\"interface{%s}\", strings.Join(methods, \"; \"))\n\tcase *types.Map:\n\t\treturn fmt.Sprintf(\"map[%s]%s\", uniqueName(t.Key()), uniqueName(t.Elem()))\n\tcase *types.Chan:\n\t\tvar dir string\n\t\tswitch t.Dir() {\n\t\tcase types.SendRecv:\n\t\t\tdir = \"chan \"\n\t\tcase types.SendOnly:\n\t\t\tdir = \"chan<- \"\n\t\tcase types.RecvOnly:\n\t\t\tdir = \"<-chan \"\n\t\t}\n\t\treturn fmt.Sprintf(\"%s%s\", dir, uniqueName(t.Elem()))\n\tcase *types.Named:\n\t\treturn fmt.Sprintf(\"%s.%s\", t.Obj().Pkg().Path(), t.Obj().Name())\n\tdefault:\n\t\treturn t.String()\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func uniqueName(t types.Type) string {\n# Natural Language Annotations: // uniqueName returns a unique pretty printed representation of the provided\n// type (e.g., \"int\", \"map[int]bool\"). The key property is that if u != t, then\n// uniqueName(u) != uniqueName(t).\n//\n// Note that types.TypeString returns a pretty printed representation of a\n// string, but it is not guaranteed to be unique. For example, if have `type\n// int bool`, then TypeString returns \"int\" for both the named type int and the\n// primitive type int.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/tool/certs/certs.go-GenerateSignedCert": {"response": ["```go\nfunc GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n\t// Generate a new private key\n\tcertKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to generate private key: %v\", err)\n\t}\n\n\t// Set the validity period for the certificate (1 year)\n\tnotBefore := time.Now()\n\tnotAfter := notBefore.AddDate(1, 0, 0)\n\n\t// Create the certificate template\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: big.NewInt(1),\n\t\tSubject: pkix.Name{\n\t\t\tCommonName: names[0],\n\t\t},\n\t\tNotBefore:             notBefore,\n\t\tNotAfter:              notAfter,\n\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tDNSNames:              names,\n\t}\n\n\t// Create the certificate\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, &template, ca, &certKey.PublicKey, caKey)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create certificate: %v\", err)\n\t}\n\n\t// Parse the certificate\n\tcert, err := x509.ParseCertificate(certBytes)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to parse certificate: %v\", err)\n\t}\n\n\treturn cert, certKey, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n# Natural Language Annotations: // GenerateSignedCert generates a certificate for the given DNS names, signed\n// by the given Certificate Authority, and a corresponding private key.\n//\n// The returned certificate has a one-year validity and should only ever\n// be used on a temporary basis.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/weaver/load.go-updateAssignment": {"response": ["```go\nfunc (lc *loadCollector) updateAssignment(assignment *protos.Assignment) {\n    lc.mu.Lock()\n    defer lc.mu.Unlock()\n\n    lc.assignment = assignment\n    lc.load = protos.Load{}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (lc *loadCollector) updateAssignment(assignment *protos.Assignment) {\n# Natural Language Annotations: // updateAssignment updates a load collector with the latest assignment. The\n// load reported by a load collector is always scoped to a single assignment.\n// A load report never spans more than one assignment. Thus, UpdateAssignment\n// also clears the load collector's accumulated load.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/weaver/load.go-report": {"response": ["```go\nfunc (lc *loadCollector) report() *protos.LoadReport_ComponentLoad {\n\tlc.mu.Lock()\n\tdefer lc.mu.Unlock()\n\n\tif lc.assignment == nil {\n\t\treturn nil\n\t}\n\n\tload := &protos.LoadReport_ComponentLoad{\n\t\tCpu: &protos.LoadReport_CpuLoad{\n\t\t\tCpuUtilization: lc.cpuUtil,\n\t\t},\n\t\tMem: &protos.LoadReport_MemLoad{\n\t\t\tMemTotal: lc.memTotal,\n\t\t\tMemUsed:  lc.memUsed,\n\t\t},\n\t\tComponentId: lc.assignment.ComponentId,\n\t}\n\n\treturn load\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (lc *loadCollector) report() *protos.LoadReport_ComponentLoad {\n# Natural Language Annotations: // report returns a report of the collected load. If the load collector\n// doesn't have any collected load---this is possible if the load collector\n// doesn't have an assignment yet---then Report returns nil.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/weaver/load.go-subslices": {"response": ["```go\nfunc subslices(load float64, xs []uint64, n int) []*protos.LoadReport_SubsliceLoad {\n\tvar (\n\t\tsplits   = make([]*protos.LoadReport_SubsliceLoad, n)\n\t\ttotal    = float64(len(xs))\n\t\tloadPerN = load / float64(n)\n\t\tstart    = xs[0]\n\t\tcount    int\n\t)\n\tfor i := 0; i < n; i++ {\n\t\tvar subload float64\n\t\tfor ; count < len(xs); count++ {\n\t\t\tif subload+total/float64(len(xs)-count) > loadPerN {\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tsubload += total / float64(len(xs)-count)\n\t\t}\n\t\tvar end uint64\n\t\tif count < len(xs) {\n\t\t\tend = xs[count]\n\t\t} else {\n\t\t\tend = math.MaxUint64\n\t\t}\n\t\tsplits[i] = &protos.LoadReport_SubsliceLoad{\n\t\t\tStart: start,\n\t\t\tLoad:  subload,\n\t\t}\n\t\tstart = end\n\t}\n\treturn splits\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func subslices(load float64, xs []uint64, n int) []*protos.LoadReport_SubsliceLoad {\n# Natural Language Annotations: // subslices returns n splits of the provided points with roughly the same\n// load. For example, given xs = []uint64{10, 20, 30, 40, 50, 60, 70, 80}, n =\n// 4, and a load of 10.0, subslices will return the following four splits:\n//\n//   - {Start: 10, Load: 2.5} // [10, 30)\n//   - {Start: 30, Load: 2.5} // [30, 50)\n//   - {Start: 50, Load: 2.5} // [50, 70)\n//   - {Start: 70, Load: 2.5} // [70, infinity)\n//\n// The returned splits are as even as possible on a best effort basis.\n// subslices only guarantees that the returned splits are contiguous and\n// sorted.\n//\n// REQUIRES xs is sorted in increasing order\n// REQUIRES n > 0\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/weaver/routing.go-update": {"response": ["```go\nfunc (rb *routingBalancer) update(assignment *protos.Assignment) {\n    rb.mu.Lock()\n    defer rb.mu.Unlock()\n\n    rb.assignment = assignment\n    rb.resolver.UpdateState(resolver.State{\n        Addresses: rb.extractAddrs(),\n    })\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rb *routingBalancer) update(assignment *protos.Assignment) {\n# Natural Language Annotations: // update updates the balancer with the provided assignment\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/status/registry.go-NewRegistry": {"response": ["```go\nfunc NewRegistry(_ context.Context, dir string) (*Registry, error) {\n    // Create the directory if it doesn't exist\n    err := os.MkdirAll(dir, os.ModePerm)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create registry directory: %v\", err)\n    }\n\n    return &Registry{\n        dir: dir,\n    }, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewRegistry(_ context.Context, dir string) (*Registry, error) {\n# Natural Language Annotations: // NewRegistry returns a registry that persists data to the provided directory.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/routing/routing.go-FormatAssignment": {"response": ["```go\nfunc FormatAssignment(a *protos.Assignment) string {\n    var sb strings.Builder\n\n    sb.WriteString(fmt.Sprintf(\"Assignment ID: %s\\n\", a.GetId()))\n    sb.WriteString(fmt.Sprintf(\"Title: %s\\n\", a.GetTitle()))\n    sb.WriteString(fmt.Sprintf(\"Description: %s\\n\", a.GetDescription()))\n    sb.WriteString(fmt.Sprintf(\"Due Date: %s\\n\", a.GetDueDate().AsTime().Format(\"2006-01-02\")))\n    sb.WriteString(fmt.Sprintf(\"Points: %.2f\\n\", a.GetPoints()))\n    sb.WriteString(fmt.Sprintf(\"Status: %s\\n\", a.GetStatus().String()))\n    sb.WriteString(fmt.Sprintf(\"Submission Count: %d\\n\", a.GetSubmissionCount()))\n\n    return sb.String()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FormatAssignment(a *protos.Assignment) string {\n# Natural Language Annotations: // FormatAssignment pretty formats the provided assignment.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/routing/routing.go-EqualSlices": {"response": ["```go\nfunc EqualSlices(replicas []string) *protos.Assignment {\n    numReplicas := len(replicas)\n    if numReplicas == 0 {\n        return &protos.Assignment{\n            Version: 0,\n            Slices:  []*protos.Slice{},\n        }\n    }\n\n    numSlices := numReplicas\n    slices := make([]*protos.Slice, numSlices)\n\n    for i := 0; i < numSlices; i++ {\n        slices[i] = &protos.Slice{\n            Replicas: []string{},\n        }\n    }\n\n    for i := 0; i < numReplicas; i++ {\n        sliceIndex := i % numSlices\n        slices[sliceIndex].Replicas = append(slices[sliceIndex].Replicas, replicas[i])\n    }\n\n    return &protos.Assignment{\n        Version: 0,\n        Slices:  slices,\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EqualSlices(replicas []string) *protos.Assignment {\n# Natural Language Annotations: // EqualSlices returns an assignment with slices of roughly equal size.\n// Replicas are assigned to slices in a round robin fashion. The returned\n// assignment has a version of 0.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/queue/queue.go-Pop": {"response": ["```go\nfunc (q *Queue[T]) Pop(ctx context.Context) (elem T, err error) {\n    select {\n    case <-ctx.Done():\n        return elem, ctx.Err()\n    case elem = <-q.elements:\n        return elem, nil\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (q *Queue[T]) Pop(ctx context.Context) (elem T, err error) {\n# Natural Language Annotations: // Pop removes the element from the front of the queue and returns it.\n// It blocks if the queue is empty.\n// It returns an error if the passed-in context is canceled.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/pipe/pipe.go-MakePipePair": {"response": ["```go\nfunc (c *Cmd) MakePipePair() (PipePair, error) {\n\tpr, pw, err := os.Pipe()\n\tif err != nil {\n\t\treturn PipePair{}, err\n\t}\n\tcr, cw, err := os.Pipe()\n\tif err != nil {\n\t\tpr.Close()\n\t\tpw.Close()\n\t\treturn PipePair{}, err\n\t}\n\tc.ExtraFiles = append(c.ExtraFiles, pr, cw)\n\tc.closeAfterStart = append(c.closeAfterStart, pw, cr)\n\tc.closeAfterWait = append(c.closeAfterWait, pr, cw)\n\treturn PipePair{pw, cr}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Cmd) MakePipePair() (PipePair, error) {\n# Natural Language Annotations: // MakePipePair makes a pair of pipes that can be used for bi-directional\n// communication with the child process.\n//\n// Cmd.ExtraFiles should not be modified directly if MakePipePair is called.\n//\n// Wait will close ParentWriter automatically after seeing the command exit. A\n// caller need only close ParentWriter to force the pipe to close sooner. For\n// example, if the command being run will not exit until standard input is\n// closed, the caller must close ParentWriter.\n//\n// Wait will close ParentReader automatically after seeing the command exit, so\n// most callers need not close ParentReader themselves. It is thus incorrect to\n// call Wait before all reads from ParentReader have completed. For the same\n// reason, it is incorrect to use Run when using MakePipePair. See the\n// exec.Cmd.StdoutPipe example [1] for idiomatic usage.\n//\n// [1]: https://pkg.go.dev/os/exec#example-Cmd.StdoutPipe\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/register/writeonce.go-Write": {"response": ["```go\nfunc (w *WriteOnce[T]) Write(val T) {\n    if w.written {\n        panic(\"write to WriteOnce register more than once\")\n    }\n    w.val = val\n    w.written = true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) Write(val T) {\n# Natural Language Annotations: // Write writes to the register, or panics if the register was already written.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/register/writeonce.go-TryWrite": {"response": ["```go\nfunc (w *WriteOnce[T]) TryWrite(val T) bool {\n    w.mu.Lock()\n    defer w.mu.Unlock()\n\n    if w.written {\n        return false\n    }\n\n    w.val = val\n    w.written = true\n    return true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) TryWrite(val T) bool {\n# Natural Language Annotations: // TryWrite tries to write to the register and returns if the write succeeds.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/register/writeonce.go-Read": {"response": ["```go\nfunc (w *WriteOnce[T]) Read() T {\n\tw.mu.Lock()\n\tfor !w.written {\n\t\tw.cond.Wait()\n\t}\n\tval := w.value\n\tw.mu.Unlock()\n\treturn val\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) Read() T {\n# Natural Language Annotations: // Read returns the value of the register, blocking until it is written.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/versioned/versioned.go-RLock": {"response": ["```go\nfunc (v *Versioned[T]) RLock(version string) string {\n\tfor {\n\t\tv.mu.RLock()\n\t\tif v.version != version {\n\t\t\tdefer v.mu.RUnlock()\n\t\t\treturn v.version\n\t\t}\n\t\tv.mu.RUnlock()\n\t\ttime.Sleep(10 * time.Millisecond)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (v *Versioned[T]) RLock(version string) string {\n# Natural Language Annotations: // RLock waits until the current version is different than the passed-in\n// version, and then acquires the read lock and returns the new\n// version.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/net/call/stub.go-makeStubMethods": {"response": ["```go\nfunc makeStubMethods(fullName string, reg *codegen.Registration) []stubMethod {\n\tvar methods []stubMethod\n\tfor _, m := range reg.Methods {\n\t\tsm := stubMethod{\n\t\t\tName:    m.Name,\n\t\t\tParams:  makeStubParams(m.Params),\n\t\t\tReturns: makeStubReturns(m.Returns),\n\t\t}\n\t\tmethods = append(methods, sm)\n\t}\n\treturn methods\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func makeStubMethods(fullName string, reg *codegen.Registration) []stubMethod {\n# Natural Language Annotations: // makeStubMethods returns a slice of stub methods for the component methods of reg.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/net/call/call.go-Serve": {"response": ["```go\nfunc Serve(ctx context.Context, l Listener, opts ServerOptions) error {\n\tdefer l.Close()\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\tselect {\n\t\t\tcase <-ctx.Done():\n\t\t\t\treturn ctx.Err()\n\t\t\tdefault:\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tgo func() {\n\t\t\tif err := handleConnection(ctx, conn, opts); err != nil {\n\t\t\t\tlog.Printf(\"Error handling connection: %v\", err)\n\t\t\t}\n\t\t}()\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Serve(ctx context.Context, l Listener, opts ServerOptions) error {\n# Natural Language Annotations: // Serve starts listening for connections and requests on l. It always returns a\n// non-nil error and closes l.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/net/call/call.go-Connect": {"response": ["```go\nfunc Connect(ctx context.Context, resolver Resolver, opts ClientOptions) (Connection, error) {\n\tendpoints, err := resolver.Resolve(ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar conn Connection\n\tfor _, endpoint := range endpoints {\n\t\tconn, err = dialEndpoint(ctx, endpoint, opts)\n\t\tif err == nil {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn conn, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Connect(ctx context.Context, resolver Resolver, opts ClientOptions) (Connection, error) {\n# Natural Language Annotations: // Connect creates a connection to the servers at the endpoints returned by the\n// resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/net/call/msg.go-writeMessage": {"response": ["```go\nfunc writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n\twlock.Lock()\n\tdefer wlock.Unlock()\n\n\thdr := make([]byte, 0, 16)\n\thdr = append(hdr, byte(mt))\n\thdr = append(hdr, extraHdr...)\n\n\ttotalLen := len(hdr) + len(payload)\n\tif totalLen > flattenLimit {\n\t\t// Write the message in parts.\n\t\tif err := binary.Write(w, binary.BigEndian, id); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := binary.Write(w, binary.BigEndian, hdr); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tlenBuf := make([]byte, 7)\n\t\tbinary.BigEndian.PutUint64(lenBuf, uint64(len(payload)))\n\t\tif _, err := w.Write(lenBuf[1:]); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif _, err := w.Write(payload); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// Flatten the message.\n\t\tmsg := make([]byte, 0, 16+totalLen)\n\t\tmsg = append(msg, byte(mt))\n\t\tmsg = append(msg, extraHdr...)\n\t\tmsg = append(msg, payload...)\n\t\tlenBuf := make([]byte, 8)\n\t\tbinary.BigEndian.PutUint64(lenBuf, uint64(len(msg)))\n\t\tmsg = append(lenBuf[1:], msg...)\n\t\tmsg = append(make([]byte, 8), msg...)\n\t\tbinary.BigEndian.PutUint64(msg, id)\n\t\tif _, err := w.Write(msg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n# Natural Language Annotations: // # Message formats\n//\n// All messages have the following format:\n//    id        [8]byte       -- identifier used to track the message\n//    type      [1]byte       -- messageType\n//    length    [7]byte       -- length of the remainder of the message\n//    payload   [length]byte  -- message-type-specific data\n//\n// The format of payload depends on the message type.\n//\n// versionMessage: this is the first message sent on a connection by both sides.\n//    version  [4]byte\n//\n// requestMessage:\n//    headerLen         [4]byte         -- length of the encoded header\n//    header            [headerLen]byte -- encoded header information\n//    payload                           -- call argument serialization\n//\n// The header is encoded using Service Weaver's encoding format for a type that\n// looks like:\n//\n// struct header {\n//   MethodKey       [16]byte\n//   Deadline        int64\n//   TraceContext    [25]byte\n//   MetadataContext map[string]string\n// }\n//\n// responseMessage:\n//    payload holds call result serialization\n//\n// responseError:\n//    payload holds error serialization\n//\n// cancelMessage:\n//    payload is empty\n// writeMessage formats and sends a message over w.\n//\n// The message payload is formed by concatenating extraHdr and payload.\n// (Allowing two arguments to form the payload avoids unnecessary allocation\n// and copying when we want to prepend some data to application supplied data).\n//\n// The write is guarded by wlock, which must not be locked when passed in.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/net/call/trace.go-writeTraceContext": {"response": ["```go\nfunc writeTraceContext(ctx context.Context, enc *codegen.Encoder) {\n\tspan := trace.SpanFromContext(ctx)\n\tif span == nil {\n\t\treturn\n\t}\n\n\tsc := span.SpanContext()\n\tenc.WriteString(sc.TraceID().String())\n\tenc.WriteString(sc.SpanID().String())\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeTraceContext(ctx context.Context, enc *codegen.Encoder) {\n# Natural Language Annotations: // writeTraceContext serializes the trace context (if any) contained in ctx\n// into enc.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "weaver-internal/net/call/trace.go-readTraceContext": {"response": ["```go\nfunc readTraceContext(dec *codegen.Decoder) *trace.SpanContext {\n    var sc trace.SpanContext\n    \n    traceID, err := dec.ReadBytes()\n    if err == nil {\n        copy(sc.TraceID[:], traceID)\n    }\n    \n    spanID, err := dec.ReadBytes()\n    if err == nil {\n        copy(sc.SpanID[:], spanID)\n    }\n    \n    sc.TraceOptions = trace.TraceOptions(dec.ReadUint32())\n    \n    return &sc\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func readTraceContext(dec *codegen.Decoder) *trace.SpanContext {\n# Natural Language Annotations: // readTraceContext returns a span context with tracing information stored in dec.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "ollama-types/model/name.go-ParseNameBare": {"response": ["```go\nfunc ParseNameBare(s string) Name {\n\tparts := strings.Split(s, \" \")\n\tswitch len(parts) {\n\tcase 1:\n\t\treturn Name{GivenName: parts[0]}\n\tcase 2:\n\t\treturn Name{GivenName: parts[0], FamilyName: parts[1]}\n\tcase 3:\n\t\treturn Name{GivenName: parts[0], MiddleName: parts[1], FamilyName: parts[2]}\n\tdefault:\n\t\treturn Name{GivenName: parts[0], MiddleName: strings.Join(parts[1:len(parts)-1], \" \"), FamilyName: parts[len(parts)-1]}\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseNameBare(s string) Name {\n# Natural Language Annotations: // ParseNameBare parses s as a name string and returns a Name. No merge with\n// [DefaultName] is performed.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "ollama-types/model/name.go-ParseNameFromFilepath": {"response": ["```go\nfunc ParseNameFromFilepath(s string) (n Name) {\n\tparts := strings.Split(s, \"/\")\n\tif len(parts) != 4 {\n\t\treturn Name{}\n\t}\n\treturn Name{\n\t\tHost:      parts[0],\n\t\tNamespace: parts[1],\n\t\tModel:     parts[2],\n\t\tTag:       parts[3],\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseNameFromFilepath(s string) (n Name) {\n# Natural Language Annotations: // ParseNameFromFilepath parses a 4-part filepath as a Name. The parts are\n// expected to be in the form:\n//\n// { host } \"/\" { namespace } \"/\" { model } \"/\" { tag }\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "ollama-types/model/name.go-DisplayShortest": {"response": ["```go\nfunc (n Name) DisplayShortest() string {\n    if len(n.FirstName) > 0 {\n        return n.FirstName\n    }\n    if len(n.MiddleName) > 0 {\n        return n.MiddleName\n    }\n    if len(n.LastName) > 0 {\n        return n.LastName\n    }\n    return \"\"\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n Name) DisplayShortest() string {\n# Natural Language Annotations: // DisplayShort returns a short string version of the name.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "ollama-types/model/name.go-Filepath": {"response": ["```go\nfunc (n Name) Filepath() string {\n\tif !n.IsFullyQualified() {\n\t\tpanic(\"name is not fully qualified\")\n\t}\n\treturn filepath.Clean(filepath.Join(n.Host(), n.Namespace(), n.Model(), n.Tag()))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n Name) Filepath() string {\n# Natural Language Annotations: // Filepath returns a canonical filepath that represents the name with each part from\n// host to tag as a directory in the form:\n//\n//\t{host}/{namespace}/{model}/{tag}\n//\n// It uses the system's filepath separator and ensures the path is clean.\n//\n// It panics if the name is not fully qualified. Use [Name.IsFullyQualified]\n// to check if the name is fully qualified.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "ollama-server/prompt.go-Prompt": {"response": ["```go\nfunc Prompt(tmpl *template.Template, system, prompt, response string, generate bool) (string, error) {\n    data := struct {\n        System   string\n        Prompt   string\n        Response string\n    }{\n        System:   system,\n        Prompt:   prompt,\n        Response: response,\n    }\n\n    var buf bytes.Buffer\n    if generate {\n        err := tmpl.Execute(&buf, data)\n        if err != nil {\n            return \"\", err\n        }\n        parts := strings.SplitN(buf.String(), response, 2)\n        return parts[0], nil\n    } else {\n        err := tmpl.Execute(&buf, data)\n        if err != nil {\n            return \"\", err\n        }\n        return buf.String(), nil\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Prompt(tmpl *template.Template, system, prompt, response string, generate bool) (string, error) {\n# Natural Language Annotations: // Prompt renders a prompt from a template. If generate is set to true,\n// the response and parts of the template following it are not rendered\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "ollama-server/sched.go-unload": {"response": ["```go\nfunc (runner *runnerRef) unload() {\n\t// The refMu must already be held when calling unload\n\trunner.refCount--\n\tif runner.refCount == 0 {\n\t\tdelete(runners, runner.key)\n\t\tclose(runner.notify)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (runner *runnerRef) unload() {\n# Natural Language Annotations: // The refMu must already be held when calling unload\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-retry.go-NewDebounce": {"response": ["```go\nfunc NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n    if len(f) == 0 {\n        panic(\"NewDebounce requires at least one function\")\n    }\n    \n    var mu sync.Mutex\n    var timer *time.Timer\n    \n    cancel := func() {\n        mu.Lock()\n        defer mu.Unlock()\n        if timer != nil {\n            timer.Stop()\n        }\n    }\n    \n    debounce := func() {\n        cancel()\n        \n        mu.Lock()\n        defer mu.Unlock()\n        \n        timer = time.AfterFunc(duration, func() {\n            for _, fn := range f {\n                fn()\n            }\n        })\n    }\n    \n    return debounce, cancel\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n# Natural Language Annotations: // NewDebounce creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/mz32VMK2nqe\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-retry.go-NewDebounceBy": {"response": ["```go\nfunc NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n\tvar (\n\t\tmu     sync.Mutex\n\t\ttimers = make(map[T]*time.Timer)\n\t\tcounts = make(map[T]int)\n\t)\n\n\tcancel := func(key T) {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tif timer, ok := timers[key]; ok {\n\t\t\ttimer.Stop()\n\t\t\tdelete(timers, key)\n\t\t\tdelete(counts, key)\n\t\t}\n\t}\n\n\treturn func(key T) {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tcounts[key]++\n\n\t\tif timer, ok := timers[key]; ok {\n\t\t\ttimer.Reset(duration)\n\t\t\treturn\n\t\t}\n\n\t\ttimers[key] = time.AfterFunc(duration, func() {\n\t\t\tmu.Lock()\n\t\t\tdefer mu.Unlock()\n\n\t\t\tcount := counts[key]\n\t\t\tdelete(timers, key)\n\t\t\tdelete(counts, key)\n\n\t\t\tfor _, fn := range f {\n\t\t\t\tfn(key, count)\n\t\t\t}\n\t\t})\n\t}, cancel\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n# Natural Language Annotations: // NewDebounceBy creates a debounced instance for each distinct key, that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/d3Vpt6pxhY8\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-errors.go-Try6": {"response": ["```go\nfunc Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n\t_, _, _, _, _, err := callback()\n\treturn err == nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n# Natural Language Annotations: // Try6 has the same behavior as Try, but callback returns 6 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-errors.go-TryOr6": {"response": ["```go\nfunc TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n\ta, b, c, d, e, f, err := callback()\n\tif err != nil {\n\t\treturn fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF, false\n\t}\n\treturn a, b, c, d, e, f, true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n# Natural Language Annotations: // TryOr6 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-string.go-Substring": {"response": ["```go\nfunc Substring[T ~string](str T, offset int, length uint) T {\n\tif offset < 0 {\n\t\toffset = 0\n\t}\n\tif length < 0 {\n\t\tlength = 0\n\t}\n\tend := offset + int(length)\n\tif end > len(str) {\n\t\tend = len(str)\n\t}\n\treturn str[offset:end]\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Substring[T ~string](str T, offset int, length uint) T {\n# Natural Language Annotations: // Substring return part of a string.\n// Play: https://go.dev/play/p/TQlxQi82Lu1\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-string.go-PascalCase": {"response": ["```go\nfunc PascalCase(str string) string {\n    if len(str) == 0 {\n        return \"\"\n    }\n\n    words := strings.Fields(str)\n    var pascalCaseWords []string\n\n    for _, word := range words {\n        pascalCaseWord := strings.ToUpper(string(word[0])) + strings.ToLower(word[1:])\n        pascalCaseWords = append(pascalCaseWords, pascalCaseWord)\n    }\n\n    return strings.Join(pascalCaseWords, \"\")\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func PascalCase(str string) string {\n# Natural Language Annotations: // PascalCase converts string to pascal case.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-map.go-PickByValues": {"response": ["```go\nfunc PickByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n\tout := make(Map)\n\tfor k, v := range in {\n\t\tfor _, val := range values {\n\t\t\tif val == v {\n\t\t\t\tout[k] = v\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn out\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func PickByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n# Natural Language Annotations: // PickByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/1zdzSvbfsJc\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-map.go-OmitByValues": {"response": ["```go\nfunc OmitByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n\tres := make(Map, len(in))\n\tfor k, v := range in {\n\t\tif !Contains(values, v) {\n\t\t\tres[k] = v\n\t\t}\n\t}\n\treturn res\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OmitByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n# Natural Language Annotations: // OmitByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/9UYZi-hrs8j\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-tuples.go-Zip9": {"response": ["```go\nfunc Zip9[A, B, C, D, E, F, G, H, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n\tminLen := min(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n\tresult := make([]Tuple9[A, B, C, D, E, F, G, H, I], minLen)\n\n\tfor j := 0; j < minLen; j++ {\n\t\ttuple := Tuple9[A, B, C, D, E, F, G, H, I]{}\n\t\tif j < len(a) {\n\t\t\ttuple.V1 = a[j]\n\t\t}\n\t\tif j < len(b) {\n\t\t\ttuple.V2 = b[j]\n\t\t}\n\t\tif j < len(c) {\n\t\t\ttuple.V3 = c[j]\n\t\t}\n\t\tif j < len(d) {\n\t\t\ttuple.V4 = d[j]\n\t\t}\n\t\tif j < len(e) {\n\t\t\ttuple.V5 = e[j]\n\t\t}\n\t\tif j < len(f) {\n\t\t\ttuple.V6 = f[j]\n\t\t}\n\t\tif j < len(g) {\n\t\t\ttuple.V7 = g[j]\n\t\t}\n\t\tif j < len(h) {\n\t\t\ttuple.V8 = h[j]\n\t\t}\n\t\tif j < len(i) {\n\t\t\ttuple.V9 = i[j]\n\t\t}\n\t\tresult[j] = tuple\n\t}\n\n\treturn result\n}\n\nfunc min(nums ...int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\n\tm := nums[0]\n\tfor _, n := range nums {\n\t\tif n < m {\n\t\t\tm = n\n\t\t}\n\t}\n\treturn m\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Zip9[A, B, C, D, E, F, G, H, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n# Natural Language Annotations: // Zip9 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-tuples.go-ZipBy9": {"response": ["```go\nfunc ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n\tminLen := min(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n\tresult := make([]Out, minLen)\n\n\tfor idx := 0; idx < minLen; idx++ {\n\t\tvar aVal, bVal, cVal, dVal, eVal, fVal, gVal, hVal, iVal any\n\t\tif idx < len(a) {\n\t\t\taVal = a[idx]\n\t\t}\n\t\tif idx < len(b) {\n\t\t\tbVal = b[idx]\n\t\t}\n\t\tif idx < len(c) {\n\t\t\tcVal = c[idx]\n\t\t}\n\t\tif idx < len(d) {\n\t\t\tdVal = d[idx]\n\t\t}\n\t\tif idx < len(e) {\n\t\t\teVal = e[idx]\n\t\t}\n\t\tif idx < len(f) {\n\t\t\tfVal = f[idx]\n\t\t}\n\t\tif idx < len(g) {\n\t\t\tgVal = g[idx]\n\t\t}\n\t\tif idx < len(h) {\n\t\t\thVal = h[idx]\n\t\t}\n\t\tif idx < len(i) {\n\t\t\tiVal = i[idx]\n\t\t}\n\t\tresult[idx] = iteratee(aVal.(A), bVal.(B), cVal.(C), dVal.(D), eVal.(E), fVal.(F), gVal.(G), hVal.(H), iVal.(I))\n\t}\n\n\treturn result\n}\n\nfunc min(nums ...int) int {\n\tif len(nums) == 0 {\n\t\treturn 0\n\t}\n\n\tm := nums[0]\n\tfor _, n := range nums[1:] {\n\t\tif n < m {\n\t\t\tm = n\n\t\t}\n\t}\n\treturn m\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n# Natural Language Annotations: // ZipBy9 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-channel.go-ChannelDispatcher": {"response": ["```go\nfunc ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n\toutputs := make([]chan T, count)\n\tfor i := 0; i < count; i++ {\n\t\toutputs[i] = make(chan T, channelBufferCap)\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\tclose(outputs[i])\n\t\t\t}\n\t\t}()\n\n\t\tfor {\n\t\t\tval, ok := <-stream\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tidx := strategy.Dispatch(val, count)\n\t\t\toutputs[idx] <- val\n\t\t}\n\t}()\n\n\tresults := make([]<-chan T, count)\n\tfor i := 0; i < count; i++ {\n\t\tresults[i] = outputs[i]\n\t}\n\n\treturn results\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n# Natural Language Annotations: // ChannelDispatcher distributes messages from input channels into N child channels.\n// Close events are propagated to children.\n// Underlying channels can have a fixed buffer capacity or be unbuffered when cap is 0.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-channel.go-DispatchingStrategyRoundRobin": {"response": ["```go\nfunc DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n    for i := 0; i < len(channels); i++ {\n        idx := int((index + uint64(i)) % uint64(len(channels)))\n        select {\n        case channels[idx] <- msg:\n            return idx\n        default:\n        }\n    }\n    return -1\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n# Natural Language Annotations: // DispatchingStrategyRoundRobin distributes messages in a rotating sequential manner.\n// If the channel capacity is exceeded, the next channel will be selected and so on.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-channel.go-FanOut": {"response": ["```go\nfunc FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n\tdownstreams := make([]<-chan T, count)\n\tfor i := 0; i < count; i++ {\n\t\tdownstreams[i] = make(chan T, channelsBufferCap)\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\tclose(downstreams[i].(chan T))\n\t\t\t}\n\t\t}()\n\n\t\tfor msg := range upstream {\n\t\t\tfor i := 0; i < count; i++ {\n\t\t\t\tselect {\n\t\t\t\tcase downstreams[i].(chan T) <- msg:\n\t\t\t\tdefault:\n\t\t\t\t\ti--\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}()\n\n\treturn downstreams\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n# Natural Language Annotations: // FanOut broadcasts all the upstream messages to multiple downstream channels.\n// When upstream channel reach EOF, downstream channels close. If any downstream\n// channels is full, broadcasting is paused.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-slice.go-Shuffle": {"response": ["```go\nfunc Shuffle[T any, Slice ~[]T](collection Slice) Slice {\n    rand.Seed(time.Now().UnixNano())\n    for i := len(collection) - 1; i > 0; i-- {\n        j := rand.Intn(i + 1)\n        collection[i], collection[j] = collection[j], collection[i]\n    }\n    return collection\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Shuffle[T any, Slice ~[]T](collection Slice) Slice {\n# Natural Language Annotations: // Shuffle returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.\n// Play: https://go.dev/play/p/Qp73bnTDnc7\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-slice.go-Fill": {"response": ["```go\nfunc Fill[T Clonable[T]](collection []T, initial T) []T {\n\tresult := make([]T, len(collection))\n\tfor i := range result {\n\t\tresult[i] = initial.Clone()\n\t}\n\treturn result\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Fill[T Clonable[T]](collection []T, initial T) []T {\n# Natural Language Annotations: // Fill fills elements of array with `initial` value.\n// Play: https://go.dev/play/p/VwR34GzqEub\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-slice.go-Repeat": {"response": ["```go\nfunc Repeat[T Clonable[T]](count int, initial T) []T {\n\tresult := make([]T, count)\n\tfor i := range result {\n\t\tresult[i] = initial.Clone()\n\t}\n\treturn result\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Repeat[T Clonable[T]](count int, initial T) []T {\n# Natural Language Annotations: // Repeat builds a slice with N copies of initial value.\n// Play: https://go.dev/play/p/g3uHXbmc3b6\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-slice.go-DropByIndex": {"response": ["```go\nfunc DropByIndex[T any](collection []T, indexes ...int) []T {\n\tif len(indexes) == 0 {\n\t\treturn collection\n\t}\n\n\tresult := make([]T, 0, len(collection))\n\tdropMap := make(map[int]bool)\n\n\tfor _, index := range indexes {\n\t\tif index < 0 {\n\t\t\tindex += len(collection)\n\t\t}\n\t\tif index >= 0 && index < len(collection) {\n\t\t\tdropMap[index] = true\n\t\t}\n\t}\n\n\tfor i, item := range collection {\n\t\tif !dropMap[i] {\n\t\t\tresult = append(result, item)\n\t\t}\n\t}\n\n\treturn result\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DropByIndex[T any](collection []T, indexes ...int) []T {\n# Natural Language Annotations: // DropByIndex drops elements from a slice or array by the index.\n// A negative index will drop elements from the end of the slice.\n// Play: https://go.dev/play/p/bPIH4npZRxS\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-intersect.go-Some": {"response": ["```go\nfunc Some[T comparable](collection []T, subset []T) bool {\n    if len(subset) == 0 {\n        return false\n    }\n\n    set := make(map[T]struct{}, len(collection))\n    for _, item := range collection {\n        set[item] = struct{}{}\n    }\n\n    for _, item := range subset {\n        if _, ok := set[item]; ok {\n            return true\n        }\n    }\n\n    return false\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Some[T comparable](collection []T, subset []T) bool {\n# Natural Language Annotations: // Some returns true if at least 1 element of a subset is contained into a collection.\n// If the subset is empty Some returns false.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-find.go-FindKeyBy": {"response": ["```go\nfunc FindKeyBy[K comparable, V any](object map[K]V, predicate func(key K, value V) bool) (K, bool) {\n\tfor key, value := range object {\n\t\tif predicate(key, value) {\n\t\t\treturn key, true\n\t\t}\n\t}\n\tvar zeroKey K\n\treturn zeroKey, false\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FindKeyBy[K comparable, V any](object map[K]V, predicate func(key K, value V) bool) (K, bool) {\n# Natural Language Annotations: // FindKeyBy returns the key of the first element predicate returns truthy for.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-find.go-FirstOr": {"response": ["```go\nfunc FirstOr[T any](collection []T, fallback T) T {\n    if len(collection) > 0 {\n        return collection[0]\n    }\n    return fallback\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FirstOr[T any](collection []T, fallback T) T {\n# Natural Language Annotations: // FirstOr returns the first element of a collection or the fallback value if empty.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-find.go-LastOr": {"response": ["```go\nfunc LastOr[T any](collection []T, fallback T) T {\n    if len(collection) == 0 {\n        return fallback\n    }\n    return collection[len(collection)-1]\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func LastOr[T any](collection []T, fallback T) T {\n# Natural Language Annotations: // LastOr returns the last element of a collection or the fallback value if empty.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-math.go-Range": {"response": ["```go\nfunc Range(elementNum int) []int {\n    numbers := make([]int, elementNum)\n    for i := 0; i < elementNum; i++ {\n        numbers[i] = i\n    }\n    return numbers\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Range(elementNum int) []int {\n# Natural Language Annotations: // Range creates an array of numbers (positive and/or negative) with given length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-math.go-RangeFrom": {"response": ["```\nfunc RangeFrom[T constraints.Integer | constraints.Float](start T, elementNum int) []T {\n    result := make([]T, elementNum)\n    for i := 0; i < elementNum; i++ {\n        result[i] = start + T(i)\n    }\n    return result\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RangeFrom[T constraints.Integer | constraints.Float](start T, elementNum int) []T {\n# Natural Language Annotations: // RangeFrom creates an array of numbers from start with specified length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-math.go-Mean": {"response": ["```go\nfunc Mean[T constraints.Float | constraints.Integer](collection []T) T {\n    if len(collection) == 0 {\n        var zero T\n        return zero\n    }\n\n    var sum T\n    for _, value := range collection {\n        sum += value\n    }\n\n    return sum / T(len(collection))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Mean[T constraints.Float | constraints.Integer](collection []T) T {\n# Natural Language Annotations: // Mean calculates the mean of a collection of numbers.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "lo-math.go-MeanBy": {"response": ["```go\nfunc MeanBy[T any, R constraints.Float | constraints.Integer](collection []T, iteratee func(item T) R) R {\n    if len(collection) == 0 {\n        var zero R\n        return zero\n    }\n\n    var sum R\n    for _, item := range collection {\n        sum += iteratee(item)\n    }\n\n    return sum / R(len(collection))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MeanBy[T any, R constraints.Float | constraints.Integer](collection []T, iteratee func(item T) R) R {\n# Natural Language Annotations: // MeanBy calculates the mean of a collection of numbers using the given return value from the iteration function.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "conc-waitgroup.go-WaitAndRecover": {"response": ["```go\nfunc (h *WaitGroup) WaitAndRecover() *panics.Recovered {\n\tvar recovered *panics.Recovered\n\th.wg.Wait()\n\tif len(h.panics) > 0 {\n\t\trecovered = h.panics[0]\n\t}\n\treturn recovered\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (h *WaitGroup) WaitAndRecover() *panics.Recovered {\n# Natural Language Annotations: // WaitAndRecover will block until all goroutines spawned with Go exit and\n// will return a *panics.Recovered if one of the child goroutines panics.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "conc-stream/stream.go-Wait": {"response": ["```go\nfunc (s *Stream) Wait() {\n    s.wg.Wait()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Stream) Wait() {\n# Natural Language Annotations: // Wait signals to the stream that all tasks have been submitted. Wait will\n// not return until all tasks and callbacks have been run.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "OpenGFW-analyzer/udp/internal/quic/packet_protector.go-UnProtect": {"response": ["```go\nfunc (pp *PacketProtector) UnProtect(packet []byte, pnOffset, pnMax int64) ([]byte, error) {\n\tif len(packet) < int(pnOffset+4) {\n\t\treturn nil, fmt.Errorf(\"packet too small: %d (expected >= %d)\", len(packet), pnOffset+4)\n\t}\n\t// The packet number can be up to 4 bytes long, but we won't know the length until we decrypt it.\n\t// 1. save a copy of the first byte\n\t// 2. decrypt the packet number\n\t// 3. parse the packet number\n\t// 4. restore the first byte\n\tb0 := packet[0]\n\tpnLen := pnOffset + 4\n\n\tnum := make([]byte, 4)\n\tcipher, err := pp.getCipherForPN(pnMax)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcipher.decryptHeader(num, packet[pnOffset:pnLen], pp.ad)\n\tpn := protocol.PacketNumber(binary.BigEndian.Uint32(num))\n\tpacket[0] = b0\n\tpacket = packet[:pnOffset+protocol.GetPacketNumberLength(pn)]\n\n\t// The real packet starts after the packet number.\n\t// Decrypt it using the cipher for the packet number.\n\tdata := packet[pnOffset+int(protocol.GetPacketNumberLength(pn)):]\n\tcipher.decryptBody(data, data, pp.packetNumber, pp.ad)\n\tpp.packetNumber++\n\treturn packet, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (pp *PacketProtector) UnProtect(packet []byte, pnOffset, pnMax int64) ([]byte, error) {\n# Natural Language Annotations: // UnProtect decrypts a QUIC packet.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "hatchet-pkg/encryption/local.go-NewLocalEncryption": {"response": ["```go\nfunc NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*localEncryptionService, error) {\n\tmasterKeyBlock, _ := pem.Decode(masterKey)\n\tif masterKeyBlock == nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse master key PEM block\")\n\t}\n\n\tprivateKeyBlock, _ := pem.Decode(privateEc256)\n\tif privateKeyBlock == nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse private key PEM block\")\n\t}\n\n\tpublicKeyBlock, _ := pem.Decode(publicEc256)\n\tif publicKeyBlock == nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse public key PEM block\")\n\t}\n\n\tprivateKey, err := x509.ParseECPrivateKey(privateKeyBlock.Bytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse private key: %w\", err)\n\t}\n\n\tpublicKey, err := x509.ParsePKIXPublicKey(publicKeyBlock.Bytes)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to parse public key: %w\", err)\n\t}\n\n\treturn &localEncryptionService{\n\t\tmasterKey:  masterKeyBlock.Bytes,\n\t\tprivateKey: privateKey,\n\t\tpublicKey:  publicKey.(*ecdsa.PublicKey),\n\t}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*localEncryptionService, error) {\n# Natural Language Annotations: // NewLocalEncryption creates a new local encryption service. keysetBytes is the raw keyset in\n// base64-encoded JSON format. This can be generated by calling hatchet-admin keyset create-local.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "hatchet-pkg/encryption/cloudkms.go-NewCloudKMSEncryption": {"response": ["```go\nfunc NewCloudKMSEncryption(keyUri string, credentialsJSON, privateEc256, publicEc256 []byte) (*cloudkmsEncryptionService, error) {\n\tctx := context.Background()\n\tclient, err := kms.NewKeyManagementClient(ctx, option.WithCredentialsJSON(credentialsJSON))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create KMS client: %v\", err)\n\t}\n\n\tkeyName, err := kmspb.ParseCryptoKeyName(keyUri)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"invalid key URI: %v\", err)\n\t}\n\n\treturn &cloudkmsEncryptionService{\n\t\tkmsClient:     client,\n\t\tkeyName:       keyName,\n\t\tprivateEc256:  privateEc256,\n\t\tpublicEc256:   publicEc256,\n\t\tcredentialsJSON: credentialsJSON,\n\t}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewCloudKMSEncryption(keyUri string, credentialsJSON, privateEc256, publicEc256 []byte) (*cloudkmsEncryptionService, error) {\n# Natural Language Annotations: // NewCloudKMSEncryption creates a GCP CloudKMS-backed encryption service.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "hatchet-internal/datautils/render.go-RenderTemplateFields": {"response": ["```go\nfunc RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n\toutput := make(map[string]interface{})\n\n\tfor key, value := range input {\n\t\tswitch v := value.(type) {\n\t\tcase string:\n\t\t\trendered, err := renderTemplate(v, data)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toutput[key] = rendered\n\t\tcase map[string]interface{}:\n\t\t\trendered, err := RenderTemplateFields(data, v)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\toutput[key] = rendered\n\t\tdefault:\n\t\t\toutput[key] = v\n\t\t}\n\t}\n\n\treturn output, nil\n}\n\nfunc renderTemplate(template string, data map[string]interface{}) (string, error) {\n\ttmpl, err := template.New(\"\").Parse(template)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tvar buf bytes.Buffer\n\terr = tmpl.Execute(&buf, data)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn buf.String(), nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n# Natural Language Annotations: // RenderTemplateFields recursively processes the input map, rendering any string fields using the data map.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-ratelimit/ratelimit.go-Reset": {"response": ["```go\nfunc (l *Limiter) Reset(ip net.IP, tm time.Time) {\n    key := ip.String()\n    l.mu.Lock()\n    defer l.mu.Unlock()\n\n    // Reset the counter for the specific IP\n    delete(l.counters, key)\n\n    // Subtract from the masked IP counters\n    mask := ip.DefaultMask()\n    maskedIP := ip.Mask(mask)\n    maskedKey := maskedIP.String()\n\n    if maskedCount, ok := l.counters[maskedKey]; ok {\n        if maskedCount > 0 {\n            l.counters[maskedKey]--\n        }\n        if l.counters[maskedKey] == 0 {\n            delete(l.counters, maskedKey)\n        }\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (l *Limiter) Reset(ip net.IP, tm time.Time) {\n# Natural Language Annotations: // Reset sets the counter to 0 for key and ip, and subtracts from the ipmasked counts.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dns/dns.go-ParseDomainLax": {"response": ["```go\nfunc ParseDomainLax(s string) (Domain, error) {\n    if !Pedantic && isASCII(s) {\n        labels := strings.Split(s, \".\")\n        for i, label := range labels {\n            if strings.Contains(label, \"_\") {\n                labels[i] = strings.ReplaceAll(label, \"_\", \"-\")\n            }\n        }\n        s = strings.Join(labels, \".\")\n    }\n    return ParseDomain(s)\n}\n\nfunc isASCII(s string) bool {\n    for i := 0; i < len(s); i++ {\n        if s[i] > 127 {\n            return false\n        }\n    }\n    return true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseDomainLax(s string) (Domain, error) {\n# Natural Language Annotations: // ParseDomainLax parses a domain like ParseDomain, but allows labels with\n// underscores if the entire domain name is ASCII-only non-IDNA and Pedantic mode\n// is not enabled. Used for interoperability, e.g. domains may specify MX\n// targets with underscores.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dmarcdb/eval.go-AddEvaluation": {"response": ["```go\nfunc AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n    // Calculate the interval hours based on the aggregate reporting interval seconds\n    e.IntervalHours = aggregateReportingIntervalSeconds / 3600\n\n    // Insert the evaluation into the database\n    _, err := db.ExecContext(ctx, `\n        INSERT INTO evaluations (\n            source_ip, count, disposition, dkim_result, spf_result, header_from,\n            envelope_from, dkim_domain, spf_domain, interval_hours\n        )\n        VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\n    `, e.SourceIP, e.Count, e.Disposition, e.DKIMResult, e.SPFResult, e.HeaderFrom,\n        e.EnvelopeFrom, e.DKIMDomain, e.SPFDomain, e.IntervalHours)\n    if err != nil {\n        return fmt.Errorf(\"failed to insert evaluation: %w\", err)\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n# Natural Language Annotations: // AddEvaluation adds the result of a DMARC evaluation for an incoming message\n// to the database.\n//\n// AddEvaluation sets Evaluation.IntervalHours based on\n// aggregateReportingIntervalSeconds.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dmarcdb/eval.go-EvaluationStats": {"response": ["```go\nfunc EvaluationStats(ctx context.Context) (map[string]EvaluationStat, error) {\n    stats := make(map[string]EvaluationStat)\n\n    // Query the database to get evaluation counts and report-sending status per domain\n    rows, err := db.QueryContext(ctx, `\n        SELECT\n            domain,\n            COUNT(*) AS total_evaluations,\n            SUM(CASE WHEN report_sent = true THEN 1 ELSE 0 END) AS reports_sent\n        FROM evaluations\n        GROUP BY domain\n    `)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to query evaluation stats: %v\", err)\n    }\n    defer rows.Close()\n\n    for rows.Next() {\n        var stat EvaluationStat\n        var domain string\n        err := rows.Scan(&domain, &stat.TotalEvaluations, &stat.ReportsSent)\n        if err != nil {\n            return nil, fmt.Errorf(\"failed to scan evaluation stat: %v\", err)\n        }\n        stats[domain] = stat\n    }\n\n    if err := rows.Err(); err != nil {\n        return nil, fmt.Errorf(\"failed to iterate over evaluation stats: %v\", err)\n    }\n\n    return stats, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EvaluationStats(ctx context.Context) (map[string]EvaluationStat, error) {\n# Natural Language Annotations: // EvaluationStats returns evaluation counts and report-sending status per domain.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dmarcdb/eval.go-EvaluationsDomain": {"response": ["```go\nfunc EvaluationsDomain(ctx context.Context, domain dns.Domain) ([]Evaluation, error) {\n    // Prepare the SQL query to fetch evaluations for the given domain\n    query := `\n        SELECT id, domain_id, status, created_at, updated_at\n        FROM evaluations\n        WHERE domain_id = $1\n    `\n\n    // Execute the query with the domain ID as a parameter\n    rows, err := db.QueryContext(ctx, query, domain.ID)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to fetch evaluations: %v\", err)\n    }\n    defer rows.Close()\n\n    // Create a slice to store the evaluations\n    evaluations := []Evaluation{}\n\n    // Iterate over the rows and scan the evaluation data into the Evaluation struct\n    for rows.Next() {\n        var evaluation Evaluation\n        err := rows.Scan(\n            &evaluation.ID,\n            &evaluation.DomainID,\n            &evaluation.Status,\n            &evaluation.CreatedAt,\n            &evaluation.UpdatedAt,\n        )\n        if err != nil {\n            return nil, fmt.Errorf(\"failed to scan evaluation: %v\", err)\n        }\n        evaluations = append(evaluations, evaluation)\n    }\n\n    // Check for any errors that occurred during iteration\n    if err := rows.Err(); err != nil {\n        return nil, fmt.Errorf(\"failed to iterate over evaluations: %v\", err)\n    }\n\n    return evaluations, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EvaluationsDomain(ctx context.Context, domain dns.Domain) ([]Evaluation, error) {\n# Natural Language Annotations: // EvaluationsDomain returns all evaluations for a domain.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dmarcdb/eval.go-RemoveEvaluationsDomain": {"response": ["```go\nfunc RemoveEvaluationsDomain(ctx context.Context, domain dns.Domain) error {\n    // Get the database connection from the context\n    db, err := database.FromContext(ctx)\n    if err != nil {\n        return err\n    }\n\n    // Start a transaction\n    tx, err := db.BeginTx(ctx, nil)\n    if err != nil {\n        return err\n    }\n    defer tx.Rollback()\n\n    // Delete evaluations for the specified domain\n    _, err = tx.ExecContext(ctx, \"DELETE FROM evaluations WHERE domain = ?\", domain)\n    if err != nil {\n        return err\n    }\n\n    // Commit the transaction\n    if err := tx.Commit(); err != nil {\n        return err\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RemoveEvaluationsDomain(ctx context.Context, domain dns.Domain) error {\n# Natural Language Annotations: // RemoveEvaluationsDomain removes evaluations for domain so they won't be sent in\n// an aggregate report.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dmarcdb/reports.go-AddReport": {"response": ["```go\nfunc AddReport(ctx context.Context, f *dmarcrpt.Feedback, fromDomain dns.Domain) error {\n    // Extract relevant data from the feedback report\n    orgName := f.PolicyPublished.Domain\n    reportID := f.ReportMetadata.ReportID\n    beginTime := f.ReportMetadata.DateRange.Begin\n    endTime := f.ReportMetadata.DateRange.End\n\n    // Create a new report record\n    report := &Report{\n        OrgName:    orgName,\n        ReportID:   reportID,\n        FromDomain: fromDomain,\n        BeginTime:  beginTime,\n        EndTime:    endTime,\n    }\n\n    // Save the report to the database\n    err := db.SaveReport(ctx, report)\n    if err != nil {\n        return fmt.Errorf(\"failed to save report: %v\", err)\n    }\n\n    // Update Prometheus metrics\n    metrics.ReportsReceived.Inc()\n    metrics.ReportsProcessed.Inc()\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func AddReport(ctx context.Context, f *dmarcrpt.Feedback, fromDomain dns.Domain) error {\n# Natural Language Annotations: // AddReport adds a DMARC aggregate feedback report from an email to the database,\n// and updates prometheus metrics.\n//\n// fromDomain is the domain in the report message From header.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-junk/bloom.go-NewBloom": {"response": ["```go\nfunc NewBloom(data []byte, k int) (*Bloom, error) {\n\tif len(data) == 0 || len(data)&(len(data)-1) != 0 {\n\t\treturn nil, errors.New(\"data length must be a power of 2\")\n\t}\n\tif k <= 0 {\n\t\treturn nil, errors.New(\"k must be positive\")\n\t}\n\twidth := bits.Len(uint(len(data) - 1))\n\tif k*width > 256 {\n\t\treturn nil, errors.New(\"k * width must not exceed 256\")\n\t}\n\treturn &Bloom{data: data, k: k, width: width}, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBloom(data []byte, k int) (*Bloom, error) {\n# Natural Language Annotations: // NewBloom returns a bloom filter with given initial data.\n//\n// The number of bits in data must be a power of 2.\n// K is the number of \"hashes\" (bits) to store/lookup for each value stored.\n// Width is calculated as the number of bits needed to represent a single bit/hash\n// position in the data.\n//\n// For each value stored/looked up, a hash over the value is calculated. The hash\n// is split into \"k\" values that are \"width\" bits wide, each used to lookup a bit.\n// K * width must not exceed 256.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-junk/filter.go-NewFilter": {"response": ["```go\nfunc NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n    if _, err := os.Stat(dbPath); !os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"database file already exists: %s\", dbPath)\n    }\n    if _, err := os.Stat(bloomPath); !os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"bloom filter file already exists: %s\", bloomPath)\n    }\n\n    db, err := bolt.Open(dbPath, 0600, &bolt.Options{Timeout: 1 * time.Second})\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to open database file: %v\", err)\n    }\n\n    bf, err := bloom.NewWithEstimates(params.BloomN, params.BloomP)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create bloom filter: %v\", err)\n    }\n\n    return &Filter{\n        log:       log,\n        params:    params,\n        db:        db,\n        dbPath:    dbPath,\n        bf:        bf,\n        bloomPath: bloomPath,\n        isNew:     true,\n    }, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n# Natural Language Annotations: // NewFilter creates a new filter with empty bloom filter and database files. The\n// filter is marked as new until the first save, will be done automatically if\n// TrainDirs is called. If the bloom and/or database files exist, an error is\n// returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-junk/filter.go-ClassifyMessagePath": {"response": ["```go\nfunc (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham, nspam int, rerr error) {\n\tdata, err := ioutil.ReadFile(path)\n\tif err != nil {\n\t\treturn 0, nil, 0, 0, err\n\t}\n\treturn f.ClassifyMessage(ctx, string(data))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham, nspam int, rerr error) {\n# Natural Language Annotations: // ClassifyMessagePath is a convenience wrapper for calling ClassifyMessage on a file.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-junk/filter.go-TrainDirs": {"response": ["```go\n// TrainDirs trains and saves a filter with mail messages from different types\n// of directories.\nfunc (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n    for _, file := range hamFiles {\n        err := f.TrainFile(hamDir+\"/\"+file, Ham)\n        if err != nil {\n            return err\n        }\n    }\n\n    for _, file := range sentFiles {\n        err := f.TrainFile(sentDir+\"/\"+file, Sent)\n        if err != nil {\n            return err\n        }\n    }\n\n    for _, file := range spamFiles {\n        err := f.TrainFile(spamDir+\"/\"+file, Spam)\n        if err != nil {\n            return err\n        }\n    }\n\n    return f.Save()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n# Natural Language Annotations: // TrainDirs trains and saves a filter with mail messages from different types\n// of directories.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-webmail/message.go-parseListPostAddress": {"response": ["```go\nfunc parseListPostAddress(s string) *MessageAddress {\n    if len(s) == 0 {\n        return nil\n    }\n\n    if s[0] == '<' {\n        end := strings.IndexByte(s, '>')\n        if end == -1 {\n            return nil\n        }\n        return parseAddress(s[1:end])\n    }\n\n    fields := strings.Fields(s)\n    if len(fields) == 0 {\n        return nil\n    }\n\n    return parseAddress(fields[0])\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func parseListPostAddress(s string) *MessageAddress {\n# Natural Language Annotations: // parses List-Post header, returning an address if it could be found, and nil otherwise.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-webmail/webmail.go-sanitizeNode": {"response": ["```go\nfunc sanitizeNode(node *html.Node) {\n\tif node.Type == html.ElementNode {\n\t\tif node.Data == \"script\" {\n\t\t\tnode.Parent.RemoveChild(node)\n\t\t\treturn\n\t\t}\n\n\t\tfor i := 0; i < len(node.Attr); i++ {\n\t\t\tattr := node.Attr[i]\n\t\t\tif strings.HasPrefix(attr.Key, \"on\") || (attr.Key == \"href\" && strings.HasPrefix(attr.Val, \"javascript:\")) {\n\t\t\t\tnode.Attr = append(node.Attr[:i], node.Attr[i+1:]...)\n\t\t\t\ti--\n\t\t\t}\n\t\t}\n\n\t\tif node.Data == \"a\" || node.Data == \"base\" {\n\t\t\tnode.Attr = append(node.Attr, html.Attribute{Key: \"target\", Val: \"_blank\"})\n\t\t}\n\t}\n\n\tfor c := node.FirstChild; c != nil; c = c.NextSibling {\n\t\tsanitizeNode(c)\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func sanitizeNode(node *html.Node) {\n# Natural Language Annotations: // sanitizeNode removes script elements, on* attributes, javascript: href\n// attributes, adds target=\"_blank\" to all links and to a base tag.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dnsbl/dnsbl.go-Lookup": {"response": ["```go\nfunc Lookup(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain, ip net.IP) (rstatus Status, rexplanation string, rerr error) {\n\treverseIP := dns.ReverseIP(ip)\n\tquery := fmt.Sprintf(\"%s.%s\", reverseIP, zone)\n\n\telog.Debug(\"performing DNS lookup\", \"query\", query)\n\n\tresp, err := resolver.LookupHost(ctx, query)\n\tif err != nil {\n\t\tif dnsErr, ok := err.(*net.DNSError); ok && dnsErr.IsNotFound {\n\t\t\telog.Debug(\"IP not found in block list\", \"ip\", ip, \"zone\", zone)\n\t\t\treturn StatusNotListed, \"IP not found in block list\", nil\n\t\t}\n\t\telog.Error(\"failed to perform DNS lookup\", \"query\", query, \"error\", err)\n\t\treturn StatusError, \"Failed to perform DNS lookup\", err\n\t}\n\n\tif len(resp) > 0 {\n\t\telog.Info(\"IP found in block list\", \"ip\", ip, \"zone\", zone)\n\t\treturn StatusListed, \"IP found in block list\", nil\n\t}\n\n\telog.Debug(\"IP not found in block list\", \"ip\", ip, \"zone\", zone)\n\treturn StatusNotListed, \"IP not found in block list\", nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Lookup(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain, ip net.IP) (rstatus Status, rexplanation string, rerr error) {\n# Natural Language Annotations: // Lookup checks if \"ip\" occurs in the DNS block list \"zone\" (e.g. dnsbl.example.org).\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dnsbl/dnsbl.go-CheckHealth": {"response": ["```go\nfunc CheckHealth(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain) (rerr error) {\n\t// Check if 127.0.0.2 is present in the DNSBL\n\tpresent, err := resolver.LookupHost(ctx, \"2.0.0.127.\"+string(zone))\n\tif err != nil {\n\t\telog.Error(\"failed to lookup 127.0.0.2\", \"zone\", zone, \"error\", err)\n\t\treturn ErrDNS\n\t}\n\tif len(present) == 0 {\n\t\telog.Error(\"127.0.0.2 not found in DNSBL\", \"zone\", zone)\n\t\treturn ErrDNSBLNotWorking\n\t}\n\n\t// Check if 127.0.0.1 is not present in the DNSBL\n\tnotPresent, err := resolver.LookupHost(ctx, \"1.0.0.127.\"+string(zone))\n\tif err != nil {\n\t\telog.Error(\"failed to lookup 127.0.0.1\", \"zone\", zone, \"error\", err)\n\t\treturn ErrDNS\n\t}\n\tif len(notPresent) > 0 {\n\t\telog.Error(\"127.0.0.1 found in DNSBL\", \"zone\", zone)\n\t\treturn ErrDNSBLNotWorking\n\t}\n\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CheckHealth(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain) (rerr error) {\n# Natural Language Annotations: // CheckHealth checks whether the DNSBL \"zone\" is operating correctly by\n// querying for 127.0.0.2 (must be present) and 127.0.0.1 (must not be present).\n// Users of a DNSBL should periodically check if the DNSBL is still operating\n// properly.\n// For temporary errors, ErrDNS is returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dmarcrpt/parse.go-ParseMessageReport": {"response": ["```go\nfunc ParseMessageReport(elog *slog.Logger, r io.ReaderAt) (*Feedback, error) {\n    const maxMessageSize = 15 * 1024 * 1024\n    const maxReportSize = 20 * 1024 * 1024\n\n    // Check message size\n    size := r.Size()\n    if size > maxMessageSize {\n        return nil, fmt.Errorf(\"message size exceeds the maximum allowed size of 15MB\")\n    }\n\n    // Read the message content\n    content := make([]byte, size)\n    if _, err := r.ReadAt(content, 0); err != nil {\n        return nil, fmt.Errorf(\"failed to read message content: %v\", err)\n    }\n\n    // Parse the message\n    msg, err := mail.ReadMessage(bytes.NewReader(content))\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to parse message: %v\", err)\n    }\n\n    // Find the attachment with the report\n    var reportData []byte\n    for _, part := range msg.Body {\n        if part.Disposition == \"attachment\" && strings.HasSuffix(part.Filename, \".gz\") {\n            reportData, err = io.ReadAll(part.Body)\n            if err != nil {\n                return nil, fmt.Errorf(\"failed to read attachment: %v\", err)\n            }\n            break\n        }\n    }\n\n    if len(reportData) == 0 {\n        return nil, fmt.Errorf(\"no report attachment found\")\n    }\n\n    // Decompress the report\n    gzipReader, err := gzip.NewReader(bytes.NewReader(reportData))\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create gzip reader: %v\", err)\n    }\n    defer gzipReader.Close()\n\n    decompressedReport, err := io.ReadAll(gzipReader)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to decompress report: %v\", err)\n    }\n\n    if len(decompressedReport) > maxReportSize {\n        return nil, fmt.Errorf(\"decompressed report size exceeds the maximum allowed size of 20MB\")\n    }\n\n    // Parse the decompressed report\n    var feedback Feedback\n    if err := json.Unmarshal(decompressedReport, &feedback); err != nil {\n        return nil, fmt.Errorf(\"failed to parse report: %v\", err)\n    }\n\n    return &feedback, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseMessageReport(elog *slog.Logger, r io.ReaderAt) (*Feedback, error) {\n# Natural Language Annotations: // ParseMessageReport parses an aggregate feedback report from a mail message. The\n// maximum message size is 15MB, the maximum report size after decompression is\n// 20MB.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-mox-/lifecycle.go-Register": {"response": ["```go\nfunc (c *connections) Register(nc net.Conn, protocol, listener string) {\n    c.mu.Lock()\n    defer c.mu.Unlock()\n\n    if c.conns == nil {\n        c.conns = make(map[*connection]struct{})\n    }\n\n    conn := &connection{\n        nc:       nc,\n        protocol: protocol,\n        listener: listener,\n    }\n\n    c.conns[conn] = struct{}{}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *connections) Register(nc net.Conn, protocol, listener string) {\n# Natural Language Annotations: // Register adds a connection for receiving an immediate i/o deadline on shutdown.\n// When the connection is closed, Remove must be called to cancel the registration.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-smtpclient/dial.go-Dial": {"response": ["```go\nfunc Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n\tvar lastErr error\n\tfor _, ip := range ips {\n\t\tipStr := ip.String()\n\t\tpreviousIPs, ok := dialedIPs[ipStr]\n\t\tif !ok {\n\t\t\tpreviousIPs = make([]net.IP, 0)\n\t\t}\n\n\t\t// Prefer a different IP family than the previous attempt\n\t\tif len(previousIPs) > 0 {\n\t\t\tif previousIPs[0].To4() != nil {\n\t\t\t\t// Previous attempt was IPv4, try IPv6 first\n\t\t\t\tif ip.To4() == nil {\n\t\t\t\t\tconn, rerr = dialWithLocalIP(ctx, elog, dialer, host, ip, port, localIPs)\n\t\t\t\t\tif rerr == nil {\n\t\t\t\t\t\tdialedIPs[ipStr] = append(previousIPs, ip)\n\t\t\t\t\t\treturn conn, ip, nil\n\t\t\t\t\t}\n\t\t\t\t\tlastErr = rerr\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Previous attempt was IPv6, try IPv4 first\n\t\t\t\tif ip.To4() != nil {\n\t\t\t\t\tconn, rerr = dialWithLocalIP(ctx, elog, dialer, host, ip, port, localIPs)\n\t\t\t\t\tif rerr == nil {\n\t\t\t\t\t\tdialedIPs[ipStr] = append(previousIPs, ip)\n\t\t\t\t\t\treturn conn, ip, nil\n\t\t\t\t\t}\n\t\t\t\t\tlastErr = rerr\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Try the same IP as the previous attempt\n\t\tif len(previousIPs) > 0 && previousIPs[0].Equal(ip) {\n\t\t\tconn, rerr = dialWithLocalIP(ctx, elog, dialer, host, ip, port, localIPs)\n\t\t\tif rerr == nil {\n\t\t\t\tdialedIPs[ipStr] = append(previousIPs, ip)\n\t\t\t\treturn conn, ip, nil\n\t\t\t}\n\t\t\tlastErr = rerr\n\t\t}\n\n\t\t// Try the remaining IPs\n\t\tconn, rerr = dialWithLocalIP(ctx, elog, dialer, host, ip, port, localIPs)\n\t\tif rerr == nil {\n\t\t\tdialedIPs[ipStr] = append(previousIPs, ip)\n\t\t\treturn conn, ip, nil\n\t\t}\n\t\tlastErr = rerr\n\t}\n\n\treturn nil, nil, lastErr\n}\n\nfunc dialWithLocalIP(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ip net.IP, port int, localIPs []net.IP) (net.Conn, error) {\n\tvar localIP net.IP\n\tfor _, lip := range localIPs {\n\t\tif lip.To4() != nil && ip.To4() != nil {\n\t\t\tlocalIP = lip\n\t\t\tbreak\n\t\t} else if lip.To4() == nil && ip.To4() == nil {\n\t\t\tlocalIP = lip\n\t\t\tbreak\n\t\t}\n\t}\n\n\tdialer = dialer.WithLocalIP(localIP)\n\treturn dialer.DialContext(ctx, \"tcp\", net.JoinHostPort(ip.String(), strconv.Itoa(port)))\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n# Natural Language Annotations: // Dial connects to host by dialing ips, taking previous attempts in dialedIPs into\n// accounts (for greylisting, blocklisting and ipv4/ipv6).\n//\n// If the previous attempt used IPv4, this attempt will use IPv6 (useful in case\n// one of the IPs is in a DNSBL).\n//\n// The second attempt for an address family we prefer the same IP as earlier, to\n// increase our chances if remote is doing greylisting.\n//\n// Dial updates dialedIPs, callers may want to save it so it can be taken into\n// account for future delivery attempts.\n//\n// The first matching protocol family from localIPs is set for the local side\n// of the TCP connection.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-smtpclient/gather.go-GatherIPs": {"response": ["```go\nfunc GatherIPs(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, network string, host dns.IPDomain, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n    // Resolve the host to get the expanded host and IPs\n    expandedHost, ips, err := resolver.LookupIPAddr(ctx, host.Domain())\n    if err != nil {\n        rerr = fmt.Errorf(\"failed to resolve host: %w\", err)\n        return\n    }\n\n    // Check if the DNS responses were authentic\n    authentic = resolver.IsAuthentic(ctx, host.Domain())\n    expandedAuthentic = resolver.IsAuthentic(ctx, expandedHost)\n\n    // Order the IPs based on previous attempts\n    orderedIPs := orderIPs(ips, dialedIPs[expandedHost.String()])\n\n    // Check if the host supports both IPv4 and IPv6\n    dualstack = hasDualStack(orderedIPs)\n\n    return authentic, expandedAuthentic, expandedHost, orderedIPs, dualstack, nil\n}\n\nfunc orderIPs(ips []net.IP, dialedIPs []net.IP) []net.IP {\n    // Implement logic to order the IPs based on previous attempts\n    // ...\n}\n\nfunc hasDualStack(ips []net.IP) bool {\n    // Check if the IPs include both IPv4 and IPv6 addresses\n    // ...\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GatherIPs(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, network string, host dns.IPDomain, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n# Natural Language Annotations: // GatherIPs looks up the IPs to try for connecting to host, with the IPs ordered\n// to take previous attempts into account. For use with DANE, the CNAME-expanded\n// name is returned, and whether the DNS responses were authentic.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-tlsrpt/report.go-TLSFailureDetails": {"response": ["```go\nfunc TLSFailureDetails(err error) (ResultType, string) {\n\tswitch e := err.(type) {\n\tcase *tls.RecordHeaderError:\n\t\treturn ResultType_Protocol, \"record_header_error\"\n\tcase *tls.alert:\n\t\tswitch e.alertType {\n\t\tcase tls.alertCloseNotify:\n\t\t\treturn ResultType_TLS, \"close_notify\"\n\t\tcase tls.alertUnexpectedMessage:\n\t\t\treturn ResultType_TLS, \"unexpected_message\"\n\t\tcase tls.alertBadRecordMAC:\n\t\t\treturn ResultType_TLS, \"bad_record_mac\"\n\t\tcase tls.alertDecryptionFailed:\n\t\t\treturn ResultType_TLS, \"decryption_failed\"\n\t\tcase tls.alertRecordOverflow:\n\t\t\treturn ResultType_TLS, \"record_overflow\"\n\t\tcase tls.alertDecompressionFailure:\n\t\t\treturn ResultType_TLS, \"decompression_failure\"\n\t\tcase tls.alertHandshakeFailure:\n\t\t\treturn ResultType_TLS, \"handshake_failure\"\n\t\tcase tls.alertNoCertificate:\n\t\t\treturn ResultType_TLS, \"no_certificate\"\n\t\tcase tls.alertBadCertificate:\n\t\t\treturn ResultType_TLS, \"bad_certificate\"\n\t\tcase tls.alertUnsupportedCertificate:\n\t\t\treturn ResultType_TLS, \"unsupported_certificate\"\n\t\tcase tls.alertCertificateRevoked:\n\t\t\treturn ResultType_TLS, \"certificate_revoked\"\n\t\tcase tls.alertCertificateExpired:\n\t\t\treturn ResultType_TLS, \"certificate_expired\"\n\t\tcase tls.alertCertificateUnknown:\n\t\t\treturn ResultType_TLS, \"certificate_unknown\"\n\t\tcase tls.alertIllegalParameter:\n\t\t\treturn ResultType_TLS, \"illegal_parameter\"\n\t\tcase tls.alertUnknownCA:\n\t\t\treturn ResultType_TLS, \"unknown_ca\"\n\t\tcase tls.alertAccessDenied:\n\t\t\treturn ResultType_TLS, \"access_denied\"\n\t\tcase tls.alertDecodeError:\n\t\t\treturn ResultType_TLS, \"decode_error\"\n\t\tcase tls.alertDecryptError:\n\t\t\treturn ResultType_TLS, \"decrypt_error\"\n\t\tcase tls.alertExportRestriction:\n\t\t\treturn ResultType_TLS, \"export_restriction\"\n\t\tcase tls.alertProtocolVersion:\n\t\t\treturn ResultType_TLS, \"protocol_version\"\n\t\tcase tls.alertInsufficientSecurity:\n\t\t\treturn ResultType_TLS, \"insufficient_security\"\n\t\tcase tls.alertInternalError:\n\t\t\treturn ResultType_TLS, \"internal_error\"\n\t\tcase tls.alertInappropriateFallback:\n\t\t\treturn ResultType_TLS, \"inappropriate_fallback\"\n\t\tcase tls.alertUserCanceled:\n\t\t\treturn ResultType_TLS, \"user_canceled\"\n\t\tcase tls.alertNoRenegotiation:\n\t\t\treturn ResultType_TLS, \"no_renegotiation\"\n\t\tcase tls.alertMissingExtension:\n\t\t\treturn ResultType_TLS, \"missing_extension\"\n\t\tcase tls.alertUnsupportedExtension:\n\t\t\treturn ResultType_TLS, \"unsupported_extension\"\n\t\tcase tls.alertCertificateUnobtainable:\n\t\t\treturn ResultType_TLS, \"certificate_unobtainable\"\n\t\tcase tls.alertUnrecognizedName:\n\t\t\treturn ResultType_TLS, \"unrecognized_name\"\n\t\tcase tls.alertBadCertificateStatusResponse:\n\t\t\treturn ResultType_TLS, \"bad_certificate_status_response\"\n\t\tcase tls.alertBadCertificateHashValue:\n\t\t\treturn ResultType_TLS, \"bad_certificate_hash_value\"\n\t\tcase tls.alertUnknownPSKIdentity:\n\t\t\treturn ResultType_TLS, \"unknown_psk_identity\"\n\t\tcase tls.alertCertificateRequired:\n\t\t\treturn ResultType_TLS, \"certificate_required\"\n\t\tcase tls.alertNoApplicationProtoc"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TLSFailureDetails(err error) (ResultType, string) {\n# Natural Language Annotations: // TLSFailureDetails turns errors encountered during TLS handshakes into a result\n// type and failure reason code for use with FailureDetails.\n//\n// Errors from crypto/tls, including local and remote alerts, from crypto/x509,\n// and generic i/o and timeout errors are recognized.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-tlsrpt/report.go-ParseMessage": {"response": ["```go\nfunc ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n\tmsg, err := mail.ReadMessage(r)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"reading mail message: %v\", err)\n\t}\n\tmediaType, _, err := mime.ParseMediaType(msg.Header.Get(\"Content-Type\"))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"parsing Content-Type: %v\", err)\n\t}\n\tif !strings.HasPrefix(mediaType, \"multipart/\") {\n\t\treturn nil, fmt.Errorf(\"unrecognized Content-Type prefix %q\", mediaType)\n\t}\n\t// 15MB max message size.\n\tconst maxMsgSize = 15 << 20\n\tif r.Size() > maxMsgSize {\n\t\treturn nil, fmt.Errorf(\"message size %d exceeds maximum %d\", r.Size(), maxMsgSize)\n\t}\n\tmr := multipart.NewReader(msg.Body, msg.Header.Get(\"Content-Type\"))\n\t// Find the first non-text part, which should contain the report.\n\tvar reportPart *multipart.Part\n\tfor {\n\t\tp, err := mr.NextPart()\n\t\tif err == io.EOF {\n\t\t\tbreak\n\t\t}\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"reading MIME parts: %v\", err)\n\t\t}\n\t\tif !strings.HasPrefix(p.Header.Get(\"Content-Type\"), \"text/\") {\n\t\t\treportPart = p\n\t\t\tbreak\n\t\t}\n\t}\n\tif reportPart == nil {\n\t\treturn nil, errors.New(\"no report file found in message\")\n\t}\n\t// 20MB max report size.\n\tconst maxReportSize = 20 << 20\n\t// Decompress the report if necessary.\n\tctype := reportPart.Header.Get(\"Content-Type\")\n\tvar reportReader io.Reader = reportPart\n\tif strings.Contains(ctype, \"gzip\") {\n\t\tgzr, err := gzip.NewReader(reportPart)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"creating gzip reader: %v\", err)\n\t\t}\n\t\tdefer gzr.Close()\n\t\tlr := &io.LimitedReader{R: gzr, N: maxReportSize}\n\t\treportReader = lr\n\t} else {\n\t\tlr := &io.LimitedReader{R: reportPart, N: maxReportSize}\n\t\treportReader = lr\n\t}\n\t// Decode the report.\n\tdec := json.NewDecoder(reportReader)\n\tvar report ReportJSON\n\tif err := dec.Decode(&report); err != nil {\n\t\treturn nil, fmt.Errorf(\"decoding JSON: %v\", err)\n\t}\n\treturn &report, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n# Natural Language Annotations: // ParseMessage parses a Report from a mail message.\n// The maximum size of the message is 15MB, the maximum size of the\n// decompressed report is 20MB.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-spf/received.go-Header": {"response": ["```go\nfunc (r Received) Header() string {\n\tvar sb strings.Builder\n\tsb.WriteString(\"Received-SPF: \")\n\tsb.WriteString(r.Result)\n\tif r.Mechanism != \"\" {\n\t\tsb.WriteString(\" (\")\n\t\tsb.WriteString(r.Mechanism)\n\t\tif r.Comment != \"\" {\n\t\t\tsb.WriteString(\": \")\n\t\t\tsb.WriteString(r.Comment)\n\t\t}\n\t\tsb.WriteString(\")\")\n\t}\n\tif r.ExtraText != \"\" {\n\t\tsb.WriteString(\" \")\n\t\tsb.WriteString(r.ExtraText)\n\t}\n\tsb.WriteString(\"\\r\\n\")\n\treturn sb.String()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r Received) Header() string {\n# Natural Language Annotations: // Header returns a Received-SPF header including trailing crlf that can be\n// prepended to an incoming message.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-spf/spf.go-Evaluate": {"response": ["```go\nfunc Evaluate(ctx context.Context, elog *slog.Logger, record *Record, resolver dns.Resolver, args Args) (rstatus Status, mechanism, rexplanation string, rauthentic bool, rerr error) {\n    // Evaluate the IP and names from args against the SPF DNS record for the domain\n    // Perform DNS lookups and evaluate the SPF mechanisms\n    // Set the resulting status, mechanism, explanation, authentic, and error values\n    // Return the evaluation results\n\n    // Placeholder implementation\n    rstatus = StatusNone\n    mechanism = \"\"\n    rexplanation = \"\"\n    rauthentic = false\n    rerr = nil\n\n    return rstatus, mechanism, rexplanation, rauthentic, rerr\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Evaluate(ctx context.Context, elog *slog.Logger, record *Record, resolver dns.Resolver, args Args) (rstatus Status, mechanism, rexplanation string, rauthentic bool, rerr error) {\n# Natural Language Annotations: // Evaluate evaluates the IP and names from args against the SPF DNS record for the domain.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-spf/parse.go-Record": {"response": ["```go\nfunc (r Record) Record() (string, error) {\n    // Check if the record type is TXT\n    if r.Type != \"TXT\" {\n        return \"\", fmt.Errorf(\"unsupported record type: %s\", r.Type)\n    }\n\n    // Construct the DNS record string\n    record := fmt.Sprintf(\"%s IN TXT %s\", r.Name, r.Value)\n\n    return record, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r Record) Record() (string, error) {\n# Natural Language Annotations: // Record returns an DNS record, to be configured as a TXT record for a domain,\n// e.g. a TXT record for example.com.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-message/part.go-EnsurePart": {"response": ["```go\nfunc EnsurePart(elog *slog.Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n    p, err := Parse(r, size)\n    if err != nil {\n        elog.Error(\"parsing part\", \"error\", err)\n        if strict {\n            return Part{\n                Header: p.Header,\n                Body:   NewBody(r, size, \"application/octet-stream\"),\n            }, err\n        }\n        // Attempt to recover from parsing errors in non-strict mode\n        if p.Header != nil {\n            // If headers were parsed successfully, return the part with an empty body\n            return Part{\n                Header: p.Header,\n                Body:   NewBody(strings.NewReader(\"\"), 0, \"application/octet-stream\"),\n            }, err\n        }\n        // If headers parsing failed, return a part with default headers and the original body\n        return Part{\n            Header: make(textproto.MIMEHeader),\n            Body:   NewBody(r, size, \"application/octet-stream\"),\n        }, err\n    }\n    return p, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EnsurePart(elog *slog.Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n# Natural Language Annotations: // EnsurePart parses a part as with Parse, but ensures a usable part is always\n// returned, even if error is non-nil. If a parse error occurs, the message is\n// returned as application/octet-stream, and headers can still be read if they\n// were valid.\n//\n// If strict is set, fewer attempts are made to continue parsing when errors are\n// encountered, such as with invalid content-type headers or bare carriage returns.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-message/part.go-ParseNextPart": {"response": ["```go\nfunc (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n\tif p.mr == nil {\n\t\treturn nil, errors.New(\"multipart message not initialized\")\n\t}\n\n\tpart, err := p.mr.NextPart()\n\tif err == io.EOF {\n\t\treturn nil, io.EOF\n\t} else if err != nil {\n\t\treturn nil, err\n\t}\n\n\tnp := &Part{\n\t\tHeader: part.Header,\n\t\tParent: p,\n\t}\n\n\tctype := part.Header.Get(\"Content-Type\")\n\tif strings.HasPrefix(ctype, \"multipart/\") {\n\t\tnp.mr = multipart.NewReader(part, params[\"boundary\"])\n\t} else {\n\t\tnp.Body = part\n\t}\n\n\tif cd := part.Header.Get(\"Content-Disposition\"); cd != \"\" {\n\t\tif _, params, err := mime.ParseMediaType(cd); err == nil {\n\t\t\tif params[\"filename\"] != \"\" {\n\t\t\t\tnp.Filename = params[\"filename\"]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn np, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n# Natural Language Annotations: // ParseNextPart parses the next (sub)part of this multipart message.\n// ParseNextPart returns io.EOF and a nil part when there are no more parts.\n// Only used for initial parsing of message. Once parsed, use p.Parts.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-message/messageid.go-MessageIDCanonical": {"response": ["```go\nfunc MessageIDCanonical(s string) (string, bool, error) {\n\tif len(s) < 2 || s[0] != '<' || s[len(s)-1] != '>' {\n\t\treturn \"\", false, errors.New(\"invalid Message-ID format\")\n\t}\n\n\ts = s[1 : len(s)-1]\n\ts = strings.TrimSpace(s)\n\ts = strings.ToLower(s)\n\n\tparts := strings.Split(s, \"@\")\n\tif len(parts) != 2 {\n\t\treturn s, true, nil\n\t}\n\n\tlocalpart := strings.TrimSpace(parts[0])\n\tdomain := strings.TrimSpace(parts[1])\n\n\tif localpart == \"\" || domain == \"\" {\n\t\treturn s, true, nil\n\t}\n\n\treturn localpart + \"@\" + domain, false, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MessageIDCanonical(s string) (string, bool, error) {\n# Natural Language Annotations: // MessageIDCanonical parses the Message-ID, returning a canonical value that is\n// lower-cased, without <>, and no unneeded quoting. For matching in threading,\n// with References/In-Reply-To. If the message-id is invalid (e.g. no <>), an error\n// is returned. If the message-id could not be parsed as address (localpart \"@\"\n// domain), the raw value and the bool return parameter true is returned. It is\n// quite common that message-id's don't adhere to the localpart @ domain\n// syntax.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-message/decode.go-DecodeReader": {"response": ["```go\nfunc DecodeReader(charset string, r io.Reader) io.Reader {\n\tswitch strings.ToLower(charset) {\n\tcase \"\", \"us-ascii\", \"utf-8\":\n\t\treturn r\n\tdefault:\n\t\tif enc, _ := htmlindex.Get(charset); enc != nil {\n\t\t\treturn enc.NewDecoder().Reader(r)\n\t\t}\n\t\treturn r\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DecodeReader(charset string, r io.Reader) io.Reader {\n# Natural Language Annotations: // DecodeReader returns a reader that reads from r, decoding as charset. If\n// charset is empty, us-ascii, utf-8 or unknown, the original reader is\n// returned and no decoding takes place.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-message/referencedids.go-ReferencedIDs": {"response": ["```go\nfunc ReferencedIDs(references []string, inReplyTo []string) ([]string, error) {\n    var ids []string\n\n    // First, try to get message IDs from the References header(s)\n    for _, ref := range references {\n        msgIDs := strings.Fields(ref)\n        for _, msgID := range msgIDs {\n            if msgID != \"\" {\n                canonicalID, err := MessageIDCanonical(msgID)\n                if err != nil {\n                    return nil, err\n                }\n                ids = append(ids, canonicalID)\n            }\n        }\n    }\n\n    // If no message IDs found in References, fallback to In-Reply-To header(s)\n    if len(ids) == 0 {\n        for _, replyTo := range inReplyTo {\n            msgIDs := strings.Fields(replyTo)\n            for _, msgID := range msgIDs {\n                if msgID != \"\" {\n                    canonicalID, err := MessageIDCanonical(msgID)\n                    if err != nil {\n                        return nil, err\n                    }\n                    ids = append(ids, canonicalID)\n                }\n            }\n        }\n    }\n\n    return ids, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReferencedIDs(references []string, inReplyTo []string) ([]string, error) {\n# Natural Language Annotations: // ReferencedIDs returns the Message-IDs referenced from the References header(s),\n// with a fallback to the In-Reply-To header(s). The ids are canonicalized for\n// thread-matching, like with MessageIDCanonical. Empty message-id's are skipped.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-message/authresults.go-ParseAuthResults": {"response": ["```go\nfunc ParseAuthResults(s string) (ar AuthResults, err error) {\n\tif len(s) == 0 {\n\t\treturn nil, errors.New(\"empty Authentication-Results header\")\n\t}\n\tif !strings.HasSuffix(s, \"\\r\\n\") && !strings.HasSuffix(s, \"\\n\") {\n\t\treturn nil, errors.New(\"missing line ending in Authentication-Results header\")\n\t}\n\tlines := strings.Split(s, \"\\n\")\n\tfor i, line := range lines {\n\t\tline = strings.TrimRight(line, \"\\r\")\n\t\tif i > 0 && (strings.HasPrefix(line, \" \") || strings.HasPrefix(line, \"\\t\")) {\n\t\t\t// Continuation of previous line\n\t\t\tar[len(ar)-1].Value += \" \" + strings.TrimSpace(line)\n\t\t\tcontinue\n\t\t}\n\t\ttokens := strings.SplitN(line, \";\", 2)\n\t\tif len(tokens) != 2 {\n\t\t\treturn nil, fmt.Errorf(\"malformed Authentication-Results header: %q\", line)\n\t\t}\n\t\tauthserv := strings.TrimSpace(tokens[0])\n\t\tresinfo := strings.TrimSpace(tokens[1])\n\t\tif len(authserv) == 0 {\n\t\t\treturn nil, errors.New(\"empty authserv-id in Authentication-Results header\")\n\t\t}\n\t\tar = append(ar, &AuthResult{\n\t\t\tAuthServID: authserv,\n\t\t\tValue:      resinfo,\n\t\t})\n\t}\n\treturn ar, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseAuthResults(s string) (ar AuthResults, err error) {\n# Natural Language Annotations: // ParseAuthResults parses a Authentication-Results header value.\n//\n// Comments are not populated in the returned AuthResults.\n// Both crlf and lf line-endings are accepted. The input string must end with\n// either crlf or lf.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-store/msgreader.go-FileMsgReader": {"response": ["```go\nfunc FileMsgReader(prefix []byte, msgFile *os.File) *MsgReader {\n    return &MsgReader{\n        prefix:  prefix,\n        r:       bufio.NewReader(msgFile),\n        msgFile: msgFile,\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FileMsgReader(prefix []byte, msgFile *os.File) *MsgReader {\n# Natural Language Annotations: // FileMsgReader makes a MsgReader for an open file.\n// If initialization fails, reads will return the error.\n// Only call close on the returned MsgReader if you want to close msgFile.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-store/import.go-ParseDovecotKeywordsFlags": {"response": ["```go\nfunc ParseDovecotKeywordsFlags(r io.Reader, log mlog.Log) ([]string, error) {\n\tvar keywords []string\n\tscanner := bufio.NewScanner(r)\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tline = strings.TrimSpace(line)\n\t\tif len(line) == 0 || line[0] == '#' {\n\t\t\tcontinue\n\t\t}\n\t\tparts := strings.Fields(line)\n\t\tif len(parts) != 2 {\n\t\t\tlog.Warn(\"invalid dovecot-keywords line\", mlog.String(\"line\", line))\n\t\t\tcontinue\n\t\t}\n\t\tkeyword := strings.ToLower(parts[0])\n\t\tif len(keyword) == 0 {\n\t\t\tlog.Warn(\"invalid dovecot-keywords line, empty keyword\", mlog.String(\"line\", line))\n\t\t\tcontinue\n\t\t}\n\t\tkeywords = append(keywords, keyword)\n\t}\n\tif err := scanner.Err(); err != nil {\n\t\treturn keywords, err\n\t}\n\treturn keywords, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseDovecotKeywordsFlags(r io.Reader, log mlog.Log) ([]string, error) {\n# Natural Language Annotations: // ParseDovecotKeywordsFlags attempts to parse a dovecot-keywords file. It only\n// returns valid flags/keywords, as lower-case. If an error is encountered and\n// returned, any keywords that were found are still returned. The returned list has\n// both system/well-known flags and custom keywords.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-store/account.go-MessageRuleset": {"response": ["```go\nfunc MessageRuleset(log mlog.Log, dest config.Destination, m *Message, msgPrefix []byte, msgFile *os.File) *config.Ruleset {\n\tfor _, ruleset := range dest.Rulesets {\n\t\tif ruleset.Matches(log, m.SMTPFrom, m.SMTPTo, m.BodyHash, msgPrefix, msgFile) {\n\t\t\treturn ruleset\n\t\t}\n\t}\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MessageRuleset(log mlog.Log, dest config.Destination, m *Message, msgPrefix []byte, msgFile *os.File) *config.Ruleset {\n# Natural Language Annotations: // MessageRuleset returns the first ruleset (if any) that matches the message\n// represented by msgPrefix and msgFile, with smtp and validation fields from m.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-smtp/address.go-ParseAddress": {"response": ["```go\nfunc ParseAddress(s string) (address Address, err error) {\n    // Check if the address is empty\n    if len(s) == 0 {\n        return Address{}, ErrBadAddress\n    }\n\n    // Split the address into local part and domain\n    parts := strings.Split(s, \"@\")\n    if len(parts) != 2 {\n        return Address{}, ErrBadAddress\n    }\n\n    local := parts[0]\n    domain := parts[1]\n\n    // Check if the local part is valid\n    if len(local) == 0 || len(local) > 64 {\n        return Address{}, ErrBadAddress\n    }\n\n    // Check if the domain is valid\n    if len(domain) == 0 || len(domain) > 255 {\n        return Address{}, ErrBadAddress\n    }\n\n    // Check if the domain contains at least one dot\n    if !strings.Contains(domain, \".\") {\n        return Address{}, ErrBadAddress\n    }\n\n    // Check if the domain ends with a dot\n    if strings.HasSuffix(domain, \".\") {\n        return Address{}, ErrBadAddress\n    }\n\n    // Check if the domain contains invalid characters\n    if !isDomainValid(domain) {\n        return Address{}, ErrBadAddress\n    }\n\n    return Address{Local: local, Domain: domain}, nil\n}\n\nfunc isDomainValid(domain string) bool {\n    // Check if the domain contains only valid characters\n    for _, c := range domain {\n        if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9') || c == '-' || c == '.') {\n            return false\n        }\n    }\n    return true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseAddress(s string) (address Address, err error) {\n# Natural Language Annotations: // ParseAddress parses an email address. UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-smtp/address.go-ParseLocalpart": {"response": ["```go\nfunc ParseLocalpart(s string) (localpart Localpart, err error) {\n    if len(s) == 0 {\n        return \"\", ErrBadAddress\n    }\n    if len(s) > 64 {\n        return \"\", ErrBadAddress\n    }\n    for _, c := range s {\n        if !isLocalpartChar(c) {\n            return \"\", ErrBadAddress\n        }\n    }\n    return Localpart(s), nil\n}\n\nfunc isLocalpartChar(c rune) bool {\n    return c >= 'a' && c <= 'z' ||\n        c >= 'A' && c <= 'Z' ||\n        c >= '0' && c <= '9' ||\n        c == '!' || c == '#' || c == '$' || c == '%' ||\n        c == '&' || c == '\\'' || c == '*' || c == '+' ||\n        c == '-' || c == '/' || c == '=' || c == '?' ||\n        c == '^' || c == '_' || c == '`' || c == '{' ||\n        c == '|' || c == '}' || c == '~' || c == '.'\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseLocalpart(s string) (localpart Localpart, err error) {\n# Natural Language Annotations: // ParseLocalpart parses the local part.\n// UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-smtp/data.go-DataWrite": {"response": ["```go\nfunc DataWrite(w io.Writer, r io.Reader) error {\n\tvar buf [1024]byte\n\tvar prevByte byte\n\tfor {\n\t\tn, err := r.Read(buf[:])\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\t_, err = w.Write([]byte{'\\r', '\\n', '.', '\\r', '\\n'})\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\tfor i := 0; i < n; i++ {\n\t\t\tb := buf[i]\n\t\t\tif b == '\\n' {\n\t\t\t\tif prevByte != '\\r' {\n\t\t\t\t\treturn errors.New(\"smtp: bare newline in message\")\n\t\t\t\t}\n\t\t\t\tif _, err := w.Write([]byte{'\\r', '\\n'}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif i+1 < n && buf[i+1] == '.' {\n\t\t\t\t\tif _, err := w.Write([]byte{'.'}); err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if b == '\\r' {\n\t\t\t\tif i+1 >= n {\n\t\t\t\t\treturn errors.New(\"smtp: bare carriage return in message\")\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif _, err := w.Write([]byte{b}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\tprevByte = b\n\t\t}\n\t}\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DataWrite(w io.Writer, r io.Reader) error {\n# Natural Language Annotations: // DataWrite reads data (a mail message) from r, and writes it to smtp\n// connection w with dot stuffing, as required by the SMTP data command.\n//\n// Messages with bare carriage returns or bare newlines result in an error.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-scram/scram.go-NewServer": {"response": ["```go\nfunc NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (server *Server, rerr error) {\n\tmsg, err := parseClientFirst(clientFirst)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tserver = &Server{\n\t\th:                      h,\n\t\tcs:                     cs,\n\t\tchannelBindingRequired: channelBindingRequired,\n\t\tclientNonce:            msg.Nonce,\n\t\tusername:               msg.Username,\n\t\tclientFirstBare:        msg.Bare,\n\t}\n\n\tif msg.ChannelBinding != \"\" {\n\t\tif cs == nil {\n\t\t\treturn nil, errors.New(\"client requested channel binding, but no TLS connection state provided\")\n\t\t}\n\t\tserver.channelBinding = msg.ChannelBinding\n\t}\n\n\treturn server, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (server *Server, rerr error) {\n# Natural Language Annotations: // NewServer returns a server given the first SCRAM message from a client.\n//\n// If cs is set, the PLUS variant can be negotiated, binding the authentication\n// exchange to the TLS channel (preventing MitM attempts). If a client\n// indicates it supports the PLUS variant, but thinks the server does not, the\n// authentication attempt will fail.\n//\n// If channelBindingRequired is set, the client has indicated it will do channel\n// binding and not doing so will cause the authentication to fail.\n//\n// The sequence for data and calls on a server:\n//\n//   - Read initial data from client, call NewServer (this call), then ServerFirst and write to the client.\n//   - Read response from client, call Finish or FinishFinal and write the resulting string.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-scram/scram.go-ServerFirst": {"response": ["```go\nfunc (s *Server) ServerFirst(iterations int, salt []byte) (string, error) {\n\ts.step = stepServerFirst\n\ts.iterations = iterations\n\ts.salt = salt\n\n\tnonce := make([]byte, nonceLen)\n\tif _, err := rand.Read(nonce); err != nil {\n\t\treturn \"\", err\n\t}\n\ts.nonce = nonce\n\n\treturn fmt.Sprintf(\"r=%s,s=%s,i=%d\", s.nonce, base64.StdEncoding.EncodeToString(s.salt), s.iterations), nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Server) ServerFirst(iterations int, salt []byte) (string, error) {\n# Natural Language Annotations: // ServerFirst returns the string to send back to the client. To be called after NewServer.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-scram/scram.go-Finish": {"response": ["```go\nfunc (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n\t// Verify the client's final message\n\terr := s.verifyClientFinal(clientFinal, saltedPassword)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Generate the server's final message\n\tserverFinal, err = s.generateServerFinal()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Authentication successful\n\treturn serverFinal, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n# Natural Language Annotations: // Finish takes the final client message, and the salted password (probably\n// from server storage), verifies the client, and returns a message to return\n// to the client. If err is nil, authentication was successful. If the\n// authorization requested is not acceptable, the server should call\n// FinishError instead.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-scram/scram.go-ClientFirst": {"response": ["```go\nfunc (c *Client) ClientFirst() (clientFirst string, rerr error) {\n    c.generateNonce()\n    \n    clientFirstBare := fmt.Sprintf(\"n=%s,r=%s\", c.username, c.cnonce)\n    clientFirst = fmt.Sprintf(\"n,,%s\", clientFirstBare)\n    \n    c.clientFirstMessageBare = clientFirstBare\n    \n    return clientFirst, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Client) ClientFirst() (clientFirst string, rerr error) {\n# Natural Language Annotations: // ClientFirst returns the first client message to write to the server.\n// No channel binding is done/supported.\n// A random nonce is generated.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-scram/scram.go-ServerFinal": {"response": ["```go\nfunc (c *Client) ServerFinal(serverFinal []byte) (rerr error) {\n    salt := c.getSalt()\n    serverProof := computeServerProof(c.authMsg, salt, c.serverSignature)\n    if subtle.ConstantTimeCompare(serverProof, serverFinal) != 1 {\n        return fmt.Errorf(\"server final message is invalid\")\n    }\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Client) ServerFinal(serverFinal []byte) (rerr error) {\n# Natural Language Annotations: // ServerFinal processes the final message from the server, verifying that the\n// server knows the password.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-autotls/autotls.go-SetAllowedHostnames": {"response": ["```go\nfunc (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n\tm.Lock()\n\tm.allowedHostnames = hostnames\n\tm.Unlock()\n\n\tif checkHosts && len(publicIPs) > 0 && !slices.Contains(publicIPs, \"0.0.0.0\") {\n\t\tgo func() {\n\t\t\tfor hostname := range hostnames {\n\t\t\t\tips, err := resolver.LookupHost(context.Background(), string(hostname))\n\t\t\t\tif err != nil {\n\t\t\t\t\tlog.Error(\"Failed to resolve hostname\", mlog.String(\"hostname\", string(hostname)), mlog.Err(err))\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tif !allIPsServed(ips, publicIPs) {\n\t\t\t\t\tlog.Warn(\"Hostname may fail ACME validation\", mlog.String(\"hostname\", string(hostname)))\n\t\t\t\t}\n\t\t\t}\n\t\t}()\n\t}\n}\n\nfunc allIPsServed(ips, publicIPs []string) bool {\n\tfor _, ip := range ips {\n\t\tif !slices.Contains(publicIPs, ip) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n# Natural Language Annotations: // SetAllowedHostnames sets a new list of allowed hostnames for automatic TLS.\n// After setting the host names, a goroutine is start to check that new host names\n// are fully served by publicIPs (only if non-empty and there is no unspecified\n// address in the list). If no, log an error with a warning that ACME validation\n// may fail.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-autotls/autotls.go-HostPolicy": {"response": ["```go\nfunc (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n\tm.mu.RLock()\n\tdefer m.mu.RUnlock()\n\n\tif m.shutdown {\n\t\treturn fmt.Errorf(\"manager is shutting down, no new connections allowed\")\n\t}\n\n\tif !m.allowedHosts[host] {\n\t\treturn fmt.Errorf(\"host %q is not allowed\", host)\n\t}\n\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n# Natural Language Annotations: // HostPolicy decides if a host is allowed for use with ACME, i.e. whether a\n// certificate will be returned if present and/or will be requested if not yet\n// present. Only hosts added with SetAllowedHostnames are allowed. During shutdown,\n// no new connections are allowed.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-imapserver/protocol.go-containsSeq": {"response": ["```go\nfunc (ss numSet) containsSeq(seq msgseq, uids []store.UID, searchResult []store.UID) bool {\n    if len(searchResult) == 0 {\n        return false\n    }\n\n    i, j := 0, 0\n    for i < len(uids) && j < len(searchResult) {\n        if uids[i] == searchResult[j] {\n            if searchResult[j] == store.UID(seq) {\n                return true\n            }\n            i++\n            j++\n        } else if uids[i] < searchResult[j] {\n            i++\n        } else {\n            j++\n        }\n    }\n\n    return false\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (ss numSet) containsSeq(seq msgseq, uids []store.UID, searchResult []store.UID) bool {\n# Natural Language Annotations: // containsSeq returns whether seq is in the numSet, given uids and (saved) searchResult.\n// uids and searchResult must be sorted. searchResult can have uids that are no longer in uids.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-imapserver/protocol.go-interpretStar": {"response": ["```go\nfunc (s numSet) interpretStar(uids []store.UID) numSet {\n\tvar ns numSet\n\tfor _, num := range s {\n\t\tif num.isStar() {\n\t\t\tfirst := num.first\n\t\t\tlast := num.last\n\t\t\tif first == 0 {\n\t\t\t\tfirst = 1\n\t\t\t}\n\t\t\tif last == 0 {\n\t\t\t\tlast = store.UID(len(uids))\n\t\t\t}\n\t\t\tfor i := first; i <= last; i++ {\n\t\t\t\tns = ns.add(newNum(i, i))\n\t\t\t}\n\t\t} else {\n\t\t\tns = ns.add(num)\n\t\t}\n\t}\n\treturn ns\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s numSet) interpretStar(uids []store.UID) numSet {\n# Natural Language Annotations: // interpretStar returns a numset that interprets stars in a numset, returning a new\n// numset without stars with increasing first/last.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-http/web.go-ServeHTTP": {"response": ["```go\nfunc (s *serve) ServeHTTP(xw http.ResponseWriter, r *http.Request) {\n    start := time.Now()\n    defer func() {\n        s.logRequest(r, time.Since(start))\n        s.trackMetrics(r, time.Since(start))\n    }()\n\n    if s.isWebSocketRequest(r) {\n        s.handleWebSocket(xw, r)\n        return\n    }\n\n    path := r.URL.Path\n    if handler, ok := s.pathHandlers[path]; ok {\n        handler.ServeHTTP(xw, r)\n        return\n    }\n\n    if s.webHandler != nil {\n        s.webHandler.ServeHTTP(xw, r)\n        return\n    }\n\n    http.NotFound(xw, r)\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *serve) ServeHTTP(xw http.ResponseWriter, r *http.Request) {\n# Natural Language Annotations: // ServeHTTP is the starting point for serving HTTP requests. It dispatches to the\n// right pathHandler or WebHandler, and it generates access logs and tracks\n// metrics.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-moxio/bufpool.go-Readline": {"response": ["```go\nfunc (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n\tvar buf []byte\n\tfor {\n\t\tchunk, isPrefix, err := r.ReadLine()\n\t\tif err != nil {\n\t\t\tif err == io.EOF {\n\t\t\t\tif len(buf) == 0 {\n\t\t\t\t\treturn \"\", io.EOF\n\t\t\t\t}\n\t\t\t\treturn string(buf), io.ErrUnexpectedEOF\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\t\tbuf = append(buf, chunk...)\n\t\tif len(buf) > maxLineLen {\n\t\t\treturn \"\", ErrLineTooLong\n\t\t}\n\t\tif !isPrefix {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn string(buf), nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n# Natural Language Annotations: // Readline reads a \\n- or \\r\\n-terminated line. Line is returned without \\n or \\r\\n.\n// If the line was too long, ErrLineTooLong is returned.\n// If an EOF is encountered before a \\n, io.ErrUnexpectedEOF is returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-moxio/linkcopy.go-LinkOrCopy": {"response": ["```go\nfunc LinkOrCopy(log mlog.Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n    if err := os.Link(src, dst); err == nil {\n        return nil\n    }\n\n    var srcReader io.Reader\n    if srcReaderOpt != nil {\n        srcReader = srcReaderOpt\n    } else {\n        srcFile, err := os.Open(src)\n        if err != nil {\n            return err\n        }\n        defer srcFile.Close()\n        srcReader = srcFile\n    }\n\n    dstFile, err := os.Create(dst)\n    if err != nil {\n        return err\n    }\n    defer func() {\n        if err := dstFile.Close(); err != nil && rerr == nil {\n            rerr = err\n        }\n        if rerr != nil {\n            if err := os.Remove(dst); err != nil {\n                log.Warn(\"Failed to remove destination file after error\", mlog.Err(err))\n            }\n        }\n    }()\n\n    _, err = io.Copy(dstFile, srcReader)\n    if err != nil {\n        return err\n    }\n\n    if sync {\n        if err := dstFile.Sync(); err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func LinkOrCopy(log mlog.Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n# Natural Language Annotations: // LinkOrCopy attempts to make a hardlink dst. If that fails, it will try to do a\n// regular file copy. If srcReaderOpt is not nil, it will be used for reading. If\n// sync is true and the file is copied, Sync is called on the file after writing to\n// ensure the file is written on disk. Callers should also sync the directory of\n// the destination file, but may want to do that after linking/copying multiple\n// files. If dst was created and an error occurred, it is removed.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-moxio/base64writer.go-Base64Writer": {"response": ["```go\nfunc Base64Writer(w io.Writer) io.WriteCloser {\n\treturn &base64Writer{\n\t\tw:         w,\n\t\tlineLen:   0,\n\t\tcloseFunc: func() error { return nil },\n\t}\n}\n\ntype base64Writer struct {\n\tw         io.Writer\n\tlineLen   int\n\tcloseFunc func() error\n}\n\nfunc (w *base64Writer) Write(p []byte) (n int, err error) {\n\tencoded := make([]byte, base64.StdEncoding.EncodedLen(len(p)))\n\tbase64.StdEncoding.Encode(encoded, p)\n\n\tfor len(encoded) > 0 {\n\t\tremaining := 78 - w.lineLen\n\t\tif remaining <= 0 {\n\t\t\tif _, err := w.w.Write([]byte(\"\\r\\n\")); err != nil {\n\t\t\t\treturn n, err\n\t\t\t}\n\t\t\tw.lineLen = 0\n\t\t\tremaining = 78\n\t\t}\n\n\t\ttoWrite := remaining\n\t\tif toWrite > len(encoded) {\n\t\t\ttoWrite = len(encoded)\n\t\t}\n\n\t\tif _, err := w.w.Write(encoded[:toWrite]); err != nil {\n\t\t\treturn n, err\n\t\t}\n\t\tw.lineLen += toWrite\n\t\tencoded = encoded[toWrite:]\n\t\tn += toWrite\n\t}\n\n\treturn n, nil\n}\n\nfunc (w *base64Writer) Close() error {\n\tif w.lineLen > 0 {\n\t\tif _, err := w.w.Write([]byte(\"\\r\\n\")); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn w.closeFunc()\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Base64Writer(w io.Writer) io.WriteCloser {\n# Natural Language Annotations: // Base64Writer turns a writer for data into one that writes base64 content on\n// \\r\\n separated lines of max 78+2 characters length.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dkim/sig.go-Header": {"response": ["```go\nfunc (s *Sig) Header() (string, error) {\n\tvar buf bytes.Buffer\n\tbuf.WriteString(\"DKIM-Signature: \")\n\n\t// Write the required fields\n\tif err := writeField(&buf, \"v\", s.Version); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"a\", s.Algorithm); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"q\", s.QueryMethod); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"d\", s.Domain); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"s\", s.Selector); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"c\", s.Canonicalization); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"t\", strconv.FormatInt(s.Timestamp, 10)); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"h\", strings.Join(s.Headers, \":\")); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"bh\", base64.StdEncoding.EncodeToString(s.BodyHash)); err != nil {\n\t\treturn \"\", err\n\t}\n\tif err := writeField(&buf, \"b\", base64.StdEncoding.EncodeToString(s.Signature)); err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Write the optional fields\n\tif s.Length != 0 {\n\t\tif err := writeField(&buf, \"l\", strconv.Itoa(s.Length)); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\tif s.BodyLength != 0 {\n\t\tif err := writeField(&buf, \"l\", strconv.Itoa(s.BodyLength)); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\tif s.Expiration != 0 {\n\t\tif err := writeField(&buf, \"x\", strconv.FormatInt(s.Expiration, 10)); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\tif s.CopiedHeaderFields != \"\" {\n\t\tif err := writeField(&buf, \"z\", s.CopiedHeaderFields); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\tif s.BodyHash != nil {\n\t\tif err := writeField(&buf, \"bh\", base64.StdEncoding.EncodeToString(s.BodyHash)); err != nil {\n\t\t\treturn \"\", err\n\t\t}\n\t}\n\n\tbuf.WriteString(\"\\r\\n\")\n\treturn buf.String(), nil\n}\n\nfunc writeField(buf *bytes.Buffer, name, value string) error {\n\tif strings.ContainsAny(value, \" ;\") {\n\t\treturn fmt.Errorf(\"dkim: invalid character in field %q\", name)\n\t}\n\tbuf.WriteString(name)\n\tbuf.WriteString(\"=\")\n\tbuf.WriteString(value)\n\tbuf.WriteString(\"; \")\n\treturn nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Sig) Header() (string, error) {\n# Natural Language Annotations: // Header returns the DKIM-Signature header in string form, to be prepended to a\n// message, including DKIM-Signature field name and trailing \\r\\n.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mox-dkim/txt.go-Record": {"response": ["```go\nfunc (r *Record) Record() (string, error) {\n\tvar buf bytes.Buffer\n\tbuf.WriteString(fmt.Sprintf(\"v=%s;\", r.Version))\n\n\tif r.HashAlgorithms != \"\" {\n\t\tbuf.WriteString(fmt.Sprintf(\"h=%s;\", r.HashAlgorithms))\n\t}\n\tif r.KeyType != \"\" {\n\t\tbuf.WriteString(fmt.Sprintf(\"k=%s;\", r.KeyType))\n\t}\n\tif r.Notes != \"\" {\n\t\tbuf.WriteString(fmt.Sprintf(\"n=%s;\", r.Notes))\n\t}\n\tif r.PublicKey != \"\" {\n\t\tbuf.WriteString(fmt.Sprintf(\"p=%s;\", r.PublicKey))\n\t}\n\tif r.ServiceType != \"\" {\n\t\tbuf.WriteString(fmt.Sprintf(\"s=%s;\", r.ServiceType))\n\t}\n\tif r.Flags != 0 {\n\t\tbuf.WriteString(fmt.Sprintf(\"t=%d;\", r.Flags))\n\t}\n\n\trecord := buf.String()\n\tif len(record) == 0 {\n\t\treturn \"\", errors.New(\"record is empty\")\n\t}\n\tif record[len(record)-1] == ';' {\n\t\trecord = record[:len(record)-1]\n\t}\n\treturn record, nil\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r *Record) Record() (string, error) {\n# Natural Language Annotations: // Record returns a DNS TXT record that should be served at\n// <selector>._domainkey.<domain>.\n//\n// Only values that are not the default values are included.\nPlease only return the code surrounded by ```, do not reply any explanation\n"}}