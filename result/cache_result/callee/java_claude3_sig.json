{"langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": {"response": ["```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory: \" + directoryPath);\n    }\n    \n    List<Document> documents = new ArrayList<>();\n    \n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path filePath : stream) {\n            if (Files.isRegularFile(filePath)) {\n                try {\n                    String text = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n                    Document document = documentParser.parse(text);\n                    documents.add(document);\n                } catch (Exception e) {\n                    // Skip documents that fail to load\n                }\n            }\n        }\n    } catch (IOException e) {\n        // Handle directory stream error\n    }\n    \n    return documents;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": {"response": ["```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory: \" + directoryPath);\n    }\n\n    List<Document> documents = new ArrayList<>();\n    try (Stream<Path> paths = Files.walk(directoryPath)) {\n        paths.filter(Files::isRegularFile)\n                .forEach(filePath -> {\n                    try {\n                        String text = Files.readString(filePath);\n                        Document document = documentParser.parse(text);\n                        documents.add(document);\n                    } catch (Exception e) {\n                        // Skip documents that fail to load\n                    }\n                });\n    } catch (IOException e) {\n        // Handle IOException if necessary\n    }\n\n    return documents;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": {"response": ["```java\npublic boolean hasSpaceFor(String text) {\n    int remainingSpace = MAX_SEGMENT_SIZE - currentSegmentSize;\n    return text.length() <= remainingSpace;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public boolean hasSpaceFor(String text) {\n# Natural Language Annotations: /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": {"response": ["```java\npublic void append(String text) {\n    if (text == null) {\n        throw new IllegalArgumentException(\"Text cannot be null\");\n    }\n    \n    currentSegment.append(text);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void append(String text) {\n# Natural Language Annotations: /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": {"response": ["```java\n/**\n * Prepends the provided text to the current segment.\n * @param text The text to prepend.\n */\npublic void prepend(String text) {\n    if (text != null && !text.isEmpty()) {\n        content = text + content;\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void prepend(String text) {\n# Natural Language Annotations: /**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": {"response": ["```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    return contentRetriever(new RetrieverToContentRetrieverAdapter(retriever));\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public AiServices<T> retriever(Retriever<TextSegment> retriever) {\n# Natural Language Annotations: /**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": {"response": ["```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    this.retrievalAugmentor = new DefaultRetrievalAugmentor(contentRetriever);\n    return this;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n# Natural Language Annotations: /**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n     * a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": {"response": ["Here is the function based on the given signature and annotations:\n\n```java\n@Override\npublic String add(Embedding embedding) {\n    String id = generateId();\n    embeddings.put(id, embedding);\n    return id;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public String add(Embedding embedding) {\n# Natural Language Annotations: /**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": {"response": ["```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            Tool tool = method.getAnnotation(Tool.class);\n            String name = tool.name().isEmpty() ? method.getName() : tool.name();\n            String description = tool.description();\n            List<ToolParameter> parameters = new ArrayList<>();\n            for (Parameter parameter : method.getParameters()) {\n                if (parameter.isAnnotationPresent(ToolParameter.class)) {\n                    ToolParameter toolParameter = parameter.getAnnotation(ToolParameter.class);\n                    parameters.add(new ToolParameter(toolParameter.name(), toolParameter.description(), parameter.getType()));\n                }\n            }\n            toolSpecifications.add(new ToolSpecification(name, description, parameters, method));\n        }\n    }\n    return toolSpecifications;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n# Natural Language Annotations: /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": {"response": ["```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    if (toolAnnotation == null) {\n        throw new IllegalArgumentException(\"Method is not annotated with @Tool: \" + method);\n    }\n\n    String name = toolAnnotation.name().isEmpty() ? method.getName() : toolAnnotation.name();\n    String description = toolAnnotation.description();\n    String[] parameters = toolAnnotation.parameters();\n\n    return new ToolSpecification(name, description, parameters);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ToolSpecification toolSpecificationFrom(Method method) {\n# Natural Language Annotations: /**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": {"response": ["```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    JsonSchemaProperty jsonSchemaProperty = toJsonSchemaProperty(parameter);\n    if (jsonSchemaProperty != null) {\n        return Collections.singleton(jsonSchemaProperty);\n    } else {\n        return Collections.emptyList();\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n# Natural Language Annotations: /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": {"response": ["```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n    for (int i = 0; i < embeddingA.vector.length; i++) {\n        dotProduct += embeddingA.vector[i] * embeddingB.vector[i];\n        normA += Math.pow(embeddingA.vector[i], 2);\n        normB += Math.pow(embeddingB.vector[i], 2);\n    }\n    if (normA == 0 || normB == 0) {\n        return 0.0;\n    }\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double between(Embedding embeddingA, Embedding embeddingB) {\n# Natural Language Annotations: /**\n     * Calculates cosine similarity between two vectors.\n     * <p>\n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": {"response": ["```java\n@Deprecated\npublic Map<String, String> asMap() {\n    return new HashMap<>(toMap());\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public Map<String, String> asMap() {\n# Natural Language Annotations: /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": {"response": ["```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source.getContent(), source.getMetadata());\n    if (document.isBlank()) {\n        throw new BlankDocumentException(\"The parsed document is blank/empty.\");\n    }\n    return document;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Document load(DocumentSource source, DocumentParser parser) {\n# Natural Language Annotations: /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": {"response": ["```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"Message does not contain a single text content.\");\n    }\n    return ((TextContent) getContents().get(0)).getText();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String singleText() {\n# Natural Language Annotations: /**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": {"response": ["```java\ndefault AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    ChatMessage chatMessage = augmentationRequest.getChatMessage();\n    List<Content> retrievedContents = retrieve(chatMessage);\n    \n    ChatMessage augmentedChatMessage = chatMessage.toBuilder()\n            .contents(retrievedContents)\n            .build();\n    \n    return AugmentationResult.builder()\n            .augmentedChatMessage(augmentedChatMessage)\n            .build();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default AugmentationResult augment(AugmentationRequest augmentationRequest) {\n# Natural Language Annotations: /**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n     * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": {"response": ["```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    AugmentationRequest request = AugmentationRequest.builder()\n            .userMessage(userMessage)\n            .metadata(metadata)\n            .build();\n    return augment(request);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    @Deprecated    public UserMessage augment(UserMessage userMessage, Metadata metadata) {\n# Natural Language Annotations: /**\n     * @deprecated use {@link #augment(AugmentationRequest)} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": {"response": ["```\ndefault ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    if (chatMessage instanceof UserMessage) {\n        UserMessage userMessage = (UserMessage) chatMessage;\n        List<Content> mergedContents = new ArrayList<>(userMessage.getContents());\n        mergedContents.addAll(contents);\n        return userMessage.toBuilder().contents(mergedContents).build();\n    } else if (chatMessage instanceof SystemMessage) {\n        SystemMessage systemMessage = (SystemMessage) chatMessage;\n        List<Content> mergedContents = new ArrayList<>(systemMessage.getContents());\n        mergedContents.addAll(contents);\n        return systemMessage.toBuilder().contents(mergedContents).build();\n    } else {\n        throw new IllegalArgumentException(\"Unsupported ChatMessage type: \" + chatMessage.getClass());\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n# Natural Language Annotations: /**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n     *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": {"response": ["```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    if (strings == null) {\n        return false;\n    }\n    for (String str : strings) {\n        if (str == null || str.trim().isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static boolean areNotNullOrBlank(String... strings) {\n# Natural Language Annotations: /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": {"response": ["```java\npublic static String generateUUIDFrom(String input) {\n    return UUID.nameUUIDFromBytes(input.getBytes()).toString();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String generateUUIDFrom(String input) {\n# Natural Language Annotations: /**\n   * Generates a UUID from a hash of the given input string.\n   * @param input The input string.\n   * @return A UUID.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": {"response": ["```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL resourceUrl = new URL(url);\n        URLConnection connection = resourceUrl.openConnection();\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        \n        try (InputStream inputStream = connection.getInputStream()) {\n            return inputStream.readAllBytes();\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to read bytes from URL: \" + url, e);\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static byte[] readBytes(String url) {\n# Natural Language Annotations: /**\n   * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n   * and from files stored on the local filesystem.\n   *\n   * @param url The URL to read from.\n   * @return The content as bytes.\n   * @throws RuntimeException if the request fails.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": {"response": ["```java\npublic int jitterDelayMillis(int attempt) {\n    if (attempt <= 0) {\n        return 0;\n    }\n    \n    int baseDelay = (int) Math.pow(2, attempt - 1) * 1000;\n    int jitter = (int) (Math.random() * baseDelay);\n    \n    return baseDelay + jitter;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int jitterDelayMillis(int attempt) {\n# Natural Language Annotations: /**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": {"response": ["Here is the function based on the provided signature and annotations:\n\n```java\n/**\n * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n *\n * @param name\n * @return \u4e3b\u952e\u751f\u6210\u5668\n */\npublic static IKeyGenerator getKeyGenerator(String name) {\n    if (name == null || name.isEmpty()) {\n        throw new IllegalArgumentException(\"Key generator name cannot be null or empty.\");\n    }\n    \n    switch (name.toLowerCase()) {\n        case \"uuid\":\n            return new UUIDKeyGenerator();\n        case \"snowflake\":\n            return new SnowflakeKeyGenerator();\n        case \"redis\":\n            return new RedisKeyGenerator();\n        default:\n            throw new IllegalArgumentException(\"Unsupported key generator: \" + name);\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static IKeyGenerator getKeyGenerator(String name) {\n# Natural Language Annotations: /**\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": {"response": ["```java\n/**\n * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n *\n * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n * @return {@link QueryCondition}\n */\npublic QueryCondition when(boolean effective) {\n    return effective ? this : new QueryCondition().nop();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public QueryCondition when(boolean effective) {\n# Natural Language Annotations: /**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": {"response": ["```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        throw new ReflectionException(\"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n\n    return name;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String methodToProperty(String name) {\n# Natural Language Annotations: /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": {"response": ["Here is the code for the `camelToUnderline` function based on the provided function signature and natural language annotations:\n\n```java\npublic static String camelToUnderline(String string) {\n    if (string == null || string.isEmpty()) {\n        return string;\n    }\n\n    StringBuilder result = new StringBuilder();\n    result.append(Character.toLowerCase(string.charAt(0)));\n\n    for (int i = 1; i < string.length(); i++) {\n        char ch = string.charAt(i);\n        if (Character.isUpperCase(ch)) {\n            result.append('_');\n            result.append(Character.toLowerCase(ch));\n        } else {\n            result.append(ch);\n        }\n    }\n\n    return result.toString();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String camelToUnderline(String string) {\n# Natural Language Annotations: /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": {"response": ["```java\npublic static String underlineToCamel(String string) {\n    if (string == null || string.isEmpty()) {\n        return string;\n    }\n    StringBuilder result = new StringBuilder();\n    String[] parts = string.split(\"_\");\n    for (int i = 0; i < parts.length; i++) {\n        String part = parts[i];\n        if (i == 0) {\n            result.append(part);\n        } else {\n            result.append(part.substring(0, 1).toUpperCase());\n            result.append(part.substring(1));\n        }\n    }\n    return result.toString();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String underlineToCamel(String string) {\n# Natural Language Annotations: /**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": {"response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        V newValue = mappingFunction.apply(key);\n        if (newValue != null) {\n            value = concurrentHashMap.putIfAbsent(key, newValue);\n            if (value == null) {\n                value = newValue;\n            }\n        }\n    }\n    return value;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n# Natural Language Annotations: /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": {"response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value == null) {\n        V newValue = mappingFunction.apply(key);\n        if (newValue != null) {\n            map.put(key, newValue);\n            return newValue;\n        }\n    }\n\n    return value;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n# Natural Language Annotations: /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": {"response": ["```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    return new BaseMapper<E>() {\n        private final Class<E> entityClass = (Class<E>) ((ParameterizedType) this.getClass().getGenericSuperclass()).getActualTypeArguments()[0];\n\n        @Override\n        public Class<E> getEntityClass() {\n            return entityClass;\n        }\n    };\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": {"response": ["```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return SqlHelper.getMapper(mapperClass);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <M> M ofMapperClass(Class<M> mapperClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": {"response": ["```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    return Flux.defer(() -> {\n        try {\n            String text = speechPrompt.getText();\n            SpeechOptions options = speechPrompt.getOptions();\n\n            // Perform speech synthesis using the provided text and options\n            // and stream the audio response\n            // ...\n\n            // Example implementation:\n            SpeechResponse response1 = new SpeechResponse(audioData1, metadata1);\n            SpeechResponse response2 = new SpeechResponse(audioData2, metadata2);\n            // ...\n\n            return Flux.just(response1, response2, ...);\n        } catch (Exception e) {\n            return Flux.error(e);\n        }\n    });\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n# Natural Language Annotations: /**\n\t * Streams the audio response for the given speech prompt.\n\t * @param speechPrompt The speech prompt containing the text and options for speech\n\t * synthesis.\n\t * @return A Flux of SpeechResponse objects containing the streamed audio and\n\t * metadata.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": {"response": ["```java\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions mergedOptions = new PostgresMlEmbeddingOptions();\n    \n    // Set default options\n    mergedOptions.setModel(\"default_model\");\n    mergedOptions.setDimension(512);\n    mergedOptions.setNormalize(true);\n    \n    // Override default options with request options if provided\n    if (requestOptions != null) {\n        if (requestOptions.getModel() != null) {\n            mergedOptions.setModel(requestOptions.getModel());\n        }\n        if (requestOptions.getDimension() > 0) {\n            mergedOptions.setDimension(requestOptions.getDimension());\n        }\n        if (requestOptions.getNormalize() != null) {\n            mergedOptions.setNormalize(requestOptions.getNormalize());\n        }\n    }\n    \n    return mergedOptions;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n# Natural Language Annotations: /**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": {"response": ["```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (modelName.equals(\"text-embedding-ada-002\")) {\n        return 1536;\n    } else if (modelName.equals(\"text-similarity-davinci-001\")) {\n        return 12288;\n    } else if (modelName.equals(\"text-search-ada-doc-001\")) {\n        return 1024;\n    } else {\n        List<Double> embedding = embeddingModel.embed(Collections.singletonList(dummyContent), modelName).getData().get(0).getEmbedding();\n        return embedding.size();\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n# Natural Language Annotations: /**\n\t * Return the dimension of the requested embedding generative name. If the generative\n\t * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n\t * count the response dimensions.\n\t * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n\t * @param modelName Embedding generative name to retrieve the dimensions for.\n\t * @param dummyContent Dummy content to use for the empirical dimension calculation.\n\t * @return Returns the embedding dimensions for the modelName.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": {"response": ["```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index must be non-negative.\");\n    }\n    return getPromptFilters().stream()\n            .filter(promptFilter -> promptFilter.getPromptIndex() == promptIndex)\n            .findFirst();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n# Natural Language Annotations: /**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": {"response": ["```\ndefault Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Long getTotalTokens() {\n# Natural Language Annotations: /**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": {"response": ["```\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Not) {\n        return ((Filter.Not) operand).getOperand();\n    } else if (operand instanceof Filter.And) {\n        Filter.Operand[] andOperands = ((Filter.And) operand).getOperands();\n        Filter.Operand[] orOperands = new Filter.Operand[andOperands.length];\n        for (int i = 0; i < andOperands.length; i++) {\n            orOperands[i] = negate(andOperands[i]);\n        }\n        return new Filter.Or(orOperands);\n    } else if (operand instanceof Filter.Or) {\n        Filter.Operand[] orOperands = ((Filter.Or) operand).getOperands();\n        Filter.Operand[] andOperands = new Filter.Operand[orOperands.length];\n        for (int i = 0; i < orOperands.length; i++) {\n            andOperands[i] = negate(orOperands[i]);\n        }\n        return new Filter.And(andOperands);\n    } else if (operand instanceof Filter.Eq) {\n        return new Filter.Ne(((Filter.Eq) operand).getField(), ((Filter.Eq) operand).getValue());\n    } else if (operand instanceof Filter.Ne) {\n        return new Filter.Eq(((Filter.Ne) operand).getField(), ((Filter.Ne) operand).getValue());\n    } else if (operand instanceof Filter.Gt) {\n        return new Filter.Lte(((Filter.Gt) operand).getField(), ((Filter.Gt) operand).getValue());\n    } else if (operand instanceof Filter.Gte) {\n        return new Filter.Lt(((Filter.Gte) operand).getField(), ((Filter.Gte) operand).getValue());\n    } else if (operand instanceof Filter.Lt) {\n        return new Filter.Gte(((Filter.Lt) operand).getField(), ((Filter.Lt) operand).getValue());\n    } else if (operand instanceof Filter.Lte) {\n        return new Filter.Gt(((Filter.Lte) operand).getField(), ((Filter.Lte) operand).getValue());\n    } else if (operand instanceof Filter.In) {\n        return new Filter.Nin(((Filter.In) operand).getField(), ((Filter.In) operand).getValues());\n    } else if (operand instanceof Filter.Nin) {\n        return new Filter.In(((Filter.Nin) operand).getField(), ((Filter.Nin) operand).getValues());\n    } else {\n        throw new IllegalArgumentException(\"Unsupported operand type: \" + operand.getClass().getName());\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Filter.Operand negate(Filter.Operand operand) {\n# Natural Language Annotations: /**\n\t * Transforms the input expression into a semantically equivalent one with negation\n\t * operators propagated thought the expression tree by following the negation rules:\n\t *\n\t * <pre>\n\t * \tNOT(NOT(a)) = a\n\t *\n\t * \tNOT(a AND b) = NOT(a) OR NOT(b)\n\t * \tNOT(a OR b) = NOT(a) AND NOT(b)\n\t *\n\t * \tNOT(a EQ b) = a NE b\n\t * \tNOT(a NE b) = a EQ b\n\t *\n\t * \tNOT(a GT b) = a LTE b\n\t * \tNOT(a GTE b) = a LT b\n\t *\n\t * \tNOT(a LT b) = a GTE b\n\t * \tNOT(a LTE b) = a GT b\n\t *\n\t * \tNOT(a IN [...]) = a NIN [...]\n\t * \tNOT(a NIN [...]) = a IN [...]\n\t * </pre>\n\t * @param operand Filter expression to negate.\n\t * @return Returns an negation of the input expression.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": {"response": ["```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    ObjectMapper mapper = new ObjectMapper();\n    JsonNode sourceNode = mapper.valueToTree(source);\n    JsonNode targetNode = mapper.valueToTree(target);\n    \n    if (acceptedFieldNames.isEmpty()) {\n        acceptedFieldNames = Arrays.stream(clazz.getDeclaredFields())\n                .filter(field -> field.isAnnotationPresent(JsonProperty.class))\n                .map(field -> field.getAnnotation(JsonProperty.class).value())\n                .collect(Collectors.toList());\n    }\n    \n    ObjectNode mergedNode = mapper.createObjectNode();\n    \n    for (String fieldName : acceptedFieldNames) {\n        JsonNode sourceValue = sourceNode.get(fieldName);\n        JsonNode targetValue = targetNode.get(fieldName);\n        \n        if (sourceValue != null && !sourceValue.isNull()) {\n            mergedNode.set(fieldName, sourceValue);\n        } else if (targetValue != null) {\n            mergedNode.set(fieldName, targetValue);\n        }\n    }\n    \n    return mapper.convertValue(mergedNode, clazz);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n\t * empty, use the {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @param acceptedFieldNames the list of field names accepted for the target object.\n\t * @return the merged object represented by the given class.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": {"response": ["```java\npublic static Map<String, Object> objectToMap(Object source) {\n    if (source == null) {\n        return null;\n    }\n\n    Map<String, Object> map = new HashMap<>();\n    Field[] fields = source.getClass().getDeclaredFields();\n\n    for (Field field : fields) {\n        field.setAccessible(true);\n        try {\n            map.put(field.getName(), field.get(source));\n        } catch (IllegalAccessException e) {\n            // Handle the exception appropriately\n            e.printStackTrace();\n        }\n    }\n\n    return map;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<String, Object> objectToMap(Object source) {\n# Natural Language Annotations: /**\n\t * Converts the given object to a Map.\n\t * @param source the object to convert to a Map.\n\t * @return the converted Map.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": {"response": ["```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean;\n    try {\n        targetBean = targetBeanClazz.getDeclaredConstructor().newInstance();\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to create a new instance of \" + targetBeanClazz.getSimpleName(), e);\n    }\n\n    Arrays.stream(sourceInterfaceClazz.getDeclaredMethods())\n            .forEach(method -> {\n                String methodName = method.getName();\n                if (methodName.startsWith(\"get\") || methodName.startsWith(\"is\")) {\n                    String setterName = \"set\" + methodName.substring(methodName.startsWith(\"is\") ? 2 : 3);\n                    try {\n                        Method setter = targetBeanClazz.getMethod(setterName, method.getReturnType());\n                        Object value = method.invoke(sourceBean);\n                        setter.invoke(targetBean, value);\n                    } catch (NoSuchMethodException e) {\n                        // Ignore missing setters\n                    } catch (Exception e) {\n                        throw new RuntimeException(\"Failed to copy property: \" + methodName, e);\n                    }\n                }\n            });\n\n    return targetBean;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param targetBeanClazz the target class, a subclass of the ChatOptions, to convert\n\t * into.\n\t * @param <T> the target class type.\n\t * @return a new instance of the targetBeanClazz with the values from the sourceBean\n\t * instance.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": {"response": ["```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    if (source == null || target == null || sourceInterfaceClazz == null) {\n        return target;\n    }\n\n    Method[] methods = sourceInterfaceClazz.getMethods();\n    for (Method method : methods) {\n        if (method.getName().startsWith(\"get\") && method.getParameterCount() == 0) {\n            String fieldName = method.getName().substring(3);\n            if (fieldName.length() > 0) {\n                fieldName = fieldName.substring(0, 1).toLowerCase() + fieldName.substring(1);\n                try {\n                    Method getterMethod = source.getClass().getMethod(method.getName());\n                    Object sourceValue = getterMethod.invoke(source);\n                    if (sourceValue != null || overrideNonNullTargetValues) {\n                        Method setterMethod = target.getClass().getMethod(\"set\" + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1), method.getReturnType());\n                        setterMethod.invoke(target, sourceValue);\n                    }\n                } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                    // Ignore and continue with the next method\n                }\n            }\n        }\n    }\n\n    return target;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": {"response": ["```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> jsonIncludeClasses = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    Set<Class<?>> jacksonAnnotatedClasses = reflections.getTypesAnnotatedWith(JsonProperty.class);\n    jacksonAnnotatedClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnore.class));\n    jacksonAnnotatedClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnoreProperties.class));\n    jacksonAnnotatedClasses.addAll(reflections.getTypesAnnotatedWith(JsonAutoDetect.class));\n    jacksonAnnotatedClasses.addAll(reflections.getTypesAnnotatedWith(JsonFormat.class));\n\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    for (Class<?> clazz : jsonIncludeClasses) {\n        annotatedClasses.add(new TypeReference<Object>() {\n            @Override\n            public Type getType() {\n                return clazz;\n            }\n        });\n    }\n    for (Class<?> clazz : jacksonAnnotatedClasses) {\n        annotatedClasses.add(new TypeReference<Object>() {\n            @Override\n            public Type getType() {\n                return clazz;\n            }\n        });\n    }\n    return annotatedClasses;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n# Natural Language Annotations: /**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageName The name of the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": {"response": ["```java\n@Override\npublic List<Document> get() {\n    List<Document> paragraphs = new ArrayList<>();\n    \n    try (PDDocument document = PDDocument.load(new File(filePath))) {\n        PDFTextStripper stripper = new PDFTextStripper();\n        String text = stripper.getText(document);\n        \n        String[] lines = text.split(\"\\\\r?\\\\n\");\n        StringBuilder paragraphBuilder = new StringBuilder();\n        \n        for (String line : lines) {\n            if (!line.isEmpty()) {\n                paragraphBuilder.append(line).append(\" \");\n            } else if (paragraphBuilder.length() > 0) {\n                String paragraphText = paragraphBuilder.toString().trim();\n                Document paragraph = new Document(paragraphText);\n                paragraphs.add(paragraph);\n                paragraphBuilder.setLength(0);\n            }\n        }\n        \n        if (paragraphBuilder.length() > 0) {\n            String paragraphText = paragraphBuilder.toString().trim();\n            Document paragraph = new Document(paragraphText);\n            paragraphs.add(paragraph);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    \n    return paragraphs;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic List<Document> get() {\n# Natural Language Annotations: /**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": {"response": ["```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (numBits < bits.length()) {\n        return bits;\n    } else {\n        int numWords = FixedBitSet.bits2words(numBits);\n        long[] words = ArrayUtil.grow(bits.getBits(), numWords);\n        return new FixedBitSet(words, words.length);\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n# Natural Language Annotations: /**\n     * If the given {@link FixedBitSet} is large enough to hold {@code numBits+1}, returns the given\n     * bits, otherwise returns a new {@link FixedBitSet} which can hold the requested number of bits.\n     *\n     * <p><b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of the given {@code\n     * bits} if possible. Also, calling {@link #length()} on the returned bits may return a value\n     * greater than {@code numBits}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": {"response": ["```java\npublic void forEach(BiConsumer<Integer, T> consumer) {\n    Node node = firstNode();\n    while (node != null) {\n        if (node.value != null) {\n            consumer.accept(node.key, node.value);\n        }\n        node = node.next;\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void forEach(IntBiConsumer<T> consumer) {\n# Natural Language Annotations: /**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": {"response": ["```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"Priority queue underflow\");\n    }\n    long result = heap[1];\n    heap[1] = heap[size];\n    size--;\n    sink(1);\n    if (size > 0 && size == (heap.length - 1) / 4) {\n        resize(heap.length / 2);\n    }\n    return result;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public final long pop() {\n# Natural Language Annotations: /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": {"response": ["```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (isEmpty()) {\n        return value;\n    }\n    arr[0] = value;\n    siftDown();\n    return arr[0];\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @VisibleForTesting    long updateTop(long value) {\n# Natural Language Annotations: /**\n     * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n     * Should be called when the top value changes.\n     * Still log(n) worst case, but it's at least twice as fast to\n     *\n     * <pre class=\"prettyprint\">\n     * pq.updateTop(value);\n     * </pre>\n     * <p>\n     * instead of\n     *\n     * <pre class=\"prettyprint\">\n     * pq.pop();\n     * pq.push(value);\n     * </pre>\n     * <p>\n     * Calling this method on an empty BoundedLongHeap has no visible effect.\n     *\n     * @param value the new element that is less than the current top.\n     * @return the new 'top' element after shuffling the heap.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": {"response": ["```\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public double score(long id, byte[] vector) {\n            return -hammingDistance(q.toArray(), vector);\n        }\n\n        @Override\n        public double score(long id, float[] vector) {\n            return -hammingDistance(q.toArray(), vector);\n        }\n    };\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n     * is a useful approximation for cosine distance and not really anything else.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": {"response": ["Here is the code for the `compute` function based on the provided function signature and natural language annotations:\n\n```java\npublic static ProductQuantization compute(float[][] ravv,\n                                           int M,\n                                           int clusterCount,\n                                           boolean globallyCenter,\n                                           float anisotropicThreshold,\n                                           ForkJoinPool simdExecutor,\n                                           ForkJoinPool parallelExecutor) {\n    int n = ravv.length;\n    int d = ravv[0].length;\n    int subDim = d / M;\n\n    // Globally center the vectors if requested\n    if (globallyCenter) {\n        float[] mean = new float[d];\n        for (float[] vector : ravv) {\n            for (int j = 0; j < d; j++) {\n                mean[j] += vector[j];\n            }\n        }\n        for (int j = 0; j < d; j++) {\n            mean[j] /= n;\n        }\n        for (float[] vector : ravv) {\n            for (int j = 0; j < d; j++) {\n                vector[j] -= mean[j];\n            }\n        }\n    }\n\n    // Split the vectors into subspaces\n    float[][][] subspaces = new float[M][n][subDim];\n    for (int i = 0; i < n; i++) {\n        for (int m = 0; m < M; m++) {\n            System.arraycopy(ravv[i], m * subDim, subspaces[m][i], 0, subDim);\n        }\n    }\n\n    // Cluster each subspace using k-means\n    float[][][] codebooks = new float[M][clusterCount][subDim];\n    int[][] assignments = new int[M][n];\n    for (int m = 0; m < M; m++) {\n        KMeans kmeans = new KMeans(clusterCount, subDim, anisotropicThreshold, simdExecutor, parallelExecutor);\n        assignments[m] = kmeans.cluster(subspaces[m], codebooks[m]);\n    }\n\n    return new ProductQuantization(codebooks, assignments);\n}\n```\n\nNote: The code assumes the existence of a `KMeans` class for clustering each subspace and a `ProductQuantization` class to store the resulting codebooks and assignments."], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ProductQuantization compute(\n# Natural Language Annotations: /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param clusterCount number of clusters per subspace\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     * @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n     *                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": {"response": ["```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Create a copy of the current PQ\n    ProductQuantization refinedPQ = new ProductQuantization(this);\n\n    // Run Lloyd's algorithm for the specified number of rounds\n    for (int round = 0; round < lloydsRounds; round++) {\n        // Assign vectors to clusters\n        int[][] assignments = new int[refinedPQ.numSubvectors][ravv.size()];\n        for (int i = 0; i < ravv.size(); i++) {\n            float[] vector = ravv.vectorFor(i);\n            int[] assignment = refinedPQ.assignVector(vector);\n            for (int j = 0; j < refinedPQ.numSubvectors; j++) {\n                assignments[j][i] = assignment[j];\n            }\n        }\n\n        // Update centroids based on assignments\n        for (int i = 0; i < refinedPQ.numSubvectors; i++) {\n            float[][] centroids = refinedPQ.getCodebook(i);\n            float[][] newCentroids = new float[centroids.length][centroids[0].length];\n\n            int[] counts = new int[centroids.length];\n            for (int j = 0; j < ravv.size(); j++) {\n                int centroidIndex = assignments[i][j];\n                counts[centroidIndex]++;\n                float[] vector = ravv.vectorFor(j);\n                int start = i * refinedPQ.dimPerSubvector;\n                int end = start + refinedPQ.dimPerSubvector;\n                for (int k = start; k < end; k++) {\n                    newCentroids[centroidIndex][k - start] += vector[k];\n                }\n            }\n\n            for (int j = 0; j < centroids.length; j++) {\n                if (counts[j] > 0) {\n                    for (int k = 0; k < centroids[0].length; k++) {\n                        newCentroids[j][k] /= counts[j];\n                    }\n                }\n            }\n\n            refinedPQ.setCodebook(i, newCentroids);\n        }\n    }\n\n    return refinedPQ;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ProductQuantization refine(RandomAccessVectorValues ravv,\n# Natural Language Annotations: /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": {"response": ["```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    ByteSequence<?> encoded = ByteSequence.allocate(codebooks.size());\n    for (int i = 0; i < codebooks.size(); i++) {\n        VectorFloat<?> subvector = vector.slice(i * subspaceDimension, (i + 1) * subspaceDimension);\n        float bestDistance = Float.POSITIVE_INFINITY;\n        byte bestCode = 0;\n        for (byte code = 0; code < codebooks.get(i).size(); code++) {\n            VectorFloat<?> codeword = codebooks.get(i).get(code);\n            float distance = subvector.distance(codeword);\n            float parallelLoss = subvector.dot(codeword) / (subvector.l2Norm() * codeword.l2Norm());\n            float orthogonalLoss = (float) Math.sqrt(distance * distance - parallelLoss * parallelLoss);\n            float weightedDistance = parallelLoss * parallelLossWeight + orthogonalLoss * orthogonalLossWeight;\n            if (weightedDistance < bestDistance) {\n                bestDistance = weightedDistance;\n                bestCode = code;\n            }\n        }\n        encoded.set(i, bestCode);\n    }\n    return encoded;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": {"response": ["```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    int subspaceCount = codebooks.size();\n    byte[] bytes = new byte[subspaceCount];\n    \n    for (int i = 0; i < subspaceCount; i++) {\n        VectorFloat<?> subvector = vector.slice(i * subspaceDimension, (i + 1) * subspaceDimension);\n        int bestIndex = 0;\n        float bestDistance = Float.MAX_VALUE;\n        \n        for (int j = 0; j < codebooks.get(i).size(); j++) {\n            float distance = subvector.distance(codebooks.get(i).get(j));\n            if (distance < bestDistance) {\n                bestDistance = distance;\n                bestIndex = j;\n            }\n        }\n        \n        bytes[i] = (byte) bestIndex;\n    }\n    \n    return new ByteSequence<>(bytes);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ByteSequence<?> encode(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": {"response": ["```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    int dimension = target.getDimension();\n    float[] reconstructed = new float[dimension];\n\n    int numSubvectors = dimension / DimensionM;\n    int numCentroids = 1 << NumBitsPerSubvector;\n\n    for (int s = 0; s < numSubvectors; s++) {\n        int startIndex = s * DimensionM;\n        int endIndex = (s + 1) * DimensionM;\n        int subvectorCode = encoded.get(s) & 0xFF;\n\n        for (int i = startIndex; i < endIndex; i++) {\n            reconstructed[i] = Codebooks[s][subvectorCode][i - startIndex];\n        }\n    }\n\n    target.setData(reconstructed);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": {"response": ["```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    int dimension = target.getDimension();\n    float[] centroid = new float[dimension];\n    for (int i = 0; i < dimension; i++) {\n        centroid[i] = globalCentroid.get(i);\n    }\n    \n    for (int i = 0; i < encoded.size(); i++) {\n        int index = encoded.get(i) & 0xFF;\n        float[] codeword = codebook[index];\n        for (int j = 0; j < dimension; j++) {\n            target.set(i * dimension + j, codeword[j] + centroid[j]);\n        }\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": {"response": ["Here is the code for the `invert()` function based on the provided function signature and natural language annotations:\n\n```java\npublic Matrix invert() {\n    int n = rows;\n    \n    // Create an identity matrix of the same size\n    Matrix identity = new Matrix(n, n);\n    for (int i = 0; i < n; i++) {\n        identity.data[i][i] = 1;\n    }\n    \n    // Augment the original matrix with the identity matrix\n    Matrix augmented = new Matrix(n, 2 * n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            augmented.data[i][j] = data[i][j];\n            augmented.data[i][j + n] = identity.data[i][j];\n        }\n    }\n    \n    // Perform Gaussian elimination\n    for (int i = 0; i < n; i++) {\n        // Find the pivot element\n        double pivot = augmented.data[i][i];\n        \n        // Divide the current row by the pivot\n        for (int j = 0; j < 2 * n; j++) {\n            augmented.data[i][j] /= pivot;\n        }\n        \n        // Subtract the current row from all other rows\n        for (int k = 0; k < n; k++) {\n            if (k != i) {\n                double factor = augmented.data[k][i];\n                for (int j = 0; j < 2 * n; j++) {\n                    augmented.data[k][j] -= factor * augmented.data[i][j];\n                }\n            }\n        }\n    }\n    \n    // Extract the inverse matrix from the augmented matrix\n    Matrix inverse = new Matrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            inverse.data[i][j] = augmented.data[i][j + n];\n        }\n    }\n    \n    return inverse;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public Matrix invert() {\n# Natural Language Annotations: /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": {"response": ["```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.size() != b.size()) {\n        throw new IllegalArgumentException(\"Vectors must have the same dimension\");\n    }\n    \n    float dotProduct = 0.0f;\n    float normA = 0.0f;\n    float normB = 0.0f;\n    \n    for (int i = 0; i < a.size(); i++) {\n        dotProduct += a.get(i) * b.get(i);\n        normA += a.get(i) * a.get(i);\n        normB += b.get(i) * b.get(i);\n    }\n    \n    if (normA == 0.0f || normB == 0.0f) {\n        return 0.0f;\n    }\n    \n    return dotProduct / (float) Math.sqrt(normA * normB);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n# Natural Language Annotations: /**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": {"response": ["```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    int size = vectors.size();\n    if (size == 0) {\n        return SearchResult.EMPTY;\n    }\n    \n    HnswGraphSearcher graphSearcher = null;\n    if (graph != null) {\n        graphSearcher = new HnswGraphSearcher(graph, vectors, similarityFunction, acceptOrds);\n    }\n\n    TopHits topHits = TopHits.of(topK, size);\n    KnnCounter counter = null;\n    if (graphSearcher != null) {\n        counter = graphSearcher.search(queryVector, topK, topHits.getMaxScore());\n    }\n\n    if (counter == null || counter.count() < topK) {\n        topHits = exactSearch(queryVector, size, vectors, similarityFunction, acceptOrds, topHits, counter);\n    } else {\n        topHits.setTotalHits(counter.count());\n    }\n\n    return topHits.toSearchResult();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n# Natural Language Annotations: /**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": {"response": ["```java\npublic int[] nodesCopy() {\n    return Arrays.copyOf(nodes, nodes.length);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int[] nodesCopy() {\n# Natural Language Annotations: /** Returns a copy of the internal nodes array. Not sorted by score! */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": {"response": ["Here is the function based on the provided signature and natural language annotations:\n\n```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    float worstScore = Float.NEGATIVE_INFINITY;\n    int numReranked = 0;\n\n    while (numReranked < topK && !reranked.isEmpty() && reranked.topScore() >= rerankFloor) {\n        Node node = reranked.pop();\n        float exactScore = reranker.score(node);\n        node.score = exactScore;\n\n        if (exactScore >= worstScore) {\n            reranked.add(node);\n            worstScore = reranked.topScore();\n            numReranked++;\n        } else {\n            unused.add(node);\n        }\n    }\n\n    while (!reranked.isEmpty()) {\n        unused.add(reranked.pop());\n    }\n\n    return worstScore;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n# Natural Language Annotations: /**\n     * Rerank results and return the worst approximate score that made it into the topK.\n     * The topK results will be placed into `reranked`, and the remainder into `unused`.\n     * <p>\n     * Only the best result or results whose approximate score is at least `rerankFloor` will be reranked.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": {"response": ["```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray merged = new NodeArray();\n    \n    int i = 0, j = 0;\n    while (i < a1.size() && j < a2.size()) {\n        if (a1.get(i).compareTo(a2.get(j)) <= 0) {\n            merged.add(a1.get(i));\n            i++;\n        } else {\n            merged.add(a2.get(j));\n            j++;\n        }\n    }\n    \n    while (i < a1.size()) {\n        merged.add(a1.get(i));\n        i++;\n    }\n    \n    while (j < a2.size()) {\n        merged.add(a2.get(j));\n        j++;\n    }\n    \n    return merged;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static NodeArray merge(NodeArray a1, NodeArray a2) {\n# Natural Language Annotations: /** always creates a new NodeArray to return, even when a1 or a2 is empty */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": {"response": ["```java\npublic void addInOrder(int newNode, float newScore) {\n    if (size == 0) {\n        nodes[0] = newNode;\n        scores[0] = newScore;\n        size++;\n    } else {\n        int index = size;\n        while (index > 0 && scores[index - 1] > newScore) {\n            nodes[index] = nodes[index - 1];\n            scores[index] = scores[index - 1];\n            index--;\n        }\n        nodes[index] = newNode;\n        scores[index] = newScore;\n        size++;\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void addInOrder(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": {"response": ["```java\npublic int insertSorted(int newNode, float newScore) {\n    // Check if the node already exists\n    for (int i = 0; i < size; i++) {\n        if (nodes[i] == newNode && scores[i] == newScore) {\n            return -1; // Duplicate node + score pair, ignore\n        }\n    }\n\n    // Find the insertion point\n    int insertionPoint = 0;\n    while (insertionPoint < size && scores[insertionPoint] > newScore) {\n        insertionPoint++;\n    }\n\n    // Shift elements to the right to make space for the new node\n    for (int i = size; i > insertionPoint; i--) {\n        nodes[i] = nodes[i - 1];\n        scores[i] = scores[i - 1];\n    }\n\n    // Insert the new node and score at the insertion point\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    size++;\n\n    return insertionPoint;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int insertSorted(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": {"response": ["```java\npublic void retain(Bits selected) {\n    int newSize = 0;\n    for (int i = 0; i < size; i++) {\n        if (selected.get(i)) {\n            nodes[newSize++] = nodes[i];\n        }\n    }\n    size = newSize;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void retain(Bits selected) {\n# Natural Language Annotations: /**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": {"response": ["```java\npublic void add(int newNode, float newScore) {\n    if (size < capacity) {\n        nodes[size] = newNode;\n        scores[size] = newScore;\n        size++;\n    } else if (newScore < scores[size - 1]) {\n        nodes[size - 1] = newNode;\n        scores[size - 1] = newScore;\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void add(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": {"response": ["```cpp\nvoid addNode(int nodeId, NodeArray nodes) {\n    if (nodeId < 0 || nodeId >= nodes.size()) {\n        throw std::out_of_range(\"Invalid node ID\");\n    }\n    nodes[nodeId].setId(nodeId);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void addNode(int nodeId, NodeArray nodes) {\n# Natural Language Annotations: /**\n     * Only for internal use and by Builder loading a saved graph\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": {"response": ["```java\npublic synchronized long removeDeletedNodes() {\n    long memoryReclaimed = 0;\n    List<Node> nodesToRemove = new ArrayList<>();\n\n    // Identify nodes marked for deletion\n    for (Node node : nodes.values()) {\n        if (node.isMarkedForDeletion()) {\n            nodesToRemove.add(node);\n        }\n    }\n\n    // Remove nodes and update neighbor lists\n    for (Node node : nodesToRemove) {\n        memoryReclaimed += node.getMemorySize();\n        nodes.remove(node.getId());\n\n        for (Node neighbor : node.getNeighbors()) {\n            neighbor.removeNeighbor(node);\n        }\n    }\n\n    return memoryReclaimed;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized long removeDeletedNodes() {\n# Natural Language Annotations: /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": {"response": ["```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    long offset = (long) ordinal * inlineSize;\n    raf.seek(offset);\n\n    for (FeatureId featureId : schema.inlineSchema().featureIds()) {\n        Feature.State state = stateMap.get(featureId);\n        if (state == null) {\n            state = Feature.State.UNKNOWN;\n        }\n        raf.writeInt(state.ordinal());\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException\n# Natural Language Annotations: /**\n     * Write the inline features of the given ordinal to the output at the correct offset.\n     * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": {"response": ["```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> renumbering = new HashMap<>();\n    int newOrdinal = 0;\n    for (int oldOrdinal = 0; oldOrdinal < graph.nodeCount(); oldOrdinal++) {\n        if (graph.exists(oldOrdinal)) {\n            renumbering.put(oldOrdinal, newOrdinal);\n            newOrdinal++;\n        }\n    }\n    return renumbering;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n# Natural Language Annotations: /**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": {"response": ["```cpp\npublic static void write(GraphIndex graph,\n                         const std::string& index_dir,\n                         int max_degree,\n                         DistanceMetric metric,\n                         bool support_eager_delete) {\n  std::vector<uint32_t> medoids;\n  std::vector<uint32_t> out_degrees;\n  std::vector<uint32_t> in_degrees;\n  std::vector<uint32_t> offsets;\n  std::vector<uint32_t> destinations;\n  std::vector<float> edge_weights;\n\n  graph.save(index_dir, max_degree, metric, support_eager_delete, medoids,\n             out_degrees, in_degrees, offsets, destinations, edge_weights);\n\n  std::string index_file = index_dir + \"/index.bin\";\n  FILE* fp = fopen(index_file.c_str(), \"wb\");\n  fwrite(medoids.data(), sizeof(uint32_t), medoids.size(), fp);\n  fwrite(out_degrees.data(), sizeof(uint32_t), out_degrees.size(), fp);\n  fwrite(in_degrees.data(), sizeof(uint32_t), in_degrees.size(), fp);\n  fwrite(offsets.data(), sizeof(uint32_t), offsets.size(), fp);\n  fwrite(destinations.data(), sizeof(uint32_t), destinations.size(), fp);\n  fwrite(edge_weights.data(), sizeof(float), edge_weights.size(), fp);\n  fclose(fp);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void write(GraphIndex graph,\n# Natural Language Annotations: /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": {"response": ["```java\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public ScoreFunction buildScorer(LeafReaderContext context) throws IOException {\n            return new ScoreFunction() {\n                @Override\n                public double score(int docId, float boost) throws IOException {\n                    ravv.setReader(context.reader());\n                    return similarityFunction.compare(ravv.vectorValue(docId), ravv.centroidValue()) * boost;\n                }\n\n                @Override\n                public Explanation explain(int docId, Explanation boostExplanation) throws IOException {\n                    ravv.setReader(context.reader());\n                    float score = (float) similarityFunction.compare(ravv.vectorValue(docId), ravv.centroidValue());\n                    return Explanation.match(\n                        score,\n                        \"Exact vector score function on doc \" + docId + \", computed from:\",\n                        Explanation.match((float) similarityFunction.compare(ravv.vectorValue(docId), ravv.centroidValue()), \"Vector score between document and centroid\"),\n                        boostExplanation\n                    );\n                }\n\n                @Override\n                public boolean equals(Object o) {\n                    if (this == o) return true;\n                    if (o == null || getClass() != o.getClass()) return false;\n                    return true;\n                }\n\n                @Override\n                public int hashCode() {\n                    return getClass().hashCode();\n                }\n            };\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            return true;\n        }\n\n        @Override\n        public int hashCode() {\n            return getClass().hashCode();\n        }\n    };\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": {"response": ["```java\npublic static double[] determineStandardDeviationDoubles(List<BenchmarkResult> results, double averageScore) {\n    return results.stream()\n            .mapToDouble(result -> {\n                double difference = result.getAverageScore() - averageScore;\n                return difference * difference;\n            })\n            .map(Math::sqrt)\n            .toArray();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double[] determineStandardDeviationDoubles(\n# Natural Language Annotations: /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": {"response": ["```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata stackMetadata = new StackMetadata();\n    stackMetadata.clear();\n    for (ValueSourceInfo type : types) {\n        stackMetadata.push(type);\n    }\n    return stackMetadata;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata stack(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": {"response": ["```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"Number of types must match the number of local variable types.\");\n    }\n    return new StackMetadata(localVariableTypes, Arrays.asList(types), stackTypes);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata locals(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": {"response": ["```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    int namei = functionMetadata.getIntArg();\n    String methodName = functionMetadata.getNames()[namei];\n    \n    PyObject obj = stackMetadata.popTOS();\n    PyObject method = obj.getMethod(methodName);\n    \n    if (method != null) {\n        stackMetadata.pushTOS(method);\n        stackMetadata.pushTOS(obj);\n    } else {\n        PyObject attributeValue = obj.getAttribute(methodName);\n        stackMetadata.pushTOS(null);\n        stackMetadata.pushTOS(attributeValue);\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": {"response": ["```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    int argc = functionMetadata.getArgc();\n    \n    // Generate code to load the arguments onto the stack\n    for (int i = argc - 1; i >= 0; i--) {\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, stackMetadata.getStackSize() - argc + i);\n    }\n    \n    // Generate code to load the callable onto the stack\n    methodVisitor.visitVarInsn(Opcodes.ALOAD, stackMetadata.getStackSize() - argc - 2);\n    \n    // Generate code to load self onto the stack (if applicable)\n    if (functionMetadata.hasSelf()) {\n        methodVisitor.visitVarInsn(Opcodes.ALOAD, stackMetadata.getStackSize() - argc - 1);\n    }\n    \n    // Generate the method invocation instruction\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, functionMetadata.getClassName(), functionMetadata.getMethodName(), functionMetadata.getMethodDescriptor(), false);\n    \n    // Update the stack metadata\n    stackMetadata.popMany(argc + 2); // Pop the arguments, callable, and self (if applicable)\n    stackMetadata.push(functionMetadata.getReturnType()); // Push the return value\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor,\n# Natural Language Annotations: /**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": {"response": ["```java\npublic static void callFunction(FunctionMetadata functionMetadata) {\n    int argc = functionMetadata.getArgc();\n    Object[] args = new Object[argc];\n    for (int i = argc - 1; i >= 0; i--) {\n        args[i] = pop();\n    }\n    Object function = pop();\n    Object result = ((Function) function).apply(args);\n    push(result);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunction(FunctionMetadata functionMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": {"response": ["```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    int argc = functionMetadata.getArgc();\n    PyObject[] args = new PyObject[argc];\n    PyObject[] keywords = new PyObject[argc];\n    String[] keywordNames = new String[argc];\n\n    PyTuple keywordNamesTuple = (PyTuple) stackMetadata.pop();\n    int numKeywords = keywordNamesTuple.size();\n\n    for (int i = 0; i < numKeywords; i++) {\n        keywords[i] = stackMetadata.pop();\n        keywordNames[i] = keywordNamesTuple.pyget(i).asString();\n    }\n\n    for (int i = argc - 1; i >= numKeywords; i--) {\n        args[i] = stackMetadata.pop();\n    }\n\n    PyObject function = stackMetadata.pop();\n    PyObject result = function.__call__(args, keywords, keywordNames);\n    stackMetadata.push(result);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": {"response": ["```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    if ((functionMetadata.getInstruction().getArg() & 1) != 0) {\n        // Keyword arguments\n        Map<String, Object> kwargs = (Map<String, Object>) stackMetadata.pop();\n        // Positional arguments\n        Iterable<Object> args = (Iterable<Object>) stackMetadata.pop();\n        // Callable\n        Callable callable = (Callable) stackMetadata.pop();\n        callable.call(args, kwargs);\n    } else {\n        // Positional arguments\n        Iterable<Object> args = (Iterable<Object>) stackMetadata.pop();\n        // Callable\n        Callable callable = (Callable) stackMetadata.pop();\n        callable.call(args);\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": {"response": ["```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    Object value = functionMetadata.getGlobalVariable(globalIndex);\n    stackMetadata.push(value);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex,\n# Natural Language Annotations: /**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": {"response": ["```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    PythonCell cell = functionMetadata.cellVariables[cellIndex];\n    stackMetadata.push(cell);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n# Natural Language Annotations: /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": {"response": ["```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    String attributeName = functionMetadata.getCodeObject().co_names[nameIndex];\n    PyObject object = stackMetadata.popTOS();\n    PyObject attribute = object.__getattr__(attributeName);\n    stackMetadata.pushTOS(attribute);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n# Natural Language Annotations: /**\n     * Replaces TOS with getattr(TOS, co_names[instruction.arg])\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": {"response": ["```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    int entityCount = 0;\n    int valueCount = 0;\n\n    for (Object entity : solution.getProblemFacts()) {\n        entityCount++;\n        if (entity instanceof Collection) {\n            valueCount += ((Collection<?>) entity).size();\n        } else {\n            valueCount++;\n        }\n    }\n\n    return Math.log10(Math.pow(valueCount, entityCount));\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n# Natural Language Annotations: /**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n     * @param solution never null\n     * @return {@code >= 0}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": {"response": ["```java\npublic static void defineClonerFor(ClassCreator classCreator) {\n    MethodCreator constructor = classCreator.getMethodCreator(\"<init>\", \"void\");\n    constructor.setModifiers(Modifier.PUBLIC);\n    constructor.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), constructor.getThis());\n    constructor.returnValue(null);\n\n    MethodCreator cloneSolution = classCreator.getMethodCreator(\"cloneSolution\", Object.class, Object.class);\n    cloneSolution.setModifiers(Modifier.PUBLIC);\n    ResultHandle solutionHandle = cloneSolution.getMethodParam(0);\n    ResultHandle clonedSolutionHandle = cloneSolution.invokeVirtualMethod(\n            MethodDescriptor.ofMethod(Object.class, \"clone\", Object.class), solutionHandle);\n    cloneSolution.returnValue(clonedSolutionHandle);\n\n    MethodCreator cloneSolutionList = classCreator.getMethodCreator(\"cloneSolutionList\", List.class, List.class);\n    cloneSolutionList.setModifiers(Modifier.PUBLIC);\n    ResultHandle solutionListHandle = cloneSolutionList.getMethodParam(0);\n    ResultHandle clonedSolutionListHandle = cloneSolutionList.newInstance(\n            MethodDescriptor.ofConstructor(ArrayList.class, Collection.class), solutionListHandle);\n    cloneSolutionList.returnValue(clonedSolutionListHandle);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void defineClonerFor(ClassCreator classCreator,\n# Natural Language Annotations: /**\n     * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given\n     * ClassCreator\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": {"response": ["```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder violationMessage = new StringBuilder();\n    int totalViolations = 0;\n\n    for (ShadowVariableDescriptor<?> descriptor : shadowVariableDescriptors) {\n        int violationCount = 0;\n        for (Object entity : descriptor.getEntities()) {\n            Object recordedValue = descriptor.getRecordedValue(entity);\n            Object actualValue = descriptor.getValue(entity);\n            if (!Objects.equals(recordedValue, actualValue)) {\n                if (violationCount < violationDisplayLimit) {\n                    violationMessage.append(\"Violation for \").append(descriptor.getVariableName())\n                            .append(\" on entity \").append(entity).append(\":\\n\")\n                            .append(\"  Recorded value: \").append(recordedValue).append(\"\\n\")\n                            .append(\"  Actual value: \").append(actualValue).append(\"\\n\");\n                }\n                violationCount++;\n                totalViolations++;\n            }\n        }\n        if (violationCount > violationDisplayLimit) {\n            violationMessage.append(\"... \").append(violationCount - violationDisplayLimit)\n                    .append(\" more violations for \").append(descriptor.getVariableName()).append(\"\\n\");\n        }\n    }\n\n    if (totalViolations == 0) {\n        return null;\n    }\n    return violationMessage.toString();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n# Natural Language Annotations: /**\n     * Takes a look at the shadow variables of all entities and compares them against the recorded state. Every difference\n     * is added to the violation message. The first N differences up to the {@code violationDisplayLimit} are displayed\n     * in detail; the number of violations exceeding the display limit is reported at the end. The limit applies per each\n     * shadow variable descriptor.\n     * <p>\n     * This method should be called after a forceful trigger of variable listeners.\n     *\n     * @param violationDisplayLimit maximum number of violations reported per shadow variable descriptor\n     * @return description of the violations or {@code null} if there are none\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": {"response": ["```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n                                                  Class<? extends Annotation> annotationClass,\n                                                  DomainAccessType domainAccessType) {\n    MemberAccessor memberAccessor = memberAccessorMap.get(member);\n    if (memberAccessor == null) {\n        memberAccessor = MemberAccessorFactory.createMemberAccessor(member, memberAccessorType, annotationClass, domainAccessType);\n        memberAccessorMap.put(member, memberAccessor);\n    }\n    return memberAccessor;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n# Natural Language Annotations: /**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": {"response": ["```java\npublic static String getGeneratedClassName(Member member) {\n    if (member instanceof Method) {\n        return getGeneratedClassName((Method) member);\n    } else if (member instanceof Constructor) {\n        return getGeneratedClassName((Constructor<?>) member);\n    } else {\n        throw new IllegalArgumentException(\"Unsupported member type: \" + member.getClass().getName());\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String getGeneratedClassName(Member member) {\n# Natural Language Annotations: /**\n     * Returns the generated class name for a given member.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": {"response": ["```java\nstatic MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    if (gizmoClassLoader == null) {\n        throw new IllegalArgumentException(\"gizmoClassLoader cannot be null\");\n    }\n\n    if (member instanceof Field) {\n        return new FieldAccessor((Field) member, annotationClass, returnTypeRequired, gizmoClassLoader);\n    } else if (member instanceof Method) {\n        return new MethodAccessor((Method) member, annotationClass, returnTypeRequired, gizmoClassLoader);\n    } else {\n        throw new IllegalArgumentException(\"Member must be either a Field or a Method\");\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass,\n# Natural Language Annotations: /**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": {"response": ["```java\nvoid set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n# Natural Language Annotations: /**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": {"response": ["```java\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    CompletableFuture<Void> future = new CompletableFuture<>();\n    solver.addProblemChange(problemChange,\n            (solution) -> {\n                // Pass the solution to the user-defined Consumer\n                future.complete(null);\n            });\n    return future;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n# Natural Language Annotations: /**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": {"response": ["```java\npublic static long nextLong(Random random, long n) {\n    if (n <= 0) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n    long bits, val;\n    do {\n        bits = (random.nextLong() << 1) >>> 1;\n        val = bits % n;\n    } while (bits - val + (n - 1) < 0L);\n    return val;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static long nextLong(Random random, long n) {\n# Natural Language Annotations: /**\n     * Mimics {@link Random#nextInt(int)} for longs.\n     *\n     * @param random never null\n     * @param n {@code > 0L}\n     * @return like {@link Random#nextInt(int)} but for a long\n     * @see Random#nextInt(int)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": {"response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double timeGradient = Double.MAX_VALUE;\n    for (Termination termination : terminationList) {\n        double nextTimeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (nextTimeGradient >= 0.0) {\n            timeGradient = Math.min(timeGradient, nextTimeGradient);\n        }\n    }\n    return timeGradient;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": {"response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minimumTimeGradient = Double.POSITIVE_INFINITY;\n    for (Termination termination : phaseScope.getTerminationList()) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient >= 0.0) {\n            minimumTimeGradient = Math.min(minimumTimeGradient, timeGradient);\n        }\n    }\n    return minimumTimeGradient;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": {"response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double timeGradient = -1.0;\n    for (Termination termination : terminationList) {\n        double nextTimeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (nextTimeGradient >= 0.0) {\n            timeGradient = Math.max(timeGradient, nextTimeGradient);\n        }\n    }\n    return timeGradient;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": {"response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    return terminationList.stream()\n            .mapToDouble(Termination::calculatePhaseTimeGradient)\n            .filter(timeGradient -> timeGradient >= 0.0)\n            .max()\n            .orElse(0.0);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": {"response": ["```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    int[] permutation = kOptDescriptor.getRemovedEdgeIndexToTourOrder();\n    int[] inversePermutation = new int[permutation.length];\n    boolean[] visited = new boolean[permutation.length];\n    KOptCycle kOptCycle = new KOptCycle();\n\n    for (int i = 0; i < permutation.length; i++) {\n        inversePermutation[permutation[i]] = i;\n    }\n\n    for (int i = 0; i < permutation.length; i++) {\n        if (!visited[i]) {\n            List<Integer> cycle = new ArrayList<>();\n            int current = i;\n            do {\n                visited[current] = true;\n                cycle.add(current);\n                current = inversePermutation[current];\n            } while (current != i);\n            kOptCycle.addCycle(cycle);\n        }\n    }\n\n    return kOptCycle;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n# Natural Language Annotations: /**\n     * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n     * <br />\n     * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n     * unique elements (p_1, p_2, ..., p_k) where\n     * <ul>\n     * <li>p_1 maps to p_2 in the permutation</li>\n     * <li>p_2 maps to p_3 in the permutation</li>\n     * <li>p_(k-1) maps to p_k in the permutation</li>\n     * <li>p_k maps to p_1 in the permutation</li>\n     * <li>In general: p_i maps to p_(i+1) in the permutation</li>\n     * </ul>\n     * For instance, the permutation\n     * <ul>\n     * <li>1 -> 2</li>\n     * <li>2 -> 3</li>\n     * <li>3 -> 1</li>\n     * <li>4 -> 5</li>\n     * <li>5 -> 4</li>\n     * </ul>\n     * can be expressed as `(1, 2, 3)(4, 5)`.\n     *\n     * @return The {@link KOptCycle} corresponding to the permutation described by\n     *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n     * @param kOptDescriptor The descriptor to calculate cycles for\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": {"response": ["```java\nTriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"listSize must be greater than or equal to minimumSubListSize\");\n    }\n    \n    int subListSize = minimumSubListSize + random.nextInt(Math.min(listSize, maximumSubListSize) - minimumSubListSize + 1);\n    int startIndex = random.nextInt(listSize - subListSize + 1);\n    int endIndex = startIndex + subListSize;\n    \n    return new TriangleElement(startIndex, endIndex);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n# Natural Language Annotations: /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": {"response": ["```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    if (isConstraintStream()) {\n        if (hasCustomJustificationMapping()) {\n            throw new IllegalStateException(\"Constraint (\" + this +\n                    \") with custom justification mapping (\" + getJustificationMapping() +\n                    \") should be accessed via getJustification() instead.\");\n        }\n        return justificationList;\n    } else {\n        return incrementalScoreCalculator.getJustificationList();\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true)    public List<Object> getJustificationList() {\n# Natural Language Annotations: /**\n     * Return a list of justifications for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n     * (eg. [A, B] for a bi stream),\n     * unless a custom justification mapping was provided, in which case it throws an exception,\n     * pointing users towards {@link #getJustification()}.</li>\n     * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": {"response": ["```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n                UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return new UniConstraintCollector<>(\n            () -> Pair.of(subCollector1.supplier().get(), subCollector2.supplier().get()),\n            (resultContainer, a) -> {\n                subCollector1.accumulator().accept(resultContainer.getKey(), a);\n                subCollector2.accumulator().accept(resultContainer.getValue(), a);\n            },\n            subCollector1.finisher(),\n            subCollector2.finisher(),\n            composeFunction);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>            UniConstraintCollector<A, ?, Result_> compose(\n# Natural Language Annotations: /**\n     * Returns a constraint collector the result of which is a composition of other constraint collectors.\n     * The return value of this collector, incl. the default return value, depends solely on the compose function.\n     *\n     * @param subCollector1 never null, first collector to compose\n     * @param subCollector2 never null, second collector to compose\n     * @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": {"response": ["Here is the function implementation based on the provided signature and natural language annotations:\n\n```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n        UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\n        toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n                          BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return new UniConstraintCollector<A, List<Range<A, PointType_>>, ConnectedRangeChain<A, PointType_, DifferenceType_>>() {\n        @Override\n        public Supplier<List<Range<A, PointType_>>> supplier() {\n            return ArrayList::new;\n        }\n\n        @Override\n        public BiConsumer<List<Range<A, PointType_>>, A> accumulator() {\n            return (list, a) -> list.add(new Range<>(a, startInclusiveMap.apply(a), endExclusiveMap.apply(a)));\n        }\n\n        @Override\n        public BinaryOperator<List<Range<A, PointType_>>> combiner() {\n            return (list1, list2) -> {\n                list1.addAll(list2);\n                return list1;\n            };\n        }\n\n        @Override\n        public Function<List<Range<A, PointType_>>, ConnectedRangeChain<A, PointType_, DifferenceType_>> finisher() {\n            return list -> ConnectedRangeChain.of(list, differenceFunction);\n        }\n    };\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>            toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n# Natural Language Annotations: /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n     *                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n     *                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": {"response": ["```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (this == other) {\n        return new ScoreAnalysis<>(Score_.zero(score.getInitScore()), ImmutableMap.of());\n    }\n    if (this.getClass() != other.getClass()) {\n        throw new IllegalStateException(\"Incompatible score analysis classes (\" +\n                this.getClass() + \" and \" + other.getClass() + \") to diff.\");\n    }\n    Score_ diffScore = score.subtract(other.getScore());\n    if (!hasMatchDetails() && !other.hasMatchDetails()) {\n        return new ScoreAnalysis<>(diffScore, ImmutableMap.of());\n    } else if (hasMatchDetails() != other.hasMatchDetails()) {\n        throw new IllegalStateException(\"Impossible state: only one of the ScoreAnalysis\" +\n                \" instances has match details.\");\n    }\n    Map<Object, MatchAnalysis> diffMap = new LinkedHashMap<>(matchAnalysisMap.size());\n    for (Map.Entry<Object, MatchAnalysis> entry : matchAnalysisMap.entrySet()) {\n        MatchAnalysis otherAnalysis = other.getMatchAnalysisMap().get(entry.getKey());\n        if (otherAnalysis == null) {\n            diffMap.put(entry.getKey(), entry.getValue());\n        } else {\n            MatchAnalysis diff = entry.getValue().diff(otherAnalysis);\n            if (!diff.isEmpty()) {\n                diffMap.put(entry.getKey(), diff);\n            }\n        }\n    }\n    for (Map.Entry<Object, MatchAnalysis> entry : other.getMatchAnalysisMap().entrySet()) {\n        if (!matchAnalysisMap.containsKey(entry.getKey())) {\n            diffMap.put(entry.getKey(), entry.getValue().negate());\n        }\n    }\n    return new ScoreAnalysis<>(diffScore, diffMap);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n# Natural Language Annotations: /**\n     * Compare this {@link ScoreAnalysis} to another {@link ScoreAnalysis}\n     * and retrieve the difference between them.\n     * The comparison is in the direction of {@code this - other}.\n     * <p>\n     * Example: if {@code this} has a score of 100 and {@code other} has a score of 90,\n     * the returned {@link ScoreAnalysis#score} will be 10.\n     * If this and other were inverted, the score would have been -10.\n     * The same applies to all other properties of {@link ScoreAnalysis}.\n     *\n     * <p>\n     * In order to properly diff {@link MatchAnalysis} against each other,\n     * we rely on the user implementing {@link ConstraintJustification} equality correctly.\n     * In other words, the diff will consider two justifications equal if the user says they are equal,\n     * and it expects the hash code to be consistent with equals.\n     *\n     * <p>\n     * If one {@link ScoreAnalysis} provides {@link MatchAnalysis} and the other doesn't, exception is thrown.\n     * Such {@link ScoreAnalysis} instances are mutually incompatible.\n     *\n     * @param other never null\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": {"response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n    summary.append(\"Score summary for solution:\\n\");\n    summary.append(\"- Feasible: \").append(isFeasible()).append(\"\\n\");\n    summary.append(\"- Score: \").append(getScore()).append(\"\\n\");\n    summary.append(\"\\nConstraint analysis:\\n\");\n\n    for (ConstraintAnalysis<?> analysis : constraintAnalyses()) {\n        summary.append(\"- Constraint: \").append(analysis.getConstraintId()).append(\"\\n\");\n        summary.append(\"  - Match count: \").append(analysis.getMatchCount()).append(\"\\n\");\n        summary.append(\"  - Score: \").append(analysis.getScore()).append(\"\\n\");\n    }\n\n    return summary.toString();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, provide this information in a UI or a service,\n     * use {@link ScoreAnalysis#constraintAnalyses()}\n     * and convert those into a domain-specific API.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": {"response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n    for (ConstraintAnalysis analysis : constraintAnalyses) {\n        if (analysis.getScore() < analysis.getConstraint().getMaximumScore()) {\n            summary.append(\"    \").append(analysis.getConstraint().getName())\n                    .append(\": \").append(analysis.toString()).append(\"\\n\");\n        }\n    }\n    return summary.length() == 0 ? \"No issues found.\" : summary.toString();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": {"response": ["```\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormat formatter = (DecimalFormat) decimalFormat.clone();\n    formatter.setDecimalFormatSymbols(DecimalFormatSymbols.getInstance(locale));\n    return formatter.format(number);\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n# Natural Language Annotations: /**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": {"response": ["```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<? super ProblemId_, ? extends Solution_> problemFinder,\n        Consumer<? super Solution_> bestSolutionConsumer) {\n    return solveBuilder()\n            .withProblemId(problemId)\n            .withProblemFinder(problemFinder)\n            .withBestSolutionConsumer(bestSolutionConsumer)\n            .build();\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true, since = \"1.6.0\")    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n# Natural Language Annotations: /**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n     * unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n     *        {@link #getSolverStatus(Object) to get the status} or if the problem changes while solving.\n     * @param problemFinder never null, a function that returns a {@link PlanningSolution}, usually with uninitialized planning\n     *        variables\n     * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n     * @deprecated It is recommended to use {@link #solveBuilder()} while also providing a consumer for the best solution\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": {"response": ["```\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (spentLimit != null) {\n        terminationConfig.withSpentLimit(spentLimit);\n    }\n    return this;\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n# Natural Language Annotations: /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": {"response": ["```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T meldProperty(T a, T b) {\n# Natural Language Annotations: /**\n     * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n     * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n     * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n     * property of the benchmark that didn't fail.\n     * <p>\n     * Null-handling:\n     * <ul>\n     * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n     * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n     * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n     * {@link #mergeProperty(Object, Object)}</li>\n     * </ul>\n     *\n     * @see #mergeProperty(Object, Object)\n     * @param a property {@code a}\n     * @param b property {@code b}\n     * @param <T> the type of property {@code a} and {@code b}\n     * @return sometimes null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n"}}