{"litestar-litestar/file_system.py-info": {"response": ["```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    full_path = self._get_full_path(path)\n    stat = await aiofiles.os.stat(full_path)\n\n    info = {\n        \"name\": os.path.basename(full_path),\n        \"path\": path,\n        \"size\": stat.st_size,\n        \"mtime\": stat.st_mtime,\n        \"ctime\": stat.st_ctime,\n        \"type\": \"file\" if os.path.isfile(full_path) else \"dir\",\n    }\n\n    return info\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n# Natural Language Annotations: \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/typing.py-has_inner_subclass_of": {"response": ["```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    return any(isinstance(arg, type) and issubclass(arg, cl) for arg in self.__args__)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n# Natural Language Annotations: \"\"\"Whether any generic args are a subclass of the given type.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether any of the type's generic args are a subclass of the given type.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/typing.py-get_type_hints": {"response": ["```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    hints = get_type_hints(self.__class__, include_extras=include_extras)\n    if resolve_generics:\n        hints = {\n            attr: resolve_generic(hint) if is_generic_type(hint) else hint\n            for attr, hint in hints.items()\n        }\n    return {\n        attr: hint\n        for attr, hint in hints.items()\n        if attr in self.__annotations__\n    }\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the type hints for the annotation.\n\n        Args:\n            include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n            resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n        Returns:\n            The type hints.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/typing.py-from_kwarg": {"response": ["```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any,\n    inner_types: Optional[Tuple[FieldDefinition, ...]] = None,\n    kwarg_definition: Optional[KwargParameter] = None,\n    extra: Optional[Dict[str, Any]] = None,\n) -> FieldDefinition:\n    if inner_types is None:\n        inner_types = ()\n    if extra is None:\n        extra = {}\n    \n    return FieldDefinition(\n        annotation=annotation,\n        name=name,\n        default=default,\n        required=default is Required,\n        inner_types=inner_types,\n        kwarg_definition=kwarg_definition,\n        extra=extra,\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_kwarg(\n# Natural Language Annotations: \"\"\"Create a new FieldDefinition instance.\n\n        Args:\n            annotation: The type of the kwarg.\n            name: Field name.\n            default: A default value.\n            inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n            kwarg_definition: Kwarg Parameter.\n            extra: A mapping of extra values.\n\n        Returns:\n            FieldDefinition instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/typing.py-from_parameter": {"response": ["```python\n@classmethod\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    name = parameter.name\n    default = parameter.default if parameter.default is not Parameter.empty else None\n    required = default is None\n    annotation = parameter.annotation if parameter.annotation is not Parameter.empty else None\n    type_hint = fn_type_hints.get(name, annotation)\n\n    field = FieldDefinition(\n        name=name,\n        type_hint=type_hint,\n        default=default,\n        required=required,\n    )\n    return field\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n# Natural Language Annotations: \"\"\"Initialize ParsedSignatureParameter.\n\n        Args:\n            parameter: inspect.Parameter\n            fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n                :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n        Returns:\n            ParsedSignatureParameter.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_openapi/responses.py-create_success_response": {"response": ["```python\ndef create_success_response(self) -> OpenAPIResponse:\n    return OpenAPIResponse(\n        description=\"Successful Response\",\n        content={\n            \"application/json\": OpenAPIMediaType(\n                schema=OpenAPISchema(\n                    type=OpenAPIType.OBJECT,\n                    properties={\n                        \"status\": OpenAPISchema(type=OpenAPIType.STRING, example=\"success\"),\n                        \"data\": OpenAPISchema(type=OpenAPIType.OBJECT),\n                    },\n                    required=[\"status\", \"data\"],\n                )\n            )\n        },\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_success_response(self) -> OpenAPIResponse:\n# Natural Language Annotations: \"\"\"Create the schema for a success response.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"response": ["```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    for status_code, response in self.additional_responses.items():\n        yield status_code, OpenAPIResponse(\n            description=response.description,\n            content={\n                \"application/json\": OpenAPIMediaType(\n                    schema=self.create_schema(response.model)\n                )\n            }\n        )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n# Natural Language Annotations: \"\"\"Create the schema for additional responses, if any.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"response": ["```python\ndef create_path_item(self) -> PathItem:\n    path_item = PathItem()\n    for http_method in self.http_methods:\n        operation = self.create_operation(http_method)\n        setattr(path_item, http_method.lower(), operation)\n    return path_item\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_path_item(self) -> PathItem:\n# Natural Language Annotations: \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n        Returns:\n            A PathItem instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"response": ["```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    if field_definition.origin in PRIMITIVE_TYPES:\n        return Schema(type=get_primitive_type(field_definition.origin))\n    elif is_enum(field_definition.origin):\n        return Schema(\n            type=\"string\",\n            enum=[item.value for item in field_definition.origin],\n        )\n    elif field_definition.origin in SEQUENCE_TYPES:\n        sub_schema = self.for_field_definition(\n            dataclasses.replace(\n                field_definition,\n                origin=field_definition.args[0].origin,\n                args=field_definition.args[0].args,\n            ),\n        )\n        return Schema(type=\"array\", items=sub_schema)\n    elif is_dataclass(field_definition.origin):\n        return self.for_dataclass(field_definition.origin)\n    else:\n        return Reference(definition=self.for_dataclass(field_definition.origin))\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n# Natural Language Annotations: \"\"\"Create a Schema for a given FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"response": ["```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    # Create a new TypeScriptNamespace instance\n    ts_namespace = TypeScriptNamespace(namespace)\n\n    # Iterate over each schema in the OpenAPI schema\n    for schema_name, schema in openapi_schema.components.schemas.items():\n        # Convert the schema to a TypeScript type\n        ts_type = convert_schema_to_type(schema)\n\n        # Add the type to the namespace\n        ts_namespace.add_type(schema_name, ts_type)\n\n    # Iterate over each path in the OpenAPI schema\n    for path, path_item in openapi_schema.paths.items():\n        # Iterate over each operation in the path\n        for operation_name, operation in path_item.items():\n            # Convert the operation to a TypeScript function\n            ts_function = convert_operation_to_function(operation, path)\n\n            # Add the function to the namespace\n            ts_namespace.add_function(operation_name, ts_function)\n\n    # Return the generated TypeScript namespace\n    return ts_namespace\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n# Natural Language Annotations: \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"response": ["```python\ndef write(self) -> str:\n    \"\"\"Write a typescript intersection value.\n\n    Example:\n        { prop: string } & { another: number }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    return \" & \".join(\n        f\"{{ {', '.join(f'{key}: {value}' for key, value in type_dict.items())} }}\"\n        for type_dict in self.type_dicts\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def write(self) -> str:\n# Natural Language Annotations: \"\"\"Write a typescript intersection value.\n\n        Example:\n            { prop: string } & { another: number }\n\n        Returns:\n            A typescript string\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/testing/helpers.py-create_test_client": {"response": ["```python\ndef create_test_client(\n    *route_handlers: RouteHandler,\n    backend: str = \"asyncio\",\n    backend_options: dict[str, Any] | None = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHook | None = None,\n    after_response: AfterResponseHook | None = None,\n    allowed_hosts: AllowedHostsConfig | Sequence[str] | None = None,\n    before_request: BeforeRequestHook | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: dict[str, Provider] | None = None,\n    dto: Type[AbstractDTO] | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: Type[BaseEventEmitterBackend] = AsyncIOEventEmitterBackend,\n    exception_handlers: dict[Type[Exception] | int, ExceptionHandler] | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[LifespanHandler] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: BaseLoggingConfig | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = 1000,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig = DEFAULT_OPENAPI_CONFIG,\n    opt: dict[str, Any] | None = None,\n    parameters: dict[str, Parameter] | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[ASGIApp] | None = None,\n    request_class: Type[Request] = Request,\n    response_class: Type[Response] = Response,\n    response_cookies: Sequence[Cookie] | None = None,\n    response_headers: dict[str, ResponseHeader] | None = None,\n    response_cache_config: ResponseCacheConfig | None = None,\n    return_dto: Type[AbstractDTO] | None = None,\n    route_handlers: Sequence[RouteHandler] | None = None,\n    security: Sequence[SecurityRequirement] | None = None,\n    signature_namespace: dict[str, Any] | None = None,\n    signature_types: Sequence[Type[Any]] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: StoreRegistry | dict[str, Store] | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: float | None = None,\n    type_encoders: dict[Type[Any], Callable[[Any], Any]] | None = None,\n    websocket_class: Type[WebSocket] = WebSocket,\n    experimental_features: Sequence[ExperimentalFeature] | None = None,\n) -> TestClient:\n    app = Litestar(\n        *route_handlers,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_test_client(\n# Natural Language Annotations: \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        route_handlers: A sequence of route handlers, which can include instances of\n            :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"response": ["```python\ndef websocket_connect(\n    self,\n    url: str,\n    *,\n    subprotocols: Sequence[str] = None,\n    params: QueryParamTypes = None,\n    headers: HeaderTypes = None,\n    cookies: CookieTypes = None,\n    auth: AuthTypes = None,\n    follow_redirects: bool = False,\n    timeout: Union[TimeoutTypes, UnsetType] = UNSET,\n    extensions: Dict[str, Any] = None,\n) -> \"WebSocketTestSession\":\n    url = self.build_url(url, params=params)\n    headers = self.build_request_headers(headers=headers, cookies=cookies, auth=auth)\n    subprotocols = subprotocols or []\n    timeout = self.timeout if isinstance(timeout, UnsetType) else timeout\n    extensions = extensions or {}\n\n    try:\n        websocket = WebSocketTestSession(\n            url,\n            subprotocols=subprotocols,\n            headers=headers,\n            cookies=self.cookies,\n            http_version=self.http_version,\n            follow_redirects=follow_redirects,\n            timeout=timeout,\n            extensions=extensions,\n        )\n    except WebSocketException as exc:\n        raise WebSocketDisconnect(exc.status_code) from exc\n\n    return websocket\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def websocket_connect(\n# Natural Language Annotations: \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"response": ["```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n    schema = schema_creator.create_schema(field_definition.outer_type_)\n    schema.title = field_definition.name\n    schema.description = field_definition.description\n    schema.default = field_definition.default\n    schema.required = field_definition.required\n    schema.extra = field_definition.extra\n    return schema\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n# Natural Language Annotations: \"\"\"Create a schema object for a given pydantic model class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"response": ["```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    if len(self._generators) > 1:\n        async with anyio.create_task_group() as tg:\n            for generator in self._generators:\n                tg.start_soon(anext, generator)\n    elif len(self._generators) == 1:\n        await anext(self._generators[0])\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def cleanup(self) -> None:\n# Natural Language Annotations: \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n        If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"response": ["```python\ndef build_route_middleware_stack(\n    app: \"Litestar\",\n    route: \"Route\",\n    route_handler: \"RouteHandler\",\n) -> \"ASGIApp\":\n    handler = convert_route_handler_to_asgi(app, route_handler)\n    handler = apply_middleware_to_route_handler(\n        app.route_middleware,\n        route,\n        handler,\n    )\n    handler = apply_middleware_to_route_handler(\n        app.middleware,\n        route,\n        handler,\n    )\n    return handler\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_route_middleware_stack(\n# Natural Language Annotations: \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/signature.py-from_fn": {"response": ["```python\n@classmethod\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    signature = inspect.signature(fn)\n    parameters = []\n    for param_name, param in signature.parameters.items():\n        if param.kind in (param.VAR_POSITIONAL, param.VAR_KEYWORD):\n            raise ValueError(f\"Variable arguments are not supported: {param.name}\")\n        if param.kind == param.KEYWORD_ONLY:\n            raise ValueError(f\"Keyword-only arguments are not supported: {param.name}\")\n        if param.kind == param.POSITIONAL_ONLY:\n            raise ValueError(f\"Positional-only arguments are not supported: {param.name}\")\n        annotation = param.annotation\n        if isinstance(annotation, str):\n            annotation = eval(annotation, signature_namespace)\n        if annotation is param.empty:\n            annotation = Any\n        default = param.default\n        if default is param.empty:\n            default = Undefined\n        parameters.append(Parameter(name=param_name, annotation=annotation, default=default))\n    return_annotation = signature.return_annotation\n    if isinstance(return_annotation, str):\n        return_annotation = eval(return_annotation, signature_namespace)\n    if return_annotation is signature.empty:\n        return_annotation = Any\n    return cls(parameters=parameters, return_annotation=return_annotation)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n# Natural Language Annotations: \"\"\"Parse a function signature.\n\n        Args:\n            fn: Any callable.\n            signature_namespace: mapping of names to types for forward reference resolution\n\n        Returns:\n            ParsedSignature\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/deprecation.py-deprecated": {"response": ["```python\ndef deprecated(\n    version: str,\n    *,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: str | None = None,\n) -> Callable:\n    def decorator(func: Callable) -> Callable:\n        if kind is None:\n            if inspect.isfunction(func) or inspect.ismethod(func):\n                _kind = \"function\"\n            elif isinstance(func, property):\n                _kind = \"property\"\n            else:\n                raise TypeError(f\"Cannot determine the type of {func}\")\n        else:\n            _kind = kind\n\n        warning_cls = PendingDeprecationWarning if pending else DeprecationWarning\n        message_parts = [f\"`{func.__name__}` {_kind} is deprecated since Litestar {version}\"]\n        if removal_in is not None:\n            message_parts.append(f\" and will be removed in {removal_in}\")\n        message_parts.append(\".\")\n\n        if alternative is not None:\n            message_parts.append(f\" Please use `{alternative}` instead.\")\n\n        if info is not None:\n            message_parts.append(f\" {info}\")\n\n        message = \"\".join(message_parts)\n\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            warnings.warn(message, category=warning_cls, stacklevel=2)\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def deprecated(\n# Natural Language Annotations: \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"response": ["```python\nfrom typing import Callable, TypeVar, Awaitable, ParamSpec\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            return fn(*args, **kwargs)\n        return async_wrapper\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n# Natural Language Annotations: \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"response": ["```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n\n    expanded_type_hint = {}\n    for param, hint in type_hint.items():\n        if hasattr(hint, \"__name__\") and hint.__name__ == \"_TypeVar\" and hint.__name__ in namespace:\n            expanded_type_hint[param] = namespace[hint.__name__]\n        else:\n            expanded_type_hint[param] = hint\n\n    return expanded_type_hint\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"response": ["```python\ndef simple_asdict(\n    obj: Any,\n    *,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: Iterable[str] = (),\n) -> dict:\n    result = {}\n    for field in fields(obj):\n        if field.name in exclude:\n            continue\n\n        value = getattr(obj, field.name)\n\n        if exclude_none and value is None:\n            continue\n\n        if exclude_empty and isinstance(value, Empty):\n            continue\n\n        if convert_nested and is_dataclass(value):\n            value = simple_asdict(\n                value,\n                exclude_none=exclude_none,\n                exclude_empty=exclude_empty,\n                convert_nested=convert_nested,\n                exclude=exclude,\n            )\n\n        result[field.name] = value\n\n    return result\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def simple_asdict(\n# Natural Language Annotations: \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/path.py-join_paths": {"response": ["```python\nimport os\n\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    normalized_paths = [os.path.normpath(path) for path in paths]\n    joined_path = os.path.join(*normalized_paths)\n    return os.path.normpath(joined_path)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def join_paths(paths: Iterable[str]) -> str:\n# Natural Language Annotations: \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/helpers.py-get_name": {"response": ["```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__class__.__name__\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_name(value: object) -> str:\n# Natural Language Annotations: \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"response": ["```python\nfrom dataclasses import is_dataclass\nfrom typing import Any, TypeGuard\n\nfrom beartype._decor.main import DataclassProtocol\n\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_dataclass(annotation)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n# Natural Language Annotations: \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/predicates.py-is_class_var": {"response": ["```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return getattr(annotation, '_name', None) == 'ClassVar'\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_class_var(annotation: Any) -> bool:\n# Natural Language Annotations: \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/utils/module_loader.py-import_string": {"response": ["```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n        module = import_module(module_path)\n        return getattr(module, class_name)\n    except (ImportError, AttributeError) as e:\n        raise ImportError(f\"Could not import {dotted_path}\") from e\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def import_string(dotted_path: str) -> Any:\n# Natural Language Annotations: \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"response": ["```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    if not isinstance(channels, Iterable):\n        raise TypeError(\"channels must be an Iterable\")\n\n    await self.execute_command(\"UNSUBSCRIBE\", *channels)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def unsubscribe(self, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Unsubscribe from ``channels``\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/channels/backends/redis.py-publish": {"response": ["```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    if not channels:\n        return\n\n    keys = [self._key(channel) for channel in channels]\n    args = keys + [data]\n\n    async with self._redis.pipeline(transaction=False) as pipe:\n        await pipe.eval(self._publish_lua, keys=keys, args=[data])\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/channels/backends/redis.py-stream_events": {"response": ["```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    while True:\n        if not self.subscribed_channels:\n            await asyncio.sleep(self.stream_sleep_no_subscriptions / 1000)\n            continue\n\n        message = await self.connection.read_message()\n\n        if message is None:\n            raise ConnectionError(\"Connection was closed by server\")\n\n        if message.startswith(\"*\"):\n            yield parse_multi_bulk_reply(message)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n# Natural Language Annotations: \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/channels/backends/redis.py-get_history": {"response": ["```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = []\n    async for message in self.client.iter_messages(channel, limit=limit):\n        history.append(message.text.encode())\n    return history\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n# Natural Language Annotations: \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"response": ["```python\ndef create_transfer_model_type(model_name: str, field_definitions: List[FieldDefinition]) -> Type[BackendT]:\n    class_name = model_name\n    class_fields = {field.name: field for field in field_definitions}\n\n    generated_class = type(class_name, (BackendT,), class_fields)\n    return generated_class\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_transfer_model_type(\n# Natural Language Annotations: \"\"\"Create a model for data transfer.\n\n        Args:\n            model_name: name for the type that should be unique across all transfer types.\n            field_definitions: field definitions for the container type.\n\n        Returns:\n            A ``BackendT`` class.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"response": ["```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    if isinstance(builtins, dict):\n        return self.model_type(**builtins)\n    elif isinstance(builtins, list):\n        return [self.model_type(**item) for item in builtins]\n    elif isinstance(builtins, tuple):\n        return tuple(self.model_type(**item) for item in builtins)\n    elif isinstance(builtins, set):\n        return {self.model_type(**item) for item in builtins}\n    else:\n        raise ValueError(f\"Unsupported builtin type: {type(builtins)}\")\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"response": ["```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    try:\n        data = json.loads(raw.decode())\n        if isinstance(data, list):\n            return [self.model_type(**item) for item in data]\n        else:\n            return self.model_type(**data)\n    except (json.JSONDecodeError, ValidationError) as e:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid request body: {str(e)}\",\n        )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/dto/_backend.py-encode_data": {"response": ["```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if isinstance(data, LitestarEncodableType):\n        return data\n    elif isinstance(data, dict):\n        return {key: self.encode_data(value) for key, value in data.items()}\n    elif isinstance(data, (list, tuple)):\n        return [self.encode_data(item) for item in data]\n    else:\n        return data\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def encode_data(self, data: Any) -> LitestarEncodableType:\n# Natural Language Annotations: \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"response": ["```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if transfer_type.type == TransferTypeEnum.PRIMITIVE:\n        return transfer_type.python_type\n    elif transfer_type.type == TransferTypeEnum.LIST:\n        return List[_create_transfer_model_type_annotation(transfer_type.sub_type)]\n    elif transfer_type.type == TransferTypeEnum.OPTIONAL:\n        return Optional[_create_transfer_model_type_annotation(transfer_type.sub_type)]\n    elif transfer_type.type == TransferTypeEnum.UNION:\n        return Union[tuple(_create_transfer_model_type_annotation(sub_type) for sub_type in transfer_type.sub_types)]\n    else:\n        return transfer_type.python_type\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n# Natural Language Annotations: \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/response/file.py-start_response": {"response": ["```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    await send({\n        'type': 'http.response.start',\n        'status': self.status_code,\n        'headers': self.raw_headers\n    })\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def start_response(self, send: Send) -> None:\n# Natural Language Annotations: \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/connection/request.py-json": {"response": ["```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if not hasattr(self, \"_json\"):\n        body = await self.body()\n        self._json = json.loads(body)\n    return self._json\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def json(self) -> Any:\n# Natural Language Annotations: \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/datastructures/multi_dicts.py-close": {"response": ["```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for file in self.values():\n        await file.close()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def close(self) -> None:\n# Natural Language Annotations: \"\"\"Close all files in the multi-dict.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/datastructures/url.py-from_scope": {"response": ["```python\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    scheme = scope.get(\"scheme\", \"http\")\n    server = scope.get(\"server\", None)\n    path = scope.get(\"root_path\", \"\") + scope[\"path\"]\n    query_string = scope.get(\"query_string\", b\"\")\n\n    host_header = None\n    for key, value in scope[\"headers\"]:\n        if key == b\"host\":\n            host_header = value.decode(\"latin-1\")\n            break\n\n    if host_header is not None:\n        url = f\"{scheme}://{host_header}{path}\"\n    elif server is None:\n        url = path\n    else:\n        host, port = server\n        default_port = {\"http\": 80, \"https\": 443, \"ws\": 80, \"wss\": 443}[scheme]\n        if port == default_port:\n            url = f\"{scheme}://{host}{path}\"\n        else:\n            url = f\"{scheme}://{host}:{port}{path}\"\n\n    if query_string:\n        url += \"?\" + query_string.decode()\n\n    return cls(url)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_scope(cls, scope: Scope) -> Self:\n# Natural Language Annotations: \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n        Args:\n            scope: A scope\n\n        Returns:\n            A URL\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/datastructures/headers.py-to_header": {"response": ["```\ndef to_header(self, include_header_name: bool = False) -> str:\n    if include_header_name:\n        return f\"{self.name}: {self.value}\"\n    else:\n        return self.value\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_header(self, include_header_name: bool = False) -> str:\n# Natural Language Annotations: \"\"\"Get the header as string.\n\n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "litestar-litestar/middleware/session/server_side.py-delete": {"response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    try:\n        await store.delete(session_id)\n    except KeyError:\n        pass\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def delete(self, session_id: str, store: Store) -> None:\n# Natural Language Annotations: \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n        Args:\n            session_id: The session-ID\n            store: Store to delete the session data from\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_islands/island_generator.py-add_code": {"response": ["```python\ndef add_code(code: str, display_code: bool = True, display_output: bool = True, is_raw: bool = False, is_reactive: bool = True):\n    if is_raw:\n        code_html = f'<pre><code>{code}</code></pre>'\n    else:\n        code_html = f'<pre><code class=\"language-python\">{code}</code></pre>'\n    \n    if is_reactive:\n        output_html = f'<div id=\"output-{len(self.code_blocks)}\"></div>'\n        self.code_blocks.append((code, f'output-{len(self.code_blocks)}'))\n    else:\n        output_html = ''\n    \n    code_block = f'''\n        <div class=\"code-block\">\n            {'<div class=\"code-header\">Code</div>' if display_code else ''}\n            {code_html if display_code else ''}\n            {'<div class=\"output-header\">Output</div>' if display_output else ''}\n            {output_html if display_output else ''}\n        </div>\n    '''\n    self.body += code_block\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_code(\n# Natural Language Annotations: \"\"\"Add a code cell to the app.\n\n        *Args:*\n\n        - code (str): The code to add to the app.\n        - display_code (bool): Whether to display the code in the HTML.\n        - display_output (bool): Whether to display the output in the HTML.\n        - is_raw (bool): Whether to handled the code without formatting.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_islands/island_generator.py-build": {"response": ["```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    Returns:\n        App: The built app.\n    \"\"\"\n    app = App()\n    for cell in self.cells:\n        await cell.execute(app)\n    return app\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def build(self) -> App:\n# Natural Language Annotations: \"\"\"\n        Build the app. This should be called after adding all the code cells.\n\n        *Returns:*\n\n        - App: The built app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"response": ["```python\nfrom dataclasses import fields\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    field_names = set(f.name for f in fields(cls))\n    return cls(**{k: v for k, v in values.items() if k in field_names})\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"response": ["```python\nfrom dataclasses import fields, is_dataclass\nfrom typing import Any, Dict, Type, TypeVar, Union\n\nimport orjson\n\nfrom langchain.utils import camel_to_snake\n\nT = TypeVar(\"T\")\n\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    if not is_dataclass(cls):\n        raise ValueError(f\"{cls} must be a dataclass\")\n    if isinstance(message, bytes):\n        message = orjson.loads(message)\n    message = {camel_to_snake(k): v for k, v in message.items()}\n    field_types: Dict[str, Type] = {field.name: field.type for field in fields(cls)}\n    parsed_data = {}\n    for field_name, field_type in field_types.items():\n        value = message.get(field_name)\n        if value is None:\n            continue\n        origin = getattr(field_type, \"__origin__\", None)\n        if origin in (list, set, tuple):\n            (arg_type,) = field_type.__args__\n            parsed_data[field_name] = origin(parse_raw(v, arg_type) for v in value)\n        elif origin == dict:\n            key_type, value_type = field_type.__args__\n            parsed_data[field_name] = {\n                parse_raw(k, key_type): parse_raw(v, value_type)\n                for k, v in value.items()\n            }\n        elif is_dataclass(field_type):\n            parsed_data[field_name] = parse_raw(value, field_type)\n        else:\n            parsed_data[field_name] = value\n    return cls(**parsed_data)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"response": ["```python\ndef icon(\n    icon_name: str,\n    size: Optional[int] = None,\n    color: Optional[str] = None,\n    inline: bool = True,\n    flip: Optional[str] = None,\n    rotate: Optional[int] = None,\n    style: Optional[dict] = None,\n) -> Html:\n    if not icon_name:\n        return Html(\"\")\n\n    if icon_name.startswith(\"icon-park\"):\n        icon_name = icon_name.replace(\"icon-park\", \"icon-park-outline\")\n\n    span_classes = [\"iconify\"]\n    if inline:\n        span_classes.append(\"inline-block\")\n    span_style = style or {}\n    if size is not None:\n        span_style[\"font-size\"] = f\"{size}px\"\n        span_style[\"height\"] = f\"{size}px\"\n        span_style[\"width\"] = f\"{size}px\"\n    if color is not None:\n        span_style[\"color\"] = color\n    if flip is not None:\n        span_classes.append(f\"iconify--flip-{flip}\")\n    if rotate is not None:\n        span_classes.append(f\"iconify--rotate-{rotate}\")\n\n    return Html(\n        f'<span class=\"{\" \".join(span_classes)}\" data-icon=\"{icon_name}\" style=\"{\"; \".join(f\"{k}: {v}\" for k, v in span_style.items())}\"></span>'\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def icon(\n# Natural Language Annotations: \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_plugins/stateless/image.py-image": {"response": ["```python\ndef image(\n    src: Union[str, BinaryIO, np.ndarray],\n    alt: Optional[str] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, str]] = None,\n) -> Html:\n    if isinstance(src, (str, Path)):\n        src = str(src)\n    elif isinstance(src, BinaryIO):\n        src = base64.b64encode(src.read()).decode(\"utf-8\")\n        src = f\"data:image/png;base64,{src}\"\n    elif isinstance(src, np.ndarray):\n        img = Image.fromarray(src)\n        buffered = BytesIO()\n        img.save(buffered, format=\"PNG\")\n        src = base64.b64encode(buffered.getvalue()).decode(\"utf-8\")\n        src = f\"data:image/png;base64,{src}\"\n    else:\n        raise TypeError(\n            f\"Expected src to be a string, file-like object, or array-like object, got {type(src)}\"\n        )\n\n    if style is None:\n        style = {}\n    if rounded:\n        style[\"border-radius\"] = \"5px\"\n    if width is not None:\n        style[\"width\"] = f\"{width}px\"\n    if height is not None:\n        style[\"height\"] = f\"{height}px\"\n\n    return Html(\n        f'<img src=\"{src}\" alt=\"{alt}\" style=\"{inline_css(style)}\">'\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def image(\n# Natural Language Annotations: \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"response": ["```python\ndef hstack(\n    items: list,\n    justify: str = \"start\",\n    align: str = \"start\",\n    wrap: bool = False,\n    gap: float = 0.25,\n    widths: Optional[Union[str, list]] = None,\n) -> Html:\n    style = {\"display\": \"flex\", \"flex-direction\": \"row\"}\n    if justify == \"start\":\n        style[\"justify-content\"] = \"flex-start\"\n    elif justify == \"center\":\n        style[\"justify-content\"] = \"center\"\n    elif justify == \"end\":\n        style[\"justify-content\"] = \"flex-end\"\n    elif justify == \"space-between\":\n        style[\"justify-content\"] = \"space-between\"\n    elif justify == \"space-around\":\n        style[\"justify-content\"] = \"space-around\"\n    else:\n        raise ValueError(f\"Invalid justify value: {justify}\")\n\n    if align == \"start\":\n        style[\"align-items\"] = \"flex-start\"\n    elif align == \"center\":\n        style[\"align-items\"] = \"center\"\n    elif align == \"end\":\n        style[\"align-items\"] = \"flex-end\"\n    elif align == \"stretch\":\n        style[\"align-items\"] = \"stretch\"\n    else:\n        raise ValueError(f\"Invalid align value: {align}\")\n\n    if wrap:\n        style[\"flex-wrap\"] = \"wrap\"\n    else:\n        style[\"flex-wrap\"] = \"nowrap\"\n\n    style[\"gap\"] = f\"{gap}rem\"\n\n    if widths == \"equal\":\n        style[\"flex\"] = \"1\"\n    elif isinstance(widths, list):\n        if len(widths) != len(items):\n            raise ValueError(\"Length of widths must match length of items\")\n        for i, width in enumerate(widths):\n            items[i] = div(items[i], style={\"flex\": str(width)})\n    elif widths is not None:\n        raise ValueError(\"Invalid widths value\")\n\n    return div(items, style=style)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def hstack(\n# Natural Language Annotations: \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"response": ["```python\ndef update_progress(self, increment=1, title=None, subtitle=None):\n    self.value += increment\n    if title is not None:\n        self.title = title\n    if subtitle is not None:\n        self.subtitle = subtitle\n    self.refresh()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def update_progress(\n# Natural Language Annotations: \"\"\"Update the progress indicator.\n\n        **Example.**\n\n        ```python\n        # Increment by 1\n        progress.update()\n\n        # Increment by 10 and update title and subtitle\n        progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n        ```\n\n        **Args.**\n\n        - increment: amount to increment by. Defaults to 1.\n        - title: new title. Defaults to None.\n        - subtitle: new subtitle. Defaults to None.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"response": ["```python\ndef build_ui_plugin(component_name, initial_value, label, args, slotted_html):\n    import json\n    import html\n\n    # Escape the label markdown\n    label = html.escape(label)\n\n    # Serialize the initial value to JSON\n    initial_value_json = json.dumps(initial_value)\n\n    # Serialize the args to JSON\n    args_json = json.dumps(args)\n\n    # Generate the HTML for the component\n    html_output = f\"\"\"\n    <{component_name}\n        initial-value='{initial_value_json}'\n        args='{args_json}'\n    >\n        <template slot=\"label\">\n            {label}\n        </template>\n        <template slot=\"component\">\n            {slotted_html}\n        </template>\n    </{component_name}>\n    \"\"\"\n\n    return html_output\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_ui_plugin(\n# Natural Language Annotations: \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_output/formatting.py-as_html": {"response": ["```python\nfrom typing import Any\nfrom IPython.display import HTML, display\n\ndef as_html(value: Any) -> HTML:\n    if isinstance(value, str):\n        return HTML(value)\n    elif hasattr(value, \"_repr_html_\"):\n        return HTML(value._repr_html_())\n    else:\n        return HTML(f\"<pre>{value}</pre>\")\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def as_html(value: object) -> Html:\n# Natural Language Annotations: \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_output/md.py-md": {"response": ["```python\ndef md(text: str) -> Html:\n    return Html(marimo.markdown(text))\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def md(text: str) -> Html:\n# Natural Language Annotations: r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"response": ["```python\ndef register_formatters() -> None:\n    import sys\n    from importlib.metadata import entry_points\n\n    def import_hook(name, globals=None, locals=None, fromlist=None, level=0):\n        module = original_import(name, globals, locals, fromlist, level)\n        if name in formatters_by_package:\n            for formatter in formatters_by_package[name]:\n                register_formatter(formatter)\n        return module\n\n    original_import = builtins.__import__\n    builtins.__import__ = import_hook\n\n    formatters_by_package = {}\n    for entry_point in entry_points(group=\"marimo.formatters\"):\n        package_name = entry_point.value.partition(\":\")[0]\n        if package_name not in formatters_by_package:\n            formatters_by_package[package_name] = []\n        formatters_by_package[package_name].append(entry_point.load())\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_formatters() -> None:\n# Natural Language Annotations: \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_data/series.py-get_category_series_info": {"response": ["```python\nfrom typing import Any, Dict\n\nclass CategorySeriesInfo:\n    def __init__(self, series_name: str, num_unique_values: int, most_common_value: Any, most_common_count: int):\n        self.series_name = series_name\n        self.num_unique_values = num_unique_values\n        self.most_common_value = most_common_value\n        self.most_common_count = most_common_count\n\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    series_name = series.name\n    num_unique_values = series.nunique()\n    value_counts = series.value_counts()\n    most_common_value = value_counts.index[0]\n    most_common_count = value_counts.iloc[0]\n\n    return CategorySeriesInfo(\n        series_name=series_name,\n        num_unique_values=num_unique_values,\n        most_common_value=most_common_value,\n        most_common_count=most_common_count\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_category_series_info(series: Any) -> CategorySeriesInfo:\n# Natural Language Annotations: \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"response": ["```python\ndef get_column_preview(df, column):\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    # Get the data type of the column\n    col_type = df[column].dtype\n\n    # Generate a preview based on the data type\n    if col_type == 'object':\n        # For categorical columns, show value counts\n        value_counts = df[column].value_counts(normalize=True)\n        chart = value_counts.plot(kind='bar', title=f'Value Counts of {column}')\n        summary = f\"Most common value: {value_counts.index[0]} ({value_counts.values[0]:.2%})\"\n    elif col_type in ['int64', 'float64']:\n        # For numerical columns, show descriptive statistics\n        desc_stats = df[column].describe()\n        chart = df[column].hist(title=f'Distribution of {column}')\n        summary = f\"Mean: {desc_stats['mean']:.2f}, Median: {desc_stats['50%']:.2f}, Range: [{desc_stats['min']:.2f}, {desc_stats['max']:.2f}]\"\n    else:\n        # For other data types, just show the first few values\n        preview_values = df[column].head().tolist()\n        chart = None\n        summary = f\"Preview values: {preview_values}\"\n\n    return chart, summary\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_column_preview(\n# Natural Language Annotations: \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"response": ["```python\ndef start_file_watcher(self) -> Disposable:\n    \"\"\"Starts the file watcher if it is not already started\"\"\"\n    if not self.file_watcher:\n        self.file_watcher = self.file_watcher_factory.create_file_watcher()\n        self.file_watcher.on_change(self.on_file_change)\n        self.file_watcher.start()\n    return Disposable(lambda: self.stop_file_watcher())\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start_file_watcher(self) -> Disposable:\n# Natural Language Annotations: \"\"\"Starts the file watcher if it is not already started\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_server/file_manager.py-save_app_config": {"response": ["```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    config_json = json.dumps(config, indent=2)\n    with open(self.config_file, 'w') as f:\n        f.write(config_json)\n    return \"App configuration saved successfully.\"\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def save_app_config(self, config: Dict[str, Any]) -> str:\n# Natural Language Annotations: \"\"\"Save the app configuration.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"response": ["```python\ndef add_stdin(self, stdin: str) -> None:\n    self.stdin_requests.append(stdin)\n    self.update_session_view()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_stdin(self, stdin: str) -> None:\n# Natural Language Annotations: \"\"\"Add a stdin request to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_server/session/session_view.py-add_operation": {"response": ["```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    self.operations.append(operation)\n    self.update_display()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_operation(self, operation: MessageOperation) -> None:\n# Natural Language Annotations: \"\"\"Add an operation to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"response": ["```python\ndef get_cell_console_outputs(cell_ids):\n    outputs = []\n    for cell_id in cell_ids:\n        cell = get_cell_by_id(cell_id)\n        if cell:\n            console_output = cell.get_console_output()\n            outputs.append(console_output)\n    return outputs\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_cell_console_outputs(\n# Natural Language Annotations: \"\"\"Get the console outputs for the given cell ids.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"response": ["```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell with id {cell_id} already exists in the graph\")\n        self.cells[cell_id] = cell\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n# Natural Language Annotations: \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"response": ["```python\ndef check_for_errors(graph):\n    errors = {}\n    for cell in graph.cells:\n        # Check for missing required fields\n        if not cell.get('id'):\n            errors[cell['id']] = \"Missing required field 'id'\"\n        if not cell.get('type'):\n            errors[cell['id']] = \"Missing required field 'type'\"\n\n        # Check for invalid cell types\n        if cell['type'] not in ['code', 'markdown']:\n            errors[cell['id']] = f\"Invalid cell type '{cell['type']}'\"\n\n        # Check for circular dependencies\n        visited = set()\n        stack = [cell['id']]\n        while stack:\n            current_id = stack.pop()\n            if current_id in visited:\n                errors[cell['id']] = \"Circular dependency detected\"\n                break\n            visited.add(current_id)\n            for child_id in graph.get_children(current_id):\n                stack.append(child_id)\n\n    return errors\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check_for_errors(\n# Natural Language Annotations: \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"response": ["```python\ndef _maybe_register_cell(self, cell_id: str, code: str) -> Tuple[Set[str], Optional[Error]]:\n    if cell_id in self._cells:\n        existing_cell = self._cells[cell_id]\n        if existing_cell.code != code:\n            # Cell code has changed, delete the old cell and register a new one\n            children_ids = self._delete_cell(cell_id)\n            self._register_cell(cell_id, code)\n            return children_ids, None\n        else:\n            # Cell code is the same, no need to update\n            return set(), None\n    else:\n        # Cell is not registered, register it\n        self._register_cell(cell_id, code)\n        return set(), None\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _maybe_register_cell(\n# Natural Language Annotations: \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_runtime/runtime.py-run": {"response": ["```python\nasync def run(execution_requests: Sequence[CellExecutionRequest],\n              runner: Runner,\n              parent_span: Optional[opentracing.Span] = None,\n              ) -> CellExecutionResult:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    new_cells = []\n    for request in execution_requests:\n        if request.cell_id not in runner.graph:\n            new_cell = Cell(request.cell_id, request.code)\n            runner.graph.add_cell(new_cell)\n            new_cells.append(new_cell)\n\n    # Run the cells and their descendants.\n    for cell in new_cells:\n        await runner.run_cell_async(cell, parent_span=parent_span)\n\n    return CellExecutionResult(runner.graph)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run(\n# Natural Language Annotations: \"\"\"Run cells and their descendants.\n\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"response": ["```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python\"\"\"\n    import sys\n    return sys.prefix != sys.base_prefix\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_python_isolated() -> bool:\n# Natural Language Annotations: \"\"\"Returns True if not using system Python\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"response": ["```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    missing = set()\n    for module in self.modules():\n        try:\n            importlib.import_module(module)\n        except ImportError:\n            missing.add(module)\n    return missing\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def missing_modules(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Modules that will fail to import.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"response": ["```python\ndef load_examples(folder, role_set):\n    examples = []\n    for file_name in os.listdir(folder):\n        file_path = os.path.join(folder, file_name)\n        if os.path.isfile(file_path) and file_name.endswith(\".json\"):\n            with open(file_path, \"r\") as f:\n                example = json.load(f)\n                if set(example[\"roles\"]) == set(role_set):\n                    examples.append(example)\n    return examples\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def load_examples(\n# Natural Language Annotations: \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    for plugin in external_plugin_pool:\n        if plugin.selected:\n            self.plugin_pool.append(plugin)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n# Natural Language Annotations: \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"response": ["```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = set()\n    for line in code.split(\"\\n\"):\n        if \"from langchain.agents import\" in line:\n            used_plugins.add(line.split(\"import\")[1].strip())\n        elif \"from langchain.chains import\" in line:\n            used_plugins.add(line.split(\"import\")[1].strip())\n        elif \"from langchain.llms import\" in line:\n            used_plugins.add(line.split(\"import\")[1].strip())\n        elif \"from langchain.prompts import\" in line:\n            used_plugins.add(line.split(\"import\")[1].strip())\n    \n    filtered_code = []\n    for line in code.split(\"\\n\"):\n        if not any(plugin in line for plugin in self.plugins if plugin not in used_plugins):\n            filtered_code.append(line)\n    \n    return \"\\n\".join(filtered_code)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def filter_unused_plugins(self, code: str):\n# Natural Language Annotations: \"\"\"\n        Filter out plugins that are not used in the code generated by LLM\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    delimiters = [',', '.', '!', '?', ':', ';', '-', '_', '(', ')', '[', ']', '{', '}', '/', '\\\\', '\\'', '\"']\n    for delimiter in delimiters:\n        text = text.replace(delimiter, '')\n    return text\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def remove_all_delimiters(text: str) -> str:\n# Natural Language Annotations: \"\"\"Remove all the delimiters from the text.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/app.py-_enable_state": {"response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    self.state_enabled = True\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _enable_state(self) -> None:\n# Natural Language Annotations: \"\"\"Enable state for the app.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/app.py-_add_optional_endpoints": {"response": ["```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    @self.app.post(\"/_upload\")\n    async def upload(file: UploadFile = File(...)):\n        try:\n            contents = await file.read()\n            with open(file.filename, \"wb\") as f:\n                f.write(contents)\n        except Exception:\n            return {\"message\": \"There was an error uploading the file\"}\n        finally:\n            await file.close()\n\n        return {\"message\": f\"Successfully uploaded {file.filename}\"}\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_optional_endpoints(self):\n# Natural Language Annotations: \"\"\"Add optional api endpoints (_upload).\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/app.py-add_page": {"response": ["```python\ndef add_page(\n    self,\n    component,\n    route=None,\n    title=None,\n    description=None,\n    image=None,\n    on_load=None,\n    meta=None,\n):\n    if route is None:\n        if callable(component):\n            route = \"/\" + component.__name__\n        else:\n            raise ValueError(\"Route must be provided for non-callable components.\")\n    else:\n        route = \"/\" + route.lstrip(\"/\")\n\n    if route in self.pages:\n        raise ValueError(f\"Route '{route}' already exists.\")\n\n    self.pages[route] = {\n        \"component\": component,\n        \"title\": title,\n        \"description\": description,\n        \"image\": image,\n        \"on_load\": on_load,\n        \"meta\": meta,\n    }\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_page(\n# Natural Language Annotations: \"\"\"Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/app.py-_setup_overlay_component": {"response": ["```python\ndef _setup_overlay_component(self):\n    if not self.use_state and self.overlay_component is None:\n        self.overlay_component = gr.HTML()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _setup_overlay_component(self):\n# Natural Language Annotations: \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/app.py-_compile": {"response": ["```python\ndef _compile(self, export: bool = False):\n    if not hasattr(self, \"State\"):\n        for page in self.pages.values():\n            if len(page.state) > 0:\n                raise ReflexRuntimeError(\n                    \"At least one page uses state, but no rx.State subclass is defined. \"\n                    \"Please define a State class in your Reflex app to use state.\"\n                )\n\n    output_dir = self.output_dir if not export else self.export_dir\n    shutil.rmtree(output_dir, ignore_errors=True)\n    output_dir.mkdir(parents=True, exist_ok=True)\n\n    js_dir = output_dir / \"js\"\n    js_dir.mkdir()\n\n    css_dir = output_dir / \"css\"\n    css_dir.mkdir()\n\n    for page in self.pages.values():\n        page._compile(js_dir=js_dir, css_dir=css_dir, export=export)\n\n    with open(output_dir / \"index.html\", \"w\") as f:\n        f.write(\n            self._index_template.render(\n                app_name=self.name,\n                page_names=self.pages.keys(),\n                export=export,\n            )\n        )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _compile(self, export: bool = False):\n# Natural Language Annotations: \"\"\"Compile the app and output it to the pages folder.\n\n        Args:\n            export: Whether to compile the app for export.\n\n        Raises:\n            ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/app.py-modify_state": {"response": ["```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not self._initialized:\n        raise RuntimeError(\"App has not been initialized yet.\")\n\n    async with self._state_lock:\n        state = self._state.get(token)\n        if state is None:\n            state = self._state[token] = self._state_class(token)\n\n        yield state\n\n        self._state[token] = state\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n# Natural Language Annotations: \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/vars.py-create": {"response": ["```python\ndef create(value, *, _var_is_local=True, _var_is_string=False, **_var_data):\n    try:\n        json.dumps(value)\n    except TypeError:\n        raise VarTypeError(\n            f\"Value {value!r} is not JSON-serializable and thus is not supported by Vars\"\n        )\n\n    return Var(\n        value=value,\n        _var_is_local=_var_is_local,\n        _var_is_string=_var_is_string,\n        **_var_data,\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/vars.py-create_safe": {"response": ["```python\ndef create_safe(value, *, _var_is_local=False, _var_is_string=False, **_var_data):\n    assert value is not None, \"Value cannot be None\"\n    return Var(value, _var_is_local=_var_is_local, _var_is_string=_var_is_string, **_var_data)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_safe(\n# Natural Language Annotations: \"\"\"Create a var from a value, asserting that it is not None.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/vars.py-foreach": {"response": ["```python\ndef foreach(self, fn: Callable) -> Var:\n    if not self.is_list():\n        raise VarTypeError(f\"foreach can only be called on a list, not {self}\")\n    return Var(\n        [fn(Var(x, self._node)) for x in self.data], self._node\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def foreach(self, fn: Callable) -> Var:\n# Natural Language Annotations: \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/vars.py-get_default_value": {"response": ["```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\n\n    Returns:\n        The default value of the var.\n\n    Raises:\n        ImportError: If the var is a dataframe and pandas is not installed.\n    \"\"\"\n    if self.type == \"dataframe\":\n        try:\n            import pandas as pd\n            return pd.DataFrame()\n        except ImportError:\n            raise ImportError(\"Pandas is not installed. Please install pandas to use dataframe variables.\")\n    elif self.type == \"int\":\n        return 0\n    elif self.type == \"float\":\n        return 0.0\n    elif self.type == \"string\":\n        return \"\"\n    elif self.type == \"bool\":\n        return False\n    elif self.type == \"list\":\n        return []\n    elif self.type == \"dict\":\n        return {}\n    else:\n        return None\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_default_value(self) -> Any:\n# Natural Language Annotations: \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-get_skip_vars": {"response": ["```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    skip_vars = set()\n    for base in cls.__bases__:\n        skip_vars.update(getattr(base, \"_skip_vars\", set()))\n    skip_vars.update(getattr(cls, \"_skip_vars\", set()))\n    return skip_vars\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_skip_vars(cls) -> set[str]:\n# Natural Language Annotations: \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-add_var": {"response": ["```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    if hasattr(cls, name):\n        raise NameError(f\"A variable named '{name}' already exists in the class.\")\n    \n    setattr(cls, name, default_value)\n    cls.__annotations__[name] = type_\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_var(cls, name: str, type_: Any, default_value: Any = None):\n# Natural Language Annotations: \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-reset": {"response": ["```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    self.base_vars = {\n        'var1': 0,\n        'var2': '',\n        'var3': [],\n        'var4': {},\n        'var5': True\n    }\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def reset(self):\n# Natural Language Annotations: \"\"\"Reset all the base vars to their default values.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-get_state": {"response": ["```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    if not hasattr(self, \"client_token\"):\n        raise ValueError(\"State does not have a client_token\")\n\n    if state_cls not in self.sibling_states:\n        raise ValueError(f\"No state of type {state_cls} associated with this client_token\")\n\n    return self.sibling_states[state_cls]\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n# Natural Language Annotations: \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-_process": {"response": ["```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    event_info = await self._obtain_event_info(event)\n    processed_event = self._process_event(event_info)\n    for state_update in processed_event:\n        yield state_update\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n# Natural Language Annotations: \"\"\"Obtain event info and process event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-_dirty_computed_vars": {"response": ["```python\ndef _dirty_computed_vars(self, from_vars: Optional[Set[str]] = None, include_backend: bool = False) -> Set[str]:\n    if from_vars is None:\n        from_vars = self.dirty_vars\n\n    dirty_computed_vars = set()\n    for var in from_vars:\n        for computed_var in self._computed_var_dependencies.get(var, set()):\n            dirty_computed_vars.add(computed_var)\n            if include_backend and computed_var in self._backend_computed_vars:\n                dirty_computed_vars.update(self._backend_computed_vars[computed_var])\n\n    return dirty_computed_vars\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _dirty_computed_vars(\n# Natural Language Annotations: \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-_potentially_dirty_substates": {"response": ["```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    dirty_substates = set()\n    for substate_cls in cls.__substate_classes__():\n        if any(\n            cls.get_var_config(var).dirty_affects_substate(substate_cls)\n            for var in cls.dirty_vars()\n        ):\n            dirty_substates.add(substate_cls)\n    return dirty_substates\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n# Natural Language Annotations: \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n        Returns:\n            Set of State classes that may need to be fetched to recalc computed vars.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/state.py-get_delta": {"response": ["```python\ndef get_delta(self) -> Delta:\n    return self.delta\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_delta(self) -> Delta:\n# Natural Language Annotations: \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/model.py-get_db_engine": {"response": ["```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    engine = create_engine(f'postgresql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{DB_PORT}/{DB_NAME}')\n    return engine\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_db_engine():\n# Natural Language Annotations: \"\"\"Get the database engine.\n\n        Returns:\n            The database engine.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/model.py-alembic_autogenerate": {"response": ["```python\ndef alembic_autogenerate(connection, message, write_migration_scripts=True):\n    from alembic.runtime.environment import EnvironmentContext\n    from alembic.autogenerate import produce_migrations\n    from alembic.script import ScriptDirectory\n    from alembic.config import Config\n\n    config = Config()\n    config.set_main_option(\"script_location\", \"migrations\")\n    script_directory = ScriptDirectory.from_config(config)\n\n    with EnvironmentContext(\n        config,\n        script_directory,\n        fn=lambda rev, _: script_directory.generate_revision(rev, message, head=\"head\", splice=False),\n    ):\n        with connection.connect() as conn:\n            context = conn.begin()\n            try:\n                autogenerate_context = context.configure(\n                    connection=conn,\n                    target_metadata=None,\n                    compare_type=True,\n                    compare_server_default=True,\n                )\n                diff = produce_migrations(autogenerate_context, config.get_main_option(\"script_location\"))\n                if write_migration_scripts:\n                    script_directory.generate_revision(\n                        None, message, head=\"head\", splice=False, refresh=True\n                    )\n                return bool(diff)\n            finally:\n                context.close()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def alembic_autogenerate(\n# Natural Language Annotations: \"\"\"Generate migration scripts for alembic-detectable changes.\n\n        Args:\n            connection: SQLAlchemy connection to use when detecting changes.\n            message: Human readable identifier describing the generated revision.\n            write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n        Returns:\n            True when changes have been detected.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/model.py-migrate": {"response": ["```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    try:\n        import alembic\n        from alembic.config import Config\n        from alembic.runtime.migration import MigrationContext\n        from alembic.script import ScriptDirectory\n        from sqlalchemy import create_engine\n        from sqlmodel import SQLModel\n    except ImportError:\n        return None\n\n    config = Config(\"alembic.ini\")\n    script = ScriptDirectory.from_config(config)\n    engine = create_engine(config.get_main_option(\"sqlalchemy.url\"))\n\n    with engine.begin() as connection:\n        context = MigrationContext.configure(connection)\n        current_rev = context.get_current_revision()\n\n        if current_rev is None:\n            SQLModel.metadata.create_all(engine)\n            alembic.command.stamp(config, \"head\")\n            return True\n\n        if autogenerate:\n            alembic.command.revision(config, autogenerate=True)\n            alembic.command.upgrade(config, \"head\")\n        else:\n            alembic.command.upgrade(config, \"head\")\n\n    return True\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def migrate(cls, autogenerate: bool = False) -> bool | None:\n# Natural Language Annotations: \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n        If alembic is not installed or has not been initialized for the project,\n        then no action is performed.\n\n        If there are no revisions currently tracked by alembic, then\n        an initial revision will be created based on sqlmodel metadata.\n\n        If models in the app have changed in incompatible ways that alembic\n        cannot automatically generate revisions for, the app may not be able to\n        start up until migration scripts have been corrected by hand.\n\n        Args:\n            autogenerate: If True, generate migration script and use it to upgrade schema\n                (otherwise, just bring the schema to current \"head\" revision).\n\n        Returns:\n            True - indicating the process was successful.\n            None - indicating the process was skipped.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/model.py-select": {"response": ["```python\n@classmethod\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    return f\"SELECT * FROM {cls.__tablename__}\"\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def select(cls):\n# Natural Language Annotations: \"\"\"Select rows from the table.\n\n        Returns:\n            The select statement.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/compiler/compiler.py-compile_components": {"response": ["```python\ndef compile_components(components):\n    compiled_components = []\n    for component in components:\n        component_path = component[\"path\"]\n        with open(component_path, \"r\") as file:\n            component_code = file.read()\n        compiled_component = {\n            \"path\": component_path,\n            \"code\": component_code\n        }\n        compiled_components.append(compiled_component)\n    return compiled_components\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def compile_components(\n# Natural Language Annotations: \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"response": ["```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    last_check_datetime = getattr(get_or_set_last_reflex_version_check_datetime, \"last_check_datetime\", None)\n    if last_check_datetime is None:\n        last_check_datetime = datetime.datetime.now()\n        setattr(get_or_set_last_reflex_version_check_datetime, \"last_check_datetime\", last_check_datetime)\n    return last_check_datetime\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_or_set_last_reflex_version_check_datetime():\n# Natural Language Annotations: \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"response": ["```python\nasync def preprocess(app, state, event):\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # Perform any necessary preprocessing of the event based on the app and state\n    # For example, you can modify the event or update the state\n\n    # Example preprocessing logic:\n    if event[\"type\"] == \"message\":\n        # Modify the event by adding a new field\n        event[\"preprocessed\"] = True\n\n        # Update the state\n        state[\"message_count\"] = state.get(\"message_count\", 0) + 1\n\n    # Return any state updates or deltas\n    return state\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def preprocess(\n# Natural Language Annotations: \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-get_event_triggers": {"response": ["```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    return self._event_triggers\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_event_triggers(self) -> Dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-get_props": {"response": ["```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set(cls.__annotations__.keys())\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_props(cls) -> Set[str]:\n# Natural Language Annotations: \"\"\"Get the unique fields for the component.\n\n        Returns:\n            The unique fields.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-create": {"response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    component = cls(**props)\n    for child in children:\n        if isinstance(child, str):\n            child = TextNode(child)\n        component.append(child)\n    return component\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_add_style_recursive": {"response": ["```python\ndef _add_style_recursive(self, style: Dict[Component, Dict[str, Any]], theme: Optional[Dict[str, Any]] = None) -> Component:\n    if hasattr(self, \"_add_style\") and self._add_style != Component._add_style:\n        warnings.warn(\n            f\"The `_add_style` method has been overridden in {self.__class__.__name__}. \"\n            \"This is not supported and may cause unexpected behavior. \"\n            \"Please use `add_style` instead.\",\n            UserWarning,\n        )\n\n    style_props = {}\n    if theme is not None:\n        style_props.update(theme.get(self._get_component_name(), {}))\n    style_props.update(self._style)\n    style_props.update(style.get(self, {}))\n    style_props.update(getattr(self, \"style\", {}))\n    style_props.update(self._style_dict)\n\n    css_props = {}\n    for key, value in style_props.items():\n        if key.startswith(\"--\"):\n            css_props[key] = value\n        else:\n            self._set_style_attr(key.replace(\"_\", \"-\"), value)\n\n    if css_props:\n        self._set_style_attr(\"css\", css_props)\n\n    for child in self._children:\n        child._add_style_recursive(style, theme)\n\n    return self\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_style_recursive(\n# Natural Language Annotations: \"\"\"Add additional style to the component and its children.\n\n        Apply order is as follows (with the latest overriding the earliest):\n        1. Default style from `_add_style`/`add_style`.\n        2. User-defined style from `App.style`.\n        3. User-defined style from `Component.style`.\n        4. style dict and css props passed to the component instance.\n\n        Args:\n            style: A dict from component to styling.\n            theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n        Raises:\n            UserWarning: If `_add_style` has been overridden.\n\n        Returns:\n            The component with the additional style.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-render": {"response": ["```python\ndef render(self) -> Dict:\n    return {\n        \"type\": \"component_type\",\n        \"props\": {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\"\n        }\n    }\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self) -> Dict:\n# Natural Language Annotations: \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_get_vars": {"response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    vars = []\n    for prop in self._spec.get(\"props\", {}).values():\n        if isinstance(prop, Var):\n            vars.append(prop)\n    for style in self._spec.get(\"styles\", {}).values():\n        if isinstance(style, Var):\n            vars.append(style)\n    for event_handler in self._spec.get(\"events\", {}).values():\n        if isinstance(event_handler, Var):\n            vars.append(event_handler)\n    if include_children:\n        for child in self._children:\n            vars.extend(child._get_vars(include_children=True))\n    return vars\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_vars(self, include_children: bool = False) -> list[Var]:\n# Natural Language Annotations: \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"response": ["```python\ndef _has_stateful_event_triggers(self):\n    if any(trigger.uses_state for trigger in self.event_triggers.values()):\n        return True\n\n    for child in self.children:\n        if child._has_stateful_event_triggers():\n            return True\n\n    return False\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _has_stateful_event_triggers(self):\n# Natural Language Annotations: \"\"\"Check if component or children have any event triggers that use state.\n\n        Returns:\n            True if the component or children have any event triggers that uses state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_get_all_custom_code": {"response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = set()\n    if self.custom_code:\n        custom_code.add(self.custom_code)\n    for child in self.children:\n        custom_code.update(child._get_all_custom_code())\n    return custom_code\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_code(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Get custom code for the component and its children.\n\n        Returns:\n            The custom code.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_get_all_imports": {"response": ["```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    imports: ParsedImportDict = {}\n    for child in self.children:\n        child_imports = child._get_all_imports(collapse=False)\n        for lib, fields in child_imports.items():\n            if lib not in imports:\n                imports[lib] = set()\n            imports[lib].update(fields)\n    if collapse:\n        for lib, fields in imports.items():\n            imports[lib] = list(fields)\n    return imports\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n# Natural Language Annotations: \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n        Args:\n            collapse: Whether to collapse the imports by removing duplicates.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    hooks = {}\n    for component in self.walk():\n        if hasattr(component, \"_internal_hooks\"):\n            for hook_name, hook_code in component._internal_hooks.items():\n                if hook_name not in hooks:\n                    hooks[hook_name] = hook_code\n    return hooks\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks_internal(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_get_all_hooks": {"response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    hooks = {}\n    for child in self.children:\n        hooks.update(child._get_all_hooks())\n    hooks.update(self.hooks)\n    return hooks\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the React hooks for this component and its children.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/component.py-_get_all_custom_components": {"response": ["```python\ndef _get_all_custom_components(self, seen: Set[str]) -> Set[str]:\n    result = set()\n    for tag in self.tags:\n        if tag not in seen:\n            seen.add(tag)\n            if tag in self.custom_components:\n                result.add(tag)\n                result.update(self.custom_components[tag]._get_all_custom_components(seen))\n    return result\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_components(\n# Natural Language Annotations: \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/core/upload.py-create": {"response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    return cls(children=list(children), **props)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create an upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The upload component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/next/image.py-create": {"response": ["```python\ndef create(*children, width, height, **props):\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props: The props of the component.\n\n    Returns:\n        Image: The Image component.\n    \"\"\"\n    return Image(\n        src=props.get(\"src\"),\n        alt=props.get(\"alt\", \"\"),\n        width=width,\n        height=height,\n        **props,\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create an Image component from next/image.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the image.\n            height: The height of the image.\n            **props:The props of the component.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/lucide/icon.py-create": {"response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if len(children) > 0:\n        raise AttributeError(\"Icon component does not accept children\")\n\n    icon = props.get(\"icon\")\n    if icon is None:\n        raise AttributeError(\"Icon component requires an icon prop\")\n\n    if not isinstance(icon, str):\n        raise ValueError(\"Icon prop must be a string\")\n\n    if not icon.startswith(\"fa-\"):\n        raise ValueError(\"Icon prop must start with 'fa-'\")\n\n    return super().create(icon=icon, **props)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "reflex-reflex/components/tags/tag.py-format_props": {"response": ["```python\ndef format_props(self) -> List:\n    props = []\n    for prop_name, prop_value in self.props.items():\n        if prop_value is not None:\n            if isinstance(prop_value, bool):\n                if prop_value:\n                    props.append(prop_name)\n            else:\n                props.append(f'{prop_name}=\"{prop_value}\"')\n    return props\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def format_props(self) -> List:\n# Natural Language Annotations: \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/screen.py-focus_next": {"response": ["```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    current_focus = self.focused\n    if current_focus is None:\n        widgets = self.query(selector).filter(Widget)\n        if widgets:\n            widgets[0].focus()\n            return widgets[0]\n        else:\n            return None\n    else:\n        widgets = current_focus.query_next(selector).filter(Widget)\n        if widgets:\n            widgets[0].focus()\n            return widgets[0]\n        else:\n            self.set_focus(None)\n            return None\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/screen.py-focus_previous": {"response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    current_focus = self.focused\n    if current_focus is None:\n        return self.focus_first(selector)\n\n    focusable_widgets = self.query(selector).filter(Widget.is_focusable)\n    if not focusable_widgets:\n        return None\n\n    index = focusable_widgets.index(current_focus)\n    if index == 0:\n        return focusable_widgets[-1]\n    else:\n        return focusable_widgets[index - 1]\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/screen.py-set_focus": {"response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    if widget is None:\n        if self._focus_widget is not None:\n            self._focus_widget.is_focused = False\n            self._focus_widget = None\n    else:\n        if self._focus_widget is not None:\n            self._focus_widget.is_focused = False\n        self._focus_widget = widget\n        widget.is_focused = True\n        if scroll_visible:\n            self.scroll_to_widget(widget)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n# Natural Language Annotations: \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/strip.py-index_to_cell_position": {"response": ["```python\ndef index_to_cell_position(self, index: int) -> int:\n    cell_position = 0\n    for i in range(index):\n        cell_position += len(self._cells[i])\n    return cell_position\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def index_to_cell_position(self, index: int) -> int:\n# Natural Language Annotations: \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/strip.py-render": {"response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    segments = []\n    for segment in self.segments:\n        if isinstance(segment, Strip):\n            segments.append(segment.render(console))\n        else:\n            segments.append(segment.render(console))\n    rendered = \"\".join(segments)\n    return rendered\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self, console: Console) -> str:\n# Natural Language Annotations: \"\"\"Render the strip into terminal sequences.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Rendered sequences.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-batch_update": {"response": ["```python\ndef batch_update(self) -> Generator[None, None, None]:\n    try:\n        self.suspend_updates()\n        yield\n    finally:\n        self.resume_updates()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def batch_update(self) -> Generator[None, None, None]:\n# Natural Language Annotations: \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-call_from_thread": {"response": ["```python\ndef call_from_thread(self, callback: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:\n    if not self._is_running:\n        raise RuntimeError(\"App is not running\")\n    if self._thread_id == threading.get_ident():\n        raise RuntimeError(\n            \"Cannot call App.call_from_thread from within the same thread that the app is running\"\n        )\n    future: Future[Any] = Future()\n    self.post_message(\n        ThreadResponse(callback=callback, args=args, kwargs=kwargs, future=future)\n    )\n    return future.result()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_from_thread(\n# Natural Language Annotations: \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-run_test": {"response": ["```python\nasync def run_test(\n    self,\n    headless: bool = True,\n    size: Size | None = None,\n    tooltips: bool = False,\n    notifications: bool = False,\n    message_hook: MessageHook | None = None,\n) -> AsyncContextManager[Pilot]:\n    \"\"\"An asynchronous context manager for testing apps.\"\"\"\n    if size is None:\n        size = get_terminal_size()\n\n    async def run_test() -> Pilot:\n        pilot = Pilot(self)\n        try:\n            await self._run_app(\n                headless=headless,\n                size=size,\n                tooltips=tooltips,\n                notifications=notifications,\n                message_hook=message_hook,\n                pilot=pilot,\n            )\n        finally:\n            await self.post_stop()\n        return pilot\n\n    return AsyncExitStack.push_async_callback(run_test)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_test(\n# Natural Language Annotations: \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-run": {"response": ["```python\ndef run(\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = False,\n    size: tuple[int, int] | None = None,\n    auto_pilot: Coroutine[Any, Any, None] | None = None,\n) -> Any:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    if headless:\n        return self._run_headless(auto_pilot)\n    elif inline:\n        return self._run_inline(inline_no_clear, auto_pilot)\n    else:\n        return self._run_terminal(mouse, size, auto_pilot)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def run(\n# Natural Language Annotations: \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-switch_mode": {"response": ["```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    if mode not in self.modes:\n        raise UnknownModeError(f\"Unknown mode: {mode}\")\n\n    self.current_mode = mode\n    screen = self.modes[mode]\n\n    if isinstance(screen, AwaitMount):\n        return screen\n    else:\n        return AwaitMount(screen)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_mode(self, mode: str) -> AwaitMount:\n# Natural Language Annotations: \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-push_screen": {"response": ["```python\ndef push_screen(\n    self,\n    screen: Union[Screen, str],\n    callback: Callable[[object], None] = None,\n    wait_for_dismiss: bool = False,\n) -> Union[Awaitable[None], asyncio.Future]:\n    \"\"\"Push a new screen on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is dismissed with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    if isinstance(screen, str):\n        screen = self.screen_registry.get_screen(screen)\n    assert isinstance(screen, Screen)\n\n    if wait_for_dismiss and not self.worker:\n        raise NoActiveWorker(\"wait_for_dismiss requires an active worker\")\n\n    screen._callback = callback\n    self.screen_stack.append(screen)\n    self.refresh(layout=True)\n\n    if wait_for_dismiss:\n        future: asyncio.Future = asyncio.Future()\n        screen._dismiss_future = future\n        return future\n    else:\n        return self.post_message(ScreenMount(screen))\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def push_screen(\n# Natural Language Annotations: \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n        Args:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n                this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n        Raises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-switch_screen": {"response": ["```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    if isinstance(screen, str):\n        screen_name = screen\n        screen = self.app.screens[screen_name]\n    else:\n        screen_name = screen.name\n\n    self.screen_stack[-1] = screen\n    return AwaitComplete(self._request_repaint(screen))\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-pop_screen": {"response": ["```python\ndef pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    previous_screen = self.screen_stack.pop()\n    if self.screen_stack:\n        self.switch_to(self.screen_stack[-1])\n    else:\n        raise ValueError(\"No screens left on the stack.\")\n    return previous_screen\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def pop_screen(self) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/app.py-run_action": {"response": ["```python\nasync def run_action(action: str, default_namespace: Optional[str] = None) -> bool:\n    \"\"\"Perform an action.\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    parts = action.split(\".\")\n    if len(parts) == 1:\n        namespace, action_name = default_namespace or \"app\", parts[0]\n    else:\n        namespace, action_name = parts\n\n    if namespace == \"app\":\n        namespace_obj = get_app()\n    else:\n        namespace_obj = get_app().namespaces.get(namespace)\n\n    if namespace_obj is None:\n        return False\n\n    handler = namespace_obj.get_key_bindings().get_handler(action_name)\n    if handler is None:\n        return False\n\n    await handler()\n    return True\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_action(\n# Natural Language Annotations: \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/file_monitor.py-check": {"response": ["```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    for file_path in self.monitored_files:\n        if os.path.getmtime(file_path) > self.last_modification_time:\n            return True\n    return False\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check(self) -> bool:\n# Natural Language Annotations: \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    result = []\n    pos = 0\n    for char in line:\n        if char == '\\t':\n            spaces = tab_size - (pos % tab_size)\n            result.append(' ' * spaces)\n            pos += spaces\n        else:\n            result.append(char)\n            pos += 1 if char.isascii() else 2\n    return ''.join(result)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n# Natural Language Annotations: \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/_resolve.py-resolve": {"response": ["```python\ndef resolve(dimensions, total, gutter, size, viewport):\n    result = []\n    total_dimensions = sum(dimensions)\n    total_gutters = gutter * (len(dimensions) - 1)\n    available_space = min(size, viewport) - total_gutters\n\n    if total_dimensions == 0:\n        # Distribute space evenly if no dimensions are provided\n        length = available_space // len(dimensions)\n        for _ in range(len(dimensions)):\n            result.append((0, length))\n    else:\n        # Calculate the scale factor\n        scale = available_space / total_dimensions\n\n        # Calculate offsets and lengths based on dimensions and scale\n        offset = 0\n        for dimension in dimensions:\n            length = dimension * scale\n            result.append((offset, length))\n            offset += length + gutter\n\n    return result\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def resolve(\n# Natural Language Annotations: \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/widget.py-mount": {"response": ["```python\ndef mount(self, *widgets, before=None, after=None):\n    if before is not None and after is not None:\n        raise MountError(\"Only one of 'before' or 'after' can be provided.\")\n\n    async def _mount():\n        for widget in widgets:\n            await widget._mount(self)\n            if before is not None:\n                if isinstance(before, int):\n                    self._children.insert(before, widget)\n                else:\n                    target = self.query_one(before)\n                    index = self._children.index(target)\n                    self._children.insert(index, widget)\n            elif after is not None:\n                if isinstance(after, int):\n                    self._children.insert(after + 1, widget)\n                else:\n                    target = self.query_one(after)\n                    index = self._children.index(target)\n                    self._children.insert(index + 1, widget)\n            else:\n                self._children.append(widget)\n        self.refresh()\n\n    return _mount()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def mount(\n# Natural Language Annotations: \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/widget.py-move_child": {"response": ["```python\ndef move_child(child, before=None, after=None):\n    if before is None and after is None:\n        raise WidgetError(\"Either 'before' or 'after' must be provided.\")\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n\n    parent = child.parent\n    if parent is None:\n        raise WidgetError(\"Child widget has no parent.\")\n\n    children = parent.children\n    if child not in children:\n        raise WidgetError(\"Child widget is not a child of the parent.\")\n\n    child_index = children.index(child)\n    children.remove(child)\n\n    if before is not None:\n        if isinstance(before, int):\n            target_index = before\n        else:\n            if before not in children:\n                raise WidgetError(\"Target 'before' widget is not a child of the parent.\")\n            target_index = children.index(before)\n    else:  # after is not None\n        if isinstance(after, int):\n            target_index = after + 1\n        else:\n            if after not in children:\n                raise WidgetError(\"Target 'after' widget is not a child of the parent.\")\n            target_index = children.index(after) + 1\n\n    children.insert(target_index, child)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def move_child(\n# Natural Language Annotations: \"\"\"Move a child widget within its parent's list of children.\n\n        Args:\n            child: The child widget to move.\n            before: Child widget or location index to move before.\n            after: Child widget or location index to move after.\n\n        Raises:\n            WidgetError: If there is a problem with the child or target.\n\n        Note:\n            Only one of `before` or `after` can be provided. If neither\n            or both are provided a `WidgetError` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/widget.py-_get_box_model": {"response": ["```python\ndef _get_box_model(self, container: Size, viewport: Size, width_fraction: float, height_fraction: float) -> Tuple[Size, Thickness]:\n    width = self.styles.width.calculate(container.width, viewport.width, width_fraction)\n    height = self.styles.height.calculate(container.height, viewport.height, height_fraction)\n    size = Size(width, height)\n\n    margin_left = self.styles.margin_left.calculate(container.width, viewport.width, width_fraction)\n    margin_right = self.styles.margin_right.calculate(container.width, viewport.width, width_fraction)\n    margin_top = self.styles.margin_top.calculate(container.height, viewport.height, height_fraction)\n    margin_bottom = self.styles.margin_bottom.calculate(container.height, viewport.height, height_fraction)\n    margin = Thickness(margin_left, margin_top, margin_right, margin_bottom)\n\n    return size, margin\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_box_model(\n# Natural Language Annotations: \"\"\"Process the box model for this widget.\n\n        Args:\n            container: The size of the container widget (with a layout)\n            viewport: The viewport size.\n            width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n            height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n        Returns:\n            The size and margin for this widget.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/widget.py-get_content_width": {"response": ["```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    return viewport.width\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_width(self, container: Size, viewport: Size) -> int:\n# Natural Language Annotations: \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/widget.py-get_content_height": {"response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    return self._content_height\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n# Natural Language Annotations: \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/suggester.py-_get_suggestion": {"response": ["```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    suggestions = await self.get_suggestion(value)\n    await requester.post_message(\n        SuggestionMessage(self, suggestions),\n        requester\n    )\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n# Natural Language Annotations: \"\"\"Used by widgets to get completion suggestions.\n\n        Note:\n            When implementing custom suggesters, this method does not need to be\n            overridden.\n\n        Args:\n            requester: The message target that requested a suggestion.\n            value: The current value to complete.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/dom.py-add_class": {"response": ["```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    for class_name in class_names:\n        self.classes.append(class_name)\n    if update:\n        self._update_styles()\n    return self\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_class(self, *class_names: str, update: bool = True) -> Self:\n# Natural Language Annotations: \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/reactive.py-_initialize_object": {"response": ["```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for name, descriptor in cls.__reactive_attributes__.items():\n        if isinstance(descriptor, Reactive):\n            if descriptor.default is not None:\n                setattr(obj, name, descriptor.default)\n            elif descriptor.required:\n                raise ValueError(f\"{name} is required\")\n        elif isinstance(descriptor, Computed):\n            descriptor.compute(obj)\n\n    for watcher in cls.__reactive_watchers__:\n        watcher.call(obj)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _initialize_object(cls, obj: Reactable) -> None:\n# Natural Language Annotations: \"\"\"Set defaults and call any watchers / computes for the first time.\n\n        Args:\n            obj: An object with Reactive descriptors\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/message_pump.py-call_after_refresh": {"response": ["```python\ndef call_after_refresh(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self._message_pump.is_running():\n        self._message_pump.call_after_refresh(callback, *args, **kwargs)\n        return True\n    return False\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/message_pump.py-call_later": {"response": ["```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    if self._closing or self._closed:\n        return False\n\n    self._pending_callbacks.append((callback, args, kwargs))\n    return True\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/message_pump.py-post_message": {"response": ["```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    try:\n        self.message_queue.put_nowait(message)\n        return True\n    except asyncio.QueueFull:\n        return False\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def post_message(self, message: Message) -> bool:\n# Natural Language Annotations: \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"response": ["```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    result = []\n    for value in self.values:\n        if value.region.intersects(region):\n            result.append(value)\n    return result\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_values_in_region(self, region: Region) -> list[ValueType]:\n# Natural Language Annotations: \"\"\"Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/validation.py-validate": {"response": ["```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    try:\n        result = urlparse(value)\n        if result.scheme:\n            return ValidationResult(success=True)\n        else:\n            return ValidationResult(\n                success=False,\n                error=f\"Invalid URL: {value}. URL must contain a scheme (e.g., http, https).\"\n            )\n    except ValueError:\n        return ValidationResult(success=False, error=f\"Invalid URL: {value}\")\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def validate(self, value: str) -> ValidationResult:\n# Natural Language Annotations: \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/geometry.py-clamp": {"response": ["```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    clamped_x = max(0, min(self.x, width))\n    clamped_y = max(0, min(self.y, height))\n    return Offset(clamped_x, clamped_y)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def clamp(self, width: int, height: int) -> Offset:\n# Natural Language Annotations: \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/constants.py-_get_textual_animations": {"response": ["```python\ndef _get_textual_animations() -> AnimationLevel:\n    animation_level = os.environ.get(\"TEXTUAL_ANIMATIONS\", \"\")\n    try:\n        return AnimationLevel(animation_level.lower())\n    except ValueError:\n        return AnimationLevel.ALL\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_textual_animations() -> AnimationLevel:\n# Natural Language Annotations: \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/color.py-parse": {"response": ["```python\n@classmethod\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n\n    color_text = color_text.strip().lower()\n\n    if color_text.startswith(\"#\"):\n        if len(color_text) == 4:\n            return cls(*(int(c * 2, 16) for c in color_text[1:]), 255)\n        elif len(color_text) == 5:\n            return cls(*(int(c * 2, 16) for c in color_text[1:]))\n        elif len(color_text) == 7:\n            return cls(*(int(color_text[i:i+2], 16) for i in (1, 3, 5)), 255)\n        elif len(color_text) == 9:\n            return cls(*(int(color_text[i:i+2], 16) for i in (1, 3, 5, 7)))\n        else:\n            raise ColorParseError(f\"Invalid color format: {color_text}\")\n\n    if color_text.startswith(\"rgb\"):\n        channels = color_text[color_text.find(\"(\")+1:color_text.find(\")\")].split(\",\")\n        if len(channels) == 3:\n            return cls(*(int(c.strip()) for c in channels), 255)\n        elif len(channels) == 4:\n            return cls(*(int(c.strip()) for c in channels[:3]), round(float(channels[3].strip()) * 255))\n        else:\n            raise ColorParseError(f\"Invalid color format: {color_text}\")\n\n    if color_text.startswith(\"hsl\"):\n        channels = color_text[color_text.find(\"(\")+1:color_text.find(\")\")].split(\",\")\n        if len(channels) == 3:\n            h, s, l = (float(c.strip().rstrip(\"%\")) for c in channels)\n            return cls.from_hsl(h, s / 100, l / 100)\n        elif len(channels) == 4:\n            h, s, l, a = (float(c.strip().rstrip(\"%\")) for c in channels)\n            return cls.from_hsl(h, s / 100, l / 100, a)\n        else:\n            raise ColorParseError(f\"Invalid color format: {color_text}\")\n\n    raise ColorParseError(f\"Invalid color format: {color_text}\")\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(cls, color_text: str | Color) -> Color:\n# Natural Language Annotations: \"\"\"Parse a string containing a named color or CSS-style color.\n\n        Colors may be parsed from the following formats:\n\n        - Text beginning with a `#` is parsed as a hexadecimal color code,\n         where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n            - `#RGB`\n            - `#RGBA`\n            - `#RRGGBB`\n            - `#RRGGBBAA`\n\n        - Alternatively, RGB colors can also be specified in the format\n         that follows, where R, G, and B must be numbers between 0 and 255\n         and A must be a value between 0 and 1:\n\n            - `rgb(R,G,B)`\n            - `rgb(R,G,B,A)`\n\n        - The HSL model can also be used, with a syntax similar to the above,\n         if H is a value between 0 and 360, S and L are percentages, and A\n         is a value between 0 and 1:\n\n            - `hsl(H,S,L)`\n            - `hsla(H,S,L,A)`\n\n        Any other formats will raise a `ColorParseError`.\n\n        Args:\n            color_text: Text with a valid color format. Color objects will\n                be returned unmodified.\n\n        Raises:\n            ColorParseError: If the color is not encoded correctly.\n\n        Returns:\n            Instance encoding the color specified by the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/_slug.py-slug": {"response": ["```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    # Convert the text to lowercase\n    text = text.lower()\n\n    # Replace spaces with hyphens\n    text = text.replace(\" \", \"-\")\n\n    # Remove any characters that are not alphanumeric or hyphens\n    text = re.sub(r\"[^a-z0-9-]\", \"\", text)\n\n    # Remove any consecutive hyphens\n    text = re.sub(r\"-+\", \"-\", text)\n\n    # Remove any leading or trailing hyphens\n    text = text.strip(\"-\")\n\n    return text\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def slug(self, text: str) -> str:\n# Natural Language Annotations: \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n        Args:\n            text: The text to generate a slug from.\n\n        Returns:\n            A slug for the given text.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/_styles_cache.py-render": {"response": ["```python\ndef render(\n    styles,\n    size,\n    base_background,\n    background,\n    render_content_line,\n    console,\n    border_title=None,\n    border_subtitle=None,\n    content_size=None,\n    padding=None,\n    crop=None,\n    filters=None,\n    opacity=1.0,\n):\n    if padding is None:\n        padding = styles.padding\n    if content_size is None:\n        content_size = size - Segment.get_rectangle_size(padding)\n\n    segments = []\n\n    # Background\n    if base_background is not None:\n        segments.append(Segment.rectangle(size, base_background))\n    if background is not None:\n        segments.append(Segment.rectangle(size, background))\n\n    # Content\n    content_segments = []\n    for line in render_content_line(content_size):\n        content_segments.extend(line)\n    segments.append(Segment(content_segments).move(padding[0], padding[1]))\n\n    # Border\n    if border_title is not None or border_subtitle is not None:\n        segments.extend(\n            render_border(\n                size,\n                border_title=border_title,\n                border_subtitle=border_subtitle,\n                styles=styles,\n            )\n        )\n\n    # Crop\n    if crop is not None:\n        segments = Segment.crop_and_filter(\n            segments, crop, filters, pad_filter=False\n        )\n\n    # Apply opacity\n    if opacity < 1.0:\n        for segment in segments:\n            segment.opacity = opacity\n\n    return Segment.simplify(segments)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(\n# Natural Language Annotations: \"\"\"Render a widget content plus CSS styles.\n\n        Args:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            content_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/document/_document.py-replace_range": {"response": ["```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    # Validate the start and end locations\n    if not isinstance(start, tuple) or len(start) != 2:\n        raise ValueError(\"Invalid start location\")\n    if not isinstance(end, tuple) or len(end) != 2:\n        raise ValueError(\"Invalid end location\")\n\n    # Extract the row and column values from the start and end locations\n    start_row, start_col = start\n    end_row, end_col = end\n\n    # Split the document into lines\n    lines = self.text.split('\\n')\n\n    # Validate the start and end locations against the document\n    if start_row < 0 or start_row >= len(lines) or start_col < 0 or start_col > len(lines[start_row]):\n        raise ValueError(\"Invalid start location\")\n    if end_row < 0 or end_row >= len(lines) or end_col < 0 or end_col > len(lines[end_row]):\n        raise ValueError(\"Invalid end location\")\n\n    # Extract the lines affected by the edit\n    affected_lines = lines[start_row:end_row+1]\n\n    # Replace the text within the affected lines\n    affected_lines[0] = affected_lines[0][:start_col] + text + affected_lines[-1][end_col:]\n    affected_lines = affected_lines[:1] + [text] * (len(affected_lines) - 2) + affected_lines[-1:]\n\n    # Update the lines in the document\n    lines[start_row:end_row+1] = affected_lines\n\n    # Join the lines back into a single string\n    self.text = '\\n'.join(lines)\n\n    # Create and return the EditResult\n    return EditResult(start, end, text)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n# Natural Language Annotations: \"\"\"Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"response": ["```python\ndef wrap_range(self, start, old_end, new_end):\n    if start > old_end or start > new_end or old_end > new_end:\n        raise ValueError(\"Invalid range\")\n\n    # Find the line numbers corresponding to the start and end locations\n    start_line = self.source.coord_to_line(start)\n    old_end_line = self.source.coord_to_line(old_end)\n    new_end_line = self.source.coord_to_line(new_end)\n\n    # Invalidate the wrapping for the affected lines\n    for line in range(start_line, max(old_end_line, new_end_line) + 1):\n        if line in self.wrapping:\n            del self.wrapping[line]\n\n    # Recompute the wrapping for the affected lines\n    self._compute_wrapping(start_line, new_end_line)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def wrap_range(\n# Natural Language Annotations: \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n        This must be called *after* the source document has been edited.\n\n        Args:\n            start: The start location of the edit that was performed in document-space.\n            old_end: The old end location of the edit in document-space.\n            new_end: The new end location of the edit in document-space.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"response": ["```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    line_index = 0\n    for line_index, line in enumerate(self.lines):\n        if offset < line.display_offset:\n            break\n    else:\n        raise ValueError(f\"Offset {offset} is out of range.\")\n\n    line = self.lines[line_index - 1]\n    column = offset - line.display_offset\n    return Location(line_index, column)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def offset_to_location(self, offset: Offset) -> Location:\n# Natural Language Annotations: \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/css/parse.py-substitute_references": {"response": ["```python\ndef substitute_references(tokens):\n    variables = {}\n    for token in tokens:\n        if token.name == \"variable_def\":\n            variables[token.value] = token\n        elif token.name == \"variable_ref\":\n            if token.value in variables:\n                referenced_token = variables[token.value]\n                referenced_token.referenced_by.append(token)\n                yield referenced_token\n            else:\n                raise ValueError(f\"Undefined variable reference: {token.value}\")\n        else:\n            yield token\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def substitute_references(\n# Natural Language Annotations: \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/css/parse.py-parse": {"response": ["```python\ndef parse(scope, css, read_from, variables, is_default_rules):\n    tokens = tokenize(css)\n    tokens = substitute_variables(tokens, variables)\n    return generate_rule_sets(scope, tokens, read_from, is_default_rules)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(\n# Natural Language Annotations: \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"response": ["```python\ndef _parse_rules(css: str, read_from: str, is_default_rules: bool, scope: str) -> List[RuleSet]:\n    try:\n        rules = []\n        nodes = tinycss2.parse_stylesheet(css, skip_comments=True, skip_whitespace=True)\n        for node in nodes:\n            if isinstance(node, tinycss2.ast.QualifiedRule):\n                selector = tinycss2.serialize(node.prelude)\n                properties = []\n                for declaration in node.content:\n                    if isinstance(declaration, tinycss2.ast.Declaration):\n                        name = tinycss2.serialize(declaration.name).lower()\n                        value = tinycss2.serialize(declaration.value).strip()\n                        properties.append(Property(name, value, declaration))\n                rules.append(RuleSet(selector, properties, is_default_rules, scope, read_from))\n        return rules\n    except tinycss2.ParseError as error:\n        raise StylesheetError(str(error), read_from)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _parse_rules(\n# Natural Language Annotations: \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "textual-src/textual/css/stylesheet.py-parse": {"response": ["```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    try:\n        # Parse the CSS source\n        parsed_stylesheet = tinycss2.parse_stylesheet(self.source)\n\n        # Process the parsed stylesheet\n        for rule in parsed_stylesheet:\n            if rule.type == 'qualified-rule':\n                self._process_qualified_rule(rule)\n            elif rule.type == 'at-rule':\n                self._process_at_rule(rule)\n            else:\n                # Handle other rule types if needed\n                pass\n\n    except tinycss2.ParseError as e:\n        # Raise StylesheetParseError with CSS related error details\n        raise StylesheetParseError(f\"CSS parsing error: {str(e)}\") from e\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(self) -> None:\n# Natural Language Annotations: \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"response": ["```python\nimport re\nfrom collections import defaultdict\n\nclass Diff:\n    def __init__(self, filename):\n        self.filename = filename\n        self.added_lines = []\n        self.removed_lines = []\n\ndef parse_diffs(diff_string: str) -> dict:\n    diff_dict = defaultdict(Diff)\n    current_diff = None\n\n    lines = diff_string.split('\\n')\n    for line in lines:\n        if line.startswith('diff --git'):\n            if current_diff:\n                diff_dict[current_diff.filename] = current_diff\n            filename = re.findall(r'b/(.+?)$', line)[0]\n            current_diff = Diff(filename)\n        elif line.startswith('@@'):\n            continue\n        elif line.startswith('+'):\n            current_diff.added_lines.append(line[1:])\n        elif line.startswith('-'):\n            current_diff.removed_lines.append(line[1:])\n\n    if current_diff:\n        diff_dict[current_diff.filename] = current_diff\n\n    return dict(diff_dict)\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_diffs(diff_string: str) -> dict:\n# Natural Language Annotations: \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"response": ["```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    self.reset()\n    self.add_system_message(system)\n    self.add_user_message(user)\n    self.step_name = step_name\n    return self.get_conversation_messages()\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n# Natural Language Annotations: \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"response": ["```python\ndef next(messages: List[Message], prompt: Optional[str] = None, step_name: str = \"\") -> List[Message]:\n    # Prepare the conversation history for the LLM\n    conversation_history = [{\"role\": message.role, \"content\": message.content} for message in messages]\n\n    # Send the conversation history to the LLM\n    response = openai.ChatCompletion.create(\n        model=\"gpt-3.5-turbo\",\n        messages=conversation_history,\n        prompt=prompt\n    )\n\n    # Extract the assistant's reply from the LLM response\n    assistant_reply = response.choices[0].message.content\n\n    # Create a new message with the assistant's reply\n    new_message = Message(role=\"assistant\", content=assistant_reply)\n\n    # Append the new message to the conversation history\n    updated_messages = messages + [new_message]\n\n    return updated_messages\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def next(\n# Natural Language Annotations: \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"response": ["```python\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    config = self._config.copy()\n    config.pop(\"config_file\", None)\n    config_str = toml.dumps(config)\n\n    if save:\n        if isinstance(config_file, str):\n            config_file = Path(config_file)\n        with config_file.open(\"w\") as f:\n            f.write(config_str)\n\n    return config_str\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_toml(self, config_file: Path | str, save=True) -> str:\n# Natural Language Annotations: \"\"\"Write the configuration to a TOML file.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"response": ["```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n    \n    if len(str1) > len(str2):\n        str1, str2 = str2, str1\n    \n    similar_chars = sum(c1 == c2 for c1, c2 in zip(str1, str2))\n    similarity_ratio = similar_chars / len(str2)\n    \n    return similarity_ratio >= similarity_threshold\n```"], "final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n# Natural Language Annotations: \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n"}}