{"langchain4j-langchain4j-vertex-ai-gemini/src/main/java/dev/langchain4j/model/vertexai/SchemaHelper.java-fromJsonSchema": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @param text     the text.\n     * @param metadata the metadata.\n     * @return the text segment.\n     */\n    public static TextSegment textSegment(String text, Metadata metadata) {\n        return from(text, metadata);\n    }\n}\n\n------------------------------\n------------------------------\n    }\n\n    public static Content from(TextSegment textSegment) {\n        return new Content(textSegment);\n    }\n}\n\n------------------------------\n------------------------------\n                \" }\";\n    }\n\n    public static Query from(String text) {\n        return new Query(text);\n    }\n\n    public static Query from(String text, Metadata metadata) {\n        return new Query(text, metadata);\n    }\n}\n\n------------------------------\n------------------------------\n\n    /**\n     * Create a new Prompt.\n     * @param text the text of the prompt.\n     * @return the new Prompt.\n     */\n    public static Prompt from(String text) {\n        return new Prompt(text);\n    }\n}\n\n------------------------------\n------------------------------\n     */\n    public static TextContent from(String text) {\n        return new TextContent(text);\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Schema fromJsonSchema(String jsonSchemaString) {\n# Natural Language Annotations: /**\n     * Create an instance of <code>Schema</code> from a JSON schema string.\n     * @param jsonSchemaString the JSON schema string\n     * @return a fully built schema\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Schema fromJsonSchema(String jsonSchemaString) {\n    // Implementation here\n}\n```\n", "```java\npublic static Schema fromJsonSchema(String jsonSchemaString) {\n    // Implement the logic to parse the jsonSchemaString and create a Schema object\n    // This is a placeholder code and it's not valid without actual implementation\n    return new Schema();\n}\n```\n", "```java\npublic static Schema fromJsonSchema(String jsonSchemaString) {\n    // Parse the JSON schema string into a Schema object\n    // This will depend on the library you are using to parse the JSON string\n    // Assuming you are using a library like Gson or Jackson, you can do something like this:\n    // ObjectMapper mapper = new ObjectMapper();\n    // Schema schema = mapper.readValue(jsonSchemaString, Schema.class);\n    // return schema;\n\n    // For simplicity, let's return a dummy Schema object\n    return new Schema();\n}\n```\n"]}, "langchain4j-langchain4j-vertex-ai-gemini/src/main/java/dev/langchain4j/model/vertexai/SchemaHelper.java-fromClass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    private static final StructuredPromptFactory FACTORY = factory();\n\n    private static StructuredPromptFactory factory() {\n        for (StructuredPromptFactory factory : loadFactories(StructuredPromptFactory.class)) {\n            return factory;\n        }\n        return new DefaultStructuredPromptFactory();\n    }\n\n    /**\n     * Converts the given structured prompt to a prompt.\n     *\n     * @param structuredPrompt the structured prompt.\n     * @return the prompt.\n     */\n    public static Prompt toPrompt(Object structuredPrompt) {\n        return FACTORY.toPrompt(structuredPrompt);\n    }\n}\n\n------------------------------\n------------------------------\n    private static JsonObjectSchema toJsonObjectSchema(Class<?> type, String description) {\n\n        Map<String, JsonSchemaElement> properties = new LinkedHashMap<>();\n        for (Field field : type.getDeclaredFields()) {\n            String fieldName = field.getName();\n            if (isStatic(field.getModifiers()) || fieldName.equals(\"__$hits$__\") || fieldName.startsWith(\"this$\")) {\n                continue;\n            }\n            String fieldDescription = getDescription(field);\n            JsonSchemaElement jsonSchemaElement = jsonSchema(field.getType(), field.getGenericType(), fieldDescription);\n            properties.put(fieldName, jsonSchemaElement);\n        }\n\n        return JsonObjectSchema.builder()\n                .description(Optional.ofNullable(description).orElse(getDescription(type)))\n                .properties(properties)\n                .required(new ArrayList<>(properties.keySet()))\n                .additionalProperties(false)\n                .build();\n    }\n\n------------------------------\n------------------------------\n        // Explanation (which will make this a lot easier to understand):\n        // In the case of List<String> these two would be set like:\n        // rawClass: List.class\n        // typeArgumentClass: String.class\n        Class<?> rawClass = getRawClass(returnType);\n        Class<?> typeArgumentClass = TypeUtils.resolveFirstGenericParameterClass(returnType);\n\n        Optional<OutputParser<?>> outputParser = new DefaultOutputParserFactory().get(rawClass, typeArgumentClass);\n        if (outputParser.isPresent()) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private static JsonObjectSchema toJsonObjectSchema(Class<?> type, String description) {\n\n        Map<String, JsonSchemaElement> properties = new LinkedHashMap<>();\n        for (Field field : type.getDeclaredFields()) {\n            String fieldName = field.getName();\n\n------------------------------\n------------------------------\n        return schema(structured, new HashSet<>());\n    }\n\n    private static JsonSchemaProperty schema(Class<?> structured, Set<Class<?>> visited) {\n        if (visited.contains(structured)) {\n            return null;\n        }\n\n        visited.add(structured);\n        Map<String, Object> properties = new HashMap<>();\n        for (Field field : structured.getDeclaredFields()) {\n            String name = field.getName();\n            if (name.equals(\"this$0\") || java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n                // Skip inner class reference.\n                continue;\n            }\n            Iterable<JsonSchemaProperty> schemaProperties = toJsonSchemaProperties(field, visited);\n            Map<Object, Object> objectMap = new HashMap<>();\n            for (JsonSchemaProperty jsonSchemaProperty : schemaProperties) {\n                objectMap.put(jsonSchemaProperty.key(), jsonSchemaProperty.value());\n\n------------------------------\n------------------------------\n     * @param searchEngine the web search engine to use for searching the web\n     * @return a new WebSearchTool\n     */\n    public static WebSearchTool from(WebSearchEngine searchEngine) {\n        return new WebSearchTool(searchEngine);\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Schema fromClass(Class<?> theClass) {\n# Natural Language Annotations: /**\n     * Create an instance of <code>Schema</code> from a class by reflection on its fields.\n     * @param theClass the class for which to create a schema representation\n     * @return a fully built schema\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Schema fromClass(Class<?> theClass) {\n    Map<String, JsonSchemaElement> properties = new LinkedHashMap<>();\n    for (Field field : theClass.getDeclaredFields()) {\n        String fieldName = field.getName();\n        if (isStatic(field.getModifiers()) || fieldName.equals(\"__$hits$__\") || fieldName.startsWith(\"this$\")) {\n            continue;\n        }\n        String fieldDescription = getDescription(field);\n        JsonSchemaElement jsonSchemaElement = jsonSchema(field.getType(), field.getGenericType(), fieldDescription);\n        properties.put(fieldName, jsonSchemaElement);\n    }\n\n    return Schema.builder()\n            .description(Optional.ofNullable(description).orElse(getDescription(theClass)))\n            .properties(properties)\n            .required(new ArrayList<>(properties.keySet()))\n            .additionalProperties(false)\n            .build();\n}\n```\n", "```java\npublic static Schema fromClass(Class<?> theClass) {\n    Map<String, Object> properties = new HashMap<>();\n    for (Field field : theClass.getDeclaredFields()) {\n        String name = field.getName();\n        if (name.equals(\"this$0\") || java.lang.reflect.Modifier.isStatic(field.getModifiers())) {\n            // Skip inner class reference.\n            continue;\n        }\n        Iterable<JsonSchemaProperty> schemaProperties = toJsonSchemaProperties(field, new HashSet<>());\n        Map<Object, Object> objectMap = new HashMap<>();\n        for (JsonSchemaProperty jsonSchemaProperty : schemaProperties) {\n            objectMap.put(jsonSchemaProperty.key(), jsonSchemaProperty.value());\n        }\n        properties.put(name, objectMap);\n    }\n    return new Schema(properties);\n}\n```\n", "```java\npublic static Schema fromClass(Class<?> theClass) {\n    Schema schema = new Schema();\n    for (Field field : theClass.getDeclaredFields()) {\n        String fieldName = field.getName();\n        if (java.lang.reflect.Modifier.isStatic(field.getModifiers()) || fieldName.equals(\"this$0\")) {\n            continue;\n        }\n        Class<?> fieldType = field.getType();\n        SchemaElement schemaElement = toSchemaElement(fieldType);\n        schema.addProperty(fieldName, schemaElement);\n    }\n    return schema;\n}\n\nprivate static SchemaElement toSchemaElement(Class<?> fieldType) {\n    // Implement the logic to convert fieldType to a SchemaElement\n    // This would depend on the specifics of your SchemaElement class\n    // For now, we'll just return a new instance\n    return new SchemaElement();\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocuments(String directoryPath, DocumentParser documentParser) {\n        return loadDocuments(Paths.get(directoryPath), documentParser);\n    }\n\n    /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the default {@link DocumentParser}.\n     * The default {@code DocumentParser} is loaded through SPI (see {@link DocumentParserFactory}).\n     * If no {@code DocumentParserFactory} is available in the classpath, a {@link TextDocumentParser} is used.\n\n------------------------------\n------------------------------\n     *\n     * @param directoryPath The path to the directory with files.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(Path directoryPath) {\n        return loadDocumentsRecursively(directoryPath, DEFAULT_DOCUMENT_PARSER);\n    }\n\n    /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n\n------------------------------\n------------------------------\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(String directoryPath, PathMatcher pathMatcher) {\n        return loadDocumentsRecursively(directoryPath, pathMatcher, DEFAULT_DOCUMENT_PARSER);\n    }\n\n    private static List<Document> loadDocuments(Stream<Path> pathStream,\n                                                PathMatcher pathMatcher,\n                                                Path pathMatcherRoot,\n                                                DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n\n        pathStream\n                .filter(Files::isRegularFile)\n                // converting absolute path into relative before using pathMatcher\n                // because patterns defined in pathMatcher are relative to pathMatcherRoot (directoryPath)\n                .map(pathMatcherRoot::relativize)\n                .filter(pathMatcher::matches)\n                // converting relative path back into absolute before loading document\n                .map(pathMatcherRoot::resolve)\n\n------------------------------\n------------------------------\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(Path directoryPath,\n                                                          PathMatcher pathMatcher,\n                                                          DocumentParser documentParser) {\n        if (!isDirectory(directoryPath)) {\n            throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n        }\n\n        try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n            return loadDocuments(pathStream, pathMatcher, directoryPath, documentParser);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Recursively loads matching {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n\n------------------------------\n------------------------------\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocuments(Path directoryPath,\n                                               PathMatcher pathMatcher,\n                                               DocumentParser documentParser) {\n        if (!isDirectory(directoryPath)) {\n            throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n        }\n\n        try (Stream<Path> pathStream = Files.list(directoryPath)) {\n            return loadDocuments(pathStream, pathMatcher, directoryPath, documentParser);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Loads matching {@link Document}s from the specified directory. Does not use recursion.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.list(directoryPath)) {\n        List<Document> documents = new ArrayList<>();\n\n        pathStream\n            .filter(Files::isRegularFile)\n            .map(documentPath -> {\n                try {\n                    return documentParser.parse(documentPath);\n                } catch (IOException e) {\n                    return null;\n                }\n            })\n            .filter(Objects::nonNull)\n            .forEach(documents::add);\n\n        return documents;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\nprivate static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (Stream<Path> pathStream = Files.list(directoryPath)) {\n        pathStream\n            .filter(Files::isRegularFile)\n            .forEach(path -> {\n                try {\n                    String text = documentParser.parse(path);\n                    Document document = new Document(path, text);\n                    documents.add(document);\n                } catch (IOException e) {\n                    System.err.println(\"Failed to load document from path: \" + path);\n                }\n            });\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n\n    return documents;\n}\n```\n", "```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (Stream<Path> pathStream = Files.list(directoryPath)) {\n        pathStream\n            .filter(Files::isRegularFile)\n            .forEach(path -> {\n                try {\n                    String text = documentParser.parse(path);\n                    Document document = new Document(text);\n                    documents.add(document);\n                } catch (IOException e) {\n                    // Skip the file if it fails to load\n                }\n            });\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n\n    return documents;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(String directoryPath, PathMatcher pathMatcher) {\n        return loadDocumentsRecursively(directoryPath, pathMatcher, DEFAULT_DOCUMENT_PARSER);\n    }\n\n    private static List<Document> loadDocuments(Stream<Path> pathStream,\n                                                PathMatcher pathMatcher,\n                                                Path pathMatcherRoot,\n                                                DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n\n        pathStream\n                .filter(Files::isRegularFile)\n                // converting absolute path into relative before using pathMatcher\n                // because patterns defined in pathMatcher are relative to pathMatcherRoot (directoryPath)\n                .map(pathMatcherRoot::relativize)\n                .filter(pathMatcher::matches)\n                // converting relative path back into absolute before loading document\n                .map(pathMatcherRoot::resolve)\n\n------------------------------\n------------------------------\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(String directoryPath, DocumentParser documentParser) {\n        return loadDocumentsRecursively(Paths.get(directoryPath), documentParser);\n    }\n\n    /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the default {@link DocumentParser}.\n     * The default {@code DocumentParser} is loaded through SPI (see {@link DocumentParserFactory}).\n     * If no {@code DocumentParserFactory} is available in the classpath, a {@link TextDocumentParser} is used.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath The path to the directory with files.\n\n------------------------------\n------------------------------\n     *\n     * @param directoryPath The path to the directory with files.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(Path directoryPath) {\n        return loadDocumentsRecursively(directoryPath, DEFAULT_DOCUMENT_PARSER);\n    }\n\n    /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n\n------------------------------\n------------------------------\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocuments(Path directoryPath,\n                                               PathMatcher pathMatcher,\n                                               DocumentParser documentParser) {\n        if (!isDirectory(directoryPath)) {\n            throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n        }\n\n        try (Stream<Path> pathStream = Files.list(directoryPath)) {\n            return loadDocuments(pathStream, pathMatcher, directoryPath, documentParser);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Loads matching {@link Document}s from the specified directory. Does not use recursion.\n\n------------------------------\n------------------------------\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(Path directoryPath,\n                                                          PathMatcher pathMatcher,\n                                                          DocumentParser documentParser) {\n        if (!isDirectory(directoryPath)) {\n            throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n        }\n\n        try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n            return loadDocuments(pathStream, pathMatcher, directoryPath, documentParser);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Recursively loads matching {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n        return loadDocuments(pathStream, path -> true, directoryPath, documentParser);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n        return loadDocuments(pathStream, documentParser);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    return loadDocumentsRecursively(directoryPath, PathMatcher.ALL, documentParser);\n}\n\nprivate static List<Document> loadDocumentsRecursively(Path directoryPath,\n                                                       PathMatcher pathMatcher,\n                                                       DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n        return loadDocuments(pathStream, pathMatcher, directoryPath, documentParser);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static List<Document> loadDocuments(Stream<Path> pathStream,\n                                             PathMatcher pathMatcher,\n                                             Path pathMatcherRoot,\n                                             DocumentParser documentParser) {\n    List<Document> documents = new ArrayList<>();\n\n    pathStream\n            .filter(Files::isRegularFile)\n            .map(pathMatcherRoot::relativize)\n            .filter(pathMatcher::matches)\n            .map(pathMatcherRoot::resolve)\n            .forEach(documentPath -> {\n                try {\n                    String text = Files.readString(documentPath);\n                    Document document = documentParser.parseDocument(text);\n                    documents.add(document);\n                } catch (IOException e) {\n                    // Skip failed documents\n                }\n            });\n\n    return documents;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(textSegment);\n    }\n\n    @Override\n    public String toString() {\n        return \"Content {\" +\n                \" textSegment = \" + textSegment +\n                \" }\";\n    }\n\n    public static Content from(String text) {\n        return new Content(text);\n    }\n\n    public static Content from(TextSegment textSegment) {\n        return new Content(textSegment);\n    }\n\n------------------------------\n------------------------------\n    @Override\n    public String[] split(String text) {\n        return text.split(\"\");\n    }\n\n    @Override\n    public String joinDelimiter() {\n        return \"\";\n    }\n\n    @Override\n    protected DocumentSplitter defaultSubSplitter() {\n        return null;\n    }\n}\n\n------------------------------\n------------------------------\n    public Content(TextSegment textSegment) {\n        this.textSegment = ensureNotNull(textSegment, \"textSegment\");\n    }\n\n    public TextSegment textSegment() {\n        return textSegment;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Content that = (Content) o;\n        return Objects.equals(this.textSegment, that.textSegment);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(textSegment);\n    }\n\n------------------------------\n------------------------------\n            totalSize += segmentSize + joinSeparatorSize;\n        }\n        return totalSize <= maxSegmentSize;\n    }\n\n    /**\n     * Returns the size of the provided text (as returned by the {@code sizeFunction}).\n     * @param text The text to check.\n     * @return The size of the provided text.\n     */\n    public int sizeOf(String text) {\n        return sizeFunction.apply(text);\n    }\n\n    /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    /**\n     * Returns {@code true} if the provided size can be added to the current segment.\n     * @param size The size to check.\n     * @return {@code true} if the provided size can be added to the current segment.\n     */\n    public boolean hasSpaceFor(int size) {\n        int totalSize = size;\n        if (isNotEmpty()) {\n            totalSize += segmentSize + joinSeparatorSize;\n        }\n        return totalSize <= maxSegmentSize;\n    }\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public boolean hasSpaceFor(String text) {\n# Natural Language Annotations: /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic boolean hasSpaceFor(String text) {\n    int textSize = sizeOf(text);\n    int totalSize = textSize;\n    if (isNotEmpty()) {\n        totalSize += segmentSize + joinSeparatorSize;\n    }\n    return totalSize <= maxSegmentSize;\n}\n```\n", "```java\npublic boolean hasSpaceFor(String text) {\n    int textSize = sizeOf(text);\n    int totalSize = textSize;\n    if (isNotEmpty()) {\n        totalSize += segmentSize + joinSeparatorSize;\n    }\n    return totalSize <= maxSegmentSize;\n}\n```\n", "```java\npublic boolean hasSpaceFor(String text) {\n    int size = sizeOf(text);\n    int totalSize = size;\n    if (isNotEmpty()) {\n        totalSize += segmentSize + joinSeparatorSize;\n    }\n    return totalSize <= maxSegmentSize;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        } catch (BlankDocumentException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n    private static UUID toUUID(Object actualUUID) {\n        if (actualUUID instanceof String) {\n            return UUID.fromString(actualUUID.toString());\n        } else if (actualUUID instanceof UUID) {\n            return (UUID)actualUUID;\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + actualUUID.getClass().getName());\n    }\n}\n\n------------------------------\n------------------------------\n\n    /**\n     * Returns the current size of the segment (as returned by the {@code sizeFunction}).\n     * @return The current size of the segment.\n     */\n    public int getSize() {\n        return segmentSize;\n    }\n\n    /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    /**\n     * Returns {@code true} if the provided size can be added to the current segment.\n     * @param size The size to check.\n     * @return {@code true} if the provided size can be added to the current segment.\n     */\n    public boolean hasSpaceFor(int size) {\n        int totalSize = size;\n        if (isNotEmpty()) {\n            totalSize += segmentSize + joinSeparatorSize;\n        }\n        return totalSize <= maxSegmentSize;\n    }\n\n\n------------------------------\n------------------------------\n            totalSize += segmentSize + joinSeparatorSize;\n        }\n        return totalSize <= maxSegmentSize;\n    }\n\n    /**\n     * Returns the size of the provided text (as returned by the {@code sizeFunction}).\n     * @param text The text to check.\n     * @return The size of the provided text.\n     */\n    public int sizeOf(String text) {\n        return sizeFunction.apply(text);\n    }\n\n    /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void append(String text) {\n# Natural Language Annotations: /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void append(String text) {\n    if (hasSpaceFor(sizeOf(text))) {\n        if (isNotEmpty()) {\n            currentSegment += joinSeparator;\n        }\n        currentSegment += text;\n        segmentSize += sizeOf(text);\n    } else {\n        throw new IllegalStateException(\"Not enough space in the segment.\");\n    }\n}\n```\n", "```java\npublic void append(String text) {\n    int textSize = sizeOf(text);\n    if (hasSpaceFor(textSize)) {\n        if (isNotEmpty()) {\n            currentSegment.append(joinSeparator);\n        }\n        currentSegment.append(text);\n        segmentSize += textSize;\n    } else {\n        throw new IllegalStateException(\"Segment has insufficient space for the provided text.\");\n    }\n}\n```\n", "```java\npublic void append(String text) {\n    if (hasSpaceFor(sizeOf(text))) {\n        // Append the text to the segment\n        // Depending on the implementation, it may look something like this:\n        // segment += text;\n        segmentSize += sizeOf(text);\n    } else {\n        throw new RuntimeException(\"Not enough space for the provided text\");\n    }\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public String[] split(String text) {\n        return text.split(\"\");\n    }\n\n    @Override\n    public String joinDelimiter() {\n        return \"\";\n    }\n\n    @Override\n    protected DocumentSplitter defaultSubSplitter() {\n        return null;\n    }\n}\n\n------------------------------\n------------------------------\n\n    /**\n     * Create a new Prompt.\n     * @param text the text of the prompt.\n     * @return the new Prompt.\n     */\n    public static Prompt from(String text) {\n        return new Prompt(text);\n    }\n}\n\n------------------------------\n------------------------------\n\n        private LabelWithScore(E label, double score) {\n            this.label = label;\n            this.score = score;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n     */\n    public static TextContent from(String text) {\n        return new TextContent(text);\n    }\n}\n\n------------------------------\n------------------------------\n            @Override\n            public void onNext(String text) {\n                nextLambda.accept(text);\n            }\n\n            @Override\n            public void onError(Throwable error) {\n                errorLambda.accept(error);\n            }\n        };\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void prepend(String text) {\n# Natural Language Annotations: /**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void prepend(String text) {\n    // Your code here\n}\n```\n", "```java\npublic void prepend(String text) {\n    // Implement your code here\n}\n```\n", "```java\npublic void prepend(String text) {\n    // Implement the prepending logic here\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        private LabelWithScore(E label, double score) {\n            this.label = label;\n            this.score = score;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n\n        public Builder responseFormat(ResponseFormat responseFormat) {\n            this.responseFormat = responseFormat;\n            return this;\n        }\n\n        public ChatRequest build() {\n            return new ChatRequest(this);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n */\n@Deprecated\npublic class EmbeddingStoreRetriever implements Retriever<TextSegment> {\n\n    private final EmbeddingStore<TextSegment> embeddingStore;\n    private final EmbeddingModel embeddingModel;\n    private final int maxResults;\n    private final Double minScore;\n\n    public EmbeddingStoreRetriever(EmbeddingStore<TextSegment> embeddingStore,\n                                   EmbeddingModel embeddingModel,\n                                   int maxResults,\n                                   Double minScore) {\n        this.embeddingStore = embeddingStore;\n        this.embeddingModel = embeddingModel;\n        this.maxResults = maxResults;\n        this.minScore = minScore;\n    }\n\n    @Override\n\n------------------------------\n------------------------------\n\n        private ChatLanguageModel chatLanguageModel;\n        private ChatMemory chatMemory;\n        private RetrievalAugmentor retrievalAugmentor;\n\n        @Deprecated\n        private dev.langchain4j.retriever.Retriever<TextSegment> retriever;\n        @Deprecated\n        private PromptTemplate promptTemplate;\n\n        public Builder chatLanguageModel(ChatLanguageModel chatLanguageModel) {\n            this.chatLanguageModel = chatLanguageModel;\n            return this;\n        }\n\n        public Builder chatMemory(ChatMemory chatMemory) {\n            this.chatMemory = chatMemory;\n            return this;\n        }\n\n\n------------------------------\n------------------------------\n    @Override\n    protected EmbeddingStore<TextSegment> embeddingStore() {\n        return embeddingStore;\n    }\n\n    @Override\n    protected EmbeddingModel embeddingModel() {\n        return embeddingModel;\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public AiServices<T> retriever(Retriever<TextSegment> retriever) {\n# Natural Language Annotations: /**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    this.retriever = retriever;\n    return this;\n}\n```\n", "```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    this.retriever = retriever;\n    return this;\n}\n```\n", "```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    // Configures a retriever that will be invoked on every method call to fetch relevant information\n    // related to the current user message from an underlying source (e.g., embedding store).\n    // This relevant information is automatically injected into the message sent to the LLM.\n    this.retriever = retriever;\n    return this;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    public DefaultQueryRouter(ContentRetriever... contentRetrievers) {\n        this(asList(contentRetrievers));\n    }\n\n    public DefaultQueryRouter(Collection<ContentRetriever> contentRetrievers) {\n        this.contentRetrievers = unmodifiableCollection(ensureNotEmpty(contentRetrievers, \"contentRetrievers\"));\n    }\n\n    @Override\n    public Collection<ContentRetriever> route(Query query) {\n        return contentRetrievers;\n    }\n}\n\n------------------------------\n------------------------------\n    private static String escapeNewlines(String text) {\n        return text.replace(\"\\n\", \"\\\\n\");\n    }\n\n    public static DefaultRetrievalAugmentorBuilder builder() {\n        return new DefaultRetrievalAugmentorBuilder();\n    }\n\n    public static class DefaultRetrievalAugmentorBuilder {\n\n        public DefaultRetrievalAugmentorBuilder contentRetriever(ContentRetriever contentRetriever) {\n            this.queryRouter = new DefaultQueryRouter(ensureNotNull(contentRetriever, \"contentRetriever\"));\n            return this;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n        public Builder chatMemory(ChatMemory chatMemory) {\n            this.chatMemory = chatMemory;\n            return this;\n        }\n\n        public Builder contentRetriever(ContentRetriever contentRetriever) {\n            if (contentRetriever != null) {\n                this.retrievalAugmentor = DefaultRetrievalAugmentor.builder()\n                        .contentRetriever(contentRetriever)\n                        .build();\n            }\n            return this;\n        }\n\n        public Builder retrievalAugmentor(RetrievalAugmentor retrievalAugmentor) {\n            this.retrievalAugmentor = retrievalAugmentor;\n            return this;\n        }\n\n        /**\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Configures a retrieval augmentor to be invoked on every method call.\n     *\n     * @param retrievalAugmentor The retrieval augmentor to be used by the AI Service.\n     * @return builder\n     */\n    public AiServices<T> retrievalAugmentor(RetrievalAugmentor retrievalAugmentor) {\n        if (retrieverSet || contentRetrieverSet) {\n            throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n\n------------------------------\n------------------------------\n     * @return builder\n     */\n    public AiServices<T> retrievalAugmentor(RetrievalAugmentor retrievalAugmentor) {\n        if (retrieverSet || contentRetrieverSet) {\n            throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n        }\n        retrievalAugmentorSet = true;\n        context.retrievalAugmentor = ensureNotNull(retrievalAugmentor, \"retrievalAugmentor\");\n        return this;\n    }\n\n    /**\n     * Constructs and returns the AI Service.\n     *\n     * @return An instance of the AI Service implementing the specified interface.\n     */\n    public abstract T build();\n\n    protected void performBasicValidation() {\n        if (context.chatModel == null && context.streamingChatModel == null) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n# Natural Language Annotations: /**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n     * a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    if (retrieverSet || retrievalAugmentorSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    contentRetrieverSet = true;\n    context.contentRetriever = ensureNotNull(contentRetriever, \"contentRetriever\");\n    return this;\n}\n```\n", "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    if (retrieverSet || retrievalAugmentorSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    contentRetrieverSet = true;\n    context.contentRetriever = ensureNotNull(contentRetriever, \"contentRetriever\");\n    return this;\n}\n```\n", "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    if (retrieverSet || retrievalAugmentorSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    contentRetrieverSet = true;\n    context.retrievalAugmentor = new DefaultRetrievalAugmentor(ensureNotNull(contentRetriever, \"contentRetriever\"));\n    return this;\n}\n```\n"]}, "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * Adds a given embedding to the store.\n     *\n     * @param id        The unique identifier for the embedding to be added.\n     * @param embedding The embedding to be added to the store.\n     */\n    @Override\n    public void add(String id, Embedding embedding) {\n        addInternal(id, embedding, null);\n    }\n\n    /**\n     * Adds a given embedding and the corresponding content that has been embedded to the store.\n     *\n     * @param embedding   The embedding to be added to the store.\n     * @param textSegment Original content that was embedded.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n    @Override\n    public String add(Embedding embedding, TextSegment textSegment) {\n        String id = randomUUID();\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public String add(Embedding embedding, Embedded embedded) {\n        String id = randomUUID();\n        add(id, embedding, embedded);\n        return id;\n    }\n\n    public void add(String id, Embedding embedding, Embedded embedded) {\n        entries.add(new Entry<>(id, embedding, embedded));\n    }\n\n    @Override\n    public List<String> addAll(List<Embedding> embeddings) {\n\n        List<Entry<Embedded>> newEntries = embeddings.stream()\n                .map(embedding -> new Entry<Embedded>(randomUUID(), embedding))\n                .collect(toList());\n\n\n------------------------------\n------------------------------\n     * @return The auto-generated ID associated with the added embedding.\n     */\n    @Override\n    public String add(Embedding embedding, TextSegment textSegment) {\n        String id = randomUUID();\n        addInternal(id, embedding, textSegment);\n        return id;\n    }\n\n    /**\n     * Adds multiple embeddings to the store.\n     *\n     * @param embeddings A list of embeddings to be added to the store.\n     * @return A list of auto-generated IDs associated with the added embeddings.\n     */\n    @Override\n    public List<String> addAll(List<Embedding> embeddings) {\n        List<String> ids = embeddings.stream().map(ignored -> randomUUID()).collect(toList());\n        addAllInternal(ids, embeddings, null);\n        return ids;\n\n------------------------------\n------------------------------\n    @Override\n    public void add(String id, Embedding embedding) {\n        addInternal(id, embedding, null);\n    }\n\n    /**\n     * Adds a given embedding and the corresponding content that has been embedded to the store.\n     *\n     * @param embedding   The embedding to be added to the store.\n     * @param textSegment Original content that was embedded.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n    @Override\n    public String add(Embedding embedding, TextSegment textSegment) {\n        String id = randomUUID();\n        addInternal(id, embedding, textSegment);\n        return id;\n    }\n\n    /**\n\n------------------------------\n------------------------------\n\n    private InMemoryEmbeddingStore(Collection<Entry<Embedded>> entries) {\n        this.entries = new CopyOnWriteArrayList<>(entries);\n    }\n\n    @Override\n    public String add(Embedding embedding) {\n        String id = randomUUID();\n        add(id, embedding);\n        return id;\n    }\n\n    @Override\n    public void add(String id, Embedding embedding) {\n        add(id, embedding, null);\n    }\n\n    @Override\n    public String add(Embedding embedding, Embedded embedded) {\n        String id = randomUUID();\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public String add(Embedding embedding) {\n# Natural Language Annotations: /**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic String add(Embedding embedding) {\n    String id = randomUUID();\n    add(id, embedding);\n    return id;\n}\n```\n", "```java\n@Override\npublic String add(Embedding embedding) {\n    String id = randomUUID();\n    addInternal(id, embedding, null);\n    return id;\n}\n```\n", "```java\nprivate String add(Embedding embedding) {\n    String id = randomUUID();\n    add(id, embedding);\n    return id;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        // Then, fuse all contents retrieved using all queries\n        return ReciprocalRankFuser.fuse(fused.values());\n    }\n\n    protected Map<Query, List<Content>> fuse(Map<Query, Collection<List<Content>>> queryToContents) {\n        Map<Query, List<Content>> fused = new LinkedHashMap<>();\n        for (Query query : queryToContents.keySet()) {\n            Collection<List<Content>> contents = queryToContents.get(query);\n            fused.put(query, ReciprocalRankFuser.fuse(contents));\n        }\n        return fused;\n    }\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public Response<AiMessage> generate(List<ChatMessage> messages) {\n        return generate(messages, new ArrayList<>());\n    }\n\n    @Override\n    public Response<AiMessage> generate(List<ChatMessage> messages, List<ToolSpecification> toolSpecifications) {\n        String modelName = generativeModel.getModelName();\n\n        List<Tool> tools = new ArrayList<>();\n        if (toolSpecifications != null && !toolSpecifications.isEmpty()) {\n            Tool tool = FunctionCallHelper.convertToolSpecifications(toolSpecifications);\n            tools.add(tool);\n        }\n\n        if (this.googleSearch != null) {\n            tools.add(this.googleSearch);\n        }\n        if (this.vertexSearch != null) {\n\n------------------------------\n------------------------------\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool}\n     * within the class of the specified object.\n     *\n     * @param objectWithTools the object.\n     * @return the {@link ToolSpecification}s.\n     */\n    public static List<ToolSpecification> toolSpecificationsFrom(Object objectWithTools) {\n        return toolSpecificationsFrom(objectWithTools.getClass());\n    }\n\n    /**\n     * Validates all the {@link ToolSpecification}s. The validation checks for duplicate method names.\n     * Throws {@link IllegalArgumentException} if validation fails\n     *\n     * @param toolSpecifications list of ToolSpecification to be validated.\n     */\n    public static void validateSpecifications(List<ToolSpecification> toolSpecifications) throws IllegalArgumentException {\n\n        // Checks for duplicates methods\n        Set<String> names = new HashSet<>();\n\n------------------------------\n------------------------------\n            for (Method method : objectWithTool.getClass().getDeclaredMethods()) {\n                if (method.isAnnotationPresent(Tool.class)) {\n                    ToolSpecification toolSpecification = toolSpecificationFrom(method);\n                    context.toolSpecifications.add(toolSpecification);\n                    context.toolExecutors.put(toolSpecification.name(), new DefaultToolExecutor(objectWithTool, method));\n                }\n            }\n        }\n\n        return this;\n    }\n\n    /**\n     * Configures the tools that the LLM can use.\n     *\n     * @param tools A map of {@link ToolSpecification} to {@link ToolExecutor} entries.\n     *              This method of configuring tools is useful when tools must be configured programmatically.\n     *              Otherwise, it is recommended to use the {@link Tool}-annotated java methods\n     *              and configure tools with the {@link #tools(Object...)} and {@link #tools(List)} methods.\n     * @return builder\n\n------------------------------\n------------------------------\n    public AiServices<T> tools(List<Object> objectsWithTools) { // TODO Collection?\n        // TODO validate uniqueness of tool names\n\n        if (context.toolSpecifications == null) {\n            context.toolSpecifications = new ArrayList<>();\n        }\n        if (context.toolExecutors == null) {\n            context.toolExecutors = new HashMap<>();\n        }\n\n        for (Object objectWithTool : objectsWithTools) {\n            if (objectWithTool instanceof Class) {\n                throw illegalConfiguration(\"Tool '%s' must be an object, not a class\", objectWithTool);\n            }\n\n            for (Method method : objectWithTool.getClass().getDeclaredMethods()) {\n                if (method.isAnnotationPresent(Tool.class)) {\n                    ToolSpecification toolSpecification = toolSpecificationFrom(method);\n                    context.toolSpecifications.add(toolSpecification);\n                    context.toolExecutors.put(toolSpecification.name(), new DefaultToolExecutor(objectWithTool, method));\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n# Natural Language Annotations: /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            ToolSpecification toolSpecification = toolSpecificationFrom(method);\n            toolSpecifications.add(toolSpecification);\n        }\n    }\n    return toolSpecifications;\n}\n```\n", "```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            ToolSpecification toolSpecification = toolSpecificationFrom(method);\n            toolSpecifications.add(toolSpecification);\n        }\n    }\n    return toolSpecifications;\n}\n```\n", "```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            ToolSpecification toolSpecification = toolSpecificationFrom(method);\n            toolSpecifications.add(toolSpecification);\n        }\n    }\n\n    return toolSpecifications;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        } else {\n            return Json.toJson(result);\n        }\n    }\n\n    static Object[] prepareArguments(\n            Method method,\n            Map<String, Object> argumentsMap,\n            Object memoryId\n    ) {\n        Parameter[] parameters = method.getParameters();\n        Object[] arguments = new Object[parameters.length];\n\n        for (int i = 0; i < parameters.length; i++) {\n\n            if (parameters[i].isAnnotationPresent(ToolMemoryId.class)) {\n                arguments[i] = memoryId;\n                continue;\n            }\n\n\n------------------------------\n------------------------------\n     * @param searchEngine the web search engine to use for searching the web\n     * @return a new WebSearchTool\n     */\n    public static WebSearchTool from(WebSearchEngine searchEngine) {\n        return new WebSearchTool(searchEngine);\n    }\n}\n\n------------------------------\n------------------------------\n\n    public static UrlSource from(URI uri) {\n        try {\n            return new UrlSource(uri.toURL());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n    public Response<AiMessage> generate(List<ChatMessage> messages, ToolSpecification toolSpecification) {\n        if (toolSpecification == null) {\n            return generate(messages);\n        } else {\n            return generate(messages, Collections.singletonList(toolSpecification));\n        }\n    }\n\n    @Override\n    public void close() throws IOException {\n        if (this.vertexAI != null) {\n            vertexAI.close();\n        }\n    }\n\n    public static VertexAiGeminiChatModelBuilder builder() {\n        for (VertexAiGeminiChatModelBuilderFactory factory : loadFactories(VertexAiGeminiChatModelBuilderFactory.class)) {\n            return factory.get();\n        }\n        return new VertexAiGeminiChatModelBuilder();\n\n------------------------------\n------------------------------\n\n    /**\n     * Create a new Prompt.\n     * @param text the text of the prompt.\n     * @return the new Prompt.\n     */\n    public static Prompt from(String text) {\n        return new Prompt(text);\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ToolSpecification toolSpecificationFrom(Method method) {\n# Natural Language Annotations: /**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    if (toolAnnotation != null) {\n        return new ToolSpecification(toolAnnotation.value());\n    }\n    return null;\n}\n```\n", "```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    if (toolAnnotation != null) {\n        return ToolSpecification.from(toolAnnotation.value());\n    } else {\n        return null;\n    }\n}\n```\n", "```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    if (method.isAnnotationPresent(Tool.class)) {\n        Tool tool = method.getAnnotation(Tool.class);\n        return new ToolSpecification(tool.name(), tool.description());\n    } else {\n        throw new IllegalArgumentException(\"The method doesn't have the @Tool annotation.\");\n    }\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        }\n        if (isJsonBoolean(clazz)) {\n            return items(JsonSchemaProperty.BOOLEAN);\n        }\n        if (isJsonInteger(clazz)) {\n            return items(JsonSchemaProperty.INTEGER);\n        }\n        if (isJsonNumber(clazz)) {\n            return items(JsonSchemaProperty.NUMBER);\n        }\n        return objectItems(schema(clazz));\n    }\n\n    /**\n     * Remove nulls from the given array.\n     *\n     * @param items the array\n     * @return an iterable of the non-null items.\n     */\n    static Iterable<JsonSchemaProperty> removeNulls(JsonSchemaProperty... items) {\n\n------------------------------\n------------------------------\n         * @return {@code this}\n         */\n        public Builder addParameter(String name, Iterable<JsonSchemaProperty> jsonSchemaProperties) {\n            addOptionalParameter(name, jsonSchemaProperties);\n            this.parameters.required().add(name);\n            return this;\n        }\n\n        /**\n         * Adds an optional parameter to the tool.\n         * @param name the name of the parameter.\n         * @param jsonSchemaProperties the properties of the parameter.\n         * @return {@code this}\n         */\n        public Builder addOptionalParameter(String name, JsonSchemaProperty... jsonSchemaProperties) {\n            return addOptionalParameter(name, asList(jsonSchemaProperties));\n        }\n\n        /**\n         * Adds an optional parameter to the tool.\n\n------------------------------\n------------------------------\n\n    private static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Class<?> type, JsonSchemaProperty description) {\n\n        if (type == String.class) {\n            return removeNulls(STRING, description);\n        }\n\n        if (isJsonBoolean(type)) {\n            return removeNulls(BOOLEAN, description);\n        }\n\n        if (isJsonInteger(type)) {\n            return removeNulls(INTEGER, description);\n        }\n\n        if (isJsonNumber(type)) {\n            return removeNulls(NUMBER, description);\n        }\n\n        if (type.isArray()) {\n\n------------------------------\n------------------------------\n     *\n     * @param items the array\n     * @return an iterable of the non-null items.\n     */\n    static Iterable<JsonSchemaProperty> removeNulls(JsonSchemaProperty... items) {\n        return stream(items)\n                .filter(Objects::nonNull)\n                .collect(toList());\n    }\n}\n\n------------------------------\n------------------------------\n\n        /**\n         * Adds a parameter to the tool.\n         * @param name the name of the parameter.\n         * @param jsonSchemaProperties the properties of the parameter.\n         * @return {@code this}\n         */\n        public Builder addParameter(String name, JsonSchemaProperty... jsonSchemaProperties) {\n            return addParameter(name, asList(jsonSchemaProperties));\n        }\n\n        /**\n         * Adds a parameter to the tool.\n         * @param name the name of the parameter.\n         * @param jsonSchemaProperties the properties of the parameter.\n         * @return {@code this}\n         */\n        public Builder addParameter(String name, Iterable<JsonSchemaProperty> jsonSchemaProperties) {\n            addOptionalParameter(name, jsonSchemaProperties);\n            this.parameters.required().add(name);\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n# Natural Language Annotations: /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    Class<?> type = parameter.getType();\n    JsonSchemaProperty description = parameter.getDescription();\n\n    if (type == String.class) {\n        return removeNulls(STRING, description);\n    }\n\n    if (isJsonBoolean(type)) {\n        return removeNulls(BOOLEAN, description);\n    }\n\n    if (isJsonInteger(type)) {\n        return removeNulls(INTEGER, description);\n    }\n\n    if (isJsonNumber(type)) {\n        return removeNulls(NUMBER, description);\n    }\n\n    if (type.isArray()) {\n        // Handle array type conversion here\n    }\n\n    return removeNulls(description);\n}\n```\n", "```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    Class<?> type = parameter.getType();\n    JsonSchemaProperty description = parameter.getDescription();\n\n    if (type == String.class) {\n        return removeNulls(JsonSchemaProperty.STRING, description);\n    }\n\n    if (isJsonBoolean(type)) {\n        return removeNulls(JsonSchemaProperty.BOOLEAN, description);\n    }\n\n    if (isJsonInteger(type)) {\n        return removeNulls(JsonSchemaProperty.INTEGER, description);\n    }\n\n    if (isJsonNumber(type)) {\n        return removeNulls(JsonSchemaProperty.NUMBER, description);\n    }\n\n    if (type.isArray()) {\n        // Handle array type here\n    }\n\n    return removeNulls(schema(type), description);\n}\n```\n", "```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    Class<?> type = parameter.getType();\n    JsonSchemaProperty description = parameter.getDescription();\n\n    if (type == String.class) {\n        return removeNulls(STRING, description);\n    }\n\n    if (isJsonBoolean(type)) {\n        return removeNulls(BOOLEAN, description);\n    }\n\n    if (isJsonInteger(type)) {\n        return removeNulls(INTEGER, description);\n    }\n\n    if (isJsonNumber(type)) {\n        return removeNulls(NUMBER, description);\n    }\n\n    if (type.isArray()) {\n        // handle array conversion here\n    }\n\n    return removeNulls(schema(type), description);\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Map<Content, Double> scores = new LinkedHashMap<>();\n        for (List<Content> singleListOfContent : listsOfContents) {\n            for (int i = 0; i < singleListOfContent.size(); i++) {\n                Content content = singleListOfContent.get(i);\n                double currentScore = scores.getOrDefault(content, 0.0);\n                int rank = i + 1;\n                double newScore = currentScore + 1.0 / (k + rank);\n                scores.put(content, newScore);\n            }\n        }\n\n        List<Content> fused = new ArrayList<>(scores.keySet());\n        fused.sort(Comparator.comparingDouble(scores::get).reversed());\n        return fused;\n    }\n}\n\n------------------------------\n------------------------------\n        float[] array = new float[vector.size()];\n        for (int i = 0; i < vector.size(); i++) {\n            array[i] = vector.get(i);\n        }\n        return new Embedding(array);\n    }\n}\n\n------------------------------\n------------------------------\n    /**\n     * Creates a new Embedding from the given vector.\n     * @param vector the vector, takes ownership of the array.\n     * @return the new Embedding.\n     */\n    public static Embedding from(float[] vector) {\n        return new Embedding(vector);\n    }\n\n    /**\n     * Creates a new Embedding from the given vector.\n     * @param vector the vector.\n     * @return the new Embedding.\n     */\n    public static Embedding from(List<Float> vector) {\n        float[] array = new float[vector.size()];\n        for (int i = 0; i < vector.size(); i++) {\n            array[i] = vector.get(i);\n        }\n        return new Embedding(array);\n\n------------------------------\n------------------------------\n\n        List<Entry<Embedded>> newEntries = embeddings.stream()\n                .map(embedding -> new Entry<Embedded>(randomUUID(), embedding))\n                .collect(toList());\n\n        return add(newEntries);\n    }\n\n    @Override\n    public List<String> addAll(List<Embedding> embeddings, List<Embedded> embedded) {\n        if (embeddings.size() != embedded.size()) {\n            throw new IllegalArgumentException(\"The list of embeddings and embedded must have the same size\");\n        }\n\n        List<Entry<Embedded>> newEntries = IntStream.range(0, embeddings.size())\n                .mapToObj(i -> new Entry<>(randomUUID(), embeddings.get(i), embedded.get(i)))\n                .collect(toList());\n\n        return add(newEntries);\n    }\n\n------------------------------\n------------------------------\n    }\n\n    /**\n     * Normalize vector\n     */\n    public void normalize() {\n        double norm = 0.0;\n        for (float f : vector) {\n            norm += f * f;\n        }\n        norm = Math.sqrt(norm);\n\n        for (int i = 0; i < vector.length; i++) {\n            vector[i] /= norm;\n        }\n    }\n\n    /**\n     * Returns the dimension of the vector.\n     * @return the dimension of the vector.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double between(Embedding embeddingA, Embedding embeddingB) {\n# Natural Language Annotations: /**\n     * Calculates cosine similarity between two vectors.\n     * <p>\n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n    for (int i = 0; i < embeddingA.vector.length; i++) {\n        dotProduct += embeddingA.vector[i] * embeddingB.vector[i];\n        normA += embeddingA.vector[i] * embeddingA.vector[i];\n        normB += embeddingB.vector[i] * embeddingB.vector[i];\n    }\n    return dotProduct / Math.sqrt(normA * normB);\n}\n```\n", "```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n    for (int i = 0; i < embeddingA.vector.length; i++) {\n        dotProduct += embeddingA.vector[i] * embeddingB.vector[i];\n        normA += embeddingA.vector[i] * embeddingA.vector[i];\n        normB += embeddingB.vector[i] * embeddingB.vector[i];\n    }\n    return dotProduct / Math.sqrt(normA * normB);\n}\n```\n", "```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n\n    float[] vectorA = embeddingA.getVector();\n    float[] vectorB = embeddingB.getVector();\n\n    for (int i = 0; i < vectorA.length; i++) {\n        dotProduct += vectorA[i] * vectorB[i];\n        normA += vectorA[i] * vectorA[i];\n        normB += vectorB[i] * vectorB[i];\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    private static Map<String, Object> toMap(String arguments) {\n        try {\n            return new ObjectMapper().readValue(arguments, new TypeReference<Map<String, Object>>() {\n            });\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n    /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     */\n    public Map<String, Object> toMap() {\n        return new HashMap<>(metadata);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Metadata that = (Metadata) o;\n\n------------------------------\n------------------------------\n    }\n\n    public String description() {\n        return description;\n    }\n\n    public Map<String, JsonSchemaElement> properties() {\n        return properties;\n    }\n\n    public List<String> required() {\n        return required;\n    }\n\n    public Boolean additionalProperties() {\n        return additionalProperties;\n    }\n\n    public static Builder builder() {\n        return new Builder();\n\n------------------------------\n------------------------------\n     */\n    public Map<Object, Object> attributes() {\n        return attributes;\n    }\n}\n\n------------------------------\n------------------------------\n     */\n    public static WebSearchOrganicResult from(String title, URI url, String snippet, String content, Map<String, String> metadata) {\n        return new WebSearchOrganicResult(title, url, snippet, content, metadata);\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public Map<String, String> asMap() {\n# Natural Language Annotations: /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> map = new HashMap<>();\n    for (Map.Entry<String, Object> entry : metadata.entrySet()) {\n        if (entry.getValue() instanceof String) {\n            map.put(entry.getKey(), (String) entry.getValue());\n        }\n    }\n    return map;\n}\n```\n", "```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> map = new HashMap<>();\n    for (Map.Entry<String, Object> entry : metadata.entrySet()) {\n        if (entry.getValue() instanceof String) {\n            map.put(entry.getKey(), (String) entry.getValue());\n        }\n    }\n    return map;\n}\n```\n", "```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> result = new HashMap<>();\n    for (Map.Entry<String, Object> entry : metadata.entrySet()) {\n        if (entry.getValue() instanceof String) {\n            result.put(entry.getKey(), (String) entry.getValue());\n        }\n    }\n    return result;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocuments(Path directoryPath,\n                                               PathMatcher pathMatcher,\n                                               DocumentParser documentParser) {\n        if (!isDirectory(directoryPath)) {\n            throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n        }\n\n        try (Stream<Path> pathStream = Files.list(directoryPath)) {\n            return loadDocuments(pathStream, pathMatcher, directoryPath, documentParser);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Loads matching {@link Document}s from the specified directory. Does not use recursion.\n\n------------------------------\n------------------------------\n\n    private static Map<String, Object> toMap(String arguments) {\n        try {\n            return new ObjectMapper().readValue(arguments, new TypeReference<Map<String, Object>>() {\n            });\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n     */\n    public static Document load(String url, DocumentParser documentParser) {\n        return load(createUrl(url), documentParser);\n    }\n\n    /**\n     * Creates a URL from the specified string.\n     * @param url The URL string.\n     * @return the URL\n     * @throws IllegalArgumentException If specified URL is malformed.\n     */\n    static URL createUrl(String url) {\n        try {\n            return new URL(url);\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n        } catch (BlankDocumentException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n\n    public static UrlSource from(URI uri) {\n        try {\n            return new UrlSource(uri.toURL());\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Document load(DocumentSource source, DocumentParser parser) {\n# Natural Language Annotations: /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    try {\n        String documentText = source.getText();\n        Document document = parser.parse(documentText);\n\n        if (document.getText().trim().isEmpty()) {\n            throw new BlankDocumentException(\"Parsed document is blank/empty\");\n        }\n\n        document.setMetadata(source.getMetadata());\n        return document;\n    } catch (BlankDocumentException e) {\n        throw e;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    try {\n        String text = source.getText();\n        Document document = parser.parse(text);\n\n        if (isBlank(document)) {\n            throw new BlankDocumentException(\"The parsed Document is blank/empty\");\n        }\n\n        document.setMetadata(source.getMetadata());\n\n        return document;\n    } catch (BlankDocumentException e) {\n        throw e;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    try {\n        String content = source.getContent();\n        String title = parser.parseTitle(content);\n        String body = parser.parseBody(content);\n\n        Document document = new Document(title, body);\n        document.setMetadata(source.getMetadata());\n\n        if (body.isEmpty()) {\n            throw new BlankDocumentException(\"Document body is blank/empty\");\n        }\n\n        return document;\n    } catch (BlankDocumentException e) {\n        throw e;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return Response.from(AiMessage.from(staticResponse));\n    }\n\n    public String userMessageText() {\n        if (requests.size() != 1) {\n            throw runtime(\"Expected exactly 1 request, got: \" + requests.size());\n        }\n\n        List<ChatMessage> messages = requests.get(0);\n        if (messages.size() != 1) {\n            throw runtime(\"Expected exactly 1 message, got: \" + messages.size());\n        }\n\n        ChatMessage message = messages.get(0);\n        if (!(message instanceof UserMessage)) {\n            throw runtime(\"Expected exactly UserMessage, got: \" + message);\n        }\n\n        return message.text();\n    }\n\n------------------------------\n------------------------------\n    public static Moderation flagged(String flaggedText) {\n        return new Moderation(flaggedText);\n    }\n\n    /**\n     * Constructs a Moderation object that is not flagged.\n     * @return a Moderation object.\n     */\n    public static Moderation notFlagged() {\n        return new Moderation();\n    }\n}\n\n------------------------------\n------------------------------\n     */\n    public boolean hasSingleText() {\n        return contents.size() == 1 && contents.get(0) instanceof TextContent;\n    }\n\n    /**\n     * {@link UserMessage} can contain not just a single {@code String text}, but also multiple {@link Content}s,\n     * which can be either {@link TextContent} or {@link ImageContent}.\n     * Therefore, this method is deprecated. Please use {@link #singleText()} if you only expect a single text,\n     * or use {@link #contents()} otherwise.\n     *\n     * @deprecated Use {@link #singleText()} or {@link #contents()} instead.\n     */\n    @Deprecated\n    public String text() {\n        return singleText();\n    }\n\n    @Override\n    public ChatMessageType type() {\n\n------------------------------\n------------------------------\n    /**\n     * The contents of the message. {@link Content} can be either {@link TextContent} or {@link ImageContent}.\n     *\n     * @return the contents.\n     */\n    public List<Content> contents() {\n        return contents;\n    }\n\n    /**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\n\n\n\n------------------------------\n------------------------------\n     * @return a single text.\n     * @see #hasSingleText()\n     */\n\n\n\n\n\n\n\n\n    /**\n     * Whether this message contains a single {@link TextContent}.\n     *\n     * @return {@code true} if this message contains a single {@link TextContent}, {@code false} otherwise.\n     */\n    public boolean hasSingleText() {\n        return contents.size() == 1 && contents.get(0) instanceof TextContent;\n    }\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String singleText() {\n# Natural Language Annotations: /**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"Expected exactly 1 TextContent, got: \" + contents.size());\n    }\n    return ((TextContent) contents.get(0)).text();\n}\n```\n", "```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"Expected a single TextContent, got: \" + contents.size());\n    }\n    return ((TextContent) contents.get(0)).text();\n}\n```\n", "```java\npublic String singleText() {\n    if (contents.size() != 1 || !(contents.get(0) instanceof TextContent)) {\n        throw new RuntimeException(\"Expected exactly 1 TextContent, got: \" + contents.size());\n    }\n    TextContent textContent = (TextContent) contents.get(0);\n    return textContent.getText();\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        public Builder responseFormat(ResponseFormat responseFormat) {\n            this.responseFormat = responseFormat;\n            return this;\n        }\n\n        public ChatRequest build() {\n            return new ChatRequest(this);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n                                .build()\n                )\n                // TODO add more models\n        );\n    }\n}\n\n------------------------------\n------------------------------\n    private UserMessage augment(UserMessage userMessage) {\n        Metadata metadata = Metadata.from(userMessage, chatMemory.id(), chatMemory.messages());\n\n        AugmentationRequest augmentationRequest = new AugmentationRequest(userMessage, metadata);\n\n        AugmentationResult augmentationResult = retrievalAugmentor.augment(augmentationRequest);\n\n        return (UserMessage) augmentationResult.chatMessage();\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n\n        private ChatLanguageModel chatLanguageModel;\n        private ChatMemory chatMemory;\n        private RetrievalAugmentor retrievalAugmentor;\n\n\n------------------------------\n------------------------------\n    /**\n     * Augments the provided {@link UserMessage} with retrieved content.\n     *\n     * @param userMessage The {@link UserMessage} to be augmented.\n     * @param metadata    The {@link Metadata} that may be useful or necessary for retrieval and augmentation.\n     * @return The augmented {@link UserMessage}.\n     * @deprecated Use/implement {@link #augment(AugmentationRequest)} instead.\n     */\n    @Deprecated\n    UserMessage augment(UserMessage userMessage, Metadata metadata);\n}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    @Override\n    public AugmentationResult augment(AugmentationRequest augmentationRequest) {\n\n        ChatMessage chatMessage = augmentationRequest.chatMessage();\n        Metadata metadata = augmentationRequest.metadata();\n\n        Query originalQuery = Query.from(chatMessage.text(), metadata);\n\n        Collection<Query> queries = queryTransformer.transform(originalQuery);\n        logQueries(originalQuery, queries);\n\n        Map<Query, Collection<List<Content>>> queryToContents = process(queries);\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default AugmentationResult augment(AugmentationRequest augmentationRequest) {\n# Natural Language Annotations: /**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n     * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\ndefault AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    ChatMessage chatMessage = augmentationRequest.chatMessage();\n    Metadata metadata = augmentationRequest.metadata();\n\n    Query originalQuery = Query.from(chatMessage.text(), metadata);\n\n    Collection<Query> queries = queryTransformer.transform(originalQuery);\n    logQueries(originalQuery, queries);\n\n    Map<Query, Collection<List<Content>>> queryToContents = process(queries);\n\n    // rest of the implementation...\n}\n```\n", "```java\ndefault AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    ChatMessage chatMessage = augmentationRequest.chatMessage();\n    Metadata metadata = augmentationRequest.metadata();\n\n    Query originalQuery = Query.from(chatMessage.text(), metadata);\n\n    Collection<Query> queries = queryTransformer.transform(originalQuery);\n    logQueries(originalQuery, queries);\n\n    Map<Query, Collection<List<Content>>> queryToContents = process(queries);\n\n    // Continue with the implementation\n    // ...\n}\n```\n", "```java\ndefault AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    ChatMessage chatMessage = augmentationRequest.chatMessage();\n    Metadata metadata = augmentationRequest.metadata();\n\n    Query originalQuery = Query.from(chatMessage.text(), metadata);\n\n    Collection<Query> queries = queryTransformer.transform(originalQuery);\n    logQueries(originalQuery, queries);\n\n    Map<Query, Collection<List<Content>>> queryToContents = process(queries);\n    \n    // ... implementation details omitted ...\n    \n    return new AugmentationResult(augmentedChatMessage);\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return from(key, value);\n    }\n\n    /**\n     * @param key   the key\n     * @param value the value\n     * @return a Metadata object\n     * @deprecated Use {@link #metadata(String, String)} instead\n     */\n    @Deprecated\n    public static Metadata metadata(String key, Object value) {\n        return from(key, value);\n    }\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public String execute(String query) {\n\n        UserMessage userMessage = UserMessage.from(query);\n        userMessage = augment(userMessage);\n        chatMemory.add(userMessage);\n\n        AiMessage aiMessage = chatLanguageModel.generate(chatMemory.messages()).content();\n\n        chatMemory.add(aiMessage);\n        return aiMessage.text();\n    }\n\n    private UserMessage augment(UserMessage userMessage) {\n        Metadata metadata = Metadata.from(userMessage, chatMemory.id(), chatMemory.messages());\n\n        AugmentationRequest augmentationRequest = new AugmentationRequest(userMessage, metadata);\n\n\n------------------------------\n------------------------------\n     * @return the {@link UserMessage}.\n     */\n    public static UserMessage userMessage(String name, List<Content> contents) {\n        return from(name, contents);\n    }\n}\n\n------------------------------\n------------------------------\n    /**\n     * Augments the provided {@link UserMessage} with retrieved content.\n     *\n     * @param userMessage The {@link UserMessage} to be augmented.\n     * @param metadata    The {@link Metadata} that may be useful or necessary for retrieval and augmentation.\n     * @return The augmented {@link UserMessage}.\n     * @deprecated Use/implement {@link #augment(AugmentationRequest)} instead.\n     */\n    @Deprecated\n    UserMessage augment(UserMessage userMessage, Metadata metadata);\n}\n\n------------------------------\n------------------------------\n\n    public ChatMessage chatMessage() {\n        return chatMessage;\n    }\n\n    public Metadata metadata() {\n        return metadata;\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    @Deprecated    public UserMessage augment(UserMessage userMessage, Metadata metadata) {\n# Natural Language Annotations: /**\n     * @deprecated use {@link #augment(AugmentationRequest)} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Your code here\n}\n```\n", "```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Your code here\n}\n```\n", "```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Your implementation here\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        ChatMessage chatMessage = GSON.fromJson(messageJsonElement, chatMessageType.messageClass());\n        if (chatMessage instanceof UserMessage && ((UserMessage) chatMessage).contents() == null) {\n            // keeping backward compatibility with old schema TODO remove after a few releases\n            chatMessage = UserMessage.from(messageJsonElement.getAsJsonObject().get(\"text\").getAsString());\n        }\n        return chatMessage;\n    }\n}\n------------------------------\n------------------------------\n    }\n\n    public ChatMessage chatMessage() {\n        return chatMessage;\n    }\n\n    public List<Content> contents() {\n        return contents;\n    }\n}\n\n------------------------------\n------------------------------\n    public DefaultContentInjector(List<String> metadataKeysToInclude) {\n        this(DEFAULT_PROMPT_TEMPLATE, ensureNotEmpty(metadataKeysToInclude, \"metadataKeysToInclude\"));\n    }\n\n    public DefaultContentInjector(PromptTemplate promptTemplate) {\n        this(ensureNotNull(promptTemplate, \"promptTemplate\"), null);\n    }\n\n    @Builder\n    public DefaultContentInjector(PromptTemplate promptTemplate, List<String> metadataKeysToInclude) {\n        this.promptTemplate = getOrDefault(promptTemplate, DEFAULT_PROMPT_TEMPLATE);\n        this.metadataKeysToInclude = copyIfNotNull(metadataKeysToInclude);\n    }\n\n    @Override\n    public ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n\n        if (contents.isEmpty()) {\n            return chatMessage;\n        }\n\n------------------------------\n------------------------------\n    public ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n\n        if (contents.isEmpty()) {\n            return chatMessage;\n        }\n\n        Prompt prompt = createPrompt(chatMessage, contents);\n        if (chatMessage instanceof UserMessage && isNotNullOrBlank(((UserMessage)chatMessage).name())) {\n            return prompt.toUserMessage(((UserMessage)chatMessage).name());\n        }\n\n        return prompt.toUserMessage();\n    }\n\n    protected Prompt createPrompt(ChatMessage chatMessage, List<Content> contents) {\n        return createPrompt((UserMessage) chatMessage, contents);\n    }\n\n    /**\n     * @deprecated use {@link #inject(List, ChatMessage)} instead.\n\n------------------------------\n------------------------------\n        return createPrompt((UserMessage) chatMessage, contents);\n    }\n\n    /**\n     * @deprecated use {@link #inject(List, ChatMessage)} instead.\n     */\n    @Override\n    @Deprecated\n    public UserMessage inject(List<Content> contents, UserMessage userMessage) {\n\n        if (contents.isEmpty()) {\n            return userMessage;\n        }\n\n        Prompt prompt = createPrompt(userMessage, contents);\n        if (isNotNullOrBlank(userMessage.name())) {\n            return prompt.toUserMessage(userMessage.name());\n        }\n        return prompt.toUserMessage();\n    }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n# Natural Language Annotations: /**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n     *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\ndefault ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    if (contents.isEmpty()) {\n        return chatMessage;\n    }\n\n    Prompt prompt = createPrompt(chatMessage, contents);\n    if (chatMessage instanceof UserMessage && isNotNullOrBlank(((UserMessage)chatMessage).name())) {\n        return prompt.toUserMessage(((UserMessage)chatMessage).name());\n    }\n\n    return prompt.toUserMessage();\n}\n```\n", "```java\ndefault ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    if (contents.isEmpty()) {\n        return chatMessage;\n    }\n\n    Prompt prompt = createPrompt(chatMessage, contents);\n    if (chatMessage instanceof UserMessage && isNotNullOrBlank(((UserMessage)chatMessage).name())) {\n        return prompt.toUserMessage(((UserMessage)chatMessage).name());\n    }\n\n    return prompt.toUserMessage();\n}\n```\n", "```java\npublic ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n\n    if (contents.isEmpty()) {\n        return chatMessage;\n    }\n\n    if (chatMessage instanceof UserMessage && ((UserMessage) chatMessage).contents() == null) {\n        // keeping backward compatibility with old schema TODO remove after a few releases\n        chatMessage = UserMessage.from(chatMessage.toString());\n    }\n\n    Prompt prompt = createPrompt(chatMessage, contents);\n    if (chatMessage instanceof UserMessage && ((UserMessage)chatMessage).name() != null) {\n        return prompt.toUserMessage(((UserMessage)chatMessage).name());\n    }\n\n    return prompt.toUserMessage();\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    return value != null ? value : defaultValueSupplier.get();\n  }\n\n  /**\n   * Is the given string {@code null} or blank?\n   * @param string The string to check.\n   * @return true if the string is {@code null} or blank.\n   */\n  public static boolean isNullOrBlank(String string) {\n    return string == null || string.trim().isEmpty();\n  }\n\n  /**\n   * Is the given string {@code null} or empty (\"\")?\n   * @param string The string to check.\n   * @return true if the string is {@code null} or empty.\n   */\n  public static boolean isNullOrEmpty(String string) {\n    return string == null || string.isEmpty();\n  }\n\n------------------------------\n------------------------------\n\n        public Builder description(String description) {\n            this.description = description;\n            return this;\n        }\n\n        public JsonStringSchema build() {\n            return new JsonStringSchema(this);\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        JsonStringSchema that = (JsonStringSchema) o;\n        return Objects.equals(this.description, that.description);\n    }\n\n    @Override\n\n------------------------------\n------------------------------\n    }\n\n    public String key() {\n        return key;\n    }\n\n    public Collection<?> comparisonValues() {\n        return comparisonValues;\n    }\n\n    @Override\n    public boolean test(Object object) {\n        if (!(object instanceof Metadata)) {\n            return false;\n        }\n\n        Metadata metadata = (Metadata) object;\n        if (!metadata.containsKey(key)) {\n            return true;\n        }\n\n------------------------------\n------------------------------\n  /**\n   * Is the given string not {@code null} and not empty (\"\")?\n   * @param string The string to check.\n   * @return true if the given string is not {@code null} and not empty (\"\")?\n   */\n  public static boolean isNotNullOrEmpty(String string) {\n    return !isNullOrEmpty(string);\n  }\n\n  /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n   * @return true if the string is {@code null} or empty.\n   */\n  public static boolean isNullOrEmpty(String string) {\n    return string == null || string.isEmpty();\n  }\n\n  /**\n   * Is the given string not {@code null} and not blank?\n   * @param string The string to check.\n   * @return true if there's something in the string.\n   */\n  public static boolean isNotNullOrBlank(String string) {\n    return !isNullOrBlank(string);\n  }\n\n  /**\n   * Is the given string not {@code null} and not empty (\"\")?\n   * @param string The string to check.\n   * @return true if the given string is not {@code null} and not empty (\"\")?\n   */\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static boolean areNotNullOrBlank(String... strings) {\n# Natural Language Annotations: /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (isNullOrBlank(string)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n", "```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (isNullOrBlank(string)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n", "```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (isNullOrBlank(string)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    public JsonIntegerSchema(Builder builder) {\n        this.description = builder.description;\n    }\n\n    public String description() {\n        return description;\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n\n        private String description;\n\n        public Builder description(String description) {\n            this.description = description;\n            return this;\n        }\n\n------------------------------\n------------------------------\npublic class UrlSource implements DocumentSource {\n\n    private final URL url;\n\n    public UrlSource(URL url) {\n        this.url = ensureNotNull(url, \"url\");\n    }\n\n    @Override\n    public InputStream inputStream() throws IOException {\n        URLConnection connection = url.openConnection();\n        return connection.getInputStream();\n    }\n\n    @Override\n    public Metadata metadata() {\n        return Metadata.from(Document.URL, url.toString());\n    }\n\n    public static UrlSource from(String url) {\n\n------------------------------\n------------------------------\n\n    public static class Builder {\n\n        private String name;\n        private JsonObjectSchema schema;\n\n        public Builder name(String name) {\n            this.name = name;\n            return this;\n        }\n\n        public Builder schema(JsonObjectSchema schema) {\n            this.schema = schema;\n            return this;\n        }\n\n        public JsonSchema build() {\n            return new JsonSchema(this);\n        }\n    }\n\n------------------------------\n------------------------------\n    private static UUID toUUID(Object actualUUID) {\n        if (actualUUID instanceof String) {\n            return UUID.fromString(actualUUID.toString());\n        } else if (actualUUID instanceof UUID) {\n            return (UUID)actualUUID;\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + actualUUID.getClass().getName());\n    }\n}\n\n------------------------------\n------------------------------\n\n    public List<String> enumValues() {\n        return enumValues;\n    }\n\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    public static class Builder {\n\n        private String description;\n        private List<String> enumValues;\n\n        public Builder description(String description) {\n            this.description = description;\n            return this;\n        }\n\n        public Builder enumValues(List<String> enumValues) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String generateUUIDFrom(String input) {\n# Natural Language Annotations: /**\n   * Generates a UUID from a hash of the given input string.\n   * @param input The input string.\n   * @return A UUID.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest md = null;\n    try {\n        md = MessageDigest.getInstance(\"SHA-256\");\n    } catch (NoSuchAlgorithmException e) {\n        e.printStackTrace();\n    }\n    byte[] hash = md.digest(input.getBytes(StandardCharsets.UTF_8));\n    UUID uuid = UUID.nameUUIDFromBytes(hash);\n    return uuid.toString();\n}\n```\n", "```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest md;\n    try {\n        md = MessageDigest.getInstance(\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n    byte[] bytesOfMessage = input.getBytes();\n    byte[] theDigest = md.digest(bytesOfMessage);\n    return new UUID(theDigest).toString();\n}\n```\n", "```java\nprivate static final MessageDigest md;\nstatic {\n    try {\n        md = MessageDigest.getInstance(\"MD5\");\n    } catch (NoSuchAlgorithmException e) {\n        throw new RuntimeException(e);\n    }\n}\n\npublic static String generateUUIDFrom(String input) {\n    byte[] hash = md.digest(input.getBytes(StandardCharsets.UTF_8));\n    UUID uuid = UUID.nameUUIDFromBytes(hash);\n    return uuid.toString();\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     */\n    public static Document load(String url, DocumentParser documentParser) {\n        return load(createUrl(url), documentParser);\n    }\n\n    /**\n     * Creates a URL from the specified string.\n     * @param url The URL string.\n     * @return the URL\n     * @throws IllegalArgumentException If specified URL is malformed.\n     */\n    static URL createUrl(String url) {\n        try {\n            return new URL(url);\n        } catch (MalformedURLException e) {\n            throw new IllegalArgumentException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n\n    private static Map<String, Object> toMap(String arguments) {\n        try {\n            return new ObjectMapper().readValue(arguments, new TypeReference<Map<String, Object>>() {\n            });\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n    public Metadata metadata() {\n        return Metadata.from(Document.URL, url.toString());\n    }\n\n    public static UrlSource from(String url) {\n        try {\n            return new UrlSource(new URL(url));\n        } catch (MalformedURLException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    public static UrlSource from(URL url) {\n        return new UrlSource(url);\n    }\n\n    public static UrlSource from(URI uri) {\n        try {\n            return new UrlSource(uri.toURL());\n        } catch (MalformedURLException e) {\n\n------------------------------\n------------------------------\n\n    private final Charset charset;\n\n    public TextDocumentParser() {\n        this(UTF_8);\n    }\n\n    public TextDocumentParser(Charset charset) {\n        this.charset = ensureNotNull(charset, \"charset\");\n    }\n\n    @Override\n    public Document parse(InputStream inputStream) {\n        // see https://stackoverflow.com/a/35446009\n        try {\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            int nRead;\n            byte[] data = new byte[1024];\n            while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n                buffer.write(data, 0, nRead);\n\n------------------------------\n------------------------------\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n            int nRead;\n            byte[] data = new byte[1024];\n            while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n                buffer.write(data, 0, nRead);\n            }\n            buffer.flush();\n\n            String text = new String(buffer.toByteArray(), charset);\n\n            if (isNullOrBlank(text)) {\n                throw new BlankDocumentException();\n            }\n\n            return Document.from(text);\n        } catch (BlankDocumentException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static byte[] readBytes(String url) {\n# Natural Language Annotations: /**\n   * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n   * and from files stored on the local filesystem.\n   *\n   * @param url The URL to read from.\n   * @return The content as bytes.\n   * @throws RuntimeException if the request fails.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static byte[] readBytes(String url) {\n    try {\n        URLConnection connection = createUrl(url).openConnection();\n        connection.connect();\n        try (InputStream inputStream = connection.getInputStream()) {\n            return IOUtils.toByteArray(inputStream);\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        URLConnection conn = urlObj.openConnection();\n\n        try (InputStream in = conn.getInputStream()) {\n            return in.readAllBytes();\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to read bytes from \" + url, e);\n    }\n}\n```\n", "```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        try (InputStream inputStream = urlObj.openStream()) {\n            return readBytesFromInputStream(inputStream);\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static byte[] readBytesFromInputStream(InputStream inputStream) throws IOException {\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n    int nRead;\n    byte[] data = new byte[1024];\n    while ((nRead = inputStream.read(data, 0, data.length)) != -1) {\n        buffer.write(data, 0, nRead);\n    }\n    buffer.flush();\n    return buffer.toByteArray();\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/ValidationUtils.java-ensureNotEmpty": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @param json the JSON string\n     * @return the corrected JSON string\n     */\n    static String removeTrailingComma(String json) {\n        if (json == null || json.isEmpty()) {\n            return json;\n        }\n        Matcher matcher = TRAILING_COMMA_PATTERN.matcher(json);\n        return matcher.replaceAll(\"$1\");\n    }\n}\n\n------------------------------\n------------------------------\n    private static UUID toUUID(Object actualUUID) {\n        if (actualUUID instanceof String) {\n            return UUID.fromString(actualUUID.toString());\n        } else if (actualUUID instanceof UUID) {\n            return (UUID)actualUUID;\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + actualUUID.getClass().getName());\n    }\n}\n\n------------------------------\n------------------------------\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n    public static long ensureBetween(Long i, long min, long max, String name) {\n        if (i == null || i < min || i > max) {\n            throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, i);\n        }\n        return i;\n    }\n}\n\n------------------------------\n------------------------------\n     * @param <K>  The type of the key.\n     * @param <V>  The type of the value.\n     * @return The map if it is not null and not empty.\n     * @throws IllegalArgumentException if the collection is null or empty.\n     */\n    public static <K, V> Map<K, V> ensureNotEmpty(Map<K, V> map, String name) {\n        if (map == null || map.isEmpty()) {\n            throw illegalArgument(\"%s cannot be null or empty\", name);\n        }\n\n        return map;\n    }\n\n    /**\n     * Ensures that the given string is not null and not blank.\n     * @param string The string to check.\n     * @param name The name of the string to be used in the exception message.\n     * @return The string if it is not null and not blank.\n     * @throws IllegalArgumentException if the string is null or blank.\n     */\n\n------------------------------\n------------------------------\n     * @param <T> The type of the object.\n     */\n    public static <T> T ensureNotNull(T object, String format, Object... args) {\n        if (object == null) {\n            throw illegalArgument(format, args);\n        }\n        return object;\n    }\n\n    /**\n     * Ensures that the given collection is not null and not empty.\n     * @param collection The collection to check.\n     * @param name The name of the collection to be used in the exception message.\n     * @return The collection if it is not null and not empty.\n     * @param <T> The type of the collection.\n     *           @throws IllegalArgumentException if the collection is null or empty.\n     */\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T extends Collection<?>> T ensureNotEmpty(T collection, String name) {\n# Natural Language Annotations: /**\n     * Ensures that the given collection is not null and not empty.\n     * @param collection The collection to check.\n     * @param name The name of the collection to be used in the exception message.\n     * @return The collection if it is not null and not empty.\n     * @param <T> The type of the collection.\n     *           @throws IllegalArgumentException if the collection is null or empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <T extends Collection<?>> T ensureNotEmpty(T collection, String name) {\n    if (collection == null || collection.isEmpty()) {\n        throw new IllegalArgumentException(name + \" cannot be null or empty\");\n    }\n    return collection;\n}\n```\n", "```java\npublic static <T extends Collection<?>> T ensureNotEmpty(T collection, String name) {\n    if (collection == null || collection.isEmpty()) {\n        throw new IllegalArgumentException(name + \" cannot be null or empty\");\n    }\n\n    return collection;\n}\n```\n", "```java\npublic static <T extends Collection<?>> T ensureNotEmpty(T collection, String name) {\n    if (collection == null || collection.isEmpty()) {\n        throw illegalArgument(\"%s cannot be null or empty\", name);\n    }\n\n    return collection;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/ValidationUtils.java-ensureNotBlank": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        private static String replaceAll(String template, String variable, Object value) {\n            if (value == null || value.toString() == null) {\n                throw illegalArgument(\"Value for the variable '%s' is null\", variable);\n            }\n            return template.replace(inDoubleCurlyBrackets(variable), value.toString());\n        }\n\n        private static String inDoubleCurlyBrackets(String variable) {\n            return \"{{\" + variable + \"}}\";\n        }\n    }\n}\n\n------------------------------\n------------------------------\n                throw illegalConfiguration(\"@%sMessage's resource '%s' not found\", type, resource);\n            }\n        } else {\n            messageTemplate = String.join(delimiter, value);\n        }\n        if (messageTemplate.trim().isEmpty()) {\n            throw illegalConfiguration(\"@%sMessage's template cannot be empty\", type);\n        }\n        return messageTemplate;\n    }\n\n    private static String getResourceText(Class<?> clazz, String resource) {\n        InputStream inputStream = clazz.getResourceAsStream(resource);\n        if (inputStream == null) {\n            inputStream = clazz.getResourceAsStream(\"/\" + resource);\n        }\n        return getText(inputStream);\n    }\n\n    private static String getText(InputStream inputStream) {\n\n------------------------------\n------------------------------\n     * @param <K>  The type of the key.\n     * @param <V>  The type of the value.\n     * @return The map if it is not null and not empty.\n     * @throws IllegalArgumentException if the collection is null or empty.\n     */\n    public static <K, V> Map<K, V> ensureNotEmpty(Map<K, V> map, String name) {\n        if (map == null || map.isEmpty()) {\n            throw illegalArgument(\"%s cannot be null or empty\", name);\n        }\n\n        return map;\n    }\n\n    /**\n     * Ensures that the given string is not null and not blank.\n     * @param string The string to check.\n     * @param name The name of the string to be used in the exception message.\n     * @return The string if it is not null and not blank.\n     * @throws IllegalArgumentException if the string is null or blank.\n     */\n\n------------------------------\n------------------------------\n     * @param json the JSON string\n     * @return the corrected JSON string\n     */\n    static String removeTrailingComma(String json) {\n        if (json == null || json.isEmpty()) {\n            return json;\n        }\n        Matcher matcher = TRAILING_COMMA_PATTERN.matcher(json);\n        return matcher.replaceAll(\"$1\");\n    }\n}\n\n------------------------------\n------------------------------\n    private static UUID toUUID(Object actualUUID) {\n        if (actualUUID instanceof String) {\n            return UUID.fromString(actualUUID.toString());\n        } else if (actualUUID instanceof UUID) {\n            return (UUID)actualUUID;\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + actualUUID.getClass().getName());\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String ensureNotBlank(String string, String name) {\n# Natural Language Annotations: /**\n     * Ensures that the given string is not null and not blank.\n     * @param string The string to check.\n     * @param name The name of the string to be used in the exception message.\n     * @return The string if it is not null and not blank.\n     * @throws IllegalArgumentException if the string is null or blank.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String ensureNotBlank(String string, String name) {\n    if (string == null || string.trim().isEmpty()) {\n        throw illegalArgument(\"%s cannot be null or blank\", name);\n    }\n    return string;\n}\n```\n", "```java\npublic static String ensureNotBlank(String string, String name) {\n    if (string == null || string.trim().isEmpty()) {\n        throw illegalArgument(\"%s cannot be null or blank\", name);\n    }\n\n    return string;\n}\n```\n", "```java\npublic static String ensureNotBlank(String string, String name) {\n    if (string == null || string.trim().isEmpty()) {\n        throw illegalArgument(\"%s cannot be null or blank\", name);\n    }\n\n    return string;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/ValidationUtils.java-ensureGreaterThanZero": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        for (EmbeddingModelFactory factory : factories) {\n            return factory.create();\n        }\n\n        return null;\n    }\n\n    public static class EmbeddingStoreContentRetrieverBuilder {\n\n        public EmbeddingStoreContentRetrieverBuilder maxResults(Integer maxResults) {\n            if (maxResults != null) {\n                dynamicMaxResults = (query) -> ensureGreaterThanZero(maxResults, \"maxResults\");\n            }\n            return this;\n        }\n\n        public EmbeddingStoreContentRetrieverBuilder minScore(Double minScore) {\n            if (minScore != null) {\n                dynamicMinScore = (query) -> ensureBetween(minScore, 0, 1, \"minScore\");\n\n------------------------------\n------------------------------\n            if (actualTypeArguments.length == 1) {\n                return (Class<?>) actualTypeArguments[0];\n            }\n        }\n        return null;\n    }\n}\n\n------------------------------\n------------------------------\n    private static UUID toUUID(Object actualUUID) {\n        if (actualUUID instanceof String) {\n            return UUID.fromString(actualUUID.toString());\n        } else if (actualUUID instanceof UUID) {\n            return (UUID)actualUUID;\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + actualUUID.getClass().getName());\n    }\n}\n\n------------------------------\n------------------------------\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n    public static int ensureBetween(Integer i, int min, int max, String name) {\n        if (i == null || i < min || i > max) {\n            throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, i);\n        }\n        return i;\n    }\n    /**\n     * Ensures that the given Long value is in {@code [min, max]}.\n     * @param i The value to check.\n     * @param min The minimum value.\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n\n------------------------------\n------------------------------\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n    public static long ensureBetween(Long i, long min, long max, String name) {\n        if (i == null || i < min || i > max) {\n            throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, i);\n        }\n        return i;\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static int ensureGreaterThanZero(Integer i, String name) {\n# Natural Language Annotations: /**\n     * Ensures that the given expression is true.\n     * @param i The expression to check.\n     * @param name The message to be used in the exception.\n     * @return The value if it is greater than zero.\n     * @throws IllegalArgumentException if the expression is false.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static int ensureGreaterThanZero(Integer i, String name) {\n    if (i == null || i <= 0) {\n        throw illegalArgument(\"%s must be greater than zero, but is: %s\", name, i);\n    }\n    return i;\n}\n```\n", "```java\n/**\n * Ensures that the given expression is true.\n * @param i The expression to check.\n * @param name The message to be used in the exception.\n * @return The value if it is greater than zero.\n * @throws IllegalArgumentException if the expression is false.\n */\npublic static int ensureGreaterThanZero(Integer i, String name) {\n    if (i == null || i <= 0) {\n        throw illegalArgument(\"%s must be greater than zero, but is: %s\", name, i);\n    }\n    return i;\n}\n```\n", "```java\n/**\n* Ensures that the given expression is true.\n* @param i The expression to check.\n* @param name The message to be used in the exception.\n* @return The value if it is greater than zero.\n* @throws IllegalArgumentException if the expression is false.\n*/\npublic static int ensureGreaterThanZero(Integer i, String name) {\n    if (i == null || i <= 0) {\n        throw illegalArgument(\"%s must be greater than zero, but is: %s\", name, i);\n    }\n    return i;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/ValidationUtils.java-ensureBetween": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        private static String replaceAll(String template, String variable, Object value) {\n            if (value == null || value.toString() == null) {\n                throw illegalArgument(\"Value for the variable '%s' is null\", variable);\n            }\n            return template.replace(inDoubleCurlyBrackets(variable), value.toString());\n        }\n\n        private static String inDoubleCurlyBrackets(String variable) {\n            return \"{{\" + variable + \"}}\";\n        }\n    }\n}\n\n------------------------------\n------------------------------\n     * @param <T> The type of the object.\n     */\n    public static <T> T ensureNotNull(T object, String format, Object... args) {\n        if (object == null) {\n            throw illegalArgument(format, args);\n        }\n        return object;\n    }\n\n    /**\n     * Ensures that the given collection is not null and not empty.\n     * @param collection The collection to check.\n     * @param name The name of the collection to be used in the exception message.\n     * @return The collection if it is not null and not empty.\n     * @param <T> The type of the collection.\n     *           @throws IllegalArgumentException if the collection is null or empty.\n     */\n\n\n\n\n------------------------------\n------------------------------\n    private static UUID toUUID(Object actualUUID) {\n        if (actualUUID instanceof String) {\n            return UUID.fromString(actualUUID.toString());\n        } else if (actualUUID instanceof UUID) {\n            return (UUID)actualUUID;\n        }\n\n        throw new IllegalArgumentException(\"Unsupported type: \" + actualUUID.getClass().getName());\n    }\n}\n\n------------------------------\n------------------------------\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n    public static int ensureBetween(Integer i, int min, int max, String name) {\n        if (i == null || i < min || i > max) {\n            throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, i);\n        }\n        return i;\n    }\n    /**\n     * Ensures that the given Long value is in {@code [min, max]}.\n     * @param i The value to check.\n     * @param min The minimum value.\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n\n------------------------------\n------------------------------\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\n    public static long ensureBetween(Long i, long min, long max, String name) {\n        if (i == null || i < min || i > max) {\n            throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, i);\n        }\n        return i;\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double ensureBetween(Double d, double min, double max, String name) {\n# Natural Language Annotations: /**\n     * Ensures that the given Double value is in {@code [min, max]}.\n     * @param d The value to check.\n     * @param min The minimum value.\n     * @param max The maximum value.\n     * @param name The value name to be used in the exception.\n     * @return The value if it is in {@code [min, max]}.\n     * @throws IllegalArgumentException if the value is not in {@code [min, max]}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static double ensureBetween(Double d, double min, double max, String name) {\n    if (d == null || d < min || d > max) {\n        throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, d);\n    }\n    return d;\n}\n```\n", "```java\npublic static double ensureBetween(Double d, double min, double max, String name) {\n    if (d == null || d < min || d > max) {\n        throw illegalArgument(\"%s must be between %s and %s, but is: %s\", name, min, max, d);\n    }\n    return d;\n}\n```\n", "```java\npublic static double ensureBetween(Double d, double min, double max, String name) {\n    if (d == null || d < min || d > max) {\n        throw new IllegalArgumentException(String.format(\"%s must be between %s and %s, but is: %s\", name, min, max, d));\n    }\n    return d;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n             * Sets the jitter scale.\n             *\n             * <p>The jitter delay in milliseconds is calculated as\n             * {@code rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale))}.\n             *\n             * @param jitterScale The jitter scale.\n             * @return {@code this}\n             */\n            public Builder jitterScale(double jitterScale) {\n                this.jitterScale = jitterScale;\n                return this;\n            }\n\n            /**\n             * Sets the backoff exponent.\n             * @param backoffExp The backoff exponent.\n             * @return {@code this}\n             */\n            public Builder backoffExp(double backoffExp) {\n                this.backoffExp = backoffExp;\n\n------------------------------\n------------------------------\n        public double rawDelayMs(int attempt) {\n            return ((double) delayMillis) * Math.pow(backoffExp, attempt - 1);\n        }\n\n        /**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\n\n\n\n\n\n\n\n        /**\n         * This method sleeps for a given attempt.\n         * @param attempt The attempt number.\n         */\n\n------------------------------\n------------------------------\n             * Sets the default maximum number of attempts.\n             * @param maxAttempts The maximum number of attempts.\n             * @return {@code this}\n             */\n            public Builder maxAttempts(int maxAttempts) {\n                this.maxAttempts = maxAttempts;\n                return this;\n            }\n\n            /**\n             * Sets the base delay in milliseconds.\n             *\n             * <p>The delay is calculated as follows:\n             * <ol>\n             *     <li>Calculate the raw delay in milliseconds as\n             *         {@code delayMillis * Math.pow(backoffExp, attempt - 1)}.</li>\n             *     <li>Calculate the jitter delay in milliseconds as\n             *         {@code rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale))}.</li>\n             *     <li>Sleep for the jitter delay in milliseconds.</li>\n             * </ol>\n\n------------------------------\n------------------------------\n             *         {@code delayMillis * Math.pow(backoffExp, attempt - 1)}.</li>\n             *     <li>Calculate the jitter delay in milliseconds as\n             *         {@code rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale))}.</li>\n             *     <li>Sleep for the jitter delay in milliseconds.</li>\n             * </ol>\n             *\n             * @param delayMillis The delay in milliseconds.\n             * @return {@code this}\n             */\n            public Builder delayMillis(int delayMillis) {\n                this.delayMillis = delayMillis;\n                return this;\n            }\n\n            /**\n             * Sets the jitter scale.\n             *\n             * <p>The jitter delay in milliseconds is calculated as\n             * {@code rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale))}.\n             *\n\n------------------------------\n------------------------------\n                int maxAttempts,\n                int delayMillis,\n                double jitterScale,\n                double backoffExp) {\n            this.maxAttempts = maxAttempts;\n            this.delayMillis = delayMillis;\n            this.jitterScale = jitterScale;\n            this.backoffExp = backoffExp;\n        }\n\n        /**\n         * This method returns the raw delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The raw delay in milliseconds.\n         */\n        public double rawDelayMs(int attempt) {\n            return ((double) delayMillis) * Math.pow(backoffExp, attempt - 1);\n        }\n\n        /**\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int jitterDelayMillis(int attempt) {\n# Natural Language Annotations: /**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelayMs = rawDelayMs(attempt);\n    int jitterDelayMs = (int) (rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale)));\n    return jitterDelayMs;\n}\n```\n", "```java\npublic int jitterDelayMillis(int attempt) {\n    Random rand = new Random();\n    double rawDelayMs = rawDelayMs(attempt);\n    return (int) (rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale)));\n}\n```\n", "```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelayMs = rawDelayMs(attempt);\n    int jitterDelay = (int) (rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale)));\n    return jitterDelay;\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @return key \u6570\u7ec4\n     */\n    @Override\n    public String[] getKeyColumnNames() {\n        return autoKeyGeneratorNames.toArray(new String[0]);\n    }\n\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public R groupBy(String name) {\n        super.groupBy(name);\n        return (R) this;\n    }\n\n    @Override\n    public R groupBy(String... names) {\n        super.groupBy(names);\n        return (R) this;\n    }\n\n    @Override\n    public R groupBy(QueryColumn column) {\n        super.groupBy(column);\n        return (R) this;\n    }\n\n    @Override\n\n------------------------------\n------------------------------\n    public static boolean isObjectMethod(String methodName) {\n        return ArrayUtil.contains(OBJECT_METHODS, methodName);\n    }\n\n}\n\n------------------------------\n------------------------------\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\n\n\n\n\n\n\n\n\n    /**\n     * \u6ce8\u518c\u4e00\u4e2a\u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param key\n     * @param keyGenerator\n     */\n    public static void register(String key, IKeyGenerator keyGenerator) {\n\n------------------------------\n------------------------------\n     *\n     * @param key\n     * @param keyGenerator\n     */\n    public static void register(String key, IKeyGenerator keyGenerator) {\n        KEY_GENERATOR_MAP.put(key.trim(), keyGenerator);\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static IKeyGenerator getKeyGenerator(String name) {\n# Natural Language Annotations: /**\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return KEY_GENERATOR_MAP.get(name.trim());\n}\n```\n", "```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return KEY_GENERATOR_MAP.get(name.trim());\n}\n```\n", "```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return KEY_GENERATOR_MAP.get(name);\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                if (joinValue != null) {\n                    return joinValue.toString();\n                }\n            }\n        }\n        return null;\n    }\n\n}\n\n------------------------------\n------------------------------\n        this.value = value;\n    }\n\n    @Override\n    public String toString() {\n        return value;\n    }\n}\n\n------------------------------\n------------------------------\n\n    public void setMaskType(String maskType) {\n        this.maskType = maskType;\n    }\n\n\n    public boolean isIgnore() {\n        return ignore;\n    }\n\n    public void setIgnore(boolean ignore) {\n        this.ignore = ignore;\n    }\n}\n\n------------------------------\n------------------------------\n\n    Propagation(int value) {\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = value;\n    }\n}\n\n------------------------------\n------------------------------\n     *\n     * @param fn \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\n    public QueryCondition when(BooleanSupplier fn) {\n        if (notEmpty()) {\n            this.effective = fn.getAsBoolean();\n        }\n        return this;\n    }\n\n    public boolean checkEffective() {\n        return effective;\n    }\n\n\n    public QueryCondition and(String sql) {\n        return and(new RawQueryCondition(sql));\n    }\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public QueryCondition when(boolean effective) {\n# Natural Language Annotations: /**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic QueryCondition when(boolean effective) {\n    if (notEmpty()) {\n        this.effective = effective;\n    }\n    return this;\n}\n```\n", "```java\npublic QueryCondition when(boolean effective) {\n    if (notEmpty()) {\n        this.effective = effective;\n    }\n    return this;\n}\n```\n", "```java\npublic QueryCondition when(boolean effective) {\n    this.effective = effective;\n    return this;\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n            if (getter == null) {\n                if (Modifier.isPublic(enumValueField.getModifiers())) {\n                    property = enumValueField;\n                } else {\n                    throw new IllegalStateException(\"Can not find method \\\"\" + getterMethodName + \"()\\\" in enum: \" + enumClass.getName());\n                }\n            } else {\n                this.getterMethod = getter;\n            }\n        }\n\n        if (!hasEnumValueAnnotation) {\n            Method enumValueMethod = ClassUtil.getFirstMethod(enumClass, method -> method.getAnnotation(EnumValue.class) != null);\n            if (enumValueMethod != null) {\n                String methodName = enumValueMethod.getName();\n                if (!(methodName.startsWith(\"get\") && methodName.length() > 3)) {\n                    throw new IllegalStateException(\"Can not find get method \\\"\" + methodName + \"()\\\" in enum: \" + enumClass.getName());\n                }\n                this.getterMethod = enumValueMethod;\n\n------------------------------\n------------------------------\n                } catch (SQLException e) {\n                    throw new ExecutorException(\n                        \"Error getting nested result map values for '\" + resultMapping.getProperty() + \"'.  Cause: \" + e, e);\n                }\n            }\n        }\n        return foundValues;\n    }\n\n    private String getColumnPrefix(String parentPrefix, ResultMapping resultMapping) {\n        final StringBuilder columnPrefixBuilder = new StringBuilder();\n        if (parentPrefix != null) {\n            columnPrefixBuilder.append(parentPrefix);\n        }\n        if (resultMapping.getColumnPrefix() != null) {\n            columnPrefixBuilder.append(resultMapping.getColumnPrefix());\n        }\n        return columnPrefixBuilder.length() == 0 ? null : columnPrefixBuilder.toString().toUpperCase(Locale.ENGLISH);\n    }\n\n\n------------------------------\n------------------------------\n                return mask(address, 6, 0, 3);\n            } else if (address.length() > 3) {\n                return mask(address, 3, 0, 3);\n            }\n        }\n        return data;\n    };\n\n\n    /**\n     * email \u8131\u654f\n     */\n    static MaskProcessor EMAIL_PROCESSOR = data -> {\n        if (data instanceof String && ((String) data).contains(\"@\")) {\n            String fullEmail = (String) data;\n            int indexOf = fullEmail.lastIndexOf(\"@\");\n            String email = fullEmail.substring(0, indexOf);\n\n            if (email.length() == 1) {\n                return \"*\" + fullEmail.substring(indexOf);\n\n------------------------------\n------------------------------\n    };\n\n\n    /**\n     * \u59d3\u540d\u8131\u654f\n     */\n    static MaskProcessor CHINESE_NAME_PROCESSOR = data -> {\n        if (data instanceof String) {\n            String name = (String) data;\n            if (name.length() == 2) {\n                return name.charAt(0) + \"*\";\n            } else if (name.length() == 3) {\n                return name.charAt(0) + \"*\" + name.charAt(2);\n            } else if (name.length() == 4) {\n                return \"**\" + name.substring(2, 4);\n            } else if (name.length() > 4) {\n                return mask(name, 2, 1, name.length() - 3);\n            }\n        }\n        return data;\n\n------------------------------\n------------------------------\n        return (Class<T>) proxyClass.getInterfaces()[0];\n    }\n\n\n    public static boolean isGetterMethod(Method method, String property) {\n        String methodName = method.getName();\n        if (methodName.startsWith(\"get\") && methodName.length() > 3) {\n            return StringUtil.firstCharToUpperCase(property).equals(methodName.substring(3));\n        } else if (methodName.startsWith(\"is\") && methodName.length() > 2) {\n            return StringUtil.firstCharToUpperCase(property).equals(methodName.substring(2));\n        } else {\n            return false;\n        }\n    }\n\n    public static boolean isObjectMethod(String methodName) {\n        return ArrayUtil.contains(OBJECT_METHODS, methodName);\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String methodToProperty(String name) {\n# Natural Language Annotations: /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        // No getter or setter method.\n        throw new ReflectionException(\"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n\n    return name;\n}\n```\n", "```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else {\n        if (!name.startsWith(\"get\") && !name.startsWith(\"set\")) {\n            throw new RuntimeException(\"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n        }\n        name = name.substring(3);\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n\n    return name;\n}\n```\n", "```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        // No property manipulation needed\n    }\n    if (name.length() > 1 && !Character.isUpperCase(name.charAt(1)) && name.charAt(0) == Character.toUpperCase(name.charAt(0))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n    return name;\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        }\n    }\n\n    public static String toHex(byte[] bytes) {\n        StringBuilder ret = new StringBuilder(bytes.length * 2);\n        for (byte b : bytes) {\n            ret.append(HEX_DIGITS[(b >> 4) & 0x0f]);\n            ret.append(HEX_DIGITS[b & 0x0f]);\n        }\n        return ret.toString();\n    }\n\n}\n\n------------------------------\n------------------------------\n            return new Date(((Timestamp) value).getTime());\n        }\n        if (value instanceof LocalDate) {\n            return DateUtil.toDate((LocalDate) value);\n        }\n        if (value instanceof LocalDateTime) {\n            return DateUtil.toDate((LocalDateTime) value);\n        }\n        if (value instanceof LocalTime) {\n            return DateUtil.toDate((LocalTime) value);\n        }\n        String s = value.toString();\n        if (StringUtil.isNumeric(s)) {\n            return new Date(Long.parseLong(s));\n        }\n        return DateUtil.parseDate(s);\n    }\n\n\n    public static Date parseDate(String dateString) {\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * \u5220\u9664\u5b57\u7b26\u4e32\u4e2d\u7684\u5b57\u7b26\n     */\n    public static String deleteChar(String string, char deleteChar) {\n        if (isBlank(string)) {\n            return \"\";\n        }\n        char[] chars = string.toCharArray();\n\n------------------------------\n------------------------------\n                    setInvoker.invoke(dataSourceObject, new Object[]{ConvertUtil.convert(value, setInvoker.getType())});\n                }\n            }\n        }\n    }\n\n\n    public static String attrToCamel(String string) {\n        int strLen = string.length();\n        StringBuilder sb = new StringBuilder(strLen);\n        for (int i = 0; i < strLen; i++) {\n            char c = string.charAt(i);\n            if (c == '-') {\n                if (++i < strLen) {\n                    sb.append(Character.toUpperCase(string.charAt(i)));\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n\n------------------------------\n------------------------------\n    public static String deleteChar(String string, char deleteChar) {\n        if (isBlank(string)) {\n            return \"\";\n        }\n        char[] chars = string.toCharArray();\n        StringBuilder sb = new StringBuilder(string.length());\n        for (char aChar : chars) {\n            if (aChar != deleteChar) {\n                sb.append(aChar);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String deleteChar(String string, char deleteChar1, char deleteChar2) {\n        if (isBlank(string)) {\n            return \"\";\n        }\n        char[] chars = string.toCharArray();\n        StringBuilder sb = new StringBuilder(string.length());\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String camelToUnderline(String string) {\n# Natural Language Annotations: /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String camelToUnderline(String string) {\n    int strLen = string.length();\n    StringBuilder sb = new StringBuilder(strLen);\n    for (int i = 0; i < strLen; i++) {\n        char c = string.charAt(i);\n        if (Character.isUpperCase(c)) {\n            sb.append(\"_\");\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String camelToUnderline(String string) {\n    if (isBlank(string)) {\n        return \"\";\n    }\n    char[] chars = string.toCharArray();\n    StringBuilder sb = new StringBuilder(string.length() + 1);\n    for (char aChar : chars) {\n        if (Character.isUpperCase(aChar)) {\n            sb.append('_');\n            sb.append(Character.toLowerCase(aChar));\n        } else {\n            sb.append(aChar);\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String camelToUnderline(String string) {\n    if (string == null || string.length() == 0) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    char[] chars = string.toCharArray();\n    for (char c : chars) {\n        if (Character.isUpperCase(c)) {\n            sb.append(\"_\").append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                    sql.append(EQUALS).append(rawValueMap.get(colName).toSql(this));\n                } else {\n                    sql.append(EQUALS_PLACEHOLDER);\n                }\n\n                index++;\n            }\n        }\n        sql.append(WHERE);\n        for (int i = 0; i < primaryKeys.length; i++) {\n            if (i > 0) {\n                sql.append(AND);\n            }\n            sql.append(wrap(primaryKeys[i])).append(EQUALS_PLACEHOLDER);\n        }\n        prepareAuth(schema, table, sql, OperateType.UPDATE);\n        return sql.toString();\n    }\n\n    @Override\n\n------------------------------\n------------------------------\n        }\n\n        if (primaryKeyStrings.length == 1) {\n            row.put(primaryKey.trim(), value);\n        } else {\n            Object[] values = (Object[]) value;\n            for (int i = 0; i < primaryKeyStrings.length; i++) {\n                row.put(primaryKeyStrings[i].trim(), values[i]);\n            }\n        }\n        return row;\n    }\n\n    public static Row ofKey(RowKey... rowKeys) {\n        Row row = new Row();\n        row.getPrimaryKeys().addAll(Arrays.asList(rowKeys));\n        return row;\n    }\n\n\n\n------------------------------\n------------------------------\n    public static String deleteChar(String string, char deleteChar) {\n        if (isBlank(string)) {\n            return \"\";\n        }\n        char[] chars = string.toCharArray();\n        StringBuilder sb = new StringBuilder(string.length());\n        for (char aChar : chars) {\n            if (aChar != deleteChar) {\n                sb.append(aChar);\n            }\n        }\n        return sb.toString();\n    }\n\n    public static String deleteChar(String string, char deleteChar1, char deleteChar2) {\n        if (isBlank(string)) {\n            return \"\";\n        }\n        char[] chars = string.toCharArray();\n        StringBuilder sb = new StringBuilder(string.length());\n\n------------------------------\n------------------------------\n                    setInvoker.invoke(dataSourceObject, new Object[]{ConvertUtil.convert(value, setInvoker.getType())});\n                }\n            }\n        }\n    }\n\n\n    public static String attrToCamel(String string) {\n        int strLen = string.length();\n        StringBuilder sb = new StringBuilder(strLen);\n        for (int i = 0; i < strLen; i++) {\n            char c = string.charAt(i);\n            if (c == '-') {\n                if (++i < strLen) {\n                    sb.append(Character.toUpperCase(string.charAt(i)));\n                }\n            } else {\n                sb.append(c);\n            }\n        }\n\n------------------------------\n------------------------------\n\n\n    public static String buildSqlParamPlaceholder(int count) {\n        StringBuilder sb = new StringBuilder(BRACKET_LEFT);\n        for (int i = 0; i < count; i++) {\n            sb.append(PLACEHOLDER);\n            if (i != count - 1) {\n                sb.append(DELIMITER);\n            }\n        }\n        sb.append(BRACKET_RIGHT);\n        return sb.toString();\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String underlineToCamel(String string) {\n# Natural Language Annotations: /**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String underlineToCamel(String string) {\n    int strLen = string.length();\n    StringBuilder sb = new StringBuilder(strLen);\n    for (int i = 0; i < strLen; i++) {\n        char c = string.charAt(i);\n        if (c == '_') {\n            if (++i < strLen) {\n                sb.append(Character.toUpperCase(string.charAt(i)));\n            }\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String underlineToCamel(String string) {\n    int strLen = string.length();\n    StringBuilder sb = new StringBuilder(strLen);\n    for (int i = 0; i < strLen; i++) {\n        char c = string.charAt(i);\n        if (c == '_') {\n            if (++i < strLen) {\n                sb.append(Character.toUpperCase(string.charAt(i)));\n            }\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String underlineToCamel(String string) {\n    if (string == null || string.isEmpty()) {\n        return \"\";\n    }\n    String[] words = string.split(\"_\");\n    StringBuilder sb = new StringBuilder(words[0].toLowerCase());\n    for (int i = 1; i < words.length; i++) {\n        sb.append(Character.toUpperCase(words[i].charAt(0)))\n         .append(words[i].substring(1).toLowerCase());\n    }\n    return sb.toString();\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    public Time getTime(String key, Time defaultValue) {\n        Time r = (Time) super.get(key);\n        return r != null ? r : defaultValue;\n    }\n\n    public Timestamp getTimestamp(String key) {\n        return (Timestamp) super.get(key);\n    }\n\n    public Timestamp getTimestamp(String key, Timestamp defaultValue) {\n        Timestamp r = (Timestamp) super.get(key);\n        return r != null ? r : defaultValue;\n    }\n\n    public Byte getByte(String key) {\n        return ConvertUtil.toByte(super.get(key));\n    }\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    public static <K, V> Map.Entry<K, V> entry(K key, V value) {\n        return new AbstractMap.SimpleImmutableEntry<>(key, value);\n    }\n\n\n}\n\n------------------------------\n------------------------------\n    public <T> Row setRaw(LambdaGetter<T> property, Object value) {\n        return setRaw(property, value, true);\n    }\n\n    @Override\n    public <T> Row setRaw(LambdaGetter<T> property, Object value, BooleanSupplier isEffective) {\n        return setRaw(property, value, isEffective.getAsBoolean());\n    }\n\n    @Override\n    public <T, V> Row setRaw(LambdaGetter<T> property, V value, Predicate<V> isEffective) {\n        return setRaw(property, value, isEffective.test(value));\n    }\n\n    public Object get(String key, Object defaultValue) {\n        Object result = super.get(key);\n        return result != null ? result : defaultValue;\n    }\n\n    public Object getIgnoreCase(String key) {\n\n------------------------------\n------------------------------\n        return new ArrayList<>(Arrays.asList(elements));\n    }\n\n\n    public static <E> ArrayList<E> newArrayList(Collection<E> collection) {\n        if (isEmpty(collection)) {\n            return new ArrayList<>();\n        }\n        return new ArrayList<>(collection);\n    }\n\n\n    public static <K, V> HashMap<K, V> newHashMap(Map<K, V> map) {\n        if (map == null || map.isEmpty()) {\n            return new HashMap<>();\n        }\n        return new HashMap<>(map);\n    }\n\n}\n\n------------------------------\n------------------------------\n\n    /**\n     * \u5408\u5e76 list\n     */\n    public static <T> List<T> merge(List<T> list, List<T> other) {\n        if (list == null && other == null) {\n            return new ArrayList<>();\n        } else if (isEmpty(other) && list != null) {\n            return list;\n        } else if (isEmpty(list)) {\n            return other;\n        }\n        List<T> newList = new ArrayList<>(list);\n        newList.addAll(other);\n        return newList;\n    }\n\n\n    public static <K, V> HashMap<K, V> newHashMap() {\n        return new HashMap<>();\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n# Natural Language Annotations: /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value != null) {\n        return value;\n    }\n    return concurrentHashMap.computeIfAbsent(key, mappingFunction);\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value != null) {\n        return value;\n    }\n    return concurrentHashMap.computeIfAbsent(key, mappingFunction);\n}\n```\n", "Here is the function based on the given function signature:\n\n```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value != null) {\n        return value;\n    }\n    return concurrentHashMap.computeIfAbsent(key, mappingFunction);\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    public Map<String, Object> getMetas() {\n        return metas;\n    }\n\n    public void setMetas(Map<String, Object> metas) {\n        this.metas = metas;\n    }\n\n    public void addMeta(String key, Object value) {\n        if (metas == null) {\n            metas = new HashMap<>();\n        }\n        metas.put(key, value);\n    }\n\n    public String getDsName() {\n        return dsName;\n    }\n\n------------------------------\n------------------------------\n\n    protected void setEndFragments(List<String> endFragments) {\n        this.endFragments = endFragments;\n    }\n\n    protected Map<String, Object> getContext() {\n        return context;\n    }\n\n    protected void setContext(Map<String, Object> context) {\n        this.context = context;\n    }\n\n    protected void putContext(String key, Object value) {\n        if (context == null) {\n            context = new HashMap<>();\n        }\n        context.put(key, value);\n    }\n\n\n------------------------------\n------------------------------\n\n    /**\n     * \u5408\u5e76 list\n     */\n    public static <T> List<T> merge(List<T> list, List<T> other) {\n        if (list == null && other == null) {\n            return new ArrayList<>();\n        } else if (isEmpty(other) && list != null) {\n            return list;\n        } else if (isEmpty(list)) {\n            return other;\n        }\n        List<T> newList = new ArrayList<>(list);\n        newList.addAll(other);\n        return newList;\n    }\n\n\n    public static <K, V> HashMap<K, V> newHashMap() {\n        return new HashMap<>();\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    public static <K, V> Map.Entry<K, V> entry(K key, V value) {\n        return new AbstractMap.SimpleImmutableEntry<>(key, value);\n    }\n\n\n}\n\n------------------------------\n------------------------------\n        return new ArrayList<>(Arrays.asList(elements));\n    }\n\n\n    public static <E> ArrayList<E> newArrayList(Collection<E> collection) {\n        if (isEmpty(collection)) {\n            return new ArrayList<>();\n        }\n        return new ArrayList<>(collection);\n    }\n\n\n    public static <K, V> HashMap<K, V> newHashMap(Map<K, V> map) {\n        if (map == null || map.isEmpty()) {\n            return new HashMap<>();\n        }\n        return new HashMap<>(map);\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n# Natural Language Annotations: /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value != null) {\n        return value;\n    }\n    return map.computeIfAbsent(key, mappingFunction);\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value != null) {\n        return value;\n    }\n    return map.computeIfAbsent(key, mappingFunction);\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value != null) {\n        return value;\n    }\n    return map.computeIfAbsent(key, mappingFunction);\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        } catch (Exception e) {\n            throw new TypeException(\"Failed invoking constructor for handler \" + typeHandlerClass, e);\n        }\n        try {\n            Constructor<?> constructor = typeHandlerClass.getConstructor(Class.class);\n            return (TypeHandler<?>) constructor.newInstance(fieldType);\n        } catch (NoSuchMethodException ignored) {\n        } catch (Exception e) {\n            throw new TypeException(\"Failed invoking constructor for handler \" + typeHandlerClass, e);\n        }\n        try {\n            Constructor<?> c = typeHandlerClass.getConstructor();\n            return (TypeHandler<?>) c.newInstance();\n        } catch (Exception e) {\n            throw new TypeException(\"Unable to find a usable constructor for \" + typeHandlerClass, e);\n        }\n    }\n\n\n    static String getColumnName(boolean isCamelToUnderline, Field field, Column column) {\n\n------------------------------\n------------------------------\n     */\n    private static TypeHandler<?> createCollectionTypeHandler(Class<?> entityClass, Field field, Class<?> typeHandlerClass, Class<?> fieldType) {\n        Class<?> genericClass = null;\n        Type genericType = TypeParameterResolver.resolveFieldType(field, entityClass);\n        if (genericType instanceof ParameterizedType) {\n            Type actualTypeArgument = ((ParameterizedType) genericType).getActualTypeArguments()[0];\n            if (actualTypeArgument instanceof Class) {\n                genericClass = (Class<?>) actualTypeArgument;\n            }\n        }\n\n        try {\n            Constructor<?> constructor = typeHandlerClass.getConstructor(Class.class, Class.class);\n            return (TypeHandler<?>) constructor.newInstance(fieldType, genericClass);\n        } catch (NoSuchMethodException ignored) {\n        } catch (Exception e) {\n            throw new TypeException(\"Failed invoking constructor for handler \" + typeHandlerClass, e);\n        }\n        try {\n            Constructor<?> constructor = typeHandlerClass.getConstructor(Class.class);\n\n------------------------------\n------------------------------\n            } catch (Exception e) {\n                throw new RuntimeException(\"Can not invoke method: \" + setter);\n            }\n        });\n        return instance;\n    }\n\n\n    public static <T> List<T> toObjectList(List<Row> rows, Class<T> objectClass) {\n        return toObjectList(rows, objectClass, 0);\n    }\n\n\n    public static <T> List<T> toObjectList(List<Row> rows, Class<T> objectClass, int index) {\n        if (rows == null || rows.isEmpty()) {\n            return Collections.emptyList();\n        } else {\n            List<T> objectList = new ArrayList<>();\n            for (Row row : rows) {\n                objectList.add(toObject(row, objectClass, index));\n\n------------------------------\n------------------------------\npublic class FlexMapperRegistry extends MapperRegistry {\n    private final FlexConfiguration config;\n    private final Map<Class<?>, FlexMapperProxyFactory<?>> knownMappers = new ConcurrentHashMap<>();\n\n    public FlexMapperRegistry(FlexConfiguration config) {\n        super(config);\n        this.config = config;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public <T> T getMapper(Class<T> type, SqlSession sqlSession) {\n        final FlexMapperProxyFactory<T> mapperProxyFactory = (FlexMapperProxyFactory<T>) knownMappers.get(type);\n        if (mapperProxyFactory == null) {\n            throw new BindingException(\"Type \" + type + \" is not known to the MapperRegistry.\");\n        }\n        try {\n            return mapperProxyFactory.newInstance(sqlSession, config);\n        } catch (Exception e) {\n            throw new BindingException(\"Error getting mapper instance. Cause: \" + e, e);\n        }\n\n------------------------------\n------------------------------\n                    && Modifier.isPublic(m.getModifiers())\n                    && Modifier.isStatic(m.getModifiers()));\n\n                if (factoryMethod != null) {\n                    return (T) factoryMethod.invoke(null);\n                }\n            }\n            throw new IllegalArgumentException(\"the class \\\"\" + clazz.getName() + \"\\\" has no constructor.\");\n        } catch (Exception e) {\n            throw new RuntimeException(\"Can not newInstance class: \" + clazz.getName(), e);\n        }\n    }\n\n\n    public static <T> T newInstance(Class<T> clazz, Object... paras) {\n        try {\n            Constructor<?>[] constructors = clazz.getDeclaredConstructors();\n            for (Constructor<?> constructor : constructors) {\n                if (isMatchedParas(constructor, paras)) {\n                    Object ret = constructor.newInstance(paras);\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    try {\n        Constructor<?>[] constructors = entityClass.getDeclaredConstructors();\n        for (Constructor<?> constructor : constructors) {\n            if (isMatchedParas(constructor, new Object[]{})) {\n                Object ret = constructor.newInstance();\n                if (ret instanceof BaseMapper) {\n                    return (BaseMapper<E>) ret;\n                }\n            }\n        }\n        throw new IllegalArgumentException(\"the class \\\"\" + entityClass.getName() + \"\\\" has no constructor.\");\n    } catch (Exception e) {\n        throw new RuntimeException(\"Can not newInstance class: \" + entityClass.getName(), e);\n    }\n}\n```\n", "```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    try {\n        Constructor<?>[] constructors = entityClass.getDeclaredConstructors();\n        for (Constructor<?> constructor : constructors) {\n            if (isMatchedParas(constructor, new Object[]{})) {\n                Object ret = constructor.newInstance();\n                return (BaseMapper<E>) ret;\n            }\n        }\n        throw new IllegalArgumentException(\"the class \\\"\" + entityClass.getName() + \"\\\" has no constructor.\");\n    } catch (Exception e) {\n        throw new RuntimeException(\"Can not newInstance class: \" + entityClass.getName(), e);\n    }\n}\n```\n", "```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    try {\n        // Code implementation here\n    } catch (Exception e) {\n        throw new RuntimeException(\"Can not newInstance class: \" + entityClass.getName(), e);\n    }\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    public static <T> UpdateChain<T> of(T entityObject, BaseMapper<T> baseMapper) {\n        return new UpdateChain<>(baseMapper, entityObject);\n    }\n\n\n    public UpdateChain(BaseMapper<T> baseMapper) {\n        this.baseMapper = baseMapper;\n        this.entity = createEntity(ClassUtil.getUsefulClass(baseMapper.getClass()));\n        this.entityWrapper = (UpdateWrapper) entity;\n    }\n\n\n    public UpdateChain(BaseMapper<T> baseMapper, T entityObject) {\n        this.baseMapper = baseMapper;\n        entityObject = (T) UpdateWrapper.of(entityObject);\n        this.entity = entityObject;\n        this.entityWrapper = (UpdateWrapper) entityObject;\n    }\n\n    private T createEntity(Class<?> mapperClass) {\n\n------------------------------\n------------------------------\n\n    private final BaseMapper<T> baseMapper;\n\n    public QueryChain(BaseMapper<T> baseMapper) {\n        this.baseMapper = baseMapper;\n    }\n\n    public static <T> QueryChain<T> of(Class<T> entityClass) {\n        BaseMapper<T> baseMapper = Mappers.ofEntityClass(entityClass);\n        return new QueryChain<>(baseMapper);\n    }\n\n    public static <E> QueryChain<E> of(BaseMapper<E> baseMapper) {\n        return new QueryChain<>(baseMapper);\n    }\n\n    @Override\n    public BaseMapper<T> baseMapper() {\n        return baseMapper;\n    }\n\n------------------------------\n------------------------------\n    public static <T> UpdateChain<T> of(Class<T> entityClass) {\n        BaseMapper<T> baseMapper = Mappers.ofEntityClass(entityClass);\n        return new UpdateChain<>(baseMapper);\n    }\n\n    public static <T> UpdateChain<T> of(BaseMapper<T> baseMapper) {\n        return new UpdateChain<>(baseMapper);\n    }\n\n    public static <T> UpdateChain<T> of(T entityObject) {\n        Class<T> entityClass = (Class<T>) ClassUtil.getUsefulClass(entityObject.getClass());\n        BaseMapper<T> baseMapper = Mappers.ofEntityClass(entityClass);\n        return new UpdateChain<>(baseMapper, entityObject);\n    }\n\n    public static <T> UpdateChain<T> of(T entityObject, BaseMapper<T> baseMapper) {\n        return new UpdateChain<>(baseMapper, entityObject);\n    }\n\n\n\n------------------------------\n------------------------------\n\n    private final Class<T> mapperInterface;\n    private final Map<Method, MybatisMapperProxy.MapperMethodInvoker> methodCache = new ConcurrentHashMap<>();\n\n    public FlexMapperProxyFactory(Class<T> mapperInterface) {\n        this.mapperInterface = mapperInterface;\n    }\n\n    public Class<T> getMapperInterface() {\n        return mapperInterface;\n    }\n\n    public Map<Method, MybatisMapperProxy.MapperMethodInvoker> getMethodCache() {\n        return methodCache;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    protected T newInstance(FlexMapperProxy<T> mapperProxy) {\n        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]{mapperInterface}, mapperProxy);\n    }\n\n------------------------------\n------------------------------\n\n    @SuppressWarnings(\"unchecked\")\n    protected T newInstance(FlexMapperProxy<T> mapperProxy) {\n        return (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), new Class[]{mapperInterface}, mapperProxy);\n    }\n\n    public T newInstance(SqlSession sqlSession, FlexConfiguration configuration) {\n        final FlexMapperProxy<T> mapperProxy = new FlexMapperProxy<>(sqlSession, mapperInterface, methodCache, configuration);\n        return newInstance(mapperProxy);\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <M> M ofMapperClass(Class<M> mapperClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    BaseMapper<M> baseMapper = Mappers.ofEntityClass(mapperClass);\n    return (M) Proxy.newProxyInstance(mapperClass.getClassLoader(), new Class[]{mapperClass}, new FlexMapperProxy<>(sqlSession, mapperClass, methodCache, configuration));\n}\n```\n", "```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    FlexMapperProxyFactory<M> factory = new FlexMapperProxyFactory<>(mapperClass);\n    return factory.newInstance(null, null);\n}\n```\n", "```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    FlexMapperProxyFactory<M> mapperFactory = new FlexMapperProxyFactory<>(mapperClass);\n    FlexConfiguration configuration = new FlexConfiguration();\n    SqlSession sqlSession = configuration.getSqlSessionFactory().openSession();\n    return mapperFactory.newInstance(sqlSession, configuration);\n}\n```\n"]}, "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n * @author Ahmed Yousri\n * @since 1.0.0-M1\n */\npublic class SpeechPrompt implements ModelRequest<SpeechMessage> {\n\n\tprivate OpenAiAudioSpeechOptions speechOptions;\n\n\tprivate final SpeechMessage message;\n\n\tpublic SpeechPrompt(String instructions) {\n\t\tthis(new SpeechMessage(instructions), OpenAiAudioSpeechOptions.builder().build());\n\t}\n\n\tpublic SpeechPrompt(String instructions, OpenAiAudioSpeechOptions speechOptions) {\n\t\tthis(new SpeechMessage(instructions), speechOptions);\n\t}\n\n\tpublic SpeechPrompt(SpeechMessage speechMessage) {\n\t\tthis(speechMessage, OpenAiAudioSpeechOptions.builder().build());\n\t}\n\n------------------------------\n------------------------------\n\tChatOptions getDefaultOptions();\n\n\tdefault Flux<ChatResponse> stream(Prompt prompt) {\n\t\tthrow new UnsupportedOperationException(\"streaming is not supported\");\n\t}\n\n}\n\n------------------------------\n------------------------------\n\t}\n\n\tpublic SpeechPrompt(SpeechMessage speechMessage) {\n\t\tthis(speechMessage, OpenAiAudioSpeechOptions.builder().build());\n\t}\n\n\tpublic SpeechPrompt(SpeechMessage speechMessage, OpenAiAudioSpeechOptions speechOptions) {\n\t\tthis.message = speechMessage;\n\t\tthis.speechOptions = speechOptions;\n\t}\n\n\t@Override\n\tpublic SpeechMessage getInstructions() {\n\t\treturn this.message;\n\t}\n\n\t@Override\n\tpublic ModelOptions getOptions() {\n\t\treturn speechOptions;\n\t}\n\n------------------------------\n------------------------------\n\t * @return the speech response containing the generated audio\n\t */\n\tSpeechResponse call(SpeechPrompt request);\n\n}\n\n------------------------------\n------------------------------\n\t * @param prompt the speech prompt containing the input text and other parameters\n\t * @return a Flux of speech responses, each containing a portion of the generated\n\t * audio\n\t */\n\t@Override\n\tFlux<SpeechResponse> stream(SpeechPrompt prompt);\n\n}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n# Natural Language Annotations: /**\n\t * Streams the audio response for the given speech prompt.\n\t * @param speechPrompt The speech prompt containing the text and options for speech\n\t * synthesis.\n\t * @return A Flux of SpeechResponse objects containing the streamed audio and\n\t * metadata.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    // Implementation goes here\n}\n```\n", "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    // Implementation goes here\n}\n```\n", "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    // TODO: Implement the streaming logic here\n    // This is a placeholder and should be implemented based on the specific requirements of your application\n    return Flux.empty();\n}\n```\n"]}, "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npackage org.springframework.ai.postgresml;\n\nimport java.util.Map;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonInclude.Include;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\nimport org.springframework.ai.document.MetadataMode;\nimport org.springframework.ai.embedding.EmbeddingOptions;\nimport org.springframework.ai.model.ModelOptionsUtils;\nimport org.springframework.ai.postgresml.PostgresMlEmbeddingModel.VectorType;\n\n/**\n * @author Christian Tzolov\n * @author Thomas Vitale\n */\n@JsonInclude(Include.NON_NULL)\npublic class PostgresMlEmbeddingOptions implements EmbeddingOptions {\n\n------------------------------\n------------------------------\n\t\tprivate EmbeddingOptions requestOptions;\n\n\t\tprivate Builder() {\n\t\t}\n\n\t\tpublic Builder embeddingRequest(EmbeddingRequest embeddingRequest) {\n\t\t\tthis.embeddingRequest = embeddingRequest;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder provider(String provider) {\n\t\t\tthis.provider = provider;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder requestOptions(EmbeddingOptions requestOptions) {\n\t\t\tthis.requestOptions = requestOptions;\n\t\t\treturn this;\n\t\t}\n\n\n------------------------------\n------------------------------\n\t\tpublic Builder requestOptions(EmbeddingOptions requestOptions) {\n\t\t\tthis.requestOptions = requestOptions;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic EmbeddingModelObservationContext build() {\n\t\t\treturn new EmbeddingModelObservationContext(embeddingRequest, provider, requestOptions);\n\t\t}\n\n\t}\n\n}\n\n------------------------------\n------------------------------\n\t\treturn new Builder();\n\t}\n\n\tpublic static class Builder {\n\n\t\tprotected PostgresMlEmbeddingOptions options;\n\n\t\tpublic Builder() {\n\t\t\tthis.options = new PostgresMlEmbeddingOptions();\n\t\t}\n\n\t\tpublic Builder withTransformer(String transformer) {\n\t\t\tthis.options.setTransformer(transformer);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic Builder withVectorType(VectorType vectorType) {\n\t\t\tthis.options.setVectorType(vectorType);\n\t\t\treturn this;\n\t\t}\n\n------------------------------\n------------------------------\n\n\t\tpublic Builder withMetadataMode(MetadataMode metadataMode) {\n\t\t\tthis.options.setMetadataMode(metadataMode);\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic PostgresMlEmbeddingOptions build() {\n\t\t\treturn this.options;\n\t\t}\n\n\t}\n\n\tpublic String getTransformer() {\n\t\treturn this.transformer;\n\t}\n\n\tpublic void setTransformer(String transformer) {\n\t\tthis.transformer = transformer;\n\t}\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n# Natural Language Annotations: /**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    this.requestOptions = requestOptions;\n    return this;\n}\n```\n", "```java\npublic PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    this.requestOptions = requestOptions;\n    return this;\n}\n```\n", "```java\npublic PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    Builder builder = new Builder();\n\n    builder.withTransformer(this.getTransformer());\n    builder.withVectorType(this.getVectorType());\n    builder.withMetadataMode(this.getMetadataMode());\n    // add other properties to merge if any\n\n    builder.requestOptions(requestOptions);\n\n    return builder.build();\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\t/**\n\t * Multimodal model.Expires on May 14, 2025.\n\t */\n\tMULTIMODAL_EMBEDDING_001(\"multimodalembedding@001\", \"001\", 1408, \"Multimodal model\");\n\n\tprivate final String modelVersion;\n\n\tprivate final String modelName;\n\n\tprivate final String description;\n\n\tprivate final int dimensions;\n\n\tVertexAiMultimodalEmbeddingModelName(String value, String modelVersion, int dimensions, String description) {\n\t\tthis.modelName = value;\n\t\tthis.modelVersion = modelVersion;\n\t\tthis.dimensions = dimensions;\n\t\tthis.description = description;\n\t}\n\n------------------------------\n------------------------------\n\t}\n\n\tprivate static final Map<String, Integer> KNOWN_EMBEDDING_DIMENSIONS = Stream\n\t\t.of(VertexAiTextEmbeddingModelName.values())\n\t\t.collect(Collectors.toMap(VertexAiTextEmbeddingModelName::getName,\n\t\t\t\tVertexAiTextEmbeddingModelName::getDimensions));\n\n}\n------------------------------\n------------------------------\n\t}\n\n\tprivate EmbeddingResponseMetadata generateResponseMetadata(String model, Integer totalTokens,\n\t\t\tMap<String, Object> metadataToUse) {\n\t\tUsage usage = new VertexAiEmbeddingUsage(totalTokens);\n\t\treturn new EmbeddingResponseMetadata(model, usage, metadataToUse);\n\t}\n\n\t@Override\n\tpublic int dimensions() {\n\t\treturn KNOWN_EMBEDDING_DIMENSIONS.getOrDefault(this.defaultOptions.getModel(), 768);\n\t}\n\n\tprivate static final Map<String, Integer> KNOWN_EMBEDDING_DIMENSIONS = Stream\n\t\t.of(VertexAiMultimodalEmbeddingModelName.values())\n\t\t.collect(Collectors.toMap(VertexAiMultimodalEmbeddingModelName::getName,\n\t\t\t\tVertexAiMultimodalEmbeddingModelName::getDimensions));\n\n}\n------------------------------\n------------------------------\n            return;\n        }\n        String value;\n        if (apiKeyPrefix != null) {\n            value = apiKeyPrefix + \" \" + apiKey;\n        } else {\n            value = apiKey;\n        }\n        if (location.equals(\"query\")) {\n            queryParams.add(paramName, value);\n        } else if (location.equals(\"header\")) {\n            headerParams.add(paramName, value);\n       }\n    }\n}\n\n------------------------------\n------------------------------\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate EmbeddingResponseMetadata generateResponseMetadata(String model, Integer totalTokens) {\n\t\tEmbeddingResponseMetadata metadata = new EmbeddingResponseMetadata();\n\t\tmetadata.setModel(model);\n\t\tUsage usage = new VertexAiEmbeddingUsage(totalTokens);\n\t\tmetadata.setUsage(usage);\n\t\treturn metadata;\n\t}\n\n\t@Override\n\tpublic int dimensions() {\n\t\treturn KNOWN_EMBEDDING_DIMENSIONS.getOrDefault(this.defaultOptions.getModel(), super.dimensions());\n\t}\n\n\tprivate static final Map<String, Integer> KNOWN_EMBEDDING_DIMENSIONS = Stream\n\t\t.of(VertexAiTextEmbeddingModelName.values())\n\t\t.collect(Collectors.toMap(VertexAiTextEmbeddingModelName::getName,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n# Natural Language Annotations: /**\n\t * Return the dimension of the requested embedding generative name. If the generative\n\t * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n\t * count the response dimensions.\n\t * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n\t * @param modelName Embedding generative name to retrieve the dimensions for.\n\t * @param dummyContent Dummy content to use for the empirical dimension calculation.\n\t * @return Returns the embedding dimensions for the modelName.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (KNOWN_EMBEDDING_DIMENSIONS.containsKey(modelName)) {\n        return KNOWN_EMBEDDING_DIMENSIONS.get(modelName);\n    } else {\n        try {\n            EmbeddingResponse response = embeddingModel.embed(dummyContent);\n            return response.getDimensions();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n", "```java\nprivate static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (KNOWN_EMBEDDING_DIMENSIONS.containsKey(modelName)) {\n        return KNOWN_EMBEDDING_DIMENSIONS.get(modelName);\n    } else {\n        EmbeddingResponse response = embeddingModel.embed(dummyContent);\n        return response.getResponseMetadata().getDimensions();\n    }\n}\n```\n", "```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (KNOWN_EMBEDDING_DIMENSIONS.containsKey(modelName)) {\n        return KNOWN_EMBEDDING_DIMENSIONS.get(modelName);\n    } else {\n        EmbeddingResponse response = embeddingModel.embed(dummyContent, modelName);\n        return response.getEmbeddings().size();\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\t\tthis.retryTemplate = retryTemplate;\n\t}\n\n\t@Override\n\tpublic ChatResponse call(Prompt prompt) {\n\n\t\tChatCompletionRequest request = createRequest(prompt, false);\n\n\t\treturn this.retryTemplate.execute(ctx -> {\n\n\t\t\tResponseEntity<ChatCompletion> completionEntity = this.doChatCompletion(request);\n\n\t\t\tvar chatCompletion = completionEntity.getBody();\n\t\t\tif (chatCompletion == null) {\n\t\t\t\tlogger.warn(\"No chat completion returned for prompt: {}\", prompt);\n\t\t\t\treturn new ChatResponse(List.of());\n\t\t\t}\n\n\t\t\t// if (chatCompletion.baseResponse() != null &&\n\t\t\t// chatCompletion.baseResponse().statusCode() != 0) {\n\n------------------------------\n------------------------------\n    public String formatDate(Date date) {\n        return dateFormat.format(date);\n    }\n\n    /**\n     * Format the given parameter object into string.\n     * @param param the object to convert\n     * @return String the parameter represented as a String\n     */\n    public String parameterToString(Object param) {\n        if (param == null) {\n            return \"\";\n        } else if (param instanceof Date) {\n            return formatDate( (Date) param);\n        } else if (param instanceof Collection) {\n            StringBuilder b = new StringBuilder();\n            for(Object o : (Collection<?>) param) {\n                if(b.length() > 0) {\n                    b.append(\",\");\n                }\n\n------------------------------\n------------------------------\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    GenerateResponse generateResponse = (GenerateResponse) o;\n    return Objects.equals(this.details, generateResponse.details) &&\n        Objects.equals(this.generatedText, generateResponse.generatedText);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(details, generatedText);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class GenerateResponse {\\n\");\n\n------------------------------\n------------------------------\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ErrorResponse errorResponse = (ErrorResponse) o;\n    return Objects.equals(this.error, errorResponse.error) &&\n        Objects.equals(this.errorType, errorResponse.errorType);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(error, errorType);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class ErrorResponse {\\n\");\n\n------------------------------\n------------------------------\n\t * {@link PromptFilterMetadata}.\n\t */\n\tstatic PromptMetadata of(Iterable<PromptFilterMetadata> iterable) {\n\t\tAssert.notNull(iterable, \"An Iterable of PromptFilterMetadata must not be null\");\n\t\treturn iterable::iterator;\n\t}\n\n\t/**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n# Natural Language Annotations: /**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"The prompt index cannot be less than 0\");\n    }\n    // Assuming that this class implements Iterable<PromptFilterMetadata>\n    for (PromptFilterMetadata metadata : this) {\n        if (metadata.getPromptIndex() == promptIndex) {\n            return Optional.of(metadata);\n        }\n    }\n    return Optional.empty();\n}\n```\n", "```java\npublic Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"The prompt index must not be less than 0\");\n    }\n    // Assuming the iterable is a collection of PromptFilterMetadata\n    for (PromptFilterMetadata metadata : this) {\n        if (metadata.getIndex() == promptIndex) {\n            return Optional.of(metadata);\n        }\n    }\n    return Optional.empty();\n}\n```\n", "```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n  if (promptIndex < 0) {\n    throw new IllegalArgumentException(\"The prompt index must be greater than or equal to 0\");\n  }\n  // Assuming that 'this' is an iterable of PromptFilterMetadata\n  Iterator<PromptFilterMetadata> iterator = this.iterator();\n  while (iterator.hasNext()) {\n    PromptFilterMetadata metadata = iterator.next();\n    if (metadata.getIndex() == promptIndex) {\n      return Optional.of(metadata);\n    }\n  }\n  return Optional.empty();\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\t}\n\n\tpublic record DefaultUsage(long promptTokens, long generationTokens, long totalTokens) implements Usage {\n\n\t\t@Override\n\t\tpublic Long getPromptTokens() {\n\t\t\treturn promptTokens();\n\t\t}\n\n\t\t@Override\n\t\tpublic Long getGenerationTokens() {\n\t\t\treturn generationTokens();\n\t\t}\n\n\t\t@Override\n\t\tpublic Long getTotalTokens() {\n\t\t\treturn totalTokens();\n\t\t}\n\t}\n\n\n------------------------------\n------------------------------\n\t\treturn getUsage().promptTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getGenerationTokens() {\n\t\treturn getUsage().completionTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getTotalTokens() {\n\t\treturn getUsage().totalTokens().longValue();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getUsage().toString();\n\t}\n\n}\n\n------------------------------\n------------------------------\n\t@Override\n\tpublic Long getPromptTokens() {\n\t\treturn getUsage().promptTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getGenerationTokens() {\n\t\treturn getUsage().completionTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getTotalTokens() {\n\t\treturn getUsage().totalTokens().longValue();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getUsage().toString();\n\t}\n\n\n------------------------------\n------------------------------\n\tpublic Long getPromptTokens() {\n\t\treturn getUsage().promptTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getGenerationTokens() {\n\t\treturn getUsage().completionTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getTotalTokens() {\n\t\treturn getUsage().totalTokens().longValue();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getUsage().toString();\n\t}\n\n}\n\n------------------------------\n------------------------------\n\tpublic Long getPromptTokens() {\n\t\treturn getUsage().inputTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getGenerationTokens() {\n\t\treturn getUsage().outputTokens().longValue();\n\t}\n\n\t@Override\n\tpublic Long getTotalTokens() {\n\t\treturn this.getPromptTokens() + this.getGenerationTokens();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn getUsage().toString();\n\t}\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Long getTotalTokens() {\n# Natural Language Annotations: /**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```\n", "```java\npublic Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```\n", "```java\npublic Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Collection<?> valueCollection = null;\n        if (value instanceof Collection) {\n            valueCollection = (Collection<?>) value;\n        } else {\n            params.add(name, parameterToString(value));\n            return params;\n        }\n\n        if (valueCollection.isEmpty()){\n            return params;\n        }\n\n        if (collectionFormat.equals(CollectionFormat.MULTI)) {\n            for (Object item : valueCollection) {\n                params.add(name, parameterToString(item));\n            }\n            return params;\n        }\n\n\n------------------------------\n------------------------------\n\t\tthis.convertOperand(operand, context);\n\t\treturn context.toString();\n\t}\n\n\tprotected void convertOperand(Operand operand, StringBuilder context) {\n\n\t\tif (operand instanceof Filter.Group group) {\n\t\t\tthis.doGroup(group, context);\n\t\t}\n\t\telse if (operand instanceof Filter.Key key) {\n\t\t\tthis.doKey(key, context);\n\t\t}\n\t\telse if (operand instanceof Filter.Value value) {\n\t\t\tthis.doValue(value, context);\n\t\t}\n\t\telse if (operand instanceof Filter.Expression expression) {\n\t\t\tif ((expression.type() != ExpressionType.NOT && expression.type() != ExpressionType.AND\n\t\t\t\t\t&& expression.type() != ExpressionType.OR) && !(expression.right() instanceof Filter.Value)) {\n\t\t\t\tthrow new RuntimeException(\"Non AND/OR expression must have Value right argument!\");\n\t\t\t}\n\n------------------------------\n------------------------------\n\t\telse if (operand instanceof Filter.Expression expression) {\n\t\t\tif ((expression.type() != ExpressionType.NOT && expression.type() != ExpressionType.AND\n\t\t\t\t\t&& expression.type() != ExpressionType.OR) && !(expression.right() instanceof Filter.Value)) {\n\t\t\t\tthrow new RuntimeException(\"Non AND/OR expression must have Value right argument!\");\n\t\t\t}\n\t\t\tif (expression.type() == ExpressionType.NOT) {\n\t\t\t\tthis.doNot(expression, context);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.doExpression(expression, context);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected void doNot(Filter.Expression expression, StringBuilder context) {\n\t\t// Default behavior is to convert the NOT expression into its semantically\n\t\t// equivalent negation expression.\n\t\t// Effectively removing the NOT types form the boolean expression tree before\n\t\t// passing it to the doExpression.\n\t\tthis.convertOperand(FilterHelper.negate(expression), context);\n\n------------------------------\n------------------------------\n\t\t@Override\n\t\tpublic Filter.Operand visitOrExpression(FiltersParser.OrExpressionContext ctx) {\n\t\t\treturn new Filter.Expression(Filter.ExpressionType.OR, this.visit(ctx.left), this.visit(ctx.right));\n\t\t}\n\n\t\t@Override\n\t\tpublic Filter.Operand visitGroupExpression(FiltersParser.GroupExpressionContext ctx) {\n\t\t\treturn new Filter.Group(castToExpression(this.visit(ctx.booleanExpression())));\n\t\t}\n\n\t\t@Override\n\t\tpublic Filter.Operand visitNotExpression(NotExpressionContext ctx) {\n\t\t\treturn new Filter.Expression(Filter.ExpressionType.NOT, this.visit(ctx.booleanExpression()), null);\n\t\t}\n\n\t\tpublic Filter.Expression castToExpression(Filter.Operand expression) {\n\t\t\tif (expression instanceof Filter.Group group) {\n\t\t\t\t// Remove the top-level grouping.\n\t\t\t\treturn group.content();\n\t\t\t}\n\n------------------------------\n------------------------------\n            return;\n        }\n        String value;\n        if (apiKeyPrefix != null) {\n            value = apiKeyPrefix + \" \" + apiKey;\n        } else {\n            value = apiKey;\n        }\n        if (location.equals(\"query\")) {\n            queryParams.add(paramName, value);\n        } else if (location.equals(\"header\")) {\n            headerParams.add(paramName, value);\n       }\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Filter.Operand negate(Filter.Operand operand) {\n# Natural Language Annotations: /**\n\t * Transforms the input expression into a semantically equivalent one with negation\n\t * operators propagated thought the expression tree by following the negation rules:\n\t *\n\t * <pre>\n\t * \tNOT(NOT(a)) = a\n\t *\n\t * \tNOT(a AND b) = NOT(a) OR NOT(b)\n\t * \tNOT(a OR b) = NOT(a) AND NOT(b)\n\t *\n\t * \tNOT(a EQ b) = a NE b\n\t * \tNOT(a NE b) = a EQ b\n\t *\n\t * \tNOT(a GT b) = a LTE b\n\t * \tNOT(a GTE b) = a LT b\n\t *\n\t * \tNOT(a LT b) = a GTE b\n\t * \tNOT(a LTE b) = a GT b\n\t *\n\t * \tNOT(a IN [...]) = a NIN [...]\n\t * \tNOT(a NIN [...]) = a IN [...]\n\t * </pre>\n\t * @param operand Filter expression to negate.\n\t * @return Returns an negation of the input expression.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Expression expression) {\n        if (expression.type() == Filter.ExpressionType.NOT) {\n            return expression.left();\n        } else if (expression.type() == Filter.ExpressionType.AND) {\n            return new Filter.Expression(Filter.ExpressionType.OR, negate(expression.left()), negate(expression.right()));\n        } else if (expression.type() == Filter.ExpressionType.OR) {\n            return new Filter.Expression(Filter.ExpressionType.AND, negate(expression.left()), negate(expression.right()));\n        } else if (expression.type() == Filter.ExpressionType.EQ) {\n            return new Filter.Expression(Filter.ExpressionType.NE, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.NE) {\n            return new Filter.Expression(Filter.ExpressionType.EQ, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.GT) {\n            return new Filter.Expression(Filter.ExpressionType.LTE, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.GTE) {\n            return new Filter.Expression(Filter.ExpressionType.LT, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.LT) {\n            return new Filter.Expression(Filter.ExpressionType.GTE, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.LTE) {\n            return new Filter.Expression(Filter.ExpressionType.GT, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.IN) {\n            return new Filter.Expression(Filter.ExpressionType.NIN, expression.left(), expression.right());\n        } else if (expression.type() == Filter.ExpressionType.NIN) {\n            return new Filter.Expression(Filter.ExpressionType.IN, expression.left(), expression.right());\n        }\n    }\n    return new Filter.Expression(Filter.ExpressionType.NOT, operand, null);\n}\n```\n", "```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Expression expression) {\n        if (expression.type() == Filter.ExpressionType.NOT) {\n            // NOT(NOT(a)) = a\n            return expression.left();\n        } else {\n            // NOT(a AND b) = NOT(a) OR NOT(b)\n            // NOT(a OR b) = NOT(a) AND NOT(b)\n            Filter.ExpressionType negatedType = expression.type() == Filter.ExpressionType.AND ? Filter.ExpressionType.OR : Filter.ExpressionType.AND;\n            return new Filter.Expression(negatedType, negate(expression.left()), negate(expression.right()));\n        }\n    } else {\n        throw new UnsupportedOperationException(\"Negation operation is not supported for operands of type \" + operand.getClass().getSimpleName());\n    }\n}\n```\n", "```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Expression expression) {\n        if (expression.type() == Filter.ExpressionType.NOT) {\n            // Recursively negate the expression inside the NOT.\n            return expression.left();\n        }\n        else if (expression.type() == Filter.ExpressionType.AND) {\n            // Negate a AND b into NOT(a) OR NOT(b).\n            return new Filter.Expression(Filter.ExpressionType.OR, negate(expression.left()), negate(expression.right()));\n        }\n        else if (expression.type() == Filter.ExpressionType.OR) {\n            // Negate a OR b into NOT(a) AND NOT(b).\n            return new Filter.Expression(Filter.ExpressionType.AND, negate(expression.left()), negate(expression.right()));\n        }\n        // Negate other types of expressions.\n        else {\n            // NOT(a EQ b) = a NE b, NOT(a NE b) = a EQ b, etc.\n            return new Filter.Expression(Filter.ExpressionType.NOT, expression, null);\n        }\n    }\n    // If operand is not an expression, return a NOT expression with the operand as its left child.\n    else {\n        return new Filter.Expression(Filter.ExpressionType.NOT, operand, null);\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\t * @param key key\n\t * @param defaultObject default object to return\n\t * @param <T> value type\n\t * @return object or default if not present\n\t */\n\t<T> T getOrDefault(Object key, T defaultObject);\n\n\t/**\n\t * Returns an element or default if not present.\n\t * @param key key\n\t * @param defaultObjectSupplier supplier for default object to return\n\t * @param <T> value type\n\t * @return object or default if not present\n\t * @since 1.11.0\n\t */\n\tdefault <T> T getOrDefault(String key, Supplier<T> defaultObjectSupplier) {\n\t\tT value = get(key);\n\t\treturn value != null ? value : defaultObjectSupplier.get();\n\t}\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\t/**\n\t * Converts the given Map to the given class.\n\t * @param <T> the type of the class to return.\n\t * @param source the Map to convert to the given class.\n\t * @param clazz the class to convert the Map to.\n\t * @return the converted class.\n\t */\n\tpublic static <T> T mapToClass(Map<String, Object> source, Class<T> clazz) {\n\t\ttry {\n\t\t\tString json = OBJECT_MAPPER.writeValueAsString(source);\n\t\t\treturn OBJECT_MAPPER.readValue(json, clazz);\n\n------------------------------\n------------------------------\n     */\n    public Map<String, Object> toMap() {\n        try {\n            var json = mapper.writeValueAsString(this);\n            var map = mapper.readValue(json, new TypeReference<Map<String, Object>>() {});\n            map.remove(\"additional\");\n\n            return map;\n        }\n        catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    /**\n     * Filter out the non supported fields from the options.\n     * @param options The options to filter.\n     * @return The filtered options.\n     */\n\n\n------------------------------\n------------------------------\n\t */\n\tpublic static List<String> getJsonPropertyValues(Class<?> clazz) {\n\t\tList<String> values = new ArrayList<>();\n\t\tField[] fields = clazz.getDeclaredFields();\n\t\tfor (Field field : fields) {\n\t\t\tJsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\t\t\tif (jsonPropertyAnnotation != null) {\n\t\t\t\tvalues.add(jsonPropertyAnnotation.value());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\n------------------------------\n------------------------------\n\t */\n\tpublic static <T> T mapToClass(Map<String, Object> source, Class<T> clazz) {\n\t\ttry {\n\t\t\tString json = OBJECT_MAPPER.writeValueAsString(source);\n\t\t\treturn OBJECT_MAPPER.readValue(json, clazz);\n\t\t}\n\t\tcatch (JsonProcessingException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the list of name values of the {@link JsonProperty} annotations.\n\t * @param clazz the class that contains fields annotated with {@link JsonProperty}.\n\t * @return the list of values of the {@link JsonProperty} annotations.\n\t */\n\tpublic static List<String> getJsonPropertyValues(Class<?> clazz) {\n\t\tList<String> values = new ArrayList<>();\n\t\tField[] fields = clazz.getDeclaredFields();\n\t\tfor (Field field : fields) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n\t * empty, use the {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @param acceptedFieldNames the list of field names accepted for the target object.\n\t * @return the merged object represented by the given class.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    try {\n        Map<String, Object> sourceMap = toMap(source);\n        Map<String, Object> targetMap = toMap(target);\n\n        if (!acceptedFieldNames.isEmpty()) {\n            sourceMap.keySet().retainAll(acceptedFieldNames);\n        }\n\n        sourceMap.forEach((key, value) -> {\n            if (value != null) {\n                targetMap.put(key, value);\n            }\n        });\n\n        String json = OBJECT_MAPPER.writeValueAsString(targetMap);\n        return OBJECT_MAPPER.readValue(json, clazz);\n    } catch (JsonProcessingException e) {\n        throw new RuntimeException(e);\n    }\n}\n\nprivate static Map<String, Object> toMap(Object obj) {\n    try {\n        String json = OBJECT_MAPPER.writeValueAsString(obj);\n        return OBJECT_MAPPER.readValue(json, new TypeReference<Map<String, Object>>() {});\n    } catch (JsonProcessingException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    Map<String, Object> sourceMap = OBJECT_MAPPER.convertValue(source, Map.class);\n    Map<String, Object> targetMap = OBJECT_MAPPER.convertValue(target, Map.class);\n\n    if (acceptedFieldNames.isEmpty()) {\n        acceptedFieldNames = getJsonPropertyValues(clazz);\n    }\n\n    for (String fieldName : acceptedFieldNames) {\n        if (sourceMap.containsKey(fieldName)) {\n            targetMap.put(fieldName, sourceMap.get(fieldName));\n        }\n    }\n\n    return OBJECT_MAPPER.convertValue(targetMap, clazz);\n}\n```\n", "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    try {\n        ObjectMapper mapper = new ObjectMapper();\n        String sourceJson = mapper.writeValueAsString(source);\n        String targetJson = mapper.writeValueAsString(target);\n\n        JsonNode sourceNode = mapper.readTree(sourceJson);\n        JsonNode targetNode = mapper.readTree(targetJson);\n\n        if (acceptedFieldNames.isEmpty()) {\n            List<String> jsonPropertyValues = getJsonPropertyValues(clazz);\n            acceptedFieldNames.addAll(jsonPropertyValues);\n        }\n\n        Iterator<Map.Entry<String, JsonNode>> sourceIterator = sourceNode.fields();\n        while (sourceIterator.hasNext()) {\n            Map.Entry<String, JsonNode> sourceField = sourceIterator.next();\n            String sourceFieldName = sourceField.getKey();\n            JsonNode sourceFieldValue = sourceField.getValue();\n            if (acceptedFieldNames.contains(sourceFieldName) && !sourceFieldValue.isNull()) {\n                ((ObjectNode) targetNode).set(sourceFieldName, sourceFieldValue);\n            }\n        }\n\n        String mergedJson = mapper.writeValueAsString(targetNode);\n        return mapper.readValue(mergedJson, clazz);\n    } catch (JsonProcessingException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\t/**\n\t * Converts the given JSON string to an Object of the given type.\n\t * @param <T> the type of the object to return.\n\t * @param json the JSON string to convert to an object.\n\t * @param type the type of the object to return.\n\t * @return Object instance of the given type.\n\t */\n\tpublic static <T> T jsonToObject(String json, Class<T> type) {\n\t\ttry {\n\t\t\treturn OBJECT_MAPPER.readValue(json, type);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Failed to json: \" + json, e);\n\t\t}\n\t}\n\n\t/**\n\t * Converts the given object to a JSON string.\n\t * @param object the object to convert to a JSON string.\n\n------------------------------\n------------------------------\npackage org.springframework.ai.reader;\n\nimport java.util.Collections;\nimport java.util.Map;\n\npublic class EmptyJsonMetadataGenerator implements JsonMetadataGenerator {\n\n\tprivate static final Map<String, Object> EMPTY_MAP = Collections.emptyMap();\n\n\t@Override\n\tpublic Map<String, Object> generate(Map<String, Object> jsonMap) {\n\t\treturn EMPTY_MAP;\n\t}\n\n}\n\n------------------------------\n------------------------------\n\t * Converts the given JSON string to a Map of String and Object.\n\t * @param json the JSON string to convert to a Map.\n\t * @return the converted Map.\n\t */\n\tpublic static Map<String, Object> jsonToMap(String json) {\n\t\ttry {\n\t\t\treturn OBJECT_MAPPER.readValue(json, MAP_TYPE_REF);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\tprivate static TypeReference<HashMap<String, Object>> MAP_TYPE_REF = new TypeReference<HashMap<String, Object>>() {\n\t};\n\n\t/**\n\t * Converts the given JSON string to an Object of the given type.\n\t * @param <T> the type of the object to return.\n\t * @param json the JSON string to convert to an object.\n\n------------------------------\n------------------------------\n\n\tpublic Map<String, Object> getRawMap() {\n\t\treturn map;\n\t}\n\n}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\t/**\n\t * Converts the given Map to the given class.\n\t * @param <T> the type of the class to return.\n\t * @param source the Map to convert to the given class.\n\t * @param clazz the class to convert the Map to.\n\t * @return the converted class.\n\t */\n\tpublic static <T> T mapToClass(Map<String, Object> source, Class<T> clazz) {\n\t\ttry {\n\t\t\tString json = OBJECT_MAPPER.writeValueAsString(source);\n\t\t\treturn OBJECT_MAPPER.readValue(json, clazz);\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<String, Object> objectToMap(Object source) {\n# Natural Language Annotations: /**\n\t * Converts the given object to a Map.\n\t * @param source the object to convert to a Map.\n\t * @return the converted Map.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        String json = OBJECT_MAPPER.writeValueAsString(source);\n        return OBJECT_MAPPER.readValue(json, MAP_TYPE_REF);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        String json = OBJECT_MAPPER.writeValueAsString(source);\n        return OBJECT_MAPPER.readValue(json, MAP_TYPE_REF);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        String json = OBJECT_MAPPER.writeValueAsString(source);\n        return OBJECT_MAPPER.readValue(json, MAP_TYPE_REF);\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\t/**\n\t * Converts the given JSON string to an Object of the given type.\n\t * @param <T> the type of the object to return.\n\t * @param json the JSON string to convert to an object.\n\t * @param type the type of the object to return.\n\t * @return Object instance of the given type.\n\t */\n\tpublic static <T> T jsonToObject(String json, Class<T> type) {\n\t\ttry {\n\t\t\treturn OBJECT_MAPPER.readValue(json, type);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Failed to json: \" + json, e);\n\t\t}\n\t}\n\n\t/**\n\t * Converts the given object to a JSON string.\n\t * @param object the object to convert to a JSON string.\n\n------------------------------\n------------------------------\n\n        ResponseEntity<T> responseEntity = restTemplate.exchange(requestEntity, returnType);\n\n        if (responseEntity.getStatusCode().is2xxSuccessful()) {\n            return responseEntity;\n        } else {\n            // The error handler built into the RestTemplate should handle 400 and 500 series errors.\n            throw new RestClientException(\"API returned \" + responseEntity.getStatusCode() + \" and it wasn't handled by the RestTemplate error handler\");\n        }\n    }\n    \n    /**\n     * Add headers to the request that is being built\n     * @param headers The headers to add\n     * @param requestBuilder The current request\n     */\n    protected void addHeadersToRequest(HttpHeaders headers, BodyBuilder requestBuilder) {\n        for (Entry<String, List<String>> entry : headers.entrySet()) {\n            List<String> values = entry.getValue();\n            for(String value : values) {\n\n------------------------------\n------------------------------\n\t */\n\tpublic static <T> T mapToClass(Map<String, Object> source, Class<T> clazz) {\n\t\ttry {\n\t\t\tString json = OBJECT_MAPPER.writeValueAsString(source);\n\t\t\treturn OBJECT_MAPPER.readValue(json, clazz);\n\t\t}\n\t\tcatch (JsonProcessingException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the list of name values of the {@link JsonProperty} annotations.\n\t * @param clazz the class that contains fields annotated with {@link JsonProperty}.\n\t * @return the list of values of the {@link JsonProperty} annotations.\n\t */\n\tpublic static List<String> getJsonPropertyValues(Class<?> clazz) {\n\t\tList<String> values = new ArrayList<>();\n\t\tField[] fields = clazz.getDeclaredFields();\n\t\tfor (Field field : fields) {\n\n------------------------------\n------------------------------\n\t */\n\tprivate static <T> T newInstance(Class<?>[] argumentTypes, Class<T> clazz, Object... args) {\n\t\ttry {\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tConstructor<T> constructor = (Constructor<T>) clazz.getDeclaredConstructor(argumentTypes);\n\t\t\tconstructor.setAccessible(true);\n\t\t\treturn constructor.newInstance(args);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Set the value of a private field in the given class instance.\n\t * @param classInstance the class instance to set the field on.\n\t * @param fieldName the name of the field to set.\n\t * @param fieldValue the value to set the field to.\n\t */\n\tprivate static void setField(Object classInstance, String fieldName, Object fieldValue) {\n\n------------------------------\n------------------------------\n\t */\n\tpublic static List<String> getJsonPropertyValues(Class<?> clazz) {\n\t\tList<String> values = new ArrayList<>();\n\t\tField[] fields = clazz.getDeclaredFields();\n\t\tfor (Field field : fields) {\n\t\t\tJsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\t\t\tif (jsonPropertyAnnotation != null) {\n\t\t\t\tvalues.add(jsonPropertyAnnotation.value());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param targetBeanClazz the target class, a subclass of the ChatOptions, to convert\n\t * into.\n\t * @param <T> the target class type.\n\t * @return a new instance of the targetBeanClazz with the values from the sourceBean\n\t * instance.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    try {\n        T targetBean = targetBeanClazz.getConstructor().newInstance();\n        for (Method sourceInterfaceMethod : sourceInterfaceClazz.getMethods()) {\n            String sourceInterfaceMethodName = sourceInterfaceMethod.getName();\n            Field sourceBeanField = sourceBean.getClass().getDeclaredField(sourceInterfaceMethodName);\n            sourceBeanField.setAccessible(true);\n            Object sourceBeanFieldValue = sourceBeanField.get(sourceBean);\n            Field targetBeanField = targetBeanClazz.getDeclaredField(sourceInterfaceMethodName);\n            targetBeanField.setAccessible(true);\n            targetBeanField.set(targetBean, sourceBeanFieldValue);\n        }\n        return targetBean;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    try {\n        Method[] methods = sourceInterfaceClazz.getMethods();\n        T targetBean = targetBeanClazz.getDeclaredConstructor().newInstance();\n\n        for (Method method : methods) {\n            String fieldName = method.getName();\n            Field sourceField = sourceBean.getClass().getDeclaredField(fieldName);\n\n            sourceField.setAccessible(true);\n            Object fieldValue = sourceField.get(sourceBean);\n\n            Field targetField = targetBeanClazz.getDeclaredField(fieldName);\n            targetField.setAccessible(true);\n            targetField.set(targetBean, fieldValue);\n        }\n        return targetBean;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    Field[] fields = sourceInterfaceClazz.getDeclaredFields();\n    try {\n        T targetBeanInstance = targetBeanClazz.getDeclaredConstructor().newInstance();\n        for (Field field : fields) {\n            field.setAccessible(true);\n            String fieldName = field.getName();\n            Field sourceField = sourceBean.getClass().getDeclaredField(fieldName);\n            sourceField.setAccessible(true);\n            Object value = sourceField.get(sourceBean);\n            field.set(targetBeanInstance, value);\n        }\n        return targetBeanInstance;\n    } catch (NoSuchFieldException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n\t/**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\n------------------------------\n------------------------------\n\tpublic Object remove(Object key) {\n\t\treturn this.map.remove(key);\n\t}\n\n\t/**\n\t * Gets an entry from the context. Throws exception when entry is not present.\n\t * @param key key\n\t * @param <T> value type\n\t * @throws IllegalArgumentException if not present\n\t * @return entry\n\t */\n\t@Override\n\t@NonNull\n\tpublic <T> T getRequired(Object key) {\n\t\tT object = (T) this.map.get(key);\n\t\tif (object == null) {\n\t\t\tthrow new IllegalArgumentException(\"Context does not have an entry for key [\" + key + \"]\");\n\t\t}\n\t\treturn object;\n\t}\n\n------------------------------\n------------------------------\n * String before sending it to the Model. Provide a custom function responseConverter\n * implementation to override this.\n *\n */\npublic class FunctionCallbackWrapper<I, O> extends AbstractFunctionCallback<I, O> {\n\n\tprivate final Function<I, O> function;\n\n\tprivate FunctionCallbackWrapper(String name, String description, String inputTypeSchema, Class<I> inputType,\n\t\t\tFunction<O, String> responseConverter, ObjectMapper objectMapper, Function<I, O> function) {\n\t\tsuper(name, description, inputTypeSchema, inputType, responseConverter, objectMapper);\n\t\tAssert.notNull(function, \"Function must not be null\");\n\t\tthis.function = function;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <I, O> Class<I> resolveInputType(Function<I, O> function) {\n\t\treturn (Class<I>) TypeResolverHelper.getFunctionInputClass((Class<Function<I, O>>) function.getClass());\n\t}\n\n\n------------------------------\n------------------------------\n     */\n    protected RestTemplate buildRestTemplate() {\n        RestTemplate restTemplate = new RestTemplate();\n        // This allows us to read the response more than once - Necessary for debugging.\n        restTemplate.setRequestFactory(new BufferingClientHttpRequestFactory(restTemplate.getRequestFactory()));\n        return restTemplate;\n    }\n\n    /**\n     * Update query and header parameters based on authentication settings.\n     *\n     * @param authNames The authentications to apply\n     * @param queryParams The query parameters\n     * @param headerParams The header parameters\n     */\n    private void updateParamsForAuth(String[] authNames, MultiValueMap<String, String> queryParams, HttpHeaders headerParams) {\n        for (String authName : authNames) {\n            Authentication auth = authentications.get(authName);\n            if (auth == null) {\n                throw new RestClientException(\"Authentication undefined: \" + authName);\n\n------------------------------\n------------------------------\n\t */\n\tpublic static List<String> getJsonPropertyValues(Class<?> clazz) {\n\t\tList<String> values = new ArrayList<>();\n\t\tField[] fields = clazz.getDeclaredFields();\n\t\tfor (Field field : fields) {\n\t\t\tJsonProperty jsonPropertyAnnotation = field.getAnnotation(JsonProperty.class);\n\t\t\tif (jsonPropertyAnnotation != null) {\n\t\t\t\tvalues.add(jsonPropertyAnnotation.value());\n\t\t\t}\n\t\t}\n\t\treturn values;\n\t}\n\n\t/**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Method[] sourceMethods = sourceInterfaceClazz.getMethods();\n    for (Method method : sourceMethods) {\n        String methodName = method.getName();\n        if (methodName.startsWith(\"get\")) {\n            String propertyName = methodName.substring(3);\n            try {\n                Object sourceValue = method.invoke(source);\n                if (sourceValue != null) {\n                    Method targetMethod = target.getClass().getMethod(\"set\" + propertyName, method.getReturnType());\n                    if (targetMethod != null) {\n                        Object targetValue = targetMethod.invoke(target);\n                        if (overrideNonNullTargetValues || targetValue == null) {\n                            targetMethod.invoke(target, sourceValue);\n                        }\n                    }\n                }\n            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    return target;\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Field[] sourceFields = source.getClass().getDeclaredFields();\n    Field[] targetFields = target.getClass().getDeclaredFields();\n\n    Map<String, Field> targetFieldsMap = new HashMap<>();\n    for (Field field : targetFields) {\n        targetFieldsMap.put(field.getName(), field);\n    }\n\n    for (Field sourceField : sourceFields) {\n        String sourceFieldName = sourceField.getName();\n        Field targetField = targetFieldsMap.get(sourceFieldName);\n\n        if (targetField == null) {\n            continue;\n        }\n\n        try {\n            Object sourceValue = sourceField.get(source);\n            if (sourceValue != null) {\n                Object targetValue = targetField.get(target);\n                if (overrideNonNullTargetValues || targetValue == null) {\n                    targetField.set(target, sourceValue);\n                }\n            }\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n\n    return target;\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Method[] sourceMethods = sourceInterfaceClazz.getMethods();\n    for (Method sourceMethod : sourceMethods) {\n        try {\n            String getterName = sourceMethod.getName();\n            String setterName = getterName.replace(\"get\", \"set\");\n            Method setterMethod = target.getClass().getMethod(setterName, sourceMethod.getReturnType());\n            Object sourceValue = sourceMethod.invoke(source);\n            if (sourceValue != null) {\n                Object targetValue = setterMethod.invoke(target, sourceValue);\n                if (targetValue == null || overrideNonNullTargetValues) {\n                    setterMethod.invoke(target, sourceValue);\n                }\n            }\n        } catch (Exception e) {\n            // Ignore methods that do not have corresponding getters/setters\n        }\n    }\n    return target;\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    return this;\n  }\n\n  public GenerateParameters addStopItem(String stopItem) {\n    if (this.stop == null) {\n      this.stop = new ArrayList<>();\n    }\n    this.stop.add(stopItem);\n    return this;\n  }\n\n   /**\n   * Get stop\n   * @return stop\n  **/\n  @Schema(example = \"[\\\"photographer\\\"]\", description = \"\")\n  public List<String> getStop() {\n    return stop;\n  }\n\n\n------------------------------\n------------------------------\n        return username;\n    }\n\n    public void setUsername(String username) {\n        this.username = username;\n    }\n\n    public String getPassword() {\n        return password;\n    }\n\n    public void setPassword(String password) {\n        this.password = password;\n    }\n\n    @Override\n    public void applyToParams(MultiValueMap<String, String> queryParams, HttpHeaders headerParams) {\n        if (username == null && password == null) {\n            return;\n        }\n\n------------------------------\n------------------------------\n  FinishReason(String value) {\n    this.value = value;\n  }\n\n  @JsonValue\n  public String getValue() {\n    return value;\n  }\n\n  @Override\n  public String toString() {\n    return String.valueOf(value);\n  }\n\n  @JsonCreator\n  public static FinishReason fromValue(String input) {\n    for (FinishReason b : FinishReason.values()) {\n      if (b.value.equals(input)) {\n        return b;\n      }\n\n------------------------------\n------------------------------\n\t\t\t\t\thasAnnotation = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn hasAnnotation;\n\t}\n\n\tprivate static Set<Class<?>> discoverJacksonAnnotatedTypesFromRootType(Class<?> type) {\n\t\tvar jsonTypes = new HashSet<Class<?>>();\n\t\tvar classesToInspect = new HashSet<Class<?>>();\n\t\tclassesToInspect.add(type);\n\t\tclassesToInspect.addAll(Arrays.asList(type.getNestMembers()));\n\t\tfor (var n : classesToInspect) {\n\t\t\tif (hasJacksonAnnotations(n)) {\n\t\t\t\tjsonTypes.add(n);\n\t\t\t}\n\t\t}\n\t\treturn jsonTypes;\n\t}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\t/**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageClass The class in the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\n\tpublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(Class<?> packageClass) {\n\t\treturn findJsonAnnotatedClassesInPackage(packageClass.getPackageName());\n\t}\n\n\t/**\n\t * Finds all classes in the specified package that match the given type filter.\n\t * @param packageName The name of the package to scan for classes.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n# Natural Language Annotations: /**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageName The name of the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> jsonAnnotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> allClasses = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JacksonAnnotationsInside.class));\n    for (Class<?> clazz : allClasses) {\n        if (hasJacksonAnnotations(clazz)) {\n            jsonAnnotatedClasses.add(new TypeReference<?>() {\n                @Override\n                public Type getType() {\n                    return clazz;\n                }\n            });\n        }\n    }\n    return jsonAnnotatedClasses;\n}\n```\n", "```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> allClasses = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnore.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnoreProperties.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonProperty.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonPropertyOrder.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonRawValue.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonValue.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonCreator.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonAutoDetect.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonBackReference.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonManagedReference.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIdentityInfo.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnoreProperties.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonFilter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonAnyGetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonAnySetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonSetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonGetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonDeserialize.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonSerialize.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonSubTypes.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JacksonAnnotationsInside.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonTypeInfo.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonTypeName.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonPOJOBuilder.class));\n\n    for (Class<?> clazz : allClasses) {\n        annotatedClasses.add(new TypeReference<?>() {\n            @Override\n            public Type getType() {\n                return clazz;\n            }\n        });\n    }\n\n    return annotatedClasses;\n}\n```\n", "```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> jsonAnnotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> allClasses = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnore.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonProperty.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonPropertyOrder.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonRawValue.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonUnwrapped.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonView.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonManagedReference.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonBackReference.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIdentityInfo.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonAutoDetect.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonFilter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnoreProperties.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonIgnoreType.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonInclude.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonPropertyOrder.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonDeserialize.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonPOJOBuilder.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonValue.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonAnyGetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonAnySetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonGetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonSetter.class));\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JsonCreator.class));\n    for (Class<?> clazz : allClasses) {\n        if (hasJacksonAnnotations(clazz)) {\n            jsonAnnotatedClasses.add(new TypeReference<?>() {\n                @Override\n                public Type getType() {\n                    return clazz;\n                }\n            });\n        }\n    }\n    return jsonAnnotatedClasses;\n}\n```\n"]}, "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\t}\n\n\t@Override\n\tpublic List<AudioTranscription> getResults() {\n\t\treturn List.of(transcript);\n\t}\n\n\t@Override\n\tpublic AudioTranscriptionResponseMetadata getMetadata() {\n\t\treturn transcriptionResponseMetadata;\n\t}\n\n}\n\n------------------------------\n------------------------------\npublic class ListOutputParser extends AbstractConversionServiceOutputParser<List<String>> {\n\n\tpublic ListOutputParser(DefaultConversionService defaultConversionService) {\n\t\tsuper(defaultConversionService);\n\t}\n\n\t@Override\n\tpublic String getFormat() {\n\t\treturn \"\"\"\n\t\t\t\tYour response should be a list of comma separated values\n\t\t\t\teg: `foo, bar, baz`\n\t\t\t\t\"\"\";\n\t}\n\n\t@Override\n\tpublic List<String> parse(String text) {\n\t\treturn getConversionService().convert(text, List.class);\n\t}\n\n}\n\n------------------------------\n------------------------------\n\t\tthis.inputs = inputs;\n\t\tthis.options = options;\n\t}\n\n\t@Override\n\tpublic List<Document> getInstructions() {\n\t\treturn this.inputs;\n\t}\n\n\t@Override\n\tpublic EmbeddingOptions getOptions() {\n\t\treturn this.options;\n\t}\n\n}\n\n------------------------------\n------------------------------\n\t\tthis.textFormatter = textFormatter;\n\t}\n\n\t/**\n\t * Extracts and returns the list of documents from the resource.\n\t * @return List of extracted {@link Document}\n\t */\n\t@Override\n\tpublic List<Document> get() {\n\t\ttry (InputStream stream = this.resource.getInputStream()) {\n\t\t\tthis.parser.parse(stream, this.handler, this.metadata, this.context);\n\t\t\treturn List.of(toDocument(this.handler.toString()));\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Converts the given text to a {@link Document}.\n\n------------------------------\n------------------------------\n\t}\n\n\t/**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic List<Document> get() {\n# Natural Language Annotations: /**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic List<Document> get() {\n    try (InputStream stream = this.resource.getInputStream()) {\n        this.parser.parse(stream, this.handler, this.metadata, this.context);\n        return List.of(toDocument(this.handler.toString()));\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\n@Override\npublic List<Document> get() {\n\ttry (InputStream stream = this.resource.getInputStream()) {\n\t\tthis.parser.parse(stream, this.handler, this.metadata, this.context);\n\t\treturn List.of(toDocument(this.handler.toString()));\n\t}\n\tcatch (Exception e) {\n\t\tthrow new RuntimeException(e);\n\t}\n}\n```\n", "```java\npublic class PDFProcessor extends AbstractProcessor {\n\n    // ... existing code ...\n\n    @Override\n    public List<Document> get() {\n        List<Document> documents = new ArrayList<>();\n        try (InputStream stream = this.resource.getInputStream()) {\n            PDDocument pdfDocument = PDDocument.load(stream);\n            PDFTextStripper stripper = new PDFTextStripper();\n            for (int page = 1; page <= pdfDocument.getNumberOfPages(); page++) {\n                stripper.setStartPage(page);\n                stripper.setEndPage(page);\n                String content = stripper.getText(pdfDocument);\n                String[] paragraphs = content.split(\"\\n\");\n                for (String paragraph : paragraphs) {\n                    Document document = new Document();\n                    document.setText(paragraph);\n                    documents.add(document);\n                }\n            }\n            pdfDocument.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n        return documents;\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    } else if (startIndex >= endIndex) {\n      return;\n    }\n    bitSet.clear(startIndex, endIndex);\n  }\n\n  @Override\n  public int cardinality() {\n    return bitSet.cardinality();\n  }\n\n  @Override\n  public int approximateCardinality() {\n    return bitSet.cardinality();\n  }\n\n  @Override\n  public int prevSetBit(int index) {\n    return bitSet.previousSetBit(index);\n  }\n\n------------------------------\n------------------------------\n\n    private final AtomicLongArray storage;\n\n    public AtomicFixedBitSet(int numBits) {\n        int numLongs = (numBits + 63) >>> 6;\n        storage = new AtomicLongArray(numLongs);\n    }\n\n    private static int index(int bit) {\n        return bit >> 6;\n    }\n\n    private static long mask(int bit) {\n        return 1L << bit;\n    }\n\n    @Override\n    public int length() {\n        return storage.length() << 6;\n    }\n\n------------------------------\n------------------------------\n     * @param storedBits the array to use as backing store\n     * @param numBits the number of bits actually needed\n     */\n    public FixedBitSet(long[] storedBits, int numBits) {\n        this.numWords = bits2words(numBits);\n        if (numWords > storedBits.length) {\n            throw new IllegalArgumentException(\n                    \"The given long array is too small  to hold \" + numBits + \" bits\");\n        }\n        this.numBits = numBits;\n        this.bits = storedBits;\n\n        assert verifyGhostBitsClear();\n    }\n\n    @Override\n    public void clear() {\n        Arrays.fill(bits, 0L);\n    }\n\n\n------------------------------\n------------------------------\n        }\n\n        bits[startWord] &= startmask;\n        Arrays.fill(bits, startWord + 1, endWord, 0L);\n        bits[endWord] &= endmask;\n    }\n\n    @Override\n    public FixedBitSet clone() {\n        long[] bits = new long[this.bits.length];\n        System.arraycopy(this.bits, 0, bits, 0, numWords);\n        return new FixedBitSet(bits, numBits);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof FixedBitSet)) {\n\n------------------------------\n------------------------------\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof FixedBitSet)) {\n            return false;\n        }\n        FixedBitSet other = (FixedBitSet) o;\n        if (numBits != other.numBits) {\n            return false;\n        }\n        // Depends on the ghost bits being clear!\n        return Arrays.equals(bits, other.bits);\n    }\n\n    @Override\n    public int hashCode() {\n        // Depends on the ghost bits being clear!\n        long h = 0;\n        for (int i = numWords; --i >= 0; ) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n# Natural Language Annotations: /**\n     * If the given {@link FixedBitSet} is large enough to hold {@code numBits+1}, returns the given\n     * bits, otherwise returns a new {@link FixedBitSet} which can hold the requested number of bits.\n     *\n     * <p><b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of the given {@code\n     * bits} if possible. Also, calling {@link #length()} on the returned bits may return a value\n     * greater than {@code numBits}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() < numBits + 1) {\n        long[] newBits = new long[bits2words(numBits + 1)];\n        System.arraycopy(bits.bits, 0, newBits, 0, bits.numWords);\n        return new FixedBitSet(newBits, numBits);\n    } else {\n        return bits;\n    }\n}\n```\n", "```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() < numBits + 1) {\n        int newNumWords = bits2words(numBits + 1);\n        long[] newBits = new long[newNumWords];\n        System.arraycopy(bits.bits, 0, newBits, 0, bits.numWords);\n        bits = new FixedBitSet(newBits, numBits);\n    }\n    return bits;\n}\n```\n", "```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    int numWords = (numBits + 63) >>> 6;\n    if (numWords <= bits.numWords) {\n        return bits;\n    }\n\n    long[] storedBits = new long[numWords];\n    System.arraycopy(bits.bits, 0, storedBits, 0, bits.numWords);\n    return new FixedBitSet(storedBits, numBits);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        @Override\n        public NodesIterator getNeighborsIterator(int ordinal) {\n            var node = cache.getNode(ordinal);\n            if (node != null) {\n                return new NodesIterator.ArrayNodesIterator(node.neighbors, node.neighbors.length);\n            }\n            return view.getNeighborsIterator(ordinal);\n        }\n\n        @Override\n        public int size() {\n            return view.size();\n        }\n\n        @Override\n        public int entryNode() {\n            return view.entryNode();\n        }\n\n        @Override\n\n------------------------------\n------------------------------\n            return null;\n        }\n\n        return objects.get(key);\n    }\n\n    private void ensureCapacity(int node) {\n        if (node < objects.length()) {\n            return;\n        }\n\n        rwl.writeLock().lock();\n        try {\n            var oldArray = objects;\n            if (node >= oldArray.length()) {\n                int newSize = ArrayUtil.oversize(node + 1, RamUsageEstimator.NUM_BYTES_OBJECT_REF);\n                var newArray = new AtomicReferenceArray<T>(newSize);\n                for (int i = 0; i < oldArray.length(); i++) {\n                    newArray.set(i, oldArray.get(i));\n                }\n\n------------------------------\n------------------------------\n\n\n    @FunctionalInterface\n    public interface IntBiConsumer<T> {\n        void consume(int key, T value);\n    }\n}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    public boolean containsKey(int key) {\n        return get(key) != null;\n    }\n\n    public NodesIterator keysIterator() {\n        // implemented here because we can't make it threadsafe AND performant elsewhere\n        var minSize = size(); // if keys are added concurrently we will miss them\n        var ref = objects;\n        var keysInts = IntStream.range(0, ref.length()).filter(i -> ref.get(i) != null).iterator();\n        return NodesIterator.fromPrimitiveIterator(keysInts, minSize);\n    }\n\n    /**\n\n------------------------------\n------------------------------\n        var keysInts = IntStream.range(0, ref.length()).filter(i -> ref.get(i) != null).iterator();\n        return NodesIterator.fromPrimitiveIterator(keysInts, minSize);\n    }\n\n    /**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\n\n\n\n\n\n\n\n\n\n\n    @FunctionalInterface\n    public interface IntBiConsumer<T> {\n        void consume(int key, T value);\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void forEach(IntBiConsumer<T> consumer) {\n# Natural Language Annotations: /**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    int minSize = size(); // if keys are added concurrently we will miss them\n    var ref = objects;\n    for (int i = 0; i < ref.length(); i++) {\n        T value = ref.get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```\n", "```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    keysIterator().forEachRemaining(key -> {\n        T value = get((int) key);\n        if (value != null) {\n            consumer.consume((int) key, value);\n        }\n    });\n}\n```\n", "```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    var ref = objects;\n    for (int i = 0; i < ref.length(); i++) {\n        T value = ref.get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n    public NodeArray copy() {\n        return copy(size);\n    }\n\n    public NodeArray copy(int newSize) {\n        if (size > newSize) {\n            throw new IllegalArgumentException(\"Cannot copy to a smaller size\");\n        }\n\n        NodeArray copy = new NodeArray(newSize);\n        copy.size = size;\n\n------------------------------\n------------------------------\n\n    @VisibleForTesting\n    long[] getHeapArray() {\n        return heap;\n    }\n}\n\n------------------------------\n------------------------------\n\n  @Override\n  public int prevSetBit(int index) {\n    return bitSet.previousSetBit(index);\n  }\n\n  @Override\n  public int nextSetBit(int i) {\n    int next = bitSet.nextSetBit(i);\n    if (next == -1) {\n      next = DocIdSetIterator.NO_MORE_DOCS;\n    }\n    return next;\n  }\n\n  @Override\n  public long ramBytesUsed() {\n    throw new UnsupportedOperationException();\n  }\n}\n\n------------------------------\n------------------------------\n\n    /**\n     * Returns the least element of the LongHeap in constant time. It is up to the caller to verify\n     * that the heap is not empty; no checking is done, and if no elements have been added, 0 is\n     * returned.\n     */\n    public final long top() {\n        return heap[1];\n    }\n\n    /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\n\n\n\n\n\n\n------------------------------\n------------------------------\n        if (points.isEmpty()) {\n            throw new IllegalArgumentException(\"Can't compute centroid of empty points list\");\n        }\n\n        VectorFloat<?> centroid = sum(points);\n        scale(centroid, 1.0f / points.size());\n\n        return centroid;\n    }\n\n    public VectorFloat<?> getCentroids() {\n        return centroids;\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public final long pop() {\n# Natural Language Annotations: /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"The LongHeap is empty\");\n    }\n    long min = heap[1];\n    heap[1] = heap[size--];\n    heapify(1);\n    return min;\n}\n```\n", "```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"The LongHeap is empty\");\n    }\n    long min = heap[1];\n    heap[1] = heap[size--];\n    sink(1);\n    return min;\n}\n```\n", "```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"The PriorityQueue is empty\");\n    }\n\n    long min = heap[1];\n    heap[1] = heap[size--];\n    heapify(1);\n\n    return min;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n------------------------------\n            return;\n        }\n\n        bits[startWord] |= startmask;\n        Arrays.fill(bits, startWord + 1, endWord, -1L);\n        bits[endWord] |= endmask;\n    }\n\n    @Override\n    public void clear(int startIndex, int endIndex) {\n        assert startIndex >= 0 && startIndex < numBits\n                : \"startIndex=\" + startIndex + \", numBits=\" + numBits;\n        assert endIndex >= 0 && endIndex <= numBits : \"endIndex=\" + endIndex + \", numBits=\" + numBits;\n        if (endIndex <= startIndex) {\n            return;\n        }\n\n        int startWord = startIndex >> 6;\n        int endWord = (endIndex - 1) >> 6;\n\n\n------------------------------\n------------------------------\n        assert startIndex >= 0 && startIndex < numBits\n                : \"startIndex=\" + startIndex + \", numBits=\" + numBits;\n        assert endIndex >= 0 && endIndex <= numBits : \"endIndex=\" + endIndex + \", numBits=\" + numBits;\n        if (endIndex <= startIndex) {\n            return;\n        }\n\n        int startWord = startIndex >> 6;\n        int endWord = (endIndex - 1) >> 6;\n\n        long startmask = -1L << startIndex;\n        long endmask = -1L >>> -endIndex;\n\n        if (startWord == endWord) {\n            bits[startWord] |= (startmask & endmask);\n            return;\n        }\n\n        bits[startWord] |= startmask;\n        Arrays.fill(bits, startWord + 1, endWord, -1L);\n\n------------------------------\n------------------------------\n        super(initialSize);\n        this.maxSize = maxSize;\n    }\n\n    public void setMaxSize(int maxSize) {\n        if (size > maxSize) {\n            throw new IllegalArgumentException(\"Cannot set maxSize smaller than current size\");\n        }\n        this.maxSize = maxSize;\n    }\n\n    @Override\n    public boolean push(long value) {\n        if (size >= maxSize) {\n            if (value < heap[1]) {\n                return false;\n            }\n            updateTop(value);\n            return true;\n        }\n\n------------------------------\n------------------------------\n        }\n        heap[i] = value; // install saved value\n    }\n\n    protected void downHeap(int i) {\n        long value = heap[i]; // save top value\n        int j = i << 1; // find smaller child\n        int k = j + 1;\n        if (k <= size && heap[k] < heap[j]) {\n            j = k;\n        }\n        while (j <= size && heap[j] < value) {\n            heap[i] = heap[j]; // shift up child\n            i = j;\n            j = i << 1;\n            k = j + 1;\n            if (k <= size && heap[k] < heap[j]) {\n                j = k;\n            }\n        }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @VisibleForTesting    long updateTop(long value) {\n# Natural Language Annotations: /**\n     * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n     * Should be called when the top value changes.\n     * Still log(n) worst case, but it's at least twice as fast to\n     *\n     * <pre class=\"prettyprint\">\n     * pq.updateTop(value);\n     * </pre>\n     * <p>\n     * instead of\n     *\n     * <pre class=\"prettyprint\">\n     * pq.pop();\n     * pq.push(value);\n     * </pre>\n     * <p>\n     * Calling this method on an empty BoundedLongHeap has no visible effect.\n     *\n     * @param value the new element that is less than the current top.\n     * @return the new 'top' element after shuffling the heap.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size > 0) {\n        heap[1] = value;\n        downHeap(1);\n    }\n    return heap[1];\n}\n```\n", "```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size > 0) {\n        heap[1] = value; // replace the top of the heap\n        downHeap(1); // enforce the heap invariant\n    }\n    return heap[1];\n}\n```\n", "```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size > 0 && value < heap[1]) {\n        heap[1] = value;\n        downHeap(1);\n    }\n    return heap[1];\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n  public VectorFloat<?> sum(List<VectorFloat<?>> vectors) {\n\n    VectorFloat<?> sum = new ArrayVectorFloat(vectors.get(0).length());\n    for (VectorFloat<?> vector : vectors) {\n      for (int i = 0; i < vector.length(); i++) {\n        sum.set(i, sum.get(i) + vector.get(i));\n      }\n    }\n    return sum;\n  }\n\n  @Override\n  public float sum(VectorFloat<?> vector) {\n    float sum = 0;\n    for (int i = 0; i < vector.length(); i++) {\n      sum += vector.get(i);\n    }\n\n    return sum;\n  }\n\n------------------------------\n------------------------------\n  public float squareDistance(VectorFloat<?> av, int aoffset, VectorFloat<?> bv, int boffset, int length)\n  {\n    float[] a = ((ArrayVectorFloat) av).get();\n    float[] b = ((ArrayVectorFloat) bv).get();\n\n    float squareSum = 0f;\n    for (int i = 0; i < length; i++) {\n      float diff = a[aoffset + i] - b[boffset + i];\n      squareSum += diff * diff;\n    }\n\n    return squareSum;\n  }\n\n  @Override\n  public VectorFloat<?> sum(List<VectorFloat<?>> vectors) {\n\n    VectorFloat<?> sum = new ArrayVectorFloat(vectors.get(0).length());\n    for (VectorFloat<?> vector : vectors) {\n      for (int i = 0; i < vector.length(); i++) {\n\n------------------------------\n------------------------------\n     *\n     * @return one bit per original f32\n     */\n    @Override\n    public long[] encode(VectorFloat<?> v) {\n        int M = (int) Math.ceil(v.length() / 64.0);\n        long[] encoded = new long[M];\n        for (int i = 0; i < M; i++) {\n            long bits = 0;\n            for (int j = 0; j < 64; j++) {\n                int idx = i * 64 + j;\n                if (idx >= v.length()) {\n                    break;\n                }\n                if (v.get(idx) > 0) {\n                    bits |= 1L << j;\n                }\n            }\n            encoded[i] = bits;\n        }\n\n------------------------------\n------------------------------\n      sum += data.get(dataBase * i + Byte.toUnsignedInt(baseOffsets.get(i)));\n    }\n    return sum;\n  }\n\n  @Override\n  public int hammingDistance(long[] v1, long[] v2) {\n    int hd = 0;\n    for (int i = 0; i < v1.length; i++) {\n      hd += Long.bitCount(v1[i] ^ v2[i]);\n    }\n    return hd;\n  }\n\n  @Override\n  public void calculatePartialSums(VectorFloat<?> codebook, int codebookIndex, int size, int clusterCount, VectorFloat<?> query, int queryOffset, VectorSimilarityFunction vsf, VectorFloat<?> partialSums) {\n    int codebookBase = codebookIndex * clusterCount;\n    for (int i = 0; i < clusterCount; i++) {\n      switch (vsf) {\n        case DOT_PRODUCT:\n\n------------------------------\n------------------------------\n            return new BQVectors(bq, compressedVectors);\n        }\n        int compressedLength = in.readInt();\n        if (compressedLength < 0) {\n            throw new IOException(\"Invalid compressed vector dimension \" + compressedLength);\n        }\n\n        // read the compressed vectors\n        for (int i = 0; i < size; i++)\n        {\n            long[] vector = new long[compressedLength];\n            in.readFully(vector);\n            compressedVectors[i] = vector;\n        }\n\n        return new BQVectors(bq, compressedVectors);\n    }\n\n    @Override\n    public ScoreFunction.ApproximateScoreFunction precomputedScoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n     * is a useful approximation for cosine distance and not really anything else.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return (VectorFloat<?> v) -> {\n        long[] v1 = encode(q);\n        long[] v2 = encode(v);\n        int hd = hammingDistance(v1, v2);\n        return 1.0f - ((float) hd) / v1.length;\n    };\n}\n```\n", "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    long[] qEncoded = encode(q);\n    VectorFloat<?> qEncodedVector = new ArrayVectorFloat(qEncoded.length * 64);\n    for (int i = 0; i < qEncoded.length; i++) {\n        for (int j = 0; j < 64; j++) {\n            qEncodedVector.set(i * 64 + j, (qEncoded[i] >> j) & 1);\n        }\n    }\n    return (c, offset, length) -> {\n        long[] cEncoded = encode(c);\n        int hd = hammingDistance(qEncoded, cEncoded);\n        return -hd;\n    };\n}\n```\n", "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public float score(VectorFloat<?> v) {\n            if (v.length() != q.length()) {\n                throw new IllegalArgumentException(\"vectors must have the same length\");\n            }\n            long[] vec1 = encode(q);\n            long[] vec2 = encode(v);\n            return hammingDistance(vec1, vec2);\n        }\n\n        @Override\n        public VectorFloat<?> apply(VectorFloat<?> v) {\n            throw new UnsupportedOperationException(\"score function does not support apply operation\");\n        }\n\n        @Override\n        public String toString() {\n            return \"HammingDistance\";\n        }\n    };\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                             int dimension,\n                             int M,\n                             int beamWidth,\n                             float neighborOverflow,\n                             float alpha,\n                             ForkJoinPool simdExecutor,\n                             ForkJoinPool parallelExecutor)\n    {\n        this.scoreProvider = scoreProvider;\n        this.dimension = dimension;\n        this.neighborOverflow = neighborOverflow;\n        this.alpha = alpha;\n        if (M <= 0) {\n            throw new IllegalArgumentException(\"maxConn must be positive\");\n        }\n        if (beamWidth <= 0) {\n            throw new IllegalArgumentException(\"beamWidth must be positive\");\n        }\n        this.beamWidth = beamWidth;\n        this.simdExecutor = simdExecutor;\n\n------------------------------\n------------------------------\n     * <p>\n     * The initial centroids provided as a parameter are copied before modification.\n     *\n     * @param points the points to cluster (points[n][i] is the ith component of the nth point)\n     * @param centroids the initial centroids.\n     * @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of `UNWEIGHTED` for normal isotropic L2 distance.\n     *        anisotropicThreshold is only valid when the supplied points are normalized to unit length.\n     */\n    public KMeansPlusPlusClusterer(VectorFloat<?>[] points, VectorFloat<?> centroids, float anisotropicThreshold) {\n        if (Float.isNaN(anisotropicThreshold) || anisotropicThreshold < -1.0 || anisotropicThreshold >= 1.0) {\n            // We use the weight function I(t >= T) from section 3.2 of the AVQ paper, which only considers\n            // quantization loss when the dot product is above a threshold T.  For unit vectors, the dot product\n            // is between -1 and 1, so the valid range for T is -1 <= t < 1.\n            throw new IllegalArgumentException(\"Valid range for anisotropic threshold T is -1.0 <= t < 1.0\");\n        }\n\n        this.points = points;\n        this.k = centroids.length() / points[0].length();\n\n------------------------------\n------------------------------\n        size += Integer.BYTES; // globalCentroidLength\n        if (globalCentroid != null) {\n            size += Float.BYTES * globalCentroid.length();\n        }\n        size += Integer.BYTES; // M\n        size += Integer.BYTES * M; // subvectorSizesAndOffsets (only the sizes are written)\n        size += Float.BYTES; // anisotropicThreshold\n        size += Integer.BYTES; // clusterCount\n        for (int i = 0; i < M; i++) {\n            size += Float.BYTES * codebooks[i].length();\n        }\n        return size;\n    }\n\n    public static ProductQuantization load(RandomAccessReader in) throws IOException {\n        int maybeMagic = in.readInt();\n        int version;\n        int globalCentroidLength;\n        if (maybeMagic != MAGIC) {\n            // JVector 1+2 format, no magic or version, starts straight off with the centroid length\n\n------------------------------\n------------------------------\n            throw new IllegalArgumentException(\"Valid range for anisotropic threshold T is -1.0 <= t < 1.0\");\n        }\n\n        this.points = points;\n        this.k = centroids.length() / points[0].length();\n        this.centroids = centroids.copy();\n        this.anisotropicThreshold = anisotropicThreshold;\n\n        centroidDenoms = new int[k];\n        // initialize with empty vectors\n        centroidNums = new VectorFloat<?>[k];\n        for (int i = 0; i < centroidNums.length; i++) {\n            centroidNums[i] = vectorTypeSupport.createFloatVector(points[0].length());\n        }\n        assignments = new int[points.length];\n\n        initializeAssignedPoints();\n    }\n\n    /**\n\n------------------------------\n------------------------------\n\n    /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     */\n    public static ProductQuantization compute(RandomAccessVectorValues ravv, int M, int clusterCount, boolean globallyCenter) {\n        return compute(ravv, M, clusterCount, globallyCenter, UNWEIGHTED, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n    }\n\n    public static ProductQuantization compute(RandomAccessVectorValues ravv, int M, int clusterCount, boolean globallyCenter, float anisotropicThreshold) {\n        return compute(ravv, M, clusterCount, globallyCenter, anisotropicThreshold, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n    }\n\n    /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ProductQuantization compute(\n# Natural Language Annotations: /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param clusterCount number of clusters per subspace\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     * @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n     *                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static ProductQuantization compute(RandomAccessVectorValues ravv, int M, int clusterCount, boolean globallyCenter, float anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    if (ravv == null) {\n        throw new IllegalArgumentException(\"ravv must not be null\");\n    }\n    if (M <= 0) {\n        throw new IllegalArgumentException(\"M must be positive\");\n    }\n    if (clusterCount <= 0) {\n        throw new IllegalArgumentException(\"clusterCount must be positive\");\n    }\n    if (Float.isNaN(anisotropicThreshold) || anisotropicThreshold < -1.0 || anisotropicThreshold >= 1.0) {\n        throw new IllegalArgumentException(\"Valid range for anisotropic threshold T is -1.0 <= t < 1.0\");\n    }\n    // Your code goes here\n}\n```\n", "```java\npublic static ProductQuantization compute(RandomAccessVectorValues ravv, int M, int clusterCount, boolean globallyCenter, float anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    if (ravv == null) {\n        throw new IllegalArgumentException(\"ravv must not be null\");\n    }\n    if (M <= 0) {\n        throw new IllegalArgumentException(\"M must be positive\");\n    }\n    if (clusterCount <= 0) {\n        throw new IllegalArgumentException(\"clusterCount must be positive\");\n    }\n    if (Float.isNaN(anisotropicThreshold) || anisotropicThreshold < -1.0 || anisotropicThreshold >= 1.0) {\n        throw new IllegalArgumentException(\"Valid range for anisotropic threshold T is -1.0 <= t < 1.0\");\n    }\n    if (simdExecutor == null || parallelExecutor == null) {\n        throw new IllegalArgumentException(\"Both simdExecutor and parallelExecutor must not be null\");\n    }\n\n    VectorFloat<?>[] points = ravv.getRandomAccessValues();\n    VectorFloat<?> centroids = VectorUtils.createRandom(ravv.getEuclideanLength(), M * clusterCount);\n    ProductQuantization productQuantization = new ProductQuantization(points, centroids, anisotropicThreshold);\n    // do something with productQuantization\n    return productQuantization;\n}\n```\n", "```java\npublic static ProductQuantization compute(\n        RandomAccessVectorValues ravv, \n        int M, \n        int clusterCount, \n        boolean globallyCenter, \n        float anisotropicThreshold, \n        ForkJoinPool simdExecutor, \n        ForkJoinPool parallelExecutor\n) {\n    if (Float.isNaN(anisotropicThreshold) || \n        anisotropicThreshold < -1.0 || \n        anisotropicThreshold >= 1.0\n    ) {\n        throw new IllegalArgumentException(\"Valid range for anisotropic threshold T is -1.0 <= t < 1.0\");\n    }\n\n    int dimension = ravv.getDimension();\n    int beamWidth = globallyCenter ? clusterCount * dimension : clusterCount;\n    float neighborOverflow = globallyCenter ? 0.05f : 0.1f;\n    float alpha = globallyCenter ? 0.001f : 0.005f;\n\n    KMeansPlusPlusClusterer clusterer = new KMeansPlusPlusClusterer(\n        ravv.getVectorArray(), \n        ravv.getVectorArray(), \n        anisotropicThreshold, \n        simdExecutor, \n        parallelExecutor\n    );\n\n    VectorFloat<?>[] points = clusterer.getPoints();\n    VectorFloat<?> centroids = clusterer.getCentroids();\n    float anisotropicThreshold = clusterer.getAnisotropicThreshold();\n    int clusterCount = clusterer.getClusterCount();\n\n    VectorFloat<?>[] codebooks = new VectorFloat<?>[M];\n    for (int i = 0; i < M; i++) {\n        codebooks[i] = vectorTypeSupport.createFloatVector(points[0].length());\n    }\n\n    ProductQuantization pq = new ProductQuantization(\n        points, \n        centroids, \n        anisotropicThreshold, \n        simdExecutor, \n        parallelExecutor\n    );\n\n    return pq;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n * Interface for vector compression.  T is the encoded (compressed) vector type;\n * it will be an array type.\n */\npublic interface VectorCompressor<T> {\n\n    default T[] encodeAll(RandomAccessVectorValues ravv) {\n        return encodeAll(ravv, PhysicalCoreExecutor.pool());\n    }\n\n    @Deprecated\n    default T[] encodeAll(List<VectorFloat<?>> vectors) {\n        return encodeAll(new ListRandomAccessVectorValues(vectors, vectors.get(0).length()),\n                         PhysicalCoreExecutor.pool());\n    }\n\n    T[] encodeAll(RandomAccessVectorValues ravv, ForkJoinPool simdExecutor);\n\n    T encode(VectorFloat<?> v);\n\n    /**\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    static List<VectorFloat<?>> extractTrainingVectors(RandomAccessVectorValues ravv, ForkJoinPool parallelExecutor) {\n        // limit the number of vectors we train on\n        var P = min(1.0f, MAX_PQ_TRAINING_SET_SIZE / (float) ravv.size());\n        var ravvCopy = ravv.threadLocalSupplier();\n\n------------------------------\n------------------------------\n     */\n    @Deprecated\n    public static BinaryQuantization compute(RandomAccessVectorValues ravv) {\n        return compute(ravv, ForkJoinPool.commonPool());\n    }\n\n    /**\n     * Use BQ constructor instead\n     */\n    @Deprecated\n    public static BinaryQuantization compute(RandomAccessVectorValues ravv, ForkJoinPool parallelExecutor) {\n        return new BinaryQuantization(ravv.dimension());\n    }\n\n    @Override\n    public CompressedVectors createCompressedVectors(Object[] compressedVectors) {\n        return new BQVectors(this, (long[][]) compressedVectors);\n    }\n\n    @Override\n\n------------------------------\n------------------------------\n  public VectorFloat<?> sum(List<VectorFloat<?>> vectors) {\n\n    VectorFloat<?> sum = new ArrayVectorFloat(vectors.get(0).length());\n    for (VectorFloat<?> vector : vectors) {\n      for (int i = 0; i < vector.length(); i++) {\n        sum.set(i, sum.get(i) + vector.get(i));\n      }\n    }\n    return sum;\n  }\n\n  @Override\n  public float sum(VectorFloat<?> vector) {\n    float sum = 0;\n    for (int i = 0; i < vector.length(); i++) {\n      sum += vector.get(i);\n    }\n\n    return sum;\n  }\n\n------------------------------\n------------------------------\n\n    /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     */\n    public ProductQuantization refine(RandomAccessVectorValues ravv) {\n        return refine(ravv, 1, UNWEIGHTED, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n    }\n\n    /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ProductQuantization refine(RandomAccessVectorValues ravv,\n# Natural Language Annotations: /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    return refine(ravv, lloydsRounds, UNWEIGHTED, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n}\n```\n", "```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Your code here\n}\n```\n", "```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Your implementation here\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            anisotropicThreshold = UNWEIGHTED;\n        } else {\n            anisotropicThreshold = in.readFloat();\n        }\n\n        int clusters = in.readInt();\n        VectorFloat<?>[] codebooks = new VectorFloat<?>[M];\n        for (int m = 0; m < M; m++) {\n            VectorFloat<?> codebook = vectorTypeSupport.readFloatVector(in, clusters * subvectorSizes[m][0]);\n            codebooks[m] = codebook;\n        }\n\n        return new ProductQuantization(codebooks, clusters, subvectorSizes, globalCentroid, anisotropicThreshold);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        ProductQuantization that = (ProductQuantization) o;\n\n------------------------------\n------------------------------\n        int result = Objects.hash(M, originalDimension);\n        result = 31 * result + Arrays.deepHashCode(codebooks);\n        result = 31 * result + Objects.hashCode(globalCentroid);\n        result = 31 * result + Arrays.deepHashCode(subvectorSizesAndOffsets);\n        return result;\n    }\n\n    /**\n     * @return the centroid of the codebooks\n     */\n    public VectorFloat<?> getOrComputeCentroid() {\n        if (globalCentroid != null) {\n            return globalCentroid;\n        }\n\n        // typically we only precompute the centroid for Euclidean similarity\n        var centroid = vectorTypeSupport.createFloatVector(originalDimension);\n        for (int m = 0; m < M; m++) {\n            for (int i = 0; i < clusterCount; i++) {\n                var subspaceSize = subvectorSizesAndOffsets[m][0];\n\n------------------------------\n------------------------------\n      sum += vector.get(i);\n    }\n\n    return sum;\n  }\n\n  @Override\n  public void scale(VectorFloat<?> vector, float multiplier) {\n    for (int i = 0; i < vector.length(); i++) {\n      vector.set(i, vector.get(i) * multiplier);\n    }\n  }\n\n  @Override\n  public void addInPlace(VectorFloat<?> v1, VectorFloat<?> v2) {\n    for (int i = 0; i < v1.length(); i++) {\n      v1.set(i, v1.get(i) + v2.get(i));\n    }\n  }\n\n\n------------------------------\n------------------------------\n        } else {\n            out.writeInt(globalCentroid.length());\n            vectorTypeSupport.writeFloatVector(out, globalCentroid);\n        }\n\n        out.writeInt(M);\n        assert Arrays.stream(subvectorSizesAndOffsets).mapToInt(m -> m[0]).sum() == originalDimension;\n        assert M == subvectorSizesAndOffsets.length;\n        for (var a : subvectorSizesAndOffsets) {\n            out.writeInt(a[0]);\n        }\n\n        if (version >= 3) {\n            out.writeFloat(anisotropicThreshold);\n        }\n\n        assert codebooks.length == M;\n        out.writeInt(clusterCount);\n        for (int i = 0; i < M; i++) {\n            var codebook = codebooks[i];\n\n------------------------------\n------------------------------\n    private Residual computeResidual(VectorFloat<?> x, VectorFloat<?> centroids, int centroid, float cNormSquared, float xNormSquared, float inverseNorm) {\n        float cDotX = VectorUtil.dotProduct(centroids, centroid * x.length(), x, 0, x.length());\n        float residualNormSquared = cNormSquared - 2 * cDotX + xNormSquared;\n        float parallelErrorSubtotal = cDotX - xNormSquared;\n        float parallelResidualComponent = square(parallelErrorSubtotal) * inverseNorm;\n        return new Residual(residualNormSquared, parallelResidualComponent);\n    }\n\n    private ByteSequence<?> encodeUnweighted(VectorFloat<?> vector) {\n        var encoded = vectorTypeSupport.createByteSequence(M);\n        for (int m = 0; m < M; m++) {\n            encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n        }\n        return encoded;\n    }\n\n    /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        var subspaceSize = subvectorSizesAndOffsets[m][0];\n        var centroids = codebooks[m];\n        var cNormSquared = square(VectorUtil.dotProduct(centroids, subspaceSize * centroids.length(), centroids, 0, subspaceSize));\n        var xNormSquared = square(VectorUtil.dotProduct(vector, subspaceSize, vector, 0, subspaceSize));\n        var inverseNorm = 1 / sqrt(xNormSquared);\n        var bestCentroid = 0;\n        var bestResidual = computeResidual(vector, centroids, bestCentroid, cNormSquared, xNormSquared, inverseNorm);\n        for (int i = 1; i < clusterCount; i++) {\n            var residual = computeResidual(vector, centroids, i, cNormSquared, xNormSquared, inverseNorm);\n            if (residual.residualNormSquared < bestResidual.residualNormSquared) {\n                bestCentroid = i;\n                bestResidual = residual;\n            }\n        }\n        encoded.set(m, (byte) bestCentroid);\n    }\n    return encoded;\n}\n```\n", "```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        float anisotropicThreshold = this.anisotropicThreshold > 0 ? this.anisotropicThreshold : 1;\n        float cNormSquared = VectorUtil.dotProduct(codebooks[m], centroid * subvectorSizesAndOffsets[m][0], codebooks[m], centroid * subvectorSizesAndOffsets[m][0], subvectorSizesAndOffsets[m][0]);\n        float xNormSquared = VectorUtil.dotProduct(vector, 0, vector, 0, subvectorSizesAndOffsets[m][0]);\n        float inverseNorm = 1 / (float) Math.sqrt(xNormSquared);\n        Residual residual = computeResidual(vector, codebooks[m], centroid, cNormSquared, xNormSquared, inverseNorm);\n        float residualNormSquared = residual.residualNormSquared();\n        float parallelResidualComponent = residual.parallelResidualComponent();\n        float orthogonalResidualComponent = residualNormSquared - parallelResidualComponent;\n        float weightedResidualComponent = parallelResidualComponent * anisotropicThreshold + orthogonalResidualComponent;\n        int closestCentroidIndex = closestCentroidIndex(vector, m, codebooks[m]);\n        float residualError = weightedResidualComponent - VectorUtil.dotProduct(codebooks[m], closestCentroidIndex * subvectorSizesAndOffsets[m][0], codebooks[m], closestCentroidIndex * subvectorSizesAndOffsets[m][0], subvectorSizesAndOffsets[m][0]);\n        if (residualError < 0) {\n            closestCentroidIndex = -1;\n        }\n        encoded.set(m, (byte) closestCentroidIndex);\n    }\n    return encoded;\n}\n```\n", "```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        var subspaceSize = subvectorSizesAndOffsets[m][0];\n        float cNormSquared = VectorUtil.dotProduct(vector, subspaceSize);\n        float xNormSquared = VectorUtil.dotProduct(centroids, subspaceSize, centroid * subspaceSize, 0, subspaceSize);\n        float inverseNorm = 1.0f / (1.0f + cNormSquared - 2 * xNormSquared);\n\n        int centroid = closestCentroidIndex(vector, m, codebooks[m]);\n        Residual residual = computeResidual(vector, centroids, centroid, cNormSquared, xNormSquared, inverseNorm);\n\n        if (residual.orthogonalResidualComponent() < anisotropicThreshold * residual.parallelResidualComponent()) {\n            encoded.set(m, (byte) centroid);\n        } else {\n            encoded.set(m, (byte) -1);\n        }\n    }\n    return encoded;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n  public VectorFloat<?> sum(List<VectorFloat<?>> vectors) {\n\n    VectorFloat<?> sum = new ArrayVectorFloat(vectors.get(0).length());\n    for (VectorFloat<?> vector : vectors) {\n      for (int i = 0; i < vector.length(); i++) {\n        sum.set(i, sum.get(i) + vector.get(i));\n      }\n    }\n    return sum;\n  }\n\n  @Override\n  public float sum(VectorFloat<?> vector) {\n    float sum = 0;\n    for (int i = 0; i < vector.length(); i++) {\n      sum += vector.get(i);\n    }\n\n    return sum;\n  }\n\n------------------------------\n------------------------------\n  }\n\n  @Override\n  public float min(VectorFloat<?> v) {\n      float min = Float.MAX_VALUE;\n      for (int i = 0; i < v.length(); i++) {\n        min = Math.min(min, v.get(i));\n      }\n      return min;\n  }\n}\n\n------------------------------\n------------------------------\n        int result = Objects.hash(M, originalDimension);\n        result = 31 * result + Arrays.deepHashCode(codebooks);\n        result = 31 * result + Objects.hashCode(globalCentroid);\n        result = 31 * result + Arrays.deepHashCode(subvectorSizesAndOffsets);\n        return result;\n    }\n\n    /**\n     * @return the centroid of the codebooks\n     */\n    public VectorFloat<?> getOrComputeCentroid() {\n        if (globalCentroid != null) {\n            return globalCentroid;\n        }\n\n        // typically we only precompute the centroid for Euclidean similarity\n        var centroid = vectorTypeSupport.createFloatVector(originalDimension);\n        for (int m = 0; m < M; m++) {\n            for (int i = 0; i < clusterCount; i++) {\n                var subspaceSize = subvectorSizesAndOffsets[m][0];\n\n------------------------------\n------------------------------\n      sum += vector.get(i);\n    }\n\n    return sum;\n  }\n\n  @Override\n  public void scale(VectorFloat<?> vector, float multiplier) {\n    for (int i = 0; i < vector.length(); i++) {\n      vector.set(i, vector.get(i) * multiplier);\n    }\n  }\n\n  @Override\n  public void addInPlace(VectorFloat<?> v1, VectorFloat<?> v2) {\n    for (int i = 0; i < v1.length(); i++) {\n      v1.set(i, v1.get(i) + v2.get(i));\n    }\n  }\n\n\n------------------------------\n------------------------------\n    private Residual computeResidual(VectorFloat<?> x, VectorFloat<?> centroids, int centroid, float cNormSquared, float xNormSquared, float inverseNorm) {\n        float cDotX = VectorUtil.dotProduct(centroids, centroid * x.length(), x, 0, x.length());\n        float residualNormSquared = cNormSquared - 2 * cDotX + xNormSquared;\n        float parallelErrorSubtotal = cDotX - xNormSquared;\n        float parallelResidualComponent = square(parallelErrorSubtotal) * inverseNorm;\n        return new Residual(residualNormSquared, parallelResidualComponent);\n    }\n\n    private ByteSequence<?> encodeUnweighted(VectorFloat<?> vector) {\n        var encoded = vectorTypeSupport.createByteSequence(M);\n        for (int m = 0; m < M; m++) {\n            encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n        }\n        return encoded;\n    }\n\n    /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ByteSequence<?> encode(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```\n", "```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```\n", "```java\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    return encodeUnweighted(vector);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public int size() {\n        return vectors.size();\n    }\n\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n    @Override\n    public VectorFloat<?> getVector(int targetOrd) {\n        return vectors.get(targetOrd);\n    }\n\n    @Override\n    public boolean isValueShared() {\n        return false;\n    }\n\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public void readByteSequence(RandomAccessReader r, ByteSequence<?> sequence) throws IOException {\n        ArrayByteSequence v = (ArrayByteSequence) sequence;\n        r.readFully(v.get());\n    }\n\n    @Override\n    public void writeByteSequence(DataOutput out, ByteSequence<?> sequence) throws IOException\n    {\n        ArrayByteSequence v = (ArrayByteSequence) sequence;\n        out.write(v.get());\n    }\n}\n\n------------------------------\n------------------------------\n\n    void read(float[] floats, int offset, int count) throws IOException;\n\n    void close() throws IOException;\n}\n\n------------------------------\n------------------------------\n\n    return impl.sum(vectors);\n  }\n\n  public static float sum(VectorFloat<?> vector) {\n    return impl.sum(vector);\n  }\n\n  public static void scale(VectorFloat<?> vector, float multiplier) {\n    impl.scale(vector, multiplier);\n  }\n\n  public static void addInPlace(VectorFloat<?> v1, VectorFloat<?> v2) {\n    impl.addInPlace(v1, v2);\n  }\n\n  public static void subInPlace(VectorFloat<?> v1, VectorFloat<?> v2) {\n    impl.subInPlace(v1, v2);\n  }\n\n\n------------------------------\n------------------------------\n\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n    @Override\n    public boolean isValueShared() {\n        return false;\n    }\n\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n\n    @Override\n    public void getVectorInto(int nodeId, VectorFloat<?> result, int offset) {\n        // getVectorInto is only called by reranking, not diversity code\n        throw new UnsupportedOperationException();\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    ArrayByteSequence v = (ArrayByteSequence) sequence;\n    byte[] bytes = v.get();\n    float[] floats = new float[bytes.length];\n    for (int i = 0; i < bytes.length; i++) {\n        floats[i] = (float) bytes[i];\n    }\n    target.add(floats);\n}\n```\n", "```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    float[] decoded = new float[target.size()];\n    decoder.decode(encoded, decoded, 0);\n    for (int i = 0; i < decoded.length; i++) {\n        target.set(i, decoded[i]);\n    }\n}\n```\n", "```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    byte[] encodedBytes = ((ArrayByteSequence) encoded).get();\n    float[] targetFloats = target.get();\n    int dimension = target.dimension();\n\n    for (int i = 0; i < dimension; i++) {\n        targetFloats[i] = encodedBytes[i]; // Assuming the encoding is simple byte to float conversion\n    }\n    target.set(targetFloats);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    VectorFloat<?> createFloatVector(Object data);\n\n    /**\n     * Create a zero-filled vector of the given length.\n     * @param length the length of the vector to create.\n     * @return the created vector.\n     */\n    VectorFloat<?> createFloatVector(int length);\n\n    /**\n     * Read a vector from the given RandomAccessReader.\n     * @param r the reader to read the vector from.\n     * @param size the size of the vector to read.\n     * @return the vector.\n     * @throws IOException\n     */\n    VectorFloat<?> readFloatVector(RandomAccessReader r, int size) throws IOException;\n\n    /**\n     * Read a vector from the given RandomAccessReader and store it in the given vector at the specified offset.\n\n------------------------------\n------------------------------\n     */\n    VectorFloat<?> readFloatVector(RandomAccessReader r, int size) throws IOException;\n\n    /**\n     * Read a vector from the given RandomAccessReader and store it in the given vector at the specified offset.\n     * @param r the reader to read the vector from.\n     * @param size the size of the vector to read.\n     * @param vector the vector to store the read data in.\n     * @param offset the offset in the vector to store the read data at.\n     * @throws IOException\n     */\n    void readFloatVector(RandomAccessReader r, int size, VectorFloat<?> vector, int offset) throws IOException;\n\n    /**\n     * Write the given vector to the given DataOutput.\n     * @param out the output to write the vector to.\n     * @param vector the vector to write.\n     * @throws IOException\n     */\n    void writeFloatVector(DataOutput out, VectorFloat<?> vector) throws IOException;\n\n------------------------------\n------------------------------\n * can be defined as a simple lambda.\n */\npublic interface ScoreFunction {\n    VectorTypeSupport vts = VectorizationProvider.getInstance().getVectorTypeSupport();\n\n    /**\n     * @return true if the ScoreFunction returns exact, full-resolution scores\n     */\n    boolean isExact();\n\n    /**\n     * @return the similarity to one other node\n     */\n    float similarityTo(int node2);\n\n    /**\n     * @return the similarity to all of the nodes that `node2` has an edge towards.\n     * Used when expanding the neighbors of a search candidate.\n     */\n    default VectorFloat<?> edgeLoadingSimilarityTo(int node2) {\n\n------------------------------\n------------------------------\n     * @param out the output to write the vector to.\n     * @param vector the vector to write.\n     * @throws IOException\n     */\n    void writeFloatVector(DataOutput out, VectorFloat<?> vector) throws IOException;\n\n    /**\n     * Create a sequence from the given data.\n     *\n     * @param data the data to create the sequence from. Supported data types are implementation-dependent.\n     * @return the created vector.\n     */\n    ByteSequence<?> createByteSequence(Object data);\n\n    /**\n     * Create a zero-filled sequence of the given length.\n     * @param length the length of the sequence to create.\n     * @return the created sequence.\n     */\n    ByteSequence<?> createByteSequence(int length);\n\n------------------------------\n------------------------------\n   * should only use this function if you need to preserve the original vectors and cannot normalize\n   * them in advance. The similarity score is normalised to assure it is positive.\n   */\n  COSINE {\n    @Override\n    public float compare(VectorFloat<?> v1, VectorFloat<?> v2) {\n      return (1 + VectorUtil.cosine(v1, v2)) / 2;\n    }\n  };\n\n  /**\n   * Calculates a similarity score between the two vectors with a specified function. Higher\n   * similarity scores correspond to closer vectors.\n   *\n   * @param v1 a vector\n   * @param v2 another vector, of the same dimension\n   * @return the value of the similarity function applied to the two vectors\n   */\n  public abstract float compare(VectorFloat<?> v1, VectorFloat<?> v2);\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Implementation goes here\n}\n```\n", "```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // TODO: Implement the decoding logic here\n}\n```\n", "```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // decode the encoded ByteSequence to its approximate original vector\n    VectorFloat<?> decoded = vts.decodeCentered(encoded);\n    // copy the decoded vector to the target vector\n    target.copyFrom(decoded);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * Create a zero-filled sequence of the given length.\n     * @param length the length of the sequence to create.\n     * @return the created sequence.\n     */\n    ByteSequence<?> createByteSequence(int length);\n\n    ByteSequence<?> readByteSequence(RandomAccessReader r, int size) throws IOException;\n\n    void readByteSequence(RandomAccessReader r, ByteSequence<?> sequence) throws IOException;\n\n    void writeByteSequence(DataOutput out, ByteSequence<?> sequence) throws IOException;\n}\n\n------------------------------\n------------------------------\n\npackage io.github.jbellis.jvector.disk;\n\nimport java.io.IOException;\n\npublic interface ReaderSupplier extends AutoCloseable {\n    /**\n     * @return a new reader.  It is up to the caller to re-use these readers or close them,\n     * the ReaderSupplier is not responsible for caching them.\n     */\n    RandomAccessReader get() throws IOException;\n\n    default void close() throws IOException {\n    }\n}\n\n------------------------------\n------------------------------\n\npackage io.github.jbellis.jvector.vector.types;\n\nimport io.github.jbellis.jvector.disk.RandomAccessReader;\n\nimport java.io.DataOutput;\nimport java.io.IOException;\n\npublic interface VectorTypeSupport {\n    /**\n     * Create a vector from the given data.\n     *\n     * @param data the data to create the vector from. Supported data types are implementation-dependent.\n     * @return the created vector.\n     */\n    VectorFloat<?> createFloatVector(Object data);\n\n    /**\n     * Create a zero-filled vector of the given length.\n     * @param length the length of the vector to create.\n\n------------------------------\n------------------------------\n     * @return true always\n     */\n    @Override\n    public boolean push(long element) {\n        add(element);\n        return true;\n    }\n}\n\n------------------------------\n------------------------------\n            sb.append(row.toString());\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public Matrix invert() {\n# Natural Language Annotations: /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic Matrix invert() {\n    // TODO: Implement the invert function\n}\n```\n", "```java\npublic Matrix invert() {\n    int n = this.getRows();\n    Matrix matrix = new Matrix(n, n);\n    Matrix identity = new Matrix(n, n);\n    identity.identity();\n    \n    for (int i = 0; i < n; i++) {\n        double pivot = this.get(i, i);\n        if (pivot == 0) {\n            for (int j = i + 1; j < n; j++) {\n                if (this.get(j, i) != 0) {\n                    this.swapRows(i, j);\n                    identity.swapRows(i, j);\n                    break;\n                }\n            }\n            pivot = this.get(i, i);\n        }\n        for (int j = 0; j < n; j++) {\n            this.set(i, j, this.get(i, j) / pivot);\n            identity.set(i, j, identity.get(i, j) / pivot);\n        }\n        for (int j = 0; j < n; j++) {\n            if (j == i) continue;\n            double scale = this.get(j, i);\n            for (int k = 0; k < n; k++) {\n                this.set(j, k, this.get(j, k) - scale * this.get(i, k));\n                identity.set(j, k, identity.get(j, k) - scale * identity.get(i, k));\n            }\n        }\n    }\n    \n    return matrix;\n}\n```\n", "Sure, here is a basic implementation of the function `invert`. This function uses Gaussian elimination to invert a square matrix.\n\n```java\npublic Matrix invert() {\n    int n = this.getNumRows();\n    Matrix result = new Matrix(n, n);\n\n    // Create an identity matrix\n    for (int i = 0; i < n; i++) {\n        result.set(i, i, 1);\n    }\n\n    // Perform Gaussian elimination\n    for (int i = 0; i < n; i++) {\n        // Normalize the current row\n        double pivot = this.get(i, i);\n        if (pivot != 1) {\n            for (int j = 0; j < n; j++) {\n                this.set(i, j, this.get(i, j) / pivot);\n                result.set(i, j, result.get(i, j) / pivot);\n            }\n        }\n\n        // Eliminate rows below the current row\n        for (int j = i + 1; j < n; j++) {\n            double factor = this.get(j, i);\n            if (factor != 0) {\n                for (int k = 0; k < n; k++) {\n                    this.set(j, k, this.get(j, k) - factor * this.get(i, k));\n                    result.set(j, k, result.get(j, k) - factor * result.get(i, k));\n                }\n            }\n        }\n    }\n\n    // Perform back substitution\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i - 1; j >= 0; j--) {\n            double factor = this.get(j, i);\n            for (int k = 0; k < n; k++) {\n                result.set(j, k, result.get(j, k) - factor * result.get(i, k));\n            }\n        }\n    }\n\n    return result;\n}\n```\n\nPlease note that this is a very basic implementation. It assumes that the `get` and `set` methods of the `Matrix` class work as expected and that the `Matrix` class has a constructor that takes two integers (the number of rows and columns). Also, it does not handle the case where the matrix is not square.\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        for (int i = 0; i < k; i++) {\n            float distance = squareL2Distance(point, 0, centroids, i * point.length(), point.length());\n            if (distance < minDistance) {\n                minDistance = distance;\n                nearestCluster = i;\n            }\n        }\n\n        return nearestCluster;\n    }\n\n    @SuppressWarnings({\"AssertWithSideEffects\", \"ConstantConditions\"})\n    private static void assertFinite(VectorFloat<?> vector) {\n        boolean assertsEnabled = false;\n        assert assertsEnabled = true;\n\n        if (assertsEnabled) {\n            for (int i = 0; i < vector.length(); i++) {\n                assert Float.isFinite(vector.get(i)) : \"vector \" + vector + \" contains non-finite value\";\n\n------------------------------\n------------------------------\n        }\n    }\n\n    public VectorFloat<?> multiply(VectorFloat<?> v) {\n        if (data.length == 0) {\n            throw new IllegalArgumentException(\"Cannot multiply empty matrix\");\n        }\n        if (v.length() == 0) {\n            throw new IllegalArgumentException(\"Cannot multiply empty vector\");\n        }\n\n        var result = vts.createFloatVector(data.length);\n        for (int i = 0; i < data.length; i++) {\n            result.set(i, VectorUtil.dotProduct(data[i], v));\n        }\n        return result;\n    }\n\n    public static Matrix outerProduct(VectorFloat<?> a, VectorFloat<?> b) {\n        var result = new Matrix(a.length(), b.length(), false);\n\n------------------------------\n------------------------------\n    assert Float.isFinite(r) : String.format(\"dotProduct(%s, %s) = %s\", a, b, r);\n    return r;\n  }\n\n  /**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\n\n\n\n\n\n\n\n\n\n  /**\n   * Returns the sum of squared differences of the two vectors.\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n  public static float dotProduct(VectorFloat<?> a, int aoffset, VectorFloat<?> b, int boffset, int length) {\n    //This check impacts FLOPS\n    /*if ( length > Math.min(a.length - aoffset, b.length - boffset) ) {\n      throw new IllegalArgumentException(\"length must be less than the vectors remaining space at the given offsets: a(\" +\n              (a.length - aoffset) + \"), b(\" + (b.length - boffset) + \"), length(\" + length + \")\");\n    }*/\n    float r = impl.dotProduct(a, aoffset, b, boffset, length);\n    assert Float.isFinite(r) : String.format(\"dotProduct(%s, %s) = %s\", a, b, r);\n    return r;\n  }\n\n  /**\n\n------------------------------\n------------------------------\n\n\n\n  /**\n   * Returns the sum of squared differences of the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\n  public static float squareL2Distance(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n      throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n    float r = impl.squareDistance(a, b);\n    assert Float.isFinite(r) : String.format(\"squareDistance(%s, %s) = %s\", a, b, r);\n    return r;\n  }\n\n  /**\n   * Returns the sum of squared differences of the two vectors, or subvectors, of the given length.\n   */\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n# Natural Language Annotations: /**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n        throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n    float dotProduct = dotProduct(a, b);\n    float magnitudeA = squareL2Distance(a, a);\n    float magnitudeB = squareL2Distance(b, b);\n    float cosineSimilarity = dotProduct / (float) (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));\n    assert Float.isFinite(cosineSimilarity) : String.format(\"cosine(%s, %s) = %s\", a, b, cosineSimilarity);\n    return cosineSimilarity;\n}\n```\n", "Sure, here is the function `cosine`:\n\n```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n        throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n    float dotProduct = dotProduct(a, b);\n    float magnitudeA = magnitude(a);\n    float magnitudeB = magnitude(b);\n    if (magnitudeA == 0 || magnitudeB == 0) {\n        throw new IllegalArgumentException(\"One or both of the vectors have zero magnitude\");\n    }\n    return dotProduct / (magnitudeA * magnitudeB);\n}\n```\n", "```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n        throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n\n    float dotProduct = dotProduct(a, b);\n    float magnitudeA = squareL2Distance(a, VectorUtil.createZeroVector(a.length()));\n    float magnitudeB = squareL2Distance(b, VectorUtil.createZeroVector(b.length()));\n\n    //Handle division by zero\n    if (magnitudeA == 0 || magnitudeB == 0) {\n        return 0;\n    }\n\n    return dotProduct / (float) (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n */\npublic class MapRandomAccessVectorValues implements RandomAccessVectorValues {\n    private final Map<Integer, VectorFloat<?>> map;\n    private final int dimension;\n\n    public MapRandomAccessVectorValues(Map<Integer, VectorFloat<?>> map, int dimension) {\n        this.map = map;\n        this.dimension = dimension;\n    }\n\n    @Override\n    public int size() {\n        return map.size();\n    }\n\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n\n------------------------------\n------------------------------\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n    @Override\n    public VectorFloat<?> getVector(int nodeId) {\n        return map.get(nodeId);\n    }\n\n    @Override\n    public boolean isValueShared() {\n        return false;\n    }\n\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n    @Override\n    public boolean isValueShared() {\n        return false;\n    }\n\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n\n    @Override\n    public void getVectorInto(int nodeId, VectorFloat<?> result, int offset) {\n        // getVectorInto is only called by reranking, not diversity code\n        throw new UnsupportedOperationException();\n\n------------------------------\n------------------------------\n        public int entryNode() {\n            return view.entryNode();\n        }\n\n        @Override\n        public Bits liveNodes() {\n            return view.liveNodes();\n        }\n\n        @Override\n        public void close() throws IOException {\n            view.close();\n        }\n\n        @Override\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.rerankerFor(queryVector, vsf);\n        }\n\n        @Override\n\n------------------------------\n------------------------------\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.rerankerFor(queryVector, vsf);\n        }\n\n        @Override\n        public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.approximateScoreFunctionFor(queryVector, vsf);\n        }\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n# Natural Language Annotations: /**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    ScoreFunction.ExactScoreFunction scoreFunction = vectors.rerankerFor(queryVector, similarityFunction);\n    SearchResult result = new SearchResult(topK);\n    for (int ord : graph.liveNodes()) {\n        if (acceptOrds.get(ord)) {\n            result.add(ord, scoreFunction.score(ord));\n        }\n    }\n    return result;\n}\n```\n", "```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    ScoreFunction.ExactScoreFunction reranker = graph.rerankerFor(queryVector, similarityFunction);\n    return SearchResult.of(reranker.score(vectors, topK, acceptOrds));\n}\n```\n", "```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    ScoreFunction.ExactScoreFunction scoreFunction = vectors.rerankerFor(queryVector, similarityFunction);\n    SearchResult result = new SearchResult(topK);\n    result.setScoreFunction(scoreFunction);\n    scoreFunction.fill(graph, vectors, result, acceptOrds);\n    return result;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    protected int getArrayLength() {\n        return nodes.length;\n    }\n}\n\n------------------------------\n------------------------------\n   * Copies the specified range of the given array into a new sub array.\n   *\n   * @param array the input array\n   * @param from the initial index of range to be copied (inclusive)\n   * @param to the final index of range to be copied (exclusive)\n   */\n  public static long[] copyOfSubArray(long[] array, int from, int to) {\n    final long[] copy = new long[to - from];\n    System.arraycopy(array, from, copy, 0, to - from);\n    return copy;\n  }\n}\n\n------------------------------\n------------------------------\n            throw new IllegalArgumentException(\"Cannot copy to a smaller size\");\n        }\n\n        NodeArray copy = new NodeArray(newSize);\n        copy.size = size;\n        System.arraycopy(nodes, 0, copy.nodes, 0, size);\n        System.arraycopy(scores, 0, copy.scores, 0, size);\n        return copy;\n    }\n\n    protected final void growArrays() {\n        nodes = ArrayUtil.grow(nodes);\n        scores = ArrayUtil.growExact(scores, nodes.length);\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n\n------------------------------\n------------------------------\n\n    @Override\n    public float get(int n) {\n        return data[n];\n    }\n\n    @Override\n    public void set(int n, float value) {\n        data[n] = value;\n    }\n\n    @Override\n    public void zero() {\n        Arrays.fill(data, 0);\n    }\n\n    @Override\n    public int length()\n    {\n        return data.length;\n\n------------------------------\n------------------------------\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n        size = 0;\n    }\n\n    public void removeLast() {\n        size--;\n    }\n\n    public void removeIndex(int idx) {\n        System.arraycopy(nodes, idx + 1, nodes, idx, size - idx - 1);\n        System.arraycopy(scores, idx + 1, scores, idx, size - idx - 1);\n        size--;\n    }\n\n    @Override\n    public String toString() {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int[] nodesCopy() {\n# Natural Language Annotations: /** Returns a copy of the internal nodes array. Not sorted by score! */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic int[] nodesCopy() {\n    int[] copy = new int[nodes.length];\n    System.arraycopy(nodes, 0, copy, 0, nodes.length);\n    return copy;\n}\n```\n", "```java\npublic int[] nodesCopy() {\n    int[] copy = new int[size];\n    System.arraycopy(nodes, 0, copy, 0, size);\n    return copy;\n}\n```\n", "```java\npublic int[] nodesCopy() {\n    int[] copy = new int[size];\n    System.arraycopy(nodes, 0, copy, 0, size);\n    return copy;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    public SearchScoreProvider(ScoreFunction scoreFunction, ScoreFunction.ExactScoreFunction reranker) {\n        assert scoreFunction != null;\n        this.scoreFunction = scoreFunction;\n        this.reranker = reranker;\n    }\n\n    public ScoreFunction scoreFunction() {\n        return scoreFunction;\n    }\n\n    public ScoreFunction.ExactScoreFunction reranker() {\n        return reranker;\n    }\n\n    public ScoreFunction.ExactScoreFunction exactScoreFunction() {\n        return scoreFunction.isExact()\n                ? (ScoreFunction.ExactScoreFunction) scoreFunction\n                : reranker;\n    }\n\n\n------------------------------\n------------------------------\n            this.scoreProvider = scoreProvider;\n            cachedScores = new Int2ObjectHashMap<>();\n            rerankCalls = 0;\n        }\n\n        @Override\n        public float similarityTo(int node2) {\n            if (cachedScores.containsKey(node2)) {\n                return cachedScores.get(node2);\n            }\n            rerankCalls++;\n            float score = scoreProvider.reranker().similarityTo(node2);\n            cachedScores.put(node2, Float.valueOf(score));\n            return score;\n        }\n\n        public int getRerankCalls() {\n            return rerankCalls;\n        }\n    }\n\n------------------------------\n------------------------------\n                reranked = 0;\n                worstApproximateInTopK = Float.POSITIVE_INFINITY;\n                popFromQueue = approximateResults;\n            } else {\n                int oldReranked = cachingReranker.getRerankCalls();\n                worstApproximateInTopK = approximateResults.rerank(topK, cachingReranker, rerankFloor, rerankedResults, evictedResults);\n                reranked = cachingReranker.getRerankCalls() - oldReranked;\n                approximateResults.clear();\n                popFromQueue = rerankedResults;\n            }\n            // pop the top K results from the results queue, which has the worst candidates at the top\n            assert popFromQueue.size() <= topK;\n            var nodes = new SearchResult.NodeScore[popFromQueue.size()];\n            for (int i = nodes.length - 1; i >= 0; i--) {\n                var nScore = popFromQueue.topScore();\n                var n = popFromQueue.pop();\n                nodes[i] = new SearchResult.NodeScore(n, nScore);\n            }\n            // that should be everything\n            assert popFromQueue.size() == 0;\n\n------------------------------\n------------------------------\n    public float getWorstApproximateScoreInTopK() {\n        return worstApproximateScoreInTopK;\n    }\n\n    public static final class NodeScore {\n        public final int node;\n        public final float score;\n\n        public NodeScore(int node, float score) {\n            this.node = node;\n            this.score = score;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"NodeScore(%d, %s)\", node, score);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n            }\n\n            // rerank results\n            assert approximateResults.size() <= rerankK;\n            NodeQueue popFromQueue;\n            float worstApproximateInTopK;\n            int reranked;\n            if (cachingReranker == null) {\n                // save the worst candidates in evictedResults for potential resume()\n                while (approximateResults.size() > topK) {\n                    var nScore = approximateResults.topScore();\n                    var n = approximateResults.pop();\n                    evictedResults.add(n, nScore);\n                }\n\n                reranked = 0;\n                worstApproximateInTopK = Float.POSITIVE_INFINITY;\n                popFromQueue = approximateResults;\n            } else {\n                int oldReranked = cachingReranker.getRerankCalls();\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n# Natural Language Annotations: /**\n     * Rerank results and return the worst approximate score that made it into the topK.\n     * The topK results will be placed into `reranked`, and the remainder into `unused`.\n     * <p>\n     * Only the best result or results whose approximate score is at least `rerankFloor` will be reranked.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodeQueue unused) {\n    int oldReranked = cachingReranker.getRerankCalls();\n    worstApproximateInTopK = approximateResults.rerank(topK, cachingReranker, rerankFloor, rerankedResults, evictedResults);\n    reranked = cachingReranker.getRerankCalls() - oldReranked;\n    approximateResults.clear();\n    popFromQueue = rerankedResults;\n\n    // pop the top K results from the results queue, which has the worst candidates at the top\n    assert popFromQueue.size() <= topK;\n    var nodes = new SearchResult.NodeScore[popFromQueue.size()];\n    for (int i = nodes.length - 1; i >= 0; i--) {\n        var nScore = popFromQueue.topScore();\n        var n = popFromQueue.pop();\n        nodes[i] = new SearchResult.NodeScore(n, nScore);\n    }\n    // that should be everything\n    assert popFromQueue.size() == 0;\n    return worstApproximateInTopK;\n}\n```\n", "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    float worstApproximateInTopK = Float.POSITIVE_INFINITY;\n\n    // Rerank results\n    while (approximateResults.size() > topK) {\n        var nScore = approximateResults.topScore();\n        if (nScore >= rerankFloor) {\n            var n = approximateResults.pop();\n            reranked.add(n, nScore);\n            worstApproximateInTopK = Math.min(worstApproximateInTopK, nScore);\n        } else {\n            unused.add(approximateResults.pop());\n        }\n    }\n\n    // Rerank remaining results\n    while (!approximateResults.isEmpty()) {\n        var nScore = approximateResults.topScore();\n        if (nScore >= rerankFloor) {\n            var n = approximateResults.pop();\n            reranked.add(n, nScore);\n            worstApproximateInTopK = Math.min(worstApproximateInTopK, nScore);\n        } else {\n            unused.add(approximateResults.pop());\n        }\n    }\n\n    return worstApproximateInTopK;\n}\n```\n", "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodeQueue unused) {\n    float worstApproximateInTopK = Float.POSITIVE_INFINITY;\n    int rerankCalls = 0;\n    \n    // create a temporary queue to hold the reranked results\n    NodeQueue tempQueue = new NodeQueue();\n\n    // iterate over the topK candidates\n    for (int i = 0; i < topK; i++) {\n        // get the score of the current candidate\n        float score = approximateResults.topScore();\n        // if the score is greater than or equal to the rerank floor\n        if (score >= rerankFloor) {\n            // rerank the candidate\n            float rerankedScore = reranker.similarityTo(approximateResults.top());\n            rerankCalls++;\n            // if the reranked score is better than the original score\n            if (rerankedScore > score) {\n                // update the original score\n                score = rerankedScore;\n            }\n        }\n        // add the candidate and its score to the temporary queue\n        tempQueue.push(approximateResults.top(), score);\n        // remove the candidate from the original queue\n        approximateResults.pop();\n    }\n\n    // iterate over the remaining candidates\n    while (!approximateResults.isEmpty()) {\n        // add the candidate and its score to the unused queue\n        unused.push(approximateResults.top(), approximateResults.topScore());\n        // remove the candidate from the original queue\n        approximateResults.pop();\n    }\n\n    // iterate over the temporary queue\n    while (!tempQueue.isEmpty()) {\n        // add the candidate and its score to the reranked queue\n        reranked.push(tempQueue.top(), tempQueue.topScore());\n        // update the worst approximate score that made it into the topK\n        if (tempQueue.topScore() < worstApproximateInTopK) {\n            worstApproximateInTopK = tempQueue.topScore();\n        }\n        // remove the candidate from the temporary queue\n        tempQueue.pop();\n    }\n\n    return worstApproximateInTopK;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return subvector;\n    }\n\n    /**\n     * Splits the vector dimension into M subvectors of roughly equal size.\n     */\n    @VisibleForTesting\n    static int[][] getSubvectorSizesAndOffsets(int dimensions, int M) {\n        if (M > dimensions) {\n            throw new IllegalArgumentException(\"Number of subspaces must be less than or equal to the vector dimension\");\n        }\n        int[][] sizes = new int[M][];\n        int baseSize = dimensions / M;\n        int remainder = dimensions % M;\n        // distribute the remainder among the subvectors\n        int offset = 0;\n        for (int i = 0; i < M; i++) {\n            int size = baseSize + (i < remainder ? 1 : 0);\n            sizes[i] = new int[]{size, offset};\n            offset += size;\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n------------------------------\n        }\n        heap[i] = value; // install saved value\n    }\n\n    protected void downHeap(int i) {\n        long value = heap[i]; // save top value\n        int j = i << 1; // find smaller child\n        int k = j + 1;\n        if (k <= size && heap[k] < heap[j]) {\n            j = k;\n        }\n        while (j <= size && heap[j] < value) {\n            heap[i] = heap[j]; // shift up child\n            i = j;\n            j = i << 1;\n            k = j + 1;\n            if (k <= size && heap[k] < heap[j]) {\n                j = k;\n            }\n        }\n\n------------------------------\n------------------------------\n            throw new IllegalArgumentException(\"Cannot copy to a smaller size\");\n        }\n\n        NodeArray copy = new NodeArray(newSize);\n        copy.size = size;\n        System.arraycopy(nodes, 0, copy.nodes, 0, size);\n        System.arraycopy(scores, 0, copy.scores, 0, size);\n        return copy;\n    }\n\n    protected final void growArrays() {\n        nodes = ArrayUtil.grow(nodes);\n        scores = ArrayUtil.growExact(scores, nodes.length);\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    public NodeArray copy() {\n        return copy(size);\n    }\n\n    public NodeArray copy(int newSize) {\n        if (size > newSize) {\n            throw new IllegalArgumentException(\"Cannot copy to a smaller size\");\n        }\n\n        NodeArray copy = new NodeArray(newSize);\n        copy.size = size;\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static NodeArray merge(NodeArray a1, NodeArray a2) {\n# Natural Language Annotations: /** always creates a new NodeArray to return, even when a1 or a2 is empty */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray merged = new NodeArray(a1.size() + a2.size());\n    for (int i = 0; i < a1.size(); i++) {\n        merged.add(a1.get(i));\n    }\n    for (int i = 0; i < a2.size(); i++) {\n        merged.add(a2.get(i));\n    }\n    return merged;\n}\n```\n", "```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray result = new NodeArray(a1.size() + a2.size());\n    int i = 0, j = 0;\n\n    while (i < a1.size() && j < a2.size()) {\n        if (a1.get(i) < a2.get(j)) {\n            result.add(a1.get(i++));\n        } else {\n            result.add(a2.get(j++));\n        }\n    }\n\n    while (i < a1.size()) {\n        result.add(a1.get(i++));\n    }\n\n    while (j < a2.size()) {\n        result.add(a2.get(j++));\n    }\n\n    return result;\n}\n```\n", "```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray result = new NodeArray(a1.size() + a2.size());\n    result.addAll(a1);\n    result.addAll(a2);\n    return result;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n      sum += vector.get(i);\n    }\n\n    return sum;\n  }\n\n  @Override\n  public void scale(VectorFloat<?> vector, float multiplier) {\n    for (int i = 0; i < vector.length(); i++) {\n      vector.set(i, vector.get(i) * multiplier);\n    }\n  }\n\n  @Override\n  public void addInPlace(VectorFloat<?> v1, VectorFloat<?> v2) {\n    for (int i = 0; i < v1.length(); i++) {\n      v1.set(i, v1.get(i) + v2.get(i));\n    }\n  }\n\n\n------------------------------\n------------------------------\n            return;\n        }\n\n        bits[startWord] |= startmask;\n        Arrays.fill(bits, startWord + 1, endWord, -1L);\n        bits[endWord] |= endmask;\n    }\n\n    @Override\n    public void clear(int startIndex, int endIndex) {\n        assert startIndex >= 0 && startIndex < numBits\n                : \"startIndex=\" + startIndex + \", numBits=\" + numBits;\n        assert endIndex >= 0 && endIndex <= numBits : \"endIndex=\" + endIndex + \", numBits=\" + numBits;\n        if (endIndex <= startIndex) {\n            return;\n        }\n\n        int startWord = startIndex >> 6;\n        int endWord = (endIndex - 1) >> 6;\n\n\n------------------------------\n------------------------------\n        }\n        heap[i] = value; // install saved value\n    }\n\n    protected void downHeap(int i) {\n        long value = heap[i]; // save top value\n        int j = i << 1; // find smaller child\n        int k = j + 1;\n        if (k <= size && heap[k] < heap[j]) {\n            j = k;\n        }\n        while (j <= size && heap[j] < value) {\n            heap[i] = heap[j]; // shift up child\n            i = j;\n            j = i << 1;\n            k = j + 1;\n            if (k <= size && heap[k] < heap[j]) {\n                j = k;\n            }\n        }\n\n------------------------------\n------------------------------\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n        size = 0;\n    }\n\n    public void removeLast() {\n        size--;\n    }\n\n    public void removeIndex(int idx) {\n        System.arraycopy(nodes, idx + 1, nodes, idx, size - idx - 1);\n        System.arraycopy(scores, idx + 1, scores, idx, size - idx - 1);\n        size--;\n    }\n\n    @Override\n    public String toString() {\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void addInOrder(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void addInOrder(int newNode, float newScore) {\n    if (!duplicateExistsNear(newNode, newScore)) {\n        int insertionPoint = findInsertionPoint(newScore);\n        insertNodeAt(newNode, newScore, insertionPoint);\n    }\n}\n\nprivate boolean duplicateExistsNear(int newNode, float newScore) {\n    int insertionPoint = findInsertionPoint(newScore);\n    // Check to the left\n    for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n        if (nodes[i] == newNode) {\n            return true;\n        }\n    }\n    // Check to the right\n    for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n        if (nodes[i] == newNode) {\n            return true;\n        }\n    }\n    return false;\n}\n\nprivate int findInsertionPoint(float newScore) {\n    int low = 0;\n    int high = size;\n    while (low < high) {\n        int mid = (low + high) >>> 1;\n        if (newScore >= scores[mid]) {\n            low = mid + 1;\n        } else {\n            high = mid;\n        }\n    }\n    return low;\n}\n\nprivate void insertNodeAt(int newNode, float newScore, int insertionPoint) {\n    System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n    System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    size++;\n}\n```\n", "```java\npublic void addInOrder(int newNode, float newScore) {\n    if (size == 0 || scores[size - 1] > newScore) {\n        // The new node is better than all existing nodes\n        ensureCapacity(size + 1);\n        nodes[size] = newNode;\n        scores[size] = newScore;\n        size++;\n    } else if (duplicateExistsNear(size - 1, newNode, newScore)) {\n        // The node already exists in the NodeArray\n        return;\n    } else {\n        // The new node is worse than all existing nodes\n        int insertionPoint = size;\n        for (int i = 0; i < size; i++) {\n            if (scores[i] < newScore) {\n                insertionPoint = i;\n                break;\n            }\n        }\n        ensureCapacity(size + 1);\n        System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n        nodes[insertionPoint] = newNode;\n        scores[insertionPoint] = newScore;\n        size++;\n    }\n}\n```\n", "```java\npublic void addInOrder(int newNode, float newScore) {\n    // If the new score is better than the worst score in the array, don't add it.\n    if (size > 0 && scores[size - 1] > newScore) {\n        return;\n    }\n\n    // If the new score is worse than the best score in the array or if there is no node in the array, add it.\n    if (size == 0 || scores[0] < newScore) {\n        insertAt(0, newNode, newScore);\n        return;\n    }\n\n    // Find an insertion point for the new node.\n    int insertionPoint = size;\n    for (int i = size - 1; i >= 0 && scores[i] > newScore; i--) {\n        insertionPoint = i;\n    }\n\n    // If the new node already exists at the same score, don't add it.\n    if (duplicateExistsNear(insertionPoint, newNode, newScore)) {\n        return;\n    }\n\n    // Add the new node at the insertion point.\n    insertAt(insertionPoint, newNode, newScore);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     *\n     * @return one bit per original f32\n     */\n    @Override\n    public long[] encode(VectorFloat<?> v) {\n        int M = (int) Math.ceil(v.length() / 64.0);\n        long[] encoded = new long[M];\n        for (int i = 0; i < M; i++) {\n            long bits = 0;\n            for (int j = 0; j < 64; j++) {\n                int idx = i * 64 + j;\n                if (idx >= v.length()) {\n                    break;\n                }\n                if (v.get(idx) > 0) {\n                    bits |= 1L << j;\n                }\n            }\n            encoded[i] = bits;\n        }\n\n------------------------------\n------------------------------\n        bb.position(bb.position() + remaining);\n    }\n\n    @Override\n    public void readFully(long[] vector) {\n        for (int i = 0; i < vector.length; i++) {\n            vector[i] = bb.getLong();\n        }\n    }\n\n    @Override\n    public int readInt() {\n        return bb.getInt();\n    }\n\n    @Override\n    public float readFloat() throws IOException {\n        return bb.getFloat();\n    }\n\n\n------------------------------\n------------------------------\n    VectorFloat<?>[] data;\n\n    public Matrix(int m, int n) {\n        this(m, n, true);\n    }\n\n    public Matrix(int m, int n, boolean allocateZeroed) {\n        data = new VectorFloat[m];\n        if (allocateZeroed) {\n            for (int i = 0; i < m; i++) {\n                data[i] = vts.createFloatVector(n);\n            }\n        }\n    }\n\n    public float get(int i, int j) {\n        return data[i].get(j);\n    }\n\n    public void set(int i, int j, float value) {\n\n------------------------------\n------------------------------\n        for (int i = 0; i < data.length; i++) {\n            if (!data[i].equals(other.data[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static Matrix from(float[][] values) {\n        var result = new Matrix(values.length, values[0].length, false);\n        for (int i = 0; i < values.length; i++) {\n            result.data[i] = vts.createFloatVector(values[i]);\n        }\n        return result;\n    }\n}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int insertSorted(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic int insertSorted(int newNode, float newScore) {\n    // Check if node + score pair already exists\n    for (int i = 0; i < size; i++) {\n        if (nodes[i] == newNode && scores[i] == newScore) {\n            return -1;\n        }\n    }\n    \n    // Find the insertion point\n    int insertionPoint = 0;\n    for (int i = 0; i < size; i++) {\n        if (scores[i] < newScore) {\n            insertionPoint = i;\n            break;\n        }\n        insertionPoint = size;\n    }\n    \n    // Shift nodes and scores to create space for new node\n    for (int i = size; i > insertionPoint; i--) {\n        nodes[i] = nodes[i - 1];\n        scores[i] = scores[i - 1];\n    }\n    \n    // Insert new node\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    \n    // Increase size\n    size++;\n    \n    return insertionPoint;\n}\n```\n", "```java\npublic int insertSorted(int newNode, float newScore) {\n    int insertionPoint = -1;\n    for (int i = 0; i < size; i++) {\n        if (newScore < scores[i]) {\n            insertionPoint = i;\n            break;\n        }\n        else if (newScore == scores[i] && newNode == nodes[i]) {\n            return -1;  // duplicate node + score pair found, ignore\n        }\n    }\n    if (insertionPoint != -1) {\n        // shift elements to the right\n        System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n        nodes[insertionPoint] = newNode;\n        scores[insertionPoint] = newScore;\n        size++;\n    } else {\n        // new node has highest score, add at the end\n        nodes[size] = newNode;\n        scores[size] = newScore;\n        size++;\n    }\n    return insertionPoint;\n}\n```\n", "```java\npublic int insertSorted(int newNode, float newScore) {\n    int insertionPoint = 0;\n    while (insertionPoint < size && scores[insertionPoint] < newScore) {\n        insertionPoint++;\n    }\n    if (insertionPoint < size && scores[insertionPoint] == newScore && nodes[insertionPoint] == newNode) {\n        return -1;  // Node and score already exist, ignore\n    }\n    if (size >= nodes.length) {\n        expandArrays();  // Assuming this method exists to increase array size\n    }\n    for (int i = size; i > insertionPoint; i--) {\n        scores[i] = scores[i - 1];\n        nodes[i] = nodes[i - 1];\n    }\n    scores[insertionPoint] = newScore;\n    nodes[insertionPoint] = newNode;\n    size++;\n    return insertionPoint;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    VectorFloat<?>[] data;\n\n    public Matrix(int m, int n) {\n        this(m, n, true);\n    }\n\n    public Matrix(int m, int n, boolean allocateZeroed) {\n        data = new VectorFloat[m];\n        if (allocateZeroed) {\n            for (int i = 0; i < m; i++) {\n                data[i] = vts.createFloatVector(n);\n            }\n        }\n    }\n\n    public float get(int i, int j) {\n        return data[i].get(j);\n    }\n\n    public void set(int i, int j, float value) {\n\n------------------------------\n------------------------------\n    @Override\n    public float readFloat() throws IOException {\n        return bb.getFloat();\n    }\n\n    @Override\n    public void read(int[] ints, int offset, int count) {\n        for (int i = 0; i < count; i++) {\n            ints[offset + i] = bb.getInt();\n        }\n    }\n\n    @Override\n    public void read(float[] floats, int offset, int count) {\n        for (int i = 0; i < count; i++) {\n            floats[offset + i] = bb.getFloat();\n        }\n    }\n\n    @Override\n\n------------------------------\n------------------------------\n        bb.position(bb.position() + remaining);\n    }\n\n    @Override\n    public void readFully(long[] vector) {\n        for (int i = 0; i < vector.length; i++) {\n            vector[i] = bb.getLong();\n        }\n    }\n\n    @Override\n    public int readInt() {\n        return bb.getInt();\n    }\n\n    @Override\n    public float readFloat() throws IOException {\n        return bb.getFloat();\n    }\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n------------------------------\n    public int size() {\n        return size;\n    }\n\n    public void clear() {\n        size = 0;\n    }\n\n    public void foreach(NodeConsumer consumer) {\n        for (int i = 0; i < size; i++) {\n            consumer.accept(node[i], score[i]);\n        }\n    }\n\n    @Override\n    public String toString() {\n        return \"NodesUnsorted[\" + size + \"]\";\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void retain(Bits selected) {\n# Natural Language Annotations: /**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void retain(Bits selected) {\n    int writeIndex = 0;\n    for (int readIndex = 0; readIndex < size; readIndex++) {\n        if (selected.get(readIndex)) {\n            nodes[writeIndex] = nodes[readIndex];\n            scores[writeIndex] = scores[readIndex];\n            writeIndex++;\n        }\n    }\n    size = writeIndex;\n}\n```\n", "```java\npublic void retain(Bits selected) {\n    int count = 0;\n    for (int i = 0; i < size; i++) {\n        if (selected.get(i)) {\n            nodes[count] = nodes[i];\n            scores[count] = scores[i];\n            count++;\n        }\n    }\n    size = count;\n}\n```\n", "```java\npublic void retain(Bits selected) {\n    int countSet = selected.countSetBits();\n    int newSize = 0;\n    int[] newNodes = new int[countSet];\n    float[] newScores = new float[countSet];\n\n    for (int i = 0; i < size; i++) {\n        if (selected.get(i)) {\n            newNodes[newSize] = nodes[i];\n            newScores[newSize] = scores[i];\n            newSize++;\n        }\n    }\n\n    nodes = newNodes;\n    scores = newScores;\n    size = countSet;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        size--;\n    }\n\n    @Override\n    public String toString() {\n        var sb = new StringBuilder(\"NodeArray(\");\n        sb.append(size).append(\"/\").append(nodes.length).append(\") [\");\n        for (int i = 0; i < size; i++) {\n            sb.append(\"(\").append(nodes[i]).append(\",\").append(scores[i]).append(\")\").append(\", \");\n        }\n        sb.append(\"]\");\n        return sb.toString();\n    }\n\n    protected final int descSortFindRightMostInsertionPoint(float newScore) {\n        int start = 0;\n        int end = size - 1;\n        while (start <= end) {\n            int mid = (start + end) / 2;\n            if (scores[mid] < newScore) end = mid - 1;\n\n------------------------------\n------------------------------\n     *\n     * @return one bit per original f32\n     */\n    @Override\n    public long[] encode(VectorFloat<?> v) {\n        int M = (int) Math.ceil(v.length() / 64.0);\n        long[] encoded = new long[M];\n        for (int i = 0; i < M; i++) {\n            long bits = 0;\n            for (int j = 0; j < 64; j++) {\n                int idx = i * 64 + j;\n                if (idx >= v.length()) {\n                    break;\n                }\n                if (v.get(idx) > 0) {\n                    bits |= 1L << j;\n                }\n            }\n            encoded[i] = bits;\n        }\n\n------------------------------\n------------------------------\n        }\n\n        int M = in.readInt();\n        int[][] subvectorSizes = new int[M][];\n        int offset = 0;\n        for (int i = 0; i < M; i++) {\n            subvectorSizes[i] = new int[2];\n            int size = in.readInt();\n            subvectorSizes[i][0] = size;\n            subvectorSizes[i][1] = offset;\n            offset += size;\n        }\n\n        float anisotropicThreshold;\n        if (version < 3) {\n            anisotropicThreshold = UNWEIGHTED;\n        } else {\n            anisotropicThreshold = in.readFloat();\n        }\n\n\n------------------------------\n------------------------------\n    for (i = 0; i + 8 <= dim; i += 8) {\n      squareSum += squareDistanceUnrolled(a, b, i);\n    }\n    for (; i < dim; i++) {\n      float diff = a[i] - b[i];\n      squareSum += diff * diff;\n    }\n    return squareSum;\n  }\n\n  private static float squareDistanceUnrolled(float[] v1, float[] v2, int index) {\n    float diff0 = v1[index + 0] - v2[index + 0];\n    float diff1 = v1[index + 1] - v2[index + 1];\n    float diff2 = v1[index + 2] - v2[index + 2];\n    float diff3 = v1[index + 3] - v2[index + 3];\n    float diff4 = v1[index + 4] - v2[index + 4];\n    float diff5 = v1[index + 5] - v2[index + 5];\n    float diff6 = v1[index + 6] - v2[index + 6];\n    float diff7 = v1[index + 7] - v2[index + 7];\n    return diff0 * diff0\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void add(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void add(int newNode, float newScore) {\n    if (size == nodes.length) {\n        nodes = Arrays.copyOf(nodes, size * 2);\n        scores = Arrays.copyOf(scores, size * 2);\n    }\n    int insertionPoint = descSortFindRightMostInsertionPoint(newScore);\n    if (!duplicateExistsNear(insertionPoint, newNode, newScore)) {\n        if (insertionPoint < size && scores[insertionPoint] == newScore) {\n            // Shift elements to the right to make space for the new node\n            System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n            System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n            nodes[insertionPoint] = newNode;\n            scores[insertionPoint] = newScore;\n        } else {\n            nodes[size] = newNode;\n            scores[size] = newScore;\n        }\n        size++;\n    }\n}\n```\n", "```java\npublic void add(int newNode, float newScore) {\n\n    // First, find the rightmost insertion point in the scores array\n    int insertionPoint = descSortFindRightMostInsertionPoint(newScore);\n\n    // Check if a duplicate exists near the insertion point\n    if (duplicateExistsNear(insertionPoint, newNode, newScore)) {\n        return;\n    }\n\n    // Shift all elements to the right of the insertion point to make room for the new node\n    System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n    System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n\n    // Insert the new node and score\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n\n    // Increment the size\n    size++;\n}\n```\n", "```java\npublic void add(int newNode, float newScore) {\n    // Check if the node already exists near the insertion point\n    int insertionPoint = descSortFindRightMostInsertionPoint(newScore);\n    if (duplicateExistsNear(insertionPoint, newNode, newScore)) {\n        return;\n    }\n\n    // Check if we need to expand the arrays\n    if (size == nodes.length) {\n        expandArrays();\n    }\n\n    // Shift the elements to the right to make room for the new node\n    System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n    System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n\n    // Add the new node and score at the insertion point\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n\n    // Increment the size\n    size++;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/RandomAccessVectorValues.java-rerankerFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return scoreFunction.isExact()\n                ? (ScoreFunction.ExactScoreFunction) scoreFunction\n                : reranker;\n    }\n\n    /**\n     * A SearchScoreProvider for a single-pass search based on exact similarity.\n     * Generally only suitable when your RandomAccessVectorValues is entirely in-memory,\n     * e.g. during construction.\n     */\n    public static SearchScoreProvider exact(VectorFloat<?> v, VectorSimilarityFunction vsf, RandomAccessVectorValues ravv) {\n        // don't use ESF.reranker, we need thread safety here\n        var sf = new ScoreFunction.ExactScoreFunction() {\n            @Override\n            public float similarityTo(int node2) {\n                return vsf.compare(v, ravv.getVector(node2));\n            }\n        };\n        return new SearchScoreProvider(sf);\n    }\n\n------------------------------\n------------------------------\n            }\n\n            @Override\n            public SearchScoreProvider searchProviderFor(VectorFloat<?> vector) {\n                // deliberately skips reranking even though we are using an approximate score function\n                return new SearchScoreProvider(pqv.precomputedScoreFunctionFor(vector, vsf));\n            }\n\n            @Override\n            public VectorFloat<?> approximateCentroid() {\n                return pqv.getCompressor().getOrComputeCentroid();\n            }\n        };\n    }\n\n}\n\n------------------------------\n------------------------------\n        }\n\n        @Override\n        public void close() throws IOException {\n            reader.close();\n        }\n\n        @Override\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            if (!features.containsKey(FeatureId.INLINE_VECTORS)) {\n                throw new UnsupportedOperationException(\"No inline vectors in this graph\");\n            }\n            return RandomAccessVectorValues.super.rerankerFor(queryVector, vsf);\n        }\n\n        @Override\n        public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            if (features.containsKey(FeatureId.FUSED_ADC)) {\n                return ((FusedADC) features.get(FeatureId.FUSED_ADC)).approximateScoreFunctionFor(queryVector, vsf, this, rerankerFor(queryVector, vsf));\n            } else {\n\n------------------------------\n------------------------------\n        public int entryNode() {\n            return view.entryNode();\n        }\n\n        @Override\n        public Bits liveNodes() {\n            return view.liveNodes();\n        }\n\n        @Override\n        public void close() throws IOException {\n            view.close();\n        }\n\n        @Override\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.rerankerFor(queryVector, vsf);\n        }\n\n        @Override\n\n------------------------------\n------------------------------\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.rerankerFor(queryVector, vsf);\n        }\n\n        @Override\n        public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.approximateScoreFunctionFor(queryVector, vsf);\n        }\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n# Natural Language Annotations: /**\n     * Convenience method to create an ExactScoreFunction for reranking.  The resulting function is NOT thread-safe.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n    return new ScoreFunction.ExactScoreFunction() {\n        @Override\n        public float similarityTo(int node2) {\n            return vsf.compare(queryVector, ravv.getVector(node2));\n        }\n    };\n}\n```\n", "```java\npublic ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n    return new ScoreFunction.ExactScoreFunction() {\n        @Override\n        public float similarityTo(int node2) {\n            return vsf.compare(queryVector, getVector(node2));\n        }\n    };\n}\n```\n", "```java\npublic ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n    return view.rerankerFor(queryVector, vsf);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                                    });\n    }\n\n    void updateEntryNode(int node) {\n        entryPoint.set(node);\n    }\n\n    @Override\n    public int maxDegree() {\n        return maxDegree;\n    }\n\n    int entry() {\n        return entryPoint.get();\n    }\n\n    @Override\n    public NodesIterator getNodes() {\n        return nodes.nodesIterator();\n    }\n\n------------------------------\n------------------------------\n    /**\n     * Only for internal use and by Builder loading a saved graph\n     */\n\n\n\n\n\n\n\n    public void addNode(int nodeId) {\n        addNode(nodeId, new NodeArray(0));\n    }\n\n    public NodesIterator nodesIterator() {\n        return neighbors.keysIterator();\n    }\n\n    public Neighbors remove(int node) {\n        return neighbors.remove(node);\n\n------------------------------\n------------------------------\n    boolean removeNode(int node) {\n        try {\n            return nodes.remove(node) != null;\n        } finally {\n            deletedNodes.clear(node);\n        }\n    }\n\n    @Override\n    public int getIdUpperBound() {\n        return maxNodeId.get() + 1;\n    }\n\n    public boolean containsNode(int nodeId) {\n        return nodes.contains(nodeId);\n    }\n\n    public double getAverageDegree() {\n        return IntStream.range(0, getIdUpperBound())\n                .filter(this::containsNode)\n\n------------------------------\n------------------------------\n    }\n\n    /**\n     * Add the given node ordinal with an empty set of neighbors.\n     *\n     * <p>Nodes can be inserted out of order, but it requires that the nodes preceded by the node\n     * inserted out of order are eventually added.\n     *\n     * <p>Actually populating the neighbors, and establishing bidirectional links, is the\n     * responsibility of the caller.\n     *\n     * <p>It is also the responsibility of the caller to ensure that each node is only added once.\n     *\n     * @param nodeId the node to add, represented as an ordinal\n     */\n    public void addNode(int nodeId) {\n        nodes.addNode(nodeId);\n        maxNodeId.accumulateAndGet(nodeId, Math::max);\n    }\n\n\n------------------------------\n------------------------------\n    public void addNode(int nodeId) {\n        nodes.addNode(nodeId);\n        maxNodeId.accumulateAndGet(nodeId, Math::max);\n    }\n\n    /**\n     * Only for use by Builder loading a saved graph\n     */\n    void addNode(int nodeId, NodeArray nodes) {\n        assert nodes != null;\n        this.nodes.addNode(nodeId, nodes);\n        maxNodeId.accumulateAndGet(nodeId, Math::max);\n    }\n\n    /**\n     * Mark the given node deleted.  Does NOT remove the node from the graph.\n     */\n    public void markDeleted(int node) {\n        deletedNodes.set(node);\n    }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void addNode(int nodeId, NodeArray nodes) {\n# Natural Language Annotations: /**\n     * Only for internal use and by Builder loading a saved graph\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nvoid addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```\n", "```java\npublic void addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```\n", "Sure, here is the requested function:\n\n```java\nvoid addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n}\n\n------------------------------\n------------------------------\n\n        public int getRerankCalls() {\n            return rerankCalls;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n  @Override\n  public long ramBytesUsed() {\n    throw new UnsupportedOperationException();\n  }\n}\n\n------------------------------\n------------------------------\n\n    @VisibleForTesting\n    long[] getHeapArray() {\n        return heap;\n    }\n}\n\n------------------------------\n------------------------------\n  @Override\n  public VectorTypeSupport getVectorTypeSupport() {\n    return vectorTypes;\n  }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized long removeDeletedNodes() {\n# Natural Language Annotations: /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic synchronized long removeDeletedNodes() {\n    // Your function implementation goes here\n}\n```\n", "```java\npublic synchronized long removeDeletedNodes() {\n    // Calculate the initial size of memory used\n    long initialSize = ramBytesUsed();\n\n    // Iterate over the nodes\n    for (Node node : nodes) {\n        // If the node is marked for deletion\n        if (node.isMarkedForDeletion()) {\n            // Update the neighbor lists to maintain connectivity\n            for (Node neighbor : node.getNeighbors()) {\n                neighbor.removeNeighbor(node);\n            }\n            // Remove the node from the list of nodes\n            nodes.remove(node);\n        }\n    }\n\n    // Calculate the final size of memory used\n    long finalSize = ramBytesUsed();\n\n    // Return the approximate size of memory no longer used\n    return initialSize - finalSize;\n}\n```\n", "```java\npublic synchronized long removeDeletedNodes() {\n    long freedMemory = 0;\n    for (int i = 0; i < nodes.length; i++) {\n        if (nodes[i] != null && nodes[i].isMarkedForDeletion()) {\n            // Remove node from its neighbors' lists\n            for (Node neighbor : nodes[i].getNeighbors()) {\n                neighbor.removeNeighbor(nodes[i]);\n                freedMemory += nodes[i].sizeInBytes();\n            }\n            // Remove node itself\n            nodes[i] = null;\n            gc();\n        }\n    }\n    return freedMemory;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    static Header load(RandomAccessReader reader, long offset) throws IOException {\n        reader.seek(offset);\n\n        EnumSet<FeatureId> featureIds;\n        EnumMap<FeatureId, Feature> features = new EnumMap<>(FeatureId.class);\n        CommonHeader common = CommonHeader.load(reader);\n        if (common.version >= 3) {\n            featureIds = FeatureId.deserialize(reader.readInt());\n        } else {\n            featureIds = EnumSet.of(FeatureId.INLINE_VECTORS);\n        }\n\n        for (FeatureId featureId : featureIds) {\n            features.put(featureId, featureId.load(common, reader));\n        }\n\n        return new Header(common, features);\n    }\n\n------------------------------\n------------------------------\n    }\n\n    static EnumMap<FeatureId, State> singleState(FeatureId id, State state) {\n        EnumMap<FeatureId, State> map = new EnumMap<>(FeatureId.class);\n        map.put(id, state);\n        return map;\n    }\n}\n\n------------------------------\n------------------------------\n    public void writeHeader(DataOutput out) {\n        // common header contains dimension, which is sufficient\n    }\n\n    @Override\n    public void writeInline(DataOutput out, Feature.State state) throws IOException {\n        vectorTypeSupport.writeFloatVector(out, ((InlineVectors.State) state).vector);\n    }\n\n    public static class State implements Feature.State {\n        public final VectorFloat<?> vector;\n\n        public State(VectorFloat<?> vector) {\n            this.vector = vector;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n    final EnumMap<FeatureId, ? extends Feature> features;\n\n    Header(CommonHeader common, EnumMap<FeatureId, ? extends Feature> features) {\n        this.common = common;\n        this.features = features;\n    }\n\n    void write(DataOutput out) throws IOException {\n        common.write(out);\n\n        if (common.version >= 3) {\n            out.writeInt(FeatureId.serialize(EnumSet.copyOf(features.keySet())));\n        }\n\n        // we restrict pre-version-3 writers to INLINE_VECTORS features, so we don't need additional version-handling here\n        for (Feature writer : features.values()) {\n            writer.writeHeader(out);\n        }\n    }\n\n\n------------------------------\n------------------------------\n\n    int inlineSize();\n\n    void writeHeader(DataOutput out) throws IOException;\n\n    void writeInline(DataOutput out, State state) throws IOException;\n\n    // Feature implementations should implement a State as well for use with writeInline\n    interface State {\n    }\n\n    static EnumMap<FeatureId, IntFunction<State>> singleStateFactory(FeatureId id, IntFunction<State> stateFactory) {\n        EnumMap<FeatureId, IntFunction<State>> map = new EnumMap<>(FeatureId.class);\n        map.put(id, stateFactory);\n        return map;\n    }\n\n    static EnumMap<FeatureId, State> singleState(FeatureId id, State state) {\n        EnumMap<FeatureId, State> map = new EnumMap<>(FeatureId.class);\n        map.put(id, state);\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException\n# Natural Language Annotations: /**\n     * Write the inline features of the given ordinal to the output at the correct offset.\n     * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        Feature feature = features.get(entry.getKey());\n        if (feature != null) {\n            feature.writeInline(out, entry.getValue());\n        }\n    }\n}\n```\n", "```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Find the feature corresponding to the ordinal\n    FeatureId featureId = FeatureId.fromOrdinal(ordinal);\n\n    // Get the state for the feature\n    Feature.State state = stateMap.get(featureId);\n\n    // If the state is null, throw an exception\n    if (state == null) {\n        throw new IllegalArgumentException(\"No state for feature \" + featureId);\n    }\n\n    // Write the inline feature to the output\n    featureId.load(common, reader).writeInline(out, state);\n}\n```\n", "```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    DataOutput out = null; // initialize output object\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        FeatureId id = entry.getKey();\n        Feature.State state = entry.getValue();\n        Feature feature = features.get(id);\n        if (feature != null) {\n            feature.writeInline(out, state);\n        } else {\n            throw new IllegalArgumentException(\"Unknown feature id: \" + id);\n        }\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    public static EnumSet<FeatureId> deserialize(int bitflags) {\n        EnumSet<FeatureId> set = EnumSet.noneOf(FeatureId.class);\n        for (int n = 0; n < values().length; n++) {\n            if ((bitflags & (1 << n)) != 0)\n                set.add(values()[n]);\n        }\n        return set;\n    }\n\n    public static int serialize(EnumSet<FeatureId> flags) {\n        int i = 0;\n        for (FeatureId flag : flags)\n            i |= 1 << flag.ordinal();\n        return i;\n    }\n}\n\n------------------------------\n------------------------------\n\n        @Override\n        public int oldToNew(int oldOrdinal) {\n            return oldToNew.get(oldOrdinal);\n        }\n\n        @Override\n        public int newToOld(int newOrdinal) {\n            return newToOld.get(newOrdinal);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    private boolean duplicateExistsNear(int insertionPoint, int newNode, float newScore) {\n        // Check to the left\n        for (int i = insertionPoint - 1; i >= 0 && scores[i] == newScore; i--) {\n            if (nodes[i] == newNode) {\n                return true;\n            }\n        }\n\n        // Check to the right\n        for (int i = insertionPoint; i < size && scores[i] == newScore; i++) {\n            if (nodes[i] == newNode) {\n                return true;\n\n------------------------------\n------------------------------\n        for (int i = 0; i < data.length; i++) {\n            if (!data[i].equals(other.data[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static Matrix from(float[][] values) {\n        var result = new Matrix(values.length, values[0].length, false);\n        for (int i = 0; i < values.length; i++) {\n            result.data[i] = vts.createFloatVector(values[i]);\n        }\n        return result;\n    }\n}\n\n------------------------------\n------------------------------\n            if (ordinalMapper == null) {\n                ordinalMapper = new OrdinalMapper.MapMapper(sequentialRenumbering(graphIndex));\n            }\n            return new OnDiskGraphIndexWriter(out, version, startOffset, graphIndex, ordinalMapper, dimension, features);\n        }\n\n        public Builder withMap(Map<Integer, Integer> oldToNewOrdinals) {\n            return withMapper(new OrdinalMapper.MapMapper(oldToNewOrdinals));\n        }\n\n        public Feature getFeature(FeatureId featureId) {\n            return features.get(featureId);\n        }\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n# Natural Language Annotations: /**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNewOrdinals = new HashMap<>();\n    int newOrdinal = 0;\n    for (int oldOrdinal = 0; oldOrdinal < graph.size(); oldOrdinal++) {\n        if (graph.contains(oldOrdinal)) {\n            oldToNewOrdinals.put(oldOrdinal, newOrdinal);\n            newOrdinal++;\n        }\n    }\n    return oldToNewOrdinals;\n}\n```\n", "```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNewOrdinals = new HashMap<>();\n    int newOrdinal = 0;\n    for (int oldOrdinal = 0; oldOrdinal < graph.size(); oldOrdinal++) {\n        if (graph.containsNode(oldOrdinal)) {\n            oldToNewOrdinals.put(oldOrdinal, newOrdinal);\n            newOrdinal++;\n        }\n    }\n    return oldToNewOrdinals;\n}\n```\n", "```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNewOrdinals = new HashMap<>();\n    int newOrdinal = 0;\n    for (int oldOrdinal = 0; oldOrdinal < graph.size(); oldOrdinal++) {\n        if (graph.containsNode(oldOrdinal)) {\n            oldToNewOrdinals.put(oldOrdinal, newOrdinal);\n            newOrdinal++;\n        }\n    }\n    return oldToNewOrdinals;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        public RandomAccessOutputStream(RandomAccessFile raf) {\n            this.raf = raf;\n        }\n\n        @Override\n        public void write(int b) throws IOException {\n            raf.write(b);\n        }\n\n        @Override\n        public void write(byte[] b, int off, int len) throws IOException {\n            raf.write(b, off, len);\n        }\n\n        @Override\n        public void close() throws IOException {\n            raf.close();\n        }\n    }\n\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public void close() throws IOException {\n        raf.close();\n    }\n\n    public static class Supplier implements ReaderSupplier {\n        private final Path path;\n\n        public Supplier(Path path) {\n            this.path = path;\n        }\n\n        @Override\n        public RandomAccessReader get() throws FileNotFoundException {\n            return new SimpleReader(path);\n        }\n    }\n}\n\n------------------------------\n------------------------------\n        stream.writeChars(s);\n    }\n\n    @Override\n    public void writeUTF(String s) throws IOException {\n        stream.writeUTF(s);\n    }\n}\n\n------------------------------\n------------------------------\n     */\n    public static class Builder {\n        private final GraphIndex graphIndex;\n        private final EnumMap<FeatureId, Feature> features;\n        private final RandomAccessWriter out;\n        private OrdinalMapper ordinalMapper;\n        private long startOffset;\n        private int version;\n\n        public Builder(GraphIndex graphIndex, Path outPath) throws FileNotFoundException {\n            this(graphIndex, new BufferedRandomAccessWriter(outPath));\n        }\n\n        public Builder(GraphIndex graphIndex, RandomAccessWriter out) {\n            this.graphIndex = graphIndex;\n            this.out = out;\n            this.features = new EnumMap<>(FeatureId.class);\n            this.version = OnDiskGraphIndex.CURRENT_VERSION;\n        }\n\n\n------------------------------\n------------------------------\n        @Override\n        public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            if (features.containsKey(FeatureId.FUSED_ADC)) {\n                return ((FusedADC) features.get(FeatureId.FUSED_ADC)).approximateScoreFunctionFor(queryVector, vsf, this, rerankerFor(queryVector, vsf));\n            } else {\n                throw new UnsupportedOperationException(\"No approximate score function available for this graph\");\n            }\n        }\n    }\n\n    /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\n    public static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n        write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), path);\n    }\n\n    /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void write(GraphIndex graph,\n# Natural Language Annotations: /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    try (RandomAccessWriter writer = new BufferedRandomAccessWriter(path)) {\n        write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), writer);\n    }\n}\n```\n", "```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    RandomAccessWriter out = new BufferedRandomAccessWriter(path);\n    write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), out);\n    out.close();\n}\n```\n", "```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    try (RandomAccessWriter writer = new BufferedRandomAccessWriter(path)) {\n        new GraphIndexWriter.Builder(graph, writer)\n                .write();\n    }\n}\n```\n\nThis function is a convenience function that writes a vanilla DiskANN-style index with no extra features. It takes a GraphIndex object, a RandomAccessVectorValues object, and a Path object, and writes the index to the specified path. It throws an IOException if there is a problem writing to the file.\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n    @Override\n    public VectorFloat<?> getVector(int nodeId) {\n        return map.get(nodeId);\n    }\n\n    @Override\n    public boolean isValueShared() {\n        return false;\n    }\n\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n}\n\n------------------------------\n------------------------------\n        return scoreFunction.isExact()\n                ? (ScoreFunction.ExactScoreFunction) scoreFunction\n                : reranker;\n    }\n\n    /**\n     * A SearchScoreProvider for a single-pass search based on exact similarity.\n     * Generally only suitable when your RandomAccessVectorValues is entirely in-memory,\n     * e.g. during construction.\n     */\n    public static SearchScoreProvider exact(VectorFloat<?> v, VectorSimilarityFunction vsf, RandomAccessVectorValues ravv) {\n        // don't use ESF.reranker, we need thread safety here\n        var sf = new ScoreFunction.ExactScoreFunction() {\n            @Override\n            public float similarityTo(int node2) {\n                return vsf.compare(v, ravv.getVector(node2));\n            }\n        };\n        return new SearchScoreProvider(sf);\n    }\n\n------------------------------\n------------------------------\n\n    @Override\n    public int dimension() {\n        return dimension;\n    }\n\n    @Override\n    public boolean isValueShared() {\n        return false;\n    }\n\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n\n    @Override\n    public void getVectorInto(int nodeId, VectorFloat<?> result, int offset) {\n        // getVectorInto is only called by reranking, not diversity code\n        throw new UnsupportedOperationException();\n\n------------------------------\n------------------------------\n    @Override\n    public RandomAccessVectorValues copy() {\n        return this;\n    }\n}\n\n------------------------------\n------------------------------\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.rerankerFor(queryVector, vsf);\n        }\n\n        @Override\n        public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return view.approximateScoreFunctionFor(queryVector, vsf);\n        }\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static SearchScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return SearchScoreProvider.exact(ravv.getVector(0), similarityFunction, ravv);\n}\n```\n", "```java\npublic static SearchScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return SearchScoreProvider.exact(ravv.getRandomVector(), similarityFunction, ravv);\n}\n```\n", "```java\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            return ravv::getVector;\n        }\n\n        @Override\n        public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n            throw new UnsupportedOperationException();\n        }\n    };\n}\n```\n"]}, "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        }\n        return new SimpleScore(initScore, score);\n    }\n\n    public static SimpleScore of(int score) {\n        return switch (score) {\n            case -1 -> MINUS_ONE;\n            case 0 -> ZERO;\n            case 1 -> ONE;\n            default -> new SimpleScore(0, score);\n        };\n    }\n\n    // ************************************************************************\n    // Fields\n    // ************************************************************************\n\n    private final int initScore;\n    private final int score;\n\n\n------------------------------\n------------------------------\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = (int) Math.floor(hardScores[i] * multiplicand);\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n            newSoftScores[i] = (int) Math.floor(softScores[i] * multiplicand);\n        }\n        return new BendableScore(\n                (int) Math.floor(initScore * multiplicand),\n                newHardScores, newSoftScores);\n    }\n\n    @Override\n    public BendableScore divide(double divisor) {\n        int[] newHardScores = new int[hardScores.length];\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = (int) Math.floor(hardScores[i] / divisor);\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n\n------------------------------\n------------------------------\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = -hardScores[i];\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n            newSoftScores[i] = -softScores[i];\n        }\n        return new BendableScore(-initScore, newHardScores, newSoftScores);\n    }\n\n    @Override\n    public BendableScore abs() {\n        int[] newHardScores = new int[hardScores.length];\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = Math.abs(hardScores[i]);\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n            newSoftScores[i] = Math.abs(softScores[i]);\n        }\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n    // TODO Do the locale formatting in benchmarkReport.html.ftl - https://issues.redhat.com/browse/PLANNER-169\n    public static String getStandardDeviationString(double[] standardDeviationDoubles) {\n        if (standardDeviationDoubles == null) {\n            return null;\n        }\n        StringBuilder standardDeviationString = new StringBuilder(standardDeviationDoubles.length * 9);\n        // Abbreviate to 2 decimals\n        // We don't use a local sensitive DecimalFormat, because other Scores don't use it either (see PLANNER-169)\n\n------------------------------\n------------------------------\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = (int) Math.floor(hardScores[i] / divisor);\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n            newSoftScores[i] = (int) Math.floor(softScores[i] / divisor);\n        }\n        return new BendableScore(\n                (int) Math.floor(initScore / divisor),\n                newHardScores, newSoftScores);\n    }\n\n    @Override\n    public BendableScore power(double exponent) {\n        int[] newHardScores = new int[hardScores.length];\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = (int) Math.floor(Math.pow(hardScores[i], exponent));\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double[] determineStandardDeviationDoubles(\n# Natural Language Annotations: /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double sum = 0.0, standardDeviation = 0.0;\n    int length = averageScore.length;\n\n    for(double num : averageScore) {\n        sum += num;\n    }\n\n    double mean = sum/length;\n\n    for(double num: averageScore) {\n        standardDeviation += Math.pow(num - mean, 2);\n    }\n\n    double[] standardDeviationDoubles = new double[1];\n    standardDeviationDoubles[0] = Math.sqrt(standardDeviation/length);\n\n    return standardDeviationDoubles;\n}\n```\n", "```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double sum = 0.0, standardDeviation = 0.0;\n    int length = averageScore.length;\n\n    for(double num : averageScore) {\n        sum += num;\n    }\n\n    double mean = sum/length;\n\n    for(double num: averageScore) {\n        standardDeviation += Math.pow(num - mean, 2);\n    }\n\n    double[] result = new double[length];\n    Arrays.fill(result, Math.sqrt(standardDeviation/length));\n    return result;\n}\n```\n", "```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double sum = 0.0, standardDeviation = 0.0;\n    int length = averageScore.length;\n\n    for(double num : averageScore) {\n        sum += num;\n    }\n\n    double mean = sum/length;\n\n    for(double num: averageScore) {\n        standardDeviation += Math.pow(num - mean, 2);\n    }\n\n    double[] standardDeviationDoubles = new double[averageScore.length];\n\n    for(int i = 0; i < length; i++) {\n        standardDeviationDoubles[i] = Math.sqrt(standardDeviation/length);\n    }\n\n    return standardDeviationDoubles;\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n    /**\n     * Return a new StackMetadata with TOS popped\n     */\n    public StackMetadata pop() {\n        StackMetadata out = copy();\n        out.stackValueSources.remove(stackValueSources.size() - 1);\n        return out;\n    }\n\n    /**\n     * Return a new StackMetadata with the top {@code count} items popped.\n     */\n    public StackMetadata pop(int count) {\n        StackMetadata out = copy();\n\n------------------------------\n------------------------------\n     * @param type The type to push to TOS\n     */\n    public StackMetadata push(ValueSourceInfo type) {\n        StackMetadata out = copy();\n        out.stackValueSources.add(type);\n        return out;\n    }\n\n    public StackMetadata set(int index, ValueSourceInfo type) {\n        StackMetadata out = copy();\n        out.stackValueSources.set(getListIndexForStackIndex(index), type);\n        return out;\n    }\n\n    public StackMetadata pushTemp(PythonLikeType type) {\n        return push(ValueSourceInfo.of(new OpcodeWithoutSource(), type));\n    }\n\n    /**\n     * Return a new StackMetadata with {@code types} added as the new\n\n------------------------------\n------------------------------\n\n    public final LocalVariableHelper localVariableHelper;\n\n    private final List<ValueSourceInfo> stackValueSources;\n    private final List<ValueSourceInfo> localVariableValueSources;\n    private final List<ValueSourceInfo> cellVariableValueSources;\n\n    private List<String> callKeywordNameList;\n\n    private StackMetadata() {\n        this.localVariableHelper = null;\n        this.stackValueSources = null;\n        this.localVariableValueSources = null;\n        this.cellVariableValueSources = null;\n        this.callKeywordNameList = null;\n    }\n\n    public StackMetadata(LocalVariableHelper localVariableHelper) {\n        this.localVariableHelper = localVariableHelper;\n        this.stackValueSources = new ArrayList<>();\n\n------------------------------\n------------------------------\n    public StackMetadata pushTemps(PythonLikeType... types) {\n        StackMetadata out = copy();\n        for (PythonLikeType type : types) {\n            out.stackValueSources.add(ValueSourceInfo.of(new OpcodeWithoutSource(), type));\n        }\n        return out;\n    }\n\n    /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        return push(ValueSourceInfo.of(new OpcodeWithoutSource(), type));\n    }\n\n    /**\n     * Return a new StackMetadata with {@code types} added as the new\n     * elements. The last element of {@code types} is TOS.\n     *\n     * @param types The types to push to TOS\n     */\n    public StackMetadata push(ValueSourceInfo... types) {\n        StackMetadata out = copy();\n        out.stackValueSources.addAll(Arrays.asList(types));\n        return out;\n    }\n\n    public StackMetadata pushTemps(PythonLikeType... types) {\n        StackMetadata out = copy();\n        for (PythonLikeType type : types) {\n            out.stackValueSources.add(ValueSourceInfo.of(new OpcodeWithoutSource(), type));\n        }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata stack(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = copy();\n    out.stackValueSources.clear();\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```\n", "```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = copy();\n    out.stackValueSources.clear();\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```\n", "```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = copy();\n    out.stackValueSources.clear();\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    public StackMetadata(LocalVariableHelper localVariableHelper) {\n        this.localVariableHelper = localVariableHelper;\n        this.stackValueSources = new ArrayList<>();\n        this.localVariableValueSources = new ArrayList<>(localVariableHelper.getNumberOfLocalVariables());\n        this.cellVariableValueSources = new ArrayList<>(localVariableHelper.getNumberOfCells());\n        for (int i = 0; i < localVariableHelper.getNumberOfLocalVariables(); i++) {\n            localVariableValueSources.add(null);\n        }\n        for (int i = 0; i < localVariableHelper.getNumberOfCells(); i++) {\n            cellVariableValueSources.add(ValueSourceInfo.of(new OpcodeWithoutSource(),\n                    BuiltinTypes.BASE_TYPE));\n        }\n        this.callKeywordNameList = Collections.emptyList();\n    }\n\n    private StackMetadata(LocalVariableHelper localVariableHelper, List<ValueSourceInfo> stackValueSources,\n            List<ValueSourceInfo> localVariableValueSources, List<ValueSourceInfo> cellVariableValueSources,\n            List<String> callKeywordNameList) {\n\n------------------------------\n------------------------------\n\n    public DelegatePythonIterator getPythonIterator() {\n        return new DelegatePythonIterator(iterator());\n    }\n\n    @Override\n    public Object[] toArray() {\n        PythonInteger[] out = new PythonInteger[size()];\n\n        for (int i = 0; i < out.length; i++) {\n            out[i] = get(i);\n        }\n\n        return out;\n    }\n\n    @Override\n    public <T> T[] toArray(T[] ts) {\n        T[] out = ts;\n        if (ts.length < size()) {\n\n------------------------------\n------------------------------\n\n    @Override\n    protected StackMetadata getStackMetadataAfterInstruction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        StackMetadata newStackMetadata = stackMetadata.pop();\n        for (int i = 0; i < instruction.arg(); i++) {\n            newStackMetadata = newStackMetadata.push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                    stackMetadata.getValueSourcesUpToStackIndex(1)));\n        }\n        return newStackMetadata;\n    }\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        CollectionImplementor.unpackSequence(functionMetadata.methodVisitor, instruction.arg(),\n                stackMetadata.localVariableHelper);\n    }\n}\n\n------------------------------\n------------------------------\n        out.localVariableValueSources.set(index, type);\n        return out;\n    }\n\n    /**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        }\n\n        for (int i = 0; i < out.cellVariableValueSources.size(); i++) {\n            out.cellVariableValueSources.set(i,\n                    unifyTypes(cellVariableValueSources.get(i), other.cellVariableValueSources.get(i)));\n        }\n\n        return out;\n    }\n\n    private static ValueSourceInfo unifyTypes(ValueSourceInfo a, ValueSourceInfo b) {\n        if (Objects.equals(a, b)) {\n            return a;\n        }\n\n        if (a == null) { // a or b are null when they are deleted/are not set yet\n            return b; // TODO: Optional type?\n        }\n\n        if (b == null) {\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata locals(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableValueSources.size()) {\n        throw new IllegalArgumentException(\"Types length does not match local variable types size\");\n    }\n\n    StackMetadata out = new StackMetadata(this.localVariableHelper);\n    for (int i = 0; i < types.length; i++) {\n        out.localVariableValueSources.set(i, types[i]);\n    }\n\n    return out;\n}\n```\n", "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableValueSources.size()) {\n        throw new IllegalArgumentException(\"types.length != localVariableTypes.size.\");\n    }\n\n    StackMetadata out = this;\n    for (int i = 0; i < types.length; i++) {\n        out = out.setLocalVariableType(i, types[i]);\n    }\n\n    return out;\n}\n```\n", "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableValueSources.size()) {\n        throw new IllegalArgumentException(\"Types length does not match localVariableTypes size\");\n    }\n\n    StackMetadata out = this.clone();  // clone the current StackMetadata\n    for (int i = 0; i < types.length; i++) {\n        out.localVariableValueSources.set(i, types[i]);\n    }\n    return out;\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, argCount);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n                Type.getMethodDescriptor(Type.getType(Map.class)),\n                false);\n\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n        // Stack is callable, argument_list, null\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n\n    public static void callGenericFunction(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, int argCount) {\n        // stack is callable, arg0, arg1, ..., arg(argc - 1)\n\n------------------------------\n------------------------------\n            PythonBytecodeInstruction instruction) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n\n        // Stack is module\n\n        // Duplicate module\n        methodVisitor.visitInsn(Opcodes.DUP);\n\n        // Stack is module, module\n\n        // Push the attribute name to load\n        methodVisitor.visitLdcInsn(functionMetadata.pythonCompiledFunction.co_names.get(instruction.arg()));\n\n        // Stack is module, module, attribute_name\n\n        // Get the attribute\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getAttributeOrError\",\n                Type.getMethodDescriptor(Type.getType(PythonLikeObject.class), Type.getType(String.class)),\n                true);\n\n------------------------------\n------------------------------\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.objectweb.asm.Type;\n\n/**\n * Implements opcodes related to functions\n */\npublic class FunctionImplementor {\n\n    public static void callBinaryMethod(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, String methodName) {\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n                true);\n        methodVisitor.visitLdcInsn(methodName);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getAttributeOrError\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n\n------------------------------\n------------------------------\n        getCallerInstance(functionMetadata, stackMetadata);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n\n    public static void callBinaryMethod(MethodVisitor methodVisitor, String methodName) {\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n                true);\n        methodVisitor.visitLdcInsn(methodName);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getAttributeOrError\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(String.class)),\n                true);\n\n------------------------------\n------------------------------\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\n    private static void loadGenericMethod(FunctionMetadata functionMetadata, MethodVisitor methodVisitor, String className,\n            PythonCompiledFunction function,\n            StackMetadata stackMetadata, int nameIndex) {\n\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n                true);\n        methodVisitor.visitLdcInsn(function.co_names.get(nameIndex));\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PythonLikeType.class),\n                \"loadMethod\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(String.class)),\n                false);\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n        Label blockEnd = new Label();\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n        MethodVisitor methodVisitor, String className, PythonCompiledFunction function, int nameIndex) {\n\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n            \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n            true);\n    methodVisitor.visitLdcInsn(function.co_names.get(nameIndex));\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PythonLikeType.class),\n            \"loadMethod\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(String.class)),\n            false);\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n}\n```\n", "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n\n    methodVisitor.visitInsn(Opcodes.SWAP);\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n            \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n            true);\n    methodVisitor.visitLdcInsn(functionMetadata.pythonCompiledFunction.co_names.get(nameIndex));\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PythonLikeType.class),\n            \"loadMethod\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(String.class)),\n            false);\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n}\n```\n", "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, String className, PythonCompiledFunction function, int nameIndex) {\n\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n                \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n                true);\n        methodVisitor.visitLdcInsn(function.co_names.get(nameIndex));\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PythonLikeType.class),\n                \"loadMethod\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(String.class)),\n                false);\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n        Label blockEnd = new Label();\n    }\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nimport ai.timefold.jpyinterpreter.types.PythonLikeType;\n\npublic class CallOpcode extends AbstractOpcode {\n\n    public CallOpcode(PythonBytecodeInstruction instruction) {\n        super(instruction);\n    }\n\n    @Override\n    protected StackMetadata getStackMetadataAfterInstruction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(instruction.arg() + 1);\n        if (functionType instanceof PythonLikeGenericType) {\n            functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n        }\n        if (functionType instanceof PythonKnownFunctionType) {\n            PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n            List<String> keywordArgumentNameList = stackMetadata.getCallKeywordNameList();\n            List<PythonLikeType> callStackParameterTypes = stackMetadata.getValueSourcesUpToStackIndex(instruction.arg())\n                    .stream().map(ValueSourceInfo::getValueType).collect(Collectors.toList());\n\n\n------------------------------\n------------------------------\n        // null, method if it was not in type (if Python 3.11+)\n    }\n\n    public static void setCallKeywordNameTuple(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n            int constantIndex) {\n        LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n        PythonConstantsImplementor.loadConstant(functionMetadata.methodVisitor, functionMetadata.className, constantIndex);\n        localVariableHelper.writeCallKeywords(functionMetadata.methodVisitor);\n    }\n\n    /**\n     * Calls a function. argc is the number of positional arguments. Keyword arguments are stored in a local variable.\n     * Keyword arguments (if any) are at the top of the stack, followed by, positional arguments.\n     * Below them either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n    public static void call(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int argumentCount) {\n        PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(argumentCount + 1);\n        if (functionType instanceof PythonLikeGenericType) {\n            functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n\n------------------------------\n------------------------------\n    public CallFunctionKeywordOpcode(PythonBytecodeInstruction instruction) {\n        super(instruction);\n    }\n\n    @Override\n    protected StackMetadata getStackMetadataAfterInstruction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(instruction.arg() + 1);\n        if (functionType instanceof PythonLikeGenericType) {\n            functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n        }\n        if (functionType instanceof PythonKnownFunctionType) {\n            PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n            return knownFunctionType.getDefaultFunctionSignature()\n                    .map(functionSignature -> stackMetadata.pop(instruction.arg() + 2).push(ValueSourceInfo.of(this,\n                            functionSignature.getReturnType(),\n                            stackMetadata.getValueSourcesUpToStackIndex(instruction.arg() + 2))))\n                    .orElseGet(() -> stackMetadata.pop(instruction.arg() + 2)\n                            .push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                                    stackMetadata.getValueSourcesUpToStackIndex(instruction.arg() + 2))));\n        }\n\n------------------------------\n------------------------------\n    public CallFunctionOpcode(PythonBytecodeInstruction instruction) {\n        super(instruction);\n    }\n\n    @Override\n    protected StackMetadata getStackMetadataAfterInstruction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(instruction.arg());\n        if (functionType instanceof PythonLikeGenericType) {\n            functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n        }\n        if (functionType instanceof PythonKnownFunctionType) {\n            PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n            return knownFunctionType.getDefaultFunctionSignature()\n                    .map(functionSignature -> stackMetadata.pop(instruction.arg() + 1).push(ValueSourceInfo.of(this,\n                            functionSignature.getReturnType(),\n                            stackMetadata.getValueSourcesUpToStackIndex(instruction.arg() + 1))))\n                    .orElseGet(() -> stackMetadata.pop(instruction.arg() + 1)\n                            .push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                                    stackMetadata.getValueSourcesUpToStackIndex(instruction.arg() + 1))));\n        }\n\n------------------------------\n------------------------------\n     */\n    public static void call(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int argumentCount) {\n        PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(argumentCount + 1);\n        if (functionType instanceof PythonLikeGenericType) {\n            functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n        }\n        if (functionType instanceof PythonKnownFunctionType) {\n            PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n            List<String> keywordArgumentNameList = stackMetadata.getCallKeywordNameList();\n            List<PythonLikeType> callStackParameterTypes = stackMetadata.getValueSourcesUpToStackIndex(argumentCount)\n                    .stream().map(ValueSourceInfo::getValueType).collect(Collectors.toList());\n\n            knownFunctionType\n                    .getFunctionForParameters(argumentCount - keywordArgumentNameList.size(), keywordArgumentNameList,\n                            callStackParameterTypes)\n                    .ifPresentOrElse(functionSignature -> {\n                        KnownCallImplementor.callPython311andAbove(functionSignature, functionMetadata, stackMetadata,\n                                argumentCount,\n                                stackMetadata.getCallKeywordNameList());\n                    }, () -> callGeneric(functionMetadata, stackMetadata, argumentCount));\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor,\n# Natural Language Annotations: /**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argumentCount) {\n    PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(argumentCount + 1);\n    if (functionType instanceof PythonLikeGenericType) {\n        functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n    }\n    if (functionType instanceof PythonKnownFunctionType) {\n        PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n        knownFunctionType.getDefaultFunctionSignature()\n                .map(functionSignature -> stackMetadata.pop(argumentCount + 2).push(ValueSourceInfo.of(this,\n                        functionSignature.getReturnType(),\n                        stackMetadata.getValueSourcesUpToStackIndex(argumentCount + 2))))\n                .orElseGet(() -> stackMetadata.pop(argumentCount + 2)\n                        .push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                                stackMetadata.getValueSourcesUpToStackIndex(argumentCount + 2))));\n    }\n}\n```\n", "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argumentCount) {\n    PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(argumentCount + 1);\n    if (functionType instanceof PythonLikeGenericType) {\n        functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n    }\n    if (functionType instanceof PythonKnownFunctionType) {\n        PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n        knownFunctionType\n                .getFunctionForParameters(argumentCount, Collections.emptyList(),\n                        stackMetadata.getValueSourcesUpToStackIndex(argumentCount)\n                                .stream().map(ValueSourceInfo::getValueType).collect(Collectors.toList()))\n                .ifPresentOrElse(functionSignature -> {\n                    KnownCallImplementor.callPython311andAbove(functionSignature, functionMetadata, stackMetadata,\n                            argumentCount,\n                            Collections.emptyList());\n                }, () -> callGeneric(functionMetadata, stackMetadata, argumentCount));\n    }\n}\n```\n", "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argumentCount) {\n    PythonLikeType functionType = stackMetadata.getTypeAtStackIndex(argumentCount);\n    if (functionType instanceof PythonLikeGenericType) {\n        functionType = ((PythonLikeGenericType) functionType).getOrigin().getConstructorType().orElse(null);\n    }\n    if (functionType instanceof PythonKnownFunctionType) {\n        PythonKnownFunctionType knownFunctionType = (PythonKnownFunctionType) functionType;\n        knownFunctionType\n                .getDefaultFunctionSignature()\n                .map(functionSignature -> stackMetadata.pop(argumentCount + 1).push(ValueSourceInfo.of(this,\n                        functionSignature.getReturnType(),\n                        stackMetadata.getValueSourcesUpToStackIndex(argumentCount + 1))))\n                .orElseGet(() -> stackMetadata.pop(argumentCount + 1)\n                        .push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                                stackMetadata.getValueSourcesUpToStackIndex(argumentCount + 1))));\n    }\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        JumpImplementor.jumpIfTrueElsePop(functionMetadata, stackMetadata, jumpTarget);\n    }\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        JumpImplementor.jumpIfFalseElsePop(functionMetadata, stackMetadata, jumpTarget);\n    }\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        JumpImplementor.popAndJumpIfTrue(functionMetadata, stackMetadata, jumpTarget);\n    }\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        DunderOperatorImplementor.unaryOperator(functionMetadata.methodVisitor, stackMetadata, operator);\n    }\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        StringImplementor.formatValue(functionMetadata.methodVisitor, instruction);\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunction(FunctionMetadata functionMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callFunction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Your code here\n}\n```\n", "```java\npublic static void callFunction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n    // TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n    // the result is pushed onto the stack.\n    FunctionMetadata functionToCall = stackMetadata.pop();\n    Object[] arguments = new Object[functionMetadata.argc];\n    for (int i = functionMetadata.argc - 1; i >= 0; i--) {\n        arguments[i] = stackMetadata.pop();\n    }\n    Object result = functionToCall.invoke(arguments);\n    stackMetadata.push(result);\n}\n```\n", "```java\npublic static void callFunction(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n    // TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n    // the result is pushed onto the stack.\n    // Implementation details are not provided in the question, so I'm assuming a general implementation.\n    // You might need to adjust it based on the actual requirements and the provided code snippets.\n\n    Object[] args = new Object[stackMetadata.getArgc()];\n    for (int i = 0; i < args.length; i++) {\n        args[i] = stackMetadata.pop();\n    }\n\n    Object function = stackMetadata.pop();\n    Object result = callFunction(function, args);\n    stackMetadata.push(result);\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, argCount);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n                Type.getMethodDescriptor(Type.getType(Map.class)),\n                false);\n\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n        // Stack is callable, argument_list, null\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n\n    public static void callGenericFunction(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, int argCount) {\n        // stack is callable, arg0, arg1, ..., arg(argc - 1)\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n    public static void callGenericFunction(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n        callGenericFunction(functionMetadata, stackMetadata, methodVisitor, instruction.arg());\n    }\n\n    public static void callGenericFunction(MethodVisitor methodVisitor, int argCount) {\n        // stack is callable, arg0, arg1, ..., arg(argc - 1)\n        CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, argCount);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n                Type.getMethodDescriptor(Type.getType(Map.class)),\n                false);\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n    private static void callGenericMethod(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor,\n            PythonBytecodeInstruction instruction,\n            LocalVariableHelper localVariableHelper) {\n        // Stack is method, (obj or null), arg0, ..., arg(argc - 1)\n        CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, instruction.arg());\n        methodVisitor.visitInsn(Opcodes.SWAP);\n\n------------------------------\n------------------------------\n        // the same number of elements in the stack), we need to add the tuple/map in the same object\n        // which will delegate it to either the tuple or the map depending on position and the first item size\n        CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n        // stack is callable, tupleMapPair\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"tuple\",\n                Type.getDescriptor(PythonLikeTuple.class));\n\n        // stack is callable, tupleMapPair, positionalArgs\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"map\",\n                Type.getDescriptor(PythonLikeDict.class));\n\n        getCallerInstance(functionMetadata, stackMetadata);\n\n        // Stack is callable, positionalArgs, keywordArgs\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n\n------------------------------\n------------------------------\n\n\n    /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n    public static void callGenericFunctionWithKeywords(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n        // stack is callable, arg0, arg1, ..., arg(argc - len(keys)), ..., arg(argc - 1), keys\n        // We know the total number of arguments, but not the number of individual positional/keyword arguments\n        // Since Java Bytecode require consistent stack frames  (i.e. the body of a loop must start with\n        // the same number of elements in the stack), we need to add the tuple/map in the same object\n        // which will delegate it to either the tuple or the map depending on position and the first item size\n        CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n        // stack is callable, tupleMapPair\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n        // stack is callable, arg0, arg1, ..., arg(argc - len(keys)), ..., arg(argc - 1), keys\n        // We know the total number of arguments, but not the number of individual positional/keyword arguments\n        // Since Java Bytecode require consistent stack frames  (i.e. the body of a loop must start with\n        // the same number of elements in the stack), we need to add the tuple/map in the same object\n        // which will delegate it to either the tuple or the map depending on position and the first item size\n        CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n        // stack is callable, tupleMapPair\n        methodVisitor.visitInsn(Opcodes.DUP);\n        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"tuple\",\n                Type.getDescriptor(PythonLikeTuple.class));\n\n        // stack is callable, tupleMapPair, positionalArgs\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"map\",\n                Type.getDescriptor(PythonLikeDict.class));\n\n        getCallerInstance(functionMetadata, stackMetadata);\n\n        // Stack is callable, positionalArgs, keywordArgs\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n```\n", "```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n    // stack is callable, arg0, arg1, ..., arg(argc - len(keys)), ..., arg(argc - 1), keys\n    // We know the total number of arguments, but not the number of individual positional/keyword arguments\n    // Since Java Bytecode require consistent stack frames  (i.e. the body of a loop must start with\n    // the same number of elements in the stack), we need to add the tuple/map in the same object\n    // which will delegate it to either the tuple or the map depending on position and the first item size\n    CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n    // stack is callable, tupleMapPair\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"tuple\", Type.getDescriptor(PythonLikeTuple.class));\n\n    // stack is callable, tupleMapPair, positionalArgs\n    methodVisitor.visitInsn(Opcodes.SWAP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"map\", Type.getDescriptor(PythonLikeDict.class));\n\n    getCallerInstance(functionMetadata, stackMetadata);\n\n    // Stack is callable, positionalArgs, keywordArgs\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class), \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class), Type.getType(List.class), Type.getType(Map.class), Type.getType(PythonLikeObject.class)), true);\n\n    // stack is callable, result\n}\n```\n", "```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // stack is callable, keys, arg0, arg1, ..., arg(argc - 1)\n    CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, instruction.arg());\n\n    // stack is callable, tuple, null\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n            Type.getMethodDescriptor(Type.getType(Map.class)), false);\n\n    // stack is callable, tuple, null, positionalArgs\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // stack is callable, positionalArgs, null, tuple\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n            Type.getMethodDescriptor(Type.getType(Map.class)), false);\n\n    // stack is callable, positionalArgs, null, tuple, null\n    CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n    // stack is callable, positionalArgs, tupleMapPair\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"tuple\",\n            Type.getDescriptor(PythonLikeTuple.class));\n\n    // stack is callable, positionalArgs, tupleMapPair, positionalArgs\n    methodVisitor.visitInsn(Opcodes.SWAP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"map\",\n            Type.getDescriptor(PythonLikeDict.class));\n\n    // stack is callable, positionalArgs, positionalArgs, keywordArgs\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)), true);\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        pythonFunctionSignature.getMethodDescriptor().callMethod(methodVisitor);\n    }\n\n    public static void callUnpackListAndMap(String defaultArgumentHolderClassInternalName, MethodDescriptor methodDescriptor,\n            MethodVisitor methodVisitor) {\n        Type[] descriptorParameterTypes = methodDescriptor.getParameterTypes();\n\n        // TOS2 is the function to call, TOS1 is positional arguments, TOS is keyword arguments\n        if (methodDescriptor.getMethodType() == MethodDescriptor.MethodType.CLASS) {\n            // stack is bound-method, pos, keywords\n            StackManipulationImplementor.rotateThree(methodVisitor);\n            // stack is keywords, bound-method, pos\n            StackManipulationImplementor.swap(methodVisitor);\n\n            // stack is keywords, pos, bound-method\n            methodVisitor.visitInsn(Opcodes.DUP_X2);\n\n            // stack is bound-method, keywords, pos, bound-method\n            methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(BoundPythonLikeFunction.class),\n\n------------------------------\n------------------------------\n\n\n    /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n    public static void callGenericFunctionWithKeywords(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata,\n            MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n        // stack is callable, arg0, arg1, ..., arg(argc - len(keys)), ..., arg(argc - 1), keys\n        // We know the total number of arguments, but not the number of individual positional/keyword arguments\n        // Since Java Bytecode require consistent stack frames  (i.e. the body of a loop must start with\n        // the same number of elements in the stack), we need to add the tuple/map in the same object\n        // which will delegate it to either the tuple or the map depending on position and the first item size\n        CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n        // stack is callable, tupleMapPair\n\n------------------------------\n------------------------------\n\n    @Override\n    public StackMetadata getStackMetadataAfterInstruction(FunctionMetadata functionMetadata,\n            StackMetadata stackMetadata) {\n        if ((instruction.arg() & 4) == 4) {\n            // There is a format argument above the value\n            return stackMetadata.pop(2)\n                    .push(ValueSourceInfo.of(this, BuiltinTypes.STRING_TYPE,\n                            stackMetadata.getValueSourcesUpToStackIndex(2)));\n        } else {\n            // There is no format argument above the value\n            return stackMetadata.pop()\n                    .push(ValueSourceInfo.of(this, BuiltinTypes.STRING_TYPE,\n                            stackMetadata.getValueSourcesUpToStackIndex(1)));\n        }\n    }\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        StringImplementor.formatValue(functionMetadata.methodVisitor, instruction);\n\n------------------------------\n------------------------------\n\n        // Stack is callable, positionalArgs, keywordArgs\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n\n    /**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\n\n\n\n\n\n\n------------------------------\n------------------------------\n            if ((instruction.arg() & 1) == 1) {\n                // Stack is null, callable, iterable, map\n                return stackMetadata.pop(4).push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                        stackMetadata.getValueSourcesUpToStackIndex(3)));\n            } else {\n                // Stack is null, callable, iterable\n                return stackMetadata.pop(3).push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                        stackMetadata.getValueSourcesUpToStackIndex(2)));\n            }\n        }\n    }\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        FunctionImplementor.callFunctionUnpack(functionMetadata, stackMetadata, instruction);\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata, PythonBytecodeInstruction instruction) {\n    // Stack is null, callable, iterable, map\n    if ((instruction.arg() & 1) == 1) {\n        // Stack is null, callable, iterable, map\n        stackMetadata.pop(4);\n        stackMetadata.push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                stackMetadata.getValueSourcesUpToStackIndex(3)));\n    } else {\n        // Stack is null, callable, iterable\n        stackMetadata.pop(3);\n        stackMetadata.push(ValueSourceInfo.of(this, BuiltinTypes.BASE_TYPE,\n                stackMetadata.getValueSourcesUpToStackIndex(2)));\n    }\n}\n```\n", "```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n    if ((instruction.arg() & 1) == 1) {\n        // Stack is null, callable, iterable, map\n        StackManipulationImplementor.rotateFour(methodVisitor);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    } else {\n        // Stack is null, callable, iterable\n        StackManipulationImplementor.rotateThree(methodVisitor);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n}\n```\n", "```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n        MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n    if ((instruction.arg() & 1) == 1) {\n        // Stack is null, callable, iterable, map\n        StackManipulationImplementor.rotateFour(methodVisitor);\n        // Stack is callable, iterable, map, null\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(CollectionImplementor.class),\n                \"unpackCollection\", Type.getMethodDescriptor(Type.getType(Iterable.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class)),\n                false);\n        // Stack is positionalArgs, keywordArgs\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    } else {\n        // Stack is null, callable, iterable\n        StackManipulationImplementor.rotateThree(methodVisitor);\n        // Stack is callable, iterable, null\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(CollectionImplementor.class),\n                \"unpackCollection\", Type.getMethodDescriptor(Type.getType(Iterable.class),\n                        Type.getType(List.class)),\n                false);\n        // Stack is positionalArgs\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        CollectionImplementor.unpackSequenceWithTail(functionMetadata.methodVisitor, instruction.arg(),\n                stackMetadata.localVariableHelper);\n    }\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        DunderOperatorImplementor.unaryOperator(functionMetadata.methodVisitor, stackMetadata, operator);\n    }\n}\n\n------------------------------\n------------------------------\n        return true;\n    }\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        ExceptionImplementor.reraise(functionMetadata.methodVisitor);\n    }\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public void implement(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        StringImplementor.formatValue(functionMetadata.methodVisitor, instruction);\n    }\n}\n\n------------------------------\n------------------------------\n    public static void deleteCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n\n        // Deleting is implemented as setting the value to null\n        loadCell(functionMetadata, stackMetadata, cellIndex);\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, Type.getInternalName(PythonCell.class), \"cellValue\",\n                Type.getDescriptor(PythonLikeObject.class));\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex,\n# Natural Language Annotations: /**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    methodVisitor.visitVarInsn(Opcodes.ALOAD, globalIndex);\n}\n```\n", "```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    methodVisitor.visitVarInsn(Opcodes.ALOAD, globalIndex);\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, \"org/python/compiler/PythonBytecodeUtils\", \"getVariableName\", \"(Ljava/lang/Object;)Ljava/lang/String;\", false);\n    methodVisitor.visitFieldInsn(Opcodes.PUTSTATIC, \"org/python/compiler/PythonBytecodeUtils\", \"__name__\", \"Ljava/lang/String;\");\n}\n```\n", "```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    String globalName = stackMetadata.globalVariableHelper.getGlobalVariableName(globalIndex);\n    methodVisitor.visitVarInsn(Opcodes.ALOAD, globalIndex);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, stackMetadata.getLocalVariablesHelper().getClassName(), globalName, Type.getDescriptor(PythonLikeObject.class));\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            stackMetadata.localVariableHelper.readTemp(methodVisitor,\n                    Type.getType(stackMetadata.getTypeAtStackIndex(i).getJavaTypeDescriptor()),\n                    stackLocalVariables[i]);\n        }\n\n        return stackLocalVariables;\n    }\n\n    public static void restoreStack(MethodVisitor methodVisitor, StackMetadata stackMetadata, int[] stackLocalVariables) {\n        for (int i = 0; i < stackLocalVariables.length; i++) {\n            stackMetadata.localVariableHelper.readTemp(methodVisitor,\n                    Type.getType(stackMetadata.getTypeAtStackIndex(i).getJavaTypeDescriptor()),\n                    stackLocalVariables[i]);\n        }\n    }\n\n    public static void storeExceptionTableStack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n            ExceptionBlock exceptionBlock) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n        LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n------------------------------\n------------------------------\n\n    /**\n     * Move TOS down two places, and pushes TOS1 and TOS2 up one:\n     *\n     * (i.e. ..., TOS2, TOS1, TOS -> ..., TOS, TOS2, TOS1)\n     */\n    public static void rotateThree(MethodVisitor methodVisitor) {\n        methodVisitor.visitInsn(Opcodes.DUP_X2);\n        methodVisitor.visitInsn(Opcodes.POP);\n    }\n\n    /**\n     * Move TOS down three places, and pushes TOS1, TOS2 and TOS3 up one:\n     *\n     * (i.e. ..., TOS3, TOS2, TOS1, TOS -> ..., TOS, TOS3, TOS2, TOS1)\n     */\n    public static void rotateFour(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n        LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n\n------------------------------\n------------------------------\n        methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(PythonCell.class));\n        localVariableHelper.writeFreeCell(methodVisitor, cellIndex);\n    }\n\n    /**\n     * Loads the cell indicated by the {@code instruction} argument onto the stack.\n     * This is used by {@link VariableOpDescriptor#LOAD_CLOSURE} when creating a closure\n     * for a dependent function.\n     */\n    public static void loadCell(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n        LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n        localVariableHelper.readCell(methodVisitor, cellIndex);\n    }\n\n    /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\n\n------------------------------\n------------------------------\n     */\n    public static void rotateFour(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n        LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n        int secondFromStack = localVariableHelper.newLocal();\n        int thirdFromStack = localVariableHelper.newLocal();\n\n        methodVisitor.visitInsn(Opcodes.DUP_X2);\n        methodVisitor.visitInsn(Opcodes.POP);\n\n        localVariableHelper.writeTemp(methodVisitor,\n                Type.getType(stackMetadata.getTypeAtStackIndex(1).getJavaTypeDescriptor()),\n                secondFromStack);\n        localVariableHelper.writeTemp(methodVisitor,\n                Type.getType(stackMetadata.getTypeAtStackIndex(2).getJavaTypeDescriptor()),\n                thirdFromStack);\n\n        methodVisitor.visitInsn(Opcodes.SWAP);\n\n\n------------------------------\n------------------------------\n    public static void deleteCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n\n        // Deleting is implemented as setting the value to null\n        loadCell(functionMetadata, stackMetadata, cellIndex);\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n        methodVisitor.visitFieldInsn(Opcodes.PUTFIELD, Type.getInternalName(PythonCell.class), \"cellValue\",\n                Type.getDescriptor(PythonLikeObject.class));\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n# Natural Language Annotations: /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```\n", "```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```\n", "```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            throw FieldCloningUtils.createExceptionOnRead(bean, field, e);\n        }\n    }\n\n    private static void setFieldValue(Object bean, Field field, boolean value) {\n        try {\n            field.setBoolean(bean, value);\n        } catch (IllegalAccessException e) {\n            throw FieldCloningUtils.createExceptionOnWrite(bean, field, value, e);\n        }\n    }\n\n    static void copyByte(Field field, Object original, Object clone) {\n        byte originalValue = getByteFieldValue(original, field);\n        setFieldValue(clone, field, originalValue);\n    }\n\n    private static byte getByteFieldValue(Object bean, Field field) {\n        try {\n            return field.getByte(bean);\n\n------------------------------\n------------------------------\n        try {\n            return field.get(bean);\n        } catch (IllegalAccessException e) {\n            throw createExceptionOnRead(bean, field, e);\n        }\n    }\n\n    private static RuntimeException createExceptionOnRead(Object bean, Field field, Exception rootCause) {\n        return new IllegalStateException(\"The class (\" + bean.getClass() + \") has a field (\" + field\n                + \") which cannot be read to create a planning clone.\", rootCause);\n    }\n\n    static void setObjectFieldValue(Object bean, Field field, Object value) {\n        try {\n            field.set(bean, value);\n        } catch (IllegalAccessException e) {\n            throw createExceptionOnWrite(bean, field, value, e);\n        }\n    }\n\n\n------------------------------\n------------------------------\n    }\n\n    private static byte getByteFieldValue(Object bean, Field field) {\n        try {\n            return field.getByte(bean);\n        } catch (IllegalAccessException e) {\n            throw FieldCloningUtils.createExceptionOnRead(bean, field, e);\n        }\n    }\n\n    private static void setFieldValue(Object bean, Field field, byte value) {\n        try {\n            field.setByte(bean, value);\n        } catch (IllegalAccessException e) {\n            throw FieldCloningUtils.createExceptionOnWrite(bean, field, value, e);\n        }\n    }\n\n    static void copyChar(Field field, Object original, Object clone) {\n        char originalValue = getCharFieldValue(original, field);\n\n------------------------------\n------------------------------\n        }\n    }\n\n    static void copyChar(Field field, Object original, Object clone) {\n        char originalValue = getCharFieldValue(original, field);\n        setFieldValue(clone, field, originalValue);\n    }\n\n    private static char getCharFieldValue(Object bean, Field field) {\n        try {\n            return field.getChar(bean);\n        } catch (IllegalAccessException e) {\n            throw FieldCloningUtils.createExceptionOnRead(bean, field, e);\n        }\n    }\n\n    private static void setFieldValue(Object bean, Field field, char value) {\n        try {\n            field.setChar(bean, value);\n        } catch (IllegalAccessException e) {\n\n------------------------------\n------------------------------\n\n    private static void setFieldValue(Object bean, Field field, char value) {\n        try {\n            field.setChar(bean, value);\n        } catch (IllegalAccessException e) {\n            throw FieldCloningUtils.createExceptionOnWrite(bean, field, value, e);\n        }\n    }\n\n    static void copyShort(Field field, Object original, Object clone) {\n        short originalValue = getShortFieldValue(original, field);\n        setFieldValue(clone, field, originalValue);\n    }\n\n    private static short getShortFieldValue(Object bean, Field field) {\n        try {\n            return field.getShort(bean);\n        } catch (IllegalAccessException e) {\n            throw FieldCloningUtils.createExceptionOnRead(bean, field, e);\n        }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n# Natural Language Annotations: /**\n     * Replaces TOS with getattr(TOS, co_names[instruction.arg])\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    TOS = getattr(TOS, functionMetadata.co_names[nameIndex]);\n}\n```\n", "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    Object topOfStack = stackMetadata.getTopOfStack();\n    String attributeName = functionMetadata.getCoNames()[nameIndex];\n\n    try {\n        Field field = topOfStack.getClass().getDeclaredField(attributeName);\n        field.setAccessible(true);\n        Object attributeValue = field.get(topOfStack);\n        stackMetadata.setTopOfStack(attributeValue);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        throw new IllegalArgumentException(\"Cannot get attribute: \" + attributeName, e);\n    }\n}\n```\n", "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    // Get the top of stack (TOS)\n    Object tos = stackMetadata.getTOS();\n    \n    // Get the name from the function metadata\n    String name = functionMetadata.getCo_names()[nameIndex];\n\n    // Get the attribute from the TOS with the given name\n    Object attribute = getAttributeFromObject(tos, name);\n\n    // Replace TOS with the attribute\n    stackMetadata.setTOS(attribute);\n}\n\nprivate static Object getAttributeFromObject(Object object, String name) {\n    try {\n        Field field = object.getClass().getDeclaredField(name);\n        field.setAccessible(true);\n        return field.get(object);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        // Handle exception here\n        e.printStackTrace();\n    }\n    return null;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n    public ProblemSizeStatistics getProblemSizeStatistics(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n        return new ProblemSizeStatistics(\n                getGenuineEntityCount(solution),\n                getGenuineVariableCount(solution),\n                getApproximateValueCount(solution),\n                getProblemScale(scoreDirector, solution));\n    }\n\n    public SolutionInitializationStatistics computeInitializationStatistics(Solution_ solution) {\n        return computeInitializationStatistics(solution, null);\n    }\n\n------------------------------\n------------------------------\n            maximumValueCount = Math.max(maximumValueCount, variableDescriptor.getValueRangeSize(solution, entity));\n        }\n        return maximumValueCount;\n\n    }\n\n    public void processProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution, Object entity,\n            ProblemScaleTracker tracker) {\n        for (GenuineVariableDescriptor<Solution_> variableDescriptor : effectiveGenuineVariableDescriptorList) {\n            long valueCount = variableDescriptor.getValueRangeSize(solution, entity);\n            // TODO: When minimum Java supported is 21, this can be replaced with a sealed interface switch\n            if (variableDescriptor instanceof BasicVariableDescriptor<Solution_> basicVariableDescriptor) {\n                if (basicVariableDescriptor.isChained()) {\n                    // An entity is a value\n                    tracker.addListValueCount(1);\n                    if (!isMovable(scoreDirector, entity)) {\n                        tracker.addPinnedListValueCount(1);\n                    }\n                    // Anchors are entities\n                    ValueRange<?> valueRange = variableDescriptor.getValueRangeDescriptor().extractValueRange(solution, entity);\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public double createProbabilityWeight(ScoreDirector<Solution_> scoreDirector, Selector_ selector) {\n        return fixedProbabilityWeightMap.getOrDefault(selector, 1.0);\n    }\n\n}\n\n------------------------------\n------------------------------\n\n    public void visitAllEntities(Solution_ solution, Consumer<Object> visitor) {\n        solutionDescriptor.visitEntitiesByEntityClass(solution, entityClass, entity -> {\n            visitor.accept(entity);\n            return false; // Iterate over all entities.\n        });\n    }\n\n    public PlanningPinToIndexReader<Solution_> getEffectivePlanningPinToIndexReader() {\n        return effectivePlanningPinToIndexReader;\n    }\n\n    public long getMaximumValueCount(Solution_ solution, Object entity) {\n        long maximumValueCount = 0L;\n        for (GenuineVariableDescriptor<Solution_> variableDescriptor : effectiveGenuineVariableDescriptorList) {\n            maximumValueCount = Math.max(maximumValueCount, variableDescriptor.getValueRangeSize(solution, entity));\n        }\n        return maximumValueCount;\n\n    }\n\n------------------------------\n------------------------------\n                        });\n            }\n        }\n        return out.longValue();\n    }\n\n    public long getMaximumValueRangeSize(Solution_ solution) {\n        return extractAllEntitiesStream(solution)\n                .mapToLong(entity -> {\n                    var entityDescriptor = findEntityDescriptorOrFail(entity.getClass());\n                    return entityDescriptor.isGenuine() ? entityDescriptor.getMaximumValueCount(solution, entity) : 0L;\n                })\n                .max()\n                .orElse(0L);\n    }\n\n    /**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n# Natural Language Annotations: /**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n     * @param solution never null\n     * @return {@code >= 0}\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    long maximumValueRangeSize = getMaximumValueRangeSize(solution);\n    return maximumValueRangeSize > 0 ? Math.log10(maximumValueRangeSize) : 0;\n}\n```\n", "```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    long searchSpaceSize = getMaximumValueRangeSize(solution);\n    return searchSpaceSize > 0 ? Math.log10(searchSpaceSize) : 0;\n}\n```\n", "```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    double maximumValueCount = this.getMaximumValueRangeSize(solution);\n    return Math.log10(maximumValueCount);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        ResultHandle fallbackCloner =\n                currentBranch.readStaticField(FieldDescriptor.of(\n                        GizmoSolutionClonerFactory.getGeneratedClassName(solutionDescriptor),\n                        FALLBACK_CLONER, FieldAccessingSolutionCloner.class));\n        ResultHandle cloneObj =\n                currentBranch.invokeVirtualMethod(MethodDescriptor.ofMethod(FieldAccessingSolutionCloner.class,\n                        \"gizmoFallbackDeepClone\", Object.class, Object.class, Map.class),\n                        fallbackCloner, toClone, cloneMap);\n        currentBranch.returnValue(cloneObj);\n\n        return branchResult.falseBranch();\n    }\n\n    // To prevent stack overflow on chained models\n    private void createDeepCloneHelperMethod(ClassCreator classCreator,\n            Class<?> entityClass,\n            SolutionDescriptor<?> solutionDescriptor,\n            Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n            SortedSet<Class<?>> deepClonedClassesSortedSet) {\n\n------------------------------\n------------------------------\n        noCloneBranch.returnValue(cloneObj);\n    }\n\n    protected void createAbstractDeepCloneHelperMethod(ClassCreator classCreator,\n            Class<?> entityClass,\n            SolutionDescriptor<?> solutionDescriptor,\n            Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n            SortedSet<Class<?>> deepClonedClassesSortedSet) {\n        MethodCreator methodCreator =\n                classCreator.getMethodCreator(getEntityHelperMethodName(entityClass), entityClass, entityClass, Map.class);\n        methodCreator.setModifiers(Modifier.STATIC | Modifier.PRIVATE);\n\n        ResultHandle toClone = methodCreator.getMethodParam(0);\n        ResultHandle cloneMap = methodCreator.getMethodParam(1);\n        ResultHandle maybeClone = methodCreator.invokeInterfaceMethod(\n                GET_METHOD, cloneMap, toClone);\n        BranchResult hasCloneBranchResult = methodCreator.ifNotNull(maybeClone);\n        BytecodeCreator hasCloneBranch = hasCloneBranchResult.trueBranch();\n        hasCloneBranch.returnValue(maybeClone);\n\n\n------------------------------\n------------------------------\n                        Object.class,\n                        Object.class));\n\n        ResultHandle thisObj = methodCreator.getMethodParam(0);\n\n        ResultHandle clone = methodCreator.invokeStaticMethod(\n                MethodDescriptor.ofMethod(\n                        GizmoSolutionClonerFactory.getGeneratedClassName(solutionDescriptor),\n                        \"cloneSolutionRun\", solutionClass, solutionClass, Map.class),\n                thisObj,\n                methodCreator.newInstance(MethodDescriptor.ofConstructor(IdentityHashMap.class)));\n        methodCreator.returnValue(clone);\n    }\n\n    private void createCloneSolutionRun(ClassCreator classCreator, SolutionDescriptor solutionDescriptor,\n            Set<Class<?>> solutionClassSet,\n            Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n            SortedSet<Class<?>> deepClonedClassesSortedSet, Comparator<Class<?>> instanceOfComparator) {\n        Class<?> solutionClass = solutionDescriptor.getSolutionClass();\n        MethodCreator methodCreator =\n\n------------------------------\n------------------------------\n        // have a subclass level of 0.\n        // Other classes subclass level is the maximum of the subclass level\n        // of the classes it is a subclass of + 1\n        Set<Class<?>> deepCloneClassesThatAreNotSolutionSet =\n                deepClonedClassSet.stream()\n                        .filter(clazz -> !solutionClassSet.contains(clazz) && !clazz.isArray())\n                        .filter(clazz -> !clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers()))\n                        .collect(Collectors.toSet());\n\n        Comparator<Class<?>> instanceOfComparator = getInstanceOfComparator(deepClonedClassSet);\n        SortedSet<Class<?>> deepCloneClassesThatAreNotSolutionSortedSet = new TreeSet<>(instanceOfComparator);\n        deepCloneClassesThatAreNotSolutionSortedSet.addAll(deepCloneClassesThatAreNotSolutionSet);\n\n        implementor.createFields(classCreator);\n        implementor.createConstructor(classCreator);\n        implementor.createSetSolutionDescriptor(classCreator, solutionDescriptor);\n        implementor.createCloneSolution(classCreator, solutionDescriptor);\n        implementor.createCloneSolutionRun(classCreator, solutionDescriptor, solutionClassSet,\n                memoizedSolutionOrEntityDescriptorMap,\n                deepCloneClassesThatAreNotSolutionSortedSet, instanceOfComparator);\n\n------------------------------\n------------------------------\n\n\n\n    /**\n     * Generates the constructor and implementations of SolutionCloner\n     * methods for the given SolutionDescriptor using the given ClassCreator\n     */\n    public static void defineClonerFor(Supplier<GizmoSolutionClonerImplementor> implementorSupplier,\n            ClassCreator classCreator,\n            SolutionDescriptor<?> solutionDescriptor,\n            Set<Class<?>> solutionClassSet,\n            Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n            Set<Class<?>> deepClonedClassSet) {\n        GizmoSolutionClonerImplementor implementor = implementorSupplier.get();\n        // Classes that are not instances of any other class in the collection\n        // have a subclass level of 0.\n        // Other classes subclass level is the maximum of the subclass level\n        // of the classes it is a subclass of + 1\n        Set<Class<?>> deepCloneClassesThatAreNotSolutionSet =\n                deepClonedClassSet.stream()\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void defineClonerFor(ClassCreator classCreator,\n# Natural Language Annotations: /**\n     * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given\n     * ClassCreator\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void defineClonerFor(ClassCreator classCreator,\n            SolutionDescriptor<?> solutionDescriptor,\n            Set<Class<?>> solutionClassSet,\n            Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n            Set<Class<?>> deepClonedClassSet) {\n\n    GizmoSolutionClonerImplementor implementor = implementorSupplier.get();\n    // Classes that are not instances of any other class in the collection\n    // have a subclass level of 0.\n    // Other classes subclass level is the maximum of the subclass level\n    // of the classes it is a subclass of + 1\n    Set<Class<?>> deepCloneClassesThatAreNotSolutionSet =\n            deepClonedClassSet.stream()\n                    .filter(clazz -> !solutionClassSet.contains(clazz) && !clazz.isArray())\n                    .filter(clazz -> !clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers()))\n                    .collect(Collectors.toSet());\n\n    Comparator<Class<?>> instanceOfComparator = getInstanceOfComparator(deepClonedClassSet);\n    SortedSet<Class<?>> deepCloneClassesThatAreNotSolutionSortedSet = new TreeSet<>(instanceOfComparator);\n    deepCloneClassesThatAreNotSolutionSortedSet.addAll(deepCloneClassesThatAreNotSolutionSet);\n\n    implementor.createFields(classCreator);\n    implementor.createConstructor(classCreator);\n    implementor.createSetSolutionDescriptor(classCreator, solutionDescriptor);\n    implementor.createCloneSolution(classCreator, solutionDescriptor);\n    implementor.createCloneSolutionRun(classCreator, solutionDescriptor, solutionClassSet,\n            memoizedSolutionOrEntityDescriptorMap,\n            deepCloneClassesThatAreNotSolutionSortedSet, instanceOfComparator);\n}\n```\n", "```java\npublic static void defineClonerFor(ClassCreator classCreator, SolutionDescriptor<?> solutionDescriptor, Set<Class<?>> solutionClassSet, Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap, Set<Class<?>> deepClonedClassSet) {\n    GizmoSolutionClonerImplementor implementor = () -> new GizmoSolutionClonerImplementorImpl();\n    Set<Class<?>> deepCloneClassesThatAreNotSolutionSet = deepClonedClassSet.stream()\n        .filter(clazz -> !solutionClassSet.contains(clazz) && !clazz.isArray())\n        .filter(clazz -> !clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers()))\n        .collect(Collectors.toSet());\n    Comparator<Class<?>> instanceOfComparator = getInstanceOfComparator(deepClonedClassSet);\n    SortedSet<Class<?>> deepCloneClassesThatAreNotSolutionSortedSet = new TreeSet<>(instanceOfComparator);\n    deepCloneClassesThatAreNotSolutionSortedSet.addAll(deepCloneClassesThatAreNotSolutionSet);\n    implementor.createFields(classCreator);\n    implementor.createConstructor(classCreator);\n    implementor.createSetSolutionDescriptor(classCreator, solutionDescriptor);\n    implementor.createCloneSolution(classCreator, solutionDescriptor);\n    implementor.createCloneSolutionRun(classCreator, solutionDescriptor, solutionClassSet, memoizedSolutionOrEntityDescriptorMap, deepCloneClassesThatAreNotSolutionSortedSet, instanceOfComparator);\n}\n```\n", "Here is the code based on the function signature and natural language annotations you provided:\n\n```java\npublic static void defineClonerFor(ClassCreator classCreator,\n        SolutionDescriptor<?> solutionDescriptor,\n        Set<Class<?>> solutionClassSet,\n        Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n        Set<Class<?>> deepClonedClassSet) {\n    GizmoSolutionClonerImplementor implementor = implementorSupplier.get();\n    // Classes that are not instances of any other class in the collection\n    // have a subclass level of 0.\n    // Other classes subclass level is the maximum of the subclass level\n    // of the classes it is a subclass of + 1\n    Set<Class<?>> deepCloneClassesThatAreNotSolutionSet =\n            deepClonedClassSet.stream()\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            }\n        });\n        MutableLong out = new MutableLong();\n        for (var variableDescriptor : genuineVariableDescriptorSet) {\n            var valueRangeDescriptor = variableDescriptor.getValueRangeDescriptor();\n            if (valueRangeDescriptor.isEntityIndependent()) {\n                var entityIndependentVariableDescriptor =\n                        (EntityIndependentValueRangeDescriptor<Solution_>) valueRangeDescriptor;\n                out.add(entityIndependentVariableDescriptor.extractValueRangeSize(solution));\n            } else {\n                visitEntitiesByEntityClass(solution,\n                        variableDescriptor.getEntityDescriptor().getEntityClass(),\n                        entity -> {\n                            out.add(valueRangeDescriptor.extractValueRangeSize(solution, entity));\n                            return false;\n                        });\n            }\n        }\n        return out.longValue();\n    }\n\n------------------------------\n------------------------------\n\n\n\n\n\n    private Map<ShadowVariableDescriptor<?>, List<String>> collectViolations() {\n        Map<ShadowVariableDescriptor<?>, List<String>> violationListMap = new TreeMap<>(\n                comparing(ShadowVariableDescriptor::getGlobalShadowOrder));\n        for (ShadowVariableSnapshot shadowVariableSnapshot : shadowVariableSnapshots) {\n            shadowVariableSnapshot.validate(violationMessage -> violationListMap\n                    .computeIfAbsent(shadowVariableSnapshot.getShadowVariableDescriptor(), k -> new ArrayList<>())\n                    .add(violationMessage));\n        }\n        return violationListMap;\n    }\n\n    private String format(Map<ShadowVariableDescriptor<?>, List<String>> violationListMap, long violationDisplayLimit) {\n        StringBuilder message = new StringBuilder();\n        violationListMap.forEach((shadowVariableDescriptor, violationList) -> {\n            violationList.stream().limit(violationDisplayLimit).forEach(message::append);\n\n------------------------------\n------------------------------\n                        Object aValue = variableDescriptor.getValue(aEntity);\n                        Object bValue = variableDescriptor.getValue(bEntity);\n                        if (areDifferent(aValue, bValue)) {\n                            mutationCount++;\n                        }\n                    }\n                }\n            }\n            if (aEntities.size() != bEntities.size()) {\n                mutationCount += Math.abs(aEntities.size() - bEntities.size())\n                        * entityDescriptor.getGenuineVariableDescriptorList().size();\n            }\n        }\n        return mutationCount;\n    }\n\n    private boolean areDifferent(Object aValue, Object bValue) {\n        EntityDescriptor<Solution_> aValueEntityDescriptor =\n                solutionDescriptor.findEntityDescriptor(aValue.getClass());\n        EntityDescriptor<Solution_> bValueEntityDescriptor =\n\n------------------------------\n------------------------------\n                        .extractEntityDescriptor(configPolicy);\n        if (onlyEntityDescriptor != null) {\n            entityDescriptors = Collections.singletonList(onlyEntityDescriptor);\n        } else {\n            entityDescriptors = configPolicy.getSolutionDescriptor().getGenuineEntityDescriptors();\n        }\n        List<GenuineVariableDescriptor<Solution_>> variableDescriptorList = new ArrayList<>();\n        for (EntityDescriptor<Solution_> entityDescriptor : entityDescriptors) {\n            GenuineVariableDescriptor<Solution_> onlyVariableDescriptor = config.getValueSelectorConfig() == null ? null\n                    : ValueSelectorFactory.<Solution_> create(config.getValueSelectorConfig())\n                            .extractVariableDescriptor(configPolicy, entityDescriptor);\n            if (onlyVariableDescriptor != null) {\n                if (onlyEntityDescriptor != null) {\n                    if (onlyVariableDescriptor.isListVariable()) {\n                        return buildListChangeMoveSelectorConfig((ListVariableDescriptor<?>) onlyVariableDescriptor, true);\n                    }\n                    // No need for unfolding or deducing\n                    return null;\n                }\n                variableDescriptorList.add(onlyVariableDescriptor);\n\n------------------------------\n------------------------------\n\n    private String format(Map<ShadowVariableDescriptor<?>, List<String>> violationListMap, long violationDisplayLimit) {\n        StringBuilder message = new StringBuilder();\n        violationListMap.forEach((shadowVariableDescriptor, violationList) -> {\n            violationList.stream().limit(violationDisplayLimit).forEach(message::append);\n            if (violationList.size() >= violationDisplayLimit) {\n                message.append(\"  ... \").append(violationList.size() - violationDisplayLimit)\n                        .append(\" more\\n\");\n            }\n        });\n        return message.toString();\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n# Natural Language Annotations: /**\n     * Takes a look at the shadow variables of all entities and compares them against the recorded state. Every difference\n     * is added to the violation message. The first N differences up to the {@code violationDisplayLimit} are displayed\n     * in detail; the number of violations exceeding the display limit is reported at the end. The limit applies per each\n     * shadow variable descriptor.\n     * <p>\n     * This method should be called after a forceful trigger of variable listeners.\n     *\n     * @param violationDisplayLimit maximum number of violations reported per shadow variable descriptor\n     * @return description of the violations or {@code null} if there are none\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    Map<ShadowVariableDescriptor<?>, List<String>> violationListMap = collectViolations();\n    if (violationListMap.isEmpty()) {\n        return null;\n    }\n    return format(violationListMap, violationDisplayLimit);\n}\n```\n", "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    Map<ShadowVariableDescriptor<?>, List<String>> violationListMap = collectViolations();\n    String message = format(violationListMap, violationDisplayLimit);\n    return message.isEmpty() ? null : message;\n}\n```\n", "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    Map<ShadowVariableDescriptor<?>, List<String>> violationListMap = collectViolations();\n    if (violationListMap.isEmpty()) {\n        return null;\n    } else {\n        return format(violationListMap, violationDisplayLimit);\n    }\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @return never null, new instance of the member accessor\n     */\n    public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            DomainAccessType domainAccessType, ClassLoader classLoader) {\n        return buildMemberAccessor(member, memberAccessorType, null, domainAccessType, classLoader);\n    }\n\n    /**\n     * Creates a new member accessor based on the given parameters.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @param classLoader null or {@link GizmoClassLoader} if domainAccessType is {@link DomainAccessType#GIZMO}.\n     * @return never null, new instance of the member accessor\n     */\n    public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType, ClassLoader classLoader) {\n        return switch (domainAccessType) {\n\n------------------------------\n------------------------------\n            Class<?> constraintConfigurationClass) {\n        this.solutionDescriptor = solutionDescriptor;\n        this.constraintConfigurationClass = constraintConfigurationClass;\n        constraintWeightDescriptorMap = new LinkedHashMap<>();\n    }\n\n    public String getConstraintPackage() {\n        return constraintPackage;\n    }\n\n    public ConstraintWeightDescriptor<Solution_> getConstraintWeightDescriptor(String propertyName) {\n        return constraintWeightDescriptorMap.get(propertyName);\n    }\n\n    // ************************************************************************\n    // Lifecycle methods\n    // ************************************************************************\n\n    public void processAnnotations(MemberAccessorFactory memberAccessorFactory, DomainAccessType domainAccessType,\n            ScoreDefinition<?> scoreDefinition) {\n\n------------------------------\n------------------------------\n        }\n        return GizmoMemberAccessorImplementor.createAccessorFor(member, annotationClass, returnTypeRequired, gizmoClassLoader);\n    }\n\n    private GizmoMemberAccessorFactory() {\n    }\n}\n\n------------------------------\n------------------------------\n     * @return never null, new instance of the member accessor\n     */\n    public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType, ClassLoader classLoader) {\n        return switch (domainAccessType) {\n            case GIZMO -> GizmoMemberAccessorFactory.buildGizmoMemberAccessor(member, annotationClass,\n                    memberAccessorType != MemberAccessorType.REGULAR_METHOD,\n                    (GizmoClassLoader) Objects.requireNonNull(classLoader));\n            case REFLECTION -> buildReflectiveMemberAccessor(member, memberAccessorType, annotationClass);\n        };\n    }\n\n    private static MemberAccessor buildReflectiveMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            Class<? extends Annotation> annotationClass) {\n        if (member instanceof Field field) {\n            return new ReflectionFieldMemberAccessor(field);\n        } else if (member instanceof Method method) {\n            MemberAccessor memberAccessor;\n            switch (memberAccessorType) {\n                case FIELD_OR_READ_METHOD:\n\n------------------------------\n------------------------------\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\n    public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            DomainAccessType domainAccessType) {\n        String generatedClassName = GizmoMemberAccessorFactory.getGeneratedClassName(member);\n        return memberAccessorCache.computeIfAbsent(generatedClassName,\n                k -> MemberAccessorFactory.buildMemberAccessor(member, memberAccessorType, domainAccessType, gizmoClassLoader));\n    }\n\n    public GizmoClassLoader getGizmoClassLoader() {\n        return gizmoClassLoader;\n    }\n\n    public enum MemberAccessorType {\n        FIELD_OR_READ_METHOD,\n        FIELD_OR_GETTER_METHOD,\n        FIELD_OR_GETTER_METHOD_WITH_SETTER,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n# Natural Language Annotations: /**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, DomainAccessType domainAccessType) {\n    String generatedClassName = GizmoMemberAccessorFactory.getGeneratedClassName(member);\n    return memberAccessorCache.computeIfAbsent(generatedClassName,\n            k -> MemberAccessorFactory.buildMemberAccessor(member, memberAccessorType, domainAccessType, gizmoClassLoader));\n}\n```\n", "```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, DomainAccessType domainAccessType) {\n    String generatedClassName = GizmoMemberAccessorFactory.getGeneratedClassName(member);\n    return memberAccessorCache.computeIfAbsent(generatedClassName,\n            k -> MemberAccessorFactory.buildMemberAccessor(member, memberAccessorType, domainAccessType, gizmoClassLoader));\n}\n```\n", "```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, DomainAccessType domainAccessType) {\n    String generatedClassName = GizmoMemberAccessorFactory.getGeneratedClassName(member);\n    return memberAccessorCache.computeIfAbsent(generatedClassName,\n        k -> MemberAccessorFactory.buildMemberAccessor(member, memberAccessorType, null, domainAccessType, gizmoClassLoader));\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    public <T extends Annotation> T[] getDeclaredAnnotationsByType(Class<T> annotationClass) {\n        return getterMethod.getDeclaredAnnotationsByType(annotationClass);\n    }\n\n    @Override\n    public String toString() {\n        return \"bean property \" + propertyName + \" on \" + getterMethod.getDeclaringClass();\n    }\n\n}\n\n------------------------------\n------------------------------\n                    + readMethod.getReturnType() + \").\");\n        }\n    }\n\n    @Override\n    public Class<?> getDeclaringClass() {\n        return readMethod.getDeclaringClass();\n    }\n\n    @Override\n    public String getName() {\n        return methodName;\n    }\n\n    @Override\n    public Class<?> getType() {\n        return returnType;\n    }\n\n    @Override\n\n------------------------------\n------------------------------\npackage ai.timefold.solver.core.impl.domain.solution.cloner.gizmo;\n\nimport ai.timefold.solver.core.api.domain.common.DomainAccessType;\nimport ai.timefold.solver.core.api.domain.solution.cloner.SolutionCloner;\nimport ai.timefold.solver.core.impl.domain.common.accessor.gizmo.GizmoClassLoader;\nimport ai.timefold.solver.core.impl.domain.solution.descriptor.SolutionDescriptor;\n\npublic final class GizmoSolutionClonerFactory {\n    /**\n     * Returns the generated class name for a given solutionDescriptor.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param solutionDescriptor The solutionDescriptor to get the generated class name for\n     * @return The generated class name for solutionDescriptor\n     */\n    public static String getGeneratedClassName(SolutionDescriptor<?> solutionDescriptor) {\n        return solutionDescriptor.getSolutionClass().getName() + \"$Timefold$SolutionCloner\";\n    }\n\n\n------------------------------\n------------------------------\n\n    @Override\n    public String toString() {\n        return getClass().getSimpleName() + \"()\";\n    }\n}\n\n------------------------------\n------------------------------\n    public String toString() {\n        return \"method \" + methodName + \" on \" + readMethod.getDeclaringClass();\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String getGeneratedClassName(Member member) {\n# Natural Language Annotations: /**\n     * Returns the generated class name for a given member.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String getGeneratedClassName(Member member) {\n    return member.getClass().getName() + \"$Timefold$SolutionCloner\";\n}\n```\n", "```java\npublic static String getGeneratedClassName(Member member) {\n    return member.getClass().getName() + \"$Timefold$SolutionCloner\";\n}\n```\n", "```java\npublic static String getGeneratedClassName(Member member) {\n    return member.getName() + \"$Timefold$SolutionCloner\";\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @return never null, new instance of the member accessor\n     */\n    public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType, ClassLoader classLoader) {\n        return switch (domainAccessType) {\n            case GIZMO -> GizmoMemberAccessorFactory.buildGizmoMemberAccessor(member, annotationClass,\n                    memberAccessorType != MemberAccessorType.REGULAR_METHOD,\n                    (GizmoClassLoader) Objects.requireNonNull(classLoader));\n            case REFLECTION -> buildReflectiveMemberAccessor(member, memberAccessorType, annotationClass);\n        };\n    }\n\n    private static MemberAccessor buildReflectiveMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            Class<? extends Annotation> annotationClass) {\n        if (member instanceof Field field) {\n            return new ReflectionFieldMemberAccessor(field);\n        } else if (member instanceof Method method) {\n            MemberAccessor memberAccessor;\n            switch (memberAccessorType) {\n                case FIELD_OR_READ_METHOD:\n\n------------------------------\n------------------------------\n     * @return never null, new instance of the member accessor\n     */\n    public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            DomainAccessType domainAccessType, ClassLoader classLoader) {\n        return buildMemberAccessor(member, memberAccessorType, null, domainAccessType, classLoader);\n    }\n\n    /**\n     * Creates a new member accessor based on the given parameters.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @param classLoader null or {@link GizmoClassLoader} if domainAccessType is {@link DomainAccessType#GIZMO}.\n     * @return never null, new instance of the member accessor\n     */\n    public static MemberAccessor buildMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n            Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType, ClassLoader classLoader) {\n        return switch (domainAccessType) {\n\n------------------------------\n------------------------------\npackage ai.timefold.solver.core.impl.domain.common.accessor.gizmo;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * @param descriptor never null\n * @param returnTypeRequired true if the method return type is required\n * @param annotationClass null if not annotated\n */\npublic record GizmoMemberInfo(GizmoMemberDescriptor descriptor, boolean returnTypeRequired,\n        Class<? extends Annotation> annotationClass) {\n\n}\n\n------------------------------\n------------------------------\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\n\n\n\n\n\n\n\n    /**\n     *\n     * @param member never null\n     * @param annotationClass may be null if the member is not annotated\n     * @param gizmoClassLoader never null\n     * @return never null\n     */\n    public static MemberAccessor buildGizmoMemberAccessor(Member member, Class<? extends Annotation> annotationClass,\n\n------------------------------\n------------------------------\n        }\n        return GizmoMemberAccessorImplementor.createAccessorFor(member, annotationClass, returnTypeRequired, gizmoClassLoader);\n    }\n\n    private GizmoMemberAccessorFactory() {\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass,\n# Natural Language Annotations: /**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, GizmoClassLoader gizmoClassLoader) {\n    if (member instanceof Field field) {\n        return new GizmoFieldMemberAccessor(field, annotationClass, gizmoClassLoader);\n    } else if (member instanceof Method method) {\n        MemberAccessor memberAccessor;\n        if (memberAccessorType == MemberAccessorType.FIELD_OR_READ_METHOD) {\n            memberAccessor = new GizmoFieldMemberAccessor(field, annotationClass, gizmoClassLoader);\n        } else {\n            memberAccessor = new GizmoMethodMemberAccessor(method, annotationClass, returnTypeRequired, gizmoClassLoader);\n        }\n        return memberAccessor;\n    }\n    throw new IllegalArgumentException(\"Unsupported member type: \" + member.getClass());\n}\n```\n", "```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, GizmoClassLoader gizmoClassLoader) {\n    if (member instanceof Method) {\n        Method method = (Method) member;\n        GizmoMemberDescriptor gizmoMemberDescriptor = GizmoMemberInfoGenerator.getGizmoMemberDescriptor(method, annotationClass, returnTypeRequired);\n        return new GizmoMethodMemberAccessor(method, gizmoMemberDescriptor, gizmoClassLoader);\n    } else if (member instanceof Field) {\n        Field field = (Field) member;\n        GizmoMemberDescriptor gizmoMemberDescriptor = GizmoMemberInfoGenerator.getGizmoMemberDescriptor(field, annotationClass);\n        return new GizmoFieldMemberAccessor(field, gizmoMemberDescriptor, gizmoClassLoader);\n    } else {\n        throw new IllegalArgumentException(\"Unsupported member type: \" + member.getClass().getName());\n    }\n}\n```\n", "```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, GizmoClassLoader gizmoClassLoader) {\n    // Check if member is a field\n    if (member instanceof Field) {\n        return new ReflectionFieldMemberAccessor((Field) member);\n    } \n    // Check if member is a method\n    else if (member instanceof Method) {\n        return GizmoMemberAccessorImplementor.generateAccessorFor((Method) member, annotationClass, returnTypeRequired, gizmoClassLoader);\n    } \n    // If member is neither a field nor a method\n    else {\n        throw new IllegalArgumentException(\"Member must be either a Field or Method\");\n    }\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    @Override\n    public void phaseEnded(AbstractPhaseScope<Solution_> phaseScope) {\n        // intentional empty\n    }\n\n    @Override\n    public void solvingStarted(SolverScope<Solution_> solverScope) {\n        // intentional empty\n    }\n\n    @Override\n    public void solvingEnded(SolverScope<Solution_> solverScope) {\n        if (lastStepImprovedSolution) {\n            bestSolutionMeterListenerList\n                    .forEach(listener -> listener.accept(bestSolutionChangedTimestamp, bestSolutionStepScope));\n            lastStepImprovedSolution = false;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public LocalSearchStepScope<Solution_> getStepScope() {\n        return (LocalSearchStepScope<Solution_>) super.getStepScope();\n    }\n\n    public Boolean getAccepted() {\n        return accepted;\n    }\n\n    public void setAccepted(Boolean accepted) {\n        this.accepted = accepted;\n    }\n\n}\n\n------------------------------\n------------------------------\n    private File problemFile;\n\n    private FileProblemProvider() {\n        // Required by JAXB\n    }\n\n    public FileProblemProvider(SolutionFileIO<Solution_> solutionFileIO, File problemFile) {\n        this.solutionFileIO = solutionFileIO;\n        this.problemFile = problemFile;\n    }\n\n    public SolutionFileIO<Solution_> getSolutionFileIO() {\n        return solutionFileIO;\n    }\n\n    @Override\n    public String getProblemName() {\n        String name = problemFile.getName();\n        int lastDotIndex = name.lastIndexOf('.');\n        if (lastDotIndex > 0) {\n\n------------------------------\n------------------------------\n        public VersionedBestSolution(Solution_ bestSolution, BigInteger version) {\n            this.bestSolution = bestSolution;\n            this.version = version;\n        }\n\n        public Solution_ getBestSolution() {\n            return bestSolution;\n        }\n\n        public BigInteger getVersion() {\n            return version;\n        }\n    }\n}\n\n------------------------------\n------------------------------\n        } : finalBestSolutionConsumer;\n        this.firstInitializedSolutionConsumer = firstInitializedSolutionConsumer;\n        this.exceptionHandler = exceptionHandler;\n        this.bestSolutionHolder = bestSolutionHolder;\n        this.firstInitializedSolution = null;\n    }\n\n    // Called on the Solver thread.\n    void consumeIntermediateBestSolution(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n        /*\n         * If the bestSolutionConsumer is not provided, the best solution is still set for the purpose of recording\n         * problem changes.\n         */\n        bestSolutionHolder.set(bestSolution, isEveryProblemChangeProcessed);\n        if (bestSolutionConsumer != null) {\n            tryConsumeWaitingIntermediateBestSolution();\n        }\n    }\n\n    // Called on the Solver thread.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n# Natural Language Annotations: /**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```\n", "```java\npublic void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```\n", "```java\npublic void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    // If all problem changes have been processed\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        phaseStartedTimeMillis = clock.millis();\n    }\n\n    // ************************************************************************\n    // Terminated methods\n    // ************************************************************************\n\n    @Override\n    public boolean isSolverTerminated(SolverScope<Solution_> solverScope) {\n        long bestSolutionTimeMillis = solverScope.getBestSolutionTimeMillis();\n        return isTerminated(bestSolutionTimeMillis);\n    }\n\n    @Override\n    public boolean isPhaseTerminated(AbstractPhaseScope<Solution_> phaseScope) {\n        var bestSolutionTimeMillis = phaseScope.getPhaseBestSolutionTimeMillis();\n        return isTerminated(bestSolutionTimeMillis);\n    }\n\n    private boolean isTerminated(long bestSolutionTimeMillis) {\n\n------------------------------\n------------------------------\n    // TODO Future features\n    //    @Override\n    //    public void reloadProblem(Function<? super ProblemId_, Solution_> problemFinder) {\n    //        throw new UnsupportedOperationException(\"The solver is still solving and reloadProblem() is not yet supported.\");\n    //    }\n\n    @Override\n    public CompletableFuture<Void> addProblemChange(ProblemChange<Solution_> problemChange) {\n        Objects.requireNonNull(problemChange, () -> \"A problem change (%s) must not be null.\".formatted(problemId));\n        if (solverStatus == SolverStatus.NOT_SOLVING) {\n            throw new IllegalStateException(\"Cannot add the problem change (%s) because the solver job (%s) is not solving.\"\n                    .formatted(problemChange, solverStatus));\n        }\n\n        return bestSolutionHolder.addProblemChange(solver, problemChange);\n    }\n\n    @Override\n    public void terminateEarly() {\n        terminatedEarly.set(true);\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public ScoreExplanation<Solution_, Score_> explain(Solution_ solution, SolutionUpdatePolicy solutionUpdatePolicy) {\n        return solutionManager.explain(solution, solutionUpdatePolicy);\n    }\n\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public void solvingEnded(SolverScope<Solution_> solverScope) {\n        // Hook method\n    }\n\n}\n\n------------------------------\n------------------------------\n        return (solverScope) -> problemFactChange.doChange(solverScope.getScoreDirector());\n    }\n\n    static <Solution_> ProblemChangeAdapter<Solution_> create(ProblemChange<Solution_> problemChange) {\n        return (solverScope) -> {\n            problemChange.doChange(solverScope.getWorkingSolution(), solverScope.getProblemChangeDirector());\n            solverScope.getScoreDirector().triggerVariableListeners();\n        };\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n# Natural Language Annotations: /**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    Objects.requireNonNull(problemChange, () -> \"A problem change (%s) must not be null.\".formatted(solver.getProblemId()));\n    if (solver.getSolverStatus() == SolverStatus.NOT_SOLVING) {\n        throw new IllegalStateException(\"Cannot add the problem change (%s) because the solver job (%s) is not solving.\"\n                .formatted(problemChange, solver.getSolverStatus()));\n    }\n\n    return solver.getBestSolutionHolder().addProblemChange(solver, problemChange);\n}\n```\n", "```java\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    Objects.requireNonNull(problemChange, () -> \"A problem change must not be null.\");\n    if (solver.getSolverStatus() == SolverStatus.NOT_SOLVING) {\n        throw new IllegalStateException(\"Cannot add the problem change because the solver is not solving.\");\n    }\n\n    return solver.getBestSolutionHolder().addProblemChange(solver, problemChange);\n}\n```\n", "```java\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    Objects.requireNonNull(problemChange, () -> \"A problem change must not be null.\");\n    if (solver == null) {\n        throw new IllegalStateException(\"Cannot add the problem change because the solver is null.\");\n    }\n\n    return bestSolutionHolder.addProblemChange(solver, problemChange);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    private class RandomBigDecimalValueRangeIterator extends ValueRangeIterator<BigDecimal> {\n\n        private final Random workingRandom;\n        private final long size = getSize();\n\n        public RandomBigDecimalValueRangeIterator(Random workingRandom) {\n            this.workingRandom = workingRandom;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return size > 0L;\n        }\n\n        @Override\n        public BigDecimal next() {\n            if (size <= 0L) {\n                throw new NoSuchElementException();\n            }\n            long index = RandomUtils.nextLong(workingRandom, size);\n\n------------------------------\n------------------------------\n\n        private final Random workingRandom;\n        private final long size = getSize();\n\n        public RandomIntValueRangeIterator(Random workingRandom) {\n            this.workingRandom = workingRandom;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return size > 0L;\n        }\n\n        @Override\n        public Integer next() {\n            if (size <= 0L) {\n                throw new NoSuchElementException();\n            }\n            long index = RandomUtils.nextLong(workingRandom, size);\n            return (int) (index * incrementUnit + from);\n\n------------------------------\n------------------------------\n            if (size <= 0L) {\n                throw new NoSuchElementException();\n            }\n            long index = RandomUtils.nextLong(workingRandom, size);\n            return (int) (index * incrementUnit + from);\n        }\n\n    }\n\n    @Override\n    public String toString() {\n        return \"[\" + from + \"-\" + to + \")\"; // Formatting: interval (mathematics) ISO 31-11\n    }\n\n}\n\n------------------------------\n------------------------------\n            return size > 0L;\n        }\n\n        @Override\n        public Long next() {\n            if (size <= 0L) {\n                throw new NoSuchElementException();\n            }\n            long index = RandomUtils.nextLong(workingRandom, size);\n            return index * incrementUnit + from;\n        }\n\n    }\n\n    @Override\n    public String toString() {\n        return \"[\" + from + \"-\" + to + \")\"; // Formatting: interval (mathematics) ISO 31-11\n    }\n\n}\n\n------------------------------\n------------------------------\n\n\n    /**\n     * Mimics {@link Random#nextInt(int)} for doubles.\n     *\n     * @param random never null\n     * @param n {@code > 0.0}\n     * @return like {@link Random#nextInt(int)} but for a double\n     * @see Random#nextInt(int)\n     */\n    public static double nextDouble(Random random, double n) {\n        // This code is based on java.util.Random#nextInt(int)'s javadoc.\n        if (n <= 0.0) {\n            throw new IllegalArgumentException(\"n must be positive\");\n        }\n        return random.nextDouble() * n;\n    }\n\n    private RandomUtils() {\n    }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static long nextLong(Random random, long n) {\n# Natural Language Annotations: /**\n     * Mimics {@link Random#nextInt(int)} for longs.\n     *\n     * @param random never null\n     * @param n {@code > 0L}\n     * @return like {@link Random#nextInt(int)} but for a long\n     * @see Random#nextInt(int)\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static long nextLong(Random random, long n) {\n    // This code is based on java.util.Random#nextInt(int)'s javadoc.\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n    return (long) (random.nextDouble() * n);\n}\n```\n", "```java\npublic static long nextLong(Random random, long n) {\n    // This code is based on java.util.Random#nextInt(int)'s javadoc.\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n    return (long) (random.nextDouble() * n);\n}\n```\n", "```java\npublic static long nextLong(Random random, long n) {\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n    return (long) (random.nextDouble() * n);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return calculateTimeGradient(solverScope.getScoreDirector());\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        return calculateTimeGradient(phaseScope.getScoreDirector());\n    }\n\n    private double calculateTimeGradient(InnerScoreDirector<Solution_, ?> scoreDirector) {\n        var scoreCalculationCount = scoreDirector.getCalculationCount();\n        var timeGradient = scoreCalculationCount / ((double) scoreCalculationCountLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n\n    @Override\n    public ScoreCalculationCountTermination<Solution_> createChildThreadTermination(SolverScope<Solution_> solverScope,\n\n------------------------------\n------------------------------\n        ScoreDirector<Solution_> scoreDirector = solverScope.getScoreDirector();\n        double probabilityWeightOffset = 0L;\n        for (Object entity : childEntitySelector) {\n            double probabilityWeight = probabilityWeightFactory.createProbabilityWeight(\n                    scoreDirector, entity);\n            cachedEntityMap.put(probabilityWeightOffset, entity);\n            probabilityWeightOffset += probabilityWeight;\n        }\n        probabilityWeightTotal = probabilityWeightOffset;\n    }\n\n    @Override\n    public void disposeCache(SolverScope<Solution_> solverScope) {\n        probabilityWeightTotal = -1.0;\n    }\n\n    @Override\n    public EntityDescriptor<Solution_> getEntityDescriptor() {\n        return childEntitySelector.getEntityDescriptor();\n    }\n\n------------------------------\n------------------------------\n        for (Move<Solution_> entity : childMoveSelector) {\n            double probabilityWeight = probabilityWeightFactory.createProbabilityWeight(scoreDirector, entity);\n            cachedMoveMap.put(probabilityWeightOffset, entity);\n            probabilityWeightOffset += probabilityWeight;\n        }\n        probabilityWeightTotal = probabilityWeightOffset;\n    }\n\n    @Override\n    public void disposeCache(SolverScope<Solution_> solverScope) {\n        probabilityWeightTotal = -1.0;\n    }\n\n    @Override\n    public boolean isCountable() {\n        return true;\n    }\n\n    @Override\n    public boolean isNeverEnding() {\n\n------------------------------\n------------------------------\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        return calculateTimeGradient(solverSafeTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        return calculateTimeGradient(phaseSafeTimeMillis);\n    }\n\n    private double calculateTimeGradient(long safeTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n        }\n        var now = clock.millis();\n        var unimprovedTimeMillisSpent = now - (safeTimeMillis - unimprovedTimeMillisSpentLimit);\n        var timeGradient = unimprovedTimeMillisSpent / ((double) unimprovedTimeMillisSpentLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n------------------------------\n------------------------------\n    }\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n\n    protected List<Termination<Solution_>> createChildThreadTerminationList(SolverScope<Solution_> solverScope,\n            ChildThreadType childThreadType) {\n        List<Termination<Solution_>> childThreadTerminationList = new ArrayList<>(terminationList.size());\n        for (Termination<Solution_> termination : terminationList) {\n            childThreadTerminationList.add(termination.createChildThreadTermination(solverScope, childThreadType));\n        }\n        return childThreadTerminationList;\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    ScoreDirector<Solution_> scoreDirector = solverScope.getScoreDirector();\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient >= 0.0 && timeGradient < minTimeGradient) {\n            minTimeGradient = timeGradient;\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    // ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        long bestSolutionTimeMillis = solverScope.getBestSolutionTimeMillis();\n        return calculateTimeGradient(bestSolutionTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        var bestSolutionTimeMillis = phaseScope.getPhaseBestSolutionTimeMillis();\n        return calculateTimeGradient(bestSolutionTimeMillis);\n    }\n\n    private double calculateTimeGradient(long bestSolutionTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n\n------------------------------\n------------------------------\n                getClass().getSimpleName() + \" can only be used for phase termination.\");\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        int nextStepIndex = phaseScope.getNextStepIndex();\n        double timeGradient = nextStepIndex / ((double) stepCountLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n\n    @Override\n    public StepCountTermination<Solution_> createChildThreadTermination(SolverScope<Solution_> solverScope,\n            ChildThreadType childThreadType) {\n        return new StepCountTermination<>(stepCountLimit);\n    }\n\n\n------------------------------\n------------------------------\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        var solverTimeMillisSpent = solverScope.calculateTimeMillisSpentUpToNow();\n        return calculateTimeGradient(solverTimeMillisSpent);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        var phaseTimeMillisSpent = phaseScope.calculatePhaseTimeMillisSpentUpToNow();\n        return calculateTimeGradient(phaseTimeMillisSpent);\n    }\n\n    private double calculateTimeGradient(long timeMillisSpent) {\n        var timeGradient = timeMillisSpent / ((double) timeMillisSpentLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n    // ************************************************************************\n    // Other methods\n\n------------------------------\n------------------------------\n        return calculateTimeGradient(solverScope.getScoreDirector());\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        return calculateTimeGradient(phaseScope.getScoreDirector());\n    }\n\n    private double calculateTimeGradient(InnerScoreDirector<Solution_, ?> scoreDirector) {\n        var scoreCalculationCount = scoreDirector.getCalculationCount();\n        var timeGradient = scoreCalculationCount / ((double) scoreCalculationCountLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n\n    @Override\n    public ScoreCalculationCountTermination<Solution_> createChildThreadTermination(SolverScope<Solution_> solverScope,\n\n------------------------------\n------------------------------\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        return calculateTimeGradient(solverSafeTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        return calculateTimeGradient(phaseSafeTimeMillis);\n    }\n\n    private double calculateTimeGradient(long safeTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n        }\n        var now = clock.millis();\n        var unimprovedTimeMillisSpent = now - (safeTimeMillis - unimprovedTimeMillisSpentLimit);\n        var timeGradient = unimprovedTimeMillisSpent / ((double) unimprovedTimeMillisSpentLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nprivate double calculateTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n\n    double solverTimeGradient = calculateSolverTimeGradient(phaseScope);\n    if (solverTimeGradient >= 0.0) {\n        minTimeGradient = Math.min(minTimeGradient, solverTimeGradient);\n    }\n\n    double phaseTimeGradient = calculatePhaseTimeGradient(phaseScope);\n    if (phaseTimeGradient >= 0.0) {\n        minTimeGradient = Math.min(minTimeGradient, phaseTimeGradient);\n    }\n\n    return minTimeGradient;\n}\n```\n", "```java\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    List<Termination> terminations = phaseScope.getTerminations();\n    for (Termination termination : terminations) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient == -1.0) {\n            continue;\n        }\n        minTimeGradient = Math.min(minTimeGradient, timeGradient);\n    }\n    return minTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                timeGradient += levelTimeGradient * levelTimeGradientWeight;\n            }\n\n        }\n        if (timeGradient > 1.0) {\n            // Rounding error due to calculating with doubles\n            timeGradient = 1.0;\n        }\n        return timeGradient;\n    }\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n\n    @Override\n    public Termination<Solution_> createChildThreadTermination(SolverScope<Solution_> solverScope,\n            ChildThreadType childThreadType) {\n        // TODO FIXME through some sort of solverlistener and async behaviour...\n        throw new UnsupportedOperationException(\"This terminationClass (\" + getClass()\n\n------------------------------\n------------------------------\n        ScoreDirector<Solution_> scoreDirector = solverScope.getScoreDirector();\n        double probabilityWeightOffset = 0L;\n        for (Object entity : childEntitySelector) {\n            double probabilityWeight = probabilityWeightFactory.createProbabilityWeight(\n                    scoreDirector, entity);\n            cachedEntityMap.put(probabilityWeightOffset, entity);\n            probabilityWeightOffset += probabilityWeight;\n        }\n        probabilityWeightTotal = probabilityWeightOffset;\n    }\n\n    @Override\n    public void disposeCache(SolverScope<Solution_> solverScope) {\n        probabilityWeightTotal = -1.0;\n    }\n\n    @Override\n    public EntityDescriptor<Solution_> getEntityDescriptor() {\n        return childEntitySelector.getEntityDescriptor();\n    }\n\n------------------------------\n------------------------------\n\n    // ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        long bestSolutionTimeMillis = solverScope.getBestSolutionTimeMillis();\n        return calculateTimeGradient(bestSolutionTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        var bestSolutionTimeMillis = phaseScope.getPhaseBestSolutionTimeMillis();\n        return calculateTimeGradient(bestSolutionTimeMillis);\n    }\n\n    private double calculateTimeGradient(long bestSolutionTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n\n------------------------------\n------------------------------\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        return calculateTimeGradient(solverSafeTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        return calculateTimeGradient(phaseSafeTimeMillis);\n    }\n\n    private double calculateTimeGradient(long safeTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n        }\n        var now = clock.millis();\n        var unimprovedTimeMillisSpent = now - (safeTimeMillis - unimprovedTimeMillisSpentLimit);\n        var timeGradient = unimprovedTimeMillisSpent / ((double) unimprovedTimeMillisSpentLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n------------------------------\n------------------------------\n    }\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n\n    protected List<Termination<Solution_>> createChildThreadTerminationList(SolverScope<Solution_> solverScope,\n            ChildThreadType childThreadType) {\n        List<Termination<Solution_>> childThreadTerminationList = new ArrayList<>(terminationList.size());\n        for (Termination<Solution_> termination : terminationList) {\n            childThreadTerminationList.add(termination.createChildThreadTermination(solverScope, childThreadType));\n        }\n        return childThreadTerminationList;\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            termination.phaseStarted(phaseScope);\n        }\n    }\n\n    @Override\n    public void stepStarted(AbstractStepScope<Solution_> stepScope) {\n        for (Termination<Solution_> termination : terminationList) {\n            termination.stepStarted(stepScope);\n        }\n    }\n\n    @Override\n    public void stepEnded(AbstractStepScope<Solution_> stepScope) {\n        for (Termination<Solution_> termination : terminationList) {\n            termination.stepEnded(stepScope);\n        }\n    }\n\n    @Override\n    public void phaseEnded(AbstractPhaseScope<Solution_> phaseScope) {\n\n------------------------------\n------------------------------\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        return calculateTimeGradient(solverSafeTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        return calculateTimeGradient(phaseSafeTimeMillis);\n    }\n\n    private double calculateTimeGradient(long safeTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n        }\n        var now = clock.millis();\n        var unimprovedTimeMillisSpent = now - (safeTimeMillis - unimprovedTimeMillisSpentLimit);\n        var timeGradient = unimprovedTimeMillisSpent / ((double) unimprovedTimeMillisSpentLimit);\n        return Math.min(timeGradient, 1.0);\n    }\n\n------------------------------\n------------------------------\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * @param phaseScope never null\n     * @return true if any of the Termination is terminated.\n     */\n    @Override\n    public boolean isPhaseTerminated(AbstractPhaseScope<Solution_> phaseScope) {\n        for (Termination<Solution_> termination : terminationList) {\n            if (termination.isPhaseTerminated(phaseScope)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n------------------------------\n------------------------------\n\n    // ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    @Override\n    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n        long bestSolutionTimeMillis = solverScope.getBestSolutionTimeMillis();\n        return calculateTimeGradient(bestSolutionTimeMillis);\n    }\n\n    @Override\n    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n        var bestSolutionTimeMillis = phaseScope.getPhaseBestSolutionTimeMillis();\n        return calculateTimeGradient(bestSolutionTimeMillis);\n    }\n\n    private double calculateTimeGradient(long bestSolutionTimeMillis) {\n        if (!currentPhaseSendsBestSolutionEvents) {\n            return 0.0;\n\n------------------------------\n------------------------------\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param phaseScope never null\n     * @return true if all the Terminations are terminated.\n     */\n    @Override\n    public boolean isPhaseTerminated(AbstractPhaseScope<Solution_> phaseScope) {\n        for (Termination<Solution_> termination : terminationList) {\n            if (!termination.isPhaseTerminated(phaseScope)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = 0.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double terminationTimeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (terminationTimeGradient > maxTimeGradient) {\n            maxTimeGradient = terminationTimeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override   \npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0 && timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            if (cycle[removedEdgeIndexToTourOrder[2 * i]] == currentCycle) {\n                var sStart = oldRemovedEdges[removedEdgeIndexToTourOrder[2 * i]];\n                var sStop = oldRemovedEdges[removedEdgeIndexToTourOrder[2 * i + 1]];\n                var attemptRemaining = k;\n                for (s1 = sStart; s1 != sStop; s1 = s2) {\n                    attemptRemaining--;\n                    if (attemptRemaining == 0) {\n                        break;\n                    }\n                    var removedEdges = Arrays.copyOf(oldRemovedEdges, oldRemovedEdges.length + 2);\n\n                    removedEdges[2 * k + 1] = s1;\n                    s2 = getNodeSuccessor(entityOrderInfo, s1);\n                    removedEdges[2 * k + 2] = s2;\n                    var addedEdgeToOtherEndpoint =\n                            Arrays.copyOf(KOptDescriptor.computeInEdgesForSequentialMove(oldRemovedEdges),\n                                    removedEdges.length + 2 + (2 * cycleCount));\n                    for (var newEdge = removedEdges.length; newEdge < addedEdgeToOtherEndpoint.length - 2; newEdge++) {\n                        addedEdgeToOtherEndpoint[newEdge] = newEdge + 2;\n                    }\n\n------------------------------\n------------------------------\n            return false;\n        }\n        for (int hardScore : hardScores) {\n            if (hardScore < 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    @Override\n    public BendableScore add(BendableScore addend) {\n        validateCompatible(addend);\n        int[] newHardScores = new int[hardScores.length];\n        int[] newSoftScores = new int[softScores.length];\n        for (int i = 0; i < newHardScores.length; i++) {\n            newHardScores[i] = hardScores[i] + addend.hardScore(i);\n        }\n        for (int i = 0; i < newSoftScores.length; i++) {\n            newSoftScores[i] = softScores[i] + addend.softScore(i);\n\n------------------------------\n------------------------------\n            var tourIndex = removedEdgeIndexToTourOrder[currentEndpoint];\n            var nextEndpointTourIndex = addedEdgeToOtherEndpoint[tourIndex];\n            currentEndpoint = inverseRemovedEdgeIndexToTourOrder[nextEndpointTourIndex] ^ 1;\n        }\n        return out;\n    }\n\n    static <Node_> List<Pair<Node_, Node_>> getRemovedEdgeList(KOptDescriptor<Node_> kOptDescriptor) {\n        var k = kOptDescriptor.k();\n        var removedEdges = kOptDescriptor.removedEdges();\n        List<Pair<Node_, Node_>> out = new ArrayList<>(2 * k);\n        for (var i = 1; i <= k; i++) {\n            out.add(new Pair<>(removedEdges[2 * i - 1], removedEdges[2 * i]));\n        }\n        return out;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <Node_> Function<Node_, Node_> getMultiEntitySuccessorFunction(Node_[] pickedValues,\n            ListVariableStateSupply<?> listVariableStateSupply) {\n\n------------------------------\n------------------------------\n\n\n    static <Node_> List<Pair<Node_, Node_>> getAddedEdgeList(KOptDescriptor<Node_> kOptDescriptor) {\n        var k = kOptDescriptor.k();\n        List<Pair<Node_, Node_>> out = new ArrayList<>(2 * k);\n        var currentEndpoint = 1;\n\n        var removedEdges = kOptDescriptor.removedEdges();\n        var addedEdgeToOtherEndpoint = kOptDescriptor.addedEdgeToOtherEndpoint();\n        var removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n        var inverseRemovedEdgeIndexToTourOrder = kOptDescriptor.inverseRemovedEdgeIndexToTourOrder();\n\n        // This loop iterates through the new tour created\n        while (currentEndpoint != 2 * k + 1) {\n            out.add(new Pair<>(removedEdges[currentEndpoint], removedEdges[addedEdgeToOtherEndpoint[currentEndpoint]]));\n            var tourIndex = removedEdgeIndexToTourOrder[currentEndpoint];\n            var nextEndpointTourIndex = addedEdgeToOtherEndpoint[tourIndex];\n            currentEndpoint = inverseRemovedEdgeIndexToTourOrder[nextEndpointTourIndex] ^ 1;\n        }\n        return out;\n\n------------------------------\n------------------------------\n        int startAsInt = PythonSlice.asValidStartIntIndexForLength(start, value.length);\n        int endAsInt = PythonSlice.asValidEndIntIndexForLength(end, value.length);\n\n        return countSubsequence(bytes.value, startAsInt, endAsInt);\n    }\n\n    public boolean hasPrefix(byte[] prefixBytes, int start, int end) {\n        if (prefixBytes.length > end - start) {\n            return false;\n        }\n\n        for (int i = 0; i < prefixBytes.length; i++) {\n            if (prefixBytes[i] != value[i + start]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n# Natural Language Annotations: /**\n     * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n     * <br />\n     * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n     * unique elements (p_1, p_2, ..., p_k) where\n     * <ul>\n     * <li>p_1 maps to p_2 in the permutation</li>\n     * <li>p_2 maps to p_3 in the permutation</li>\n     * <li>p_(k-1) maps to p_k in the permutation</li>\n     * <li>p_k maps to p_1 in the permutation</li>\n     * <li>In general: p_i maps to p_(i+1) in the permutation</li>\n     * </ul>\n     * For instance, the permutation\n     * <ul>\n     * <li>1 -> 2</li>\n     * <li>2 -> 3</li>\n     * <li>3 -> 1</li>\n     * <li>4 -> 5</li>\n     * <li>5 -> 4</li>\n     * </ul>\n     * can be expressed as `(1, 2, 3)(4, 5)`.\n     *\n     * @return The {@link KOptCycle} corresponding to the permutation described by\n     *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n     * @param kOptDescriptor The descriptor to calculate cycles for\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    KOptCycle kOptCycle = new KOptCycle();\n    int[] permutation = kOptDescriptor.removedEdgeIndexToTourOrder();\n    boolean[] visited = new boolean[permutation.length];\n\n    for (int i = 0; i < permutation.length; i++) {\n        if (!visited[i]) {\n            List<Integer> cycle = new ArrayList<>();\n            int vertex = i;\n            while (!visited[vertex]) {\n                visited[vertex] = true;\n                cycle.add(vertex);\n                vertex = permutation[vertex];\n            }\n            kOptCycle.addCycle(cycle);\n        }\n    }\n\n    return kOptCycle;\n}\n```\n", "```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    int[] removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    int[] oldRemovedEdges = kOptDescriptor.oldRemovedEdges();\n    KOptCycle kOptCycle = new KOptCycle();\n\n    for (int i = 0; i < removedEdgeIndexToTourOrder.length; i += 2) {\n        List<Integer> cycle = new ArrayList<>();\n        int startNode = oldRemovedEdges[removedEdgeIndexToTourOrder[i]];\n        int currentNode = startNode;\n        do {\n            cycle.add(currentNode);\n            currentNode = getNodeSuccessor(entityOrderInfo, currentNode);\n        } while (currentNode != startNode);\n        kOptCycle.addCycle(cycle);\n    }\n\n    return kOptCycle;\n}\n```\n", "```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    int[] removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    int[] inverseRemovedEdgeIndexToTourOrder = kOptDescriptor.inverseRemovedEdgeIndexToTourOrder();\n    int[] oldRemovedEdges = kOptDescriptor.oldRemovedEdges();\n\n    KOptCycle kOptCycle = new KOptCycle();\n    int[] addedEdgeToOtherEndpoint = kOptDescriptor.addedEdgeToOtherEndpoint();\n    int currentEndpoint = 1;\n\n    // This loop iterates through the new tour created\n    while (currentEndpoint != 2 * kOptDescriptor.k() + 1) {\n        var cycle = new ArrayList<Integer>();\n        var start = currentEndpoint;\n        do {\n            cycle.add(oldRemovedEdges[currentEndpoint]);\n            var tourIndex = removedEdgeIndexToTourOrder[currentEndpoint];\n            var nextEndpointTourIndex = addedEdgeToOtherEndpoint[tourIndex];\n            currentEndpoint = inverseRemovedEdgeIndexToTourOrder[nextEndpointTourIndex] ^ 1;\n        } while (currentEndpoint != start);\n        kOptCycle.addCycle(cycle);\n    }\n\n    return kOptCycle;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\n\n\n\n\n\n\n\n\n\n\n    record TriangleElement(int index, int level, int indexOnLevel) {\n\n        static TriangleElement valueOf(int index) {\n            int level = (int) Math.ceil(triangularRoot(index));\n            return new TriangleElement(index, level, index - nthTriangle(level - 1));\n        }\n\n------------------------------\n------------------------------\n\n    @Override\n    public S next() {\n        if (empty) {\n            throw new NoSuchElementException();\n        }\n        int index = workingRandom.nextInt(cachedList.size());\n        return cachedList.get(index);\n    }\n\n}\n\n------------------------------\n------------------------------\n            int minimumSubListSize, int maximumSubListSize) {\n        this.entitySelector = entitySelector;\n        this.valueSelector = valueSelector;\n        this.listVariableDescriptor = (ListVariableDescriptor<Solution_>) valueSelector.getVariableDescriptor();\n        if (minimumSubListSize < 1) {\n            // TODO raise this to 2 in Timefold Solver 2.0\n            throw new IllegalArgumentException(\n                    \"The minimumSubListSize (\" + minimumSubListSize + \") must be greater than 0.\");\n        }\n        if (minimumSubListSize > maximumSubListSize) {\n            throw new IllegalArgumentException(\"The minimumSubListSize (\" + minimumSubListSize\n                    + \") must be less than or equal to the maximumSubListSize (\" + maximumSubListSize + \").\");\n        }\n        this.minimumSubListSize = minimumSubListSize;\n        this.maximumSubListSize = maximumSubListSize;\n\n        phaseLifecycleSupport.addEventListener(entitySelector);\n        phaseLifecycleSupport.addEventListener(valueSelector);\n    }\n\n\n------------------------------\n------------------------------\npackage ai.timefold.solver.core.impl.heuristic.selector.list;\n\nimport static ai.timefold.solver.core.impl.heuristic.selector.list.TriangularNumbers.nthTriangle;\nimport static ai.timefold.solver.core.impl.heuristic.selector.list.TriangularNumbers.triangularRoot;\n\nimport java.util.Random;\n\nfinal class TriangleElementFactory {\n\n    private final int minimumSubListSize;\n    private final int maximumSubListSize;\n    private final Random workingRandom;\n\n    TriangleElementFactory(int minimumSubListSize, int maximumSubListSize, Random workingRandom) {\n        if (minimumSubListSize > maximumSubListSize) {\n            throw new IllegalArgumentException(\"The minimumSubListSize (\" + minimumSubListSize\n                    + \") must be less than or equal to the maximumSubListSize (\" + maximumSubListSize + \").\");\n        }\n        if (minimumSubListSize < 1) {\n            throw new IllegalArgumentException(\n\n------------------------------\n------------------------------\n            throw new IllegalArgumentException(\"The minimumSubListSize (\" + minimumSubListSize\n                    + \") must be less than or equal to the maximumSubListSize (\" + maximumSubListSize + \").\");\n        }\n        if (minimumSubListSize < 1) {\n            throw new IllegalArgumentException(\n                    \"The minimumSubListSize (\" + minimumSubListSize + \") must be greater than 0.\");\n        }\n        this.minimumSubListSize = minimumSubListSize;\n        this.maximumSubListSize = maximumSubListSize;\n        this.workingRandom = workingRandom;\n    }\n\n    /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n# Natural Language Annotations: /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"The listSize (\" + listSize\n                + \") must be greater than or equal to the minimumSubListSize (\" + minimumSubListSize + \").\");\n    }\n    if (listSize > maximumSubListSize) {\n        throw new IllegalArgumentException(\"The listSize (\" + listSize\n                + \") must be less than or equal to the maximumSubListSize (\" + maximumSubListSize + \").\");\n    }\n    int index = workingRandom.nextInt(listSize);\n    return TriangleElement.valueOf(index);\n}\n```\n", "```java\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"The listSize (\" + listSize\n                + \") must be greater than or equal to the minimumSubListSize (\" + minimumSubListSize + \").\");\n    }\n    int index = workingRandom.nextInt(nthTriangle(listSize)) + nthTriangle(listSize - 1);\n    return TriangleElement.valueOf(index);\n}\n```\n", "```java\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"The listSize (\" + listSize\n                + \") must be greater than or equal to the minimumSubListSize (\" + minimumSubListSize + \").\");\n    }\n    int triangleIndex = workingRandom.nextInt(listSize) + 1;\n    return TriangleElement.valueOf(triangleIndex);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    private final List<Object> indictedObjectList;\n    private final Score_ score;\n\n    /**\n     * @deprecated Prefer {@link ConstraintMatch#ConstraintMatch(ConstraintRef, ConstraintJustification, Collection, Score)}.\n     * @param constraintPackage never null\n     * @param constraintName never null\n     * @param justificationList never null, sometimes empty\n     * @param score never null\n     */\n    @Deprecated(forRemoval = true)\n    public ConstraintMatch(String constraintPackage, String constraintName, List<Object> justificationList, Score_ score) {\n        this(constraintPackage, constraintName, DefaultConstraintJustification.of(score, justificationList),\n                justificationList, score);\n    }\n\n    /**\n     * @deprecated Prefer {@link ConstraintMatch#ConstraintMatch(ConstraintRef, ConstraintJustification, Collection, Score)}.\n     * @param constraintPackage never null\n     * @param constraintName never null\n\n------------------------------\n------------------------------\n        this.problemStatisticEnabled = problemStatisticEnabled;\n    }\n\n    public List<ProblemStatisticType> getProblemStatisticTypeList() {\n        return problemStatisticTypeList;\n    }\n\n    public void setProblemStatisticTypeList(List<ProblemStatisticType> problemStatisticTypeList) {\n        this.problemStatisticTypeList = problemStatisticTypeList;\n    }\n\n    public List<SingleStatisticType> getSingleStatisticTypeList() {\n        return singleStatisticTypeList;\n    }\n\n    public void setSingleStatisticTypeList(List<SingleStatisticType> singleStatisticTypeList) {\n        this.singleStatisticTypeList = singleStatisticTypeList;\n    }\n\n    // ************************************************************************\n\n------------------------------\n------------------------------\n     */\n    public int softScore() {\n        return softScore;\n    }\n\n    /**\n     * As defined by {@link #softScore()}.\n     *\n     * @deprecated Use {@link #softScore()} instead.\n     */\n    @Deprecated(forRemoval = true)\n    public int getSoftScore() {\n        return softScore;\n    }\n\n    // ************************************************************************\n    // Worker methods\n    // ************************************************************************\n\n    @Override\n\n------------------------------\n------------------------------\n    }\n\n    /**\n     * As defined by {@link #levelsSize()}.\n     *\n     * @deprecated Use {@link #levelsSize()} instead.\n     */\n    @Deprecated(forRemoval = true)\n    default int getLevelsSize() {\n        return levelsSize();\n    }\n\n}\n\n------------------------------\n------------------------------\n    /** Workaround for annotation limitation in {@link #scoreDefinitionClass()}. */\n    @Deprecated(forRemoval = true)\n    interface NullScoreDefinition extends ScoreDefinition {\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true)    public List<Object> getJustificationList() {\n# Natural Language Annotations: /**\n     * Return a list of justifications for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n     * (eg. [A, B] for a bi stream),\n     * unless a custom justification mapping was provided, in which case it throws an exception,\n     * pointing users towards {@link #getJustification()}.</li>\n     * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    return indictedObjectList;\n}\n```\n", "```java\n/**\n * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n * @return never null\n */\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    return justificationList;\n}\n```\n", "```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    // return the list of justifications\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                composeFunction);\n    }\n\n    /**\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, BiFunction)}.\n     */\n    public static <A, B, C, D, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n            QuadConstraintCollector<A, B, C, D, ?, Result_> compose(\n                    QuadConstraintCollector<A, B, C, D, SubResultContainer1_, SubResult1_> subCollector1,\n                    QuadConstraintCollector<A, B, C, D, SubResultContainer2_, SubResult2_> subCollector2,\n                    BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n        return InnerQuadConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n    }\n\n    /**\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, TriFunction)}.\n     */\n    public static <A, B, C, D, Result_, SubResultContainer1_, SubResultContainer2_, SubResultContainer3_, SubResult1_, SubResult2_, SubResult3_>\n            QuadConstraintCollector<A, B, C, D, ?, Result_> compose(\n                    QuadConstraintCollector<A, B, C, D, SubResultContainer1_, SubResult1_> subCollector1,\n\n------------------------------\n------------------------------\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, TriFunction)}.\n     */\n    public static <A, B, Result_, SubResultContainer1_, SubResultContainer2_, SubResultContainer3_, SubResult1_, SubResult2_, SubResult3_>\n            BiConstraintCollector<A, B, ?, Result_> compose(\n                    BiConstraintCollector<A, B, SubResultContainer1_, SubResult1_> subCollector1,\n                    BiConstraintCollector<A, B, SubResultContainer2_, SubResult2_> subCollector2,\n                    BiConstraintCollector<A, B, SubResultContainer3_, SubResult3_> subCollector3,\n                    TriFunction<SubResult1_, SubResult2_, SubResult3_, Result_> composeFunction) {\n        return InnerBiConstraintCollectors.compose(subCollector1, subCollector2, subCollector3, composeFunction);\n    }\n\n    /**\n     * As defined by\n     * {@link #compose(UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, QuadFunction)}.\n     */\n    public static <A, B, Result_, SubResultContainer1_, SubResultContainer2_, SubResultContainer3_, SubResultContainer4_, SubResult1_, SubResult2_, SubResult3_, SubResult4_>\n            BiConstraintCollector<A, B, ?, Result_> compose(\n                    BiConstraintCollector<A, B, SubResultContainer1_, SubResult1_> subCollector1,\n                    BiConstraintCollector<A, B, SubResultContainer2_, SubResult2_> subCollector2,\n                    BiConstraintCollector<A, B, SubResultContainer3_, SubResult3_> subCollector3,\n\n------------------------------\n------------------------------\n                    TriConstraintCollector<A, B, C, SubResultContainer1_, SubResult1_> subCollector1,\n                    TriConstraintCollector<A, B, C, SubResultContainer2_, SubResult2_> subCollector2,\n                    BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n        return InnerTriConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n    }\n\n    /**\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, TriFunction)}.\n     */\n    public static <A, B, C, Result_, SubResultContainer1_, SubResultContainer2_, SubResultContainer3_, SubResult1_, SubResult2_, SubResult3_>\n            TriConstraintCollector<A, B, C, ?, Result_> compose(\n                    TriConstraintCollector<A, B, C, SubResultContainer1_, SubResult1_> subCollector1,\n                    TriConstraintCollector<A, B, C, SubResultContainer2_, SubResult2_> subCollector2,\n                    TriConstraintCollector<A, B, C, SubResultContainer3_, SubResult3_> subCollector3,\n                    TriFunction<SubResult1_, SubResult2_, SubResult3_, Result_> composeFunction) {\n        return InnerTriConstraintCollectors.compose(subCollector1, subCollector2, subCollector3, composeFunction);\n    }\n\n    /**\n     * As defined by\n\n------------------------------\n------------------------------\n        return InnerTriConstraintCollectors.compose(subCollector1, subCollector2, subCollector3, composeFunction);\n    }\n\n    /**\n     * As defined by\n     * {@link #compose(UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, QuadFunction)}.\n     */\n    public static <A, B, C, Result_, SubResultContainer1_, SubResultContainer2_, SubResultContainer3_, SubResultContainer4_, SubResult1_, SubResult2_, SubResult3_, SubResult4_>\n            TriConstraintCollector<A, B, C, ?, Result_> compose(\n                    TriConstraintCollector<A, B, C, SubResultContainer1_, SubResult1_> subCollector1,\n                    TriConstraintCollector<A, B, C, SubResultContainer2_, SubResult2_> subCollector2,\n                    TriConstraintCollector<A, B, C, SubResultContainer3_, SubResult3_> subCollector3,\n                    TriConstraintCollector<A, B, C, SubResultContainer4_, SubResult4_> subCollector4,\n                    QuadFunction<SubResult1_, SubResult2_, SubResult3_, SubResult4_, Result_> composeFunction) {\n        return InnerTriConstraintCollectors.compose(subCollector1, subCollector2, subCollector3, subCollector4,\n                composeFunction);\n    }\n\n    /**\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, BiFunction)}.\n\n------------------------------\n------------------------------\n                composeFunction);\n    }\n\n    /**\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, BiFunction)}.\n     */\n    public static <A, B, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n            BiConstraintCollector<A, B, ?, Result_> compose(\n                    BiConstraintCollector<A, B, SubResultContainer1_, SubResult1_> subCollector1,\n                    BiConstraintCollector<A, B, SubResultContainer2_, SubResult2_> subCollector2,\n                    BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n        return InnerBiConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n    }\n\n    /**\n     * As defined by {@link #compose(UniConstraintCollector, UniConstraintCollector, UniConstraintCollector, TriFunction)}.\n     */\n    public static <A, B, Result_, SubResultContainer1_, SubResultContainer2_, SubResultContainer3_, SubResult1_, SubResult2_, SubResult3_>\n            BiConstraintCollector<A, B, ?, Result_> compose(\n                    BiConstraintCollector<A, B, SubResultContainer1_, SubResult1_> subCollector1,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>            UniConstraintCollector<A, ?, Result_> compose(\n# Natural Language Annotations: /**\n     * Returns a constraint collector the result of which is a composition of other constraint collectors.\n     * The return value of this collector, incl. the default return value, depends solely on the compose function.\n     *\n     * @param subCollector1 never null, first collector to compose\n     * @param subCollector2 never null, second collector to compose\n     * @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n                UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return InnerUniConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n}\n```\n", "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n                UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return InnerUniConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n}\n```\n", "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n                UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return InnerUniConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n    /**\n     * Specialized version of {@link #toConnectedRanges(Function,Function,BiFunction)} for\n     * {@link Temporal} types.\n     *\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> temporal type of the endpoints\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @return never null\n     */\n    public static <A, PointType_ extends Temporal & Comparable<PointType_>>\n            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, Duration>>\n            toConnectedTemporalRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap) {\n\n------------------------------\n------------------------------\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\n    public static <A, B, C, D, IntervalType_, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n            QuadConstraintCollector<A, B, C, D, ?, ConnectedRangeChain<IntervalType_, PointType_, DifferenceType_>>\n            toConnectedRanges(QuadFunction<A, B, C, D, IntervalType_> intervalMap,\n                    Function<IntervalType_, PointType_> startInclusiveMap, Function<IntervalType_, PointType_> endExclusiveMap,\n                    BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n        return InnerQuadConstraintCollectors.toConnectedRanges(intervalMap, startInclusiveMap, endExclusiveMap,\n                differenceFunction);\n    }\n\n    /**\n     * As defined by {@link #toConnectedTemporalRanges(Function,Function)}.\n     *\n     * @param intervalMap Maps the three facts to an item in the cluster\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param <A> type of the first mapped fact\n     * @param <B> type of the second mapped fact\n\n------------------------------\n------------------------------\n            QuadFunction<? super A, ? super B, ? super C, ? super D, ? extends Mapped_> mapper,\n            Comparator<? super Mapped_> comparator) {\n        return new ToSortedSetComparatorQuadCollector<>(mapper, comparator);\n    }\n\n    public static <A, B, C, D, Result_> QuadConstraintCollector<A, B, C, D, ?, SequenceChain<Result_, Integer>>\n            toConsecutiveSequences(QuadFunction<A, B, C, D, Result_> resultMap, ToIntFunction<Result_> indexMap) {\n        return new ConsecutiveSequencesQuadConstraintCollector<>(resultMap, indexMap);\n    }\n\n    public static <A, B, C, D, Interval_, Point_ extends Comparable<Point_>, Difference_ extends Comparable<Difference_>>\n            QuadConstraintCollector<A, B, C, D, ?, ConnectedRangeChain<Interval_, Point_, Difference_>>\n            toConnectedRanges(QuadFunction<? super A, ? super B, ? super C, ? super D, ? extends Interval_> mapper,\n                    Function<? super Interval_, ? extends Point_> startMap,\n                    Function<? super Interval_, ? extends Point_> endMap,\n                    BiFunction<? super Point_, ? super Point_, ? extends Difference_> differenceFunction) {\n        return new ConnectedRangesQuadConstraintCollector<>(mapper, startMap, endMap,\n                differenceFunction);\n    }\n\n\n------------------------------\n------------------------------\n     * @param <A> type of the first mapped fact\n     * @param <B> type of the second mapped fact\n     * @param <IntervalType_> type of the item in the cluster\n     * @param <PointType_> type of the item endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\n    public static <A, B, IntervalType_, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n            BiConstraintCollector<A, B, ?, ConnectedRangeChain<IntervalType_, PointType_, DifferenceType_>>\n            toConnectedRanges(BiFunction<A, B, IntervalType_> intervalMap,\n                    Function<IntervalType_, PointType_> startInclusiveMap,\n                    Function<IntervalType_, PointType_> endExclusiveMap,\n                    BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n        return InnerBiConstraintCollectors.toConnectedRanges(intervalMap, startInclusiveMap, endExclusiveMap,\n                differenceFunction);\n    }\n\n    /**\n     * As defined by {@link #toConnectedTemporalRanges(Function,Function)}.\n     *\n\n------------------------------\n------------------------------\n            toConsecutiveSequences(ToIntFunction<A> indexMap) {\n        return new ConsecutiveSequencesUniConstraintCollector<>(indexMap);\n    }\n\n    public static <A, Interval_, Point_ extends Comparable<Point_>, Difference_ extends Comparable<Difference_>>\n            UniConstraintCollector<A, ?, ConnectedRangeChain<Interval_, Point_, Difference_>>\n            toConnectedRanges(Function<? super A, ? extends Interval_> mapper,\n                    Function<? super Interval_, ? extends Point_> startMap,\n                    Function<? super Interval_, ? extends Point_> endMap,\n                    BiFunction<? super Point_, ? super Point_, ? extends Difference_> differenceFunction) {\n        return new ConnectedRangesUniConstraintCollector<>(mapper, startMap, endMap,\n                differenceFunction);\n    }\n\n    public static <A, Intermediate_, Result_> UniConstraintCollector<A, ?, Result_>\n            collectAndThen(UniConstraintCollector<A, ?, Intermediate_> delegate,\n                    Function<Intermediate_, Result_> mappingFunction) {\n        return new AndThenUniCollector<>(delegate, mappingFunction);\n    }\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>            toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n# Natural Language Annotations: /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n     *                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n     *                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\ntoConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\nBiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return new ConnectedRangesUniConstraintCollector<>(startInclusiveMap, endExclusiveMap, differenceFunction);\n}\n```\n", "```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n        UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\n        toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n                         BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return new UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>() {\n        @Override\n        public Supplier<ConnectedRangeChain<A, PointType_, DifferenceType_>> supplier() {\n            return ConnectedRangeChain::new;\n        }\n\n        @Override\n        public BiConsumer<ConnectedRangeChain<A, PointType_, DifferenceType_>, A> accumulator() {\n            return (connectedRangeChain, a) -> {\n                PointType_ start = startInclusiveMap.apply(a);\n                PointType_ end = endExclusiveMap.apply(a);\n                connectedRangeChain.add(a, start, end, differenceFunction);\n            };\n        }\n\n        @Override\n        public BinaryOperator<ConnectedRangeChain<A, PointType_, DifferenceType_>> combiner() {\n            return (connectedRangeChain1, connectedRangeChain2) -> {\n                connectedRangeChain1.addAll(connectedRangeChain2);\n                return connectedRangeChain1;\n            };\n        }\n\n        @Override\n        public Function<ConnectedRangeChain<A, PointType_, DifferenceType_>, ConnectedRangeChain<A, PointType_, DifferenceType_>> finisher() {\n            return Function.identity();\n        }\n\n        @Override\n        public Set<Characteristics> characteristics() {\n            return Collections.emptySet();\n        }\n    };\n}\n```\n", "```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>> \nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\ntoConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n                  BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return InnerUniConstraintCollectors.toConnectedRanges(startInclusiveMap, endExclusiveMap, differenceFunction);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    default ScoreAnalysis<Score_> buildScoreAnalysis(boolean analyzeConstraintMatches) {\n        return buildScoreAnalysis(analyzeConstraintMatches, ScoreAnalysisMode.DEFAULT);\n    }\n\n    /**\n     *\n     * @param analyzeConstraintMatches True if the result's {@link ConstraintAnalysis} should have its {@link MatchAnalysis}\n     *        populated.\n     * @param mode Allows to tweak the behavior of this method.\n     * @return never null\n     */\n    default ScoreAnalysis<Score_> buildScoreAnalysis(boolean analyzeConstraintMatches, ScoreAnalysisMode mode) {\n        var score = calculateScore();\n        if (Objects.requireNonNull(mode) == ScoreAnalysisMode.RECOMMENDATION_API) {\n            score = score.withInitScore(0);\n        }\n        var constraintAnalysisMap = new TreeMap<ConstraintRef, ConstraintAnalysis<Score_>>();\n        for (var constraintMatchTotal : getConstraintMatchTotalMap().values()) {\n            var constraintAnalysis = getConstraintAnalysis(constraintMatchTotal, analyzeConstraintMatches);\n\n------------------------------\n------------------------------\n        validateConstraintWeight(constraintRef, weight);\n        return weight;\n    }\n\n    private void validateConstraintWeight(ConstraintRef constraintRef, Score_ constraintWeight) {\n        if (constraintWeight == null) {\n            throw new IllegalArgumentException(\"\"\"\n                    The constraintWeight for constraint (%s) must not be null.\n                    Maybe validate the data input of your constraintConfigurationClass (%s) for that constraint.\"\"\"\n                    .formatted(constraintRef, constraintConfigurationDescriptor.getConstraintConfigurationClass()));\n        }\n        var scoreDescriptor = constraintConfigurationDescriptor.getSolutionDescriptor().<Score_> getScoreDescriptor();\n        if (!scoreDescriptor.getScoreClass().isAssignableFrom(constraintWeight.getClass())) {\n            throw new IllegalArgumentException(\"\"\"\n                    The constraintWeight (%s) of class (%s) for constraint (%s) must be of the scoreClass (%s).\n                    Maybe validate the data input of your constraintConfigurationClass (%s) for that constraint.\"\"\"\n                    .formatted(constraintWeight, constraintWeight.getClass(), constraintRef, scoreDescriptor.getScoreClass(),\n                            constraintConfigurationDescriptor.getConstraintConfigurationClass()));\n        }\n        if (constraintWeight.initScore() != 0) {\n\n------------------------------\n------------------------------\n            score = score.withInitScore(0);\n        }\n        var constraintAnalysisMap = new TreeMap<ConstraintRef, ConstraintAnalysis<Score_>>();\n        for (var constraintMatchTotal : getConstraintMatchTotalMap().values()) {\n            var constraintAnalysis = getConstraintAnalysis(constraintMatchTotal, analyzeConstraintMatches);\n            constraintAnalysisMap.put(constraintMatchTotal.getConstraintRef(), constraintAnalysis);\n        }\n        return new ScoreAnalysis<>(score, constraintAnalysisMap);\n    }\n\n    enum ScoreAnalysisMode {\n        /**\n         * The default mode, which will throw an exception if the solution is not initialized.\n         */\n        DEFAULT,\n        /**\n         * If analysis is requested as a result of a score corruption detection,\n         * there will be no tweaks to the score and no initialization exception will be thrown.\n         * This is because score corruption may have been detected during construction heuristics,\n         * where the score is rightfully uninitialized.\n\n------------------------------\n------------------------------\n        private ConstraintMatchCarrier(ConstraintMatchSupplier<Score_> constraintMatchSupplier, Constraint constraint,\n                Score_ score) {\n            this.constraint = constraint;\n            this.constraintMatchSupplier = constraintMatchSupplier;\n            this.score = score;\n        }\n\n        @Override\n        public ConstraintMatch<Score_> get() {\n            if (constraintMatch == null) {\n                // Repeated requests for score explanation should not create the same constraint match over and over.\n                constraintMatch = constraintMatchSupplier.apply(constraint, score);\n            }\n            return constraintMatch;\n        }\n\n    }\n\n}\n\n------------------------------\n------------------------------\n            Score_ score) {\n        ConstraintMatch<Score_> constraintMatch = new ConstraintMatch<>(constraintRef, justification, indictedObjects, score);\n        addConstraintMatch(constraintMatch);\n        return constraintMatch;\n    }\n\n    public void addConstraintMatch(ConstraintMatch<Score_> constraintMatch) {\n        Score_ constraintMatchScore = constraintMatch.getScore();\n        this.score = this.score == null ? constraintMatchScore : this.score.add(constraintMatchScore);\n        constraintMatchSet.add(constraintMatch);\n    }\n\n    public void removeConstraintMatch(ConstraintMatch<Score_> constraintMatch) {\n        score = score.subtract(constraintMatch.getScore());\n        boolean removed = constraintMatchSet.remove(constraintMatch);\n        if (!removed) {\n            throw new IllegalStateException(\"The constraintMatchTotal (\" + this\n                    + \") could not remove constraintMatch (\" + constraintMatch\n                    + \") from its constraintMatchSet (\" + constraintMatchSet + \").\");\n        }\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n# Natural Language Annotations: /**\n     * Compare this {@link ScoreAnalysis} to another {@link ScoreAnalysis}\n     * and retrieve the difference between them.\n     * The comparison is in the direction of {@code this - other}.\n     * <p>\n     * Example: if {@code this} has a score of 100 and {@code other} has a score of 90,\n     * the returned {@link ScoreAnalysis#score} will be 10.\n     * If this and other were inverted, the score would have been -10.\n     * The same applies to all other properties of {@link ScoreAnalysis}.\n     *\n     * <p>\n     * In order to properly diff {@link MatchAnalysis} against each other,\n     * we rely on the user implementing {@link ConstraintJustification} equality correctly.\n     * In other words, the diff will consider two justifications equal if the user says they are equal,\n     * and it expects the hash code to be consistent with equals.\n     *\n     * <p>\n     * If one {@link ScoreAnalysis} provides {@link MatchAnalysis} and the other doesn't, exception is thrown.\n     * Such {@link ScoreAnalysis} instances are mutually incompatible.\n     *\n     * @param other never null\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (!this.score.getClass().equals(other.score.getClass())) {\n        throw new IllegalArgumentException(\"Incompatible ScoreAnalysis: different Score_ classes\");\n    }\n    Score_ diffScore = this.score.subtract(other.score);\n    Map<ConstraintRef, ConstraintAnalysis<Score_>> diffAnalysisMap = new TreeMap<>();\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> thisEntry : this.constraintAnalysisMap.entrySet()) {\n        ConstraintRef constraintRef = thisEntry.getKey();\n        ConstraintAnalysis<Score_> thisAnalysis = thisEntry.getValue();\n        if (!other.constraintAnalysisMap.containsKey(constraintRef)) {\n            throw new IllegalArgumentException(\"Incompatible ScoreAnalysis: missing constraint analysis for \" + constraintRef);\n        }\n        ConstraintAnalysis<Score_> otherAnalysis = other.constraintAnalysisMap.get(constraintRef);\n        diffAnalysisMap.put(constraintRef, thisAnalysis.diff(otherAnalysis));\n    }\n    return new ScoreAnalysis<>(diffScore, diffAnalysisMap);\n}\n```\n", "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    Score_ newScore = this.score.subtract(other.score);\n\n    Map<ConstraintRef, ConstraintAnalysis<Score_>> diffConstraintAnalysisMap = new TreeMap<>();\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> thisEntry : this.constraintAnalysisMap.entrySet()) {\n        ConstraintRef constraintRef = thisEntry.getKey();\n        ConstraintAnalysis<Score_> thisConstraintAnalysis = thisEntry.getValue();\n        ConstraintAnalysis<Score_> otherConstraintAnalysis = other.constraintAnalysisMap.get(constraintRef);\n\n        if (otherConstraintAnalysis == null) {\n            throw new IllegalArgumentException(\"Both ScoreAnalyses must provide a ConstraintAnalysis for every ConstraintRef. \" +\n                    \"ConstraintRef \" + constraintRef + \" was found in this but not in other.\");\n        }\n\n        diffConstraintAnalysisMap.put(constraintRef, thisConstraintAnalysis.diff(otherConstraintAnalysis));\n    }\n\n    return new ScoreAnalysis<>(newScore, diffConstraintAnalysisMap);\n}\n```\n", "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    Score_ scoreDiff = this.score.subtract(other.score);\n    Map<ConstraintRef, ConstraintAnalysis<Score_>> constraintAnalysisDiff = new TreeMap<>();\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> entry : this.constraintAnalysisMap.entrySet()) {\n        ConstraintRef constraintRef = entry.getKey();\n        ConstraintAnalysis<Score_> thisAnalysis = entry.getValue();\n        if (!other.constraintAnalysisMap.containsKey(constraintRef)) {\n            throw new IllegalArgumentException(\"Mutually incompatible ScoreAnalysis instances. Missing ConstraintRef \" + constraintRef);\n        }\n        ConstraintAnalysis<Score_> otherAnalysis = other.constraintAnalysisMap.get(constraintRef);\n        ConstraintMatchTotal<Score_> thisMatchTotal = thisAnalysis.getConstraintMatchTotal();\n        ConstraintMatchTotal<Score_> otherMatchTotal = otherAnalysis.getConstraintMatchTotal();\n        Score_ matchScoreDiff = thisMatchTotal.getScore().subtract(otherMatchTotal.getScore());\n        ConstraintMatchTotal<Score_> matchTotalDiff = new ConstraintMatchTotal<>(thisMatchTotal.getConstraintRef(), matchScoreDiff,\n                thisMatchTotal.getConstraintMatchList().stream().filter(match -> !otherMatchTotal.getConstraintMatchList().contains(match)).collect(Collectors.toList()));\n        ConstraintAnalysis<Score_> diffAnalysis = new ConstraintAnalysis<>(thisAnalysis.getConstraint(), matchTotalDiff);\n        constraintAnalysisDiff.put(constraintRef, diffAnalysis);\n    }\n    return new ScoreAnalysis<>(scoreDiff, constraintAnalysisDiff);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public int hashCode() {\n        return entrySet.hashCode();\n    }\n\n    public PythonString toRepresentation() {\n        return PythonString.valueOf(toString());\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder out = new StringBuilder(\"dict_items([\");\n\n        for (Map.Entry<PythonLikeObject, PythonLikeObject> entry : entrySet) {\n            out.append(\"(\");\n            out.append(UnaryDunderBuiltin.REPRESENTATION.invoke(entry.getKey()));\n            out.append(\", \");\n            out.append(UnaryDunderBuiltin.REPRESENTATION.invoke(entry.getValue()));\n            out.append(\"), \");\n        }\n\n------------------------------\n------------------------------\n        switch (constraintMatchSetSize) {\n            case 0 -> {\n                return Collections.emptyList();\n            }\n            case 1 -> {\n                return Collections.singletonList(constraintMatchSet.iterator().next().getJustification());\n            }\n            default -> {\n                Set<ConstraintJustification> justificationSet = CollectionUtils.newLinkedHashSet(constraintMatchSetSize);\n                for (ConstraintMatch<Score_> constraintMatch : constraintMatchSet) {\n                    justificationSet.add(constraintMatch.getJustification());\n                }\n                return CollectionUtils.toDistinctList(justificationSet);\n            }\n        }\n    }\n\n    @Override\n    public Score_ getScore() {\n        return score;\n\n------------------------------\n------------------------------\n\n    @Override\n    public int hashCode() {\n        return keySet.hashCode();\n    }\n\n    public PythonString toRepresentation() {\n        return PythonString.valueOf(toString());\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder out = new StringBuilder(\"dict_keys([\");\n\n        for (PythonLikeObject key : keySet) {\n            out.append(UnaryDunderBuiltin.REPRESENTATION.invoke(key));\n            out.append(\", \");\n        }\n        out.delete(out.length() - 2, out.length());\n        out.append(\"])\");\n\n------------------------------\n------------------------------\n        this.constraintDescriptorMap = Collections.unmodifiableMap(constraintDescriptorMap);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ConstraintDescriptor<Score_> getConstraintDescriptor(ConstraintRef constraintRef) {\n        var constraint = constraintDescriptorMap.get(constraintRef);\n        return new ConstraintDescriptor<>(constraint.getConstraintRef().constraintName(),\n                constraint.getDescription(), (Score_) constraint.getDefaultConstraintWeight());\n    }\n\n    @Override\n    public Collection<AbstractConstraint<?, ?, ?>> getConstraints() {\n        return constraintDescriptorMap.values();\n    }\n\n}\n\n------------------------------\n------------------------------\n\n    @Override\n    public String toString() {\n        StringBuilder out = new StringBuilder(\"dict_values([\");\n\n        for (PythonLikeObject value : valueCollection) {\n            out.append(UnaryDunderBuiltin.REPRESENTATION.invoke(value));\n            out.append(\", \");\n        }\n        out.delete(out.length() - 2, out.length());\n        out.append(\"])\");\n\n        return out.toString();\n    }\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, provide this information in a UI or a service,\n     * use {@link ScoreAnalysis#constraintAnalyses()}\n     * and convert those into a domain-specific API.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder out = new StringBuilder();\n\n    if (score.isFeasible()) {\n        out.append(\"Solution is feasible.\");\n    } else {\n        out.append(\"Solution is infeasible. Causing constraints: \");\n        for (ConstraintMatch<Score_> constraintMatch : constraintMatchSet) {\n            out.append(constraintMatch.getJustification().toString());\n            out.append(\", \");\n        }\n    }\n\n    return out.toString();\n}\n```\n", "```java\n@Override\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n\n    if (score.isFeasible()) {\n        summary.append(\"The solution is feasible. No constraints cause that score quality.\");\n    } else {\n        summary.append(\"The solution is infeasible. The following constraints cause that score quality: \");\n        for (ConstraintMatch<Score_> constraintMatch : constraintMatchSet) {\n            summary.append(constraintMatch.getJustification().toString());\n            summary.append(\", \");\n        }\n    }\n\n    return summary.toString();\n}\n```\n", "```java\n@Override\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Solution Quality: \");\n    if (score.isFeasible()) {\n        sb.append(\"Feasible\\n\");\n        sb.append(\"Constraints causing score quality:\\n\");\n        for (ConstraintMatch<Score_> constraintMatch : constraintMatchSet) {\n            sb.append(constraintMatch.getJustification()).append(\"\\n\");\n        }\n    } else {\n        sb.append(\"Infeasible\\n\");\n        sb.append(\"Cause of infeasibility:\\n\");\n        // Additional logic to determine cause of infeasibility\n    }\n    return sb.toString();\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                .asConstraint(constraintName);\n    }\n\n    @Override\n    default Constraint impact(String constraintPackage, String constraintName, Score<?> constraintWeight) {\n        return impact((Score) constraintWeight)\n                .asConstraint(constraintPackage, constraintName);\n    }\n\n}\n\n------------------------------\n------------------------------\n    public String constraintPackage() {\n        return constraintRef.packageName();\n    }\n\n    /**\n     * Return name of the constraint that this analysis is for.\n     *\n     * @return equal to {@code constraintRef.constraintName()}\n     */\n    public String constraintName() {\n        return constraintRef.constraintName();\n    }\n\n    /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\n\n\n------------------------------\n------------------------------\n        private ConstraintMatchCarrier(ConstraintMatchSupplier<Score_> constraintMatchSupplier, Constraint constraint,\n                Score_ score) {\n            this.constraint = constraint;\n            this.constraintMatchSupplier = constraintMatchSupplier;\n            this.score = score;\n        }\n\n        @Override\n        public ConstraintMatch<Score_> get() {\n            if (constraintMatch == null) {\n                // Repeated requests for score explanation should not create the same constraint match over and over.\n                constraintMatch = constraintMatchSupplier.apply(constraint, score);\n            }\n            return constraintMatch;\n        }\n\n    }\n\n}\n\n------------------------------\n------------------------------\n\n    ConstraintAnalysis<Score_> negate() {\n        if (matches == null) {\n            return ConstraintAnalysis.of(constraintRef, weight.negate(), score.negate());\n        } else {\n            var negatedMatchAnalyses = matches.stream()\n                    .map(MatchAnalysis::negate)\n                    .toList();\n            return new ConstraintAnalysis<>(constraintRef, weight.negate(), score.negate(), negatedMatchAnalyses);\n        }\n    }\n\n    static <Score_ extends Score<Score_>> ConstraintAnalysis<Score_> diff(\n            ConstraintRef constraintRef, ConstraintAnalysis<Score_> constraintAnalysis,\n            ConstraintAnalysis<Score_> otherConstraintAnalysis) {\n        if (constraintAnalysis == null) {\n            if (otherConstraintAnalysis == null) {\n                throw new IllegalStateException(\n                        \"Impossible state: none of the score explanations provided constraint matches for a constraint (%s).\"\n                                .formatted(constraintRef));\n\n------------------------------\n------------------------------\n        this.constraintDescriptorMap = Collections.unmodifiableMap(constraintDescriptorMap);\n    }\n\n    @Override\n    @SuppressWarnings(\"unchecked\")\n    public ConstraintDescriptor<Score_> getConstraintDescriptor(ConstraintRef constraintRef) {\n        var constraint = constraintDescriptorMap.get(constraintRef);\n        return new ConstraintDescriptor<>(constraint.getConstraintRef().constraintName(),\n                constraint.getDescription(), (Score_) constraint.getDefaultConstraintWeight());\n    }\n\n    @Override\n    public Collection<AbstractConstraint<?, ?, ?>> getConstraints() {\n        return constraintDescriptorMap.values();\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    // TODO: Implement this method\n    return \"\";\n}\n```\n", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Constraint Package: \").append(constraintPackage()).append(\"\\n\");\n    sb.append(\"Constraint Name: \").append(constraintName()).append(\"\\n\");\n    sb.append(\"Constraint Match: \").append(constraintMatch()).append(\"\\n\");\n    sb.append(\"Constraint Score: \").append(constraintScore()).append(\"\\n\");\n    sb.append(\"Constraint Analysis: \").append(constraintAnalysis()).append(\"\\n\");\n    return sb.toString();\n}\n```\n", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder builder = new StringBuilder();\n    builder.append(\"Constraint Analysis:\\n\");\n    builder.append(\"Constraint Package: \").append(constraintPackage()).append(\"\\n\");\n    builder.append(\"Constraint Name: \").append(constraintName()).append(\"\\n\");\n    builder.append(\"Weight: \").append(weight).append(\"\\n\");\n    builder.append(\"Score: \").append(score).append(\"\\n\");\n    if (matches != null) {\n        builder.append(\"Matches:\\n\");\n        for (var match : matches) {\n            builder.append(match).append(\"\\n\");\n        }\n    }\n    return builder.toString();\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        count--;\n        sum = subtractor.apply(sum, input);\n    }\n\n    @Override\n    public Output_ result() {\n        if (count == 0) {\n            return null;\n        }\n        return divider.apply(sum, count);\n    }\n}\n\n------------------------------\n------------------------------\n    static final MillisecondDurationNumberFormatFactory INSTANCE = new MillisecondDurationNumberFormatFactory();\n\n    @Override\n    public TemplateNumberFormat get(String params, Locale locale, Environment environment) throws TemplateValueFormatException {\n        TemplateFormatUtil.checkHasNoParameters(params);\n        return new MillisecondDurationNumberFormat(locale);\n    }\n\n    static final class MillisecondDurationNumberFormat extends TemplateNumberFormat {\n\n        private final Locale locale;\n\n        public MillisecondDurationNumberFormat(Locale locale) {\n            this.locale = locale;\n        }\n\n        @Override\n        public String formatToPlainText(TemplateNumberModel templateNumberModel) throws TemplateModelException {\n            Number n = templateNumberModel.getAsNumber();\n            if (n == null) {\n\n------------------------------\n------------------------------\n        NumberFormat numberFormat = getNumberFormat(formatSpec);\n\n        out.append(numberFormat.format(value));\n        StringFormatter.align(out, formatSpec, DefaultFormatSpec.AlignmentOption.RIGHT_ALIGN);\n        return PythonString.valueOf(out.toString());\n    }\n\n    @Override\n    public <T> T coerce(Class<T> targetType) {\n        if (targetType.equals(PythonInteger.class)) {\n            return (T) PythonInteger.valueOf((long) value);\n        }\n        return null;\n    }\n}\n\n------------------------------\n------------------------------\n    public String toString() {\n        return toString(Locale.US);\n    }\n\n    public String toString(Locale locale) {\n        StringBuilder s = new StringBuilder(percentageLevels.length * 8);\n        DecimalFormat decimalFormat = new DecimalFormat(\"0.00%\", DecimalFormatSymbols.getInstance(locale));\n        for (int i = 0; i < percentageLevels.length; i++) {\n            if (i > 0) {\n                s.append(\"/\");\n            }\n            s.append(decimalFormat.format(percentageLevels[i]));\n        }\n        return s.toString();\n    }\n\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public StringBuffer format(double number, StringBuffer toAppendTo, FieldPosition pos) {\n        return format((long) number, toAppendTo, pos);\n    }\n\n    @Override\n    public StringBuffer format(long number, StringBuffer toAppendTo, FieldPosition pos) {\n        return toAppendTo.append(MillisecondDurationNumberFormatFactory.formatMillis(locale, number));\n    }\n\n    @Override\n    public Number parse(String source, ParsePosition parsePosition) {\n        throw new UnsupportedOperationException();\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n# Natural Language Annotations: /**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormatSymbols symbols = DecimalFormatSymbols.getInstance(locale);\n    decimalFormat.setDecimalFormatSymbols(symbols);\n    return decimalFormat.format(number);\n}\n```\n", "```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(locale);\n    DecimalFormat localizedFormat = (DecimalFormat) decimalFormat.clone();\n    localizedFormat.setDecimalFormatSymbols(otherSymbols);\n    return localizedFormat.format(number);\n}\n```\n", "```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);\n    decimalFormat.setDecimalFormatSymbols(symbols);\n    return decimalFormat.format(number);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @Override\n    public SolverJobBuilder<Solution_, ProblemId_> solveBuilder() {\n        return new DefaultSolverJobBuilder<>(this);\n    }\n\n    protected SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n            Function<? super ProblemId_, ? extends Solution_> problemFinder,\n            Consumer<? super Solution_> bestSolutionConsumer,\n            Consumer<? super Solution_> finalBestSolutionConsumer,\n            Consumer<? super Solution_> initializedSolutionConsumer,\n            BiConsumer<? super ProblemId_, ? super Throwable> exceptionHandler,\n            SolverConfigOverride<Solution_> solverConfigOverride) {\n        if (bestSolutionConsumer == null) {\n            throw new IllegalStateException(\"The consumer bestSolutionConsumer is required.\");\n        }\n        return solve(getProblemIdOrThrow(problemId), problemFinder, bestSolutionConsumer, finalBestSolutionConsumer,\n                initializedSolutionConsumer, exceptionHandler, solverConfigOverride);\n    }\n\n    protected SolverJob<Solution_, ProblemId_> solve(ProblemId_ problemId,\n\n------------------------------\n------------------------------\n     */\n    @Deprecated(forRemoval = true, since = \"1.6.0\")\n    default SolverJob<Solution_, ProblemId_> solve(ProblemId_ problemId,\n            Function<? super ProblemId_, ? extends Solution_> problemFinder,\n            Consumer<? super Solution_> finalBestSolutionConsumer) {\n        SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n                .withProblemId(problemId)\n                .withProblemFinder(problemFinder);\n        if (finalBestSolutionConsumer != null) {\n            builder.withFinalBestSolutionConsumer(finalBestSolutionConsumer);\n        }\n        return builder.run();\n    }\n\n    /**\n     * As defined by {@link #solve(Object, Function, Consumer)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n     *        {@link #getSolverStatus(Object) to get the status} or if the problem changes while solving.\n\n------------------------------\n------------------------------\n     * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n     * @param finalBestSolutionConsumer sometimes null, called only once, at the end, on a consumer thread.\n     *        That final best solution is already consumed by the bestSolutionConsumer earlier.\n     * @param exceptionHandler sometimes null, called if an exception or error occurs.\n     *        If null it defaults to logging the exception as an error.\n     * @deprecated It is recommended to use {@link #solveBuilder()} while also providing a consumer for the best solution\n     * @return never null\n     */\n    @Deprecated(forRemoval = true, since = \"1.6.0\")\n    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n            Function<? super ProblemId_, ? extends Solution_> problemFinder,\n            Consumer<? super Solution_> bestSolutionConsumer,\n            Consumer<? super Solution_> finalBestSolutionConsumer,\n            BiConsumer<? super ProblemId_, ? super Throwable> exceptionHandler) {\n        SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n                .withProblemId(problemId)\n                .withProblemFinder(problemFinder)\n                .withBestSolutionConsumer(bestSolutionConsumer);\n        if (finalBestSolutionConsumer != null) {\n            builder.withFinalBestSolutionConsumer(finalBestSolutionConsumer);\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public SolverJobBuilder<Solution_, ProblemId_> withProblemId(ProblemId_ problemId) {\n        this.problemId = Objects.requireNonNull(problemId, \"Invalid problemId (null) given to SolverJobBuilder.\");\n        return this;\n    }\n\n    @Override\n    public SolverJobBuilder<Solution_, ProblemId_>\n            withProblemFinder(Function<? super ProblemId_, ? extends Solution_> problemFinder) {\n        this.problemFinder = Objects.requireNonNull(problemFinder, \"Invalid problemFinder (null) given to SolverJobBuilder.\");\n        return this;\n    }\n\n    @Override\n    public SolverJobBuilder<Solution_, ProblemId_> withBestSolutionConsumer(Consumer<? super Solution_> bestSolutionConsumer) {\n        this.bestSolutionConsumer =\n                Objects.requireNonNull(bestSolutionConsumer, \"Invalid bestSolutionConsumer (null) given to SolverJobBuilder.\");\n        return this;\n\n------------------------------\n------------------------------\n    @Deprecated(forRemoval = true, since = \"1.6.0\")\n    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n            Function<? super ProblemId_, ? extends Solution_> problemFinder,\n            Consumer<? super Solution_> bestSolutionConsumer,\n            BiConsumer<? super ProblemId_, ? super Throwable> exceptionHandler) {\n        SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n                .withProblemId(problemId)\n                .withProblemFinder(problemFinder)\n                .withBestSolutionConsumer(bestSolutionConsumer);\n        if (exceptionHandler != null) {\n            builder.withExceptionHandler(exceptionHandler);\n        }\n        return builder.run();\n    }\n\n    /**\n     * As defined by {@link #solveAndListen(Object, Function, Consumer)}.\n     * <p>\n     * The final best solution is delivered twice:\n     * first to the {@code bestSolutionConsumer} when it is found\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true, since = \"1.6.0\")    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n# Natural Language Annotations: /**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n     * unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n     *        {@link #getSolverStatus(Object) to get the status} or if the problem changes while solving.\n     * @param problemFinder never null, a function that returns a {@link PlanningSolution}, usually with uninitialized planning\n     *        variables\n     * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n     * @deprecated It is recommended to use {@link #solveBuilder()} while also providing a consumer for the best solution\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<? super ProblemId_, ? extends Solution_> problemFinder,\n        Consumer<? super Solution_> bestSolutionConsumer) {\n    SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n            .withProblemId(problemId)\n            .withProblemFinder(problemFinder)\n            .withBestSolutionConsumer(bestSolutionConsumer);\n    return builder.run();\n}\n```\n", "```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<? super ProblemId_, ? extends Solution_> problemFinder,\n        Consumer<? super Solution_> bestSolutionConsumer) {\n    SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n            .withProblemId(problemId)\n            .withProblemFinder(problemFinder)\n            .withBestSolutionConsumer(bestSolutionConsumer);\n    return builder.run();\n}\n```\n", "```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<? super ProblemId_, ? extends Solution_> problemFinder,\n        Consumer<? super Solution_> bestSolutionConsumer) {\n    SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n            .withProblemId(problemId)\n            .withProblemFinder(problemFinder)\n            .withBestSolutionConsumer(bestSolutionConsumer);\n    return builder.run();\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        this.terminationClass = terminationClass;\n    }\n\n    public TerminationCompositionStyle getTerminationCompositionStyle() {\n        return terminationCompositionStyle;\n    }\n\n    public void setTerminationCompositionStyle(TerminationCompositionStyle terminationCompositionStyle) {\n        this.terminationCompositionStyle = terminationCompositionStyle;\n    }\n\n    public Duration getSpentLimit() {\n        return spentLimit;\n    }\n\n    public void setSpentLimit(Duration spentLimit) {\n        this.spentLimit = spentLimit;\n    }\n\n    public Long getMillisecondsSpentLimit() {\n\n------------------------------\n------------------------------\n\n    public TerminationConfig withTerminationConfigList(List<TerminationConfig> terminationConfigList) {\n        this.terminationConfigList = terminationConfigList;\n        return this;\n    }\n\n    public void overwriteSpentLimit(Duration spentLimit) {\n        setSpentLimit(spentLimit);\n        setMillisecondsSpentLimit(null);\n        setSecondsSpentLimit(null);\n        setMinutesSpentLimit(null);\n        setHoursSpentLimit(null);\n        setDaysSpentLimit(null);\n    }\n\n    public Long calculateTimeMillisSpentLimit() {\n        if (millisecondsSpentLimit == null && secondsSpentLimit == null\n                && minutesSpentLimit == null && hoursSpentLimit == null && daysSpentLimit == null) {\n            if (spentLimit != null) {\n                if (spentLimit.getNano() % 1000 != 0) {\n\n------------------------------\n------------------------------\n\n    public TerminationConfig withSpentLimit(Duration spentLimit) {\n        this.spentLimit = spentLimit;\n        return this;\n    }\n\n    public TerminationConfig withMillisecondsSpentLimit(Long millisecondsSpentLimit) {\n        this.millisecondsSpentLimit = millisecondsSpentLimit;\n        return this;\n    }\n\n    public TerminationConfig withSecondsSpentLimit(Long secondsSpentLimit) {\n        this.secondsSpentLimit = secondsSpentLimit;\n        return this;\n    }\n\n    public TerminationConfig withMinutesSpentLimit(Long minutesSpentLimit) {\n        this.minutesSpentLimit = minutesSpentLimit;\n        return this;\n    }\n\n------------------------------\n------------------------------\n\n    public TerminationConfig withUnimprovedSpentLimit(Duration unimprovedSpentLimit) {\n        this.unimprovedSpentLimit = unimprovedSpentLimit;\n        return this;\n    }\n\n    public TerminationConfig withUnimprovedMillisecondsSpentLimit(Long unimprovedMillisecondsSpentLimit) {\n        this.unimprovedMillisecondsSpentLimit = unimprovedMillisecondsSpentLimit;\n        return this;\n    }\n\n    public TerminationConfig withUnimprovedSecondsSpentLimit(Long unimprovedSecondsSpentLimit) {\n        this.unimprovedSecondsSpentLimit = unimprovedSecondsSpentLimit;\n        return this;\n    }\n\n    public TerminationConfig withUnimprovedMinutesSpentLimit(Long unimprovedMinutesSpentLimit) {\n        this.unimprovedMinutesSpentLimit = unimprovedMinutesSpentLimit;\n        return this;\n    }\n\n------------------------------\n------------------------------\n            scoreDirectorFactoryConfig = new ScoreDirectorFactoryConfig();\n        }\n        scoreDirectorFactoryConfig.setConstraintStreamImplType(constraintStreamImplType);\n        return this;\n    }\n\n    public SolverConfig withTerminationConfig(TerminationConfig terminationConfig) {\n        this.terminationConfig = terminationConfig;\n        return this;\n    }\n\n    /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n# Natural Language Annotations: /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (this.terminationConfig == null) {\n        this.terminationConfig = new TerminationConfig();\n    }\n    this.terminationConfig.withSpentLimit(spentLimit);\n    return this;\n}\n```\n", "```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (terminationConfig != null) {\n        terminationConfig.withSpentLimit(spentLimit);\n    }\n    return this;\n}\n```\n", "```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (this.terminationConfig == null) {\n        this.terminationConfig = new TerminationConfig();\n    }\n    this.terminationConfig.setSpentLimit(spentLimit);\n    return this;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-inherit": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    @Override\n    public void write(SolverConfig solverConfig, Writer writer) {\n        genericJaxbIO.writeWithoutNamespaces(solverConfig, writer);\n    }\n}\n\n------------------------------\n------------------------------\n    public SolverConfig(SolverConfig inheritedConfig) {\n        inherit(inheritedConfig);\n    }\n\n    public ClassLoader getClassLoader() {\n        return classLoader;\n    }\n\n    public void setClassLoader(ClassLoader classLoader) {\n        this.classLoader = classLoader;\n    }\n\n    public EnvironmentMode getEnvironmentMode() {\n        return environmentMode;\n    }\n\n    public void setEnvironmentMode(EnvironmentMode environmentMode) {\n        this.environmentMode = environmentMode;\n    }\n\n\n------------------------------\n------------------------------\n\n    public SolverBenchmarkConfig getInheritedSolverBenchmarkConfig() {\n        return inheritedSolverBenchmarkConfig;\n    }\n\n    public void setInheritedSolverBenchmarkConfig(SolverBenchmarkConfig inheritedSolverBenchmarkConfig) {\n        this.inheritedSolverBenchmarkConfig = inheritedSolverBenchmarkConfig;\n    }\n\n    public List<SolverBenchmarkBluePrintConfig> getSolverBenchmarkBluePrintConfigList() {\n        return solverBenchmarkBluePrintConfigList;\n    }\n\n    public void setSolverBenchmarkBluePrintConfigList(List<SolverBenchmarkBluePrintConfig> solverBenchmarkBluePrintConfigList) {\n        this.solverBenchmarkBluePrintConfigList = solverBenchmarkBluePrintConfigList;\n    }\n\n    public List<SolverBenchmarkConfig> getSolverBenchmarkConfigList() {\n        return solverBenchmarkConfigList;\n    }\n\n------------------------------\n------------------------------\n\n    public PlannerBenchmarkConfig withSolverBenchmarkConfigs(SolverBenchmarkConfig... solverBenchmarkConfigs) {\n        this.setSolverBenchmarkConfigList(List.of(solverBenchmarkConfigs));\n        return this;\n    }\n}\n\n------------------------------\n------------------------------\n    }\n\n    @Override\n    public void solvingEnded(SolverScope<Solution_> solverScope) {\n        // Hook method\n    }\n\n}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public SolverConfig inherit(SolverConfig inheritedConfig) {\n# Natural Language Annotations: /**\n     * Do not use this method, it is an internal method.\n     * Use {@link #SolverConfig(SolverConfig)} instead.\n     *\n     * @param inheritedConfig never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\n/**\n * Do not use this method, it is an internal method.\n * Use {@link #SolverConfig(SolverConfig)} instead.\n *\n * @param inheritedConfig never null\n */\npublic SolverConfig inherit(SolverConfig inheritedConfig) {\n    setClassLoader(inheritedConfig.getClassLoader());\n    setEnvironmentMode(inheritedConfig.getEnvironmentMode());\n    setInheritedSolverBenchmarkConfig(inheritedConfig.getInheritedSolverBenchmarkConfig());\n    setSolverBenchmarkBluePrintConfigList(inheritedConfig.getSolverBenchmarkBluePrintConfigList());\n    setSolverBenchmarkConfigList(inheritedConfig.getSolverBenchmarkConfigList());\n    return this;\n}\n```\n", "```java\n/**\n * Do not use this method, it is an internal method.\n * Use {@link #SolverConfig(SolverConfig)} instead.\n *\n * @param inheritedConfig never null\n */\n@Override\npublic SolverConfig inherit(SolverConfig inheritedConfig) {\n    if (inheritedConfig != null) {\n        this.setClassLoader(inheritedConfig.getClassLoader());\n        this.setEnvironmentMode(inheritedConfig.getEnvironmentMode());\n        this.setInheritedSolverBenchmarkConfig(inheritedConfig.getInheritedSolverBenchmarkConfig());\n        this.setSolverBenchmarkBluePrintConfigList(inheritedConfig.getSolverBenchmarkBluePrintConfigList());\n        this.setSolverBenchmarkConfigList(inheritedConfig.getSolverBenchmarkConfigList());\n    }\n    return this;\n}\n```\n", "```java\n/**\n * Do not use this method, it is an internal method.\n * Use {@link #SolverConfig(SolverConfig)} instead.\n *\n * @param inheritedConfig never null\n */\n@Override\npublic SolverConfig inherit(SolverConfig inheritedConfig) {\n    setClassLoader(inheritedConfig.getClassLoader());\n    setEnvironmentMode(inheritedConfig.getEnvironmentMode());\n    // Add more settings here if needed\n    return this;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    }\n\n    @Override\n    public String marshal(Duration duration) {\n        if (duration == null) {\n            return null;\n        }\n        return duration.toString();\n    }\n}\n\n------------------------------\n------------------------------\n        } else if (originalList == null) {\n            // Shallow clone due to modifications after calling inherit\n            return new ArrayList<>(inheritedList);\n        } else {\n            // The inheritedList should be before the originalList\n            List<T> mergedList = new ArrayList<>(inheritedList);\n            mergedList.addAll(originalList);\n            return mergedList;\n        }\n    }\n\n    public static <T> List<T> inheritUniqueMergeableListProperty(List<T> originalList, List<T> inheritedList) {\n        if (inheritedList == null) {\n            return originalList;\n        } else if (originalList == null) {\n            // Shallow clone due to modifications after calling inherit\n            return new ArrayList<>(inheritedList);\n        } else {\n            // The inheritedMap should be before the originalMap\n            Set<T> mergedSet = new LinkedHashSet<>(inheritedList);\n\n------------------------------\n------------------------------\n\n    @Override\n    public String marshal(Locale locale) {\n        if (locale == null) {\n            return null;\n        }\n        return locale.toString();\n    }\n}\n\n------------------------------\n------------------------------\n            if (comparison != 0) {\n                return comparison;\n            }\n        }\n        return Integer.compare(aSize, bSize);\n    }\n\n}\n\n------------------------------\n------------------------------\n        return originalList;\n    }\n\n    public static <T> T inheritOverwritableProperty(T original, T inherited) {\n        if (original != null) {\n            // Original overwrites inherited\n            return original;\n        } else {\n            return inherited;\n        }\n    }\n\n    public static <T> List<T> inheritMergeableListProperty(List<T> originalList, List<T> inheritedList) {\n        if (inheritedList == null) {\n            return originalList;\n        } else if (originalList == null) {\n            // Shallow clone due to modifications after calling inherit\n            return new ArrayList<>(inheritedList);\n        } else {\n            // The inheritedList should be before the originalList\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T meldProperty(T a, T b) {\n# Natural Language Annotations: /**\n     * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n     * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n     * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n     * property of the benchmark that didn't fail.\n     * <p>\n     * Null-handling:\n     * <ul>\n     * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n     * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n     * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n     * {@link #mergeProperty(Object, Object)}</li>\n     * </ul>\n     *\n     * @see #mergeProperty(Object, Object)\n     * @param a property {@code a}\n     * @param b property {@code b}\n     * @param <T> the type of property {@code a} and {@code b}\n     * @return sometimes null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```\n", "```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```\n", "```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```\n"]}}