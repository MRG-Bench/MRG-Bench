{"litestar-litestar/file_system.py-info": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n        A dictionary of parsed path parameters.\n    \"\"\"\n    return {\n        param_definition.name: param_definition.parser(value) if param_definition.parser else value\n        for param_definition, value in zip(parameter_definitions, path_param_values)\n    }\n------------------------------\n------------------------------\nReturns:\n            A dictionary of file info.\n        \"\"\"\n        file_info: FileInfo = {\n            \"created\": result.st_ctime,\n            \"gid\": result.st_gid,\n            \"ino\": result.st_ino,\n            \"islink\": await Path(path).is_symlink(),\n            \"mode\": result.st_mode,\n            \"mtime\": result.st_mtime,\n            \"name\": str(path),\n            \"nlink\": result.st_nlink,\n            \"size\": result.st_size,\n------------------------------\n------------------------------\nReturns:\n            A dictionary of file info.\n        \"\"\"\n        try:\n            awaitable = (\n                self.file_system.info(str(path))\n                if is_async_callable(self.file_system.info)\n                else sync_to_thread(self.file_system.info, str(path))\n            )\n            return cast(\"FileInfo\", await awaitable)\n        except FileNotFoundError as e:\n            raise e\n        except PermissionError as e:\n------------------------------\n------------------------------\nArgs:\n            file: Path to the target file.\n            mode: Mode, similar to the built ``open``.\n            buffering: Buffer size.\n        \"\"\"\n        ...\n------------------------------\n------------------------------\nasync def info(self, path: PathType) -> FileInfo:\n        \"\"\"Proxies the call to the underlying FS Spec's ``info`` method, ensuring it's done in an async fashion and with\n        strong typing.\n\n        Args:\n            path: A file path to load the info for.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n# Natural Language Annotations: \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path))\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path))\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n        pass\n```", "```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path), **kwargs)\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path), **kwargs)\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n        raise e\n```", "```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path))\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path))\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n        pass\n```"]}, "litestar-litestar/typing.py-has_inner_subclass_of": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nWhere ``self.annotation`` is a union type, this method will return ``True`` when all members of the union are\n        a subtype of ``cl``, otherwise, ``False``.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n------------------------------\n------------------------------\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        True if the annotation is a subclass of :data:`Generic <typing.Generic>` otherwise ``False``.\n    \"\"\"\n    return is_class_and_subclass(annotation, Generic)  # type: ignore[arg-type]\n------------------------------\n------------------------------\ndef is_class_and_subclass(annotation: Any, type_or_type_tuple: type[T] | tuple[type[T], ...]) -> TypeGuard[type[T]]:\n    \"\"\"Return ``True`` if ``value`` is a ``class`` and is a subtype of ``t_type``.\n\n    See https://github.com/litestar-org/litestar/issues/367\n\n    Args:\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n------------------------------\n------------------------------\n@property\n    def type_(self) -> Any:\n        \"\"\"The type of the annotation with all the wrappers removed, including the generic types.\"\"\"\n\n        return self.origin or self.annotation\n\n    def is_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n        \"\"\"Whether the annotation is a subclass of the given type.\n------------------------------\n------------------------------\ndef is_attrs_class(annotation: Any) -> TypeGuard[type[attrs.AttrsInstance]]:  # pyright: ignore\n    \"\"\"Given a type annotation determine if the annotation is a class that includes an attrs attribute.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is an attrs class.\n    \"\"\"\n    return attrs.has(annotation) if attrs is not Empty else False  # type: ignore[comparison-overlap]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n# Natural Language Annotations: \"\"\"Whether any generic args are a subclass of the given type.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether any of the type's generic args are a subclass of the given type.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\"\"\"\n\n    if hasattr(self.annotation, '__origin__'):\n        origin = self.annotation.__origin__\n        if hasattr(origin, '__args__'):\n            args = origin.__args__\n            return any(issubclass(arg, cl) for arg in args if isinstance(arg, type))\n    return False\n```", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    if hasattr(self.annotation, '__origin__') and self.annotation.__origin__ is not None:\n        return any(issubclass(arg, cl) for arg in self.annotation.__args__)\n    return False\n```", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\"\"\"\n\n    if is_generic(self.type_):\n        origin_type = self.type_.__origin__\n        if isinstance(origin_type, type):\n            return issubclass(origin_type, cl)\n        elif isinstance(origin_type, tuple):\n            return any(issubclass(t, cl) for t in origin_type)\n    return False\n```"]}, "litestar-litestar/typing.py-get_type_hints": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        annotation: A type annotation.\n        globalns: The global namespace.\n        localns: The local namespace.\n        include_extras: A flag indicating whether to include the ``Annotated[T, ...]`` or not.\n        type_hints: Already resolved type hints\n    \"\"\"\n    origin = get_origin(annotation)\n------------------------------\n------------------------------\nArgs:\n            annotation: The type annotation. This should be extracted from the return of\n                ``get_type_hints(..., include_extras=True)`` so that forward references are resolved and recursive\n                ``Annotated`` types are flattened.\n            **kwargs: Additional keyword arguments to pass to the ``FieldDefinition`` constructor.\n\n        Returns:\n            FieldDefinition\n        \"\"\"\n------------------------------\n------------------------------\ndef get_type_hints_with_generics_resolved(\n    annotation: Any,\n    globalns: dict[str, Any] | None = None,\n    localns: dict[str, Any] | None = None,\n    include_extras: bool = False,\n    type_hints: dict[str, Any] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Get the type hints for the given object after resolving the generic types as much as possible.\n------------------------------\n------------------------------\ndef pydantic_get_unwrapped_annotation_and_type_hints(annotation: Any) -> tuple[Any, dict[str, Any]]:  # pragma:  pver\n    \"\"\"Get the unwrapped annotation and the type hints after resolving generics.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A tuple containing the unwrapped annotation and the type hints.\n    \"\"\"\n------------------------------\n------------------------------\ndef is_any(annotation: Any) -> TypeGuard[Any]:\n    \"\"\"Given a type annotation determine if the annotation is Any.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Any <typing.Any>`.\n    \"\"\"\n    return (\n        annotation is Any\n        or getattr(annotation, \"_name\", \"\") == \"typing.Any\"\n        or (get_origin_or_inner_type(annotation) in UnionTypes and Any in get_args(annotation))\n    )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the type hints for the annotation.\n\n        Args:\n            include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n            resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n        Returns:\n            The type hints.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    type_hints = {}\n    for name, annotation in vars(self.__class__).items():\n        if name.startswith('__') and name.endswith('__'):\n            continue\n        origin = get_origin(annotation)\n        if resolve_generics:\n            annotation, type_hints = pydantic_get_unwrapped_annotation_and_type_hints(annotation)\n        if include_extras and is_any(annotation):\n            type_hints[name] = annotation\n    return type_hints\n```", "```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    if resolve_generics:\n        type_hints = get_type_hints_with_generics_resolved(self.annotation, self.globalns, self.localns, include_extras)\n    else:\n        type_hints = get_type_hints(self.annotation, include_extras=True)\n    \n    if include_extras:\n        # Add logic to include ``Annotated[T, ...]``\n        pass\n    \n    return type_hints\n```", "```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    # Your code here\n```"]}, "litestar-litestar/typing.py-from_kwarg": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nThis is to serve safely rebuilding a generic outer type with different args at runtime.\n    \"\"\"\n    inner_types: tuple[FieldDefinition, ...]\n    \"\"\"The type's generic args parsed as ``FieldDefinition``, if applicable.\"\"\"\n    default: Any\n    \"\"\"Default value of the field.\"\"\"\n    extra: dict[str, Any]\n    \"\"\"A mapping of extra values.\"\"\"\n    kwarg_definition: KwargDefinition | DependencyKwarg | None\n    \"\"\"Kwarg Parameter.\"\"\"\n    name: str\n    \"\"\"Field name.\"\"\"\n------------------------------\n------------------------------\nparam_definitions.add(\n                create_parameter_definition(\n                    field_definition=FieldDefinition.from_kwarg(\n                        name=field.name,\n                        default=default,\n                        inner_types=field.inner_types,\n                        annotation=field.annotation,\n                        kwarg_definition=field.kwarg_definition,\n                        extra=field.extra,\n                    ),\n------------------------------\n------------------------------\nparam_definitions.add(\n                create_parameter_definition(\n                    field_definition=FieldDefinition.from_kwarg(\n                        name=field.name,\n                        default=default,\n                        inner_types=field.inner_types,\n                        annotation=field.annotation,\n                        kwarg_definition=field.kwarg_definition,\n                        extra=field.extra,\n                    ),\n------------------------------\n------------------------------\nfield_definition = FieldDefinition.from_kwarg(\n            inner_types=field.inner_types,\n            default=default,\n            extra=field.extra,\n            annotation=annotation,\n            kwarg_definition=field.kwarg_definition,\n            name=field_name,\n        )\n        return self.create_parameter(field_definition=field_definition, parameter_name=parameter_name)\n------------------------------\n------------------------------\ndef for_new_type(self, field_definition: FieldDefinition) -> Schema | Reference:\n        return self.for_field_definition(\n            FieldDefinition.from_kwarg(\n                annotation=unwrap_new_type(field_definition.annotation),\n                name=field_definition.name,\n                default=field_definition.default,\n            )\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_kwarg(\n# Natural Language Annotations: \"\"\"Create a new FieldDefinition instance.\n\n        Args:\n            annotation: The type of the kwarg.\n            name: Field name.\n            default: A default value.\n            inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n            kwarg_definition: Kwarg Parameter.\n            extra: A mapping of extra values.\n\n        Returns:\n            FieldDefinition instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any = None,\n    inner_types: Tuple[FieldDefinition, ...] = (),\n    kwarg_definition: Optional[Union[KwargDefinition, DependencyKwarg]] = None,\n    extra: Optional[Dict[str, Any]] = None,\n) -> FieldDefinition:\n    return FieldDefinition(annotation=annotation, name=name, default=default, inner_types=inner_types, kwarg_definition=kwarg_definition, extra=extra)\n```", "```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any = None,\n    inner_types: Optional[Tuple[FieldDefinition, ...]] = None,\n    kwarg_definition: Optional[Union[KwargDefinition, DependencyKwarg]] = None,\n    extra: Optional[Dict[str, Any]] = None,\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(annotation, name, default, inner_types, kwarg_definition, extra)\n```", "```python\ndef from_kwarg(\n        annotation: Any,\n        name: str,\n        default: Any = None,\n        inner_types: Tuple[FieldDefinition, ...] = (),\n        kwarg_definition: Optional[Union[KwargDefinition, DependencyKwarg]] = None,\n        extra: Optional[Dict[str, Any]] = None\n) -> FieldDefinition:\n    return FieldDefinition(\n        annotation=annotation,\n        name=name,\n        default=default,\n        inner_types=inner_types,\n        kwarg_definition=kwarg_definition,\n        extra=extra or {}\n    )\n```"]}, "litestar-litestar/typing.py-from_parameter": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n        parameters = tuple(\n            FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n            for name, parameter in signature.parameters.items()\n            if name not in (\"self\", \"cls\")\n        )\n------------------------------\n------------------------------\nparameters = [\n            inspect.Parameter(name=field_name, kind=inspect.Parameter.KEYWORD_ONLY, annotation=Any)\n            for field_name in model_fields\n        ]\n        type_hints = {field_name: Any for field_name in model_fields}\n        return Signature(parameters), type_hints\n------------------------------\n------------------------------\ndef get_fn_type_hints(fn: Any, namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Resolve type hints for ``fn``.\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n------------------------------\n------------------------------\nfn_type_hints={\n                **get_fn_type_hints(fn, namespace=self.resolve_signature_namespace()),\n                **get_fn_type_hints(ListenerHandler.__call__, namespace=self.resolve_signature_namespace()),\n            },\n        )\n------------------------------\n------------------------------\ndef get_typed_init(self, type_: Any) -> tuple[Signature, dict[str, Any]]:\n        parameters = []\n        type_hints = {}\n        for field_info in msgspec.structs.fields(type_):\n            type_hints[field_info.name] = field_info.type\n            parameters.append(\n                inspect.Parameter(\n                    name=field_info.name,\n                    kind=inspect.Parameter.KEYWORD_ONLY,\n                    annotation=field_info.type,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n# Natural Language Annotations: \"\"\"Initialize ParsedSignatureParameter.\n\n        Args:\n            parameter: inspect.Parameter\n            fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n                :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n        Returns:\n            ParsedSignatureParameter.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n    name = parameter.name\n    kind = parameter.kind\n    annotation = fn_type_hints.get(name, inspect.Parameter.empty)\n    default = parameter.default\n    return cls(name, kind, annotation, default)\n```", "```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n    return cls(\n        name=parameter.name,\n        kind=parameter.kind,\n        annotation=fn_type_hints.get(parameter.name, parameter.annotation),\n        default=parameter.default,\n    )\n```", "def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n    annotation = fn_type_hints.get(parameter.name, inspect._empty)  # type: ignore\n    return cls(\n        name=parameter.name,\n        kind=parameter.kind,\n        default=parameter.default,\n        annotation=annotation,\n    )"]}, "litestar-litestar/_openapi/responses.py-create_success_response": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef set_success_response_headers(self, response: OpenAPIResponse) -> None:\n        \"\"\"Set the schema for success response headers, if any.\"\"\"\n\n        if response.headers is None:\n            response.headers = {}\n\n        if not self.schema_creator.generate_examples:\n            schema_creator = self.schema_creator\n        else:\n            schema_creator = SchemaCreator.from_openapi_context(self.context, generate_examples=False)\n------------------------------\n------------------------------\ndef create_redirect_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a redirect response.\"\"\"\n        return OpenAPIResponse(\n            content=None,\n            description=self.create_description(),\n            headers={\n                \"location\": OpenAPIHeader(\n                    schema=Schema(type=OpenAPIType.STRING), description=\"target path for the redirect\"\n                )\n            },\n        )\n------------------------------\n------------------------------\ndef create_responses(self, raises_validation_error: bool) -> Responses | None:\n        \"\"\"Create the schema for responses, if any.\n\n        Args:\n            raises_validation_error: Boolean flag indicating whether the handler raises a ValidationException.\n\n        Returns:\n            Responses\n        \"\"\"\n        responses: Responses = {\n            str(self.route_handler.status_code): self.create_success_response(),\n        }\n------------------------------\n------------------------------\nReturns:\n        Responses\n    \"\"\"\n    return ResponseFactory(context, route_handler).create_responses(raises_validation_error=raises_validation_error)\n------------------------------\n------------------------------\nschema.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_success_response(self) -> OpenAPIResponse:\n# Natural Language Annotations: \"\"\"Create the schema for a success response.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    return OpenAPIResponse(\n        content=self.create_content(),\n        description=self.create_description(),\n        headers=self.create_headers(),\n    )\n```", "```python\ndef create_success_response(self) -> OpenAPIResponse:\n    return OpenAPIResponse(\n        content=self.create_content(),\n        description=self.create_description(),\n        headers=self.create_headers(),\n    )\n```", "```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    return OpenAPIResponse(\n        content=self.schema_creator.create_content(),\n        description=self.create_description(),\n        headers=self.create_headers()\n    )\n```"]}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nThese are schemas that can be referenced by other schemas in the document, including self references.\n\n        To support self referencing schemas, the schema is added to the registry before schemas for its properties\n        are created. This allows the schema to be referenced by its properties.\n------------------------------\n------------------------------\nclass ResponseSpec:\n    \"\"\"Container type of additional responses.\"\"\"\n------------------------------\n------------------------------\ndef create_template_context(self, request: Request) -> dict[str, Any]:\n        \"\"\"Create a context object for the template.\n\n        Args:\n            request: A :class:`Request <.connection.Request>` instance.\n------------------------------\n------------------------------\ndef create_schema_for_annotation(annotation: Any) -> Schema:\n    \"\"\"Get a schema from the type mapping - if possible.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A schema instance or None.\n    \"\"\"\n\n    return copy(TYPE_MAP[annotation]) if annotation in TYPE_MAP else Schema()\n------------------------------\n------------------------------\ndef create_redirect_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a redirect response.\"\"\"\n        return OpenAPIResponse(\n            content=None,\n            description=self.create_description(),\n            headers={\n                \"location\": OpenAPIHeader(\n                    schema=Schema(type=OpenAPIType.STRING), description=\"target path for the redirect\"\n                )\n            },\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n# Natural Language Annotations: \"\"\"Create the schema for additional responses, if any.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    return iter([])\n```", "```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses = []\n    # logic to generate additional responses goes here\n    # this could involve checking certain conditions or using a loop to generate responses\n    # for example:\n    # for response in self.additional_responses:\n    #     additional_responses.append((response.name, self.create_redirect_response()))\n    return additional_responses\n```", "```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    # Your code here\n    pass\n```"]}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef create_path_item_for_route(openapi_context: OpenAPIContext, route: HTTPRoute) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Args:\n        openapi_context: The OpenAPIContext instance.\n        route: The route to create a PathItem for.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item_factory = PathItemFactory(openapi_context, route)\n    return path_item_factory.create_path_item()\n------------------------------\n------------------------------\nclass PathItemFactory:\n    \"\"\"Factory for creating a PathItem instance for a given route.\"\"\"\n\n    def __init__(self, openapi_context: OpenAPIContext, route: HTTPRoute) -> None:\n        self.context = openapi_context\n        self.route = route\n        self._path_item = PathItem()\n------------------------------\n------------------------------\ndef create_operation_for_handler_method(\n        self, route_handler: HTTPRouteHandler, http_method: HttpMethod\n    ) -> Operation:\n        \"\"\"Create an Operation instance for a given route handler and http method.\n\n        Args:\n            route_handler: A route handler instance.\n            http_method: An HttpMethod enum value.\n------------------------------\n------------------------------\n# Code for: def merge_path_item_operations(source: PathItem, other: PathItem, for_path: str) -> PathItem:\n------------------------------\n------------------------------\nReturns:\n            An Operation instance.\n        \"\"\"\n        operation_id = self.create_operation_id(route_handler, http_method)\n        parameters = create_parameters_for_handler(self.context, route_handler, self.route.path_parameters)\n        signature_fields = route_handler.parsed_fn_signature.parameters\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_path_item(self) -> PathItem:\n# Natural Language Annotations: \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n        Returns:\n            A PathItem instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    http_methods = [method for method in HttpMethod]\n    for http_method in http_methods:\n        operation = self.create_operation_for_handler_method(self.route.handler, http_method)\n        self._path_item.add_operation(http_method.value, operation)\n    return self._path_item\n```", "```python\ndef create_path_item(self) -> PathItem:\n    path_item = PathItem()\n    path_item_factory = PathItemFactory(self.context, self.route)\n    for http_method in HTTPMethod:\n        operation = self.create_operation_for_handler_method(self.route.handler, http_method)\n        path_item.set_operation(http_method, operation)\n    return path_item\n```", "```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem()\n    for http_method in HttpMethod:\n        if http_method in self.route.http_methods:\n            operation = self.create_operation_for_handler_method(self.route.http_methods[http_method], http_method)\n            path_item.operations[http_method] = operation\n    return path_item\n```"]}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn Schema(one_of=[Schema(type=OpenAPIType.NULL), *result])\n\n    def for_union_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for a union FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\ndef for_collection_constrained_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create Schema from Constrained List/Set field.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\ndef for_constrained_field(self, field: FieldDefinition) -> Schema:\n        \"\"\"Create Schema for Pydantic Constrained fields (created using constr(), conint() and so forth, or by subclassing\n        Constrained*)\n\n        Args:\n            field: A signature field instance.\n------------------------------\n------------------------------\ndef for_plugin(self, field_definition: FieldDefinition, plugin: OpenAPISchemaPluginProtocol) -> Schema | Reference:\n        \"\"\"Create a schema using a plugin.\n\n        Args:\n            field_definition: A signature field instance.\n            plugin: A plugin for the field type.\n------------------------------\n------------------------------\nArgs:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n# Natural Language Annotations: \"\"\"Create a Schema for a given FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if isinstance(field_definition, ConstrainedField):\n        return self.for_constrained_field(field_definition)\n    elif isinstance(field_definition, UnionField):\n        return self.for_union_field(field_definition)\n    elif isinstance(field_definition, CollectionConstrainedField):\n        return self.for_collection_constrained_field(field_definition)\n    else:\n        return self.for_plugin(field_definition, plugin)\n```", "```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if field_definition.is_nullable():\n        return Schema(one_of=[Schema(type=OpenAPIType.NULL)])\n    elif field_definition.is_union():\n        result = []\n        for sub_field in field_definition.get_sub_fields():\n            result.append(self.for_field_definition(sub_field))\n        return Schema(one_of=[Schema(type=OpenAPIType.NULL), *result])\n    elif field_definition.is_collection():\n        return self.for_collection_constrained_field(field_definition)\n    elif field_definition.is_constrained():\n        return self.for_constrained_field(field_definition)\n    elif field_definition.has_plugin():\n        plugin = field_definition.get_plugin()\n        return self.for_plugin(field_definition, plugin)\n    else:\n        raise ValueError(f\"Unsupported field type: {field_definition.type}\")\n```", "```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if isinstance(field_definition, ConstrainedField):\n        return self.for_constrained_field(field_definition)\n    elif isinstance(field_definition, CollectionConstrainedField):\n        return self.for_collection_constrained_field(field_definition)\n    elif isinstance(field_definition, UnionField):\n        return Schema(one_of=[Schema(type=OpenAPIType.NULL), *result])\n    elif isinstance(field_definition, PluginField):\n        return self.for_plugin(field_definition, field_definition.plugin)\n    else:\n        raise ValueError(f\"Unsupported field type: {type(field_definition)}\")\n```"]}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef parse_schema(schema: Schema) -> TypeScriptElement:\n    \"\"\"Parse an OpenAPI schema object recursively to create typescript types.\n\n    Args:\n        schema: An OpenAPI Schema object.\n------------------------------\n------------------------------\ndef parse_type_schema(schema: Schema) -> TypeScriptPrimitive | TypeScriptLiteral | TypeScriptUnion:\n    \"\"\"Parse an OpenAPI schema representing a primitive type(s).\n\n    Args:\n        schema: An OpenAPI schema.\n------------------------------\n------------------------------\nReturns:\n        A typescript type.\n    \"\"\"\n    if schema.all_of:\n        return TypeScriptIntersection(tuple(parse_schema(s) for s in schema.all_of if is_schema_value(s)))\n    if schema.one_of:\n        return TypeScriptUnion(tuple(parse_schema(s) for s in schema.one_of if is_schema_value(s)))\n    if is_schema_value(schema.items):\n        return TypeScriptArray(parse_schema(schema.items))\n    if schema.type == OpenAPIType.OBJECT:\n        return create_interface(\n------------------------------\n------------------------------\nReturns:\n        A tuple of namespaces, mapping response codes to data.\n    \"\"\"\n    result: list[TypeScriptNamespace] = []\n    for http_status, response in [\n        (status, get_openapi_type(res, components=components)) for status, res in responses.items()\n    ]:\n        if response.content and (\n            content := [get_openapi_type(v.schema, components) for v in response.content.values() if v.schema]\n        ):\n            ts_type = parse_schema(content[0])\n        else:\n------------------------------\n------------------------------\ndef to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        if field_definition.origin is ClassicPagination:\n            return Schema(\n                type=OpenAPIType.OBJECT,\n                properties={\n                    \"items\": Schema(\n                        type=OpenAPIType.ARRAY,\n                        items=schema_creator.for_field_definition(field_definition.inner_types[0]),\n                    ),\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n# Natural Language Annotations: \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    result: list[TypeScriptNamespace] = []\n    for path, path_item in openapi_schema.paths.items():\n        for http_method, operation in path_item.operations.items():\n            responses = operation.responses\n            for http_status, response in responses.items():\n                if response.content and (\n                    content := [get_openapi_type(v.schema, openapi_schema.components) for v in response.content.values() if v.schema]\n                ):\n                    ts_type = parse_schema(content[0])\n                    if isinstance(ts_type, (TypeScriptUnion, TypeScriptPrimitive, TypeScriptLiteral)):\n                        result.append(create_interface(namespace, http_method.upper() + http_status, ts_type))\n    return TypeScriptNamespace(namespace, tuple(result))\n```", "```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    result: list[TypeScriptNamespace] = []\n    for path, path_item in openapi_schema.paths.items():\n        for http_method, operation in path_item.operations.items():\n            if operation.request_body:\n                request_body_type = parse_schema(operation.request_body.schema)\n                result.append(create_interface(namespace, f\"{http_method.upper()}{path_to_interface_name(path)}Request\", request_body_type))\n            if operation.responses:\n                for http_status, response in operation.responses.items():\n                    if response.content and (\n                        content := [get_openapi_type(v.schema, components) for v in response.content.values() if v.schema]\n                    ):\n                        ts_type = parse_schema(content[0])\n                        result.append(create_interface(namespace, f\"{http_method.upper()}{path_to_interface_name(path)}{http_status}Response\", ts_type))\n    return \"\\n\".join(str(r) for r in result)\n```", "```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    result: list[TypeScriptNamespace] = []\n    for path, operations in openapi_schema.paths.items():\n        for method, operation in operations.items():\n            if operation.requestBody:\n                request_body = operation.requestBody\n                request_body_schema = get_openapi_type(request_body.content[\"application/json\"].schema, openapi_schema.components)\n                request_body_type = parse_schema(request_body_schema)\n                result.append(TypeScriptNamespace(\n                    name=f\"{namespace}{path.replace('/', '').capitalize()}{method.capitalize()}RequestBody\",\n                    elements=[request_body_type]\n                ))\n            for response_code, response in operation.responses.items():\n                if response.content:\n                    response_body_schema = get_openapi_type(response.content[\"application/json\"].schema, openapi_schema.components)\n                    response_body_type = parse_schema(response_body_schema)\n                    result.append(TypeScriptNamespace(\n                        name=f\"{namespace}{path.replace('/', '').capitalize()}{method.capitalize()}{response_code}ResponseBody\",\n                        elements=[response_body_type]\n                    ))\n    return \"\\n\".join(str(ts_namespace) for ts_namespace in result)\n```"]}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass TypeScriptInterface(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript interface.\"\"\"\n\n    name: str\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface.\n\n        Example:\n            export interface MyInterface {\n                key: string;\n                optional?: number;\n            };\n------------------------------\n------------------------------\nReturns:\n        A typescript interface or anonymous interface.\n    \"\"\"\n    parsed_properties = tuple(\n        TypeScriptProperty(\n            key=normalize_typescript_namespace(key, allow_quoted=True),\n            value=parse_schema(schema),\n            required=key in required if required is not None else True,\n        )\n        for key, schema in properties.items()\n    )\n    return (\n        TypeScriptInterface(name=name, properties=parsed_properties)\n        if name is not None\n------------------------------\n------------------------------\ndef create_interface(\n    properties: dict[str, Schema], required: set[str] | None = None, name: str | None = None\n) -> TypeScriptAnonymousInterface | TypeScriptInterface:\n    \"\"\"Create a typescript interface from the given schema.properties values.\n\n    Args:\n        properties: schema.properties mapping.\n        required: An optional list of required properties.\n        name: An optional string representing the interface name.\n------------------------------\n------------------------------\nclass TypeScriptProperty(TypeScriptElement):\n    \"\"\"A class representing a TypeScript interface property.\"\"\"\n\n    required: bool\n    key: str\n    value: TypeScriptElement\n\n    def write(self) -> str:\n        \"\"\"Write a typescript property. This class is used exclusively inside interfaces.\n\n        Example:\n            key: string;\n            optional?: number;\n------------------------------\n------------------------------\nReturns:\n            A typescript string\n        \"\"\"\n        interface = TypeScriptAnonymousInterface(properties=self.properties)\n        return f\"export interface {self.name} {interface.write()};\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def write(self) -> str:\n# Natural Language Annotations: \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef write(self) -> str:\n    \"\"\"Write a typescript interface object, without a name.\"\"\"\n\n    Example:\n        {\n            key: string;\n            optional?: number;\n        }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    properties_string = \", \".join(prop.write() for prop in self.properties)\n    return f\"{properties_string}\"\n```", "```python\nclass TypeScriptAnonymousInterface(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript anonymous interface.\"\"\"\n\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\n        return (\n            \"{\"\n            + \", \".join(prop.write() for prop in self.properties)\n            + \"}\"\n        )\n```", "```python\ndef write(self) -> str:\n    \"\"\"Write a typescript interface object, without a name.\"\"\"\n    \n    properties_str = \",\\n\".join(prop.write() for prop in self.properties)\n    return f\"\"\"{{\n{properties_str}\n}}\"\"\"\n```"]}, "litestar-litestar/testing/helpers.py-create_test_client": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n:class:`AsyncTestClient <litestar.testing.AsyncTestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_async_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n------------------------------\n------------------------------\n@get(\"/\")\n                def my_handler(request: Request) -> None: ...\n\n\n                app = Litestar(route_handlers=[my_handler], middleware=[session_auth_config.middleware])\n\n\n        Returns:\n            An instance of DefineMiddleware including ``self`` as the config kwarg value.\n        \"\"\"\n        return DefineMiddleware(MiddlewareWrapper, config=self)\n\n    @property\n    def session_backend(self) -> BaseSessionBackendT:\n        \"\"\"Create a session backend.\n------------------------------\n------------------------------\nan instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n------------------------------\n------------------------------\ndef create_response_handler(\n    after_request: AfterRequestHookHandler | None,\n    background: BackgroundTask | BackgroundTasks | None,\n    cookies: frozenset[Cookie],\n    headers: frozenset[ResponseHeader],\n    media_type: str,\n    status_code: int,\n    type_encoders: TypeEncodersMap | None,\n) -> AsyncAnyCallable:\n    \"\"\"Create a handler function for Litestar Responses.\n------------------------------\n------------------------------\n# We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Litestar(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[jwt_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_test_client(\n# Natural Language Annotations: \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        route_handlers: A sequence of route handlers, which can include instances of\n            :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_test_client(\n    route_handlers: Any,\n    backend: str | None = None,\n    backend_options: Dict[str, Any] | None = None,\n    base_url: str | None = None,\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AfterResponseHookHandler | None = None,\n    allowed_hosts: AllowedHostsConfig | Iterable[str] | None = None,\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: DependencyRegistry | None = None,\n    dto: AbstractDTO | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: Type[BaseEventEmitterBackend] = EventEmitterBackend,\n    exception_handlers: ExceptionHandlers | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[LifespanHook] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: BaseLoggingConfig | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = DEFAULT_FORM_PART_LIMIT,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,\n    opt: Opt | None = None,\n    parameters: Parameters | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[PluginProtocol] | None = None,\n    request_class: Type[Request] = Request,\n    response_class: Type[Response] = Response,\n    response_cookies: Sequence[Cookie] | None = None,\n    response_headers: Mapping[str, str] | None = None,\n    response_cache_config: ResponseCacheConfig | None = None,\n    return_dto: AbstractDTO | None = None,\n    security: Sequence[SecurityRequirement] | None = None,\n    signature_namespace: Mapping[str, Type[Any]] | None = None,\n    signature_types: Iterable[Type[Any]] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: StoreRegistry | Mapping[str, Store] | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: int | float | None = None,\n    type_encoders: TypeEncodersMap | None = None,\n    websocket_class: Type[WebSocket] = WebSocket,\n    experimental_features: Iterable[str] | None = None,\n):\n    app = Litestar(\n        route_handlers=route_handlers,\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_send,\n        cache_control=cache_control,\n        compression_config=compression_config,\n        cors_config=cors_config,\n        csrf_config=csrf_config,\n        debug=debug,\n        dependencies=dependencies,\n        dto=dto,\n        etag=etag,\n        event_emitter_backend=event_emitter_backend,\n        exception_handlers=exception_handlers,\n        guards=guards,\n        include_in_schema=include_in_schema,\n        lifespan=lifespan,\n        listeners=listeners,\n        logging_config=logging_config,\n        middleware=middleware,\n        multipart_form_part_limit=multipart_form_part_limit,\n        on_app_init=on_app_init,\n        on_shutdown=on_shutdown,\n        on_startup=on_startup,\n        openapi_config=openapi_config,\n        opt=opt,\n        parameters=parameters,\n        path=path,\n        pdb_on_exception=pdb_on_exception,\n        plugins=plugins,\n        request_class=request_class,\n        response_class=response_class,\n        response_cookies=response_cookies,\n        response_headers=response_headers,\n        response_cache_config=response_cache_config,\n        return_dto=return_dto,\n        security=security,\n        signature_namespace=signature_namespace,\n        signature_types=signature_types,\n        state=state,\n        static_files_config=static_files_config,\n        stores=stores,\n        tags=tags,\n        template_config=template_config,\n        timeout=timeout,\n        type_encoders=type_encoders,\n        websocket_class=websocket_class,\n        experimental_features=experimental_features,\n    )\n    return TestClient(app)\n```", "```python\ndef create_test_client(\n    route_handlers: Sequence[Any] = (),\n    backend: str | None = None,\n    backend_options: dict[str, Any] | None = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AsyncAfterResponseHookHandler | SyncAfterResponseHookHandler | None = None,\n    allowed_hosts: AllowedHostsConfig | Sequence[str] | None = None,\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: Dependencies | None = None,\n    dto: AbstractDTO | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: Type[BaseEventEmitterBackend] = DefaultEventEmitterBackend,\n    exception_handlers: ExceptionHandlers | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[LifespanHook] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: Type[BaseLoggingConfig] = DEFAULT_LOGGING_CONFIG,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = DEFAULT_MULTIPART_FORM_PART_LIMIT,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,\n    opt: Opt | None = None,\n    parameters: Parameters | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[PluginProtocol] | None = None,\n    request_class: Type[Request] = Request,\n    response_class: Type[Response] = Response,\n    response_cookies: Sequence[Cookie] = (),\n    response_headers: ResponseHeaders | None = None,\n    response_cache_config: ResponseCacheConfig | None = None,\n    return_dto: AbstractDTO | None = None,\n    route_handlers: Sequence[Any] = (),\n    security: Sequence[SecurityRequirement] | None = None,\n    signature_namespace: dict[str, Any] | None = None,\n    signature_types: Sequence[Any] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: StoreRegistry | MutableMapping[str, Store] | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: float = DEFAULT_TIMEOUT,\n    type_encoders: TypeEncodersMap | None = None,\n    websocket_class: Type[WebSocket] = WebSocket,\n    experimental_features: set[str] | None = None,\n) -> TestClient:\n    app = Litestar(\n        route_handlers=route_handlers,\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_send,\n        cache_control=cache_control,\n        compression_config=compression_config,\n        cors_config=cors_config,\n        csrf_config=csrf_config,\n        debug=debug,\n        dependencies=dependencies,\n        dto=dto,\n        etag=etag,\n        event_emitter_backend=event_emitter_backend,\n        exception_handlers=exception_handlers,\n        guards=guards,\n        include_in_schema=include_in_schema,\n        lifespan=lifespan,\n        listeners=listeners,\n        logging_config=logging_config,\n        middleware=middleware,\n        multipart_form_part_limit=multipart_form_part_limit,\n        on_app_init=on_app_init,\n        on_shutdown=on_shutdown,\n        on_startup=on_startup,\n        openapi_config=openapi_config,\n        opt=opt,\n        parameters=parameters,\n        path=path,\n        pdb_on_exception=pdb_on_exception,\n        plugins=plugins,\n        request_class=request_class,\n        response_class=response_class,\n        response_cookies=response_cookies,\n        response_headers=response_headers,\n        response_cache_config=response_cache_config,\n        return_dto=return_dto,\n        security=security,\n        signature_namespace=signature_namespace,\n        signature_types=signature_types,\n        state=state,\n        static_files_config=static_files_config,\n        stores=stores,\n        tags=tags,\n        template_config=template_config,\n        timeout=timeout,\n        type_encoders=type_encoders,\n        websocket_class=websocket_class,\n        experimental_features=experimental_features,\n    )\n    return TestClient(app)\n```", "```python\ndef create_test_client(\n    route_handlers: Any,\n    backend: str = \"asyncio\",\n    backend_options: dict = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AfterResponseHookHandler | None = None,\n    allowed_hosts: AllowedHostsConfig | Sequence[str] | None = None,\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: dict[str, Provide] | None = None,\n    dto: AbstractDTO | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: Type[BaseEventEmitterBackend] | None = None,\n    exception_handlers: dict[int | Type[Exception], ExceptionHandler] | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[LifespanHook] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: BaseLoggingConfig | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = DEFAULT_PART_LIMIT,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig | None = None,\n    opt: dict[str, Any] | None = None,\n    parameters: dict[str, ParameterDefinition] | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[PluginProtocol] | None = None,\n    request_class: Type[Request] | None = None,\n    response_class: Type[Response] | None = None,\n    response_cookies: Sequence[Cookie] | None = None,\n    response_headers: dict[str, ResponseHeader] | None = None,\n    response_cache_config: ResponseCacheConfig | None = None,\n    return_dto: AbstractDTO | None = None,\n    security: Sequence[SecurityRequirement] | None = None,\n    signature_namespace: dict[str, Any] | None = None,\n    signature_types: Sequence[Any] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: StoreRegistry | dict[str, Store] | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: float = DEFAULT_TIMEOUT,\n    type_encoders: TypeEncodersMap | None = None,\n    websocket_class: Type[WebSocket] | None = None,\n    experimental_features: Sequence[str] | None = None,\n):\n    app = Litestar(\n        route_handlers=route_handlers,\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_send,\n        cache_control=cache_control,\n        compression_config=compression_config,\n        cors_config=cors_config,\n        csrf_config=csrf_config,\n        debug=debug,\n        dependencies=dependencies,\n        dto=dto,\n        etag=etag,\n        event_emitter_backend=event_emitter_backend,\n        exception_handlers=exception_handlers,\n        guards=guards,\n        include_in_schema=include_in_schema,\n        lifespan=lifespan,\n        listeners=listeners,\n        logging_config=logging_config,\n        middleware=middleware,\n        multipart_form_part_limit=multipart_form_part_limit,\n        on_app_init=on_app_init,\n        on_shutdown=on_shutdown,\n        on_startup=on_startup,\n        openapi_config=openapi_config,\n        opt=opt,\n        parameters=parameters,\n        path=path,\n        pdb_on_exception=pdb_on_exception,\n        plugins=plugins,\n        request_class=request_class,\n        response_class=response_class,\n        response_cookies=response_cookies,\n        response_headers=response_headers,\n        response_cache_config=response_cache_config,\n        return_dto=return_dto,\n        security=security,\n        signature_namespace=signature_namespace,\n        signature_types=signature_types,\n        state=state,\n        static_files_config=static_files_config,\n        stores=stores,\n        tags=tags,\n        template_config=template_config,\n        timeout=timeout,\n        type_encoders=type_encoders,\n        websocket_class=websocket_class,\n        experimental_features=experimental_features,\n    )\n    return TestClient(app)\n```"]}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n------------------------------\n------------------------------\nReturns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\n        try:\n            await self.send(\n                self._prepare_ws_connect_request(\n                    url=url,\n                    subprotocols=subprotocols,\n                    params=params,\n                    headers=headers,\n                    cookies=cookies,\n                    extensions=extensions,\n                    timeout=timeout,\n                ),\n------------------------------\n------------------------------\nasync def websocket_connect(\n        self,\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n------------------------------\n------------------------------\nclass WebSocket(Generic[UserT, AuthT, StateT], ASGIConnection[\"WebsocketRouteHandler\", UserT, AuthT, StateT]):\n    \"\"\"The Litestar WebSocket class.\"\"\"\n\n    __slots__ = (\"connection_state\",)\n\n    scope: WebSocketScope  # pyright: ignore\n    \"\"\"The ASGI scope attached to the connection.\"\"\"\n    receive: Receive\n    \"\"\"The ASGI receive function.\"\"\"\n    send: Send\n    \"\"\"The ASGI send function.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            app: The instance of :class:`Litestar <litestar.app.Litestar>` under test.\n            base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n            raise_server_exceptions: Flag for the underlying test client to raise server exceptions instead of\n                wrapping them in an HTTP response.\n            root_path: Path prefix for requests.\n            backend: The async backend to use, options are \"asyncio\" or \"trio\".\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def websocket_connect(\n# Natural Language Annotations: \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef websocket_connect(\n        self,\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n):\n    try:\n        return self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            )\n```", "```python\nasync def websocket_connect(\n        self,\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: dict[str, Any] | None = None,\n) -> WebSocketTestSession:\n    try:\n        await self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            )\n        )\n```", "```python\ndef websocket_connect(\n        self,\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: dict | None = None,\n):\n    try:\n        await self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            ),\n    except Exception as e:\n        raise e\n```"]}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n            field_definition: An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n            schema_creator: An instance of the openapi SchemaCreator.\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n        raise NotImplementedError()\n------------------------------\n------------------------------\n@staticmethod\n    def is_constrained_field(field_definition: FieldDefinition) -> bool:\n        return is_pydantic_constrained_field(field_definition.annotation)\n\n    def to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        \"\"\"Given a type annotation, transform it into an OpenAPI schema class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n------------------------------\n------------------------------\ndef for_constrained_field(self, field: FieldDefinition) -> Schema:\n        \"\"\"Create Schema for Pydantic Constrained fields (created using constr(), conint() and so forth, or by subclassing\n        Constrained*)\n\n        Args:\n            field: A signature field instance.\n------------------------------\n------------------------------\ndef to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        if field_definition.origin is ClassicPagination:\n            return Schema(\n                type=OpenAPIType.OBJECT,\n                properties={\n                    \"items\": Schema(\n                        type=OpenAPIType.ARRAY,\n                        items=schema_creator.for_field_definition(field_definition.inner_types[0]),\n                    ),\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n# Natural Language Annotations: \"\"\"Create a schema object for a given pydantic model class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    properties = {}\n    required = []\n    for field in cls.__fields__.values():\n        if field.required:\n            required.append(field.alias)\n        properties[field.alias] = schema_creator.for_field_definition(field)\n    return Schema(type=OpenAPIType.OBJECT, properties=properties, required=required)\n```", "```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    properties = {}\n    required = []\n\n    for field in cls.__fields__.values():\n        if self.is_constrained_field(field):\n            properties[field.alias] = self.for_constrained_field(field)\n        else:\n            properties[field.alias] = schema_creator.for_field_definition(field)\n\n        if field.required:\n            required.append(field.alias)\n\n    return Schema(\n        type=OpenAPIType.OBJECT,\n        properties=properties,\n        required=required if required else None\n    )\n```", "```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    properties = {}\n    required = []\n\n    for field in cls.__fields__.values():\n        if self.is_constrained_field(field):\n            properties[field.name] = self.for_constrained_field(field)\n            if field.required:\n                required.append(field.name)\n        else:\n            properties[field.name] = schema_creator.for_field_definition(field.annotation)\n            if field.required:\n                required.append(field.name)\n\n    return Schema(\n        type=OpenAPIType.OBJECT,\n        properties=properties,\n        required=required,\n    )\n```"]}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n__slots__ = (\"_generators\", \"_closed\")\n\n    def __init__(self, generators: list[AnyGenerator] | None = None) -> None:\n        \"\"\"Initialize ``DependencyCleanupGroup``.\n\n        Args:\n            generators: An optional list of generators to be called at cleanup\n        \"\"\"\n        self._generators = generators or []\n        self._closed = False\n\n    def add(self, generator: Generator[Any, None, None] | AsyncGenerator[Any, None]) -> None:\n        \"\"\"Add a new generator to the group.\n------------------------------\n------------------------------\nSimplify cleanup by wrapping :func:`next` / :func:`anext` calls and providing facilities to\n    :meth:`throw <generator.throw>` / :meth:`athrow <agen.athrow>` into all generators consecutively. An instance of\n    this class can be used as a contextmanager, which will automatically throw any exceptions into its generators. All\n    exceptions caught in this manner will be re-raised after they have been thrown in the generators.\n    \"\"\"\n\n    __slots__ = (\"_generators\", \"_closed\")\n------------------------------\n------------------------------\nArgs:\n            generator: The generator to add\n\n        Returns:\n            None\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Cannot call cleanup on a closed DependencyCleanupGroup\")\n        self._generators.append(generator)\n\n    @staticmethod\n    def _wrap_next(generator: AnyGenerator) -> Callable[[], Awaitable[None]]:\n        if isasyncgen(generator):\n\n            async def wrapped_async() -> None:\n                await async_next(generator, None)\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nfrom inspect import Traceback, isasyncgen\nfrom typing import TYPE_CHECKING, Any, AsyncGenerator, Awaitable, Callable, Generator\n\nfrom anyio import create_task_group\n\nfrom litestar.utils import ensure_async_callable\nfrom litestar.utils.compat import async_next\n\n__all__ = (\"DependencyCleanupGroup\",)\n\n\nif TYPE_CHECKING:\n    from litestar.types import AnyGenerator\n\n\n# Code for: class DependencyCleanupGroup:\n------------------------------\n------------------------------\nclass DependencyCleanupGroup:\n    \"\"\"Wrapper for generator based dependencies.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def cleanup(self) -> None:\n# Natural Language Annotations: \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n        If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    self._closed = True\n    if not self._generators:\n        return\n\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            task_group.start_soon(self._wrap_next(generator))\n```", "```python\nasync def cleanup(self) -> None:\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            task_group.start_soon(self._wrap_next(generator))\n```", "```python\nasync def cleanup(self) -> None:\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            task_group.start_soon(ensure_async_callable(self._wrap_next(generator)))\n```"]}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            app: An ASGIApp, this value is the next ASGI handler to call in the middleware stack.\n            config: An instance of SessionAuth.\n        \"\"\"\n        self.app = app\n        self.config = config\n        self.has_wrapped_middleware = False\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"Handle creating a middleware stack and calling it.\n------------------------------\n------------------------------\napp = Litestar(\n                    route_handlers=[my_handler],\n                    logging_config=logging_config,\n                    middleware=[logging_middleware_config.middleware],\n                )\n\n        Returns:\n            An instance of DefineMiddleware including ``self`` as the config kwarg value.\n        \"\"\"\n        return DefineMiddleware(self.middleware_class, config=self)\n------------------------------\n------------------------------\napp = Litestar(route_handlers=[my_handler], middleware=[throttle_config.middleware])\n\n        Returns:\n            An instance of :class:`DefineMiddleware <.middleware.base.DefineMiddleware>` including ``self`` as the\n            config kwarg value.\n        \"\"\"\n        return DefineMiddleware(self.middleware_class, config=self)\n------------------------------\n------------------------------\nArgs:\n        app: The Litestar app instance.\n        mount_routes: A dictionary mapping static routes to trie nodes.\n        plain_routes: A set of routes that do not have path parameters.\n        root_node: The root trie node.\n        route: The route that is being added.\n\n    Returns:\n        A RouteTrieNode instance.\n    \"\"\"\n    current_node = root_node\n\n    has_path_parameters = bool(route.path_parameters)\n------------------------------\n------------------------------\ndef __call__(self, app: ASGIApp) -> ASGIApp:\n        \"\"\"Call the middleware constructor or factory.\n\n        Args:\n            app: An ASGIApp, this value is the next ASGI handler to call in the middleware stack.\n\n        Returns:\n            Calls :class:`DefineMiddleware.middleware <.DefineMiddleware>` and returns the ASGIApp created.\n        \"\"\"\n\n        return self.middleware(*self.args, app=app, **self.kwargs)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_route_middleware_stack(\n# Natural Language Annotations: \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef build_route_middleware_stack(app, route, route_handler):\n    if route.handler == route_handler:\n        middleware_stack = app.middleware_stack.copy()\n        for middleware in route.middleware:\n            middleware_stack.append(middleware)\n        return middleware_stack\n    else:\n        return []\n```", "```python\ndef build_route_middleware_stack(app: Litestar, route: Route, route_handler: Callable) -> ASGIApp:\n    middleware_stack = []\n    for middleware in app.middleware:\n        middleware_stack.append(middleware)\n    middleware_stack.append(route_handler)\n\n    asgi_app = app.app\n    for middleware in reversed(middleware_stack):\n        asgi_app = middleware(asgi_app)\n\n    return asgi_app\n```", "```python\ndef build_route_middleware_stack(app: Litestar, route: Route, route_handler: RouteHandlerType) -> ASGIApp:\n    middleware_stack = [DefineMiddleware(config.middleware, config=config) for config in route.middleware]\n    handler_stack = app.get_route_handler_layer().handler_method_stack(route_handler)\n    return ASGIApp(*middleware_stack, *handler_stack)\n```"]}, "litestar-litestar/utils/signature.py-from_fn": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n        parameters = tuple(\n            FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n            for name, parameter in signature.parameters.items()\n            if name not in (\"self\", \"cls\")\n        )\n------------------------------\n------------------------------\ndef __call__(self, fn: AnyCallable) -> Self:\n        parsed_signature = ParsedSignature.from_fn(fn, self.resolve_signature_namespace())\n\n        if \"data\" not in parsed_signature.parameters:\n            raise ImproperlyConfiguredException(\"Websocket listeners must accept a 'data' parameter\")\n------------------------------\n------------------------------\ndef get_fn_type_hints(fn: Any, namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Resolve type hints for ``fn``.\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n------------------------------\n------------------------------\nparameters: dict[str, FieldDefinition]\n    \"\"\"A mapping of parameter names to ParsedSignatureParameter instances.\"\"\"\n    return_type: FieldDefinition\n    \"\"\"The return annotation of the callable.\"\"\"\n    original_signature: Signature\n    \"\"\"The raw signature as returned by :func:`inspect.signature`\"\"\"\n------------------------------\n------------------------------\nprovider.parsed_fn_signature = ParsedSignature.from_signature(signature, init_type_hints)\n            else:\n                provider.parsed_fn_signature = ParsedSignature.from_fn(dependency, self.resolve_signature_namespace())\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n# Natural Language Annotations: \"\"\"Parse a function signature.\n\n        Args:\n            fn: Any callable.\n            signature_namespace: mapping of names to types for forward reference resolution\n\n        Returns:\n            ParsedSignature\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    signature = inspect.signature(fn)\n    init_type_hints = cls.get_fn_type_hints(fn, signature_namespace)\n\n    parameters = tuple(\n        FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=init_type_hints)\n        for name, parameter in signature.parameters.items()\n        if name not in (\"self\", \"cls\")\n    )\n\n    return_type = FieldDefinition.from_type_hint(signature.return_annotation, init_type_hints)\n\n    return cls(parameters=parameters, return_type=return_type, original_signature=signature)\n```", "```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    signature = inspect.signature(fn, *signature_namespace)\n    init_type_hints = get_fn_type_hints(fn, signature_namespace)\n    return ParsedSignature.from_signature(signature, init_type_hints)\n```", "```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    signature = inspect.signature(fn)\n    fn_type_hints = get_fn_type_hints(fn, signature_namespace)\n\n    parameters = tuple(\n        FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n        for name, parameter in signature.parameters.items()\n        if name not in (\"self\", \"cls\")\n    )\n\n    return_type = FieldDefinition.from_type_hint(signature.return_annotation, fn_type_hints)\n\n    return cls(parameters=parameters, return_type=return_type, original_signature=signature)\n```"]}, "litestar-litestar/utils/deprecation.py-deprecated": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        version: Litestar version where the deprecation will occur\n        deprecated_name: Name of the deprecated function\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated thing\n    \"\"\"\n    parts = []\n------------------------------\n------------------------------\ndef warn_deprecation(\n    version: str,\n    deprecated_name: str,\n    kind: DeprecatedKind,\n    *,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n) -> None:\n    \"\"\"Warn about a call to a (soon to be) deprecated function.\n------------------------------\n------------------------------\nparts.extend(\n        (\n            f\"Deprecated in litestar {version}\",\n            f\"This {kind} will be removed in {removal_in or 'the next major version'}\",\n        )\n    )\n    if alternative:\n        parts.append(f\"Use {alternative!r} instead\")\n\n    if info:\n        parts.append(info)\n\n    text = \". \".join(parts)\n    warning_class = PendingDeprecationWarning if pending else DeprecationWarning\n\n    warn(text, warning_class, stacklevel=2)\n------------------------------\n------------------------------\nfrom typing import Any\n\nfrom litestar.utils.deprecation import deprecated, warn_deprecation\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nimport inspect\nfrom functools import wraps\nfrom typing import Callable, Literal, TypeVar\nfrom warnings import warn\n\nfrom typing_extensions import ParamSpec\n\n__all__ = (\"deprecated\", \"warn_deprecation\")\n\n\nT = TypeVar(\"T\")\nP = ParamSpec(\"P\")\nDeprecatedKind = Literal[\"function\", \"method\", \"classmethod\", \"attribute\", \"property\", \"class\", \"parameter\", \"import\"]\n\n\n# Code for: def warn_deprecation(\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def deprecated(\n# Natural Language Annotations: \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            _kind = kind or (\n                \"method\" if inspect.ismethod(func) else \"function\"\n            )  # forcing kind to be 'function' or 'method' if not provided\n            warn_deprecation(\n                version=version,\n                deprecated_name=func.__name__,\n                removal_in=removal_in,\n                alternative=alternative,\n                info=info,\n                pending=pending,\n                kind=_kind,\n            )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```", "```python\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n):\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            nonlocal kind\n            if kind is None:\n                kind = \"method\" if inspect.ismethod(func) else \"function\"\n            warn_deprecation(version, func.__qualname__, kind, removal_in=removal_in, alternative=alternative, info=info, pending=pending)\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```", "```python\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            if kind is None:\n                kind = \"method\" if args else \"function\"\n            warn_deprecation(\n                version=version,\n                deprecated_name=func.__name__,\n                kind=kind,\n                removal_in=removal_in,\n                alternative=alternative,\n                info=info,\n                pending=pending,\n            )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```"]}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __call__(self, fn: AnyCallable) -> HTTPRouteHandler:\n        \"\"\"Replace a function with itself.\"\"\"\n        if not is_async_callable(fn):\n            if self.sync_to_thread is None:\n                warn_implicit_sync_to_thread(fn, stacklevel=3)\n        elif self.sync_to_thread is not None:\n            warn_sync_to_thread_with_async_callable(fn, stacklevel=3)\n\n        super().__call__(fn)\n        return self\n------------------------------\n------------------------------\ndef __call__(self, fn: AnyCallable) -> EventListener:\n        \"\"\"Decorate a callable by wrapping it inside an instance of EventListener.\n\n        Args:\n            fn: Callable to decorate.\n\n        Returns:\n            An instance of EventListener\n        \"\"\"\n        if not callable(fn):\n            raise ImproperlyConfiguredException(\"EventListener instance should be called as a decorator on a callable\")\n\n        self.fn = self.wrap_in_error_handler(ensure_async_callable(fn))\n------------------------------\n------------------------------\n@property\n    def fn(self) -> AsyncAnyCallable:\n        \"\"\"Get the handler function.\n\n        Raises:\n            ImproperlyConfiguredException: if handler fn is not set.\n\n        Returns:\n            Handler function\n        \"\"\"\n        if not hasattr(self, \"_fn\"):\n            raise ImproperlyConfiguredException(\"No callable has been registered for this handler\")\n        return self._fn\n------------------------------\n------------------------------\nif not is_async_callable(self.fn):\n            raise ImproperlyConfiguredException(f\"{self}: WebSocket handler functions must be asynchronous\")\n------------------------------\n------------------------------\nif self.has_sync_callable and self.sync_to_thread:\n            self._fn = ensure_async_callable(self.fn)\n            self.has_sync_callable = False\n\n    def _validate_handler_function(self) -> None:\n        \"\"\"Validate the route handler function once it is set by inspecting its return annotations.\"\"\"\n        super()._validate_handler_function()\n\n        return_type = self.parsed_fn_signature.return_type\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n# Natural Language Annotations: \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if is_async_callable(fn):\n        return fn\n    return AsyncCallable(fn)\n```", "```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that `fn` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    `AsyncCallable`\n    \"\"\"\n    if is_async_callable(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```", "```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```"]}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ntype_hints = get_type_hints(origin, globalns=globalns, localns=localns, include_extras=include_extras)\n        # the __parameters__ is only available on the origin itself and not the annotation\n        typevar_map = dict(zip(origin.__parameters__, get_args(annotation)))\n------------------------------\n------------------------------\nmodel_annotations = get_type_hints(\n                origin, globalns=globalns, localns=localns, include_extras=include_extras\n            )\n        args = annotation.__pydantic_generic_metadata__[\"args\"]\n        parameters = origin.__pydantic_generic_metadata__[\"parameters\"]\n        typevar_map = dict(zip(parameters, args))\n------------------------------\n------------------------------\ndef get_typed_init(self, type_: Any) -> tuple[Signature, dict[str, Any]]:\n        parameters = []\n        type_hints = {}\n        for field_info in msgspec.structs.fields(type_):\n            type_hints[field_info.name] = field_info.type\n            parameters.append(\n                inspect.Parameter(\n                    name=field_info.name,\n                    kind=inspect.Parameter.KEYWORD_ONLY,\n                    annotation=field_info.type,\n------------------------------\n------------------------------\ndef get_fn_type_hints(fn: Any, namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Resolve type hints for ``fn``.\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n------------------------------\n------------------------------\ntype_hints = field_definition.get_type_hints(include_extras=True, resolve_generics=True)\n        struct_fields = fields(field_definition.type_)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n\n    expanded_type_hint = {}\n    for param, type_ in type_hint.items():\n        if isinstance(type_, TypeVar):\n            expanded_type_hint[param] = namespace.get(type_.__name__, type_)\n        else:\n            expanded_type_hint[param] = type_\n\n    return expanded_type_hint\n```", "```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n\n    new_type_hint = {}\n    for param, annotation in type_hint.items():\n        if isinstance(annotation, TypeVar):\n            new_type_hint[param] = namespace.get(annotation, annotation)\n        else:\n            new_type_hint[param] = annotation\n    return new_type_hint\n```", "```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n\n    expanded_type_hint = {}\n    for param, hint in type_hint.items():\n        if type(hint) in (tuple, list):\n            expanded_hint = []\n            for item in hint:\n                if item in namespace:\n                    expanded_hint.extend(namespace[item])\n                else:\n                    expanded_hint.append(item)\n            expanded_type_hint[param] = tuple(expanded_hint)\n        elif hint in namespace:\n            expanded_type_hint[param] = namespace[hint]\n        else:\n            expanded_type_hint[param] = hint\n\n    return expanded_type_hint\n```"]}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A tuple of key/value pairs.\n    \"\"\"\n    dataclass_fields = extract_dataclass_fields(dt, exclude_none, exclude_empty, include, exclude)\n    return tuple((field.name, getattr(dt, field.name)) for field in dataclass_fields)\n------------------------------\n------------------------------\nArgs:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n\n    Returns:\n        A tuple of dataclass fields.\n    \"\"\"\n    include = include or set()\n    exclude = exclude or set()\n\n    if common := (include & exclude):\n        raise ValueError(f\"Fields {common} are both included and excluded.\")\n------------------------------\n------------------------------\ndef extract_dataclass_items(\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    include: AbstractSet[str] | None = None,\n    exclude: AbstractSet[str] | None = None,\n) -> tuple[tuple[str, Any], ...]:\n    \"\"\"Extract dataclass name, value pairs.\n\n    Unlike the 'asdict' method exports by the stlib, this function does not pickle values.\n------------------------------\n------------------------------\ndef _obfuscate(values: dict[str, Any], fields_to_obfuscate: set[str]) -> dict[str, Any]:\n    \"\"\"Obfuscate values in a dictionary, replacing values with `******`\n\n    Args:\n        values: A dictionary of strings\n        fields_to_obfuscate: keys to obfuscate\n\n    Returns:\n        A dictionary with obfuscated strings\n    \"\"\"\n    return {key: \"*****\" if key.lower() in fields_to_obfuscate else value for key, value in values.items()}\n------------------------------\n------------------------------\ndef extract_dataclass_fields(\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    include: AbstractSet[str] | None = None,\n    exclude: AbstractSet[str] | None = None,\n) -> tuple[Field[Any], ...]:\n    \"\"\"Extract dataclass fields.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def simple_asdict(\n# Natural Language Annotations: \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["Sure, here is the function based on the given signature and natural language annotations:\n\n```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    result = {}\n    fields = extract_dataclass_fields(obj, exclude_none, exclude_empty, include=None, exclude=exclude)\n    for field in fields:\n        value = getattr(obj, field.name)\n        if convert_nested and is_dataclass(value):\n            value = simple_asdict(value)\n        result[field.name] = value\n    return result\n```", "```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    result = {}\n    for f in fields(obj):\n        if exclude and f.name in exclude:\n            continue\n        value = getattr(obj, f.name)\n        if exclude_none and value is None:\n            continue\n        if exclude_empty and not value:\n            continue\n        if convert_nested and is_dataclass(value):\n            value = simple_asdict(value, exclude_none, exclude_empty, convert_nested, exclude)\n        result[f.name] = value\n    return result\n```", "```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    dataclass_fields = extract_dataclass_fields(obj, exclude_none, exclude_empty, None, exclude)\n    return {field.name: getattr(obj, field.name) for field in dataclass_fields}\n```"]}, "litestar-litestar/utils/path.py-join_paths": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef normalize_path(path: str) -> str:\n    \"\"\"Normalize a given path by ensuring it starts with a slash and does not end with a slash.\n\n    Args:\n        path: Path string\n\n    Returns:\n        Path string\n    \"\"\"\n    path = path.strip(\"/\")\n    path = f\"/{path}\"\n    return multi_slash_pattern.sub(\"/\", path)\n------------------------------\n------------------------------\nReturns:\n            A 3-tuple of the normalized path, the OpenAPI formatted path, and the list of parsed components.\n        \"\"\"\n        path = normalize_path(path)\n\n        parsed_components: list[str | PathParameterDefinition] = []\n        path_format_components = []\n        path_parameters: dict[str, PathParameterDefinition] = {}\n------------------------------\n------------------------------\nArgs:\n            path: A path fragment for the route handler function or a sequence of path fragments. If not given defaults\n                to ``/``\n            connection_accept_handler: A callable that accepts a :class:`WebSocket <.connection.WebSocket>` instance\n                and returns a coroutine that when awaited, will accept the connection. Defaults to ``WebSocket.accept``.\n------------------------------\n------------------------------\nArgs:\n            path: A path fragment for the route handler function or a sequence of path fragments. If not given defaults\n                to ``/``\n            dependencies: A string keyed mapping of dependency :class:`Provider <.di.Provide>` instances.\n            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n                validation of request data.\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\n__all__ = (\"join_paths\", \"normalize_path\")\n\n\nmulti_slash_pattern = re.compile(\"//+\")\n\n\n# Code for: def normalize_path(path: str) -> str:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def join_paths(paths: Iterable[str]) -> str:\n# Natural Language Annotations: \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return \"/\".join(normalize_path(path) for path in paths)\n```", "```python\nfrom __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\n__all__ = (\"join_paths\", \"normalize_path\")\n\n\nmulti_slash_pattern = re.compile(\"//+\")\n\n\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return multi_slash_pattern.sub(\"/\", \"/\".join(paths))\n```", "```python\nfrom __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\n__all__ = (\"join_paths\", \"normalize_path\")\n\n\nmulti_slash_pattern = re.compile(\"//+\")\n\n\n# Code for: def normalize_path(path: str) -> str:\n\ndef normalize_path(path: str) -> str:\n    path = path.strip(\"/\")\n    path = f\"/{path}\"\n    return multi_slash_pattern.sub(\"/\", path)\n\n\n# Function for: def join_paths(paths: Iterable[str]) -> str:\n\ndef join_paths(paths: Iterable[str]) -> str:\n    return multi_slash_pattern.sub(\"/\", \"/\".join(paths))\n```"]}, "litestar-litestar/utils/helpers.py-get_name": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            An integer\n        \"\"\"\n        return len(self._state)\n\n    def __getattr__(self, key: str) -> Any:\n        \"\"\"Get the value for the corresponding key from the wrapped state object using attribute notation.\n\n        Args:\n            key: Key to retrieve\n\n        Raises:\n            AttributeError: if the given attribute is not set.\n------------------------------\n------------------------------\ndef get_enum_string_value(value: Enum | str) -> str:\n    \"\"\"Return the string value of a string enum.\n\n    See: https://github.com/litestar-org/litestar/pull/633#issuecomment-1286519267\n\n    Args:\n        value: An enum or string.\n\n    Returns:\n        A string.\n    \"\"\"\n    return value.value if isinstance(value, Enum) else value  # type: ignore[no-any-return]\n------------------------------\n------------------------------\nExample:\n            number[]\n\n        Returns:\n            A typescript string\n        \"\"\"\n        value = (\n            f\"({self.item_type.write()})\"\n            if isinstance(self.item_type, (TypeScriptUnion, TypeScriptIntersection))\n            else self.item_type.write()\n        )\n        return f\"{value}[]\"\n------------------------------\n------------------------------\nReturns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    async def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n------------------------------\n------------------------------\n@classmethod\n    def get_id_attribute_value(cls, item: T | type[T], id_attribute: str | None = None) -> Any:\n        \"\"\"Get value of attribute named as :attr:`id_attribute <AbstractAsyncRepository.id_attribute>` on ``item``.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_name(value: object) -> str:\n# Natural Language Annotations: \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```", "```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the __name__ of an object.\"\"\"\n    return value.__name__\n```", "```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```"]}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef is_dataclass_instance(obj: Any) -> TypeGuard[DataclassProtocol]:\n    \"\"\"Check if an object is a dataclass instance.\n\n    Args:\n        obj: An object to check.\n\n    Returns:\n        True if the object is a dataclass instance.\n    \"\"\"\n    return hasattr(type(obj), \"__dataclass_fields__\")\n------------------------------\n------------------------------\ndef is_class_and_subclass(annotation: Any, type_or_type_tuple: type[T] | tuple[type[T], ...]) -> TypeGuard[type[T]]:\n    \"\"\"Return ``True`` if ``value`` is a ``class`` and is a subtype of ``t_type``.\n\n    See https://github.com/litestar-org/litestar/issues/367\n\n    Args:\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n------------------------------\n------------------------------\ndef is_attrs_class(annotation: Any) -> TypeGuard[type[attrs.AttrsInstance]]:  # pyright: ignore\n    \"\"\"Given a type annotation determine if the annotation is a class that includes an attrs attribute.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is an attrs class.\n    \"\"\"\n    return attrs.has(annotation) if attrs is not Empty else False  # type: ignore[comparison-overlap]\n------------------------------\n------------------------------\ndef is_mapping(annotation: Any) -> TypeGuard[Mapping[Any, Any]]:\n    \"\"\"Given a type annotation determine if the annotation is a mapping type.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type can be cast as :class:`Mapping <typing.Mapping>`.\n    \"\"\"\n    _type = get_origin_or_inner_type(annotation) or annotation\n    return isclass(_type) and issubclass(_type, (dict, defaultdict, DefaultDict, Mapping))\n------------------------------\n------------------------------\ndef is_any(annotation: Any) -> TypeGuard[Any]:\n    \"\"\"Given a type annotation determine if the annotation is Any.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Any <typing.Any>`.\n    \"\"\"\n    return (\n        annotation is Any\n        or getattr(annotation, \"_name\", \"\") == \"typing.Any\"\n        or (get_origin_or_inner_type(annotation) in UnionTypes and Any in get_args(annotation))\n    )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n# Natural Language Annotations: \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return dataclasses.is_dataclass(annotation)\n```", "```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_dataclass(annotation)\n```", "```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return dataclasses.is_dataclass(annotation)\n```"]}, "litestar-litestar/utils/predicates.py-is_class_var": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef is_annotated_type(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is an Annotated.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _AnnotatedAlias) and getattr(annotation, \"__args__\", None) is not None\n------------------------------\n------------------------------\ndef is_any(annotation: Any) -> TypeGuard[Any]:\n    \"\"\"Given a type annotation determine if the annotation is Any.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Any <typing.Any>`.\n    \"\"\"\n    return (\n        annotation is Any\n        or getattr(annotation, \"_name\", \"\") == \"typing.Any\"\n        or (get_origin_or_inner_type(annotation) in UnionTypes and Any in get_args(annotation))\n    )\n------------------------------\n------------------------------\nArgs:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Union typing.Union>` with a\n            None value or :data:`Optional <typing.Optional>` which is equivalent.\n    \"\"\"\n    origin = get_origin_or_inner_type(annotation)\n    return origin is Optional or (\n        get_origin_or_inner_type(annotation) in UnionTypes and NoneType in get_args(annotation)\n    )\n------------------------------\n------------------------------\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        True if the annotation is a subclass of :data:`Generic <typing.Generic>` otherwise ``False``.\n    \"\"\"\n    return is_class_and_subclass(annotation, Generic)  # type: ignore[arg-type]\n------------------------------\n------------------------------\ndef is_union(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation infers an optional union.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A boolean determining whether the type is :data:`Union typing.Union>`.\n    \"\"\"\n    return get_origin_or_inner_type(annotation) in UnionTypes\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_class_var(annotation: Any) -> bool:\n# Natural Language Annotations: \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _ClassVarAlias) and getattr(annotation, \"__args__\", None) is not None\n```", "```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _ClassVarAlias)\n```", "```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _ClassVarAlias)\n```"]}, "litestar-litestar/utils/module_loader.py-import_string": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef module_to_os_path(dotted_path: str = \"app\") -> Path:\n    \"\"\"Find Module to OS Path.\n\n    Return a path to the base directory of the project or the module\n    specified by `dotted_path`.\n\n    Args:\n        dotted_path: The path to the module. Defaults to \"app\".\n\n    Raises:\n        TypeError: The module could not be found.\n------------------------------\n------------------------------\nReturns:\n        Path: The path to the module.\n    \"\"\"\n    try:\n        if (src := find_spec(dotted_path)) is None:  # pragma: no cover\n            raise TypeError(f\"Couldn't find the path for {dotted_path}\")\n    except ModuleNotFoundError as e:\n        raise TypeError(f\"Couldn't find the path for {dotted_path}\") from e\n\n    return Path(str(src.origin).rsplit(os.path.sep + \"__init__.py\", maxsplit=1)[0])\n------------------------------\n------------------------------\n\"\"\"General utility functions.\"\"\"\n\nfrom __future__ import annotations\n\nimport os.path\nimport sys\nfrom importlib import import_module\nfrom importlib.util import find_spec\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nif TYPE_CHECKING:\n    from types import ModuleType\n\n__all__ = (\n    \"import_string\",\n    \"module_to_os_path\",\n)\n\n\n# Code for: def module_to_os_path(dotted_path: str = \"app\") -> Path:\n------------------------------\n------------------------------\ndef _path_to_dotted_path(path: Path) -> str:\n    if path.stem == \"__init__\":\n        path = path.parent\n    return \".\".join(path.with_suffix(\"\").parts)\n------------------------------\n------------------------------\ndef get_module_global_imports(module_import_path: str, reference_target_source_obj: str) -> set[str]:\n    \"\"\"Return a set of names that are imported globally within the containing module of ``reference_target_source_obj``,\n    including imports in ``if TYPE_CHECKING`` blocks.\n    \"\"\"\n    module = importlib.import_module(module_import_path)\n    obj = getattr(module, reference_target_source_obj)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def import_string(dotted_path: str) -> Any:\n# Natural Language Annotations: \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as e:\n        raise ImportError(f\"{dotted_path} does not look like a module path\") from e\n\n    try:\n        module = import_module(module_path)\n    except Exception as e:\n        raise ImportError(f\"Could not import module {module_path}\") from e\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError as e:\n        raise ImportError(f\"Module {module_path} has no attribute {class_name}\") from e\n```", "```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n        module = import_module(module_path)\n        return getattr(module, class_name)\n    except (ImportError, AttributeError) as e:\n        raise ImportError(f\"Could not import {dotted_path}\") from e\n```", "```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as e:\n        raise ImportError(f\"{dotted_path} doesn't look like a module path\") from e\n\n    module = import_module(module_path)\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError as e:\n        raise ImportError(f\"Module {module_path} does not define a {class_name} attribute/class\") from e\n```"]}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            channels: Channels to unsubscribe from. If ``None``, unsubscribe from all channels\n            subscriber: :class:`Subscriber` to unsubscribe\n        \"\"\"\n        if channels is None:\n            channels = list(self._channels.keys())\n        elif isinstance(channels, str):\n            channels = [channels]\n\n        channels_to_unsubscribe: set[str] = set()\n\n        for channel in channels:\n            channel_subscribers = self._channels[channel]\n------------------------------\n------------------------------\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Unsubscribe from ``channels``\"\"\"\n        self._channels -= set(channels)\n        try:\n            for channel in channels:\n                del self._history[channel]\n        except KeyError:\n            pass\n------------------------------\n------------------------------\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        await self._pub_sub.unsubscribe(*channels)\n        # if we have no active subscriptions, or only subscriptions which are pending\n        # to be unsubscribed we consider the backend to be unsubscribed from all\n        # channels, so we reset the event\n        if not self._pub_sub.channels.keys() - self._pub_sub.pending_unsubscribe_channels:\n------------------------------\n------------------------------\n@abstractmethod\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Start listening for events on ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        ...\n------------------------------\n------------------------------\n# subscribed to anymore\n            if channel.encode() in self._pub_sub.channels.keys() - self._pub_sub.pending_unsubscribe_channels:\n                yield channel, data\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def unsubscribe(self, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Unsubscribe from ``channels``\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```"]}, "litestar-litestar/channels/backends/redis.py-publish": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\n\n        .. note::\n            This operation is performed atomically, using a lua script\n        \"\"\"\n        await self._publish_script(keys=list(set(channels)), args=[data])\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n------------------------------\n------------------------------\nasync def wait_published(self, data: LitestarEncodableType, channels: str | Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\"\"\"\n        if isinstance(channels, str):\n            channels = [channels]\n        data = self.encode_data(data)\n\n        await self._backend.publish(data, channels)\n------------------------------\n------------------------------\nreturn app_config\n\n    def publish(self, data: LitestarEncodableType, channels: str | Iterable[str]) -> None:\n        \"\"\"Schedule ``data`` to be published to ``channels``.\n\n        .. note::\n            This is a synchronous method that returns immediately. There are no\n            guarantees that when this method returns the data will have been published\n            to the backend. For that, use :meth:`wait_published`\n------------------------------\n------------------------------\nasync def on_shutdown(self) -> None:\n        self._queue = None\n\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``. If a channel has not yet been subscribed to,\n        this will be a no-op.\n\n        Args:\n            data: Data to publish\n            channels: Channels to publish to\n\n        Returns:\n            None\n------------------------------\n------------------------------\n\"\"\"\n        if isinstance(channels, str):\n            channels = [channels]\n        data = self.encode_data(data)\n        try:\n            self._pub_queue.put_nowait((data, list(channels)))  # type: ignore[union-attr]\n        except AttributeError as e:\n            raise RuntimeError(\"Plugin not yet initialized. Did you forget to call on_startup?\") from e\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``.\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```", "```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```", "```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```"]}, "litestar-litestar/channels/backends/redis.py-stream_events": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nIf no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\n\n        while True:\n            await self._has_subscribed.wait()\n            message = await self._pub_sub.get_message(\n                ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n            )\n            if message is None:\n                continue\n------------------------------\n------------------------------\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        if self._queue is None:\n            raise RuntimeError(\"Backend not yet initialized. Did you forget to call on_startup?\")\n\n        while True:\n            channel, message = await self._queue.get()\n            self._queue.task_done()\n------------------------------\n------------------------------\n@abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        ...\n\n    @abstractmethod\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        ...\n------------------------------\n------------------------------\nArgs:\n            redis: A :class:`redis.asyncio.Redis` instance\n            key_prefix: Key prefix to use for storing data in redis\n            stream_sleep_no_subscriptions: Amount of time in milliseconds to pause the\n                :meth:`stream_events` generator, should no subscribers exist\n        \"\"\"\n        self._redis = redis\n        self._key_prefix = key_prefix\n        self._stream_sleep_no_subscriptions = stream_sleep_no_subscriptions\n------------------------------\n------------------------------\nArgs:\n            redis: A :class:`redis.asyncio.Redis` instance\n            key_prefix: Key prefix to use for storing data in redis\n            stream_sleep_no_subscriptions: Amount of time in milliseconds to pause the\n                :meth:`stream_events` generator, should no subscribers exist\n        \"\"\"\n        super().__init__(\n            redis=redis, stream_sleep_no_subscriptions=stream_sleep_no_subscriptions, key_prefix=key_prefix\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n# Natural Language Annotations: \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n        if message is None:\n            continue\n        channel, message = await self._queue.get()\n        self._queue.task_done()\n```", "```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n        if message is None:\n            continue\n        channel, message = await self._queue.get()\n        self._queue.task_done()\n```", "```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n        if message is None:\n            continue\n        channel, message = await self._queue.get()\n        self._queue.task_done()\n        yield channel, message\n```"]}, "litestar-litestar/channels/backends/redis.py-get_history": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        history = list(self._history[channel])\n        if limit:\n            history = history[-limit:]\n        return history\n------------------------------\n------------------------------\nclass MemoryChannelsBackend(ChannelsBackend):\n    \"\"\"An in-memory channels backend\"\"\"\n\n    def __init__(self, history: int = 0) -> None:\n        self._max_history_length = history\n        self._channels: set[str] = set()\n        self._queue: Queue[tuple[str, bytes]] | None = None\n        self._history: defaultdict[str, deque[bytes]] = defaultdict(lambda: deque(maxlen=self._max_history_length))\n\n    async def on_startup(self) -> None:\n        self._queue = Queue()\n------------------------------\n------------------------------\n@abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        ...\n\n    @abstractmethod\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        ...\n------------------------------\n------------------------------\nreturn message\n------------------------------\n------------------------------\nchannel_subscribers.add(subscriber)\n\n        if channels_to_subscribe:\n            await self._backend.subscribe(channels_to_subscribe)\n\n        if history:\n            await self.put_subscriber_history(subscriber=subscriber, limit=history, channels=channels)\n\n        return subscriber\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n# Natural Language Annotations: \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```", "```\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```"]}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef build_annotation_for_backend(\n    model_type: type[Any], field_definition: FieldDefinition, transfer_model: type[Struct]\n) -> Any:\n    \"\"\"A helper to re-build a generic outer type with new inner type.\n\n    Args:\n        model_type: The original model type.\n        field_definition: The parsed type that represents the handler annotation for which the DTO is being applied.\n        transfer_model: The transfer model generated to represent the model type.\n------------------------------\n------------------------------\nclass TransferType:\n    \"\"\"Type for representing model types for data transfer.\"\"\"\n\n    __slots__ = (\"field_definition\",)\n\n    field_definition: FieldDefinition\n------------------------------\n------------------------------\n# generated transfer model type in the type arguments.\n            transfer_model = backend.transfer_model_type\n            generic_args = tuple(transfer_model if a is cls.model_type else a for a in field_definition.args)\n            annotation = field_definition.safe_generic_origin[generic_args]\n        else:\n            annotation = backend.annotation\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return _transfer_data(\n            destination_type=self.model_type,\n            source_data=builtins,\n            field_definitions=self.parsed_field_definitions,\n            field_definition=self.field_definition,\n            is_data_field=self.is_data_field,\n        )\n------------------------------\n------------------------------\ndef _transfer_data(\n    destination_type: type[Any],\n    source_data: Any | Collection[Any],\n    field_definitions: tuple[TransferDTOFieldDefinition, ...],\n    field_definition: FieldDefinition,\n    is_data_field: bool,\n) -> Any:\n    \"\"\"Create instance or iterable of instances of ``destination_type``.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_transfer_model_type(\n# Natural Language Annotations: \"\"\"Create a model for data transfer.\n\n        Args:\n            model_name: name for the type that should be unique across all transfer types.\n            field_definitions: field definitions for the container type.\n\n        Returns:\n            A ``BackendT`` class.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_transfer_model_type(model_name: str, field_definitions: tuple[TransferDTOFieldDefinition, ...]) -> BackendT:\n    class_dict = {\"__slots__\": (\"field_definition\",)}\n    for i, field_definition in enumerate(field_definitions):\n        class_dict[f\"field_definition_{i}\"] = field_definition\n    BackendT = type(model_name, (TransferType,), class_dict)\n    return BackendT\n```", "```python\ndef create_transfer_model_type(model_name: str, field_definitions: tuple[TransferDTOFieldDefinition, ...]) -> Any:\n    class BackendT(TransferType):\n        __slots__ = field_definitions\n        field_definition = field_definitions\n\n    BackendT.__name__ = model_name\n    return BackendT\n```", "```python\ndef create_transfer_model_type(\n    model_name: str, field_definitions: Tuple[TransferDTOFieldDefinition, ...]\n) -> Type[BackendT]:\n    transfer_model_type = type(model_name, (BackendT,), {})\n    setattr(transfer_model_type, \"__annotations__\", {definition.name: definition.type for definition in field_definitions})\n    return transfer_model_type\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n------------------------------\n------------------------------\nArgs:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The builtin type parsed into transfer model type.\n        \"\"\"\n        return convert(\n            obj=builtins,\n            type=self.annotation,\n            dec_hook=asgi_connection.route_handler.default_deserializer,\n            strict=False,\n            str_keys=True,\n        )\n------------------------------\n------------------------------\ndef transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return self._transfer_data_from_builtins(builtins)\n\n    def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse raw bytes into instance of `model_type`.\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n            )\n        return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n------------------------------\n------------------------------\ndef transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    return convert(\n        obj=builtins,\n        type=self.annotation,\n        dec_hook=asgi_connection.route_handler.default_deserializer,\n        strict=False,\n        str_keys=True,\n    )\n```", "```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    return self._transfer_data_from_builtins(builtins)\n```", "```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    return convert(\n        obj=builtins,\n        type=self.annotation,\n        dec_hook=asgi_connection.route_handler.default_deserializer,\n        strict=False,\n        str_keys=True,\n    )\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n            )\n        return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n------------------------------\n------------------------------\nreturn name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def parse_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Struct | Collection[Struct]:\n        \"\"\"Parse raw bytes into transfer model type.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The raw bytes parsed into transfer model type.\n        \"\"\"\n        request_encoding = RequestEncodingType.JSON\n------------------------------\n------------------------------\ndef transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return self._transfer_data_from_builtins(builtins)\n\n    def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse raw bytes into instance of `model_type`.\n------------------------------\n------------------------------\nArgs:\n            connection: An :class:`ASGIConnection <litestar.connection.ASGIConnection>` instance.\n\n        Returns:\n            Either a dictionary with the connection's parsed query string or the raw query byte-string.\n        \"\"\"\n        return connection.query_params.dict() if self.parse_query else connection.scope.get(\"query_string\", b\"\")\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n            )\n        return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n        )\n    return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n```", "```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n        )\n    return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n```", "```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n        )\n    return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n```"]}, "litestar-litestar/dto/_backend.py-encode_data": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n        \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\n        if self.wrapper_attribute_name:\n            wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n            setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n            return cast(\"LitestarEncodableType\", data)\n------------------------------\n------------------------------\nArgs:\n            app: The :class:`Litestar <litestar.app.Litestar>` app instance\n            data: Either an instance of a :class:`Response <.response.Response>`,\n                a Response instance or an arbitrary value.\n            request: A :class:`Request <.connection.Request>` instance\n\n        Returns:\n            A Response instance\n        \"\"\"\n        if return_dto_type := self.resolve_return_dto():\n            data = return_dto_type(request).data_to_encodable_type(data)\n------------------------------\n------------------------------\nArgs:\n            data: Either a string or a byte string.\n            mode: The key to use - ``text`` or ``bytes``\n            encoding: The encoding to use when encoding or decoding data.\n------------------------------\n------------------------------\n__all__ = (\n    \"LitestarEncodableType\",\n    \"EncodableBuiltinType\",\n    \"EncodableBuiltinCollectionType\",\n    \"EncodableStdLibType\",\n    \"EncodableStdLibIPType\",\n    \"EncodableMsgSpecType\",\n    \"DataContainerType\",\n)\n------------------------------\n------------------------------\nbackend = self._dto_backends[self.asgi_connection.route_handler.handler_id][\"data_backend\"]  # pyright: ignore\n        return backend.populate_data_from_raw(value, self.asgi_connection)\n\n    def data_to_encodable_type(self, data: T | Collection[T]) -> LitestarEncodableType:\n        backend = self._dto_backends[self.asgi_connection.route_handler.handler_id][\"return_backend\"]  # pyright: ignore\n        return backend.encode_data(data)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def encode_data(self, data: Any) -> LitestarEncodableType:\n# Natural Language Annotations: \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n```", "```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n```", "```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n```"]}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# generated transfer model type in the type arguments.\n            transfer_model = backend.transfer_model_type\n            generic_args = tuple(transfer_model if a is cls.model_type else a for a in field_definition.args)\n            annotation = field_definition.safe_generic_origin[generic_args]\n        else:\n            annotation = backend.annotation\n------------------------------\n------------------------------\ndef build_annotation_for_backend(\n    model_type: type[Any], field_definition: FieldDefinition, transfer_model: type[Struct]\n) -> Any:\n    \"\"\"A helper to re-build a generic outer type with new inner type.\n\n    Args:\n        model_type: The original model type.\n        field_definition: The parsed type that represents the handler annotation for which the DTO is being applied.\n        transfer_model: The transfer model generated to represent the model type.\n------------------------------\n------------------------------\nReturns:\n        Annotation with new inner type if applicable.\n    \"\"\"\n    if not field_definition.inner_types:\n        if field_definition.is_subclass_of(model_type):\n            return transfer_model\n        return field_definition.annotation\n\n    inner_types = tuple(\n        build_annotation_for_backend(model_type, inner_type, transfer_model)\n        for inner_type in field_definition.inner_types\n    )\n\n    return field_definition.safe_generic_origin[inner_types]\n------------------------------\n------------------------------\nfield_type = _create_transfer_model_type_annotation(field_definition.transfer_type)\n        if field_definition.is_partial:\n            field_type = Union[field_type, UnsetType]\n\n        if (field_meta := _create_struct_field_meta_for_field_definition(field_definition)) is not None:\n            field_type = Annotated[field_type, field_meta]\n------------------------------\n------------------------------\ndef _create_transfer_model_mapping_type(transfer_type: MappingType) -> Any:\n    key_type = _create_transfer_model_type_annotation(transfer_type.key_type)\n    value_type = _create_transfer_model_type_annotation(transfer_type.value_type)\n    return transfer_type.field_definition.safe_generic_origin[key_type, value_type]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n# Natural Language Annotations: \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if isinstance(transfer_type, BaseType):\n        return transfer_type.annotation\n    elif isinstance(transfer_type, MappingType):\n        key_type = _create_transfer_model_type_annotation(transfer_type.key_type)\n        value_type = _create_transfer_model_type_annotation(transfer_type.value_type)\n        return transfer_type.field_definition.safe_generic_origin[key_type, value_type]\n    elif isinstance(transfer_type, SequenceType):\n        item_type = _create_transfer_model_type_annotation(transfer_type.item_type)\n        return transfer_type.field_definition.safe_generic_origin[item_type]\n    elif isinstance(transfer_type, OptionalType):\n        item_type = _create_transfer_model_type_annotation(transfer_type.item_type)\n        return Union[item_type, NoneType]\n    elif isinstance(transfer_type, SetType):\n        item_type = _create_transfer_model_type_annotation(transfer_type.item_type)\n        return transfer_type.field_definition.safe_generic_origin[item_type]\n    elif isinstance(transfer_type, UnionType):\n        left_type = _create_transfer_model_type_annotation(transfer_type.left_type)\n        right_type = _create_transfer_model_type_annotation(transfer_type.right_type)\n        return Union[left_type, right_type]\n    else:\n        raise ValueError(f\"Unknown transfer type: {transfer_type}\")\n```", "```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if isinstance(transfer_type, _PrimitiveType):\n        return transfer_type.annotation\n    elif isinstance(transfer_type, _MappingType):\n        key_type = _create_transfer_model_type_annotation(transfer_type.key_type)\n        value_type = _create_transfer_model_type_annotation(transfer_type.value_type)\n        return transfer_type.field_definition.safe_generic_origin[key_type, value_type]\n    elif isinstance(transfer_type, _SequenceType):\n        item_type = _create_transfer_model_type_annotation(transfer_type.item_type)\n        return transfer_type.field_definition.safe_generic_origin[item_type]\n    elif isinstance(transfer_type, _OptionalType):\n        item_type = _create_transfer_model_type_annotation(transfer_type.item_type)\n        return Union[item_type, None]\n    elif isinstance(transfer_type, _UnionType):\n        union_types = tuple(_create_transfer_model_type_annotation(t) for t in transfer_type.types)\n        return Union[union_types]\n    else:\n        raise NotImplementedError(f\"Unsupported transfer type: {type(transfer_type)}\")\n```", "```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if isinstance(transfer_type, AtomicType):\n        return transfer_type.field_definition.annotation\n    elif isinstance(transfer_type, MappingType):\n        return _create_transfer_model_mapping_type(transfer_type)\n    elif isinstance(transfer_type, SequenceType):\n        return _create_transfer_model_sequence_type(transfer_type)\n    elif isinstance(transfer_type, OptionalType):\n        return _create_transfer_model_optional_type(transfer_type)\n    elif isinstance(transfer_type, UnionType):\n        return _create_transfer_model_union_type(transfer_type)\n    else:\n        raise TypeError(f'Unsupported transfer type: {transfer_type}')\n```"]}, "litestar-litestar/response/file.py-start_response": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            None\n        \"\"\"\n        if self.background is not None:\n            await self.background()\n\n    async def start_response(self, send: Send) -> None:\n        \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n------------------------------\n------------------------------\nReturns:\n            None\n        \"\"\"\n        event: HTTPResponseStartEvent = {\n            \"type\": \"http.response.start\",\n            \"status\": self.status_code,\n            \"headers\": self.encode_headers(),\n        }\n        await send(event)\n\n    async def send_body(self, send: Send, receive: Receive) -> None:\n        \"\"\"Emit the response body.\n\n        Args:\n            send: The ASGI send function.\n            receive: The ASGI receive function.\n------------------------------\n------------------------------\nArgs:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        await self.start_response(send=send)\n\n        if self.is_head_response:\n            event: HTTPResponseBodyEvent = {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False}\n            await send(event)\n        else:\n            await self.send_body(send=send, receive=receive)\n------------------------------\n------------------------------\nArgs:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n------------------------------\n------------------------------\nasync def _stream(self, send: Send) -> None:\n        \"\"\"Send the chunks from the iterator as a stream of ASGI 'http.response.body' events.\n\n        Args:\n            send: The ASGI Send function.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def start_response(self, send: Send) -> None:\n# Natural Language Annotations: \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```"]}, "litestar-litestar/connection/request.py-json": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nrequest_body: RequestBody | Reference | None = None\n    \"\"\"The request body applicable for this operation.\n------------------------------\n------------------------------\ndef __call__(self, connection: ASGIConnection[Any, Any, Any, Any]) -> ExtractedRequestData:\n        \"\"\"Extract data from the connection, returning a dictionary of values.\n\n        Notes:\n            - The value for ``body`` - if present - is an unresolved Coroutine and as such should be awaited by the receiver.\n\n        Args:\n            connection: An ASGI connection or its subclasses.\n------------------------------\n------------------------------\nReturns:\n        The Body value.\n    \"\"\"\n    values[\"body\"] = connection.body()\n------------------------------\n------------------------------\nReturns:\n            Either the parsed request body or the raw byte-string.\n        \"\"\"\n        if request.method == HttpMethod.GET:\n            return None\n        if not self.parse_body:\n            return await request.body()\n        try:\n            request_encoding_type = request.content_type[0]\n            if request_encoding_type == RequestEncodingType.JSON:\n                return await request.json()\n            form_data = await request.form()\n------------------------------\n------------------------------\nasync def extract_body(self, request: Request[Any, Any, Any]) -> Any:\n        \"\"\"Extract the body from an ``ASGIConnection``\n\n        Args:\n            request: A :class:`Request <litestar.connection.Request>` instance.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def json(self) -> Any:\n# Natural Language Annotations: \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if self.headers.get('content-type') != 'application/json':\n        raise ValueError('Content-Type is not application/json')\n    body = await self.body()\n    return json.loads(body.decode())\n```", "```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n```", "```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n```"]}, "litestar-litestar/datastructures/multi_dicts.py-close": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            A :class:`MultiDict <.datastructures.multi_dicts.MultiDict>` with query parameters\n------------------------------\n------------------------------\nReturns:\n        A dictionary of parsed results.\n    \"\"\"\n\n    fields: defaultdict[str, list[Any]] = defaultdict(list)\n\n    for form_part in parse_body(body=body, boundary=boundary, multipart_form_part_limit=multipart_form_part_limit):\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        headers: list[tuple[str, str]] = []\n------------------------------\n------------------------------\ndef to_dict(self) -> dict[str, Any]:\n        \"\"\"Normalize access to the signature model's dictionary method, because different backends use different methods\n        for this.\n\n        Returns: A dictionary of string keyed values.\n        \"\"\"\n        return asdict(self)\n------------------------------\n------------------------------\n)\n        return MultiDict(self._parsed_query)\n------------------------------\n------------------------------\nArgs:\n            args: Mapping-like structure to create the ``MultiDict`` from\n        \"\"\"\n        super().__init__(args or {})\n\n    def immutable(self) -> ImmutableMultiDict[T]:\n        \"\"\"Create an.\n\n        :class:`ImmutableMultiDict` view.\n\n        Returns:\n            An immutable multi dict\n        \"\"\"\n        return ImmutableMultiDict[T](self)  # pyright: ignore\n\n    def copy(self) -> Self:\n        \"\"\"Return a shallow copy\"\"\"\n        return type(self)(list(self.multi_items()))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def close(self) -> None:\n# Natural Language Annotations: \"\"\"Close all files in the multi-dict.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for value in self.values():\n        if isinstance(value, IOBase):\n            value.close()\n```", "```\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\"\"\"\n\n    for value in self.values():\n        if isinstance(value, IOBase):\n            value.close()\n```", "```python\nasync def close(self) -> None:\n    for value in self:\n        if isinstance(value, FileStorage):\n            value.close()\n```"]}, "litestar-litestar/datastructures/url.py-from_scope": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            A URL instance constructed from the request's scope.\n        \"\"\"\n        if self._url is Empty:\n            if (url := self._connection_state.url) is not Empty:\n                self._url = url\n            else:\n                self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n        return self._url\n\n    @property\n    def base_url(self) -> URL:\n        \"\"\"Return the base URL of this connection's ``Scope``.\n------------------------------\n------------------------------\nReturns:\n            A URL instance constructed from the request's scope, representing only the base part\n            (host + domain + prefix) of the request.\n        \"\"\"\n        if self._base_url is Empty:\n            if (base_url := self._connection_state.base_url) is not Empty:\n                self._base_url = base_url\n            else:\n                scope = cast(\n                    \"Scope\",\n                    {\n                        **self.scope,\n------------------------------\n------------------------------\n@classmethod\n    def from_scope(cls, scope: Scope) -> Self:\n        \"\"\"Create a new `ConnectionState` object from a scope.\n\n        Object is cached in the scope's state under the `SCOPE_STATE_NAMESPACE` key.\n\n        Args:\n            scope: The ASGI connection scope.\n------------------------------\n------------------------------\nArgs:\n            request:\n                A :class:`Request <.connection.Request>` instance.\n\n        Returns:\n            A rendered html string.\n        \"\"\"\n        schema = self.get_schema_from_request(request)\n------------------------------\n------------------------------\n@property\n    def state(self) -> StateT:\n        \"\"\"Return the ``State`` of this connection.\n\n        Returns:\n            A State instance constructed from the scope[\"state\"] value.\n        \"\"\"\n        return cast(\"StateT\", State(self.scope.get(\"state\")))\n\n    @property\n    def url(self) -> URL:\n        \"\"\"Return the URL of this connection's ``Scope``.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_scope(cls, scope: Scope) -> Self:\n# Natural Language Annotations: \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n        Args:\n            scope: A scope\n\n        Returns:\n            A URL\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nfrom typing import TypeVar, cast\nfrom .types import Scope\nfrom .url import URL\n\nSelf = TypeVar(\"Self\", bound=\"ConnectionState\")\n\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    if self._url is Empty:\n        if (url := self._connection_state.url) is not Empty:\n            self._url = url\n        else:\n            self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n    return self._url\n```", "```python\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    return URL.from_scope(scope)\n```", "```python\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    if self._url is Empty:\n        if (url := self._connection_state.url) is not Empty:\n            self._url = url\n        else:\n            self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n    return self._url\n```"]}, "litestar-litestar/datastructures/headers.py-to_header": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _get_header_value(self) -> str:\n        \"\"\"Get the header value as string.\"\"\"\n\n        cc_items = [\n            key.replace(\"_\", \"-\") if isinstance(value, bool) else f\"{key.replace('_', '-')}={value}\"\n            for key, value in simple_asdict(self, exclude_none=True, exclude={\"documentation_only\"}).items()\n        ]\n        return \", \".join(cc_items)\n------------------------------\n------------------------------\ndef getall(self, key: str, default: Optional[List[str]] = None) -> List[str]:\n        \"\"\"Get all values of a header.\n\n        Args:\n            key: Header key.\n            default: Default value to return if ``name`` is not found.\n\n        Returns:\n            A list of strings.\n------------------------------\n------------------------------\nReturns:\n        A string keyed dictionary of normalized values\n    \"\"\"\n    return {\n        header.name: cast(\"str\", header.value)  # we know value to be a string at this point because we validate it\n        # that it's not None when initializing a header with documentation_only=True\n        for header in headers\n        if not header.documentation_only\n    }\n------------------------------\n------------------------------\ndef set_header(self, key: str, value: Any) -> None:\n        \"\"\"Set a header on the response.\n\n        Args:\n            key: Header key.\n            value: Header value.\n\n        Returns:\n            None.\n        \"\"\"\n        self.headers[key] = value\n\n    def set_etag(self, etag: str | ETag) -> None:\n        \"\"\"Set an etag header.\n\n        Args:\n            etag: An etag value.\n------------------------------\n------------------------------\nclass Header(ABC):\n    \"\"\"An abstract type for HTTP headers.\"\"\"\n\n    HEADER_NAME: ClassVar[str] = \"\"\n\n    documentation_only: bool = False\n    \"\"\"Defines the header instance as for OpenAPI documentation purpose only.\"\"\"\n\n    @abstractmethod\n    def _get_header_value(self) -> str:\n        \"\"\"Get the header value as string.\"\"\"\n        raise NotImplementedError\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_header(self, include_header_name: bool = False) -> str:\n# Natural Language Annotations: \"\"\"Get the header as string.\n\n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    header_value = self._get_header_value()\n    if include_header_name:\n        return f\"{self.HEADER_NAME}: {header_value}\"\n    else:\n        return header_value\n```", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    header_value = self._get_header_value()\n    return f\"{self.HEADER_NAME}: {header_value}\" if include_header_name else header_value\n```", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    if include_header_name:\n        return f\"{self.HEADER_NAME}: {self._get_header_value()}\"\n    return self._get_header_value()\n```"]}, "litestar-litestar/middleware/session/server_side.py-delete": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nIf there is already data associated with ``session_id``, replace\n        it with ``data`` and reset its expiry time\n\n        Args:\n            session_id: The session-ID\n            data: Serialized session data\n            store: Store to save the session data in\n\n        Returns:\n            None\n        \"\"\"\n        expires_in = int(self.config.max_age) if self.config.max_age is not None else None\n        await store.set(session_id, data, expires_in=expires_in)\n------------------------------\n------------------------------\nArgs:\n            config: A subclass of ``ServerSideSessionConfig``\n        \"\"\"\n        super().__init__(config=config)\n\n    async def get(self, session_id: str, store: Store) -> bytes | None:\n        \"\"\"Retrieve data associated with ``session_id``.\n\n        Args:\n            session_id: The session-ID\n            store: Store to retrieve the session data from\n------------------------------\n------------------------------\ndef delete_session_handler(request: Request) -> None:\n    \"\"\"Handler to clear the session.\"\"\"\n    if request.session:\n        request.clear_session()\n------------------------------\n------------------------------\nReturns:\n            The session data, if existing, otherwise ``None``.\n        \"\"\"\n        max_age = int(self.config.max_age) if self.config.max_age is not None else None\n        return await store.get(session_id, renew_for=max_age if self.config.renew_on_access else None)\n\n    async def set(self, session_id: str, data: bytes, store: Store) -> None:\n        \"\"\"Store ``data`` under the ``session_id`` for later retrieval.\n------------------------------\n------------------------------\ndef get_session_id(self, connection: ASGIConnection) -> str:\n        \"\"\"Try to fetch session id from the connection. If one does not exist, generate one.\n\n        If a session ID already exists in the cookies, it is returned.\n        If there is no ID in the cookies but one in the connection state, then the session exists but has not yet\n        been returned to the user.\n        Otherwise, a new session must be created.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def delete(self, session_id: str, store: Store) -> None:\n# Natural Language Annotations: \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n        Args:\n            session_id: The session-ID\n            store: Store to delete the session data from\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        await store.delete(session_id)\n    except KeyError:\n        pass\n```", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        await store.delete(session_id)\n    except KeyError:\n        # Fails silently if no such session-ID exists\n        pass\n```", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        await store.delete(session_id)\n    except KeyError:\n        pass\n```"]}, "marimo-marimo/_islands/island_generator.py-add_code": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n*Args:*\n\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n        - str: The HTML code.\n        \"\"\"\n------------------------------\n------------------------------\n- str: The HTML code.\n        \"\"\"\n\n        is_reactive = (\n            is_reactive if is_reactive is not None else self._is_reactive\n        )\n        display_code = (\n            display_code if display_code is not None else self._display_code\n        )\n        display_output = (\n            display_output\n            if display_output is not None\n            else self._display_output\n        )\n------------------------------\n------------------------------\ndef render(\n        self,\n        display_code: Optional[bool] = None,\n        display_output: Optional[bool] = None,\n        is_reactive: Optional[bool] = None,\n    ) -> str:\n        \"\"\"\n        Render the HTML island code for the cell.\n        Note: This will override construction defaults.\n\n        *Args:*\n------------------------------\n------------------------------\n@app.cell\n# Code for: def __(w_reactive):\n\n\n@app.cell\n# Code for: def __():\n\n\n@app.cell\n# Code for: def __(mo):\n\n\n@app.cell(hide_code=True)\n# Code for: def __(alt, dd_widget, mo, pd):\n\n\nif __name__ == \"__main__\":\n    app.run()\n------------------------------\n------------------------------\nself._unparsable = False\n        self._initialized = False\n\n        self._app_kernel_runner: AppKernelRunner | None = None\n\n    def cell(\n        self,\n        func: Callable[..., Any] | None = None,\n        *,\n        disabled: bool = False,\n        hide_code: bool = False,\n        **kwargs: Any,\n    ) -> Cell | Callable[[Callable[..., Any]], Cell]:\n        \"\"\"A decorator to add a cell to the app\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_code(\n# Natural Language Annotations: \"\"\"Add a code cell to the app.\n\n        *Args:*\n\n        - code (str): The code to add to the app.\n        - display_code (bool): Whether to display the code in the HTML.\n        - display_output (bool): Whether to display the output in the HTML.\n        - is_raw (bool): Whether to handled the code without formatting.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_code(\n    self,\n    code: str,\n    display_code: bool = True,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = True,\n):\n    \"\"\"Add a code cell to the app.\"\"\"\n\n    # Code implementation here\n```", "```python\ndef add_code(\n    self,\n    code: str,\n    display_code: bool = True,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = False,\n):\n    \"\"\"Add a code cell to the app.\"\"\"\n\n    self._unparsable = False\n    self._initialized = False\n\n    self._app_kernel_runner = None\n\n    def cell(\n        func: Callable[..., Any] | None = None,\n        *,\n        disabled: bool = False,\n        hide_code: bool = False,\n        **kwargs: Any,\n    ) -> Cell | Callable[[Callable[..., Any]], Cell]:\n        \"\"\"A decorator to add a cell to the app\"\"\"\n\n        # Code logic here...\n```", "```python\ndef add_code(\n    self,\n    code: str,\n    display_code: bool = True,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = False,\n) -> None:\n    \"\"\"Add a code cell to the app.\"\"\"\n    cell = Cell(\n        code=code,\n        display_code=display_code,\n        display_output=display_output,\n        is_raw=is_raw,\n        is_reactive=is_reactive,\n    )\n    self._cells.append(cell)\n```"]}, "marimo-marimo/_islands/island_generator.py-build": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _register(func: Callable[..., Any]) -> Cell:\n            cell = cell_factory(func, cell_id=self.create_cell_id())\n            cell._cell.configure(cell_config)\n            self._register_cell(cell, app=app)\n            return cell\n------------------------------\n------------------------------\nself._unparsable = False\n        self._initialized = False\n\n        self._app_kernel_runner: AppKernelRunner | None = None\n\n    def cell(\n        self,\n        func: Callable[..., Any] | None = None,\n        *,\n        disabled: bool = False,\n        hide_code: bool = False,\n        **kwargs: Any,\n    ) -> Cell | Callable[[Callable[..., Any]], Cell]:\n        \"\"\"A decorator to add a cell to the app\n------------------------------\n------------------------------\n{as_html(list(self.refs))}\n\n            **Definitions:**\n\n            {as_html(list(self.defs))}\n            \"\"\"\n        )\n\n    def _register_app(self, app: InternalApp) -> None:\n        self._app = app\n\n    def run(\n        self, **refs: Any\n    ) -> (\n        tuple[Any, Mapping[str, Any]]\n        | Awaitable[tuple[Any, Mapping[str, Any]]]\n    ):\n        \"\"\"Run this cell and return its visual output and definitions\n------------------------------\n------------------------------\n@app.cell\n# Code for: def __(mo):\n\n\n@app.cell\n# Code for: def __(mo):\n\n\n@app.cell\n# Code for: def __(dict, mo):\n\n\nif __name__ == \"__main__\":\n    app.run()\n------------------------------\n------------------------------\n@app.cell\n# Code for: def __(mo, solved):\n\n\n@app.cell\n# Code for: def __():\n\n\n@app.cell\n# Code for: def __():\n\n\nif __name__ == \"__main__\":\n    app.run()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def build(self) -> App:\n# Natural Language Annotations: \"\"\"\n        Build the app. This should be called after adding all the code cells.\n\n        *Returns:*\n\n        - App: The built app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def build(self) -> App:\n    self._unparsable = False\n    self._initialized = True\n\n    self._app_kernel_runner = self._create_kernel_runner()\n    self._app_kernel_runner.start()\n\n    code_cells = [cell.code for cell in self._cells]\n    self._app_kernel_runner.execute(code_cells)\n\n    app = self._create_app()\n    return app\n```", "```python\nasync def build(self) -> App:\n    self._initialized = True\n    if self._unparsable:\n        raise ValueError(\"Unparsable cells found. Please check the code.\")\n\n    if self._app_kernel_runner is None:\n        self._app_kernel_runner = AppKernelRunner()\n\n    self._app_kernel_runner.run(self._app)\n    return self._app\n```", "```python\nasync def build(self) -> App:\n    self._initialized = True\n    self._app_kernel_runner = self._build_app_kernel_runner()\n    return self._app\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __():\n    from dataclasses import dataclass\n    return dataclass,\n------------------------------\n------------------------------\ndef __():\n    from dataclasses import dataclass\n    return dataclass,\n------------------------------\n------------------------------\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n------------------------------\n------------------------------\n# Opinionated or known types\n            if isinstance(obj, pd.DataFrame):\n                return obj.to_dict(\"records\")\n            elif isinstance(obj, pd.Series):\n                return obj.to_list()\n            elif isinstance(obj, pd.Categorical):\n                return obj.tolist()\n            elif isinstance(obj, pd.CategoricalDtype):\n                return str(obj)\n            elif isinstance(obj, pd.Timestamp):\n                return str(obj)\n------------------------------\n------------------------------\n@staticmethod\n    def is_type(value: Any) -> bool:\n        return isinstance(value, (list, tuple, dict))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\n    return cls(**values)\n```", "```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    field_names = [f.name for f in dataclasses.fields(cls)]\n    filtered_values = {k: v for k, v in values.items() if k in field_names}\n    return cls(**filtered_values)\n```", "```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    # Create a dictionary of field names and values\n    field_values = {field.name: values[field.name] for field in dataclasses.fields(cls)}\n    # Return the instance of the dataclass\n    return cls(**field_values)\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nprocessed_classes: Dict[Any, str] = {\n        JSONType: \"JSONType\",\n    }\n    component_schemas: Dict[str, Any] = {\n        # Hand-written schema to avoid circular dependencies\n        \"JSONType\": {\n            \"oneOf\": [\n                {\"type\": \"string\"},\n                {\"type\": \"number\"},\n                {\"type\": \"object\"},\n                {\"type\": \"array\"},\n                {\"type\": \"boolean\"},\n                {\"type\": \"null\"},\n            ]\n        }\n    }\n------------------------------\n------------------------------\ndef convert_dataclass(\n        self,\n        cls: Type[Any],\n        processed_classes: Dict[Any, str],\n    ) -> Dict[str, Any]:\n        \"\"\"Convert a dataclass to an OpenAPI schema.\n\n        Args:\n            cls (Type[Any]): The dataclass to convert.\n\n        Raises:\n            ValueError: If cls is not a dataclass.\n------------------------------\n------------------------------\nasync def parse_request(request: Request, cls: Type[T]) -> T:\n    \"\"\"Parse the request body as a dataclass of type `cls`\"\"\"\n    return parse_raw(await request.body(), cls=cls)\n------------------------------\n------------------------------\ndef serialize(datacls: Any) -> Dict[str, JSONType]:\n    try:\n        # Try to serialize as a dataclass\n        return cast(\n            Dict[str, JSONType],\n            asdict(datacls),\n        )\n    except Exception:\n        # If that fails, try to serialize using the WebComponentEncoder\n        return cast(\n            Dict[str, JSONType],\n            json.loads(json.dumps(datacls, cls=WebComponentEncoder)),\n        )\n------------------------------\n------------------------------\n# Frontend type is a tuple (index, value update)\n# Python type is a sequence of values, one for each UI element\n@mddoc\n# Code for: class array(UIElement[Dict[str, JSONType], Sequence[object]]):\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nimport json\nimport re\nfrom typing import Any, Dict, Type, TypeVar, Union\nT = TypeVar('T')\n\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[T]) -> T:\n    \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n    if isinstance(message, bytes):\n        message = json.loads(message)\n\n    def camel_to_snake(s):\n        return re.sub(r'(?<=[a-z])(?=[A-Z])', '_', s).lower()\n\n    def convert_keys(obj):\n        \"\"\"\n        Convert a dict's keys to snake case.\n        \"\"\"\n        if isinstance(obj, dict):\n            return {camel_to_snake(k): convert_keys(v) for k, v in obj.items()}\n        elif isinstance(obj, list):\n            return [convert_keys(elem) for elem in obj]\n        else:\n            return obj\n    \n    message = convert_keys(message)\n    return cls(**message)\n```", "```python\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[T]) -> T:\n    if isinstance(message, bytes):\n        message = json.loads(message.decode('utf-8'))\n\n    if not dataclasses.is_dataclass(cls):\n        raise ValueError(f\"{cls} is not a dataclass.\")\n\n    if isinstance(message, list):\n        message = {f\"__{i}__\": v for i, v in enumerate(message)}\n\n    message = {to_snake_case(k): v for k, v in message.items()}\n\n    return cls(**message)\n```", "```python\nimport json\nfrom typing import TypeVar, Type, Union, Any, Dict\nfrom dataclasses import asdict, is_dataclass\nfrom humps import decamelize\n\nT = TypeVar('T')\n\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[T]) -> T:\n    if isinstance(message, bytes):\n        message = json.loads(message)\n        \n    if not is_dataclass(cls):\n        raise ValueError(f\"{cls} must be a dataclass\")\n    \n    message = {k: v for k, v in message.items()}\n    message = {decamelize(k): v for k, v in message.items()}\n    \n    return cls(**message)\n```"]}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef style(item: object, styles: dict[str, Any]) -> Html:\n    \"\"\"Wrap an object in a styled container.\n\n    **Example.**\n\n    ```python\n    mo.style(item, styles={\"max-height\": \"300px\", \"overflow\": \"auto\"})\n    ```\n\n    **Args.**\n\n    - `item`: an object to render as HTML\n    - `styles`: a dict of CSS styles, keyed by property name\n    \"\"\"\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in styles.items()])\n    return Html(h.div(children=as_html(item).text, style=style_str))\n------------------------------\n------------------------------\ndef __(mo):\n    mo.hstack(\n        [\n            mo.md(\"Icon sets\"),\n            mo.icon(\"lucide:leaf\", size=20),\n            mo.icon(\"material-symbols:rocket-launch\", size=20),\n            mo.icon(\"ic:twotone-rocket-launch\", size=20),\n        ],\n        justify=\"start\",\n    )\n    return\n------------------------------\n------------------------------\ndef __(mo):\n    mo.hstack(\n        [\n            mo.md(\"Flip\"),\n            mo.icon(\"lucide:leaf\", size=20),\n            mo.icon(\"lucide:leaf\", size=20, flip=\"vertical\"),\n            mo.icon(\"lucide:leaf\", size=20, flip=\"horizontal\"),\n            mo.icon(\"lucide:leaf\", size=20, flip=\"vertical,horizontal\"),\n        ],\n        justify=\"start\",\n    )\n    return\n------------------------------\n------------------------------\n**Examples.**\n\n    ```python\n    nav_menu = mo.nav_menu(\n        {\n            \"/overview\": \"Overview\",\n            \"/sales\": f\"{mo.icon('lucide:shopping-cart')} Sales\",\n            \"/products\": f\"{mo.icon('lucide:package')} Products\",\n        }\n    )\n    ```\n------------------------------\n------------------------------\ndef interactive(figure: \"Figure | Axes\") -> Html:  # type: ignore[name-defined] # noqa:F821,E501\n    \"\"\"Render a matplotlib figure using an interactive viewer.\n\n    The interactive viewer allows you to pan, zoom, and see plot coordinates\n    on mouse hover.\n\n    **Example**:\n\n    ```python\n    plt.plot([1, 2])\n    # plt.gcf() gets the current figure\n    mo.mpl.interactive(plt.gcf())\n    ```\n\n    **Args**:\n\n    - figure: a matplotlib `Figure` or `Axes` object\n\n    **Returns**:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def icon(\n# Natural Language Annotations: \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef icon(icon_name: str, size: int = 24, color: str = \"#000\", inline: bool = True, flip: str = \"\", rotate: int = 0, style: dict[str, Any] = {}) -> Html:\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in style.items()])\n    icon_html = Html(h.span(style=style_str))\n    icon_html.children.append(h.i(className=f\"iconify __{'inline' if inline else 'block'}\", style=f\"font-size:{size}px;color:{color};{'--t:'+str(rotate)+'deg' if rotate else ''};{'--tz:'+str(rotate)+'deg' if rotate else ''};{'--tl:'+str(rotate)+'deg' if rotate else ''};{'--tq:'+str(rotate)+'deg' if rotate else ''};{'--tf:'+str(rotate)+'deg' if rotate else ''};{'--ts:'+str(rotate)+'deg' if rotate else ''};{'--fx:'+str(flip)+'deg' if flip else ''};{'--fy:'+str(flip)+'deg' if flip else ''};{'--fz:'+str(flip)+'deg' if flip else ''};{'--fr:'+str(flip)+'deg' if flip else ''};{'--fa:'+str(flip)+'deg' if flip else ''};{'--fs:'+str(flip)+'deg' if flip else ''};{'--ft:'+str(flip)+'deg' if flip else ''};{'--fd:'+str(flip)+'deg' if flip else ''};{'--fb:'+str(flip)+'deg' if flip else ''};{'--fc:'+str(flip)+'deg' if flip else ''};{'--fd:'+str(flip)+'deg' if flip else ''};{'--fe:'+str(flip)+'deg' if flip else ''};{'--ff:'+str(flip)+'deg' if flip else ''};\")))\n    icon_html.children.append(h.span(data_icon=icon_name, className=\"iconify\"))\n    return icon_html\n```", "```python\ndef icon(icon_name: str, size: int = 24, color: str = \"black\", inline: bool = False, flip: str = \"\", rotate: int = 0, style: dict[str, Any] = {}) -> Html:\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in style.items()])\n    inline_style = f\"color:{color};font-size:{size}px;{'display:inline-block;' if inline else ''}{-moz-transform: rotate({rotate}deg);-webkit-transform: rotate({rotate}deg);-o-transform: rotate({rotate}deg);-ms-transform: rotate({rotate}deg);transform: rotate({rotate}deg);{style_str}\"\n    flip_class = f\"flip-{flip}\" if flip else \"\"\n    return Html(f'<div style=\"{inline_style}\" class=\"iconify {flip_class}\" data-icon=\"{icon_name}\"></div>')\n```", "```python\ndef icon(icon_name: str, size: int = 20, color: str = \"black\", inline: bool = True, flip: Union[str, None] = None, rotate: Union[int, None] = None, style: Dict[str, str] = {}) -> Html:\n    # Style string is created\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in style.items()])\n\n    # Rotation is handled\n    rotate_str = \"\"\n    if rotate:\n        rotate_str = f\"rotate({rotate}deg)\"\n\n    # Flip is handled\n    flip_str = \"\"\n    if flip:\n        if \"vertical\" in flip:\n            flip_str += \"scaleY(-1) \"\n        if \"horizontal\" in flip:\n            flip_str += \"scaleX(-1) \"\n\n    # CSS classes are set\n    css_class = \"iconify\"\n    if inline:\n        css_class += \" inline-icon\"\n\n    # Icon HTML is created\n    icon_html = Html(h.span(style=f\"{style_str};{rotate_str}{flip_str}\", className=css_class, data_icon=icon_name))\n\n    # If size is specified, a style wrapper is created\n    if size:\n        icon_html = style(icon_html, {\"font-size\": f\"{size}px\"})\n\n    return icon_html\n```"]}, "marimo-marimo/_plugins/stateless/image.py-image": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef audio(\n    src: Union[str, io.BytesIO],\n) -> Html:\n    \"\"\"Render an audio file as HTML.\n\n    **Example.**\n\n    ```python3\n    mo.audio(\n        src=\"https://upload.wikimedia.org/wikipedia/commons/8/8c/Ivan_Ili%C4%87-Chopin_-_Prelude_no._1_in_C_major.ogg\"\n    )\n\n    mo.audio(src=\"path/to/local/file.wav\")\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an audio file, bytes,\n        or a file-like object opened in binary mode\n\n    **Returns.**\n------------------------------\n------------------------------\ndef style(item: object, styles: dict[str, Any]) -> Html:\n    \"\"\"Wrap an object in a styled container.\n\n    **Example.**\n\n    ```python\n    mo.style(item, styles={\"max-height\": \"300px\", \"overflow\": \"auto\"})\n    ```\n\n    **Args.**\n\n    - `item`: an object to render as HTML\n    - `styles`: a dict of CSS styles, keyed by property name\n    \"\"\"\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in styles.items()])\n    return Html(h.div(children=as_html(item).text, style=style_str))\n------------------------------\n------------------------------\n**Example.**\n\n        ```python\n        mo.md(\"...\").style({\"max-height\": \"300px\", \"overflow\": \"auto\"})\n        ```\n\n        **Args.**\n\n        - `styles`: a dict of CSS styles, keyed by property name\n        \"\"\"\n        from marimo._plugins.stateless import style as _style\n\n        return _style.style(self, style)\n------------------------------\n------------------------------\n*Args:*\n\n        - filename (str): Marimo .py filename to convert to reactive HTML.\n        - display_code (bool): Whether to display the code in HTML snippets.\n        \"\"\"\n        path = MarimoPath(filename)\n        file_router = AppFileRouter.from_filename(path)\n        file_key = file_router.get_unique_file_key()\n        assert file_key is not None\n        file_manager = file_router.get_file_manager(file_key)\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: An image-like object. This can be a list, array, tensor, or a\n        file-like object.\n\n    **Returns.**\n\n    A BytesIO object or other Image type.\n\n    **Raises.**\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def image(\n# Natural Language Annotations: \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef image(\n    src: Union[str, io.BytesIO, ArrayLike],\n    alt: Optional[str] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, Any]] = None,\n) -> Html:\n    if isinstance(src, (str, io.BytesIO)):\n        image_data = open_image(src)\n    else:\n        image_data = src\n\n    if style is None:\n        style = {}\n\n    if rounded:\n        style[\"border-radius\"] = \"50%\"\n\n    if width is not None:\n        style[\"width\"] = f\"{width}px\"\n\n    if height is not None:\n        style[\"height\"] = f\"{height}px\"\n\n    return Html(\n        h.img(\n            src=image_to_base64(image_data),\n            alt=alt or \"\",\n            style=\";\".join(f\"{k}:{v}\" for k, v in style.items()),\n        )\n    )\n```", "```python\ndef image(\n    src: Union[str, io.BytesIO, object],\n    alt: Optional[str] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, Any]] = None,\n) -> Html:\n    \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\n    if isinstance(src, object):\n        src = image_to_base64(src)\n    if rounded:\n        style[\"border-radius\"] = \"50%\"\n    if width:\n        style[\"width\"] = f\"{width}px\"\n    if height:\n        style[\"height\"] = f\"{height}px\"\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in style.items()])\n    return Html(h.img(src=src, alt=alt, style=style_str))\n```", "```python\ndef image(\n    src: Union[str, io.BytesIO, ArrayLike],\n    alt: Optional[str] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, Any]] = None,\n) -> Html:\n    \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\n```"]}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef vstack(\n    items: Sequence[object],\n    *,\n    align: Optional[Literal[\"start\", \"end\", \"center\", \"stretch\"]] = None,\n    justify: Literal[\n        \"start\", \"center\", \"end\", \"space-between\", \"space-around\"\n    ] = \"start\",\n    gap: float = 0.5,\n    heights: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items vertically, in a column.\n\n    Combine with `hstack` to build a grid of items.\n\n    **Example.**\n------------------------------\n------------------------------\n**Args.**\n\n    - `items`: A list of items.\n    - `align`: Align items horizontally: start, end, center, or stretch.\n    - `justify`: Justify items vertically: start, center, end,\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `heights`: \"equal\" to give items equal height;\n        or a list of relative heights with same length as `items`,\n        eg, [1, 2] means the second item is twice as tall\n        as the first; or `None` for a sensible default\n------------------------------\n------------------------------\ndef _spaced(\n    items: Sequence[object],\n    justify: Literal[\"left\", \"right\", \"center\", \"normal\"] = \"center\",\n    items_per_row: Optional[int] = None,\n    column_gap: float = 1,\n    row_gap: float = 1,\n) -> Html:\n    \"\"\"Space items evenly in row-major order.\n\n    A grid built with this function has a fixed number of items per row.\n    For more flexibility, use `hstack` and `vstack`.\n\n    **Args.**\n------------------------------\n------------------------------\n**Example.**\n\n    ```python3\n    # Build a column of items\n    mo.vstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.vstack(\n        [\n            mo.hstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.hstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n------------------------------\n------------------------------\nstacks = mo.vstack(\n        [\n            mo.hstack([justify, align, gap], justify=\"center\"),\n            horizontal,\n            mo.md(\"-----------------------------\"),\n            vertical,\n        ],\n        align=\"stretch\",\n        gap=1,\n    )\n\n    create_wrapper(\n        stacks,\n        \"stacks\",\n    )\n    return horizontal, stacks, vertical\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def hstack(\n# Natural Language Annotations: \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python3\ndef hstack(\n    items: Sequence[object],\n    *,\n    justify: Literal[\n        \"start\", \"center\", \"end\", \"space-between\", \"space-around\"\n    ] = \"start\",\n    align: Literal[\"start\", \"end\", \"center\", \"stretch\"] = \"stretch\",\n    wrap: bool = False,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n```", "```python\ndef hstack(\n    items: Sequence[object],\n    *,\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Literal[\"start\", \"end\", \"center\", \"stretch\"] = None,\n    wrap: bool = True,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    # Your function implementation here\n```", "```python\ndef hstack(\n    items: Sequence[object],\n    *,\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Literal[\"start\", \"end\", \"center\", \"stretch\"] = \"start\",\n    wrap: bool = False,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n```"]}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n```python\n    with mo.status.progress_bar(total=10) as bar:\n        for i in range(10):\n            ...\n            bar.update()\n    ```\n\n    The `update` method accepts the optional keyword\n    arguments `increment` (defaults to `1`), `title`,\n    and `subtitle`.\n\n    For performance reasons, the progress bar is only updated in the UI\n    every 150ms.\n\n    **Args.**\n------------------------------\n------------------------------\ndef update(\n        self,\n        increment: int = 1,\n        title: str | None = None,\n        subtitle: str | None = None,\n    ) -> None:\n        super().update_progress(\n            increment=increment, title=title, subtitle=subtitle\n        )\n------------------------------\n------------------------------\nclass progress_bar:\n    \"\"\"Iterate over a collection and show a progress bar\n\n    **Example.**\n\n    ```python\n    for i in mo.status.progress_bar(range(10)):\n        ...\n    ```\n\n    You can optionally provide a title and subtitle to show\n    during iteration, and a title/subtitle to show upon completion.\n\n    You can also use progress_bar with a context manager and manually update\n    the bar:\n------------------------------\n------------------------------\ndef _finish(self) -> None:\n        self.progress.update(\n            increment=0,\n            title=self.completion_title,\n            subtitle=self.completion_subtitle,\n        )\n        self.progress.close()\n------------------------------\n------------------------------\nclass Spinner(_Progress):\n    \"\"\"A spinner output representing a loading state\"\"\"\n\n    def __init__(self, title: str | None, subtitle: str | None) -> None:\n        super().__init__(\n            title=title,\n            subtitle=subtitle,\n            total=None,\n            show_rate=False,\n            show_eta=False,\n        )\n\n    def update(\n        self, title: str | None = None, subtitle: str | None = None\n    ) -> None:\n        \"\"\"Update the title and subtitle of the spinner\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def update_progress(\n# Natural Language Annotations: \"\"\"Update the progress indicator.\n\n        **Example.**\n\n        ```python\n        # Increment by 1\n        progress.update()\n\n        # Increment by 10 and update title and subtitle\n        progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n        ```\n\n        **Args.**\n\n        - increment: amount to increment by. Defaults to 1.\n        - title: new title. Defaults to None.\n        - subtitle: new subtitle. Defaults to None.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef update_progress(\n    self,\n    increment: int = 1,\n    title: str | None = None,\n    subtitle: str | None = None,\n) -> None:\n    super().update(increment=increment, title=title, subtitle=subtitle)\n```", "```python\ndef update_progress(\n    self,\n    increment: int = 1,\n    title: str | None = None,\n    subtitle: str | None = None,\n) -> None:\n    \"\"\"Update the progress indicator.\n\n    **Example.**\n\n    ```python\n    # Increment by 1\n    progress.update()\n\n    # Increment by 10 and update title and subtitle\n    progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    **Args.**\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    super().update_progress(\n        increment=increment, title=title, subtitle=subtitle\n    )\n```", "```python\ndef update_progress(self, increment: int = 1, title: str | None = None, subtitle: str | None = None) -> None:\n    \"\"\"Update the progress indicator.\n\n    **Example.**\n\n    ```python\n    # Increment by 1\n    progress.update_progress()\n\n    # Increment by 10 and update title and subtitle\n    progress.update_progress(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    **Args.**\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    if title is not None:\n        self.title = title\n    if subtitle is not None:\n        self.subtitle = subtitle\n    self.increment = increment\n    self.update(increment=increment, title=title, subtitle=subtitle)\n```"]}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef build_stateless_plugin(\n    component_name: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a stateless plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n------------------------------\n------------------------------\ndef __init__(\n        self,\n        html: Html,\n        elements: dict[str, UIElement[JSONType, object]],\n        label: str = \"\",\n        on_change: Optional[Callable[[Dict[str, object]], None]] = None,\n    ) -> None:\n        self._elements = elements\n        super().__init__(\n            component_name=_batch_base._name,\n            initial_value={\n                key: e._initial_value_frontend\n                for key, e in self._elements.items()\n            },\n            label=label,\n------------------------------\n------------------------------\ndef __init__(\n        self,\n        elements: Sequence[UIElement[Any, Any]],\n        *,\n        label: str = \"\",\n        on_change: Optional[Callable[[Sequence[object]], None]] = None,\n    ) -> None:\n        self._elements = [e._clone() for e in elements]\n        self._label = label\n        slotted_html = json_output(\n            json_data=format_structure(self._elements),\n            name=\"array\" if not label else label,\n        )\n        super().__init__(\n------------------------------\n------------------------------\n_value_frontend: S\n    _value: T\n\n    def __init__(\n        self,\n        component_name: str,\n        initial_value: S,\n        label: Optional[str],\n        on_change: Optional[Callable[[T], None]],\n        args: dict[str, JSONType],\n        slotted_html: str = \"\",\n        functions: tuple[Function[Any, Any], ...] = (),\n    ) -> None:\n        \"\"\"Initialize a UIElement\n------------------------------\n------------------------------\ndef _initialize(\n        self,\n        component_name: str,\n        initial_value: S,\n        label: Optional[str],\n        on_change: Optional[Callable[[T], None]],\n        args: dict[str, JSONType],\n        slotted_html: str,\n        functions: tuple[Function[Any, Any], ...] = (),\n    ) -> None:\n        \"\"\"Initialize the UIElement\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_ui_plugin(\n# Natural Language Annotations: \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    # Implementation goes here\n```", "```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str = \"\",\n    args: dict[str, JSONType] = {},\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    # Your implementation here\n```", "Here is the function based on the given function signature and natural language annotations:\n\n```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    # Your implementation goes here\n```"]}, "marimo-marimo/_output/formatting.py-as_html": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## Interpolating Python values\n\n        You can interpolate Python values into markdown using\n        `f-strings` and marimo's ` as_html` function. This lets you create \n        markdown whose contents depend on data that changes at runtime.\n\n        Here are some examples.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n            apps. This function compiles Markdown into HTML that marimo\n            can display.\n\n            For example, here's the code that rendered the above title and\n            paragraph:\n\n            ```python3\n            mo.md(\n                '''\n                # Hello, Markdown!\n------------------------------\n------------------------------\nif apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n\n\n@mddoc\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        **Explanation.** By lifting Markdown into Python, marimo lets you construct\n        dynamic Markdown parametrized by arbitrary Python elements. marimo knows\n        how to render its own elements, and you can use `mo.as_html` to render other\n        objects, like plots.\n\n        _Tip: toggle a markdown view via `Cmd/Ctrl-Shift-M` in an empty cell._\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nUse `mo.as_html` to convert objects to HTML. This function\n        generates rich HTML for many Python types, including:\n\n        - lists, dicts, and tuples,\n        - `pandas` dataframes and series,\n        - `seaborn` figures,\n        - `plotly` figures, and\n        - `altair` figures.\n\n        For example, here's a pandas dataframe:\n\n        {mo.as_html(make_dataframe())}\n        \"\"\"\n    )\n    return make_dataframe,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def as_html(value: object) -> Html:\n# Natural Language Annotations: \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nfrom marimo.html import Html\n\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    apply_markdown_class = True\n    html_text = f\"{value}\"\n    if apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n```", "```python\ndef as_html(value: object) -> Html:\n    \"\"\"\n    Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    if apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n\nif apply_markdown_class:\n    return Html('<span class=\"markdown\">' + html_text + \"</span>\")\nelse:\n    return Html(html_text)\n\ndef __(mo):\n    mo.md(\n        rf\\\"\\\"\\\"\n        **Explanation.** By lifting Markdown into Python, marimo lets you construct\n        dynamic Markdown parametrized by arbitrary Python elements. marimo knows\n        how to render its own elements, and you can use `mo.as_html` to render other\n        objects, like plots.\n\n        _Tip: toggle a markdown view via `Cmd/Ctrl-Shift-M` in an empty cell._\n        \\\"\\\"\\\"\n    )\n    return\n```", "```python3\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    if apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n```"]}, "marimo-marimo/_output/md.py-md": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## Interpolating Python values\n\n        You can interpolate Python values into markdown using\n        `f-strings` and marimo's ` as_html` function. This lets you create \n        markdown whose contents depend on data that changes at runtime.\n\n        Here are some examples.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n            apps. This function compiles Markdown into HTML that marimo\n            can display.\n\n            For example, here's the code that rendered the above title and\n            paragraph:\n\n            ```python3\n            mo.md(\n                '''\n                # Hello, Markdown!\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        # Hello, Markdown!\n\n        Use marimo's \"`md`\" function to write markdown. This function compiles Markdown into HTML that marimo can display.\n\n        For example, here's the code that rendered the above title and \n        paragraph:\n\n        ```python3\n        mo.md(\n            '''\n            # Hello, Markdown!\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        **Explanation.** By lifting Markdown into Python, marimo lets you construct\n        dynamic Markdown parametrized by arbitrary Python elements. marimo knows\n        how to render its own elements, and you can use `mo.as_html` to render other\n        objects, like plots.\n\n        _Tip: toggle a markdown view via `Cmd/Ctrl-Shift-M` in an empty cell._\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        r\"\"\"\n        ## LaTeX\n        You can embed LaTeX in Markdown.\n\n        For example,\n\n        ```python3\n        mo.md(r'$f : \\mathbf{R} \\to \\mathbf{R}$')\n        ```\n\n        renders $f : \\mathbf{R} \\to \\mathbf{R}$, while\n\n        ```python3\n        mo.md(\n            r'''\n            \\[\n            f: \\mathbf{R} \\to \\mathbf{R}\n            \\]\n            '''\n        )\n        ```\n\n        renders the display math\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def md(text: str) -> Html:\n# Natural Language Annotations: r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python3\ndef md(text: str) -> Html:\n    \"\"\"\n    Write markdown.\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2\u6280} + \\frac{x^3}{3\u6280} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2\u6280} + \\frac{x^3}{3\u79d1\u6280} + \\ldots.\n    $$\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n    from markdown import markdown\n    from IPython.display import HTML\n\n    html = markdown(text)\n    return HTML(html)\n```", "```python\ndef md(text: str) -> Html:\n    \"\"\"Write markdown.\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2scriptstyle} + \\frac{x^3}{3scriptscriptstyle} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2scriptscriptstyle} + \\frac{x^3}{3scriptscriptstyle} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n``` \n\nPlease note that the `Html` and `mo` objects are not defined in the provided code. You need to replace them with the appropriate objects based on your application.", "Here is the function based on the function signature and natural language annotations:\n\n```python3\ndef md(text: str) -> Html:\n    \"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2\n```"]}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Install formatters when marimo is being used without\n            # a kernel (eg, in a unit test or when run as a Python script)\n            register_formatters()\n\n    if isinstance(obj, Plain):\n        child_formatter = get_formatter(obj.child, include_opinionated=False)\n        if child_formatter:\n\n            def plain_formatter(obj: T) -> tuple[KnownMimeType, str]:\n                assert child_formatter is not None\n                return child_formatter(cast(Plain, obj).child)\n------------------------------\n------------------------------\n# formatters aren't automatically registered when running as a\n            # script\n            from marimo._output.formatters.formatters import (\n                register_formatters,\n            )\n            from marimo._output.formatting import FORMATTERS\n\n            if not FORMATTERS:\n                register_formatters()\n\n            post_execute_hooks = []\n            if DependencyManager.has_matplotlib():\n                from marimo._output.mpl import close_figures\n------------------------------\n------------------------------\ndef __():\n    intro = \"\"\"\n    # File Format\n\n    marimo apps are stored as pure Python files.\n\n    These files are:\n\n    - easily versioned with git, producing small diffs\n    - legible for both humans and machines\n    - formattable using your tool of choice\n    - usable as Python  scripts, with UI  elements taking their default values\n    \"\"\"\n    return intro,\n------------------------------\n------------------------------\nif is_edit_mode:\n        # completions only provided in edit mode\n        kernel.start_completion_worker(completion_queue)\n\n        # In edit mode, kernel runs in its own process so it's interruptible.\n        from marimo._output.formatters.formatters import register_formatters\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        ## Parting thoughts\n\n        marimo is a **reinvention** of the Python notebook as a reproducible, interactive, and shareable Python program, instead of an error-prone scratchpad.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_formatters() -> None:\n# Natural Language Annotations: \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\"\"\"\n    \n    # marimo comes packaged with rich formatters for a number of third-party\n    # libraries. This function hooks into Python's import system to register\n    # these formatters with the kernel if and when a supported third-party\n    # library is imported into a marimo notebook.\n\n    # Hooking into the import system is more complicated than the alternative\n    # of checking whether a package is installed (by importing it) and then\n    # registering its formatters at kernel start-up. However, because some\n    # packages imports take a long time, this alternative would add considerable\n    # delay at program start-up, as the kernel would block as it registered\n    # all formatters before running the notebook. Hooking into the import\n    # system makes formatter registration completely lazy, improving\n    # UX at the cost of increased complexity that we have to maintain. In this\n    # case, the trade-off is worth it.\n\n    # Implementation goes here.\n```", "```python\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\"\"\"\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n\n    from marimo._output.formatters.formatters import register_formatters\n\n    # Register formatters with marimo\n    register_formatters()\n```", "```python\ndef register_formatters() -> None:\n    \"\"\"\n    Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n```"]}, "marimo-marimo/_data/series.py-get_category_series_info": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass CategorySeriesInfo:\n    \"\"\"\n    Represents a summary of a categorical series.\n    \"\"\"\n\n    categories: list[str]\n    label: str\n------------------------------\n------------------------------\nclass NumberSeriesInfo:\n    \"\"\"\n    Represents a summary of a numeric series.\n    \"\"\"\n\n    min: float\n    max: float\n    label: str\n------------------------------\n------------------------------\nclass ColumnSummary:\n    \"\"\"\n    Represents a summary of a column in a data table.\n\n    \"\"\"\n------------------------------\n------------------------------\nclass DateSeriesInfo:\n    \"\"\"\n    Represents a summary of a date series.\n    \"\"\"\n\n    min: str\n    max: str\n    label: str\n------------------------------\n------------------------------\n**Args.**\n\n    - `collection`: optional collection to iterate over\n    - `title`: optional title\n    - `subtitle`: optional subtitle\n    - `completion_title`: optional title to show during completion\n    - `completion_subtitle`: optional subtitle to show during completion\n    - `total`: optional total number of items to iterate over\n    - `show_rate`: if True, show the rate of progress (items per second)\n    - `show_eta`: if True, show the estimated time of completion\n    \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_category_series_info(series: Any) -> CategorySeriesInfo:\n# Natural Language Annotations: \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    unique_values = series.unique()\n    categories = unique_values.tolist()\n    label = series.name\n    return CategorySeriesInfo(categories, label)\n```", "```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    categories = list(series.unique())\n    label = series.name\n    return CategorySeriesInfo(categories, label)\n```", "```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    categories = list(set(series))\n    label = series.name\n    return CategorySeriesInfo(categories, label)\n```"]}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def preview_dataset_column(\n        self, request: PreviewDatasetColumnRequest\n    ) -> None:\n        \"\"\"Preview a column of a dataset.\n------------------------------\n------------------------------\nclass ColumnSummary:\n    \"\"\"\n    Represents a summary of a column in a data table.\n\n    \"\"\"\n------------------------------\n------------------------------\nasync def preview_column(\n    request: Request,\n) -> BaseResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/PreviewDatasetColumnRequest\"\n    responses:\n        200:\n            description: Preview a column in a dataset\n            content:\n                application/json:\n                    schema:\n                        $ref: \"#/components/schemas/SuccessResponse\"\n    \"\"\"\n------------------------------\n------------------------------\nThe dataset is loaded, and the column is displayed in the frontend.\n        \"\"\"\n        try:\n            dataset = self.globals[request.table_name]\n            column_preview = get_column_preview(dataset, request)\n            if column_preview is None:\n                DataColumnPreview(\n                    error=f\"Column {request.column_name} not found\",\n                    column_name=request.column_name,\n                    table_name=request.table_name,\n                ).broadcast()\n------------------------------\n------------------------------\nclass PreviewDatasetColumnRequest:\n    # The source of the dataset\n    source: str\n    # The name of the dataset\n    # This currently corresponds to the variable name\n    table_name: str\n    # The name of the column\n    column_name: str\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_column_preview(\n# Natural Language Annotations: \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_column_preview(\n    dataset: pd.DataFrame, \n    request: PreviewDatasetColumnRequest\n) -> Union[DataColumnPreview, None]:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    \n    if request.column_name in dataset.columns:\n        column_data = dataset[request.column_name]\n        \n        # calculate summary\n        summary = ColumnSummary(\n            min=column_data.min(),\n            max=column_data.max(),\n            mean=column_data.mean(),\n            median=column_data.median(),\n            std_dev=column_data.std(),\n            count=column_data.count(),\n            unique_count=column_data.nunique()\n        )\n        \n        # TODO: generate chart\n        # chart = generate_chart(column_data)\n        \n        # return column preview\n        return DataColumnPreview(\n            column_name=request.column_name,\n            table_name=request.table_name,\n            summary=summary,\n            # chart=chart\n        )\n    else:\n        return None\n```", "```python\ndef get_column_preview(dataset: pd.DataFrame, request: PreviewDatasetColumnRequest):\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    if request.column_name in dataset.columns:\n        column = dataset[request.column_name]\n        chart = column.plot(kind='hist')\n        summary = ColumnSummary(column.describe())\n        return chart, summary\n    else:\n        return None\n```", "```python\ndef get_column_preview(dataset: DataFrame, request: PreviewDatasetColumnRequest) -> ColumnSummary:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    if request.column_name in dataset.columns:\n        column_data = dataset[request.column_name]\n        chart = generate_column_chart(column_data)\n        summary = generate_column_summary(column_data)\n        return ColumnSummary(chart=chart, summary=summary)\n    else:\n        return None\n```"]}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n)\n        if self.module_watcher is not None:\n            self.module_watcher.run_is_processed.set()\n------------------------------\n------------------------------\nasync def start() -> None:\n        # Watch the file for changes\n        watcher = FileWatcher.create(marimo_path.path, on_file_changed)\n        click.echo(\n            f\"Watching {green(marimo_path.relative_name)} for changes...\"\n        )\n        watcher.start()\n        try:\n            # Run forever\n            while True:\n                await asyncio.sleep(1)\n        except KeyboardInterrupt:\n            watcher.stop()\n\n    asyncio_run(start())\n------------------------------\n------------------------------\nhelp=\"Include notebook code in the app.\",\n)\n@click.option(\n    \"--watch\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    type=bool,\n    help=\"\"\"\n    Watch the file for changes and reload the app.\n    If watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"--base-url\",\n    default=\"\",\n    show_default=True,\n    type=str,\n    help=\"Base URL for the server. Should start with a /.\",\n------------------------------\n------------------------------\n# (e.g. recursive/broken symlinks)\n                    continue\n------------------------------\n------------------------------\n):\n                LOGGER.debug(\n                    \"Found a resumable RUN session: prev_id=%s\",\n                    new_session_id,\n                )\n                return maybe_session\n            return None\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start_file_watcher(self) -> Disposable:\n# Natural Language Annotations: \"\"\"Starts the file watcher if it is not already started\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef start_file_watcher(self) -> Disposable:\n    if self.module_watcher is None:\n        watcher = FileWatcher.create(marimo_path.path, on_file_changed)\n        click.echo(\n            f\"Watching {green(marimo_path.relative_name)} for changes...\"\n        )\n        watcher.start()\n        return watcher\n```", "```python\ndef start_file_watcher(self) -> Disposable:\n    if self.module_watcher is not None:\n        self.module_watcher.run_is_processed.set()\n    return Disposable()\n```", "Sure, here is the function based on your request:\n\n```python\ndef start_file_watcher(self) -> Disposable:\n    if self.module_watcher is not None and not self.module_watcher.is_running():\n        self.module_watcher.start()\n        click.echo(f\"Watching {green(marimo_path.relative_name)} for changes...\")\n    return self.module_watcher\n```"]}, "marimo-marimo/_server/file_manager.py-save_app_config": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass SaveAppConfigurationRequest:\n    # partial app config\n    config: Dict[str, Any]\n------------------------------\n------------------------------\nasync def save_app_config(\n    *,\n    request: Request,\n) -> PlainTextResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/SaveAppConfigurationRequest\"\n    responses:\n        200:\n            description: Save the app configuration\n            content:\n                text/plain:\n                    schema:\n                        type: string\n    \"\"\"\n    app_state = AppState(request)\n------------------------------\n------------------------------\ndef save(self, request: SaveNotebookRequest) -> str:\n        \"\"\"Save the current app.\"\"\"\n        cell_ids, codes, configs, names, filename, layout = (\n            request.cell_ids,\n            request.codes,\n            request.configs,\n            request.names,\n            request.filename,\n            request.layout,\n        )\n        filename = canonicalize_filename(filename)\n        self.app.with_data(\n            cell_ids=cell_ids,\n            codes=codes,\n            names=names,\n------------------------------\n------------------------------\n# deleting state that the user might want to keep\n            self.app.update_config({\"layout_file\": None})\n        return self._save_file(\n            filename,\n            codes,\n            names,\n            configs,\n            self.app.config,\n            persist=request.persist,\n        )\n------------------------------\n------------------------------\n@router.post(\"/save_app_config\")\n@requires(\"edit\")\n# Code for: async def save_app_config(\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def save_app_config(self, config: Dict[str, Any]) -> str:\n# Natural Language Annotations: \"\"\"Save the app configuration.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    self.app.update_config(config)\n    return \"App configuration saved.\"\n```", "```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    # Save the app configuration\n    self.config = config\n    # Return a success message\n    return \"App configuration saved successfully!\"\n```", "```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    self.app.update_config(config)\n    return \"App configuration saved successfully.\"\n```"]}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass PyodideSession:\n    \"\"\"A client session that is compatible with Pyodide.\"\"\"\n------------------------------\n------------------------------\nclass SessionView:\n    \"\"\"\n    This stores the current view of the session.\n\n    Which are the cell's outputs, status, and console.\n    \"\"\"\n------------------------------\n------------------------------\nclass StdinRequest:\n    text: str\n------------------------------\n------------------------------\noperations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the consumer\",\n        )\n------------------------------\n------------------------------\ndef put_completion_request(\n        self, request: requests.CodeCompletionRequest\n    ) -> None:\n        \"\"\"Put a code completion request in the completion queue.\"\"\"\n        self._queue_manager.completion_queue.put(request)\n\n    def put_input(self, text: str) -> None:\n        \"\"\"Put an input() request in the input queue.\"\"\"\n        self._queue_manager.input_queue.put(text)\n        self.session_view.add_stdin(text)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_stdin(self, stdin: str) -> None:\n# Natural Language Annotations: \"\"\"Add a stdin request to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    self._queue_manager.input_queue.put(stdin)\n    self.session_view.add_stdin(stdin)\n```", "```python\ndef add_stdin(self, stdin: str) -> None:\n    self.session_view.add_stdin(stdin)\n```", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    self.session_view.add_stdin(stdin)\n```"]}, "marimo-marimo/_server/session/session_view.py-add_operation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\noperations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the consumer\",\n        )\n------------------------------\n------------------------------\noperations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the kiosk consumer\",\n        )\n------------------------------\n------------------------------\nclass SessionView:\n    \"\"\"\n    This stores the current view of the session.\n\n    Which are the cell's outputs, status, and console.\n    \"\"\"\n------------------------------\n------------------------------\n# Code for: class SessionView:\n\n\n# Code for: def merge_cell_operation(\n\n\n# Code for: def as_list(value: Union[Any, Optional[Any], list[Any]]) -> list[Any]:\n------------------------------\n------------------------------\nfor op in operations:\n            LOGGER.debug(\"Replaying operation %s\", serialize(op))\n            self.write_operation(op)\n\n    def _connect_kiosk(self, session: Session) -> None:\n        \"\"\"Connect to a kiosk session.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_operation(self, operation: MessageOperation) -> None:\n# Natural Language Annotations: \"\"\"Add an operation to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.operations.append(operation)\n```", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.operations.append(operation)\n    LOGGER.debug(\"Adding operation %s\", serialize(operation))\n    self.write_operation(operation)\n```", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.operations.append(operation)\n    LOGGER.debug(\"Replaying operation %s\", serialize(operation))\n    self.write_operation(operation)\n```"]}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_cell_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, CellOutput]:\n        \"\"\"Get the outputs for the given cell ids.\"\"\"\n        outputs: dict[CellId_t, CellOutput] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.output is not None:\n                outputs[cell_id] = cell_op.output\n        return outputs\n------------------------------\n------------------------------\ncodes = [\"\" for _ in cell_ids]\n            configs = [CellConfig() for _ in cell_ids]\n            console_outputs = {}\n------------------------------\n------------------------------\ncell_configs=list(configs),\n            cell_outputs=session_view.get_cell_outputs(cell_ids),\n            cell_console_outputs=console_outputs,\n            files=files,\n            asset_url=request.asset_url,\n        )\n------------------------------\n------------------------------\nserialized_cell_outputs = {\n        cell_id: _serialize_to_base64(json.dumps(output.asdict()))\n        for cell_id, output in cell_outputs.items()\n    }\n    serialized_cell_console_outputs = {\n        cell_id: [_serialize_to_base64(json.dumps(o.asdict())) for o in output]\n        for cell_id, output in cell_console_outputs.items()\n        if output\n    }\n------------------------------\n------------------------------\n# code and console outputs are grouped together, but\n        # we can split them up in the future if desired.\n        if request.include_code:\n            code = file_manager.to_code()\n            codes = file_manager.app.cell_manager.codes()\n            configs = file_manager.app.cell_manager.configs()\n            console_outputs = session_view.get_cell_console_outputs(cell_ids)\n        else:\n            code = \"\"\n            codes = [\"\" for _ in cell_ids]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_cell_console_outputs(\n# Natural Language Annotations: \"\"\"Get the console outputs for the given cell ids.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_cell_console_outputs(self, ids: list[CellId_t]) -> dict[CellId_t, list[str]]:\n    \"\"\"Get the console outputs for the given cell ids.\"\"\"\n    console_outputs: dict[CellId_t, list[str]] = {}\n    for cell_id in ids:\n        cell_op = self.cell_operations.get(cell_id)\n        if cell_op is not None and cell_op.console_output is not None:\n            console_outputs[cell_id] = cell_op.console_output\n    return console_outputs\n```", "```python\ndef get_cell_console_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, CellOutput]:\n        \"\"\"Get the console outputs for the given cell ids.\"\"\"\n        console_outputs: dict[CellId_t, CellOutput] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.console_output is not None:\n                console_outputs[cell_id] = cell_op.console_output\n        return console_outputs\n```", "```python\ndef get_cell_console_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, list[str]]:\n        \"\"\"Get the console outputs for the given cell ids.\"\"\"\n        outputs: dict[CellId_t, list[str]] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.console_output is not None:\n                outputs[cell_id] = cell_op.console_output\n        return outputs\n```"]}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Removes a cell from the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Returns the ids of the children of the removed cell.\n        \"\"\"\n        with self.lock:\n            if cell_id not in self.cells:\n                raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\ndef enable_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"\n        Enables a cell in the graph.\n\n        Does not mutate the graph (but does mutate cell statuses).\n\n        Returns:\n        - set of cells that were stale and should be re-run\n        \"\"\"\n        if cell_id not in self.cells:\n            raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\ndef mutate_graph(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> set[CellId_t]:\n        \"\"\"Add and remove cells to/from the graph.\n\n        This method adds the cells in `execution_requests` to the kernel's\n        graph (deleting old versions of these cells, if any), and removes the\n        cells in `deletion_requests` from the kernel's graph.\n------------------------------\n------------------------------\nwith graph.lock:\n        codes = [\n            graph.cells[cid].code\n            for cid in dataflow.topological_sort(\n                graph,\n                set(graph.cells.keys()) - set([request.cell_id]),\n            )\n        ]\n------------------------------\n------------------------------\nmodules: dict[str, types.ModuleType] = {}\n        modname_to_cell_id: dict[str, CellId_t] = {}\n        with graph.lock:\n            for cell_id, cell in graph.cells.items():\n                for modname in modules_imported_by_cell(cell, sys_modules):\n                    if modname in sys_modules:\n                        modules[modname] = sys_modules[modname]\n                        modname_to_cell_id[modname] = cell_id\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n# Natural Language Annotations: \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```", "```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```", "```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```"]}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## References and definitions\n\n        A marimo notebook is a directed acyclic graph in which nodes represent \n        cells and edges represent data dependencies. marimo creates this graph by\n        analyzing each cell (without running it) to determine its\n\n        - references (\"refs*), the global variables it reads but doesn't define;\n        - definitions (\"defs\"), the global variables it defines.\n------------------------------\n------------------------------\ndef check_for_multiple_definitions(\n    graph: DirectedGraph,\n) -> dict[CellId_t, list[MultipleDefinitionError]]:\n    \"\"\"Check whether multiple cells define the same global name.\"\"\"\n    errors = defaultdict(list)\n    defs = sorted(\n        list(set().union(*(cell.defs for _, cell in graph.cells.items())))\n    )\n    for name in defs:\n        defining_cells = graph.definitions[name]\n        if len(defining_cells) > 1:\n            for cid in defining_cells:\n                errors[cid].append(\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport itertools\nfrom collections import defaultdict\n\nfrom marimo._ast.cell import CellId_t\nfrom marimo._messaging.errors import (\n    CycleError,\n    DeleteNonlocalError,\n    Error,\n    MultipleDefinitionError,\n)\nfrom marimo._runtime.dataflow import DirectedGraph\n\n\n# Code for: def check_for_multiple_definitions(\n\n\n# Code for: def check_for_delete_nonlocal(\n------------------------------\n------------------------------\n# Check for semantic errors, like multiple definition errors, cycle\n        # errors, and delete nonlocal errors.\n        semantic_errors = check_for_errors(self.graph)\n        LOGGER.debug(\"After mutation, syntax errors %s\", syntax_errors)\n        LOGGER.debug(\"Semantic errors %s\", semantic_errors)\n------------------------------\n------------------------------\ndef __(mo):\n    mo.accordion(\n        {\n            \"Tip: inspecting refs and defs\": f\"\"\"\n            Use `mo.refs()` and `mo.defs()` to inspect the refs and defs of any\n            given cell. This can help with debugging complex notebooks.\n\n            For example, here are the refs and defs of this cell:\n\n            {mo.as_html({\"refs\": mo.refs(), \"defs\": mo.defs()})}\n            \"\"\"\n        }\n    )\n    return\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check_for_errors(\n# Natural Language Annotations: \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef check_for_errors(graph: DirectedGraph) -> dict[CellId_t, list[Error]]:\n    errors = defaultdict(list)\n\n    multiple_def_errors = check_for_multiple_definitions(graph)\n    cycle_errors = check_for_cycles(graph)\n    delete_nonlocal_errors = check_for_delete_nonlocal(graph)\n\n    for cid in multiple_def_errors:\n        errors[cid].extend(multiple_def_errors[cid])\n    for cid in cycle_errors:\n        errors[cid].extend(cycle_errors[cid])\n    for cid in delete_nonlocal_errors:\n        errors[cid].extend(delete_nonlocal_errors[cid])\n\n    return errors\n```", "```python\ndef check_for_errors(\n    graph: DirectedGraph,\n) -> dict[CellId_t, list[Error]]:\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    errors = defaultdict(list)\n\n    # Check for multiple definition errors\n    multiple_def_errors = check_for_multiple_definitions(graph)\n    for cell_id, cell_errors in multiple_def_errors.items():\n        errors[cell_id].extend(cell_errors)\n\n    # Check for cycle errors\n    cycle_errors = check_for_cycles(graph)\n    for cell_id, cell_errors in cycle_errors.items():\n        errors[cell_id].extend(cell_errors)\n\n    # Check for delete nonlocal errors\n    delete_nonlocal_errors = check_for_delete_nonlocal(graph)\n    for cell_id, cell_errors in delete_nonlocal_errors.items():\n        errors[cell_id].extend(cell_errors)\n\n    return errors\n```", "```python\ndef check_for_errors(\n    graph: DirectedGraph,\n) -> dict[CellId_t, list[Error]]:\n    errors = defaultdict(list)\n    multiple_definition_errors = check_for_multiple_definitions(graph)\n    cycle_errors = check_for_cycles(graph)\n    delete_nonlocal_errors = check_for_delete_nonlocal(graph)\n    for cid, cell in graph.cells.items():\n        errors[cid].extend(\n            itertools.chain(\n                multiple_definition_errors.get(cid, []),\n                cycle_errors.get(cid, []),\n                delete_nonlocal_errors.get(cid, []),\n            )\n        )\n    return errors\n```"]}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _try_registering_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> Optional[Error]:\n        \"\"\"Attempt to register a cell with given id and code.\n\n        Precondition: a cell with the supplied id must not already exist in the\n        graph.\n------------------------------\n------------------------------\n# The set of cells that need to be re-run due to cells being\n        # deleted/re-registered.\n        cells_that_were_children_of_mutated_cells: set[CellId_t] = set()\n\n        # Cells that were unable to be added to the graph due to syntax errors\n        syntax_errors: dict[CellId_t, Error] = {}\n------------------------------\n------------------------------\ndef delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Removes a cell from the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Returns the ids of the children of the removed cell.\n        \"\"\"\n        with self.lock:\n            if cell_id not in self.cells:\n                raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\nif cell_id in self.cell_metadata and cell is not None:\n            # If we already have a config for this cell id, restore it\n            # This can happen when a cell was previously deactivated (due to a\n            # syntax error or multiple definition error, for example) and then\n            # re-registered\n            cell.configure(self.cell_metadata[cell_id].config)\n        elif cell_id not in self.cell_metadata:\n            self.cell_metadata[cell_id] = CellMetadata()\n------------------------------\n------------------------------\n# Register and delete cells\n        for er in execution_requests:\n            old_children, error = self._maybe_register_cell(\n                er.cell_id, er.code\n            )\n            cells_that_were_children_of_mutated_cells |= old_children\n            if error is None:\n                registered_cell_ids.add(er.cell_id)\n            else:\n                syntax_errors[er.cell_id] = error\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _maybe_register_cell(\n# Natural Language Annotations: \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _maybe_register_cell(self, cell_id: CellId_t, code: str) -> Tuple[set[CellId_t], Optional[Error]]:\n    with self.lock:\n        if cell_id in self.cells:\n            # cell already exists, check if code is the same\n            if self.cells[cell_id].code == code:\n                return set(), None\n            else:\n                # code differs, delete cell and its children\n                old_children = self.delete_cell(cell_id)\n                # register new cell with same id but new code\n                error = self._try_registering_cell(cell_id, code)\n                return old_children, error\n        else:\n            # register new cell\n            error = self._try_registering_cell(cell_id, code)\n            return set(), error\n```", "```python\ndef _maybe_register_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> Tuple[set[CellId_t], Optional[Error]]:\n        \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\n        old_children = set()\n        error = None\n\n        with self.lock:\n            if cell_id in self.cells and self.cells[cell_id].code != code:\n                old_children = self.delete_cell(cell_id)\n\n            if cell_id not in self.cells or self.cells[cell_id].code != code:\n                error = self._try_registering_cell(cell_id, code)\n\n        return old_children, error\n```", "```python\ndef _maybe_register_cell(self, cell_id: CellId_t, code: str) -> Tuple[Set[CellId_t], Optional[Error]]:\n    with self.lock:\n        old_children = set()\n        error = None\n\n        if cell_id in self.cells:\n            old_children = self.delete_cell(cell_id)\n\n        try:\n            self._try_registering_cell(cell_id, code)\n        except SyntaxError as e:\n            error = Error(str(e))\n\n        return old_children, error\n```"]}, "marimo-marimo/_runtime/runtime.py-run": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Runner always runs stale ancestors, if any.\n        cells_to_run = roots.union(\n            dataflow.transitive_closure(\n                graph,\n                roots,\n                children=False,\n                inclusive=False,\n                predicate=lambda cell: cell.stale,\n            )\n        )\n        if self.execution_mode == \"autorun\":\n            # in autorun/eager mode, descendants are also run\n------------------------------\n------------------------------\nasync def run_cell(\n    *,\n    request: Request,\n) -> BaseResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/RunRequest\"\n    responses:\n        200:\n            description: Run a cell. Updates cell code in the kernel if needed; registers new cells for unseen cell IDs. Only allowed in edit mode.\n            content:\n                application/json:\n                    schema:\n------------------------------\n------------------------------\nThere is an edge from one cell to another if the latter cell references any\n        global variables defined by the former cell.\n\n        The rule for reactive execution can be restated in terms of the graph: when\n        a cell is run, its descendants are run automatically.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nclass Runner:\n    \"\"\"Utility for running individual cells in a graph\n\n    This class provides methods to a run a cell in the graph and obtain its\n    output (last expression) and the values of its defs.\n\n    If needed, the runner will recursively compute the values of the cell's\n    refs by executing its ancestors. Refs can also be substituted by the\n    caller.\n\n    TODO(akshayka): Add an API for caching defs across cell runs.\n    \"\"\"\n------------------------------\n------------------------------\nRunner._substitute_refs(cell_impl, glbls, kwargs)\n        output = await execute_cell_async(\n            graph.cells[cell_impl.cell_id], glbls, graph\n        )\n        defs = Runner._returns(cell_impl, glbls)\n        return output, defs\n\n    def run_cell_sync(\n        self, cell_id: CellId_t, kwargs: dict[str, Any]\n    ) -> tuple[Any, dict[str, Any]]:\n        \"\"\"Run a synchronous cell and its ancestors\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run(\n# Natural Language Annotations: \"\"\"Run cells and their descendants.\n\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def run(self, execution_requests: list[ExecutionRequest]) -> None:\n    # Run cells and their descendants.\n    #\n    # The cells may be cells already existing in the graph or new cells.\n    # Adds the cells in `execution_requests` to the graph before running\n    # them.\n    #\n    # Cells may use top-level await, which is why this function is async.\n\n    for request in execution_requests:\n        self.graph.add_cells(request.cells)\n\n    roots = set(self.graph.cells.values())  # assume that all cells are roots\n    cells_to_run = roots.union(\n        dataflow.transitive_closure(\n            self.graph,\n            roots,\n            children=False,\n            inclusive=False,\n            predicate=lambda cell: cell.stale,\n        )\n    )\n\n    for cell in cells_to_run:\n        if self.execution_mode == \"autorun\":\n            # in autorun/eager mode, descendants are also run\n            for descendant in self.graph.children(cell):\n                self.run_cell_sync(descendant.cell_id, {})\n```", "```python\nasync def run(self, execution_requests: ExecutionRequests_t) -> dict[CellId_t, tuple[Any, dict[str, Any]]]:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    # Add the cells in `execution_requests` to the graph\n    for cell in execution_requests:\n        self.graph.add_cell(cell)\n\n    # Run the cells and their descendants\n    results = {}\n    for cell in execution_requests:\n        output, defs = await self.run_cell_sync(cell.cell_id, {})\n        results[cell.cell_id] = (output, defs)\n\n    return results\n```", "```python\nasync def run(self, execution_requests: list[CellId_t]):\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    # Add execution requests to the graph\n    for cell_id in execution_requests:\n        if cell_id not in self.graph.cells:\n            self.graph.add_cell(cell_id)\n\n    # Run cells\n    for cell_id in execution_requests:\n        cell = self.graph.cells[cell_id]\n\n        # Run cell and its descendants\n        await self.run_cell(cell)\n```"]}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@staticmethod\n    def has_openai() -> bool:\n        \"\"\"Return True if openai is installed.\"\"\"\n        return importlib.util.find_spec(\"openai\") is not None\n\n    @staticmethod\n    def has_pandas() -> bool:\n        \"\"\"Return True if pandas is installed.\"\"\"\n        return importlib.util.find_spec(\"pandas\") is not None\n\n    @staticmethod\n    def has_pyarrow() -> bool:\n        \"\"\"Return True if pyarrow is installed.\"\"\"\n        return importlib.util.find_spec(\"pyarrow\") is not None\n------------------------------\n------------------------------\nreturn True\n    else:\n        return True\n------------------------------\n------------------------------\n@staticmethod\n    def has_watchdog() -> bool:\n        \"\"\"Return True if watchdog is installed.\"\"\"\n        return importlib.util.find_spec(\"watchdog\") is not None\n\n    @staticmethod\n    def has_ipython() -> bool:\n        \"\"\"Return True if IPython is installed.\"\"\"\n        return importlib.util.find_spec(\"IPython\") is not None\n\n    @staticmethod\n    def has_nbformat() -> bool:\n        \"\"\"Return True if nbformat is installed.\"\"\"\n        return importlib.util.find_spec(\"nbformat\") is not None\n------------------------------\n------------------------------\nif name is not None:\n        # Validate name, or download from URL\n        # The second return value is an optional temporary directory. It is\n        # unused, but must be kept around because its lifetime on disk is bound\n        # to the life of the Python object\n        name, _ = validate_name(\n            name, allow_new_file=True, allow_directory=True\n        )\n        is_dir = os.path.isdir(name)\n        if os.path.exists(name) and not is_dir:\n------------------------------\n------------------------------\ndef check_dependencies():\n        if missing_packages:\n            return module_not_found_explainer\n    return check_dependencies, module_not_found_explainer\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_python_isolated() -> bool:\n# Natural Language Annotations: \"\"\"Returns True if not using system Python\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_python_isolated() -> bool:\n    import sys\n    return sys.executable != sys.base_exec_prefix\n```", "```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python.\"\"\"\n    import sys\n    if getattr(sys, 'real_prefix', None) is not None:\n        return True\n    elif getattr(sys, 'base_prefix', None) != sys.prefix:\n        return True\n    else:\n        return False\n```", "```python\nimport sys\n\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python\"\"\"\n    return sys.prefix != sys.base_prefix\n```"]}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __init__(self) -> None:\n        # Modules that failed to reload: {module: mtime-on-failed-reload, ...}\n        self.failed: dict[str, float] = {}\n        # For replacing old code objects\n        self.old_objects: OldObjectsMapping = {}\n        # module-name -> mtime (module modification timestamps)\n        self.modules_mtimes: dict[str, float] = {}\n        # set of modules names known to be stale but haven't been reloaded\n        self.stale_modules: set[str] = set()\n------------------------------\n------------------------------\ndef __():\n    import importlib\n    import modules.components as complib\n    import modules.intro_problem as intro_problem\n    import modules.problems as problems\n    import modules.explainer as explainer\n\n    problems.configure_matplotlib()\n    _ = importlib.reload(complib)\n    _ = importlib.reload(explainer)\n    _ = importlib.reload(problems)\n    _ = importlib.reload(intro_problem)\n    return complib, explainer, importlib, intro_problem, problems\n------------------------------\n------------------------------\nasync def install_missing_packages(\n        self, request: InstallMissingPackagesRequest\n    ) -> None:\n        \"\"\"Attempts to install packages for modules that cannot be imported\n\n        Runs cells affected by successful installation.\n        \"\"\"\n        assert self.package_manager is not None\n        if request.manager != self.package_manager.name:\n            # Swap out the package manager\n            self.package_manager = create_package_manager(request.manager)\n------------------------------\n------------------------------\ntry:\n        import numpy as np\n\n        numpy_installed = True\n    except ModuleNotFoundError:\n        pass\n    return (\n        matplotlib_installed,\n        missing_matplotlib_msg,\n        missing_numpy_msg,\n        np,\n        numpy_installed,\n        plt,\n    )\n------------------------------\n------------------------------\n# module itself has been modified\n            return {}\n        except Exception:\n            # some modules like numpy fail when called with run_script;\n            # run_script takes a long time before failing on them, so\n            # don't try to analyze them again\n            self._failed_module_filenames.add(file)\n            return {}\n        else:\n            # False positives\n            self._module_dependencies[file] = finder.modules  # type: ignore[assignment]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def missing_modules(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Modules that will fail to import.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    return self.failed.keys()\n```", "```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    return self.failed.keys()\n```", "```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    missing_modules = set()\n    for module_name in self.modules_mtimes:\n        if module_name not in sys.modules:\n            missing_modules.add(module_name)\n    return missing_modules\n```"]}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef load_examples(\n        self,\n    ) -> List[Conversation]:\n        if self.config.load_example:\n            return load_examples(\n                folder=self.config.example_base_path,\n                role_set={self.alias, \"Planner\"},\n            )\n        return []\n\n    def get_plugin_pool(self) -> List[PluginEntry]:\n        return self.plugin_pool\n------------------------------\n------------------------------\nreturn reply_post\n\n    def get_examples(self) -> List[Conversation]:\n        example_conv_list = load_examples(\n            self.config.example_base_path,\n            role_set=set(self.recipient_alias_set) | {self.alias, \"User\"},\n        )\n        return example_conv_list\n------------------------------\n------------------------------\n# Code for: class DocumentRetriever(Role):\n------------------------------\n------------------------------\nclass DocumentRetrieverConfig(RoleConfig):\n    def _configure(self):\n        # default is the directory where this file is located\n        self.index_folder = self._get_str(\n            \"index_folder\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"knowledge_base\",\n            ),\n        )\n        self.size = self._get_int(\"size\", 5)\n        self.target_length = self._get_int(\"target_length\", 256)\n------------------------------\n------------------------------\nclass RoleRegistry(ComponentRegistry[RoleEntry]):\n    def __init__(\n        self,\n        file_glob: Union[str, List[str]],\n        ttl: Optional[timedelta] = None,\n    ) -> None:\n        super().__init__(file_glob, ttl)\n\n    def _load_component(self, path: str) -> Tuple[str, RoleEntry]:\n        entry: Optional[RoleEntry] = RoleEntry.from_yaml_file(file_path=path)\n        assert entry, f\"failed to loading role from {path}\"\n        return entry.name, entry\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def load_examples(\n# Natural Language Annotations: \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef load_examples(folder: str, role_set: Set[str]) -> List[Conversation]:\n    examples = []\n    for role in role_set:\n        role_folder = os.path.join(folder, role)\n        if not os.path.isdir(role_folder):\n            continue\n        for filename in os.listdir(role_folder):\n            if filename.endswith(\".json\"):\n                file_path = os.path.join(role_folder, filename)\n                with open(file_path, \"r\") as f:\n                    data = json.load(f)\n                examples.append(Conversation.from_dict(data))\n    return examples\n```", "```python\ndef load_examples(folder: str, role_set: Set[str]) -> List[Conversation]:\n    examples = []\n    for root, _, files in os.walk(folder):\n        for file in files:\n            if file.endswith('.txt'):\n                with open(os.path.join(root, file), 'r') as f:\n                    text = f.read()\n                    if any(role in text for role in role_set):\n                        examples.append(Conversation(text))\n    return examples\n```", "```python\ndef load_examples(folder: str, role_set: Set[str]) -> List[Conversation]:\n    examples = []\n    for path in os.listdir(folder):\n        if os.path.isfile(os.path.join(folder, path)):\n            with open(os.path.join(folder, path), 'r') as file:\n                content = json.load(file)\n                if set(content.keys()).issubset(role_set):\n                    examples.append(content)\n    return examples\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nself.logger.info(\n            f\"Selected plugin pool: {[p.name for p in self.selected_plugin_pool.get_plugins()]}\",\n        )\n------------------------------\n------------------------------\nself.logger.info(\n            f\"Selected plugin pool: {[p.name for p in self.selected_plugin_pool.get_plugins()]}\",\n        )\n------------------------------\n------------------------------\nclass SelectedPluginPool:\n    def __init__(self):\n        self.selected_plugin_pool = []\n        self._previous_used_plugin_cache = []  # cache the plugins used in the previous code generation\n\n\n\n\n\n\n\n    def __len__(self) -> int:\n        return len(self.selected_plugin_pool)\n\n\n\n\n\n\n\n\n\n\n\n\n    def get_plugins(self) -> List[PluginEntry]:\n        return self.selected_plugin_pool\n------------------------------\n------------------------------\ndef select_plugins_for_prompt(\n        self,\n        query: str,\n    ) -> List[PluginEntry]:\n        selected_plugins = self.plugin_selector.plugin_select(\n            query,\n            self.config.auto_plugin_selection_topk,\n        )\n        self.selected_plugin_pool.add_selected_plugins(selected_plugins)\n        self.logger.info(f\"Selected plugins: {[p.name for p in selected_plugins]}\")\n        self.logger.info(\n------------------------------\n------------------------------\ndef select_plugins_for_prompt(\n        self,\n        user_query: str,\n    ) -> List[PluginEntry]:\n        selected_plugins = self.plugin_selector.plugin_select(\n            user_query,\n            self.config.auto_plugin_selection_topk,\n        )\n        self.selected_plugin_pool.add_selected_plugins(selected_plugins)\n        self.logger.info(f\"Selected plugins: {[p.name for p in selected_plugins]}\")\n        self.logger.info(\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n# Natural Language Annotations: \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    self.selected_plugin_pool.extend(external_plugin_pool)\n    self.logger.info(f\"Added plugins to pool: {[p.name for p in external_plugin_pool]}\")\n```", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    self.selected_plugin_pool = external_plugin_pool\n```", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    self.selected_plugin_pool += external_plugin_pool\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nif self.config.enable_auto_plugin_selection:\n                # here the code is in json format, not really code\n                self.selected_plugin_pool.filter_unused_plugins(\n                    code=llm_response[\"content\"],\n                )\n            return post_proxy.end()\n        else:\n            self.tracing.set_span_status(\n                \"ERROR\",\n                f\"Unexpected response from LLM {llm_response}\",\n            )\n------------------------------\n------------------------------\nif self.config.enable_auto_plugin_selection:\n            # filter out plugins that are not used in the generated code\n            self.selected_plugin_pool.filter_unused_plugins(code=generated_code)\n\n        if prompt_log_path is not None:\n            self.logger.dump_prompt_file(prompt, prompt_log_path)\n\n        self.tracing.set_span_attribute(\"code\", generated_code)\n\n        return post_proxy.post\n------------------------------\n------------------------------\nclass PluginSelector:\n    @inject\n    def __init__(\n        self,\n        plugin_registry: PluginRegistry,\n        llm_api: LLMApi,\n        plugin_only: bool = False,\n    ):\n        if plugin_only:\n            self.available_plugins = [p for p in plugin_registry.get_list() if p.plugin_only is True]\n        else:\n            self.available_plugins = plugin_registry.get_list()\n        self.llm_api = llm_api\n        self.plugin_embedding_dict: Dict[str, List[float]] = {}\n------------------------------\n------------------------------\nif len(plugins_to_embedded) == 0:\n            print(\"All plugins are up-to-date.\")\n            return\n\n        plugin_embeddings = self.llm_api.get_embedding_list([text for idx, text in plugins_to_embedded])\n------------------------------\n------------------------------\nf\"Plugin {p.name} is using embedding model {p.meta_data.embedding_model}, \"\n                f\"which is different from the one used by current session\"\n                f\" ({self.llm_api.embedding_service.config.embedding_model}). \"\n                f\"Please use the same embedding model or refresh the plugin embedding.\"\n                + self.exception_message_for_refresh\n            )\n            # check if the plugin has been modified\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def filter_unused_plugins(self, code: str):\n# Natural Language Annotations: \"\"\"\n        Filter out plugins that are not used in the code generated by LLM\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = set()\n    for p in self.selected_plugin_pool.get_list():\n        if p.name in code:\n            used_plugins.add(p)\n    self.selected_plugin_pool.plugins = list(used_plugins)\n```", "```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = []\n    for plugin in self.selected_plugin_pool:\n        if plugin.name in code:\n            used_plugins.append(plugin)\n    self.selected_plugin_pool = used_plugins\n```", "```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = []\n    for plugin in self.selected_plugin_pool:\n        if plugin.name in code:\n            used_plugins.append(plugin)\n    self.selected_plugin_pool = used_plugins\n```"]}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nfor post in round.post_list:\n                post.message = PromptUtil.remove_parts(\n                    post.message,\n                    delimiter=PromptUtil.DELIMITER_TEMPORAL,\n                )\n        # Remove the delimiters from the text of the posts of the last round\n        for post in rounds_from_role[-1].post_list:\n            post.message = PromptUtil.remove_all_delimiters(post.message)\n------------------------------\n------------------------------\n@staticmethod\n    def remove_parts(text: str, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Remove the parts of the text that are wrapped by the specified delimiters.\"\"\"\n        while True:\n            # Find the start of the temporal part\n            start_index = text.find(delimiter[0])\n            # Find the end of the temporal part\n            end_index = text.find(delimiter[1], start_index + len(delimiter[0]))\n------------------------------\n------------------------------\n@staticmethod\n    def remove_delimiter(text: str, delimiter: Tuple[str, str]):\n        \"\"\"Remove the specified delimiter from the text.\"\"\"\n        text = text.replace(delimiter[0], \"\")\n        text = text.replace(delimiter[1], \"\")\n        return text\n\n    @staticmethod\n------------------------------\n------------------------------\n@staticmethod\n    def get_all_delimiters() -> List[Tuple[str, str]]:\n        \"\"\"Get all the delimiters.\"\"\"\n        return [getattr(PromptUtil, attr) for attr in dir(PromptUtil) if attr.startswith(\"DELIMITER_\")]\n------------------------------\n------------------------------\nclass PromptUtil:\n    DELIMITER_TEMPORAL: Tuple[str, str] = (\"{{DELIMITER_START_TEMPORAL}}\", \"{{DELIMITER_END_TEMPORAL}}\")\n\n    @staticmethod\n    def wrap_text_with_delimiter(text, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Wrap the provided text with the specified start and end delimiters.\"\"\"\n        return f\"{delimiter[0]}{text}{delimiter[1]}\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def remove_all_delimiters(text: str) -> str:\n# Natural Language Annotations: \"\"\"Remove all the delimiters from the text.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    for delimiter in PromptUtil.get_all_delimiters():\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    delimiters = PromptUtil.get_all_delimiters()\n    for delimiter in delimiters:\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    delimiters = PromptUtil.get_all_delimiters()\n    for delimiter in delimiters:\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```"]}, "reflex-reflex/app.py-_enable_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass State(rx.State):\n    \"\"\"The app state.\"\"\"\n\n    ...\n------------------------------\n------------------------------\ndef compile_state(state: Type[BaseState]) -> dict:\n    \"\"\"Compile the state of the app.\n\n    Args:\n        state: The app state object.\n------------------------------\n------------------------------\ndef get_state_manager() -> StateManager:\n    \"\"\"Get the state manager for the app that is currently running.\n\n    Returns:\n        The state manager.\n    \"\"\"\n    app = getattr(prerequisites.get_app(), constants.CompileVars.APP)\n    return app.state_manager\n------------------------------\n------------------------------\nArgs:\n        state: The app state object.\n\n    Returns:\n        A dictionary of the compiled state.\n    \"\"\"\n    try:\n        initial_state = state(_reflex_internal_init=True).dict(initial=True)\n    except Exception as e:\n        console.warn(\n            f\"Failed to compile initial state with computed vars, excluding them: {e}\"\n        )\n        initial_state = state(_reflex_internal_init=True).dict(include_computed=False)\n    return format.format_state(initial_state)\n------------------------------\n------------------------------\nclass State(State):\n    \"\"\"The app state.\"\"\"\n\n    # A dict from the chat name to the list of questions and answers.\n    chats: dict[str, list[QA]] = DEFAULT_CHATS\n\n    # The current chat name.\n    current_chat = \"Intros\"\n\n    # The current question.\n    question: str\n\n    # Whether we are processing the question.\n    processing: bool = False\n\n    # The name of the new chat.\n    new_chat_name: str = \"\"\n\n    # Whether the drawer is open.\n    drawer_open: bool = False\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _enable_state(self) -> None:\n# Natural Language Annotations: \"\"\"Enable state for the app.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    try:\n        initial_state = self.state(_reflex_internal_init=True).dict(initial=True)\n    except Exception as e:\n        console.warn(\n            f\"Failed to compile initial state with computed vars, excluding them: {e}\"\n        )\n        initial_state = self.state(_reflex_internal_init=True).dict(include_computed=False)\n    self.format.format_state(initial_state)\n```", "```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    self.state_enabled = True\n```", "```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n```"]}, "reflex-reflex/app.py-_add_optional_endpoints": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __call__(self) -> FastAPI:\n        \"\"\"Run the backend api instance.\n\n        Returns:\n            The backend api.\n        \"\"\"\n        return self.api\n\n    def _add_default_endpoints(self):\n        \"\"\"Add default api endpoints (ping).\"\"\"\n        # To test the server.\n        self.api.get(str(constants.Endpoint.PING))(ping)\n------------------------------\n------------------------------\n\"\"\"A file upload component.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom typing import Callable, ClassVar, Dict, List, Optional\n------------------------------\n------------------------------\nclass Endpoint(Enum):\n    \"\"\"Endpoints for the reflex backend API.\"\"\"\n\n    PING = \"ping\"\n    EVENT = \"_event\"\n    UPLOAD = \"_upload\"\n    AUTH_CODESPACE = \"auth-codespace\"\n\n    def __str__(self) -> str:\n        \"\"\"Get the string representation of the endpoint.\n\n        Returns:\n            The path for the endpoint.\n        \"\"\"\n        return f\"/{self.value}\"\n\n    def get_url(self) -> str:\n        \"\"\"Get the URL for the endpoint.\n------------------------------\n------------------------------\nclass UploadValueError(ReflexError, ValueError):\n    \"\"\"Custom ValueError for upload related errors.\"\"\"\n------------------------------\n------------------------------\nclass UploadFilesProvider(Component):\n    \"\"\"AppWrap component that provides a dict of selected files by ID via useContext.\"\"\"\n\n    library = f\"/{Dirs.CONTEXTS_PATH}\"\n    tag = \"UploadFilesProvider\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_optional_endpoints(self):\n# Natural Language Annotations: \"\"\"Add optional api endpoints (_upload).\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    self.api.get(str(Endpoint.UPLOAD))(self._handle_upload)\n```", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    self.api.post(str(Endpoint.UPLOAD))(upload)\n```", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    self.api.post(str(constants.Endpoint.UPLOAD))(upload)\n```"]}, "reflex-reflex/app.py-add_page": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            component: The component to display at the page.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n        \"\"\"\n        if component is None:\n            component = Default404Page.create()\n        self.add_page(\n------------------------------\n------------------------------\nNote: the decorated functions still need to be imported.\n\n    Args:\n        route: The route to reach the page.\n        title: The title of the page.\n        image: The favicon of the page.\n        description: The description of the page.\n        meta: Additional meta to add to the page.\n        on_load: The event handler(s) called when the page load.\n        script_tags: scripts to attach to the page\n\n    Returns:\n        The decorated function.\n    \"\"\"\n------------------------------\n------------------------------\ndef page(\n    route: str | None = None,\n    title: str | None = None,\n    image: str | None = None,\n    description: str | None = None,\n    meta: list[Any] | None = None,\n    script_tags: list[Any] | None = None,\n    on_load: Any | list[Any] | None = None,\n):\n    \"\"\"Decorate a function as a page.\n\n    rx.App() will automatically call add_page() for any method decorated with page\n    when App.compile is called.\n\n    All defaults are None because they will use the one from add_page().\n------------------------------\n------------------------------\ndef add_meta(\n    page: Component,\n    title: str,\n    image: str,\n    meta: list[dict],\n    description: str | None = None,\n) -> Component:\n    \"\"\"Add metadata to a page.\n\n    Args:\n        page: The component for the page.\n        title: The title of the page.\n        image: The image for the page.\n        meta: The metadata list.\n        description: The description of the page.\n------------------------------\n------------------------------\nself.add_page(\n            component=wait_for_client_redirect(self._generate_component(component)),\n            route=constants.Page404.SLUG,\n            title=title or constants.Page404.TITLE,\n            image=image or constants.Page404.IMAGE,\n            description=description or constants.Page404.DESCRIPTION,\n            on_load=on_load,\n            meta=meta,\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_page(\n# Natural Language Annotations: \"\"\"Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_page(\n    component: Callable | Component,\n    route: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    image: str | None = None,\n    on_load: Any | list[Any] | None = None,\n    meta: list[Any] | None = None,\n):\n    if route is None:\n        if callable(component):\n            route = component.__name__\n        else:\n            raise ValueError(\"Route must be provided when component is not a callable.\")\n\n    if route in self.routes:\n        raise ValueError(f\"Route {route} already exists.\")\n\n    self.routes[route] = component\n\n    if title is None:\n        title = getattr(component, \"title\", None)\n\n    if description is None:\n        description = getattr(component, \"description\", None)\n\n    if image is None:\n        image = getattr(component, \"image\", None)\n\n    self.add_page(\n        component=wait_for_client_redirect(self._generate_component(component)),\n        route=route,\n        title=title,\n        image=image,\n        description=description,\n        on_load=on_load,\n        meta=meta,\n    )\n```", "```python\ndef add_page(\n    component: Callable,\n    route: str = None,\n    title: str = None,\n    description: str = None,\n    image: str = None,\n    on_load: Any | list[Any] = None,\n    meta: list[Any] = None,\n):\n    if callable(component):\n        if route is None:\n            route = component.__name__\n        component = component()\n\n    if route in self.routes:\n        raise ValueError(\"The specified route name already exists.\")\n\n    self.routes[route] = {\n        \"component\": component,\n        \"title\": title,\n        \"description\": description,\n        \"image\": image,\n        \"on_load\": on_load,\n        \"meta\": meta,\n    }\n```", "```python\ndef add_page(\n    component: Any,\n    route: str = None,\n    title: str = None,\n    description: str = None,\n    image: str = None,\n    on_load: Any | list[Any] = None,\n    meta: list[Any] = None,\n):\n    \"\"\"Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    if callable(component) and route is None:\n        route = component.__name__\n\n    if route is None:\n        raise ValueError(\"A route must be provided if the component isn't a callable.\")\n\n    if route in self._pages:\n        raise ValueError(f\"The specified route name '{route}' already exists.\")\n\n    self._pages[route] = {\n        \"component\": component,\n        \"title\": title,\n        \"description\": description,\n        \"image\": image,\n        \"on_load\": on_load if isinstance(on_load, list) else [on_load],\n        \"meta\": meta,\n    }\n```"]}, "reflex-reflex/app.py-_setup_overlay_component": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# When the component is referenced by more than one page, render it\n        # to be included in the STATEFUL_COMPONENTS module.\n        # Skip this step in dev mode, thereby avoiding potential hot reload errors for larger apps\n        if (\n            isinstance(component, StatefulComponent)\n            and component.references > 1\n            and is_prod_mode()\n        ):\n            # Reset this flag to render the actual component.\n            component.rendered_as_shared = False\n------------------------------\n------------------------------\nclass ConnectionModal(Component):\n    \"\"\"A connection status modal window.\"\"\"\n\n    @classmethod\n    def create(cls, comp: Optional[Component] = None) -> Component:\n        \"\"\"Create a connection banner component.\n\n        Args:\n            comp: The component to render when there's a server connection error.\n------------------------------\n------------------------------\nif stateful_component is not None:\n                return stateful_component\n        return component\n------------------------------\n------------------------------\nRaises:\n            ValueError: If the event namespace is not provided in the config.\n                        Also, if there are multiple client subclasses of rx.BaseState(Subclasses of rx.BaseState should consist\n                        of the DefaultState and the client app state).\n        \"\"\"\n        if \"connect_error_component\" in kwargs:\n            raise ValueError(\n                \"`connect_error_component` is deprecated, use `overlay_component` instead\"\n            )\n------------------------------\n------------------------------\nif (\n            hasattr(render_fn, \"__qualname__\")\n            and render_fn.__qualname__ == ComponentState.create.__qualname__\n        ):\n            raise TypeError(\n                \"Using a ComponentState as `render_fn` inside `rx.foreach` is not supported yet.\"\n            )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _setup_overlay_component(self):\n# Natural Language Annotations: \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _setup_overlay_component(self):\n    if not self.use_state and not self.overlay_component:\n        return\n```", "```python\ndef _setup_overlay_component(self):\n    if self.state is not None or self.overlay_component is not None:\n        return\n\n    self.overlay_component = ConnectionModal.create()\n```", "```python\ndef _setup_overlay_component(self):\n    if self.state is None and self.overlay_component is None:\n        self.overlay_component = ConnectionModal.create()\n```"]}, "reflex-reflex/app.py-_compile": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"Welcome to Reflex! This file outlines the steps to create a basic app.\"\"\"\n\nimport reflex as rx\n\nfrom rxconfig import config\n\n\n# Code for: class State(rx.State):\n\n\n# Code for: def index() -> rx.Component:\n\n\napp = rx.App()\napp.add_page(index)\n------------------------------\n------------------------------\ndef AppWithOnePage():\n    \"\"\"A reflex app with one page.\"\"\"\n    from rxconfig import config  # type: ignore\n\n    import reflex as rx\n\n    docs_url = \"https://reflex.dev/docs/getting-started/introduction/\"\n    filename = f\"{config.app_name}/{config.app_name}.py\"\n\n    class State(rx.State):\n        \"\"\"The app state.\"\"\"\n\n        pass\n------------------------------\n------------------------------\n\"\"\"Base state for the app.\"\"\"\n\nimport reflex as rx\n\n\n# Code for: class State(rx.State):\n------------------------------\n------------------------------\ndef NavigationApp():\n    \"\"\"Reflex app with links for navigation.\"\"\"\n    import reflex as rx\n\n    class State(rx.State):\n        is_external: bool = True\n\n    app = rx.App()\n------------------------------\n------------------------------\n\"\"\"Welcome to Reflex! This file outlines the steps to create a basic app.\"\"\"\n\nfrom typing import Callable\n\nimport reflex as rx\n\nfrom .pages import chatapp_page, datatable_page, forms_page, graphing_page, home_page\nfrom .sidebar import sidebar\nfrom .state import State\nfrom .styles import *\n\nmeta = [\n    {\n        \"name\": \"viewport\",\n        \"content\": \"width=device-width, shrink-to-fit=no, initial-scale=1\",\n    },\n]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _compile(self, export: bool = False):\n# Natural Language Annotations: \"\"\"Compile the app and output it to the pages folder.\n\n        Args:\n            export: Whether to compile the app for export.\n\n        Raises:\n            ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n```", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    if export:\n        self.compile(export=True)\n    else:\n        self.compile()\n```", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n```"]}, "reflex-reflex/app.py-modify_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            token: The token to set the state for.\n            state: The state to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state for a token while holding exclusive lock.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state for the token.\n        \"\"\"\n        yield self.state()\n------------------------------\n------------------------------\nArgs:\n            token: The token to set the state for.\n            state: The state to set.\n        \"\"\"\n        pass\n\n    @contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state for a token while holding exclusive lock.\n\n        Args:\n            token: The token to modify the state for.\n------------------------------\n------------------------------\n@contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state associated with the given token and send update to frontend.\n\n        Args:\n            token: The state token to modify\n\n        Yields:\n            The state instance associated with the given token\n------------------------------\n------------------------------\nYields:\n            The state for the token.\n        \"\"\"\n        async with self._lock(token) as lock_id:\n            state = await self.get_state(token)\n            yield state\n            await self.set_state(token, state, lock_id)\n\n    @staticmethod\n    def _lock_key(token: str) -> bytes:\n        \"\"\"Get the redis key for a token's lock.\n\n        Args:\n            token: The token to get the lock key for.\n------------------------------\n------------------------------\nArgs:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n# Natural Language Annotations: \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not self._initialized:\n        raise RuntimeError(\"The app has not been initialized yet.\")\n\n    async with self._lock(token) as lock_id:\n        state = await self.get_state(token)\n        yield state\n        await self.set_state(token, state, lock_id)\n```", "```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    async with self._lock(token) as lock_id:\n        state = await self.get_state(token)\n        yield state\n        await self.set_state(token, state, lock_id)\n```", "```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not self.initialized:\n        raise RuntimeError(\"App has not been initialized yet\")\n\n    async with self._lock(token) as lock_id:\n        state = await self.get_state(token)\n        yield state\n        await self.set_state(token, state, lock_id)\n```"]}, "reflex-reflex/vars.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n------------------------------\n------------------------------\nReturns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n            TypeError: If _var_is_local or _var_is_string is not None.\n        \"\"\"\n        if _var_is_local is not None:\n            raise TypeError(\n                \"The _var_is_local argument is not supported for ImmutableVar.\"\n            )\n------------------------------\n------------------------------\n@classmethod\n    def create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n------------------------------\n------------------------------\nArgs:\n            key: The key to set.\n            value: The value to set.\n        \"\"\"\n        # Create a Var to collapse VarData encoded in f-string.\n        _var = Var.create(value, _var_is_string=False)\n        if _var is not None:\n            # Carry the imports/hooks when setting a Var as a value.\n            self._var_data = VarData.merge(self._var_data, _var._var_data)\n        super().__setitem__(key, value)\n------------------------------\n------------------------------\nArgs:\n            json: Whether to convert to a JSON string.\n\n        Returns:\n            The stringified var.\n        \"\"\"\n        fn = \"JSON.stringify\" if json else \"String\"\n        return self.operation(fn=fn, type_=str)\n\n    def to_int(self) -> Var:\n        \"\"\"Convert a var to an int.\n\n        Returns:\n            The parseInt var.\n        \"\"\"\n        return self.operation(fn=\"parseInt\", type_=int)\n\n    def __hash__(self) -> int:\n        \"\"\"Define a hash function for a var.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n    if _var_is_local is not None or _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_local and _var_is_string arguments are not supported for ImmutableVar.\"\n        )\n    try:\n        return Var(value, _var_is_local, _var_is_string, _var_data)\n    except json.JSONDecodeError:\n        raise VarTypeError(\"The value is JSON-unserializable.\")\n```", "```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    if _var_is_local is not None or _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_local and _var_is_string arguments are not supported for ImmutableVar.\"\n        )\n\n    # Create a Var to collapse VarData encoded in f-string.\n    _var = Var.create(value, _var_is_string=False)\n    if _var is not None:\n        # Carry the imports/hooks when setting a Var as a value.\n        self._var_data = VarData.merge(self._var_data, _var._var_data)\n    super().__setitem__(key, value)\n```", "```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    \"\"\"Create a var from a value.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n\n    Raises:\n        VarTypeError: If the value is JSON-unserializable.\n    \"\"\"\n    # Code here...\n```"]}, "reflex-reflex/vars.py-create_safe": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n------------------------------\n------------------------------\n@classmethod\n    def create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n------------------------------\n------------------------------\nArgs:\n            key: The key to set.\n            value: The value to set.\n        \"\"\"\n        # Create a Var to collapse VarData encoded in f-string.\n        _var = Var.create(value, _var_is_string=False)\n        if _var is not None:\n            # Carry the imports/hooks when setting a Var as a value.\n            self._var_data = VarData.merge(self._var_data, _var._var_data)\n        super().__setitem__(key, value)\n------------------------------\n------------------------------\nclass Var:\n    \"\"\"An abstract var.\"\"\"\n\n    # The name of the var.\n    _var_name: str\n\n    # The type of the var.\n    _var_type: Type\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool\n\n    # Whether the var is a string literal.\n    _var_is_string: bool\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool\n\n    # Extra metadata associated with the Var\n    _var_data: Optional[VarData]\n\n    @classmethod\n------------------------------\n------------------------------\ndef const(name, value) -> Var:\n    \"\"\"Create a constant Var.\n\n    Args:\n        name: The name of the constant.\n        value: The value of the constant.\n\n    Returns:\n        The constant Var.\n    \"\"\"\n    if isinstance(name, list):\n        return Var.create_safe(\n            f\"const [{', '.join(name)}] = {value}\", _var_is_string=False\n        )\n    return Var.create_safe(f\"const {name} = {value}\", _var_is_string=False)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_safe(\n# Natural Language Annotations: \"\"\"Create a var from a value, asserting that it is not None.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_safe(\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n    \"\"\"Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    assert value is not None\n    return Var.create(value, _var_is_local=_var_is_local, _var_is_string=_var_is_string, _var_data=_var_data)\n```", "```python\ndef create_safe(\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n    \"\"\"Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    return Var.create(value, _var_is_local, _var_is_string, _var_data)\n```", "```python\ndef create_safe(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var:\n    \"\"\"Create a var from a value, asserting that it is not None.\"\"\"\n    assert value is not None, \"Value cannot be None\"\n    return Var.create(value, _var_is_local, _var_is_string, _var_data)\n```"]}, "reflex-reflex/vars.py-foreach": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The code to render the component.\n        \"\"\"\n        return self.component_fn(*self.get_prop_vars())\n------------------------------\n------------------------------\ndef call_event_fn(fn: Callable, arg: Union[Var, ArgsSpec]) -> list[EventSpec] | Var:\n    \"\"\"Call a function to a list of event specs.\n\n    The function should return a single EventSpec, a list of EventSpecs, or a\n    single Var. If the function takes in an arg, the arg will be passed to the\n    function. Otherwise, the function will be called with no args.\n\n    Args:\n        fn: The function to call.\n        arg: The argument to pass to the function.\n------------------------------\n------------------------------\nReturns:\n            The Var returned from calling the function.\n        \"\"\"\n        return self.fn(*args, **kwargs)\n------------------------------\n------------------------------\nArgs:\n            op: The operation to perform.\n            other: The other var to perform the operation on.\n            type_: The type of the operation result.\n            flip: Whether to flip the order of the operation.\n            fn: A function to apply to the operation.\n            invoke_fn: Whether to invoke the function.\n\n        Returns:\n            The operation result.\n------------------------------\n------------------------------\nReturns:\n            A var representing the type check.\n        \"\"\"\n        return self._replace(\n            _var_name=f\"typeof {self._var_full_name}\",\n            _var_type=str,\n            _var_is_string=False,\n            _var_full_name_needs_state_prefix=False,\n        )\n\n    def __eq__(self, other: Union[Var, Type]) -> Var:\n        \"\"\"Perform an equality comparison.\n\n        Args:\n            other: The other var to compare with.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def foreach(self, fn: Callable) -> Var:\n# Natural Language Annotations: \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Perform a foreach operation on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not isinstance(self, Var):\n        raise VarTypeError(\"The var must be of type Var.\")\n\n    if not isinstance(self._var_type, list):\n        raise VarTypeError(\"The var must be a list.\")\n\n    return [fn(x) for x in self._var_type]\n```", "```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components. after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not isinstance(self, list):\n        raise VarTypeError(\"The var is not a list.\")\n\n    return [fn(i) for i in self]\n```", "```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components. after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if isinstance(self, list):\n        return [fn(i) for i in self]\n    else:\n        raise VarTypeError(\"Var is not a list.\")\n```"]}, "reflex-reflex/vars.py-get_default_value": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            prop: The var to set the default value for.\n        \"\"\"\n        # Get the pydantic field for the var.\n        field = cls.get_fields()[prop._var_name]\n        if field.required:\n            default_value = prop.get_default_value()\n            if default_value is not None:\n                field.required = False\n                field.default = default_value\n        if (\n            not field.required\n            and field.default is None\n------------------------------\n------------------------------\nReturns:\n            The value of the var.\n        \"\"\"\n        # If the state hasn't been initialized yet, return the default value.\n        if not super().__getattribute__(\"__dict__\"):\n            return super().__getattribute__(name)\n\n        inherited_vars = {\n            **super().__getattribute__(\"inherited_vars\"),\n            **super().__getattribute__(\"inherited_backend_vars\"),\n        }\n------------------------------\n------------------------------\n# match cases and default should all be Vars at this point.\n        # Retrieve var data of every var in the match cases and default.\n        var_data = [\n            *[el._var_data for case in match_cases for el in case],\n            default._var_data,  # type: ignore\n        ]\n------------------------------\n------------------------------\nArgs:\n            var: The variable to add a pydantic field for.\n            default_value: The default value of the field\n        \"\"\"\n        new_field = ModelField.infer(\n            name=var._var_name,\n            value=default_value,\n            annotation=var._var_type,\n            class_validators=None,\n            config=cls.__config__,  # type: ignore\n        )\n        cls.__fields__.update({var._var_name: new_field})\n------------------------------\n------------------------------\n# Validate the match cases (as well as the default case) to have Var return types.\n        if any(\n            case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n        ) or not types._isinstance(default, BaseVar):\n            raise ValueError(\"Return types of match cases should be Vars.\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_default_value(self) -> Any:\n# Natural Language Annotations: \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_default_value(self) -> Any:\n    field = self.get_fields()[self._var_name]\n    if field.required:\n        default_value = self.get_default_value()\n        if default_value is not None:\n            field.required = False\n            field.default = default_value\n    if (\n        not field.required\n        and field.default is None\n    ):\n        raise ValueError(\"Default value not set.\")\n    return field.default\n```\n------------------------------\n```python\ndef get_value(self, name: str) -> Any:\n    if not super().__getattribute__(\"__dict__\"):\n        return super().__getattribute__(name)\n    inherited_vars = {\n        **super().__getattribute__(\"inherited_vars\"),\n        **super().__getattribute__(\"inherited_backend_vars\"),\n    }\n    return inherited_vars.get(name, self.__getattribute__(name))\n```\n------------------------------\n```python\ndef add_var_field(self, var: Var, default_value: Any) -> None:\n    new_field = ModelField.infer(\n        name=var._var_name,\n        value=default_value,\n        annotation=var._var_type,\n        class_validators=None,\n        config=self.__config__,  # type: ignore\n    )\n    self.__fields__.update({var._var_name: new_field})\n```\n------------------------------\n```python\ndef validate_match_cases(self, match_cases: List[List[Var]], default: Var) -> None:\n    if any(\n        case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n    ) or not types._isinstance(default, BaseVar):\n        raise ValueError(\"Return types of match cases should be Vars.\")\n```\n------------------------------\n```python\ndef get_default_value(self) -> Any:\n    # Get the pydantic field for the var.\n    field = self.get_fields()[self._var_name]\n\n    # If the var is required and has a default value,\n    # set the field required to False and set the default value.\n    if field.required:\n        default_value = self.get_default_value()\n        if default_value is not None:\n            field.required = False\n            field.default = default_value\n\n    # If the field is not required and its default value is None,\n    # raise a ValueError.\n    if (\n        not field.required\n        and field.default is None\n    ):\n        raise ValueError(\"Default value not set.\")\n\n    # Return the field default value.\n    return field.default\n```", "```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\"\"\"\n\n    # Get the pydantic field for the var.\n    field = self.get_fields()[self._var_name]\n    if field.required:\n        default_value = self.get_default_value()\n        if default_value is not None:\n            field.required = False\n            field.default = default_value\n    if (\n        not field.required\n        and field.default is None\n    ):\n        raise ValueError(\"Default value not set.\")\n\n    # If the state hasn't been initialized yet, return the default value.\n    if not super().__getattribute__(\"__dict__\"):\n        return super().__getattribute__(self._var_name)\n\n    inherited_vars = {\n        **super().__getattribute__(\"inherited_vars\"),\n        **super().__getattribute__(\"inherited_backend_vars\"),\n    }\n\n    # match cases and default should all be Vars at this point.\n    # Retrieve var data of every var in the match cases and default.\n    var_data = [\n        *[el._var_data for case in match_cases for el in case],\n        default._var_data,  # type: ignore\n    ]\n\n    # Validate the match cases (as well as the default case) to have Var return types.\n    if any(\n        case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n    ) or not types._isinstance(default, BaseVar):\n        raise ValueError(\"Return types of match cases should be Vars.\")\n\n    # Get the default value of the var.\n    new_field = ModelField.infer(\n        name=self._var_name,\n        value=default_value,\n        annotation=self._var_type,\n        class_validators=None,\n        config=self.__config__,  # type: ignore\n    )\n    self.__fields__.update({self._var_name: new_field})\n```", "```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\"\"\"\n\n    # Get the pydantic field for the var.\n    field = self.__class__.get_fields()[self._var_name]\n    if field.required:\n        default_value = self.get_default_value()\n        if default_value is not None:\n            field.required = False\n            field.default = default_value\n    if (\n        not field.required\n        and field.default is None\n    ):\n        raise ValueError(\"Default value cannot be None.\")\n\n    # If the state hasn't been initialized yet, return the default value.\n    if not super().__getattribute__(\"__dict__\"):\n        return super().__getattribute__(self._var_name)\n\n    inherited_vars = {\n        **super().__getattribute__(\"inherited_vars\"),\n        **super().__getattribute__(\"inherited_backend_vars\"),\n    }\n\n    # match cases and default should all be Vars at this point.\n    # Retrieve var data of every var in the match cases and default.\n    var_data = [\n        *[el._var_data for case in match_cases for el in case],\n        default._var_data,  # type: ignore\n    ]\n\n    # Validate the match cases (as well as the default case) to have Var return types.\n    if any(\n        case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n    ) or not types._isinstance(default, BaseVar):\n        raise ValueError(\"Return types of match cases should be Vars.\")\n```"]}, "reflex-reflex/state.py-get_skip_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n        The serialized value, or None if a serializer is not found.\n    \"\"\"\n    # Get the serializer for the type.\n    serializer = get_serializer(type(value))\n\n    # If there is no serializer, return None.\n    if serializer is None:\n        if get_type:\n            return None, None\n        return None\n\n    # Serialize the value.\n    serialized = serializer(value)\n------------------------------\n------------------------------\ndef serialize_str(value: str) -> str:\n    \"\"\"Serialize a string.\n\n    Args:\n        value: The string to serialize.\n\n    Returns:\n        The serialized string.\n    \"\"\"\n    return value\n------------------------------\n------------------------------\ndef get_serializer(type_: Type) -> Optional[Serializer]:\n    \"\"\"Get the serializer for the type.\n\n    Args:\n        type_: The type to get the serializer for.\n\n    Returns:\n        The serializer for the type, or None if there is no serializer.\n    \"\"\"\n    # First, check if the type is registered.\n    serializer = SERIALIZERS.get(type_)\n    if serializer is not None:\n        return serializer\n------------------------------\n------------------------------\ndef get_serializer_type(type_: Type) -> Optional[Type]:\n    \"\"\"Get the converted type for the type after serializing.\n\n    Args:\n        type_: The type to get the serializer type for.\n\n    Returns:\n        The serialized type for the type, or None if there is no type conversion registered.\n    \"\"\"\n    # First, check if the type is registered.\n    serializer = SERIALIZER_TYPES.get(type_)\n    if serializer is not None:\n        return serializer\n------------------------------\n------------------------------\ndef serialize(\n    value: Any, get_type: bool = False\n) -> Union[\n    Optional[SerializedType],\n    Tuple[Optional[SerializedType], Optional[types.GenericType]],\n]:\n    \"\"\"Serialize the value to a JSON string.\n\n    Args:\n        value: The value to serialize.\n        get_type: Whether to return the type of the serialized value.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_skip_vars(cls) -> set[str]:\n# Natural Language Annotations: \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\"\"\"\n    # Get the vars to skip when serializing.\n    skip_vars = getattr(cls, \"__skip_vars__\", set())\n\n    # Get the superclass vars to skip when serializing.\n    for base in cls.__bases__:\n        skip_vars |= get_skip_vars(base)\n\n    return skip_vars\n```", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\"\"\"\n    skip_vars = set()\n    for var_name in vars(cls):\n        if var_name.startswith(\"_\"):\n            skip_vars.add(var_name)\n    return skip_vars\n```", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\"\"\"\n    skip_vars = set()\n    for var in vars(cls):\n        if var.startswith(\"__\"):\n            skip_vars.add(var)\n    return skip_vars\n```"]}, "reflex-reflex/state.py-add_var": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@classmethod\n    def add_field(cls, var: Any, default_value: Any):\n        \"\"\"Add a pydantic field after class definition.\n\n        Used by State.add_var() to correctly handle the new variable.\n------------------------------\n------------------------------\nArgs:\n            var: The variable to add a pydantic field for.\n            default_value: The default value of the field\n        \"\"\"\n        new_field = ModelField.infer(\n            name=var._var_name,\n            value=default_value,\n            annotation=var._var_type,\n            class_validators=None,\n            config=cls.__config__,  # type: ignore\n        )\n        cls.__fields__.update({var._var_name: new_field})\n------------------------------\n------------------------------\ndef useState(var_name, default=None) -> Var:\n    \"\"\"Create a useState hook with a variable name and setter name.\n\n    Args:\n        var_name: The name of the variable.\n        default: The default value of the variable.\n------------------------------\n------------------------------\nArgs:\n                state: The state within which we add the setter function.\n                value: The value to set.\n            \"\"\"\n            if self._var_type in [int, float]:\n                try:\n                    value = self._var_type(value)\n                    setattr(state, self._var_name, value)\n                except ValueError:\n                    console.debug(\n------------------------------\n------------------------------\nArgs:\n            name: The name of the attribute.\n            value: The value of the attribute.\n        \"\"\"\n        if isinstance(value, MutableProxy):\n            # unwrap proxy objects when assigning back to the state\n            value = value.__wrapped__\n\n        # Set the var on the parent state.\n        inherited_vars = {**self.inherited_vars, **self.inherited_backend_vars}\n        if name in inherited_vars:\n            setattr(self.parent_state, name, value)\n            return\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_var(cls, name: str, type_: Any, default_value: Any = None):\n# Natural Language Annotations: \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"A variable named '{name}' already exists.\")\n\n    setattr(cls, name, default_value)\n    cls.add_field(name, default_value)\n```", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"Variable {name} already exists\")\n\n    new_field = ModelField.infer(\n        name=name,\n        value=default_value,\n        annotation=type_,\n        class_validators=None,\n        config=cls.__config__,  # type: ignore\n    )\n    setattr(cls, name, default_value)\n    cls.__fields__.update({name: new_field})\n```", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    if hasattr(cls, name):\n        raise NameError(f\"A variable of name {name} already exists\")\n\n    new_field = ModelField.infer(\n        name=name,\n        value=default_value,\n        annotation=type_,\n        class_validators=None,\n        config=cls.__config__,  # type: ignore\n    )\n    cls.__fields__.update({name: new_field})\n```"]}, "reflex-reflex/state.py-reset": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Validate the match cases (as well as the default case) to have Var return types.\n        if any(\n            case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n        ) or not types._isinstance(default, BaseVar):\n            raise ValueError(\"Return types of match cases should be Vars.\")\n------------------------------\n------------------------------\nReturns:\n            The prop vars.\n        \"\"\"\n        return [\n            BaseVar(\n                _var_name=name,\n                _var_type=(\n                    prop._var_type if types._isinstance(prop, Var) else type(prop)\n                ),\n            )\n            for name, prop in self.props.items()\n        ]\n\n    def _get_vars(self, include_children: bool = False) -> list[Var]:\n        \"\"\"Walk all Vars used in this component.\n------------------------------\n------------------------------\n# all values should be back to their defaults\n    c1 = driver.find_element(By.ID, \"c1\")\n    c2 = driver.find_element(By.ID, \"c2\")\n    c3 = driver.find_element(By.ID, \"c3\")\n    c4 = driver.find_element(By.ID, \"c4\")\n    c5 = driver.find_element(By.ID, \"c5\")\n    c6 = driver.find_element(By.ID, \"c6\")\n    c7 = driver.find_element(By.ID, \"c7\")\n    l1 = driver.find_element(By.ID, \"l1\")\n    l2 = driver.find_element(By.ID, \"l2\")\n    l3 = driver.find_element(By.ID, \"l3\")\n------------------------------\n------------------------------\ndef cond(condition: Any, c1: Any, c2: Any) -> BaseVar: ...\n------------------------------\n------------------------------\n# match cases and default should all be Vars at this point.\n        # Retrieve var data of every var in the match cases and default.\n        var_data = [\n            *[el._var_data for case in match_cases for el in case],\n            default._var_data,  # type: ignore\n        ]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def reset(self):\n# Natural Language Annotations: \"\"\"Reset all the base vars to their default values.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    for name, prop in self.props.items():\n        if isinstance(prop, BaseVar):\n            prop.reset()\n```", "```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    for var in self.base_vars:\n        var.value = var.default_value\n```", "```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    for base_var in self.base_vars:\n        base_var._var_data = base_var._default_value\n```"]}, "reflex-reflex/state.py-get_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get an instance of the state associated with this token.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The state.\n------------------------------\n------------------------------\nReturns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\n        if self.parent_state is None:\n            root_state = self\n        else:\n            root_state = self._get_parent_states()[-1][1]\n        return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n\n    async def _get_state_from_redis(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get a state instance from redis.\n------------------------------\n------------------------------\nArgs:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n\n        Raises:\n            RuntimeError: If redis is not used in this backend process.\n        \"\"\"\n        # Fetch all missing parent states from redis.\n        parent_state_of_state_cls = await self._populate_parent_states(state_cls)\n------------------------------\n------------------------------\nasync def get_state(self, token: str) -> BaseState:\n        \"\"\"Get the state associated with the given token.\n\n        Args:\n            token: The state token to look up.\n\n        Returns:\n            The state instance associated with the given token\n------------------------------\n------------------------------\nArgs:\n            state: The state to start from.\n\n        Returns:\n            An instance of the top-level state (self.state).\n        \"\"\"\n        while type(state) != self.state and state.parent_state is not None:\n            state = state.parent_state\n        return state\n\n    async def _get_parent_state(self, token: str) -> BaseState | None:\n        \"\"\"Get the parent state for the state requested in the token.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n# Natural Language Annotations: \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    if self.parent_state is None:\n        root_state = self\n    else:\n        root_state = self._get_parent_states()[-1][1]\n    return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n```", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    if self.parent_state is None:\n        root_state = self\n    else:\n        root_state = self._get_parent_states()[-1][1]\n    return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n```", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    if self.parent_state is None:\n        root_state = self\n    else:\n        root_state = self._get_parent_states()[-1][1]\n    return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n```"]}, "reflex-reflex/state.py-_process": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nYields:\n        The state updates after processing the event.\n    \"\"\"\n    from reflex.utils import telemetry\n------------------------------\n------------------------------\nYields:\n                Each state update as JSON followed by a new line.\n            \"\"\"\n            # Process the event.\n            async with app.state_manager.modify_state(event.substate_token) as state:\n                async for update in state._process(event):\n                    # Postprocess the event.\n                    update = await app._postprocess(state, event, update)\n                    yield update.json() + \"\\n\"\n------------------------------\n------------------------------\n# Preprocess the event.\n            update = await app._preprocess(state, event)\n\n            # If there was an update, yield it.\n            if update is not None:\n                yield update\n------------------------------\n------------------------------\nYields:\n            tuple of (event_name, event_vars)\n        \"\"\"\n        for event_trigger, event in event_triggers.items():\n            if isinstance(event, Var):\n                yield event_trigger, [event]\n            elif isinstance(event, EventChain):\n                event_args = []\n                for spec in event.events:\n                    for args in spec.args:\n                        event_args.extend(args)\n                yield event_trigger, event_args\n------------------------------\n------------------------------\n# Process the event synchronously.\n                async for update in state._process(event):\n                    # Postprocess the event.\n                    update = await app._postprocess(state, event, update)\n\n                    # Yield the update.\n                    yield update\n    except Exception as ex:\n        telemetry.send_error(ex, context=\"backend\")\n        raise\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n# Natural Language Annotations: \"\"\"Obtain event info and process event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"\n    Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    try:\n        async with app.state_manager.modify_state(event.substate_token) as state:\n            async for update in state._process(event):\n                update = await app._postprocess(state, event, update)\n                yield update.json() + \"\\n\"\n    except Exception as ex:\n        telemetry.send_error(ex, context=\"backend\")\n        raise\n```", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    from reflex.utils import telemetry\n\n    try:\n        # Preprocess the event.\n        update = await self._preprocess(event)\n\n        # If there was an update, yield it.\n        if update is not None:\n            yield update\n\n        # Process the event synchronously.\n        async for update in self._process_sync(event):\n            # Postprocess the event.\n            update = await self._postprocess(event, update)\n\n            # Yield the update.\n            yield update\n    except Exception as ex:\n        telemetry.send_error(ex, context=\"backend\")\n        raise\n```", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Process the event synchronously.\n    async for update in state._process(event):\n        # Postprocess the event.\n        update = await app._postprocess(state, event, update)\n\n        # Yield the update.\n        yield update\n```"]}, "reflex-reflex/state.py-_dirty_computed_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _mark_dirty_computed_vars(self) -> None:\n        \"\"\"Mark ComputedVars that need to be recalculated based on dirty_vars.\"\"\"\n        dirty_vars = self.dirty_vars\n        while dirty_vars:\n            calc_vars, dirty_vars = dirty_vars, set()\n            for cvar in self._dirty_computed_vars(from_vars=calc_vars):\n                self.dirty_vars.add(cvar)\n                dirty_vars.add(cvar)\n                actual_var = self.computed_vars.get(cvar)\n------------------------------\n------------------------------\ndef _expired_computed_vars(self) -> set[str]:\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n        return set(\n            cvar\n            for cvar in self.computed_vars\n            if self.computed_vars[cvar].needs_update(instance=self)\n        )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n------------------------------\n------------------------------\n# Append expired computed vars to dirty_vars to trigger recalculation\n        self.dirty_vars.update(self._expired_computed_vars())\n\n        # have to mark computed vars dirty to allow access to newly computed\n        # values within the same ComputedVar function\n        self._mark_dirty_computed_vars()\n        self._mark_dirty_substates()\n------------------------------\n------------------------------\n# Mapping of var name to set of computed variables that depend on it\n    _computed_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Mapping of var name to set of substates that depend on it\n    _substate_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Set of vars which always need to be recomputed\n    _always_dirty_computed_vars: ClassVar[Set[str]] = set()\n------------------------------\n------------------------------\nReturns:\n            The object as a dictionary.\n        \"\"\"\n        if include_computed:\n            # Apply dirty variables down into substates to allow never-cached ComputedVar to\n            # trigger recalculation of dependent vars\n            self.dirty_vars.update(self._always_dirty_computed_vars)\n            self._mark_dirty()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _dirty_computed_vars(\n# Natural Language Annotations: \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _dirty_computed_vars(self, from_vars: set[str] = None, include_backend: bool = False) -> set[str]:\n    \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = self.dirty_vars\n    dirty_vars = set()\n    for cvar in from_vars:\n        if cvar in self._computed_var_dependencies:\n            for dependent_var in self._computed_var_dependencies[cvar]:\n                if include_backend or not dependent_var.startswith(\"_\"):\n                    dirty_vars.add(dependent_var)\n    return dirty_vars\n```", "```python\ndef _dirty_computed_vars(self, from_vars: set[str] = None, include_backend: bool = True) -> set[str]:\n    \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = self.dirty_vars\n\n    dirty_vars = set()\n    for var in from_vars:\n        if var in self._computed_var_dependencies:\n            dirty_vars.update(self._computed_var_dependencies[var])\n\n    if include_backend:\n        dirty_vars.update(self.backend_vars.keys())\n\n    return dirty_vars\n```", "```python\ndef _dirty_computed_vars(self, from_vars: set[str] = None, include_backend: bool = False) -> set[str]:\n    if from_vars is None:\n        from_vars = self.dirty_vars\n    cvars = set()\n    for cvar, actual_var in self.computed_vars.items():\n        if any(dep in from_vars for dep in self._computed_var_dependencies.get(cvar, set())):\n            if include_backend or not actual_var.is_backend:\n                cvars.add(cvar)\n    return cvars\n```"]}, "reflex-reflex/state.py-_potentially_dirty_substates": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nif all_substates:\n            # All substates are requested.\n            fetch_substates = state.get_substates()\n        else:\n            # Only _potentially_dirty_substates need to be fetched to recalc computed vars.\n            fetch_substates = state._potentially_dirty_substates()\n------------------------------\n------------------------------\n# Any substate containing a ComputedVar with cache=False always needs to be recomputed\n        if cls._always_dirty_computed_vars:\n            # Tell parent classes that this substate has always dirty computed vars\n            state_name = cls.get_name()\n            parent_state = cls.get_parent_state()\n            while parent_state is not None:\n                parent_state._always_dirty_substates.add(state_name)\n                state_name, parent_state = (\n------------------------------\n------------------------------\n# Set of substates which always need to be recomputed\n    _always_dirty_substates: ClassVar[Set[str]] = set()\n\n    # The parent state.\n    parent_state: Optional[BaseState] = None\n\n    # The substates of the state.\n    substates: Dict[str, BaseState] = {}\n\n    # The set of dirty vars.\n    dirty_vars: Set[str] = set()\n\n    # The set of dirty substates.\n    dirty_substates: Set[str] = set()\n\n    # The routing path that triggered the state\n    router_data: Dict[str, Any] = {}\n------------------------------\n------------------------------\n# Reset dirty substate tracking for this class.\n        cls._always_dirty_substates = set()\n\n        # Get the parent vars.\n        parent_state = cls.get_parent_state()\n        if parent_state is not None:\n            cls.inherited_vars = parent_state.vars\n            cls.inherited_backend_vars = parent_state.backend_vars\n------------------------------\n------------------------------\n# Mapping of var name to set of computed variables that depend on it\n    _computed_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Mapping of var name to set of substates that depend on it\n    _substate_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Set of vars which always need to be recomputed\n    _always_dirty_computed_vars: ClassVar[Set[str]] = set()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n# Natural Language Annotations: \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n        Returns:\n            Set of State classes that may need to be fetched to recalc computed vars.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\"\"\"\n\n    potentially_dirty_substates = set()\n    for var in cls.dirty_vars:\n        potentially_dirty_substates.update(cls._computed_var_dependencies.get(var, set()))\n        potentially_dirty_substates.update(cls._substate_var_dependencies.get(var, set()))\n\n    return potentially_dirty_substates\n```", "```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    potentially_dirty_substates = set()\n    for var in cls.dirty_vars:\n        potentially_dirty_substates.update(cls._computed_var_dependencies.get(var, set()))\n        potentially_dirty_substates.update(cls._substate_var_dependencies.get(var, set()))\n    return potentially_dirty_substates\n```", "```python\ndef _potentially_dirty_substates(cls) -> Set[Type[BaseState]]:\n    dirty_substates = set()\n\n    for var in cls.dirty_vars:\n        # Add all substates with computed vars depending on this var\n        dirty_substates.update(cls._computed_var_dependencies.get(var, set()))\n\n        # Add all substates with vars depending on this var\n        dirty_substates.update(cls._substate_var_dependencies.get(var, set()))\n\n    # Convert substate names to substate classes\n    potentially_dirty_substates = set(\n        cls.substates[substate_name] for substate_name in dirty_substates\n    )\n\n    return potentially_dirty_substates\n```"]}, "reflex-reflex/state.py-get_delta": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            state: The state to set or the full name of the state.\n\n        Returns:\n            The var with the set state.\n        \"\"\"\n        from reflex.utils import format\n------------------------------\n------------------------------\ndef get_event(state, event):\n    \"\"\"Get the event from the given state.\n\n    Args:\n        state: The state.\n        event: The event.\n\n    Returns:\n        The event.\n    \"\"\"\n    return f\"{state.get_name()}.{event}\"\n------------------------------\n------------------------------\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get an instance of the state associated with this token.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The state.\n------------------------------\n------------------------------\nReturns:\n            The state dict for serialization.\n        \"\"\"\n        state = super().__getstate__()\n        # Never serialize parent_state or substates\n        state[\"__dict__\"] = state[\"__dict__\"].copy()\n        state[\"__dict__\"][\"parent_state\"] = None\n        state[\"__dict__\"][\"substates\"] = {}\n        state[\"__dict__\"].pop(\"_was_touched\", None)\n        return state\n------------------------------\n------------------------------\nArgs:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_delta(self) -> Delta:\n# Natural Language Annotations: \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    # Your code here\n    pass\n```", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n```", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    # Your code here\n```"]}, "reflex-reflex/model.py-get_db_engine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_engine(url: str | None = None) -> sqlalchemy.engine.Engine:\n    \"\"\"Get the database engine.\n\n    Args:\n        url: the DB url to use.\n\n    Returns:\n        The database engine.\n------------------------------\n------------------------------\nReturns:\n            DBConfig instance.\n        \"\"\"\n        return cls(\n            engine=\"sqlite\",\n            database=database,\n        )\n\n    def get_url(self) -> str:\n        \"\"\"Get database URL.\n------------------------------\n------------------------------\n# get a reference to the counter\n    counter = driver.find_element(By.ID, \"counter\")\n\n    # get a reference to the iterations input\n    iterations_input = driver.find_element(By.ID, \"iterations\")\n------------------------------\n------------------------------\nArgs:\n            database: Database name.\n            username: Database username.\n            password: Database password.\n            host: Database host.\n            port: Database port.\n\n        Returns:\n            DBConfig instance.\n        \"\"\"\n        return cls(\n            engine=\"postgresql\",\n            username=username,\n            password=password,\n            host=host,\n            port=port,\n            database=database,\n        )\n------------------------------\n------------------------------\nReturns:\n            DBConfig instance.\n        \"\"\"\n        return cls(\n            engine=\"postgresql+psycopg2\",\n            username=username,\n            password=password,\n            host=host,\n            port=port,\n            database=database,\n        )\n\n    @classmethod\n    def sqlite(\n        cls,\n        database: str,\n    ) -> DBConfig:\n        \"\"\"Create an instance with sqlite engine.\n\n        Args:\n            database: Database name.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_db_engine():\n# Natural Language Annotations: \"\"\"Get the database engine.\n\n        Returns:\n            The database engine.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_db_engine():\n    \"\"\"\n    Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    return get_engine()\n```", "```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    # Here is where you would code to get the database engine\n```", "```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    # Replace with your actual database engine retrieval code\n    # For example, using sqlalchemy:\n    from sqlalchemy import create_engine\n    engine = create_engine('sqlite:///your_database.db')\n    return engine\n```"]}, "reflex-reflex/model.py-alembic_autogenerate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@classmethod\n    def _alembic_upgrade(\n        cls,\n        connection: sqlalchemy.engine.Connection,\n        to_rev: str = \"head\",\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n            to_rev: Revision to migrate towards.\n        \"\"\"\n        config, script_directory = cls._alembic_config()\n------------------------------\n------------------------------\ndef makemigrations(\n    message: str = typer.Option(\n        None, help=\"Human readable identifier for the generated revision.\"\n    ),\n):\n    \"\"\"Create autogenerated alembic migration scripts.\"\"\"\n    from alembic.util.exc import CommandError\n\n    from reflex import model\n    from reflex.utils import prerequisites\n------------------------------\n------------------------------\nThis method is called to provide python code for the given obj,\n        but currently it is only used to add `sqlmodel` to the import list\n        when generating migration scripts.\n\n        See https://alembic.sqlalchemy.org/en/latest/api/runtime.html\n------------------------------\n------------------------------\n# Check the alembic config.\n    if Path(constants.ALEMBIC_CONFIG).exists():\n        console.error(\n            \"Database is already initialized. Use \"\n            \"[bold]reflex db makemigrations[/bold] to create schema change \"\n            \"scripts and [bold]reflex db migrate[/bold] to apply migrations \"\n            \"to a new or existing database.\",\n        )\n        return\n------------------------------\n------------------------------\n\"\"\"Database built into Reflex.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import defaultdict\nfrom pathlib import Path\nfrom typing import Any, ClassVar, Optional, Type, Union\n\nimport alembic.autogenerate\nimport alembic.command\nimport alembic.config\nimport alembic.operations.ops\nimport alembic.runtime.environment\nimport alembic.script\nimport alembic.util\nimport sqlalchemy\nimport sqlalchemy.orm\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def alembic_autogenerate(\n# Natural Language Annotations: \"\"\"Generate migration scripts for alembic-detectable changes.\n\n        Args:\n            connection: SQLAlchemy connection to use when detecting changes.\n            message: Human readable identifier describing the generated revision.\n            write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n        Returns:\n            True when changes have been detected.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str,\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n\n    # Create a new migration script.\n    command.revision(config, message=message, autogenerate=True)\n\n    if write_migration_scripts:\n        # Execute the migration script.\n        command.upgrade(config, \"head\")\n        return True\n    else:\n        # Return False if no changes were detected.\n        return False\n```", "```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str,\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n    config.attributes['connection'] = connection\n\n    command.revision(config, message, autogenerate=True)\n\n    if write_migration_scripts:\n        script_dir_path = Path(config.get_main_option('script_location'))\n        script_dir_path.mkdir(exist_ok=True, parents=True)\n        script.write_scripts(config, script_dir_path, [])\n\n    return True\n```", "```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str = \"auto generated migration\",\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n\n    alembic_config = alembic.config.Config(file_=str(config))\n    script = alembic.script.ScriptDirectory.from_config(alembic_config)\n\n    def detect_migrations(connection, script, target_metadata):\n        context = alembic.migration.MigrationContext.configure(connection)\n        return script.get_revisions(context._version)\n\n    with connection.begin():\n        context = alembic.migration.MigrationContext.configure(connection)\n        result = detect_migrations(connection, script, context.opts['target_metadata'])\n\n    if result:\n        if write_migration_scripts:\n            command.revision(config, message=message, autogenerate=True)\n        return True\n\n    return False\n```"]}, "reflex-reflex/model.py-migrate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@classmethod\n    def _alembic_upgrade(\n        cls,\n        connection: sqlalchemy.engine.Connection,\n        to_rev: str = \"head\",\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n            to_rev: Revision to migrate towards.\n        \"\"\"\n        config, script_directory = cls._alembic_config()\n------------------------------\n------------------------------\ndef check_schema_up_to_date():\n    \"\"\"Check if the sqlmodel metadata matches the current database schema.\"\"\"\n    if get_config().db_url is None or not Path(constants.ALEMBIC_CONFIG).exists():\n        return\n    with model.Model.get_db_engine().connect() as connection:\n        try:\n            if model.Model.alembic_autogenerate(\n                connection=connection,\n                write_migration_scripts=False,\n            ):\n                console.error(\n------------------------------\n------------------------------\n# Check the alembic config.\n    if Path(constants.ALEMBIC_CONFIG).exists():\n        console.error(\n            \"Database is already initialized. Use \"\n            \"[bold]reflex db makemigrations[/bold] to create schema change \"\n            \"scripts and [bold]reflex db migrate[/bold] to apply migrations \"\n            \"to a new or existing database.\",\n        )\n        return\n------------------------------\n------------------------------\n# Initialize the database.\n    _skip_compile()\n    prerequisites.get_compiled_app()\n    model.Model.alembic_init()\n    model.Model.migrate(autogenerate=True)\n------------------------------\n------------------------------\ndef check_db_initialized() -> bool:\n    \"\"\"Check if the database migrations are initialized.\n\n    Returns:\n        True if alembic is initialized (or if database is not used).\n    \"\"\"\n    if get_config().db_url is not None and not Path(constants.ALEMBIC_CONFIG).exists():\n        console.error(\n            \"Database is not initialized. Run [bold]reflex db init[/bold] first.\"\n        )\n        return False\n    return True\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def migrate(cls, autogenerate: bool = False) -> bool | None:\n# Natural Language Annotations: \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n        If alembic is not installed or has not been initialized for the project,\n        then no action is performed.\n\n        If there are no revisions currently tracked by alembic, then\n        an initial revision will be created based on sqlmodel metadata.\n\n        If models in the app have changed in incompatible ways that alembic\n        cannot automatically generate revisions for, the app may not be able to\n        start up until migration scripts have been corrected by hand.\n\n        Args:\n            autogenerate: If True, generate migration script and use it to upgrade schema\n                (otherwise, just bring the schema to current \"head\" revision).\n\n        Returns:\n            True - indicating the process was successful.\n            None - indicating the process was skipped.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    if not cls.check_db_initialized():\n        return\n\n    with cls.get_db_engine().connect() as connection:\n        if cls.alembic_autogenerate(connection=connection, write_migration_scripts=autogenerate):\n            cls.alembic_upgrade(connection=connection)\n            return True\n\n    return None\n```", "```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    if not cls._is_alembic_installed() or not Path(constants.ALEMBIC_CONFIG).exists():\n        return None\n\n    with cls.get_db_engine().connect() as connection:\n        if cls.alembic_autogenerate(connection=connection, write_migration_scripts=autogenerate):\n            return True\n        else:\n            return False\n```", "```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    if model.Model.alembic_autogenerate(\n        connection=connection,\n        write_migration_scripts=False,\n    ):\n        return True\n    else:\n        return None\n```"]}, "reflex-reflex/model.py-select": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef ask(\n    question: str,\n    choices: list[str] | None = None,\n    default: str | None = None,\n    show_choices: bool = True,\n) -> str:\n    \"\"\"Takes a prompt question and optionally a list of choices\n     and returns the user input.\n\n    Args:\n        question: The question to ask the user.\n        choices: A list of choices to select from.\n        default: The default option selected.\n        show_choices: Whether to show the choices.\n------------------------------\n------------------------------\nReturns:\n        A string with the user input.\n    \"\"\"\n    return Prompt.ask(\n        question, choices=choices, default=default, show_choices=show_choices\n    )  # type: ignore\n------------------------------\n------------------------------\nReturns:\n            A list of keys.\n        \"\"\"\n        return self.driver.execute_script(\n            f\"var ls = window.{self.storage_key}, keys = []; \"\n            \"for (var i = 0; i < ls.length; ++i) \"\n            \"  keys[i] = ls.key(i); \"\n            \"return keys; \"\n        )\n\n    def get(self, key) -> str:\n        \"\"\"Get a key from local storage.\n\n        Args:\n            key: The key to get.\n------------------------------\n------------------------------\nReturns:\n            A var representing the greater than or equal to comparison.\n        \"\"\"\n        return self.compare(\">=\", other)\n\n    def __lt__(self, other: Var) -> Var:\n        \"\"\"Perform a less than comparison.\n\n        Args:\n            other: The other var to compare with.\n\n        Returns:\n            A var representing the less than comparison.\n        \"\"\"\n        return self.compare(\"<\", other)\n------------------------------\n------------------------------\nReturns:\n        new string containing keywords.\n    \"\"\"\n    # /posts -> /post\n    # /posts/[slug] -> /posts/__SINGLE_SEGMENT__\n    # /posts/[slug]/comments -> /posts/__SINGLE_SEGMENT__/comments\n    # /posts/[[slug]] -> /posts/__DOUBLE_SEGMENT__\n    # / posts/[[...slug2]]-> /posts/__DOUBLE_CATCHALL_SEGMENT__\n    # /posts/[...slug3]-> /posts/__SINGLE_CATCHALL_SEGMENT__\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def select(cls):\n# Natural Language Annotations: \"\"\"Select rows from the table.\n\n        Returns:\n            The select statement.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef select(cls):\n    \"\"\"Select rows from the table.\"\"\"\n\n    return cls.select()\n```", "```python\ndef select(cls):\n    \"\"\"Select rows from the table.\"\"\"\n    return \"SELECT * FROM \" + cls.__tablename__\n```", "```python\ndef select(cls):\n    \"\"\"Select rows from the table.\"\"\"\n    return cls.query.all()\n```"]}, "reflex-reflex/compiler/compiler.py-compile_components": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef compile_custom_component(\n    component: CustomComponent,\n) -> tuple[dict, ParsedImportDict]:\n    \"\"\"Compile a custom component.\n\n    Args:\n        component: The custom component to compile.\n\n    Returns:\n        A tuple of the compiled component and the imports required by the component.\n    \"\"\"\n    # Render the component.\n    render = component.get_component(component)\n------------------------------\n------------------------------\ndef _compile_components(\n    components: set[CustomComponent],\n) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the components.\n\n    Args:\n        components: The components to compile.\n\n    Returns:\n        The compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n------------------------------\n------------------------------\nReturns:\n            The path and code of the compiled custom components.\n\n        Raises:\n            ValueError: If the custom components are not set.\n        \"\"\"\n        if cls.CUSTOM_COMPONENTS is None:\n            raise ValueError(\"CUSTOM_COMPONENTS should be set\")\n        return compile_components(cls.CUSTOM_COMPONENTS)\n\n    @classmethod\n    def compile_theme(cls):\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n------------------------------\ndef _compile_component(component: Component | StatefulComponent) -> str:\n    \"\"\"Compile a single component.\n\n    Args:\n        component: The component to compile.\n\n    Returns:\n        The compiled component.\n    \"\"\"\n    return templates.COMPONENT.render(component=component)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def compile_components(\n# Natural Language Annotations: \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef compile_components(components: set[CustomComponent]) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n\n    for component in components:\n        render = component.get_component(component)\n        component_renders.append(render)\n\n    return \"/components\", \"\".join(component_renders)\n```", "```python\ndef compile_components(components: set[CustomComponent]) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n\n    for component in components:\n        render = component.get_component(component)\n        component_renders.append(render)\n\n    return (component_renders, imports)\n```", "```python\ndef compile_components(\n    components: set[CustomComponent],\n) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n\n    for component in components:\n        render = compile_custom_component(component)\n        component_renders.append(render)\n\n    return \"/components/path\", component_renders\n```"]}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nand not get_or_set_last_reflex_version_check_datetime()\n        ):\n            # only show a warning when the host version is outdated and\n            # the last_version_check_datetime is not set in reflex.json\n            console.warn(\n                f\"Your version ({current_version}) of {package_name} is out of date. Upgrade to {latest_version} with 'pip install {package_name} --upgrade'\"\n            )\n    except Exception:\n        pass\n------------------------------\n------------------------------\ndef get_reflex_version() -> str:\n    \"\"\"Get the Reflex version.\n\n    Returns:\n        The Reflex version.\n    \"\"\"\n    return constants.Reflex.VERSION\n------------------------------\n------------------------------\ndef version(value: bool):\n    \"\"\"Get the Reflex version.\n\n    Args:\n        value: Whether the version flag was passed.\n\n    Raises:\n        typer.Exit: If the version flag was passed.\n    \"\"\"\n    if value:\n        console.print(constants.Reflex.VERSION)\n        raise typer.Exit()\n------------------------------\n------------------------------\n\"\"\"The pyi generator module.\"\"\"\n\nimport logging\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom reflex.utils.pyi_generator import PyiGenerator, _relative_to_pwd\n\nlogger = logging.getLogger(\"pyi_generator\")\n\nLAST_RUN_COMMIT_SHA_FILE = Path(\".pyi_generator_last_run\").resolve()\nGENERATOR_FILE = Path(__file__).resolve()\nGENERATOR_DIFF_FILE = Path(\".pyi_generator_diff\").resolve()\nDEFAULT_TARGETS = [\"reflex/components\", \"reflex/experimental\", \"reflex/__init__.py\"]\n------------------------------\n------------------------------\nif existing_init_reflex_version is None:\n        # They clone a reflex app from git for the first time.\n        # That app may or may not be 0.4 compatible.\n        # So let's just show these instructions THIS TIME.\n        return True\n\n    if constants.Reflex.VERSION < \"0.4\":\n        return False\n    else:\n        return existing_init_reflex_version < \"0.4\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_or_set_last_reflex_version_check_datetime():\n# Natural Language Annotations: \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nimport datetime\nimport json\nfrom pathlib import Path\n\ndef get_or_set_last_reflex_version_check_datetime() -> datetime.datetime:\n    \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    reflex_json_path = Path(\".reflex.json\")\n\n    if reflex_json_path.exists():\n        with reflex_json_path.open() as f:\n            reflex_json = json.load(f)\n        if \"last_version_check_datetime\" in reflex_json:\n            return datetime.datetime.strptime(reflex_json[\"last_version_check_datetime\"], \"%Y-%m-%d %H:%M:%S.%f\")\n\n    now = datetime.datetime.now()\n    with reflex_json_path.open(\"w\") as f:\n        json.dump({\"last_version_check_datetime\": now.strftime(\"%Y-%m-%d %H:%M:%S.%f\")}, f)\n\n    return now\n```", "```python\nimport datetime\nimport json\nfrom pathlib import Path\n\nREFLEX_JSON_FILE = Path(\"reflex.json\")\n\ndef get_or_set_last_reflex_version_check_datetime() -> datetime:\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    try:\n        with open(REFLEX_JSON_FILE, \"r\") as f:\n            data = json.load(f)\n\n        if \"last_version_check_datetime\" in data:\n            return datetime.datetime.strptime(data[\"last_version_check_datetime\"], \"%Y-%m-%d %H:%M:%S\")\n        else:\n            current_time = datetime.datetime.now()\n            data[\"last_version_check_datetime\"] = current_time.strftime(\"%Y-%m-%d %H:%M:%S\")\n            with open(REFLEX_JSON_FILE, \"w\") as f:\n                json.dump(data, f)\n            return current_time\n    except Exception:\n        return datetime.datetime.now()\n```", "```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    try:\n        with open(constants.LAST_VERSION_CHECK_DATETIME_FILE, \"r\") as f:\n            last_check_datetime = datetime.strptime(f.read().strip(), \"%Y-%m-%d %H:%M:%S.%f\")\n    except (FileNotFoundError, ValueError):\n        last_check_datetime = None\n\n    # If the file does not exist, or the datetime cannot be parsed,\n    # set the last check datetime to now and write it to the file.\n    if last_check_datetime is None:\n        last_check_datetime = datetime.now()\n        with open(constants.LAST_VERSION_CHECK_DATETIME_FILE, \"w\") as f:\n            f.write(last_check_datetime.strftime(\"%Y-%m-%d %H:%M:%S.%f\"))\n\n    return last_check_datetime\n```"]}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nThis is where middleware can modify the event before it is processed.\n        Each middleware is called in the order it was added to the app.\n\n        If a middleware returns an update, the event is not processed and the\n        update is returned.\n\n        Args:\n            state: The state to preprocess.\n            event: The event to preprocess.\n------------------------------\n------------------------------\nclass Middleware(Base, ABC):\n    \"\"\"Middleware to preprocess and postprocess requests.\"\"\"\n\n    async def preprocess(\n        self, app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate]:\n        \"\"\"Preprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional state update to return.\n        \"\"\"\n        return None\n------------------------------\n------------------------------\nArgs:\n            middleware: The middleware to add.\n            index: The index to add the middleware at.\n        \"\"\"\n        if index is None:\n            self.middleware.append(middleware)\n        else:\n            self.middleware.insert(index, middleware)\n\n    async def _preprocess(self, state: BaseState, event: Event) -> StateUpdate | None:\n        \"\"\"Preprocess the event.\n------------------------------\n------------------------------\nReturns:\n            An optional state to return.\n        \"\"\"\n        for middleware in self.middleware:\n            if asyncio.iscoroutinefunction(middleware.preprocess):\n                out = await middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            else:\n                out = middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            if out is not None:\n                return out  # type: ignore\n------------------------------\n------------------------------\nasync def _postprocess(\n        self, state: BaseState, event: Event, update: StateUpdate\n    ) -> StateUpdate:\n        \"\"\"Postprocess the event.\n\n        This is where middleware can modify the delta after it is processed.\n        Each middleware is called in the order it was added to the app.\n\n        Args:\n            state: The state to postprocess.\n            event: The event to postprocess.\n            update: The current state update.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def preprocess(\n# Natural Language Annotations: \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def preprocess(\n        app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate | List[StateUpdate]]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    for middleware in app.middleware:\n        if asyncio.iscoroutinefunction(middleware.preprocess):\n            out = await middleware.preprocess(app=app, state=state, event=event)  # type: ignore\n        else:\n            out = middleware.preprocess(app=app, state=state, event=event)  # type: ignore\n        if out is not None:\n            return out  # type: ignore\n    return None\n```", "```python\nasync def preprocess(\n    app: App, \n    state: BaseState, \n    event: Event\n) -> Optional[Union[StateUpdate, List[StateUpdate]]]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    for middleware in self.middleware:\n        if asyncio.iscoroutinefunction(middleware.preprocess):\n            out = await middleware.preprocess(app=app, state=state, event=event)\n        else:\n            out = middleware.preprocess(app=app, state=state, event=event)\n        if out is not None:\n            return out\n    return None\n```", "```python\nasync def preprocess(app: App, state: BaseState, event: Event) -> Optional[StateUpdate]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional state update to return.\n    \"\"\"\n    for middleware in self.middleware:\n        if asyncio.iscoroutinefunction(middleware.preprocess):\n            out = await middleware.preprocess(app=app, state=state, event=event)  # type: ignore\n        else:\n            out = middleware.preprocess(app=app, state=state, event=event)  # type: ignore\n        if out is not None:\n            return out  # type: ignore\n```"]}, "reflex-reflex/components/component.py-get_event_triggers": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\n------------------------------\n------------------------------\ndef get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\n------------------------------\n------------------------------\nReturns:\n            A dict of event trigger name to a tuple of the memoized event trigger Var and\n            the hook code that memoizes the event handler.\n        \"\"\"\n        trigger_memo = {}\n        for event_trigger, event_args in component._get_vars_from_event_triggers(\n            component.event_triggers\n        ):\n            if event_trigger in {\n                EventTriggers.ON_MOUNT,\n                EventTriggers.ON_UNMOUNT,\n                EventTriggers.ON_SUBMIT,\n------------------------------\n------------------------------\nfor child in children:\n            validate_child(child)\n\n    @staticmethod\n    def _get_vars_from_event_triggers(\n        event_triggers: dict[str, EventChain | Var],\n    ) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\n\n        Args:\n            event_triggers: The event triggers from the component instance.\n------------------------------\n------------------------------\nReturns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        return dict(\n            tag.add_props(\n                **self.event_triggers,\n                key=self.key,\n                sx=self.style,\n                id=self.id,\n                class_name=self.class_name,\n            ).set(\n                props=tag.format_props(),\n            ),\n            cond_state=f\"isTrue({self.cond._var_full_name})\",\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_event_triggers(self) -> Dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    trigger_memo = {}\n    for event_trigger, event_args in component._get_vars_from_event_triggers(\n        component.event_triggers\n    ):\n        if event_trigger in {\n            EventTriggers.ON_MOUNT,\n            EventTriggers.ON_UNMOUNT,\n            EventTriggers.ON_SUBMIT,\n        }:\n            trigger_memo[event_trigger] = (event_args, self._memoize_event_trigger(event_args))\n    return trigger_memo\n```", "```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\"\"\"\n\n    trigger_memo = {}\n    for event_trigger, event_args in component._get_vars_from_event_triggers(\n        component.event_triggers\n    ):\n        if event_trigger in {\n            EventTriggers.ON_MOUNT,\n            EventTriggers.ON_UNMOUNT,\n            EventTriggers.ON_SUBMIT,\n        }:\n            trigger_memo[event_trigger] = event_args\n\n    return trigger_memo\n```", "```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    trigger_memo = {}\n    for event_trigger, event_args in component._get_vars_from_event_triggers(component.event_triggers):\n        if event_trigger in {EventTriggers.ON_MOUNT, EventTriggers.ON_UNMOUNT, EventTriggers.ON_SUBMIT}:\n            trigger_memo[event_trigger] = (event_args, component._hook_code_that_memoizes_event_handler(event_args))\n    return trigger_memo\n```"]}, "reflex-reflex/components/component.py-get_props": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n------------------------------\nReturns:\n            The code to render the component.\n        \"\"\"\n        return self.component_fn(*self.get_prop_vars())\n------------------------------\n------------------------------\nReturns:\n            The components props.\n        \"\"\"\n        return {\n            name\n            for name, field in cls.get_fields().items()\n            if name in cls.get_props()\n            and types._issubclass(field.outer_type_, Component)\n        }\n\n    @classmethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def add_style(self) -> dict[str, Any] | None:\n        \"\"\"Add style to the component.\n------------------------------\n------------------------------\nReturns:\n            The hash of the component.\n        \"\"\"\n        return hash(self.tag)\n\n    @classmethod\n    def get_props(cls) -> Set[str]:\n        \"\"\"Get the props for the component.\n\n        Returns:\n            The set of component props.\n        \"\"\"\n        return set()\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> Set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n------------------------------\n------------------------------\nReturns:\n            The set of custom components.\n        \"\"\"\n        custom_components = super()._get_all_custom_components(seen=seen)\n\n        # Get the custom components for each tag.\n        for component in self.component_map.values():\n            custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n                seen=seen\n            )\n\n        return custom_components\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_props(cls) -> Set[str]:\n# Natural Language Annotations: \"\"\"Get the unique fields for the component.\n\n        Returns:\n            The unique fields.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["def get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return {\n        name\n        for name, field in cls.get_fields().items()\n        if name in cls.get_props()\n        and types._issubclass(field.outer_type_, Component)\n    }", "```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return {\n        name\n        for name, field in cls.get_fields().items()\n        if name in cls.get_props()\n        and types._issubclass(field.outer_type_, Component)\n    }\n```", "```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set()\n```"]}, "reflex-reflex/components/component.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of item to add as child of the component.\n            **props: The properties of the component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return cls(*children, **props)\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\"\"\"\n\n    # Initialize the component with the provided props.\n    component = cls(**props)\n\n    # Add all children to the component.\n    for child in children:\n        component.append(child)\n\n    # Return the created component.\n    return component\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\"\"\"\n\n    # Create the component with the given children and props\n    component = cls(*children, **props)\n\n    return component\n```"]}, "reflex-reflex/components/component.py-_add_style_recursive": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn _compile_component(self)\n\n    def _apply_theme(self, theme: Optional[Component]):\n        \"\"\"Apply the theme to this component.\n\n        Deprecated. Use add_style instead.\n\n        Args:\n            theme: The theme to apply.\n        \"\"\"\n        pass\n\n    def apply_theme(self, theme: Optional[Component]):\n        \"\"\"Apply a theme to the component and its children.\n------------------------------\n------------------------------\nDownstream components can override this method to return a style dict\n        that will be applied to the component.\n\n        Returns:\n            The style to add.\n        \"\"\"\n        return None\n\n    def _add_style(self) -> Style:\n        \"\"\"Call add_style for all bases in the MRO.\n\n        Downstream components should NOT override. Use add_style instead.\n\n        Returns:\n            The style to add.\n        \"\"\"\n        styles = []\n------------------------------\n------------------------------\nreturn super().create(*children, value=value, **props, class_name=cls_name)\n\n    def add_style(self) -> dict[str, Any] | None:\n        \"\"\"Add style to the component.\n------------------------------\n------------------------------\nArgs:\n            theme: The theme to apply.\n        \"\"\"\n        self._apply_theme(theme)\n        for child in self.children:\n            if isinstance(child, Component):\n                child.apply_theme(theme)\n\n    def _exclude_props(self) -> list[str]:\n        \"\"\"Props to exclude when adding the component props to the Tag.\n\n        Returns:\n            A list of component props to exclude.\n        \"\"\"\n        return []\n------------------------------\n------------------------------\ndef add_style(self) -> dict[str, Any] | None:\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return {\n            \"direction\": \"column\",\n            \"list_style_position\": \"inside\",\n        }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_style_recursive(\n# Natural Language Annotations: \"\"\"Add additional style to the component and its children.\n\n        Apply order is as follows (with the latest overriding the earliest):\n        1. Default style from `_add_style`/`add_style`.\n        2. User-defined style from `App.style`.\n        3. User-defined style from `Component.style`.\n        4. style dict and css props passed to the component instance.\n\n        Args:\n            style: A dict from component to styling.\n            theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n        Raises:\n            UserWarning: If `_add_style` has been overridden.\n\n        Returns:\n            The component with the additional style.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _add_style_recursive(self, style: dict[str, Any], theme: Optional[Component] = None):\n    if theme is not None:\n        self._apply_theme(theme)\n\n    if isinstance(self, Component) and self._add_style() is not None:\n        raise UserWarning(\"_add_style has been overridden\")\n\n    if isinstance(self, Component) and self.add_style() is not None:\n        style.update(self.add_style())\n\n    if self.style is not None:\n        style.update(self.style)\n\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(style, theme)\n\n    return style\n```", "```python\ndef _add_style_recursive(self, style: dict[str, Any] = None, theme: Optional[Component] = None) -> Component:\n    if self._add_style.__name__ != \"_add_style\":\n        raise UserWarning(\"_add_style has been overridden. Please ensure to use add_style.\")\n\n    self._apply_theme(theme)\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(style=style, theme=theme)\n\n    default_style = self._add_style()\n    if default_style:\n        style = {**default_style, **(style or {})}\n\n    if self.style:\n        style = {**style, **self.style}\n\n    if self.css_props:\n        style = {**style, **self.css_props}\n\n    self.style = style\n    return self\n```", "```python\ndef _add_style_recursive(self, style: dict[str, Any], theme: Optional[Component]):\n    if self._add_style and self._add_style.__name__ != \"_add_style\":\n        raise UserWarning(\"_add_style has been overridden\")\n\n    # Adding default style from _add_style or add_style\n    default_style = self._add_style() if self._add_style else self.add_style()\n\n    # Applying user-defined style from App.style or Component.style\n    if hasattr(self, \"App\") and hasattr(self.App, \"style\"):\n        user_style = self.App.style\n    elif hasattr(self, \"style\") and self.style:\n        user_style = self.style\n\n    # Merging all styles\n    merged_style = {**style, **default_style, **user_style}\n\n    # Applying the theme\n    self._apply_theme(theme)\n\n    # Adding style to children\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(merged_style, theme)\n\n    return self\n```"]}, "reflex-reflex/components/component.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        return dict(\n            tag.add_props(\n                **self.event_triggers,\n                key=self.key,\n                sx=self.style,\n                id=self.id,\n                class_name=self.class_name,\n            ).set(\n                props=tag.format_props(),\n            ),\n            cond_state=f\"isTrue({self.cond._var_full_name})\",\n        )\n------------------------------\n------------------------------\nreturn IterTag(\n            iterable=self.iterable,\n            render_fn=self.render_fn,\n            children=self.children,\n            **props,\n        )\n\n    def render(self):\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n------------------------------\n------------------------------\n# List here the dependencies that need to be transpiled by Next.js\n    transpile_packages: List[str] = []\n\n    # The tag to use when rendering the component.\n    tag: Optional[str] = None\n\n    @abstractmethod\n    def render(self) -> dict:\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of the component.\n        \"\"\"\n------------------------------\n------------------------------\ndef _render(self) -> Tag:\n        return MatchTag(\n            cond=self.cond, match_cases=self.match_cases, default=self.default\n        )\n\n    def render(self) -> Dict:\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        tag.name = \"match\"\n        return dict(tag)\n\n    def add_imports(self) -> ImportDict:\n        \"\"\"Add imports for the Match component.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self) -> Dict:\n# Natural Language Annotations: \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef render(self) -> Dict:\n    tag = self._render()\n    return dict(\n        tag.add_props(\n            **self.event_triggers,\n            key=self.key,\n            sx=self.style,\n            id=self.id,\n            class_name=self.class_name,\n        ).set(\n            props=tag.format_props(),\n        ),\n        cond_state=f\"isTrue({self.cond._var_full_name})\",\n    )\n```", "```python\ndef render(self) -> Dict:\n    tag = self._render()\n    return dict(\n        tag.add_props(\n            **self.event_triggers,\n            key=self.key,\n            sx=self.style,\n            id=self.id,\n            class_name=self.class_name,\n        ).set(\n            props=tag.format_props(),\n        ),\n        cond_state=f\"isTrue({self.cond._var_full_name})\",\n    )\n```", "```python\ndef render(self) -> Dict:\n    tag = self._render()\n    return dict(tag)\n```"]}, "reflex-reflex/components/component.py-_get_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\n        return super()._get_vars(include_children=include_children) + [\n            prop for prop in self.props.values() if isinstance(prop, Var)\n        ]\n\n    @lru_cache(maxsize=None)  # noqa\n    def get_component(self) -> Component:\n        \"\"\"Render the component.\n------------------------------\n------------------------------\ndef _get_vars(self, include_children: bool = False) -> Iterator[Var]:\n        \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Yields:\n            The contents if it is a Var, otherwise nothing.\n        \"\"\"\n        yield self.contents\n------------------------------\n------------------------------\nReturns:\n            The prop vars.\n        \"\"\"\n        return [\n            BaseVar(\n                _var_name=name,\n                _var_type=(\n                    prop._var_type if types._isinstance(prop, Var) else type(prop)\n                ),\n            )\n            for name, prop in self.props.items()\n        ]\n\n    def _get_vars(self, include_children: bool = False) -> list[Var]:\n        \"\"\"Walk all Vars used in this component.\n------------------------------\n------------------------------\nfor child in children:\n            validate_child(child)\n\n    @staticmethod\n    def _get_vars_from_event_triggers(\n        event_triggers: dict[str, EventChain | Var],\n    ) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\n\n        Args:\n            event_triggers: The event triggers from the component instance.\n------------------------------\n------------------------------\n# Return None to indicate this component should not be memoized.\n        return None\n\n    @staticmethod\n    def _child_var(child: Component) -> Var | Component:\n        \"\"\"Get the Var from a child component.\n\n        This method is used for special cases when the StatefulComponent should actually\n        wrap the parent component of the child instead of recursing into the children\n        and memoizing them independently.\n\n        Args:\n            child: The child component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_vars(self, include_children: bool = False) -> list[Var]:\n# Natural Language Annotations: \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars = [prop for prop in self.props.values() if isinstance(prop, Var)]\n    if include_children:\n        for child in self.children:\n            vars.extend(child._get_vars(include_children=True))\n    return vars\n```", "```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars = [prop for prop in self.props.values() if isinstance(prop, Var)]\n\n    if include_children:\n        for child in self.children:\n            vars.extend(child._get_vars())\n\n    return vars\n```", "```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars = super()._get_vars(include_children=include_children)\n    vars += [prop for prop in self.props.values() if isinstance(prop, Var)]\n    return vars\n```"]}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _event_trigger_values_use_state(self) -> bool:\n        \"\"\"Check if the values of a component's event trigger use state.\n------------------------------\n------------------------------\nReturns:\n            True if any of the component's event trigger values uses State.\n        \"\"\"\n        for trigger in self.event_triggers.values():\n            if isinstance(trigger, EventChain):\n                for event in trigger.events:\n                    if event.handler.state_full_name:\n                        return True\n            elif isinstance(trigger, Var) and trigger._var_state:\n                return True\n        return False\n------------------------------\n------------------------------\nfor child in children:\n            validate_child(child)\n\n    @staticmethod\n    def _get_vars_from_event_triggers(\n        event_triggers: dict[str, EventChain | Var],\n    ) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\n\n        Args:\n            event_triggers: The event triggers from the component instance.\n------------------------------\n------------------------------\ndef code_uses_state_contexts(javascript_code: str) -> bool:\n    \"\"\"Check if the rendered Javascript uses state contexts.\n\n    Args:\n        javascript_code: The Javascript code to check.\n\n    Returns:\n        True if the code attempts to access a member of StateContexts.\n    \"\"\"\n    return bool(\"useContext(StateContexts\" in javascript_code)\n------------------------------\n------------------------------\nReturns:\n            The memoized component tree.\n        \"\"\"\n        if isinstance(component, Component):\n            if component._memoization_mode.recursive:\n                # Recursively memoize stateful children (default).\n                component.children = [\n                    cls.compile_from(child) for child in component.children\n                ]\n            # Memoize this component if it depends on state.\n            stateful_component = cls.create(component)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _has_stateful_event_triggers(self):\n# Natural Language Annotations: \"\"\"Check if component or children have any event triggers that use state.\n\n        Returns:\n            True if the component or children have any event triggers that uses state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    return self._event_trigger_values_use_state() or any(\n        child._has_stateful_event_triggers() for child in self.children\n    )\n```", "```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    return self._event_trigger_values_use_state()\n```", "```python\ndef _has_stateful_event_triggers(self) -> bool:\n    for child in self.children:\n        if child._event_trigger_values_use_state() or child._has_stateful_event_triggers():\n            return True\n    return self._event_trigger_values_use_state()\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_code": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The custom code.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_custom_code().union({self.code})\n\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_refs()\n------------------------------\n------------------------------\n@abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n------------------------------\n# Fetch custom components from props as well.\n        for child_component in self.component_props.values():\n            if child_component.tag is None:\n                continue\n            if child_component.tag not in seen:\n                seen.add(child_component.tag)\n                if isinstance(child_component, CustomComponent):\n                    custom_components |= {child_component}\n                custom_components |= child_component._get_all_custom_components(\n------------------------------\n------------------------------\nReturns:\n            The custom code for the component.\n        \"\"\"\n        custom_code = super()._get_all_custom_code()\n        if self.auto_height is not None:\n            custom_code.add(AUTO_HEIGHT_JS)\n        if self.enter_key_submit is not None:\n            custom_code.add(ENTER_KEY_SUBMIT_JS)\n        return custom_code\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_code(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Get custom code for the component and its children.\n\n        Returns:\n            The custom code.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = super()._get_all_custom_code()\n    if self.auto_height is not None:\n        custom_code.add(AUTO_HEIGHT_JS)\n    if self.enter_key_submit is not None:\n        custom_code.add(ENTER_KEY_SUBMIT_JS)\n    return custom_code\n```", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = super()._get_all_custom_code()\n    if self.code is not None:\n        custom_code.add(self.code)\n    if self.auto_height is not None:\n        custom_code.add(AUTO_HEIGHT_JS)\n    if self.enter_key_submit is not None:\n        custom_code.add(ENTER_KEY_SUBMIT_JS)\n    return custom_code\n```", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\"\"\"\n    custom_code = super()._get_all_custom_code()\n    if self.auto_height is not None:\n        custom_code.add(AUTO_HEIGHT_JS)\n    if self.enter_key_submit is not None:\n        custom_code.add(ENTER_KEY_SUBMIT_JS)\n    return custom_code\n```"]}, "reflex-reflex/components/component.py-_get_all_imports": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n        if self.rendered_as_shared:\n            return {\n                f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [\n                    ImportVar(tag=self.tag)\n                ]\n            }\n        return self.component._get_all_imports()\n------------------------------\n------------------------------\nreturn imports.merge_imports(_imports, *other_imports)\n\n    def _get_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The imports needed by the component.\n        \"\"\"\n        _imports = {}\n\n        # Import this component's tag from the main library.\n        if self.library is not None and self.tag is not None:\n            _imports[self.library] = {self.import_var}\n------------------------------\n------------------------------\ndef compile_imports(import_dict: ParsedImportDict) -> list[dict]:\n    \"\"\"Compile an import dict.\n\n    Args:\n        import_dict: The import dict to compile.\n\n    Returns:\n        The list of import dict.\n    \"\"\"\n    collapsed_import_dict: ParsedImportDict = imports.collapse_imports(import_dict)\n    validate_imports(collapsed_import_dict)\n    import_dicts = []\n    for lib, fields in collapsed_import_dict.items():\n        default, rest = compile_import_statement(fields)\n------------------------------\n------------------------------\ndef collapse_imports(imports: ParsedImportDict) -> ParsedImportDict:\n    \"\"\"Remove all duplicate ImportVar within an ImportDict.\n\n    Args:\n        imports: The import dict to collapse.\n\n    Returns:\n        The collapsed import dict.\n    \"\"\"\n    return {\n        lib: list(set(import_vars)) if isinstance(import_vars, list) else import_vars\n        for lib, import_vars in imports.items()\n    }\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n# Natural Language Annotations: \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n        Args:\n            collapse: Whether to collapse the imports by removing duplicates.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    if self.rendered_as_shared:\n        import_dict = {f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [ImportVar(tag=self.tag)]}\n    else:\n        import_dict = self.component._get_all_imports()\n    \n    if collapse:\n        import_dict = imports.collapse_imports(import_dict)\n\n    return import_dict\n```", "```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    if self.rendered_as_shared:\n        import_dict = {\n            f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [\n                ImportVar(tag=self.tag)\n            ]\n        }\n    else:\n        import_dict = self.component._get_all_imports()\n    \n    if collapse:\n        return imports.collapse_imports(import_dict)\n    else:\n        return import_dict\n```", "```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    if self.rendered_as_shared:\n        _imports = {\n            f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [\n                ImportVar(tag=self.tag)\n            ]\n        }\n    else:\n        _imports = self.component._get_all_imports()\n\n    if collapse:\n        _imports = imports.collapse_imports(_imports)\n\n    return _imports\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n------------------------------\n------------------------------\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n------------------------------\n------------------------------\n# Render the code for this component and hooks.\n        return STATEFUL_COMPONENT.render(\n            tag_name=tag_name,\n            memo_trigger_hooks=memo_trigger_hooks,\n            component=component,\n        )\n\n    @staticmethod\n    def _get_hook_deps(hook: str) -> list[str]:\n        \"\"\"Extract var deps from a hook.\n\n        Args:\n            hook: The hook line to extract deps from.\n------------------------------\n------------------------------\ndef _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def get_ref(self) -> str | None:\n        \"\"\"Get the name of the ref for the component.\n------------------------------\n------------------------------\nReturns:\n            The custom code.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_custom_code().union({self.code})\n\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_refs()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks_internal(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {}\n```", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {}\n```", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {}\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n------------------------------\n------------------------------\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n------------------------------\n------------------------------\ndef _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def get_ref(self) -> str | None:\n        \"\"\"Get the name of the ref for the component.\n------------------------------\n------------------------------\ndef _render(self) -> Tag:\n        \"\"\"Define how to render the component in React.\n\n        Returns:\n            The tag to render.\n        \"\"\"\n        return super()._render(props=self.props)\n\n    def get_prop_vars(self) -> List[BaseVar]:\n        \"\"\"Get the prop vars.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the React hooks for this component and its children.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    all_hooks = self._get_all_hooks_internal()\n    all_hooks.update(self._get_all_hooks())\n    return all_hooks\n```", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    # Initialize an empty dictionary to hold the hooks\n    all_hooks = {}\n\n    # Add the hooks for this component\n    all_hooks.update(self._get_all_hooks_internal())\n    all_hooks.update(self._get_all_hooks())\n\n    # Add the hooks for the children components\n    for child in self.children:\n        all_hooks.update(child._get_all_hooks())\n\n    return all_hooks\n```", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    all_hooks = {}\n    for child in self.children:\n        all_hooks.update(child._get_all_hooks())\n    all_hooks.update(self._get_hooks())\n    return all_hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_components": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\n        assert self.tag is not None, \"The tag must be set.\"\n\n        # Store the seen components in a set to avoid infinite recursion.\n        if seen is None:\n            seen = set()\n        custom_components = {self} | super()._get_all_custom_components(seen=seen)\n------------------------------\n------------------------------\nReturns:\n            The set of custom components.\n        \"\"\"\n        custom_components = super()._get_all_custom_components(seen=seen)\n\n        # Get the custom components for each tag.\n        for component in self.component_map.values():\n            custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n                seen=seen\n            )\n\n        return custom_components\n------------------------------\n------------------------------\n# Create the component.\n        return super().create(\n            src,\n            component_map=component_map,\n            component_map_hash=cls._component_map_hash(component_map),\n            **props,\n        )\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n------------------------------\n------------------------------\nReturns:\n            The hash of the component.\n        \"\"\"\n        return hash(self.tag)\n\n    @classmethod\n    def get_props(cls) -> Set[str]:\n        \"\"\"Get the props for the component.\n\n        Returns:\n            The set of component props.\n        \"\"\"\n        return set()\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> Set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n------------------------------\n------------------------------\nseen=seen\n                )\n        return custom_components\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_components(\n# Natural Language Annotations: \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_custom_components(\n    self, seen: set[str] | None = None\n) -> set[CustomComponent]:\n    custom_components = {self} | super()._get_all_custom_components(seen=seen)\n    for component in self.component_map.values():\n        custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n            seen=seen\n        )\n    return custom_components\n```", "```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    if seen is None:\n        seen = set()\n    custom_components = {self} | super()._get_all_custom_components(seen=seen)\n\n    for component in self.component_map.values():\n        custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n            seen=seen\n        )\n\n    return custom_components\n```", "Sure, here is the Python function based on your specifications:\n\n```python\ndef _get_all_custom_components(\n    self, seen: set[str] | None = None\n) -> set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    # Create a set to store the custom components.\n    custom_components = set()\n\n    # If the seen set is None, initialize it as an empty set.\n    if seen is None:\n        seen = set()\n\n    # Add the current component to the set of custom components.\n    custom_components.add(self)\n\n    # Get the custom components for each tag.\n    for component in self.component_map.values():\n        custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n            seen=seen\n        )\n\n    return custom_components\n```"]}, "reflex-reflex/components/core/upload.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of item to add as child of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n------------------------------\n------------------------------\n@classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an Input component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\n@classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an Input component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\n@classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an Input component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create an upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The upload component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n```", "```python\n@classmethod\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n```", "```python\n@classmethod\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    # Your code here\n    pass\n```"]}, "reflex-reflex/components/next/image.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            list_style_type: The style of the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n\n        \"\"\"\n        props[\"margin_left\"] = props.get(\"margin_left\", \"1.5rem\")\n        return super().create(\n            *children, items=items, list_style_type=list_style_type, **props\n        )\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            list_style_type: The style of the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n\n        \"\"\"\n        props[\"margin_left\"] = props.get(\"margin_left\", \"1.5rem\")\n        return super().create(\n            *children, items=items, list_style_type=list_style_type, **props\n        )\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of item to add as child of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create an Image component from next/image.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the image.\n            height: The height of the image.\n            **props:The props of the component.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(self, *children, width=None, height=None, **props):\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props: The props of the component.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    return super().create(*children, width=width, height=height, **props)\n```", "```python\ndef create_image(\n    *children: Union[str, ImageComponent],\n    width: Optional[Union[int, str]] = None,\n    height: Optional[Union[int, str]] = None,\n    **props: Dict[str, Any],\n) -> ImageComponent:\n    \"\"\"\n    Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props: The props of the component.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    # Your code here\n```", "```python\ndef create(self, *children, width=None, height=None, **props):\n    props[\"width\"] = width\n    props[\"height\"] = height\n    return super().create(*children, **props)\n```"]}, "reflex-reflex/components/lucide/icon.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass Icon(ChakraIconComponent):\n    \"\"\"An image icon.\"\"\"\n\n    tag = \"None\"\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n------------------------------\n------------------------------\nReturns:\n            The created component.\n        \"\"\"\n        if children:\n            raise AttributeError(\n                f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n            )\n        if \"tag\" not in props:\n            raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n        if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n            raise ValueError(\n------------------------------\n------------------------------\nclass AccordionIcon(Icon):\n    \"\"\"An accordion icon component.\"\"\"\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create the Accordion icon component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nReturns:\n            The IconButton component.\n        \"\"\"\n        if children:\n            if isinstance(children[0], str):\n                children = [\n                    Icon.create(\n                        children[0],\n                    )\n                ]\n        else:\n            raise ValueError(\n                \"IconButton requires a child icon. Pass a string as the first child or a rx.icon.\"\n            )\n        if \"size\" in props:\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            icon: The icon of the alert.\n            title: The title of the alert.\n            desc: The description of the alert\n            **props: The properties of the component.\n\n        Returns:\n            The alert component.\n        \"\"\"\n        if len(children) == 0:\n            children = []\n\n            if icon:\n                children.append(AlertIcon.create())\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n            f\"Invalid 'tag' keyword-argument for Icon: {props['tag']}. Must be one of {ICON_LIST}\"\n        )\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n            f\"Invalid 'tag' keyword-argument for Icon: {props['tag']} not in the list of valid icons.\"\n        )\n```"]}, "reflex-reflex/components/tags/tag.py-format_props": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef format_prop(\n    prop: Union[Var, EventChain, ComponentStyle, str],\n) -> Union[int, float, str]:\n    \"\"\"Format a prop.\n\n    Args:\n        prop: The prop to format.\n\n    Returns:\n        The formatted prop to display within a tag.\n------------------------------\n------------------------------\ndef format_props(*single_props, **key_value_props) -> list[str]:\n    \"\"\"Format the tag's props.\n\n    Args:\n        single_props: Props that are not key-value pairs.\n        key_value_props: Props that are key-value pairs.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Format all the props.\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(key_value_props.items())\n        if prop is not None\n    ] + [str(prop) for prop in single_props]\n------------------------------\n------------------------------\ndef format_component(self, tag: str, **props) -> str:\n        \"\"\"Format a component for rendering in the component map.\n\n        Args:\n            tag: The tag of the component.\n            **props: Extra props to pass to the component function.\n\n        Returns:\n            The formatted component.\n        \"\"\"\n        return str(self.get_component(tag, **props)).replace(\"\\n\", \"\")\n\n    def format_component_map(self) -> dict[str, str]:\n        \"\"\"Format the component map for rendering.\n------------------------------\n------------------------------\nReturns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        return dict(\n            tag.add_props(\n                **self.event_triggers,\n                key=self.key,\n                sx=self.style,\n                id=self.id,\n                class_name=self.class_name,\n            ).set(\n                props=tag.format_props(),\n            ),\n            cond_state=f\"isTrue({self.cond._var_full_name})\",\n        )\n------------------------------\n------------------------------\nReturns:\n            The formatted component map.\n        \"\"\"\n        components = {\n            tag: f\"{{({{node, {_CHILDREN._var_name}, {_PROPS._var_name}}}) => {self.format_component(tag)}}}\"\n            for tag in self.component_map\n        }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def format_props(self) -> List:\n# Natural Language Annotations: \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef format_props(self) -> list[str]:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Format all the props.\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(self.key_value_props.items())\n        if prop is not None\n    ] + [str(prop) for prop in self.single_props]\n```", "```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Format all the props.\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(key_value_props.items())\n        if prop is not None\n    ] + [str(prop) for prop in single_props]\n```", "```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Format all the props.\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(self.key_value_props.items())\n        if prop is not None\n    ] + [str(prop) for prop in self.single_props]\n```"]}, "textual-src/textual/screen.py-focus_next": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        # TODO: This shouldn't be required\n        self._compositor._full_map_invalidated = True\n        if not isinstance(selector, str):\n            selector = selector.__name__\n        selector_set = parse_selectors(selector)\n------------------------------\n------------------------------\nreturn widgets\n\n    def _move_focus(\n        self, direction: int = 0, selector: str | type[QueryType] = \"*\"\n    ) -> Widget | None:\n        \"\"\"Move the focus in the given direction.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\nArgs:\n            selector: A CSS selector, widget type, or `None` for all nodes.\n\n        Returns:\n            A query object.\n        \"\"\"\n        from .css.query import DOMQuery, QueryType\n        from .widget import Widget\n\n        if isinstance(selector, str) or selector is None:\n            return DOMQuery[Widget](self, filter=selector)\n        else:\n            return DOMQuery[QueryType](self, filter=selector.__name__)\n\n    if TYPE_CHECKING:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n    widgets = self.query(selector).all()\n    if not widgets:\n        return None\n    if self.focused:\n        try:\n            index = widgets.index(self.focused)\n        except ValueError:\n            index = None\n        if index is not None:\n            if index < len(widgets) - 1:\n                self._set_focus(widgets[index + 1])\n            else:\n                self._set_focus(widgets[0])\n    else:\n        self._set_focus(widgets[0])\n    return self.focused\n```", "```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\"\"\"\n    \n    # If no widget is currently focused, this will focus the first focusable widget.\n    if not self.focused:\n        self._move_focus(selector=selector)\n        return self.focused\n    \n    # If no focusable widget matches the given CSS selector, focus is set to `None`.\n    focused_widgets = self._query(selector)\n    if not focused_widgets:\n        return None\n    \n    # Move the focus to the next widget in the list.\n    current_index = focused_widgets.index(self.focused)\n    next_index = (current_index + 1) % len(focused_widgets)\n    self._move_focus(selector=selector)\n    \n    return self.focused\n```", "```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n\n    # TODO: Implement actual logic for moving focus\n    # This is just a placeholder for now\n    return None\n```"]}, "textual-src/textual/screen.py-focus_previous": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        # TODO: This shouldn't be required\n        self._compositor._full_map_invalidated = True\n        if not isinstance(selector, str):\n            selector = selector.__name__\n        selector_set = parse_selectors(selector)\n------------------------------\n------------------------------\nreturn widgets\n\n    def _move_focus(\n        self, direction: int = 0, selector: str | type[QueryType] = \"*\"\n    ) -> Widget | None:\n        \"\"\"Move the focus in the given direction.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\nArgs:\n            selector: A CSS selector, widget type, or `None` for all nodes.\n\n        Returns:\n            A query object.\n        \"\"\"\n        from .css.query import DOMQuery, QueryType\n        from .widget import Widget\n\n        if isinstance(selector, str) or selector is None:\n            return DOMQuery[Widget](self, filter=selector)\n        else:\n            return DOMQuery[QueryType](self, filter=selector.__name__)\n\n    if TYPE_CHECKING:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n    widgets = self._query(selector).filter(Widget)\n    if len(widgets) == 0:\n        return None\n    current_focus = self.focused\n    if current_focus is None:\n        self.focused = widgets[0]\n        return self.focused\n    current_index = widgets.index(current_focus)\n    if current_index == 0:\n        self.focused = widgets[-1]\n    else:\n        self.focused = widgets[current_index - 1]\n    return self.focused\n```", "```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\"\"\"\n\n    # Get all nodes that match the given CSS selector\n    nodes = self.query(selector)\n\n    # Find the currently focused node\n    focused = self.focused\n\n    # If there's no focused node, focus the first node\n    if focused is None:\n        if len(nodes) > 0:\n            return nodes[0]\n        else:\n            return None\n\n    # If there's a focused node, find the previous node in the list\n    index = nodes.index(focused)\n    if index > 0:\n        return nodes[index - 1]\n    else:\n        return None\n```", "```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: This shouldn't be required\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n\n    # Find the current focused widget\n    focused_widget = self.focused\n    if focused_widget is None:\n        # If no widget is currently focused, focus the first focusable widget\n        focused_widget = self._find_first_focusable()\n        if focused_widget is None:\n            return None\n    else:\n        # If a widget is currently focused, focus the previous focusable widget\n        focused_widget = self._find_previous_focusable(focused_widget)\n        if focused_widget is None:\n            return None\n\n    # Filter the focused widget by the CSS selector\n    if not self._matches_selector(focused_widget, selector_set):\n        return None\n\n    return focused_widget\n```"]}, "textual-src/textual/screen.py-set_focus": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n        \"\"\"Focus (or unfocus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\n        self.screen.set_focus(widget, scroll_visible)\n\n    def _set_mouse_over(self, widget: Widget | None) -> None:\n        \"\"\"Called when the mouse is over another widget.\n------------------------------\n------------------------------\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n        \"\"\"Focus (or unfocus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\n        self.screen.set_focus(widget, scroll_visible)\n\n    def _set_mouse_over(self, widget: Widget | None) -> None:\n        \"\"\"Called when the mouse is over another widget.\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\ndef focus(self, scroll_visible: bool = True) -> Self:\n        \"\"\"Give focus to this widget.\n\n        Args:\n            scroll_visible: Scroll parent to make this widget visible.\n\n        Returns:\n            The `Widget` instance.\n        \"\"\"\n\n        def set_focus(widget: Widget) -> None:\n            \"\"\"Callback to set the focus.\"\"\"\n            try:\n                widget.screen.set_focus(self, scroll_visible=scroll_visible)\n            except NoScreen:\n                pass\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n# Natural Language Annotations: \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    self.screen.set_focus(widget, scroll_visible)\n```", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    self.screen.set_focus(widget, scroll_visible)\n```", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is None:\n        self.screen.set_focus(None, scroll_visible)\n    else:\n        self.screen.set_focus(widget, scroll_visible)\n```"]}, "textual-src/textual/strip.py-index_to_cell_position": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef index_to_cell_position(segments: Iterable[Segment], index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character within\n    an Iterable of Segments. This is the sum of the cell lengths of all the characters\n    *before* the character at `index`.\n\n    Args:\n        segments: The segments to find the cell position within.\n        index: The index to convert into a cell position.\n\n    Returns:\n        The cell position of the character at `index`.\n------------------------------\n------------------------------\nReturns:\n            The index in the document's text.\n        \"\"\"\n        row, column = location\n        index = row * len(self.newline) + column\n        for line_index in range(row):\n            index += len(self.get_line(line_index))\n        return index\n\n    def get_location_from_index(self, index: int) -> Location:\n        \"\"\"Given an index in the document's text, returns the corresponding location.\n\n        Args:\n            index: The index in the document's text.\n------------------------------\n------------------------------\ndef cell_width_to_column_index(line: str, cell_width: int, tab_width: int) -> int:\n    \"\"\"Retrieve the column index corresponding to the given cell width.\n\n    Args:\n        line: The line of text to search within.\n        cell_width: The cell width to convert to column index.\n        tab_width: The tab stop width to expand tabs contained within the line.\n------------------------------\n------------------------------\nreturn replace_result\n\n    def get_line(self, line_index: int) -> str:\n        \"\"\"Return the string representing the line, not including new line characters.\n\n        Args:\n            line_index: The index of the line.\n\n        Returns:\n            The string representing the line.\n        \"\"\"\n        line_string = self[line_index]\n        return line_string\n------------------------------\n------------------------------\ndef get_column_at(self, column_index: int) -> Iterable[CellType]:\n        \"\"\"Get the values from the column at a given index.\n\n        Args:\n            column_index: The index of the column.\n\n        Returns:\n            A generator which yields the cells in the column.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def index_to_cell_position(self, index: int) -> int:\n# Natural Language Annotations: \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    cell_position = 0\n    for segment in self.segments:\n        if index >= len(segment.text):\n            cell_position += len(segment.text)\n            index -= len(segment.text)\n        else:\n            cell_position += index\n            break\n    return cell_position\n```", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    cell_position = 0\n    for segment in self.segments[:index]:\n        cell_position += len(segment)\n    return cell_position\n```", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    pass\n```"]}, "textual-src/textual/strip.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n------------------------------\n------------------------------\ndef render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n------------------------------\n------------------------------\nclass StripRenderable:\n    \"\"\"A renderable which renders a list of strips in to lines.\"\"\"\n\n    def __init__(self, strips: list[Strip], width: int | None = None) -> None:\n        self._strips = strips\n        self._width = width\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        new_line = Segment.line()\n        for strip in self._strips:\n            yield from strip\n            yield new_line\n------------------------------\n------------------------------\nif y != last_y:\n                yield new_line\n\n    def render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Raw data with escape sequences.\n        \"\"\"\n\n        sequences: list[str] = []\n        append = sequences.append\n------------------------------\n------------------------------\nelse:\n                            segments = console.render(renderable)\n                            terminal_sequence = console._render_buffer(segments)\n                    except Exception as error:\n                        self._handle_exception(error)\n                    else:\n                        if WINDOWS:\n                            # Combat a problem with Python on Windows.\n                            #\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self, console: Console) -> str:\n# Natural Language Annotations: \"\"\"Render the strip into terminal sequences.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Rendered sequences.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n\n    sequences: list[str] = []\n    append = sequences.append\n    \n    new_line = Segment.line()\n    for strip in self._strips:\n        yield from strip\n        yield new_line\n    \n    segments = console.render(renderable)\n    terminal_sequence = console._render_buffer(segments)\n\n    return terminal_sequence\n```", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n\n    sequences: list[str] = []\n    append = sequences.append\n\n    if y != last_y:\n        yield new_line\n\n    else:\n        segments = console.render(renderable)\n        terminal_sequence = console._render_buffer(segments)\n        sequences.append(terminal_sequence)\n\n    return \"\\n\".join(sequences)\n```", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n\n    sequences: list[str] = []\n    append = sequences.append\n\n    new_line = Segment.line()\n    for strip in self._strips:\n        yield from strip\n        yield new_line\n\n    if y != last_y:\n        yield new_line\n\n    segments = console.render(renderable)\n    terminal_sequence = console._render_buffer(segments)\n    except Exception as error:\n        self._handle_exception(error)\n    else:\n        if WINDOWS:\n            # Combat a problem with Python on Windows.\n\n    return terminal_sequence\n```"]}, "textual-src/textual/app.py-batch_update": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@contextmanager\n    def batch_update(self) -> Generator[None, None, None]:\n        \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n        self._begin_batch()\n        try:\n            yield\n        finally:\n            self._end_batch()\n\n    def _begin_batch(self) -> None:\n        \"\"\"Begin a batch update.\"\"\"\n        self._batch_count += 1\n------------------------------\n------------------------------\nFor drivers that support the application being suspended by the\n        operating system, this context manager is used to mark a body of\n        code as one that will manage its own stop and start.\n        \"\"\"\n        auto_restart = self._auto_restart\n        self._auto_restart = False\n        try:\n            yield\n        finally:\n            self._auto_restart = auto_restart\n\n    def close(self) -> None:\n        \"\"\"Perform any final cleanup.\"\"\"\n------------------------------\n------------------------------\n@on(Driver.SignalResume)\n    def _resume_signal(self) -> None:\n        \"\"\"Signal that the application is being resumed from a suspension.\"\"\"\n        self.app_resume_signal.publish(self)\n\n    @contextmanager\n    def suspend(self) -> Iterator[None]:\n        \"\"\"A context manager that temporarily suspends the app.\n------------------------------\n------------------------------\n@on(Driver.SignalResume)\n    def _resume_signal(self) -> None:\n        \"\"\"Signal that the application is being resumed from a suspension.\"\"\"\n        self.app_resume_signal.publish(self)\n\n    @contextmanager\n    def suspend(self) -> Iterator[None]:\n        \"\"\"A context manager that temporarily suspends the app.\n------------------------------\n------------------------------\n# Refresh according to descriptor flags\n            if self._layout or self._repaint or self._recompose:\n                obj.refresh(\n                    repaint=self._repaint,\n                    layout=self._layout,\n                    recompose=self._recompose,\n                )\n\n    @classmethod\n    def _check_watchers(cls, obj: Reactable, name: str, old_value: Any) -> None:\n        \"\"\"Check watchers, and call watch methods / computes\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def batch_update(self) -> Generator[None, None, None]:\n# Natural Language Annotations: \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n```", "```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n```", "```python\n@contextmanager\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n```"]}, "textual-src/textual/app.py-call_from_thread": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n------------------------------\n------------------------------\nThis method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n------------------------------\n------------------------------\nif self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            \"\"\"Run the callback, set the result or error on the future.\"\"\"\n            self._set_active()\n            return await invoke(callback_with_args)\n------------------------------\n------------------------------\nArgs:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n------------------------------\n------------------------------\nRaises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\n\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_from_thread(\n# Natural Language Annotations: \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\n        if self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            \"\"\"Run the callback, set the result or error on the future.\"\"\"\n            self._set_active()\n            return await invoke(callback_with_args)\n\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n```", "```python\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        if self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            self._set_active()\n            return await invoke(callback_with_args)\n\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n\n        return run_callback()\n```", "```python\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\n        if self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            \"\"\"Run the callback, set the result or error on the future.\"\"\"\n            self._set_active()\n            return await invoke(callback_with_args)\n\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n```"]}, "textual-src/textual/app.py-run_test": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@asynccontextmanager\n    async def run_test(\n        self,\n        *,\n        headless: bool = True,\n        size: tuple[int, int] | None = (80, 24),\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncGenerator[Pilot[ReturnType], None]:\n        \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n------------------------------\n------------------------------\nUse this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_test(\n# Natural Language Annotations: \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def run_test(\n        self,\n        *,\n        headless: bool = True,\n        size: tuple[int, int] | None = (80, 24),\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncGenerator[Pilot[ReturnType], None]:\n        # Your code here\n```", "```python\nasync def run_test(\n        self,\n        *,\n        headless: bool = True,\n        size: tuple[int, int] | None = (80, 24),\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncGenerator[Pilot[ReturnType], None]:\n        \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n        from .pilot import Pilot\n```", "```python\nasync def run_test(\n        self,\n        *,\n        headless: bool = True,\n        size: tuple[int, int] | None = (80, 24),\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncGenerator[Pilot[ReturnType], None]:\n        from .pilot import Pilot\n        # Your implementation here\n```"]}, "textual-src/textual/app.py-run": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nreturn app.return_value\n\n    def run(\n        self,\n        *,\n        headless: bool = False,\n        inline: bool = False,\n        inline_no_clear: bool = False,\n        mouse: bool = True,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> ReturnType | None:\n        \"\"\"Run the app.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def run(\n# Natural Language Annotations: \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef run(\n    self,\n    *,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    from .pilot import Pilot\n```", "```python\ndef run(\n        self,\n        *,\n        headless: bool = False,\n        inline: bool = False,\n        inline_no_clear: bool = False,\n        mouse: bool = True,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> ReturnType | None:\n        \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n        # Your function implementation goes here\n```", "```python\ndef run(\n    self,\n    *,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\"\"\"\n    from .pilot import Pilot\n    # Your code here\n```"]}, "textual-src/textual/app.py-switch_mode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef switch_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\n        if mode not in self.MODES:\n            raise UnknownModeError(f\"No known mode {mode!r}\")\n------------------------------\n------------------------------\ndef _init_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Do internal initialization of a new screen stack mode.\n\n        Args:\n            mode: Name of the mode.\n\n        Returns:\n            An optionally awaitable object which can be awaited until the screen\n            associated with the mode has been mounted.\n        \"\"\"\n------------------------------\n------------------------------\ndef _init_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Do internal initialization of a new screen stack mode.\n\n        Args:\n            mode: Name of the mode.\n\n        Returns:\n            An optionally awaitable object which can be awaited until the screen\n            associated with the mode has been mounted.\n        \"\"\"\n------------------------------\n------------------------------\nself.log.system(f\"{self._current_mode!r} is the current mode\")\n        self.log.system(f\"{self.screen} is active\")\n\n        return await_mount\n\n    def add_mode(\n        self, mode: str, base_screen: str | Screen | Callable[[], Screen]\n    ) -> None:\n        \"\"\"Adds a mode and its corresponding base screen to the app.\n\n        Args:\n            mode: The new mode.\n            base_screen: The base screen associated with the given mode.\n------------------------------\n------------------------------\nReturns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        if self.app._exit:\n            return AwaitMount(self, [])\n        await_mount = self.mount(*widgets, before=before, after=after)\n        return await_mount\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_mode(self, mode: str) -> AwaitMount:\n# Natural Language Annotations: \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"No known mode {mode}\")\n    # Your code here\n    pass\n```", "```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    \"\"\"Switch to a given mode.\n\n    Args:\n        mode: The mode to switch to.\n\n    Returns:\n        An optionally awaitable object which waits for the screen associated\n            with the mode to be mounted.\n\n    Raises:\n        UnknownModeError: If trying to switch to an unknown mode.\n    \"\"\"\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"No known mode {mode}\")\n```", "```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"No known mode {mode}\")\n    # Implement switching to mode here\n    return AwaitMount(self, [])  # Replace with actual implementation\n```"]}, "textual-src/textual/app.py-push_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n------------------------------\n------------------------------\nNote that this method may only be called when running in a worker.\n\n        Args:\n            screen: A screen or the name of an installed screen.\n\n        Returns:\n            The screen's result.\n        \"\"\"\n        await self._flush_next_callbacks()\n        return await self.push_screen(screen, wait_for_dismiss=True)\n------------------------------\n------------------------------\nasync def push_screen_wait(\n        self, screen: Screen[ScreenResultType] | str\n    ) -> ScreenResultType | Any:\n        \"\"\"Push a screen and wait for the result (received from [`Screen.dismiss`][textual.screen.Screen.dismiss]).\n\n        Note that this method may only be called when running in a worker.\n\n        Args:\n            screen: A screen or the name of an installed screen.\n------------------------------\n------------------------------\nIf `result` is provided and a callback was set when the screen was [pushed][textual.app.App.push_screen], then\n        the callback will be invoked with `result`.\n\n        Args:\n            result: The optional result to be passed to the result callback.\n\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n------------------------------\n------------------------------\nRaises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"push_screen requires a Screen instance or str; not {screen!r}\"\n            )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def push_screen(\n# Natural Language Annotations: \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n        Args:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n                this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n        Raises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef push_screen(self, screen: Screen | str, callback: Callable = None, wait_for_dismiss: bool = False) -> Optional[Awaitable]:\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(f\"push_screen requires a Screen instance or str; not {screen}\")\n\n    if wait_for_dismiss and not self._worker:\n        raise NoActiveWorker(\"wait_for_dismiss should only be set to True when running in a worker\")\n\n    await self._flush_next_callbacks()\n    return await self.push_screen(screen, callback, wait_for_dismiss)\n```", "```python\ndef push_screen(self, screen: Screen[ScreenResultType] | str, callback: Optional[Callable[[ScreenResultType | Any], None]] = None, wait_for_dismiss: bool = False) -> ScreenResultType | Any:\n    \"\"\"\n    Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n```", "```python\ndef push_screen(\n        self, screen: Screen[ScreenResultType] | str,\n        callback: Optional[Callable[[ScreenResultType | Any], None]] = None,\n        wait_for_dismiss: bool = False\n    ) -> Awaitable[ScreenResultType | Any]:\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"push_screen requires a Screen instance or str; not {screen.__class__.__name__}\"\n            )\n        if wait_for_dismiss and not self._app._running_in_worker:\n            raise NoActiveWorker(\n                \"wait_for_dismiss must be used in a worker thread\"\n            )\n        return self._post_message(\n            self._app._push_screen_message(\n                screen, callback=callback, wait_for_dismiss=wait_for_dismiss\n            )\n        )\n```"]}, "textual-src/textual/app.py-switch_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n        \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"switch_screen requires a Screen instance or str; not {screen!r}\"\n            )\n------------------------------\n------------------------------\ndef get_screen(self, screen: Screen | str) -> Screen:\n        \"\"\"Get an installed screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Raises:\n            KeyError: If the named screen doesn't exist.\n------------------------------\n------------------------------\ndef get_screen(self, screen: Screen | str) -> Screen:\n        \"\"\"Get an installed screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Raises:\n            KeyError: If the named screen doesn't exist.\n------------------------------\n------------------------------\nawait await_mount()\n            await self._replace_screen(top_screen)\n\n        return AwaitComplete(do_switch()).call_next(self)\n\n    def install_screen(self, screen: Screen, name: str) -> None:\n        \"\"\"Install a screen.\n------------------------------\n------------------------------\nasync def _replace_screen(self, screen: Screen) -> Screen:\n        \"\"\"Handle the replaced screen.\n\n        Args:\n            screen: A screen object.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(\n            f\"switch_screen requires a Screen instance or str; not {screen}\")\n\n    await await_mount()\n    await self._replace_screen(top_screen)\n\n    return AwaitComplete(do_switch()).call_next(self)\n```", "```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(\n            f\"switch_screen requires a Screen instance or str; not {screen}. Please provide a valid screen or its name.\"\n        )\n\n    self._replace_screen(screen)\n    return AwaitComplete(do_switch()).call_next(self)\n```", "```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(\n            f\"switch_screen requires a Screen instance or str; not {screen_type}\"\n        )\n\n    await await_mount()\n    await self._replace_screen(top_screen)\n\n    return AwaitComplete(do_switch()).call_next(self)\n```"]}, "textual-src/textual/app.py-pop_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef pop_screen(self) -> AwaitComplete:\n        \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\n\n        screen_stack = self._screen_stack\n        if len(screen_stack) <= 1:\n            raise ScreenStackError(\n                \"Can't pop screen; there must be at least one screen on the stack\"\n            )\n------------------------------\n------------------------------\nReturns:\n            A snapshot of the current state of the screen stack.\n        \"\"\"\n        return self._screen_stacks[self._current_mode].copy()\n\n    @property\n    def _screen_stack(self) -> list[Screen[Any]]:\n        \"\"\"A reference to the current screen stack.\n\n        Note:\n            Consider using [`screen_stack`][textual.app.App.screen_stack] instead.\n------------------------------\n------------------------------\nReturns:\n            A snapshot of the current state of the screen stack.\n        \"\"\"\n        return self._screen_stacks[self._current_mode].copy()\n\n    @property\n    def _screen_stack(self) -> list[Screen[Any]]:\n        \"\"\"A reference to the current screen stack.\n\n        Note:\n            Consider using [`screen_stack`][textual.app.App.screen_stack] instead.\n------------------------------\n------------------------------\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n        \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"switch_screen requires a Screen instance or str; not {screen!r}\"\n            )\n------------------------------\n------------------------------\nReturns:\n            The screen that was replaced.\n        \"\"\"\n        if self._screen_stack:\n            self.screen.refresh()\n        screen.post_message(events.ScreenSuspend())\n        self.log.system(f\"{screen} SUSPENDED\")\n        if not self.is_screen_installed(screen) and all(\n            screen not in stack for stack in self._screen_stacks.values()\n        ):\n            await screen.remove()\n            self.log.system(f\"{screen} REMOVED\")\n        return screen\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def pop_screen(self) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    screen_stack = self._screen_stack\n    if len(screen_stack) <= 1:\n        raise ScreenStackError(\n            \"Can't pop screen; there must be at least one screen on the stack\"\n        )\n    else:\n        replaced_screen = screen_stack.pop()\n        self._current_screen = screen_stack[-1]\n        return replaced_screen\n```", "```python\ndef pop_screen(self) -> AwaitComplete:\n        \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\n        screen_stack = self._screen_stack\n        if len(screen_stack) <= 1:\n            raise ScreenStackError(\n                \"Can't pop screen; there must be at least one screen on the stack\"\n            )\n\n        # Get the current screen\n        current_screen = screen_stack.pop()\n\n        if screen_stack:\n            # If there are still screens in the stack, switch to the previous one\n            self.switch_screen(screen_stack[-1])\n\n        return current_screen\n```", "```python\ndef pop_screen(self) -> AwaitComplete:\n    screen_stack = self._screen_stack\n    if len(screen_stack) <= 1:\n        raise ScreenStackError(\n            \"Can't pop screen; there must be at least one screen on the stack\"\n        )\n    screen = screen_stack.pop()\n    self.screen = screen_stack[-1]\n    return screen\n```"]}, "textual-src/textual/app.py-run_action": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def run_action(\n        self,\n        action: str | ActionParseResult,\n        default_namespace: DOMNode | None = None,\n    ) -> bool:\n        \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n------------------------------\n------------------------------\nArgs:\n            keys: A comma separated list of keys, i.e.\n            action: Action to bind to.\n            description: Short description of action.\n            show: Show key in UI.\n            key_display: Replacement text for key, or None to use default.\n        \"\"\"\n        self._bindings.bind(\n            keys, action, description, show=show, key_display=key_display\n        )\n------------------------------\n------------------------------\nArgs:\n            keys: A comma separated list of keys, i.e.\n            action: Action to bind to.\n            description: Short description of action.\n            show: Show key in UI.\n            key_display: Replacement text for key, or None to use default.\n        \"\"\"\n        self._bindings.bind(\n            keys, action, description, show=show, key_display=key_display\n        )\n------------------------------\n------------------------------\nArgs:\n            keys: The keys to bind. Can be a comma-separated list of keys.\n            action: The action to bind the keys to.\n            description: An optional description for the binding.\n            show: A flag to say if the binding should appear in the footer.\n            key_display: Optional string to display in the footer for the key.\n            priority: Is this a priority binding, checked form app down to focused widget?\n        \"\"\"\n------------------------------\n------------------------------\nif isinstance(action, str):\n            await self.run_action(action, default_namespace)\n        elif isinstance(action, tuple) and len(action) == 2:\n            action_name, action_params = action\n            namespace, parsed_action, _ = actions.parse(action_name)\n            await self.run_action(\n                (namespace, parsed_action, action_params),\n                default_namespace,\n            )\n        elif callable(action):\n            await action()\n        else:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_action(\n# Natural Language Annotations: \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def run_action(\n        self,\n        action: str | ActionParseResult,\n        default_namespace: DOMNode | None = None,\n    ) -> bool:\n        if isinstance(action, str):\n            await self.run_action(action, default_namespace)\n        elif isinstance(action, tuple) and len(action) == 2:\n            action_name, action_params = action\n            namespace, parsed_action, _ = actions.parse(action_name)\n            await self.run_action(\n                (namespace, parsed_action, action_params),\n                default_namespace,\n            )\n        elif callable(action):\n            await action()\n```", "```python\nasync def run_action(self, action: str | ActionParseResult, default_namespace: DOMNode | None = None) -> bool:\n    if isinstance(action, str):\n        await self.run_action(action, default_namespace)\n    elif isinstance(action, tuple) and len(action) == 2:\n        action_name, action_params = action\n        namespace, parsed_action, _ = actions.parse(action_name)\n        await self.run_action((namespace, parsed_action, action_params), default_namespace)\n    elif callable(action):\n        await action()\n    else:\n        return False\n```", "```python\nasync def run_action(\n        self,\n        action: str | ActionParseResult,\n        default_namespace: DOMNode | None = None,\n    ) -> bool:\n        \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\n        if isinstance(action, str):\n            await self.run_action(action, default_namespace)\n        elif isinstance(action, tuple) and len(action) == 2:\n            action_name, action_params = action\n            namespace, parsed_action, _ = actions.parse(action_name)\n            await self.run_action(\n                (namespace, parsed_action, action_params),\n                default_namespace,\n            )\n        elif callable(action):\n            await action()\n        else:\n            return False\n```"]}, "textual-src/textual/file_monitor.py-check": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef check(self) -> bool:\n        \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n        modified = self._get_last_modified_time()\n        changed = modified != self._modified\n        self._modified = modified\n        return changed\n\n    def add_paths(self, paths: Iterable[Path]) -> None:\n        \"\"\"Adds paths to start being monitored.\n------------------------------\n------------------------------\ndef _get_last_modified_time(self) -> float:\n        \"\"\"Get the most recent modified time out of all files being watched.\"\"\"\n        modified_times = []\n        for path in self._paths:\n            try:\n                modified_time = os.stat(path).st_mtime\n            except FileNotFoundError:\n                modified_time = 0\n            modified_times.append(modified_time)\n        return max(modified_times, default=0)\n------------------------------\n------------------------------\ndef _get_last_modified_time(self) -> float:\n        \"\"\"Get the most recent modified time out of all files being watched.\"\"\"\n        modified_times = []\n        for path in self._paths:\n            try:\n                modified_time = os.stat(path).st_mtime\n            except FileNotFoundError:\n                modified_time = 0\n            modified_times.append(modified_time)\n        return max(modified_times, default=0)\n------------------------------\n------------------------------\nArgs:\n            paths: The paths to be monitored.\n        \"\"\"\n        self._paths.update(paths)\n\n    async def __call__(self) -> None:\n        if self.check():\n            await self.on_change()\n\n    async def on_change(self) -> None:\n        \"\"\"Called when any of the monitored files change.\"\"\"\n        await invoke(self.callback)\n------------------------------\n------------------------------\nclass FileMonitor:\n    \"\"\"Monitors files for changes and invokes a callback when it does.\"\"\"\n\n    _paths: set[Path]\n\n    def __init__(self, paths: Sequence[Path], callback: Callable[[], None]) -> None:\n        \"\"\"Monitor the given file paths for changes.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check(self) -> bool:\n# Natural Language Annotations: \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef check(self) -> bool:\n    modified = self._get_last_modified_time()\n    changed = modified != self._modified\n    self._modified = modified\n    return changed\n```", "```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    modified = self._get_last_modified_time()\n    changed = modified != self._modified\n    self._modified = modified\n    return changed\n```", "```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    modified = self._get_last_modified_time()\n    changed = modified != self._modified\n    self._modified = modified\n    return changed\n```"]}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        line: The `Text` instance to expand tabs in.\n        tab_widths: The widths to expand tabs to.\n\n    Returns:\n        A new text instance with tab characters converted to spaces.\n    \"\"\"\n    if \"\\t\" not in line.plain:\n        return line\n\n    parts = line.split(\"\\t\", include_separator=True)\n    tab_widths_iter = iter(tab_widths)\n------------------------------\n------------------------------\ndef get_tab_widths(line: str, tab_size: int = 4) -> list[tuple[str, int]]:\n    \"\"\"Splits a string line into tuples (str, int).\n\n    Each tuple represents a section of the line which precedes a tab character.\n    The string is the string text that appears before the tab character (excluding the tab).\n    The integer is the width that the tab character is expanded to.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n------------------------------\n------------------------------\ndef expand_text_tabs_from_widths(line: Text, tab_widths: list[int]) -> Text:\n    \"\"\"Expand tabs to the widths defined in the `tab_widths` list.\n\n    This will return a new Text instance with tab characters expanded into a\n    number of spaces. Each time a tab is encountered, it's expanded into the\n    next integer encountered in the `tab_widths` list. Consequently, the length\n    of `tab_widths` should match the number of tab characters in `line`.\n------------------------------\n------------------------------\nArgs:\n        text: The text to examine.\n        width: The available cell width.\n        tab_size: The tab stop width.\n        fold: If True, words longer than `width` will be folded onto a new line.\n        precomputed_tab_sections: The output of `get_tab_widths` can be passed here directly,\n            to prevent us from having to recompute the value.\n------------------------------\n------------------------------\nReturns:\n        A list of tuples representing the line split on tab characters,\n            and the widths of the tabs after tab expansion is applied.\n    \"\"\"\n\n    parts: list[tuple[str, int]] = []\n    add_part = parts.append\n    cell_position = 0\n    matches = _TABS_SPLITTER_RE.findall(line)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n# Natural Language Annotations: \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\"\"\"\n    parts = line.split('\\t')\n    result = []\n    for part in parts:\n        if part == '':\n            result.append(' ' * tab_size)\n        else:\n            result.append(part)\n    return ''.join(result)\n```", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    parts = line.split('\\t')\n    result = []\n    for part in parts:\n        result.append(part.replace('\\t', ' ' * tab_size))\n    return ''.join(result)\n```", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\"\"\"\n\n    parts = line.split('\\t')\n    result = []\n    for part in parts:\n        if part == '':\n            result.append('\\t')\n        else:\n            result.append(part)\n            result.append(' ' * (tab_size - len(part) % tab_size))\n    return ''.join(result)\n```"]}, "textual-src/textual/_resolve.py-resolve": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        dimensions: A list of Scalars or Nones for each dimension.\n        widgets: Widgets in resolve.\n        size: Size of container.\n        viewport_size: Viewport size.\n        margin: Total space occupied by margin\n        resolve_dimension: Which dimension to resolve.\n\n    Returns:\n        List of resolved box models.\n    \"\"\"\n    margin_width, margin_height = margin\n------------------------------\n------------------------------\ncolumns = resolve(column_scalars, size.width, gutter_vertical, size, viewport)\n------------------------------\n------------------------------\n@lru_cache(maxsize=4096)\n    def resolve(\n        self, size: Size, viewport: Size, fraction_unit: Fraction | None = None\n    ) -> Fraction:\n        \"\"\"Resolve scalar with units in to a dimensions.\n\n        Args:\n            size: Size of the container.\n            viewport: Size of the viewport (typically terminal size)\n\n        Raises:\n            ScalarResolveError: If the unit is unknown.\n------------------------------\n------------------------------\ndef resolve_box_models(\n    dimensions: list[Scalar | None],\n    widgets: list[Widget],\n    size: Size,\n    viewport_size: Size,\n    margin: Size,\n    resolve_dimension: Literal[\"width\", \"height\"] = \"width\",\n) -> list[BoxModel]:\n    \"\"\"Resolve box models for a list of dimensions\n------------------------------\n------------------------------\ndef layout_resolve(total: int, edges: Sequence[EdgeProtocol]) -> list[int]:\n    \"\"\"Divide total space to satisfy size, fraction, and min_size, constraints.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def resolve(\n# Natural Language Annotations: \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef resolve(\n    dimensions: list[Scalar | None],\n    total: int,\n    gutter: int,\n    size: Size,\n    viewport: Size,\n) -> list[tuple[int, int]]:\n    \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    resolved_dimensions = []\n    offset = 0\n    for dimension in dimensions:\n        resolved_dimension = resolve_scalar(dimension, total, size, viewport)\n        resolved_dimensions.append((offset, resolved_dimension))\n        offset += resolved_dimension + gutter\n    return resolved_dimensions\n```", "```python\ndef resolve(dimensions: list[Scalar | None], total: int, gutter: int, size: Size, viewport: Size) -> list[tuple[int, int]]:\n    result = []\n    current = 0\n\n    for dimension in dimensions:\n        if dimension is None:\n            remaining_space = total - current\n            if remaining_space < gutter:\n                length = remaining_space\n                offset = total - length\n            else:\n                length = gutter\n                offset = current\n        else:\n            resolved = resolve(size, viewport)\n            length = resolved.fraction\n            offset = current\n\n        result.append((offset, length))\n        current += length + gutter\n\n    return result\n```", "```python\ndef resolve(\n    dimensions: list[Scalar | None],\n    total: int,\n    gutter: int,\n    size: Size,\n    viewport: Size,\n) -> list[tuple[int, int]]:\n    resolved = []\n\n    for dim in dimensions:\n        if dim is None:\n            resolved.append((0, 0))\n            continue\n\n        # Assuming Scalar has properties for:\n        # - value\n        # - unit (e.g., \"px\", \"%\", \"fr\")\n\n        if dim.unit == \"px\":\n            resolved.append((0, dim.value))\n        elif dim.unit == \"%\":\n            resolved.append((0, size.width * dim.value // 100))\n        elif dim.unit == \"fr\":\n            resolved.append((0, total * dim.value // sum(d.value for d in dimensions if d.unit == \"fr\")))\n        else:\n            raise ValueError(f\"Unknown unit: {dim.unit}\")\n\n    return resolved\n```"]}, "textual-src/textual/widget.py-mount": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def mount(\n# Natural Language Annotations: \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef mount(self, *widgets, before=None, after=None):\n    if before and after:\n        raise MountError(\"Only one of `before` or `after` can be provided.\")\n\n    mounts = []\n    for widget in widgets:\n        if isinstance(before, int):\n            mounts.append(widget.mount_before(self.children[before]))\n        elif isinstance(before, str):\n            mounts.append(widget.mount_before(self.query_one(before)))\n        elif isinstance(after, int):\n            mounts.append(widget.mount_after(self.children[after]))\n        elif isinstance(after, str):\n            mounts.append(widget.mount_after(self.query_one(after)))\n        else:\n            mounts.append(widget.mount(self))\n\n    return asyncio.gather(*mounts)\n```", "```python\ndef mount(self, *widgets, before=None, after=None):\n    \"\"\"Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before and after:\n        raise MountError(\"Only one of `before` or `after` can be provided.\")\n\n    # Your implementation here\n```", "```python\ndef mount(self, *widgets, before=None, after=None):\n    if before and after:\n        raise MountError(\"Only one of before or after can be provided.\")\n\n    # Code to mount the widgets\n\n    return mount_task  # An awaitable object\n```"]}, "textual-src/textual/widget.py-move_child": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def move_child(\n# Natural Language Annotations: \"\"\"Move a child widget within its parent's list of children.\n\n        Args:\n            child: The child widget to move.\n            before: Child widget or location index to move before.\n            after: Child widget or location index to move after.\n\n        Raises:\n            WidgetError: If there is a problem with the child or target.\n\n        Note:\n            Only one of `before` or `after` can be provided. If neither\n            or both are provided a `WidgetError` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef move_child(child, before=None, after=None):\n    if (before is None and after is None) or (before is not None and after is not None):\n        raise WidgetError(\"Either 'before' or 'after' must be provided, but not both.\")\n\n    # Your function implementation here\n    pass\n```", "```python\ndef move_child(child, before=None, after=None):\n    if (before is None and after is None) or (before is not None and after is not None):\n        raise WidgetError(\"Only one of `before` or `after` can be provided.\")\n\n    if before is not None:\n        # find parent and index of child\n        parent = child.parent\n        if isinstance(before, int):\n            target_index = before\n        elif isinstance(before, str):\n            target_widget = parent.query_one(before)\n            target_index = parent.children.index(target_widget)\n        else:\n            raise WidgetError(\"Invalid type for `before`.\")\n\n        # remove child from current location and insert it at target location\n        child_index = parent.children.index(child)\n        parent.children.pop(child_index)\n        parent.children.insert(target_index, child)\n\n    if after is not None:\n        # find parent and index of child\n        parent = child.parent\n        if isinstance(after, int):\n            target_index = after + 1\n        elif isinstance(after, str):\n            target_widget = parent.query_one(after)\n            target_index = parent.children.index(target_widget) + 1\n        else:\n            raise WidgetError(\"Invalid type for `after`.\")\n\n        # remove child from current location and insert it at target location\n        child_index = parent.children.index(child)\n        parent.children.pop(child_index)\n        parent.children.insert(target_index, child)\n```", "```python\ndef move_child(child, before=None, after=None):\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of `before` or `after` can be provided.\")\n    if before is None and after is None:\n        raise WidgetError(\"Either `before` or `after` must be provided.\")\n    \n    if isinstance(before, int):\n        # Move the child before the child at the given index\n        child.parent.children.insert(before, child)\n    elif isinstance(before, str):\n        # Move the child before the widget returned by the query\n        target = child.parent.query_one(before)\n        child.parent.children.insert(child.parent.children.index(target), child)\n    elif isinstance(after, int):\n        # Move the child after the child at the given index\n        child.parent.children.insert(after+1, child)\n    elif isinstance(after, str):\n        # Move the child after the widget returned by the query\n        target = child.parent.query_one(after)\n        child.parent.children.insert(child.parent.children.index(target)+1, child)\n```"]}, "textual-src/textual/widget.py-_get_box_model": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n------------------------------\n------------------------------\nresolve_dimension,\n        )\n        width_fraction = fraction_unit\n        height_fraction = Fraction(margin_size.height)\n    else:\n        total_remaining = int(\n            sum(\n                [\n                    box_model.height\n                    for widget, box_model in zip(widgets, box_models)\n                    if (box_model is not None and widget.styles.overlay != \"screen\")\n                ]\n            )\n        )\n------------------------------\n------------------------------\nmargin_size = size - margin\n\n    # Fixed box models\n    box_models: list[BoxModel | None] = [\n        (\n            None\n            if _dimension is not None and _dimension.is_fraction\n            else widget._get_box_model(\n                size, viewport_size, fraction_width, fraction_height\n            )\n        )\n        for (_dimension, widget) in zip(dimensions, widgets)\n    ]\n------------------------------\n------------------------------\ndef resolve_fraction_unit(\n    widget_styles: Iterable[RenderStyles],\n    size: Size,\n    viewport_size: Size,\n    remaining_space: Fraction,\n    resolve_dimension: Literal[\"width\", \"height\"] = \"width\",\n) -> Fraction:\n    \"\"\"Calculate the fraction.\n\n    Args:\n        widget_styles: Styles for widgets with fraction units.\n        size: Container size.\n        viewport_size: Viewport size.\n        remaining_space: Remaining space for fr units.\n        resolve_dimension: Which dimension to resolve.\n------------------------------\n------------------------------\nbox_model = dock_widget._get_box_model(\n            size, viewport, Fraction(size.width), Fraction(size.height)\n        )\n        widget_width_fraction, widget_height_fraction, margin = box_model\n\n        widget_width = int(widget_width_fraction) + margin.width\n        widget_height = int(widget_height_fraction) + margin.height\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_box_model(\n# Natural Language Annotations: \"\"\"Process the box model for this widget.\n\n        Args:\n            container: The size of the container widget (with a layout)\n            viewport: The viewport size.\n            width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n            height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n        Returns:\n            The size and margin for this widget.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_box_model(\n    container: Size,\n    viewport: Size,\n    width_fraction: Fraction,\n    height_fraction: Fraction,\n) -> Tuple[Fraction, Fraction, Margin]:\n    # Implement your logic here\n    pass\n```", "```python\ndef _get_box_model(\n    container: Size,\n    viewport: Size,\n    width_fraction: Fraction,\n    height_fraction: Fraction,\n) -> Tuple[Fraction, Fraction, Margin]:\n\n    # Code implementation goes here\n```", "```python\ndef _get_box_model(\n    self,\n    container: Size,\n    viewport: Size,\n    width_fraction: Fraction,\n    height_fraction: Fraction\n) -> Tuple[Fraction, Fraction, Margin]:\n    # Implementation goes here\n```"]}, "textual-src/textual/widget.py-get_content_width": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Called by textual to get the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return DigitsRenderable.get_width(self._value)\n------------------------------\n------------------------------\nReturns:\n            An iterable of widget location\n        \"\"\"\n\n    def get_content_width(self, widget: Widget, container: Size, viewport: Size) -> int:\n        \"\"\"Get the optimal content width by arranging children.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport size.\n------------------------------\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n------------------------------\n------------------------------\ndef on_mount(self):\n        self._refresh_scrollbars()\n\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Gets the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return self.virtual_size.width\n------------------------------\n------------------------------\ndef on_mount(self):\n        self._refresh_scrollbars()\n\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Gets the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return self.virtual_size.width\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_width(self, container: Size, viewport: Size) -> int:\n# Natural Language Annotations: \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"\n    Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    pass\n```", "```\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    pass\n```", "```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    raise NotImplementedError\n```"]}, "textual-src/textual/widget.py-get_content_height": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n------------------------------\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Gets the height (number of lines) in the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n------------------------------\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Gets the height (number of lines) in the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n------------------------------\n------------------------------\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Called by textual to get the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return DigitsRenderable.get_width(self._value)\n------------------------------\n------------------------------\nArgs:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n# Natural Language Annotations: \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    pass\n```", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    # Your implementation here\n    return 3  # Always 3 lines\n```", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"\n    Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    raise NotImplementedError(\"Subclass must implement this method\")\n```"]}, "textual-src/textual/suggester.py-_get_suggestion": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            value: The current value of the requester widget.\n\n        Returns:\n            A valid suggestion or `None`.\n        \"\"\"\n        pass\n------------------------------\n------------------------------\nclass SuggestionReady(Message):\n    \"\"\"Sent when a completion suggestion is ready.\"\"\"\n\n    value: str\n    \"\"\"The value to which the suggestion is for.\"\"\"\n    suggestion: str\n    \"\"\"The string suggestion.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            selector: A selector to specify a widget that should be used as the reference\n                for the event offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the event may not land on the widget you specified.\n------------------------------\n------------------------------\nArgs:\n            selector: A selector to specify a widget that should be used as the reference\n                for the event offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the event may not land on the widget you specified.\n------------------------------\n------------------------------\nArgs:\n            selector: A selector to specify a widget that should be used as the reference\n                for the events offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the events may not land on the widget you specified.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n# Natural Language Annotations: \"\"\"Used by widgets to get completion suggestions.\n\n        Note:\n            When implementing custom suggesters, this method does not need to be\n            overridden.\n\n        Args:\n            requester: The message target that requested a suggestion.\n            value: The current value to complete.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n```", "```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    pass\n```", "```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n```"]}, "textual-src/textual/dom.py-add_class": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *class_names: CSS class names to toggle.\n\n        Returns:\n            Self.\n        \"\"\"\n        check_identifiers(\"class name\", *class_names)\n        old_classes = self._classes.copy()\n        self._classes.symmetric_difference_update(class_names)\n        if old_classes == self._classes:\n            return self\n        self._update_styles()\n        return self\n------------------------------\n------------------------------\nShould be called whenever CSS classes / pseudo classes change.\n        \"\"\"\n        try:\n            self.app.update_styles(self)\n        except NoActiveAppError:\n            pass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def remove_class(self, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Remove class names from this Node.\n\n        Args:\n            *class_names: CSS class names to remove.\n            update: Also update styles.\n------------------------------\n------------------------------\nArgs:\n            add: Add the classes if True, otherwise remove them.\n\n        Returns:\n            Self.\n        \"\"\"\n        for node in self:\n            node.set_class(add, *class_names)\n        return self\n\n    def set_classes(self, classes: str | Iterable[str]) -> DOMQuery[QueryType]:\n        \"\"\"Set the classes on nodes to exactly the given set.\n\n        Args:\n            classes: A string of space separated classes, or an iterable of class names.\n------------------------------\n------------------------------\nReturns:\n            Self.\n        \"\"\"\n        check_identifiers(\"class name\", *class_names)\n        old_classes = self._classes.copy()\n        self._classes.difference_update(class_names)\n        if old_classes == self._classes:\n            return self\n        if update:\n            self._update_styles()\n        return self\n\n    def toggle_class(self, *class_names: str) -> Self:\n        \"\"\"Toggle class names on this Node.\n------------------------------\n------------------------------\ndef add_class(self, *class_names: str) -> DOMQuery[QueryType]:\n        \"\"\"Add the given class name(s) to nodes.\"\"\"\n        for node in self:\n            node.add_class(*class_names)\n        return self\n\n    def remove_class(self, *class_names: str) -> DOMQuery[QueryType]:\n        \"\"\"Remove the given class names from the nodes.\"\"\"\n        for node in self:\n            node.remove_class(*class_names)\n        return self\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_class(self, *class_names: str, update: bool = True) -> Self:\n# Natural Language Annotations: \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```"]}, "textual-src/textual/reactive.py-_initialize_object": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@classmethod\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def _reset_object(cls, obj: object) -> None:\n        \"\"\"Reset reactive structures on object (to avoid reference cycles).\n\n        Args:\n            obj: A reactive object.\n        \"\"\"\n        getattr(obj, \"__watchers\", {}).clear()\n        getattr(obj, \"__computes\", []).clear()\n------------------------------\n------------------------------\n# Refresh according to descriptor flags\n            if self._layout or self._repaint or self._recompose:\n                obj.refresh(\n                    repaint=self._repaint,\n                    layout=self._layout,\n                    recompose=self._recompose,\n                )\n\n    @classmethod\n    def _check_watchers(cls, obj: Reactable, name: str, old_value: Any) -> None:\n        \"\"\"Check watchers, and call watch methods / computes\n------------------------------\n------------------------------\nArgs:\n        node: The node that created the watcher.\n        obj: The parent object.\n        attribute_name: The attribute to watch.\n        callback: A callable to call when the attribute changes.\n        init: True to call watcher initialization.\n    \"\"\"\n    if not hasattr(obj, \"__watchers\"):\n        setattr(obj, \"__watchers\", {})\n    watchers: dict[str, list[tuple[Reactable, WatchCallbackType]]] = getattr(\n        obj, \"__watchers\"\n    )\n------------------------------\n------------------------------\nclass reactive(Reactive[ReactiveType]):\n    \"\"\"Create a reactive attribute.\n\n    Args:\n        default: A default value or callable that returns a default.\n        layout: Perform a layout on change.\n        repaint: Perform a repaint on change.\n        init: Call watchers on initialize (post mount).\n        always_update: Call watchers even when the new value equals the old value.\n        bindings: Refresh bindings when the reactive changes.\n    \"\"\"\n------------------------------\n------------------------------\nArgs:\n            obj: Object containing attribute to watch.\n            attribute_name: Attribute to watch.\n            callback: A callback to run when attribute changes.\n            init: Check watchers on first call.\n        \"\"\"\n        _watch(self, obj, attribute_name, callback, init=init)\n\n    def get_pseudo_classes(self) -> Iterable[str]:\n        \"\"\"Get any pseudo classes applicable to this Node, e.g. hover, focus.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _initialize_object(cls, obj: Reactable) -> None:\n# Natural Language Annotations: \"\"\"Set defaults and call any watchers / computes for the first time.\n\n        Args:\n            obj: An object with Reactive descriptors\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr_name in vars(obj):\n        attr = getattr(obj, attr_name)\n        if isinstance(attr, Reactive):\n            attr._initialize()\n        elif isinstance(attr, Computed):\n            attr._initialize()\n    cls._check_watchers(obj, '', None)\n```", "```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr, value in vars(obj).items():\n        if isinstance(value, reactive):\n            if value.default is not None:\n                setattr(obj, attr, value.default()) if callable(value.default) else value.default\n    cls._reset_object(obj)\n    cls._check_watchers(obj, \"__init__\", None)\n```", "```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for descriptor in obj.__dict__.values():\n        if isinstance(descriptor, reactive):\n            descriptor._set_default(obj)\n\n    _check_watchers(obj, \"\", None)\n```"]}, "textual-src/textual/message_pump.py-call_after_refresh": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n------------------------------\n------------------------------\ndef call_next(self, callback: Callback, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Schedule a callback to run immediately after processing the current message.\n------------------------------\n------------------------------\ndef _invoke_later(self, callback: CallbackType, sender: MessagePump) -> None:\n        \"\"\"Enqueue a callback to be invoked after the screen is repainted.\n\n        Args:\n            callback: A callback.\n            sender: The sender (active message pump) of the callback.\n        \"\"\"\n\n        self._callbacks.append((callback, sender))\n        self.check_idle()\n------------------------------\n------------------------------\nThis method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n------------------------------\n------------------------------\nasync def _invoke_and_clear_callbacks(self) -> None:\n        \"\"\"If there are scheduled callbacks to run, call them and clear\n        the callback queue.\"\"\"\n        if self._callbacks:\n            callbacks = self._callbacks[:]\n            self._callbacks.clear()\n            for callback, message_pump in callbacks:\n                reset_token = active_message_pump.set(message_pump)\n                try:\n                    await invoke(callback)\n                finally:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if not self._callbacks:\n        return False\n    self._callbacks.append((callback, *args, **kwargs))\n    self.check_idle()\n    return True\n```", "```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if not self.is_running:\n        return False\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._next_callbacks.append(callback_message)\n    return True\n```", "```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._next_callbacks.append(callback_message)\n    self.check_idle()\n    if self._has_screen and not self._screen._dirty:\n        self._invoke_later(self._next_callbacks.pop(0), self)\n        return True\n    return False\n```"]}, "textual-src/textual/message_pump.py-call_later": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n------------------------------\n------------------------------\ndef call_next(self, callback: Callback, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Schedule a callback to run immediately after processing the current message.\n------------------------------\n------------------------------\nThis method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n------------------------------\n------------------------------\nArgs:\n            event: An Event object.\n        \"\"\"\n        await self._on_message(event)\n\n    async def _on_message(self, message: Message) -> None:\n        \"\"\"Called to process a message.\n\n        Args:\n            message: A Message object.\n        \"\"\"\n        _rich_traceback_guard = True\n        handler_name = message.handler_name\n------------------------------\n------------------------------\nArgs:\n        event_target: The object which will receive the timer events.\n        interval: The time between timer events, in seconds.\n        name: A name to assign the event (for debugging).\n        callback: A optional callback to invoke when the event is handled.\n        repeat: The number of times to repeat the timer, or None to repeat forever.\n        skip: Enable skipping of scheduled events that couldn't be sent in time.\n        pause: Start the timer paused.\n    \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._later_callbacks.append(callback_message)\n    self.check_idle()\n```", "```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        True if the callback was scheduled, or False if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if not self._open:\n        return False\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._next_callbacks.append(callback_message)\n    return True\n```", "```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n```"]}, "textual-src/textual/message_pump.py-post_message": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef post_message(self, message: Message) -> bool:\n        \"\"\"Post a message to this widget.\n\n        Args:\n            message: Message to post.\n------------------------------\n------------------------------\nArgs:\n            event: An Event object.\n        \"\"\"\n        await self._on_message(event)\n\n    async def _on_message(self, message: Message) -> None:\n        \"\"\"Called to process a message.\n\n        Args:\n            message: A Message object.\n        \"\"\"\n        _rich_traceback_guard = True\n        handler_name = message.handler_name\n------------------------------\n------------------------------\nArgs:\n            value: The current value of the requester widget.\n\n        Returns:\n            A valid suggestion or `None`.\n        \"\"\"\n        pass\n------------------------------\n------------------------------\nasync def _dispatch_message(self, message: Message) -> None:\n        \"\"\"Dispatch a message received from the message queue.\n\n        Args:\n            message: A message object\n        \"\"\"\n        _rich_traceback_guard = True\n        if message.no_dispatch:\n            return\n\n        try:\n            message_hook = message_hook_context_var.get()\n        except LookupError:\n            pass\n        else:\n            message_hook(message)\n------------------------------\n------------------------------\ndef check_message_enabled(self, message: Message) -> bool:\n        \"\"\"Check if a given message is enabled (allowed to be sent).\n\n        Args:\n            message: A message object.\n\n        Returns:\n            `True` if the message will be sent, or `False` if it is disabled.\n        \"\"\"\n        return type(message) not in self._disabled_messages\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def post_message(self, message: Message) -> bool:\n# Natural Language Annotations: \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    return self._on_message(message)\n```", "```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    try:\n        self._message_queue.put_nowait(message)\n        return True\n    except asyncio.QueueFull:\n        return False\n```", "```python\ndef post_message(self, message: Message) -> bool:\n        \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\n        try:\n            return self._on_message(message)\n        except Exception:\n            return False\n```"]}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@lru_cache(maxsize=4096)\n    def intersection(self, region: Region) -> Region:\n        \"\"\"Get the overlapping portion of the two regions.\n\n        Args:\n            region: A region that overlaps this region.\n------------------------------\n------------------------------\nReturns:\n            Set of placements.\n        \"\"\"\n        if self.total_region in region:\n            # Short circuit for when we want all the placements\n            return self.placements\n        visible_placements = self.spatial_map.get_values_in_region(region)\n        overlaps = region.overlaps\n        culled_placements = [\n            placement\n            for placement in visible_placements\n            if placement.fixed or overlaps(placement.region)\n        ]\n------------------------------\n------------------------------\nArgs:\n            regions_and_values: An iterable of (REGION, FIXED, OVERLAY, VALUE).\n        \"\"\"\n        append_fixed = self._fixed.append\n        get_grid_list = self._map.__getitem__\n        _region_to_grid = self._region_to_grid_coordinates\n        total_region = self.total_region\n        for region, fixed, overlay, value in regions_and_values:\n            if fixed:\n                append_fixed(value)\n            else:\n                if not overlay:\n------------------------------\n------------------------------\nReturns:\n            A Region that encloses all other regions.\n        \"\"\"\n        if not regions:\n            raise ValueError(\"At least one region expected\")\n        min_x = min(regions, key=itemgetter(0)).x\n        max_x = max(regions, key=attrgetter(\"right\")).right\n        min_y = min(regions, key=itemgetter(1)).y\n        max_y = max(regions, key=attrgetter(\"bottom\")).bottom\n        return cls(min_x, min_y, max_x - min_x, max_y - min_y)\n------------------------------\n------------------------------\nreturn self._spatial_map\n\n    @property\n    def total_region(self) -> Region:\n        \"\"\"The total area occupied by the arrangement.\n\n        Returns:\n            A Region.\n        \"\"\"\n        _top, right, bottom, _left = self.scroll_spacing\n        return self.spatial_map.total_region.grow((0, right, bottom, 0))\n\n    def get_visible_placements(self, region: Region) -> list[WidgetPlacement]:\n        \"\"\"Get the placements visible within the given region.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_values_in_region(self, region: Region) -> list[ValueType]:\n# Natural Language Annotations: \"\"\"Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    visible_placements = self.spatial_map.get_values_in_region(region)\n    overlaps = region.overlaps\n    culled_placements = [\n        placement\n        for placement in visible_placements\n        if placement.fixed or overlaps(placement.region)\n    ]\n    return culled_placements\n```", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    visible_placements = self.spatial_map.get_values_in_region(region)\n    overlaps = region.overlaps\n    culled_placements = [\n        placement\n        for placement in visible_placements\n        if placement.fixed or overlaps(placement.region)\n    ]\n    return culled_placements\n```", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n\n    # Retrieve all values that intersect with the given region\n    values = self.spatial_map.get_values_in_region(region)\n    \n    # Return the values\n    return values\n```"]}, "textual-src/textual/validation.py-validate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            value: The value\n\n        Returns:\n            The key\n        \"\"\"\n        return self._reverse.get(value)\n\n    def contains_value(self, value: Value) -> bool:\n        \"\"\"Check if `value` is a value within this TwoWayDict.\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            True if the value is within the values of this dict.\n        \"\"\"\n        return value in self._reverse\n\n    def __len__(self):\n        return len(self._forward)\n------------------------------\n------------------------------\n@abstractmethod\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validate the value and return a ValidationResult describing the outcome of the validation.\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n\n    def describe_failure(self, failure: Failure) -> str | None:\n        \"\"\"Return a string description of the Failure.\n------------------------------\n------------------------------\nReturns:\n            A ValidationResult indicating success if the function returned True,\n                and failure if the function return False.\n        \"\"\"\n        is_valid = self.function(value)\n        if is_valid:\n            return self.success()\n        return self.failure(failures=Function.ReturnedFalse(self, value))\n\n    def describe_failure(self, failure: Failure) -> str | None:\n        \"\"\"Describes why the validator failed.\n------------------------------\n------------------------------\nReturns:\n            A string description of the failure.\n        \"\"\"\n        return self.failure_description\n\n    def success(self) -> ValidationResult:\n        \"\"\"Shorthand for `ValidationResult(True)`.\n\n        You can return success() from a `Validator.validate` method implementation to signal\n        that validation has succeeded.\n\n        Returns:\n            A ValidationResult indicating validation succeeded.\n        \"\"\"\n        return ValidationResult()\n------------------------------\n------------------------------\nclass ReturnedFalse(Failure):\n        \"\"\"Indicates validation failed because the supplied function returned False.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validate that the supplied function returns True.\n\n        Args:\n            value: The value to pass into the supplied function.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def validate(self, value: str) -> ValidationResult:\n# Natural Language Annotations: \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    is_valid = bool(urlparse(value).scheme)\n    if is_valid:\n        return self.success()\n    return self.failure(failures=Function.ReturnedFalse(self, value))\n```", "```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    from urllib.parse import urlparse\n\n    result = urlparse(value)\n    if result.scheme:\n        return self.success()\n    else:\n        return self.failure(failures=Function.ReturnedFalse(self, value))\n```", "```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    is_valid = validators.url(value)\n    if is_valid:\n        return self.success()\n    return self.failure(failures=ReturnedFalse(self, value))\n```"]}, "textual-src/textual/geometry.py-clamp": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            offset: An offset.\n\n        Returns:\n            A new offset that will fit inside the dimensions defined in the Size.\n        \"\"\"\n        return offset.clamp(self.width, self.height)\n------------------------------\n------------------------------\ndef __contains__(self, other: Any) -> bool:\n        try:\n            x: int\n            y: int\n            x, y = other\n        except Exception:\n            raise TypeError(\n                \"Dimensions.__contains__ requires an iterable of two integers\"\n            )\n        width, height = self\n        return width > x >= 0 and height > y >= 0\n\n    def clamp_offset(self, offset: Offset) -> Offset:\n        \"\"\"Clamp an offset to fit within the width x height.\n------------------------------\n------------------------------\nArgs:\n            width: Width of bounds.\n            height: Height of bounds.\n\n        Returns:\n            Clipped region.\n        \"\"\"\n        x1, y1, x2, y2 = self.corners\n\n        _clamp = clamp\n        new_region = Region.from_corners(\n            _clamp(x1, 0, width),\n            _clamp(y1, 0, height),\n            _clamp(x2, 0, width),\n            _clamp(y2, 0, height),\n        )\n        return new_region\n------------------------------\n------------------------------\nReturns:\n            An offset to add to the X coordinate.\n        \"\"\"\n        offset_x = 0\n        align_horizontal = self.align_horizontal\n        if align_horizontal != \"left\":\n            if align_horizontal == \"center\":\n                offset_x = (parent_width - width) // 2\n            else:\n                offset_x = parent_width - width\n        return offset_x\n\n    def _align_height(self, height: int, parent_height: int) -> int:\n        \"\"\"Align the height dimensions\n------------------------------\n------------------------------\nReturns:\n            A new region.\n        \"\"\"\n        expand_width, expand_height = size\n        x, y, width, height = self\n        return Region(\n            x - expand_width,\n            y - expand_height,\n            width + expand_width * 2,\n            height + expand_height * 2,\n        )\n\n    def clip_size(self, size: tuple[int, int]) -> Region:\n        \"\"\"Clip the size to fit within minimum values.\n\n        Args:\n            size: Maximum width and height.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def clamp(self, width: int, height: int) -> Offset:\n# Natural Language Annotations: \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    x = max(0, min(self.x, width))\n    y = max(0, min(self.y, height))\n    return Offset(x, y)\n```", "```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    x, y = self\n    x = max(0, min(width - 1, x))\n    y = max(0, min(height - 1, y))\n    return Offset(x, y)\n```", "```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    return Offset(max(0, min(width, self.width)), max(0, min(height, self.height)))\n```"]}, "textual-src/textual/constants.py-_get_textual_animations": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nAnimationLevel = Literal[\"none\", \"basic\", \"full\"]\n\"\"\"The levels that the [`TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS] env var can be set to.\"\"\"\n------------------------------\n------------------------------\nAnimationLevel = Literal[\"none\", \"basic\", \"full\"]\n\"\"\"The levels that the [`TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS] env var can be set to.\"\"\"\n------------------------------\n------------------------------\nself.animation_level: AnimationLevel = constants.TEXTUAL_ANIMATIONS\n        \"\"\"Determines what type of animations the app will display.\n\n        See [`textual.constants.TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS].\n        \"\"\"\n\n        self._last_focused_on_app_blur: Widget | None = None\n        \"\"\"The widget that had focus when the last `AppBlur` happened.\n\n        This will be used to restore correct focus when an `AppFocus`\n        happens.\n        \"\"\"\n------------------------------\n------------------------------\nself.animation_level: AnimationLevel = constants.TEXTUAL_ANIMATIONS\n        \"\"\"Determines what type of animations the app will display.\n\n        See [`textual.constants.TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS].\n        \"\"\"\n\n        self._last_focused_on_app_blur: Widget | None = None\n        \"\"\"The widget that had focus when the last `AppBlur` happened.\n\n        This will be used to restore correct focus when an `AppFocus`\n        happens.\n        \"\"\"\n------------------------------\n------------------------------\nlevel: Minimum level required for the animation to take place (inclusive).\n        \"\"\"\n        self._animate(\n            attribute,\n            value,\n            final_value=final_value,\n            duration=duration,\n            speed=speed,\n            delay=delay,\n            easing=easing,\n            on_complete=on_complete,\n            level=level,\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_textual_animations() -> AnimationLevel:\n# Natural Language Annotations: \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nimport os\n\ndef _get_textual_animations() -> AnimationLevel:\n    anim_level = os.getenv(\"TEXTUAL_ANIMATIONS\", \"full\")\n    if anim_level not in AnimationLevel.__args__:\n        return \"full\"\n    return anim_level\n```", "```python\nimport os\nfrom textual.constants import AnimationLevel\n\ndef _get_textual_animations() -> AnimationLevel:\n    textual_animations = os.getenv(\"TEXTUAL_ANIMATIONS\", \"full\")\n    if textual_animations not in AnimationLevel.__args__:\n        return \"full\"\n    return textual_animations\n```", "```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    level = os.getenv(\"TEXTUAL_ANIMATIONS\", \"full\")\n    if level not in AnimationLevel.__args__:\n        level = \"full\"\n    return level\n```"]}, "textual-src/textual/color.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nFor example, `\"#46b3de\"`.\n        \"\"\"\n        r, g, b, _a = self.clamped\n        return f\"#{r:02X}{g:02X}{b:02X}\"\n\n    @property\n    def css(self) -> str:\n        \"\"\"The color in CSS RGB or RGBA form.\n\n        For example, `\"rgb(10,20,30)\"` for an RGB color, or `\"rgb(50,70,80,0.5)\"` for an RGBA color.\n        \"\"\"\n        r, g, b, a = self\n        return f\"rgb({r},{g},{b})\" if a == 1 else f\"rgba({r},{g},{b},{a})\"\n------------------------------\n------------------------------\nFor example, `\"#46b3de\"` for an RGB color, or `\"#3342457f\"` for a color with alpha.\n        \"\"\"\n        r, g, b, a = self.clamped\n        return (\n            f\"#{r:02X}{g:02X}{b:02X}\"\n            if a == 1\n            else f\"#{r:02X}{g:02X}{b:02X}{int(a*255):02X}\"\n        )\n\n    @property\n    def hex6(self) -> str:\n        \"\"\"The color in CSS hex form, with 6 digits for RGB. Alpha is ignored.\n------------------------------\n------------------------------\nHSL color is an alternative way of representing a color, which can be used in certain color calculations.\n\n        Returns:\n            Color encoded in HSL format.\n        \"\"\"\n        r, g, b = self.normalized\n        h, l, s = rgb_to_hls(r, g, b)\n        return HSL(h, s, l)\n\n    @property\n    def brightness(self) -> float:\n        \"\"\"The human perceptual brightness.\n------------------------------\n------------------------------\nArgs:\n            obj: The ``Styles`` object.\n            color: The color to set. Pass a ``Color`` instance directly,\n                or pass a ``str`` which will be parsed into a color (e.g. ``\"red\"\"``, ``\"rgb(20, 50, 80)\"``,\n                ``\"#f4e32d\"``).\n------------------------------\n------------------------------\nA value of 1 is returned for pure white, and 0 for pure black.\n        Other colors lie on a gradient between the two extremes.\n        \"\"\"\n        r, g, b = self.normalized\n        brightness = (299 * r + 587 * g + 114 * b) / 1000\n        return brightness\n\n    @property\n    def hex(self) -> str:\n        \"\"\"The color in CSS hex form, with 6 digits for RGB, and 8 digits for RGBA.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(cls, color_text: str | Color) -> Color:\n# Natural Language Annotations: \"\"\"Parse a string containing a named color or CSS-style color.\n\n        Colors may be parsed from the following formats:\n\n        - Text beginning with a `#` is parsed as a hexadecimal color code,\n         where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n            - `#RGB`\n            - `#RGBA`\n            - `#RRGGBB`\n            - `#RRGGBBAA`\n\n        - Alternatively, RGB colors can also be specified in the format\n         that follows, where R, G, and B must be numbers between 0 and 255\n         and A must be a value between 0 and 1:\n\n            - `rgb(R,G,B)`\n            - `rgb(R,G,B,A)`\n\n        - The HSL model can also be used, with a syntax similar to the above,\n         if H is a value between 0 and 360, S and L are percentages, and A\n         is a value between 0 and 1:\n\n            - `hsl(H,S,L)`\n            - `hsla(H,S,L,A)`\n\n        Any other formats will raise a `ColorParseError`.\n\n        Args:\n            color_text: Text with a valid color format. Color objects will\n                be returned unmodified.\n\n        Raises:\n            ColorParseError: If the color is not encoded correctly.\n\n        Returns:\n            Instance encoding the color specified by the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n    color_text = color_text.strip().lower()\n    if color_text.startswith(\"#\"):\n        return cls.from_hex(color_text)\n    elif color_text.startswith(\"rgb(\"):\n        return cls.from_rgb(color_text)\n    elif color_text.startswith(\"hsl(\"):\n        return cls.from_hsl(color_text)\n    else:\n        raise ColorParseError(f\"Invalid color format: {color_text}\")\n```", "```python\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n    elif isinstance(color_text, str):\n        if color_text.startswith(\"#\"):\n            # Parse hexadecimal color\n            if len(color_text) == 4:\n                r = int(color_text[1]*2, 16)\n                g = int(color_text[2]*2, 16)\n                b = int(color_text[3]*2, 16)\n                a = 1\n            elif len(color_text) == 5:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[2:4], 16)\n                b = int(color_text[3:5], 16)\n                a = 1\n            elif len(color_text) == 7:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[3:5], 16)\n                b = int(color_text[5:7], 16)\n                a = 1\n            elif len(color_text) == 9:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[3:5], 16)\n                b = int(color_text[5:7], 16)\n                a = int(color_text[7:9], 16) / 255\n            else:\n                raise ColorParseError(\"Invalid hex color format\")\n        elif color_text.startswith(\"rgb\"):\n            # Parse rgb color\n            color_values = color_text[color_text.index('(')+1:color_text.index(')')].split(',')\n            if len(color_values) in [3, 4]:\n                r = int(color_values[0])\n                g = int(color_values[1])\n                b = int(color_values[2])\n                a = float(color_values[3]) if len(color_values) == 4 else 1\n            else:\n                raise ColorParseError(\"Invalid RGB color format\")\n        elif color_text.startswith(\"hsl\"):\n            # Parse hsl color\n            color_values = color_text[color_text.index('(')+1:color_text.index(')')].split(',')\n            if len(color_values) in [3, 4]:\n                h = float(color_values[0])\n                s = float(color_values[1][:-1])/100\n                l = float(color_values[2][:-1])/100\n                a = float(color_values[3]) if len(color_values) == 4 else 1\n                r, g, b = hls_to_rgb(h, l, s)\n            else:\n                raise ColorParseError(\"Invalid HSL color format\")\n        else:\n            raise ColorParseError(\"Unrecognized color format\")\n        return cls(r, g, b, a)\n    else:\n        raise TypeError(\"Invalid color type\")\n```", "Here is the function based on the function signature and natural language annotations:\n\n```python\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n\n    if color_text.startswith(\"#\"):\n        if len(color_text) == 4:\n            r, g, b = (int(color_text[i]*2, 16) for i in range(1, 4))\n            a = 1\n        elif len(color_text) == 5:\n            r, g, b = (int(color_text[i]*2, 16) for i in range(1, 4))\n            a = int(color_text[-1]*2, 16) / 255\n        elif len(color_text) == 7:\n            r, g, b = (int(color_text[i:i+2], 16) for i in range(1, 6, 2))\n            a = 1\n        elif len(color_text) == 9:\n            r, g, b = (int(color_text[i:i+2], 16) for i in range(1, 6, 2))\n            a = int(color_text[-2:], 16) / 255\n        else:\n            raise ColorParseError\n    elif color_text.startswith(\"rgb\"):\n        match = re.match(r\"rgba?\\((.*)\\)\", color_text)\n        if match:\n            r, g, b, a = map(float, match.group(1).split(\",\"))\n            if a > 1:\n                a /= 255\n        else:\n            raise ColorParseError\n    elif color_text.startswith(\"hsl\"):\n        match = re.match(r\"hsla?\\((.*)\\)\", color_text)\n        if match:\n            h, s, l, a = map(float, match.group(1).split(\",\"))\n            r, g, b = hls_to_rgb(h/360, l/100, s/100)\n        else:\n            raise ColorParseError\n    else:\n        raise ColorParseError\n\n    return cls(r, g, b, a)\n```"]}, "textual-src/textual/_slug.py-slug": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef slug(text: str) -> str:\n    \"\"\"Create a Markdown-friendly slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n------------------------------\n------------------------------\nclass TrackedSlugs:\n    \"\"\"Provides a class for generating tracked slugs.\n\n    While [`slug`][textual._slug.slug] will generate a slug for a given\n    string, it does not guarantee that it is unique for a given context. If\n    you want to ensure that the same string generates unique slugs (perhaps\n    heading slugs within a Markdown document, as an example), use an\n    instance of this class to generate them.\n------------------------------\n------------------------------\n\"\"\"Provides a utility function and class for creating Markdown-friendly slugs.\n\nThe approach to creating slugs is designed to be as close to\nGitHub-flavoured Markdown as possible. However, because there doesn't appear\nto be any actual documentation for this 'standard', the code here involves\nsome guesswork and also some pragmatic shortcuts.\n\nExpect this to grow over time.\n\nThe main rules used in here at the moment are:\n------------------------------\n------------------------------\nReturns:\n        A slug for the given text.\n\n    The rules used in generating the slug are based on observations of how\n    GitHub-flavoured Markdown works.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    return quote(result)\n------------------------------\n------------------------------\ndef __init__(self, markdown: Markdown, *args, **kwargs) -> None:\n        self._markdown: Markdown = markdown\n        \"\"\"A reference to the Markdown document that contains this block.\"\"\"\n        self._text = Text()\n        self._token: Token | None = None\n        self._blocks: list[MarkdownBlock] = []\n        super().__init__(*args, **kwargs)\n\n    def compose(self) -> ComposeResult:\n        yield from self._blocks\n        self._blocks.clear()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def slug(self, text: str) -> str:\n# Natural Language Annotations: \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n        Args:\n            text: The text to generate a slug from.\n\n        Returns:\n            A slug for the given text.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    return quote(result)\n```", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    return quote(result)\n```", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    return quote(result)\n```"]}, "textual-src/textual/_styles_cache.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n------------------------------\n------------------------------\nArgs:\n            styles: Styles object.\n            y: The y coordinate of the line (relative to widget screen offset).\n            size: Size of the widget.\n            content_size: Size of the content area.\n            padding: Padding.\n            base_background: Background color of widget beneath this line.\n            background: Background color of widget.\n            render_content_line: Callback to render a line of content.\n            console: The console in use by the app.\n------------------------------\n------------------------------\nArgs:\n            styles: Styles object.\n            y: The y coordinate of the line (relative to widget screen offset).\n            size: Size of the widget.\n            content_size: Size of the content area.\n            padding: Padding.\n            base_background: Background color of widget beneath this line.\n            background: Background color of widget.\n            render_content_line: Callback to render a line of content.\n            console: The console in use by the app.\n------------------------------\n------------------------------\nbase_background, background = widget._opacity_background_colors\n        styles = widget.styles\n        strips = self.render(\n            styles,\n            widget.region.size,\n            base_background,\n            background,\n            widget.render_line,\n            widget.app.console,\n            (\n                None\n                if border_title is None\n                else (\n                    border_title,\n------------------------------\n------------------------------\nbase_background, background = widget._opacity_background_colors\n        styles = widget.styles\n        strips = self.render(\n            styles,\n            widget.region.size,\n            base_background,\n            background,\n            widget.render_line,\n            widget.app.console,\n            (\n                None\n                if border_title is None\n                else (\n                    border_title,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(\n# Natural Language Annotations: \"\"\"Render a widget content plus CSS styles.\n\n        Args:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            content_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef render(\n    styles: CSSStyles,\n    size: Size,\n    base_background: BackgroundColor,\n    background: BackgroundColor,\n    render_content_line: Callback,\n    console: AppConsole,\n    border_title: Optional[Tuple[str, Color, BackgroundColor, Style]],\n    border_subtitle: Optional[Tuple[str, Color, BackgroundColor, Style]],\n    content_size: Optional[Size] = None,\n    padding: Optional[Padding] = None,\n    crop: Optional[Region] = None,\n    filters: Optional[List[Filter]] = None,\n    opacity: Optional[float] = 1.0\n) -> RenderedLines:\n    # Implementation of the function goes here\n    pass\n```", "```python\ndef render(styles, size, base_background, background, render_content_line, console, \n           border_title=None, border_subtitle=None, content_size=None, padding=None, \n           crop=None, filters=None, opacity=1.0):\n    \n    # Code for rendering the widget goes here\n    pass\n```", "```python\ndef render(\n    styles: CSS_Styles_object,\n    size: Widget_size,\n    base_background: Background_color,\n    background: Widget_background_color,\n    render_content_line: Callback_to_render_content_line,\n    console: The_console_in_use_by_the_app,\n    border_title: Optional_tuple_of_title_color_background_style = None,\n    border_subtitle: Optional_tuple_of_subtitle_color_background_style = None,\n    content_size: Size_of_content_or_None_to_assume_full_size = None,\n    padding: Override_padding_from_Styles_or_None_to_use_styles_padding = None,\n    crop: Region_to_crop_to = None,\n    filters: Additional_post_processing_for_the_segments = None,\n    opacity: Widget_opacity = None\n) -> Rendered_lines:\n    # Function body goes here\n```"]}, "textual-src/textual/document/_document.py-replace_range": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n        top, bottom = sorted((start, end))\n------------------------------\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def text(self) -> str:\n        \"\"\"The text from the document as a string.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            start: The start location.\n            end: The end location.\n\n        Returns:\n            The text between start and end.\n        \"\"\"\n        start, end = sorted((start, end))\n        return self.document.get_text_range(start, end)\n\n    def edit(self, edit: Edit) -> EditResult:\n        \"\"\"Perform an Edit.\n\n        Args:\n            edit: The Edit to perform.\n------------------------------\n------------------------------\nArgs:\n            insert: The text to insert into the document.\n            start: The start location of the text to replace.\n            end: The end location of the text to replace.\n\n        Returns:\n            An EditResult or None if no edit was performed (e.g. on read-only mode).\n        \"\"\"\n        if self.read_only:\n            return None\n        return self.replace(insert, start, end, maintain_selection_offset=False)\n------------------------------\n------------------------------\nselection_start, selection_end = text_area.selection\n        selection_start_row, selection_start_column = selection_start\n        selection_end_row, selection_end_column = selection_end\n\n        edit_result = text_area.document.replace_range(self.top, self.bottom, text)\n\n        new_edit_to_row, new_edit_to_column = edit_result.end_location\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n# Natural Language Annotations: \"\"\"Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    start, end = sorted((start, end))\n    edit_result = self.document.replace_range(start, end, text)\n    return edit_result\n```", "```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    start, end = sorted((start, end))\n    edit_result = self.document.replace_range(start, end, text)\n    return edit_result\n```", "```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    if self.read_only:\n        return None\n    return self.replace(text, start, end, maintain_selection_offset=False)\n```"]}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n        top, bottom = sorted((start, end))\n------------------------------\n------------------------------\nArgs:\n            start: The start location.\n            end: The end location.\n\n        Returns:\n            The text between start and end.\n        \"\"\"\n        start, end = sorted((start, end))\n        return self.document.get_text_range(start, end)\n\n    def edit(self, edit: Edit) -> EditResult:\n        \"\"\"Perform an Edit.\n\n        Args:\n            edit: The Edit to perform.\n------------------------------\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def text(self) -> str:\n        \"\"\"The text from the document as a string.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            start: The start location of the selection.\n            end: The end location of the selection.\n\n        Returns:\n            The text between start (inclusive) and end (exclusive).\n        \"\"\"\n        if start == end:\n            return \"\"\n------------------------------\n------------------------------\nArgs:\n            insert: The text to insert into the document.\n            start: The start location of the text to replace.\n            end: The end location of the text to replace.\n\n        Returns:\n            An EditResult or None if no edit was performed (e.g. on read-only mode).\n        \"\"\"\n        if self.read_only:\n            return None\n        return self.replace(insert, start, end, maintain_selection_offset=False)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def wrap_range(\n# Natural Language Annotations: \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n        This must be called *after* the source document has been edited.\n\n        Args:\n            start: The start location of the edit that was performed in document-space.\n            old_end: The old end location of the edit in document-space.\n            new_end: The new end location of the edit in document-space.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef wrap_range(start: int, old_end: int, new_end: int) -> None:\n    # Incrementally recompute wrapping based on a performed edit.\n    # This must be called *after* the source document has been edited.\n\n    # Args:\n    #     start: The start location of the edit that was performed in document-space.\n    #     old_end: The old end location of the edit in document-space.\n    #     new_end: The new end location of the edit in document-space.\n\n    # Your code here\n```", "```python\ndef wrap_range(start, old_end, new_end):\n    if new_end > old_end:\n        self.document.wrap(start, old_end, new_end - old_end)\n    elif new_end < old_end:\n        self.document.wrap(start, new_end, old_end - new_end)\n    else:\n        return\n```", "```python\ndef wrap_range(\n    self,\n    start: Tuple[int, int],\n    old_end: Tuple[int, int],\n    new_end: Tuple[int, int]\n) -> None:\n    # Incrementally recompute wrapping based on a performed edit.\n\n    # This must be called *after* the source document has been edited.\n\n    # Args:\n    #     start: The start location of the edit that was performed in document-space.\n    #     old_end: The old end location of the edit in document-space.\n    #     new_end: The new end location of the edit in document-space.\n\n    # Your implementation here\n    pass\n```"]}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef location_to_offset(self, location: Location) -> Offset:\n        \"\"\"\n        Convert a location in the document to an offset within the wrapped/visual display of the document.\n\n        Args:\n            location: The location in the document.\n\n        Returns:\n            The Offset in the document's visual display corresponding to the given location.\n        \"\"\"\n        line_index, column_index = location\n------------------------------\n------------------------------\nArgs:\n             line_index: The index of the line in the document.\n             x_offset: The x-offset within the wrapped line.\n             y_offset: The y-offset within the wrapped line (supports negative indexing).\n\n        Returns:\n            The column index corresponding to the line index and y offset.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            The index in the document's text.\n        \"\"\"\n        row, column = location\n        index = row * len(self.newline) + column\n        for line_index in range(row):\n            index += len(self.get_line(line_index))\n        return index\n\n    def get_location_from_index(self, index: int) -> Location:\n        \"\"\"Given an index in the document's text, returns the corresponding location.\n\n        Args:\n            index: The index in the document's text.\n------------------------------\n------------------------------\nReturns:\n            The location corresponding to the end of the wrapped line.\n        \"\"\"\n        line_index, column_offset = location\n        wrap_offsets = self._wrapped_document.get_offsets(line_index)\n        if wrap_offsets:\n            # Get the next wrap offset to the right\n            next_offset_right = bisect(wrap_offsets, column_offset)\n            # There's no more wrapping to the right of this location - go to line end.\n------------------------------\n------------------------------\nReturns:\n            The offsets within the line where wrapping should occur.\n        \"\"\"\n        wrap_offsets = self._wrap_offsets\n        out_of_bounds = line_index < 0 or line_index >= len(wrap_offsets)\n        if out_of_bounds:\n            raise ValueError(\n                f\"The document line index {line_index!r} is out of bounds. \"\n                f\"The document contains {len(wrap_offsets)!r} lines.\"\n            )\n        return wrap_offsets[line_index]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def offset_to_location(self, offset: Offset) -> Location:\n# Natural Language Annotations: \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    # Find the line index of the offset\n    line_index = self._find_line_index(offset)\n    if line_index is None:\n        raise ValueError(\"The given offset does not correspond to a line in the document.\")\n\n    # Compute the column index\n    column_index = self._compute_column_index(line_index, offset)\n\n    return line_index, column_index\n```", "```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    line_index = offset.line_index\n    if line_index < 0 or line_index >= len(self._wrapped_document):\n        raise ValueError(f\"The document line index {line_index} is out of bounds.\")\n    wrap_offsets = self._wrapped_document.get_offsets(line_index)\n    for i, wrap_offset in enumerate(wrap_offsets):\n        if offset.y_offset < wrap_offset:\n            return Location(line_index, i - 1) if i > 0 else Location(line_index - 1, len(self._wrapped_document.get_offsets(line_index - 1)) - 1)\n    return Location(line_index, len(wrap_offsets) - 1)\n```", "```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    for line_index, y_offset in enumerate(self._wrapped_document.y_offsets):\n        if y_offset == offset:\n            return line_index, 0\n    raise ValueError(f\"The given offset does not correspond to a line in the document.\")\n```"]}, "textual-src/textual/css/parse.py-substitute_references": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef with_reference(self, by: ReferencedBy | None) -> \"Token\":\n        \"\"\"Return a copy of the Token, with reference information attached.\n        This is used for variable substitution, where a variable reference\n        can refer to tokens which were defined elsewhere. With the additional\n        ReferencedBy data attached, we can track where the token we are referring\n        to is used.\n        \"\"\"\n        return Token(\n            name=self.name,\n            value=self.value,\n------------------------------\n------------------------------\ndef _unresolved(variable_name: str, variables: Iterable[str], token: Token) -> NoReturn:\n    \"\"\"Raise a TokenError regarding an unresolved variable.\n\n    Args:\n        variable_name: A variable name.\n        variables: Possible choices used to generate suggestion.\n        token: The Token.\n------------------------------\n------------------------------\ndef tokenize_values(values: dict[str, str]) -> dict[str, list[Token]]:\n    \"\"\"Tokenizes the values in a dict of strings.\n\n    Args:\n        values: A mapping of CSS variable name on to a value, to be\n            added to the CSS context.\n\n    Returns:\n        A mapping of name on to a list of tokens,\n    \"\"\"\n    value_tokens = {\n        name: list(tokenize_value(value, (\"__name__\", \"\")))\n        for name, value in values.items()\n    }\n    return value_tokens\n------------------------------\n------------------------------\ndef __rich_repr__(self) -> rich.repr.Result:\n        yield list(self.source.keys())\n\n    @property\n    def _variable_tokens(self) -> dict[str, list[Token]]:\n        if self.__variable_tokens is None:\n            self.__variable_tokens = tokenize_values(self._variables)\n        return self.__variable_tokens\n\n    @property\n    def rules(self) -> list[RuleSet]:\n        \"\"\"List of rule sets.\n------------------------------\n------------------------------\nwhile tokens:\n                yield popleft()\n\n    def parse(\n        self, on_token: ByteStreamTokenCallback\n    ) -> Generator[Awaitable, bytes, None]:\n        \"\"\"Implement in a sub-class to define parse behavior.\n\n        Args:\n            on_token: A callable which accepts the token type, and returns None.\n\n        \"\"\"\n        yield from ()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def substitute_references(\n# Natural Language Annotations: \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef substitute_references(tokens: Iterator[Token]) -> Generator[Token, None, None]:\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            # assume that there is a function get_variable_value\n            # that returns the value of a variable\n            variable_value = get_variable_value(token.value)\n            yield from tokenize_value(variable_value, (\"__name__\", \"\"))\n        else:\n            yield token\n```", "```python\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    tokenized_values = {name: list(tokenize_value(value, (\"__name__\", \"\"))) for name, value in values.items()}\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            variable_name = token.value\n            if variable_name in tokenized_values:\n                yield from tokenized_values[variable_name]\n            else:\n                _unresolved(variable_name, tokenized_values.keys(), token)\n        else:\n            yield token\n```", "```python\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            variable_value = get_variable_value(token.value)  # replace this with actual logic to get variable value\n            for value_token in variable_value:\n                yield value_token.with_reference(referenced_by=token)\n        else:\n            yield token\n\ndef get_variable_value(variable_name: str) -> Iterator[Token]:\n    # replace this with actual logic to get variable value\n    pass\n```"]}, "textual-src/textual/css/parse.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n------------------------------\n------------------------------\ndef add_source(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_css: bool = False,\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n------------------------------\n------------------------------\ndef parse_declarations(css: str, read_from: CSSLocation) -> Styles:\n    \"\"\"Parse declarations and return a Styles object.\n\n    Args:\n        css: String containing CSS.\n        read_from: The location where the CSS was read from.\n\n    Returns:\n        A styles object.\n    \"\"\"\n\n    tokens = iter(tokenize_declarations(css, read_from))\n    styles_builder = StylesBuilder()\n------------------------------\n------------------------------\nArgs:\n            css: Textual CSS.\n            read_from: Location where the CSS was read from.\n            node: Node to associate with the Styles.\n\n        Returns:\n            A Styles instance containing result of parsing CSS.\n        \"\"\"\n        from .parse import parse_declarations\n\n        styles = parse_declarations(css, read_from)\n        styles.node = node\n        return styles\n\n    def _get_transition(self, key: str) -> Transition | None:\n        \"\"\"Get a transition.\n------------------------------\n------------------------------\n)\n            return\n        self.source[read_from] = CssSource(css, is_default_css, tie_breaker, scope)\n        self._require_parse = True\n        self._rules_map = None\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(\n# Natural Language Annotations: \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse(\n        self,\n        scope: str,\n        css: str,\n        read_from: CSSLocation,\n        variables: dict[str, str] | None = None,\n        is_default_rules: bool = False,\n    ) -> Styles:\n        \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n        and generating rule sets from it.\n\n        Args:\n            scope: CSS type name.\n            css: The input CSS.\n            read_from: The source location of the CSS.\n            variables: Substitution variables to substitute tokens for.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n\n        Returns:\n            A Styles instance containing result of parsing CSS.\n        \"\"\"\n        from .parse import tokenize_declarations\n        from .parse import CssSource\n        from .parse import StylesBuilder\n\n        tokens = iter(tokenize_declarations(css, read_from))\n        styles_builder = StylesBuilder()\n\n        # perform variable substitution\n        if variables:\n            for key, value in variables.items():\n                css = css.replace(key, value)\n\n        styles = self.parse_declarations(css, read_from)\n        styles.node = self.node\n        self.source[read_from] = CssSource(css, is_default_rules, self.tie_breaker, scope)\n        self._require_parse = True\n        self._rules_map = None\n\n        return styles\n```", "```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation,\n    variables: Dict[str, str],\n    is_default_rules: bool = False,\n) -> Styles:\n    \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n    # Perform variable substitution\n    css = substitute_variables(css, variables)\n\n    # Tokenize the CSS\n    tokens = tokenize_declarations(css, read_from)\n\n    # Generate rule sets\n    styles_builder = StylesBuilder()\n\n    # Iterate over the tokens and generate rule sets\n    for token in tokens:\n        # Add code to generate rule sets from tokens\n        pass\n\n    # Get the resulting Styles object\n    styles = styles_builder.styles\n\n    # Set additional attributes on the Styles object\n    styles.node = node\n\n    return styles\n```", "```python\ndef parse(\n        self,\n        scope: str,\n        css: str,\n        read_from: CSSLocation,\n        variables: dict[str, str],\n        is_default_rules: bool = False,\n    ) -> None:\n        \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n        and generating rule sets from it.\n\n        Args:\n            scope: CSS type name.\n            css: The input CSS.\n            read_from: The source location of the CSS.\n            variables: Substitution variables to substitute tokens for.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        \"\"\"\n        # Tokenize the CSS\n        tokens = tokenize_declarations(css, read_from)\n\n        # Perform variable substitution\n        for key, value in variables.items():\n            tokens = [token.replace(key, value) for token in tokens]\n\n        # Generate rule sets\n        rules = generate_rule_sets(tokens)\n\n        # Store the rules\n        self.rules[scope] = rules\n```"]}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n------------------------------\n------------------------------\nArgs:\n            css: Textual CSS.\n            read_from: Location where the CSS was read from.\n            node: Node to associate with the Styles.\n\n        Returns:\n            A Styles instance containing result of parsing CSS.\n        \"\"\"\n        from .parse import parse_declarations\n\n        styles = parse_declarations(css, read_from)\n        styles.node = node\n        return styles\n\n    def _get_transition(self, key: str) -> Transition | None:\n        \"\"\"Get a transition.\n------------------------------\n------------------------------\nArgs:\n            specificity: A node specificity.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n------------------------------\n------------------------------\n)\n            return\n        self.source[read_from] = CssSource(css, is_default_css, tie_breaker, scope)\n        self._require_parse = True\n        self._rules_map = None\n------------------------------\n------------------------------\ndef add_source(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_css: bool = False,\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _parse_rules(\n# Natural Language Annotations: \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _parse_rules(css: str, read_from: CSSLocation, is_default_rules: bool, scope: str) -> List[RuleSet]:\n    \"\"\"Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    try:\n        # Parse the CSS\n        rules = parse_css(css)\n        return rules\n    except Exception as e:\n        raise StylesheetError(f\"Invalid CSS: {e}\")\n```", "```python\ndef _parse_rules(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_rules: bool = False,\n        scope: str = \"\",\n    ) -> List[RuleSet]:\n        from .parse import parse_rules\n        from .rule_set import RuleSet\n\n        rules = parse_rules(css, read_from)\n        rule_sets = [RuleSet(rule) for rule in rules]\n\n        for rule_set in rule_sets:\n            rule_set.is_default_rules = is_default_rules\n            rule_set.scope = scope\n\n        return rule_sets\n```", "```python\ndef _parse_rules(css: str, read_from: CSSLocation | None = None, is_default_rules: bool = False, scope: str = \"\") -> List[RuleSets]:\n    \"\"\"Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n```"]}, "textual-src/textual/css/stylesheet.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nRaises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n        # Do this in a fresh Stylesheet so if there are errors we don't break self.\n        stylesheet = Stylesheet(variables=self._variables)\n        for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n            stylesheet.add_source(\n                css,\n                read_from=read_from,\n------------------------------\n------------------------------\nRaises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n        if read_from is None:\n            read_from = (\"\", str(hash(css)))\n------------------------------\n------------------------------\ndef has_source(self, path: str, class_var: str = \"\") -> bool:\n        \"\"\"Check if the stylesheet has this CSS source already.\n\n        Args:\n            path: The file path of the source in question.\n            class_var: The widget class variable we might be reading the CSS from.\n\n        Returns:\n            Whether the stylesheet is aware of this CSS source or not.\n        \"\"\"\n        return (path, class_var) in self.source\n------------------------------\n------------------------------\nclass StylesheetParseError(StylesheetError):\n    \"\"\"Raised when the stylesheet could not be parsed.\"\"\"\n\n    def __init__(self, errors: StylesheetErrors) -> None:\n        self.errors = errors\n\n    def __rich__(self) -> RenderableType:\n        return self.errors\n------------------------------\n------------------------------\nRaises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n        filename = os.path.expanduser(filename)\n        try:\n            with open(filename, \"rt\") as css_file:\n                css = css_file.read()\n            path = os.path.abspath(filename)\n        except Exception:\n            raise StylesheetError(f\"unable to read CSS file {filename!r}\") from None\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(self) -> None:\n# Natural Language Annotations: \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    errors = StylesheetErrors()\n    for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n        try:\n            stylesheet.add_source(\n                css,\n                read_from=read_from,\n                is_defaults=is_defaults,\n                tie_breaker=tie_breaker,\n                scope=scope,\n            )\n        except (StylesheetError, StylesheetParseError) as e:\n            errors.append(e)\n\n    if errors:\n        raise StylesheetParseError(errors)\n```", "```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    errors = StylesheetErrors()\n    for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n        try:\n            stylesheet = Stylesheet(variables=self._variables)\n            stylesheet.add_source(css, read_from=read_from)\n        except StylesheetError as e:\n            errors.append(e)\n    \n    if errors:\n        raise StylesheetParseError(errors)\n```", "```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    errors = StylesheetErrors()\n    for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n        try:\n            stylesheet.add_source(css, read_from=read_from, is_defaults=is_defaults, tie_breaker=tie_breaker, scope=scope)\n        except StylesheetError as e:\n            errors.add(read_from, str(e))\n        except StylesheetParseError as e:\n            errors.add(read_from, str(e))\n    if errors:\n        raise StylesheetParseError(errors)\n```"]}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n- parse_diffs: Parses a string containing diffs in the unified git diff format, extracting the changes described\n  in the diffs and organizing them into a dictionary of Diff objects, keyed by the filename to which each diff applies.\n\n- parse_diff_block: Parses a single block of text from a diff string, translating it into a Diff object that\n  represents the changes described in that block of text.\n------------------------------\n------------------------------\ndef parse_diff_block(diff_block: str) -> dict:\n    \"\"\"\n    Parses a block of diff text into a Diff object.\n\n    Args:\n    - diff_block (str): A single block of diff text.\n------------------------------\n------------------------------\ndef apply_diffs(diffs: Dict[str, Diff], files: FilesDict) -> FilesDict:\n    \"\"\"\n    Applies diffs to the provided files.\n\n    Args:\n    - diffs (Dict[str, Diff]): A dictionary of diffs to apply, keyed by filename.\n    - files (FilesDict): The original files to which diffs will be applied.\n------------------------------\n------------------------------\nReturns:\n    - dict: A dictionary containing a single Diff object keyed by the post-edit filename.\n    \"\"\"\n    lines = diff_block.strip().split(\"\\n\")[1:-1]  # Exclude the opening and closing ```\n    diffs = {}\n    current_diff = None\n    hunk_lines = []\n    filename_pre = None\n    filename_post = None\n    hunk_header = None\n------------------------------\n------------------------------\n\"\"\"\nThis Python script provides functionalities for parsing chat transcripts that contain file paths and code blocks,\napplying diffs to these files, and parsing unified git diff format strings. The script is designed to work within\na larger system that involves processing and manipulating code files based on chat inputs and diff information.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_diffs(diff_string: str) -> dict:\n# Natural Language Annotations: \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diff_blocks = diff_string.split(\"\\n```\\n\")\n    return {block.split(\"\\n\")[0]: parse_diff_block(block) for block in diff_blocks}\n```", "```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diff_blocks = diff_string.split('diff --git')[1:]\n    return {parse_diff_block(block)[0]: parse_diff_block(block)[1] for block in diff_blocks}\n```", "```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diff_blocks = diff_string.split(\"diff --git\")\n    diffs = {}\n    for block in diff_blocks:\n        if block.strip():\n            diffs.update(parse_diff_block(block.strip()))\n    return diffs\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nlogger.debug(f\"Using model {self.model_name}\")\n\n    def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n        \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n------------------------------\n------------------------------\nReturns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\n\n        messages: List[Message] = [\n            SystemMessage(content=system),\n            HumanMessage(content=user),\n        ]\n        return self.next(messages, step_name=step_name)\n------------------------------\n------------------------------\nParameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\n\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n------------------------------\n------------------------------\nMethods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n------------------------------\n------------------------------\nMethods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n# Natural Language Annotations: \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n\n    messages: List[Message] = [\n        SystemMessage(content=system),\n        HumanMessage(content=user),\n    ]\n    return self.next(messages, step_name=step_name)\n```", "```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n\n    messages: List[Message] = [\n        SystemMessage(content=system),\n        HumanMessage(content=user),\n    ]\n    return self.next(messages, step_name=step_name)\n```", "```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    logger.debug(f\"Using model {self.model_name}\")\n\n    messages: List[Message] = [\n        SystemMessage(content=system),\n        HumanMessage(content=user),\n    ]\n    return self.next(messages, step_name=step_name)\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ncollapsed_messages.append(previous_message.__class__(content=combined_content))\n        return collapsed_messages\n\n    def next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n------------------------------\n------------------------------\nParameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\n\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n------------------------------\n------------------------------\nMethods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n------------------------------\n------------------------------\nMethods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n------------------------------\n------------------------------\ndef next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        \"\"\"\n        Not yet fully supported\n        \"\"\"\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n\n        logger.debug(f\"Creating a new chat completion: {messages}\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def next(\n# Natural Language Annotations: \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef next(self, messages: List[Message], prompt: Optional[str] = None, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Advances the conversation by sending message history\n    to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n\n    if prompt:\n        messages.append(HumanMessage(content=prompt))\n\n    return messages\n```", "```python\ndef next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n\n        logger.debug(f\"Creating a new chat completion: {messages}\")\n```", "```python\ndef next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\n\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n\n        # Add your code here to send messages to the LLM and update the conversation\n\n        return messages\n```"]}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Code for: def read_config(config_file: Path) -> tomlkit.TOMLDocument:\n------------------------------\n------------------------------\n\"\"\"\nFunctions for reading and writing the `gpt-engineer.toml` configuration file.\n\nThe `gpt-engineer.toml` file is a TOML file that contains project-specific configuration used by the GPT Engineer CLI and gptengineer.app.\n\"\"\"\nfrom dataclasses import asdict, dataclass, field\nfrom pathlib import Path\n\nimport tomlkit\n\ndefault_config_filename = \"gpt-engineer.toml\"\n\nexample_config = \"\"\"\n[run]\nbuild = \"npm run build\"\ntest = \"npm run test\"\nlint = \"quick-lint-js\"\n------------------------------\n------------------------------\n@classmethod\n    def from_toml(cls, config_file: Path | str):\n        if isinstance(config_file, str):\n            config_file = Path(config_file)\n        config_dict = read_config(config_file)\n        return cls.from_dict(config_dict)\n------------------------------\n------------------------------\n# add comments on all lines that match = \"selected\"\n            s = \"\\n\".join(\n                [\n                    \"# \" + line if line.endswith(' = \"selected\"') else line\n                    for line in s.split(\"\\n\")\n                ]\n            )\n            # Write to the toml file\n            with open(toml_file, \"w\") as f:\n                f.write(self.COMMENT)\n                f.write(self.LINTING_STRING)\n                f.write(s)\n------------------------------\n------------------------------\ndef get_files_from_toml(\n        self, input_path: Union[str, Path], toml_file: Union[str, Path]\n    ) -> List[str]:\n        \"\"\"\n        Retrieves a list of selected files from a .toml configuration file.\n\n        Parameters\n        ----------\n        input_path : Union[str, Path]\n            The path where file selection was performed.\n        toml_file : Union[str, Path]\n            The path to the .toml file containing the file selection.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_toml(self, config_file: Path | str, save=True) -> str:\n# Natural Language Annotations: \"\"\"Write the configuration to a TOML file.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nimport tomlkit\n\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n    config_dict = self.asdict()\n    toml_config = tomlkit.dumps(config_dict)\n    if save:\n        with open(config_file, \"w\") as f:\n            f.write(toml_config)\n    return toml_config\n```", "```python\nimport tomlkit\nfrom pathlib import Path\n\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n    config_dict = asdict(self)\n    toml_dict = tomlkit.document()\n    toml_dict.update(config_dict)\n    if save:\n        with open(config_file, \"w\") as f:\n            tomlkit.dump(toml_dict, f)\n    return tomlkit.dumps(toml_dict)\n```", "```\nimport tomlkit\nfrom pathlib import Path\n\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n\n    # Convert the configuration to a TOML Document object\n    toml_document = tomlkit.document()\n    toml_document.update(self)\n\n    # Convert the Path object to a string if necessary\n    if isinstance(config_file, Path):\n        config_file = str(config_file)\n\n    # Write the TOML Document to a file\n    if save:\n        with open(config_file, \"w\") as toml_file:\n            tomlkit.dump(toml_document, toml_file)\n\n    # Return the TOML Document as a string\n    return tomlkit.dumps(toml_document)\n```"]}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef count_ratio(str1, str2) -> float:\n    \"\"\"\n    Computes the ratio of common characters to the length of the longer string, ignoring spaces and case.\n\n    Parameters:\n    - str1, str2 (str): The strings to compare.\n\n    Returns:\n    - float: The ratio of common characters to the length of the longer string.\n    \"\"\"\n    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n------------------------------\n------------------------------\ndef ask_yes_no(question: str) -> bool:\n    \"\"\"\n    Asks a yes/no question and returns the response as a boolean value.\n\n    Parameters\n    ----------\n    question : str\n        The yes/no question to ask.\n\n    Returns\n    -------\n    bool\n        True if the answer is 'yes', False if 'no'.\n\n    \"\"\"\n------------------------------\n------------------------------\n4. Utility functions `is_similar` and `count_ratio` offer the capability to compare strings for similarity, accounting for variations in spacing and case. This aids in the validation process by allowing a flexible comparison of code lines.\n\nDependencies:\n------------------------------\n------------------------------\n2. `Diff`: Class representing the entire set of changes in a file, containing multiple `Hunk` instances and methods for overall diff management.\n\n3. `is_similar(str1, str2, similarity_threshold)`: Function to compare two strings for similarity, useful in validating line changes in hunks.\n\n4. `count_ratio(str1, str2)`: Function that computes the ratio of common characters to the length of the longer string, aiding in the assessment of line similarity.\n------------------------------\n------------------------------\n\"\"\"\n\n    while True:\n        response = input(question + \" (y/n): \").lower().strip()\n        if response == \"y\":\n            return True\n        elif response == \"n\":\n            return False\n        else:\n            print(\"Please enter either 'y' or 'n'.\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n# Natural Language Annotations: \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    similarity_ratio = count_ratio(str1, str2)\n    return similarity_ratio >= similarity_threshold\n```", "```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n    return count_ratio(str1, str2) >= similarity_threshold\n```", "```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    return count_ratio(str1, str2) >= similarity_threshold\n```"]}}