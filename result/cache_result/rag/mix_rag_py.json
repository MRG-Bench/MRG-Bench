{"litestar-litestar/file_system.py-info": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            A dictionary of file info.\n        \"\"\"\n        file_info: FileInfo = {\n            \"created\": result.st_ctime,\n            \"gid\": result.st_gid,\n            \"ino\": result.st_ino,\n            \"islink\": await Path(path).is_symlink(),\n            \"mode\": result.st_mode,\n            \"mtime\": result.st_mtime,\n            \"name\": str(path),\n            \"nlink\": result.st_nlink,\n            \"size\": result.st_size,\n------------------------------\n------------------------------\nReturns:\n            A dictionary of file info.\n        \"\"\"\n        try:\n            awaitable = (\n                self.file_system.info(str(path))\n                if is_async_callable(self.file_system.info)\n                else sync_to_thread(self.file_system.info, str(path))\n            )\n            return cast(\"FileInfo\", await awaitable)\n        except FileNotFoundError as e:\n            raise e\n        except PermissionError as e:\n------------------------------\n------------------------------\nclass FileSystemProtocol(Protocol):\n    \"\"\"Base protocol used to interact with a file-system.\n\n    This protocol is commensurable with the file systems\n    exported by the `fsspec <https://filesystem-spec.readthedocs.io/en/latest/>` library.\n    \"\"\"\n\n    def info(self, path: PathType, **kwargs: Any) -> FileInfo | Awaitable[FileInfo]:\n        \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n------------------------------\n------------------------------\nReturns:\n        A dictionary of parsed path parameters.\n    \"\"\"\n    return {\n        param_definition.name: param_definition.parser(value) if param_definition.parser else value\n        for param_definition, value in zip(parameter_definitions, path_param_values)\n    }\n------------------------------\n------------------------------\ncookies: The response cookies.\n            encoded_headers: A list of encoded headers.\n            encoding: The response encoding.\n            etag: An etag.\n            file_info: A file info.\n            file_path: A path to a file.\n            file_system: A file system adapter.\n            filename: The name of the file.\n            headers: A dictionary of headers.\n            headers: The response headers.\n------------------------------\n------------------------------\nArgs:\n            file: Path to the target file.\n            mode: Mode, similar to the built ``open``.\n            buffering: Buffer size.\n        \"\"\"\n        ...\n------------------------------\n------------------------------\nclass FileInfo(TypedDict):\n    \"\"\"File information gathered from a file system.\"\"\"\n------------------------------\n------------------------------\nasync def info(self, path: PathType) -> FileInfo:\n        \"\"\"Proxies the call to the underlying FS Spec's ``info`` method, ensuring it's done in an async fashion and with\n        strong typing.\n\n        Args:\n            path: A file path to load the info for.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n# Natural Language Annotations: \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path), **kwargs)\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path), **kwargs)\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n        raise e\n```", "```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path), **kwargs)\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path), **kwargs)\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n        raise e\n```", "```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path), **kwargs)\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path), **kwargs)\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n```"]}, "litestar-litestar/typing.py-has_inner_subclass_of": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nWhere ``self.annotation`` is a union type, this method will return ``True`` when all members of the union are\n        a subtype of ``cl``, otherwise, ``False``.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n------------------------------\n------------------------------\n@property\n    def type_(self) -> Any:\n        \"\"\"The type of the annotation with all the wrappers removed, including the generic types.\"\"\"\n\n        return self.origin or self.annotation\n\n    def is_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n        \"\"\"Whether the annotation is a subclass of the given type.\n------------------------------\n------------------------------\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        True if the annotation is a subclass of :data:`Generic <typing.Generic>` otherwise ``False``.\n    \"\"\"\n    return is_class_and_subclass(annotation, Generic)  # type: ignore[arg-type]\n------------------------------\n------------------------------\nThis is to serve safely rebuilding a generic outer type with different args at runtime.\n    \"\"\"\n    inner_types: tuple[FieldDefinition, ...]\n    \"\"\"The type's generic args parsed as ``FieldDefinition``, if applicable.\"\"\"\n    default: Any\n    \"\"\"Default value of the field.\"\"\"\n    extra: dict[str, Any]\n    \"\"\"A mapping of extra values.\"\"\"\n    kwarg_definition: KwargDefinition | DependencyKwarg | None\n    \"\"\"Kwarg Parameter.\"\"\"\n    name: str\n    \"\"\"Field name.\"\"\"\n------------------------------\n------------------------------\ndef is_class_and_subclass(annotation: Any, type_or_type_tuple: type[T] | tuple[type[T], ...]) -> TypeGuard[type[T]]:\n    \"\"\"Return ``True`` if ``value`` is a ``class`` and is a subtype of ``t_type``.\n\n    See https://github.com/litestar-org/litestar/issues/367\n\n    Args:\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n------------------------------\n------------------------------\nArgs:\n            dto_factory: The DTO factory class calling this backend.\n            field_definition: Parsed type.\n            handler_id: The name of the handler that this backend is for.\n            is_data_field: Whether the field is a subclass of DTOData.\n            model_type: Model type.\n            wrapper_attribute_name: If the data that DTO should operate upon is wrapped in a generic datastructure, this is the name of the attribute that the data is stored in.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n            dto_factory: The DTO factory class calling this backend.\n            field_definition: Parsed type.\n            handler_id: The name of the handler that this backend is for.\n            is_data_field: Whether the field is a subclass of DTOData.\n            model_type: Model type.\n            wrapper_attribute_name: If the data that DTO should operate upon is wrapped in a generic datastructure,\n              this is the name of the attribute that the data is stored in.\n------------------------------\n------------------------------\ndef is_attrs_class(annotation: Any) -> TypeGuard[type[attrs.AttrsInstance]]:  # pyright: ignore\n    \"\"\"Given a type annotation determine if the annotation is a class that includes an attrs attribute.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is an attrs class.\n    \"\"\"\n    return attrs.has(annotation) if attrs is not Empty else False  # type: ignore[comparison-overlap]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n# Natural Language Annotations: \"\"\"Whether any generic args are a subclass of the given type.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether any of the type's generic args are a subclass of the given type.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    if isinstance(self.annotation, tuple):\n        return any(issubclass(a, cl) for a in self.annotation)\n    if isinstance(self.annotation, type):\n        return issubclass(self.annotation, cl)\n    return False\n```", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    if isinstance(self.type_, TypeVar):\n        return issubclass(self.type_.__bound__, cl)  # type: ignore\n    elif isinstance(self.type_, UnionType):\n        return any(issubclass(arg, cl) for arg in self.type_.__args__)  # type: ignore\n    return issubclass(self.type_, cl)  # type: ignore\n```", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\"\"\"\n    return any(issubclass(inner_type.annotation, cl) for inner_type in self.inner_types)\n```"]}, "litestar-litestar/typing.py-get_type_hints": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        annotation: A type annotation.\n        globalns: The global namespace.\n        localns: The local namespace.\n        include_extras: A flag indicating whether to include the ``Annotated[T, ...]`` or not.\n        type_hints: Already resolved type hints\n    \"\"\"\n    origin = get_origin(annotation)\n------------------------------\n------------------------------\ndef pydantic_get_unwrapped_annotation_and_type_hints(annotation: Any) -> tuple[Any, dict[str, Any]]:  # pragma:  pver\n    \"\"\"Get the unwrapped annotation and the type hints after resolving generics.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A tuple containing the unwrapped annotation and the type hints.\n    \"\"\"\n------------------------------\n------------------------------\ndef get_type_hints_with_generics_resolved(\n    annotation: Any,\n    globalns: dict[str, Any] | None = None,\n    localns: dict[str, Any] | None = None,\n    include_extras: bool = False,\n    type_hints: dict[str, Any] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Get the type hints for the given object after resolving the generic types as much as possible.\n------------------------------\n------------------------------\nArgs:\n            annotation: The type annotation. This should be extracted from the return of\n                ``get_type_hints(..., include_extras=True)`` so that forward references are resolved and recursive\n                ``Annotated`` types are flattened.\n            **kwargs: Additional keyword arguments to pass to the ``FieldDefinition`` constructor.\n\n        Returns:\n            FieldDefinition\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n            is_html_mode: Flag dictating whether serving html. If true, the default file will be ``index.html``.\n            directories: A list of directories to serve files from.\n            file_system: The file_system spec to use for serving files.\n            send_as_attachment: Whether to send the file with a ``content-disposition`` header of\n             ``attachment`` or ``inline``\n            resolve_symlinks: Resolve symlinks to the directories\n------------------------------\n------------------------------\ndef create_schema_for_annotation(annotation: Any) -> Schema:\n    \"\"\"Get a schema from the type mapping - if possible.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A schema instance or None.\n    \"\"\"\n\n    return copy(TYPE_MAP[annotation]) if annotation in TYPE_MAP else Schema()\n------------------------------\n------------------------------\ndef is_any(annotation: Any) -> TypeGuard[Any]:\n    \"\"\"Given a type annotation determine if the annotation is Any.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Any <typing.Any>`.\n    \"\"\"\n    return (\n        annotation is Any\n        or getattr(annotation, \"_name\", \"\") == \"typing.Any\"\n        or (get_origin_or_inner_type(annotation) in UnionTypes and Any in get_args(annotation))\n    )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the type hints for the annotation.\n\n        Args:\n            include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n            resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n        Returns:\n            The type hints.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    annotation = self.annotation\n    origin = get_origin(annotation)\n    type_hints = get_type_hints_with_generics_resolved(annotation)\n\n    if include_extras:\n        type_hints = self.get_type_hints_with_extras(annotation)\n\n    if resolve_generics:\n        type_hints = self.resolve_generics(type_hints)\n\n    return type_hints\n```", "```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n\n    # Your code here\n```", "```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    if resolve_generics:\n        annotation = get_origin(self.annotation)\n        return get_type_hints_with_generics_resolved(annotation, include_extras=include_extras)\n    else:\n        return get_type_hints(self.annotation, include_extras=include_extras)\n```"]}, "litestar-litestar/typing.py-from_kwarg": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nThis is to serve safely rebuilding a generic outer type with different args at runtime.\n    \"\"\"\n    inner_types: tuple[FieldDefinition, ...]\n    \"\"\"The type's generic args parsed as ``FieldDefinition``, if applicable.\"\"\"\n    default: Any\n    \"\"\"Default value of the field.\"\"\"\n    extra: dict[str, Any]\n    \"\"\"A mapping of extra values.\"\"\"\n    kwarg_definition: KwargDefinition | DependencyKwarg | None\n    \"\"\"Kwarg Parameter.\"\"\"\n    name: str\n    \"\"\"Field name.\"\"\"\n------------------------------\n------------------------------\nparam_definitions.add(\n                create_parameter_definition(\n                    field_definition=FieldDefinition.from_kwarg(\n                        name=field.name,\n                        default=default,\n                        inner_types=field.inner_types,\n                        annotation=field.annotation,\n                        kwarg_definition=field.kwarg_definition,\n                        extra=field.extra,\n                    ),\n------------------------------\n------------------------------\ndef create_parameter_definition(\n    field_definition: FieldDefinition,\n    field_name: str,\n    path_parameters: set[str],\n) -> ParameterDefinition:\n    \"\"\"Create a ParameterDefinition for the given FieldDefinition.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        field_name: The field's name.\n        path_parameters: A set of path parameter names.\n------------------------------\n------------------------------\nArgs:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n            field_definition: A :class:`FieldDefinition` to create a :class:`FieldDefinition` from.\n            model_name: The name of the model.\n            default_factory: Default factory function, if any.\n            dto_field: DTOField instance.\n------------------------------\n------------------------------\nfield_definition = FieldDefinition.from_kwarg(\n            inner_types=field.inner_types,\n            default=default,\n            extra=field.extra,\n            annotation=annotation,\n            kwarg_definition=field.kwarg_definition,\n            name=field_name,\n        )\n        return self.create_parameter(field_definition=field_definition, parameter_name=parameter_name)\n------------------------------\n------------------------------\nArgs:\n        const: A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter\n            must equal its default value. This also causes the OpenAPI const field to be\n            populated with the default value.\n        content_encoding: The content encoding of the value. Applicable on to string values.\n            See OpenAPI 3.1 for details.\n        default: A default value. If const is true, this value is required.\n------------------------------\n------------------------------\ndef for_new_type(self, field_definition: FieldDefinition) -> Schema | Reference:\n        return self.for_field_definition(\n            FieldDefinition.from_kwarg(\n                annotation=unwrap_new_type(field_definition.annotation),\n                name=field_definition.name,\n                default=field_definition.default,\n            )\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_kwarg(\n# Natural Language Annotations: \"\"\"Create a new FieldDefinition instance.\n\n        Args:\n            annotation: The type of the kwarg.\n            name: Field name.\n            default: A default value.\n            inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n            kwarg_definition: Kwarg Parameter.\n            extra: A mapping of extra values.\n\n        Returns:\n            FieldDefinition instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef from_kwarg(\n        annotation: Any,\n        name: str,\n        default: Any = None,\n        inner_types: Optional[Tuple[FieldDefinition, ...]] = None,\n        kwarg_definition: Optional[Union[KwargDefinition, DependencyKwarg]] = None,\n        extra: Optional[Dict[str, Any]] = None\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(\n        inner_types=inner_types or (),\n        default=default,\n        extra=extra or {},\n        kwarg_definition=kwarg_definition,\n        name=name,\n        annotation=annotation,\n    )\n```", "```python\ndef from_kwarg(\n        annotation: Any,\n        name: str,\n        default: Any = None,\n        inner_types: tuple[FieldDefinition, ...] = tuple(),\n        kwarg_definition: KwargDefinition | DependencyKwarg | None = None,\n        extra: dict[str, Any] = None,\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(\n        inner_types=inner_types,\n        default=default,\n        extra=extra or {},\n        kwarg_definition=kwarg_definition,\n        name=name,\n    )\n```", "```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any = None,\n    inner_types: tuple[FieldDefinition, ...] = (),\n    kwarg_definition: KwargDefinition | DependencyKwarg | None = None,\n    extra: dict[str, Any] = None,\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(\n        annotation=annotation,\n        default=default,\n        inner_types=inner_types,\n        kwarg_definition=kwarg_definition,\n        extra=extra,\n        name=name,\n    )\n```"]}, "litestar-litestar/typing.py-from_parameter": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n        parameters = tuple(\n            FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n            for name, parameter in signature.parameters.items()\n            if name not in (\"self\", \"cls\")\n        )\n------------------------------\n------------------------------\ndef get_fn_type_hints(fn: Any, namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Resolve type hints for ``fn``.\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n------------------------------\n------------------------------\nThis function makes the latter case consistent with the former by either removing the outer union if it is redundant\n    or flattening the union if it is not. The latter case would become `Annotated[Union[str, int, NoneType], ...]`.\n\n    Args:\n        defaults: Mapping of names to default values.\n        hints: Mapping of names to types.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n------------------------------\n------------------------------\nparameters = [\n            inspect.Parameter(name=field_name, kind=inspect.Parameter.KEYWORD_ONLY, annotation=Any)\n            for field_name in model_fields\n        ]\n        type_hints = {field_name: Any for field_name in model_fields}\n        return Signature(parameters), type_hints\n------------------------------\n------------------------------\ndef __init__(self, owner: Router) -> None:\n        \"\"\"Initialize a controller.\n\n        Should only be called by routers as part of controller registration.\n------------------------------\n------------------------------\nfn_type_hints={\n                **get_fn_type_hints(fn, namespace=self.resolve_signature_namespace()),\n                **get_fn_type_hints(ListenerHandler.__call__, namespace=self.resolve_signature_namespace()),\n            },\n        )\n------------------------------\n------------------------------\nShould be an instance of :class:`ExternalDocumentation <litestar.openapi.spec.external_documentation.ExternalDocumentation>`.\n    \"\"\"\n    license: License | None = field(default=None)\n    \"\"\"API Licensing information.\n\n    Should be an instance of :class:`License <litestar.openapi.spec.license.License>`.\n    \"\"\"\n    security: list[SecurityRequirement] | None = field(default=None)\n    \"\"\"API Security requirements information.\n------------------------------\n------------------------------\ndef get_typed_init(self, type_: Any) -> tuple[Signature, dict[str, Any]]:\n        parameters = []\n        type_hints = {}\n        for field_info in msgspec.structs.fields(type_):\n            type_hints[field_info.name] = field_info.type\n            parameters.append(\n                inspect.Parameter(\n                    name=field_info.name,\n                    kind=inspect.Parameter.KEYWORD_ONLY,\n                    annotation=field_info.type,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n# Natural Language Annotations: \"\"\"Initialize ParsedSignatureParameter.\n\n        Args:\n            parameter: inspect.Parameter\n            fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n                :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n        Returns:\n            ParsedSignatureParameter.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n    return cls(\n        name=parameter.name,\n        kind=parameter.kind,\n        default=parameter.default,\n        annotation=fn_type_hints.get(parameter.name, parameter.annotation),\n    )\n```", "```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\"\"\"\n    return FieldDefinition(parameter=parameter, fn_type_hints=fn_type_hints)\n```", "```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n    # Your code here\n```"]}, "litestar-litestar/_openapi/responses.py-create_success_response": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef create_redirect_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a redirect response.\"\"\"\n        return OpenAPIResponse(\n            content=None,\n            description=self.create_description(),\n            headers={\n                \"location\": OpenAPIHeader(\n                    schema=Schema(type=OpenAPIType.STRING), description=\"target path for the redirect\"\n                )\n            },\n        )\n------------------------------\n------------------------------\ndef set_success_response_headers(self, response: OpenAPIResponse) -> None:\n        \"\"\"Set the schema for success response headers, if any.\"\"\"\n\n        if response.headers is None:\n            response.headers = {}\n\n        if not self.schema_creator.generate_examples:\n            schema_creator = self.schema_creator\n        else:\n            schema_creator = SchemaCreator.from_openapi_context(self.context, generate_examples=False)\n------------------------------\n------------------------------\ndef create_description(self) -> str:\n        \"\"\"Create the description for a success response.\"\"\"\n        default_descriptions: dict[Any, str] = {\n            Stream: \"Stream Response\",\n            Redirect: \"Redirect Response\",\n            File: \"File Download\",\n        }\n        return (\n            self.route_handler.response_description\n            or default_descriptions.get(self.field_definition.annotation)\n            or HTTPStatus(self.route_handler.status_code).description\n------------------------------\n------------------------------\ndef create_file_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a file/stream response.\"\"\"\n        return OpenAPIResponse(\n            content={\n                self.route_handler.media_type: OpenAPIMediaType(\n                    schema=Schema(\n                        type=OpenAPIType.STRING,\n                        content_encoding=self.route_handler.content_encoding,\n------------------------------\n------------------------------\ndef create_responses(self, raises_validation_error: bool) -> Responses | None:\n        \"\"\"Create the schema for responses, if any.\n\n        Args:\n            raises_validation_error: Boolean flag indicating whether the handler raises a ValidationException.\n\n        Returns:\n            Responses\n        \"\"\"\n        responses: Responses = {\n            str(self.route_handler.status_code): self.create_success_response(),\n        }\n------------------------------\n------------------------------\nreturn schema\n\n    @staticmethod\n    def for_typevar() -> Schema:\n        \"\"\"Create a schema for a TypeVar.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n\n        return Schema(type=OpenAPIType.OBJECT)\n\n    def for_optional_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for an optional FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\nReturns:\n        Responses\n    \"\"\"\n    return ResponseFactory(context, route_handler).create_responses(raises_validation_error=raises_validation_error)\n------------------------------\n------------------------------\nschema.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_success_response(self) -> OpenAPIResponse:\n# Natural Language Annotations: \"\"\"Create the schema for a success response.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    return OpenAPIResponse(\n        content=self.content,\n        description=self.create_description(),\n    )\n```", "```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n\n    content: Optional[Dict[str, OpenAPIMediaType]] = None\n    if self.route_handler.media_type:\n        content = {\n            self.route_handler.media_type: OpenAPIMediaType(\n                schema=self.schema_creator.for_field_definition(self.field_definition),\n                example=self.schema_creator.get_example_for_field_definition(self.field_definition),\n            )\n        }\n\n    return OpenAPIResponse(\n        content=content,\n        description=self.create_description(),\n        headers={\n            \"location\": OpenAPIHeader(schema=Schema(type=OpenAPIType.STRING), description=\"target path for the redirect\")\n        },\n    )\n```", "```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    return OpenAPIResponse(\n        content=self.create_content(),\n        description=self.create_description(),\n        headers=self.create_headers(),\n    )\n```"]}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef create_error_responses(exceptions: list[type[HTTPException]]) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for error responses, if any.\"\"\"\n    grouped_exceptions: dict[int, list[type[HTTPException]]] = {}\n    for exc in exceptions:\n        if not grouped_exceptions.get(exc.status_code):\n            grouped_exceptions[exc.status_code] = []\n        grouped_exceptions[exc.status_code].append(exc)\n    for status_code, exception_group in grouped_exceptions.items():\n------------------------------\n------------------------------\nThese are schemas that can be referenced by other schemas in the document, including self references.\n\n        To support self referencing schemas, the schema is added to the registry before schemas for its properties\n        are created. This allows the schema to be referenced by its properties.\n------------------------------\n------------------------------\ndef create_responses(self, raises_validation_error: bool) -> Responses | None:\n        \"\"\"Create the schema for responses, if any.\n\n        Args:\n            raises_validation_error: Boolean flag indicating whether the handler raises a ValidationException.\n\n        Returns:\n            Responses\n        \"\"\"\n        responses: Responses = {\n            str(self.route_handler.status_code): self.create_success_response(),\n        }\n------------------------------\n------------------------------\nclass ResponseSpec:\n    \"\"\"Container type of additional responses.\"\"\"\n------------------------------\n------------------------------\ndef create_responses_for_handler(\n    context: OpenAPIContext, route_handler: HTTPRouteHandler, raises_validation_error: bool\n) -> Responses | None:\n    \"\"\"Create the schema for responses, if any.\n\n    Args:\n        context: An OpenAPIContext instance.\n        route_handler: An HTTPRouteHandler instance.\n        raises_validation_error: Boolean flag indicating whether the handler raises a ValidationException.\n------------------------------\n------------------------------\ndef create_template_context(self, request: Request) -> dict[str, Any]:\n        \"\"\"Create a context object for the template.\n\n        Args:\n            request: A :class:`Request <.connection.Request>` instance.\n------------------------------\n------------------------------\ndef set_success_response_headers(self, response: OpenAPIResponse) -> None:\n        \"\"\"Set the schema for success response headers, if any.\"\"\"\n\n        if response.headers is None:\n            response.headers = {}\n\n        if not self.schema_creator.generate_examples:\n            schema_creator = self.schema_creator\n        else:\n            schema_creator = SchemaCreator.from_openapi_context(self.context, generate_examples=False)\n------------------------------\n------------------------------\ndef create_schema_for_annotation(annotation: Any) -> Schema:\n    \"\"\"Get a schema from the type mapping - if possible.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A schema instance or None.\n    \"\"\"\n\n    return copy(TYPE_MAP[annotation]) if annotation in TYPE_MAP else Schema()\n------------------------------\n------------------------------\nreturn schema\n\n    @staticmethod\n    def for_typevar() -> Schema:\n        \"\"\"Create a schema for a TypeVar.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n\n        return Schema(type=OpenAPIType.OBJECT)\n\n    def for_optional_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for an optional FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\ndef create_redirect_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a redirect response.\"\"\"\n        return OpenAPIResponse(\n            content=None,\n            description=self.create_description(),\n            headers={\n                \"location\": OpenAPIHeader(\n                    schema=Schema(type=OpenAPIType.STRING), description=\"target path for the redirect\"\n                )\n            },\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n# Natural Language Annotations: \"\"\"Create the schema for additional responses, if any.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses = self.context.get_additional_responses(self.route_handler)\n    for status_code, response in additional_responses.items():\n        yield str(status_code), response\n```", "```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses = {}\n    for status_code, exception_group in self.grouped_exceptions.items():\n        if status_code in self.responses:\n            continue\n        additional_responses[status_code] = self.create_error_response(exception_group)\n    return additional_responses.items()\n```", "```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    if not hasattr(self, \"additional_responses\"):\n        return iter(())\n    for status_code, response in self.additional_responses.items():\n        yield status_code, response\n```"]}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef create_path_item_for_route(openapi_context: OpenAPIContext, route: HTTPRoute) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Args:\n        openapi_context: The OpenAPIContext instance.\n        route: The route to create a PathItem for.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item_factory = PathItemFactory(openapi_context, route)\n    return path_item_factory.create_path_item()\n------------------------------\n------------------------------\ndef create_operation_for_handler_method(\n        self, route_handler: HTTPRouteHandler, http_method: HttpMethod\n    ) -> Operation:\n        \"\"\"Create an Operation instance for a given route handler and http method.\n\n        Args:\n            route_handler: A route handler instance.\n            http_method: An HttpMethod enum value.\n------------------------------\n------------------------------\nclass PathItemFactory:\n    \"\"\"Factory for creating a PathItem instance for a given route.\"\"\"\n\n    def __init__(self, openapi_context: OpenAPIContext, route: HTTPRoute) -> None:\n        self.context = openapi_context\n        self.route = route\n        self._path_item = PathItem()\n------------------------------\n------------------------------\ndef default_operation_id_creator(\n    route_handler: HTTPRouteHandler,\n    http_method: Method,\n    path_components: list[str | PathParameterDefinition],\n) -> str:\n    \"\"\"Create a unique 'operationId' for an OpenAPI PathItem entry.\n\n    Args:\n        route_handler: The HTTP Route Handler instance.\n        http_method: The HTTP method for the given PathItem.\n        path_components: A list of path components.\n------------------------------\n------------------------------\n# Code for: def merge_path_item_operations(source: PathItem, other: PathItem, for_path: str) -> PathItem:\n------------------------------\n------------------------------\ndef create_node() -> RouteTrieNode:\n    \"\"\"Create a RouteMapNode instance.\n\n    Returns:\n        A route map node instance.\n    \"\"\"\n\n    return RouteTrieNode(\n        asgi_handlers={},\n        child_keys=set(),\n        children={},\n        is_path_param_node=False,\n        is_asgi=False,\n        is_mount=False,\n        is_static=False,\n        is_path_type=False,\n        path_parameters={},\n    )\n------------------------------\n------------------------------\nReturns:\n            An Operation instance.\n        \"\"\"\n        operation_id = self.create_operation_id(route_handler, http_method)\n        parameters = create_parameters_for_handler(self.context, route_handler, self.route.path_parameters)\n        signature_fields = route_handler.parsed_fn_signature.parameters\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_path_item(self) -> PathItem:\n# Natural Language Annotations: \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n        Returns:\n            A PathItem instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem()\n    for http_method in HTTPMethod:\n        operation = self.create_operation_for_handler_method(self.route.route_handlers[http_method], http_method)\n        path_item.operations[operation.method] = operation\n    return path_item\n```", "```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem()\n    for http_method, route_handler in self.route.methods.items():\n        operation = self.create_operation_for_handler_method(route_handler, http_method)\n        setattr(path_item, http_method.lower(), operation)\n    return path_item\n```", "```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item_factory = PathItemFactory(self.openapi_context, self.route)\n    return path_item_factory.create_path_item()\n```"]}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn Schema(one_of=[Schema(type=OpenAPIType.NULL), *result])\n\n    def for_union_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for a union FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\ndef for_collection_constrained_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create Schema from Constrained List/Set field.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\ndef for_plugin(self, field_definition: FieldDefinition, plugin: OpenAPISchemaPluginProtocol) -> Schema | Reference:\n        \"\"\"Create a schema using a plugin.\n\n        Args:\n            field_definition: A signature field instance.\n            plugin: A plugin for the field type.\n------------------------------\n------------------------------\nreturn schema\n\n    @staticmethod\n    def for_typevar() -> Schema:\n        \"\"\"Create a schema for a TypeVar.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n\n        return Schema(type=OpenAPIType.OBJECT)\n\n    def for_optional_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for an optional FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\ndef for_constrained_field(self, field: FieldDefinition) -> Schema:\n        \"\"\"Create Schema for Pydantic Constrained fields (created using constr(), conint() and so forth, or by subclassing\n        Constrained*)\n\n        Args:\n            field: A signature field instance.\n------------------------------\n------------------------------\nArgs:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        if field_definition.has_inner_subclass_of(UploadFile):\n            return self.for_upload_file(field_definition)\n------------------------------\n------------------------------\nArgs:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n# Natural Language Annotations: \"\"\"Create a Schema for a given FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if field_definition.is_optional():\n        return self.for_optional_field(field_definition)\n    elif field_definition.is_constrained():\n        return self.for_constrained_field(field_definition)\n    elif field_definition.is_union():\n        return self.for_union_field(field_definition)\n    elif field_definition.is_collection_constrained():\n        return self.for_collection_constrained_field(field_definition)\n    elif field_definition.is_typevar():\n        return self.for_typevar()\n    elif field_definition.has_inner_subclass_of(UploadFile):\n        return self.for_upload_file(field_definition)\n```", "```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if field_definition.has_inner_subclass_of(UploadFile):\n        return self.for_upload_file(field_definition)\n    elif field_definition.is_optional():\n        return self.for_optional_field(field_definition)\n    elif field_definition.is_union():\n        result = [self.for_schema(subfield) for subfield in field_definition.subfields]\n        return Schema(one_of=[Schema(type=OpenAPIType.NULL), *result])\n    elif field_definition.is_typevar():\n        return self.for_typevar()\n    elif field_definition.is_constrained():\n        return self.for_constrained_field(field_definition)\n    elif field_definition.is_collection():\n        return self.for_collection_constrained_field(field_definition)\n    elif field_definition.has_plugin():\n        return self.for_plugin(field_definition, field_definition.plugin)\n```", "```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if field_definition.is_optional():\n        return self.for_optional_field(field_definition)\n\n    if field_definition.is_collection():\n        return self.for_collection_constrained_field(field_definition)\n\n    if field_definition.has_inner_subclass_of(UploadFile):\n        return self.for_upload_file(field_definition)\n\n    if field_definition.is_constrained():\n        return self.for_constrained_field(field_definition)\n\n    if field_definition.is_type_var():\n        return self.for_typevar()\n\n    if field_definition.is_union():\n        return self.for_union_field(field_definition)\n\n    # default case\n    return self.for_type(field_definition.type)\n```"]}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef parse_schema(schema: Schema) -> TypeScriptElement:\n    \"\"\"Parse an OpenAPI schema object recursively to create typescript types.\n\n    Args:\n        schema: An OpenAPI Schema object.\n------------------------------\n------------------------------\ndef parse_request_body(body: RequestBody, components: Components) -> TypeScriptType:\n    \"\"\"Parse the schema request body.\n\n    Args:\n        body: An OpenAPI RequestBody instance.\n        components: The OpenAPI schema Components section.\n\n    Returns:\n        A TypeScript type.\n    \"\"\"\n    undefined = TypeScriptPrimitive(\"undefined\")\n    if not body.content:\n        return TypeScriptType(\"RequestBody\", undefined)\n------------------------------\n------------------------------\ndef parse_type_schema(schema: Schema) -> TypeScriptPrimitive | TypeScriptLiteral | TypeScriptUnion:\n    \"\"\"Parse an OpenAPI schema representing a primitive type(s).\n\n    Args:\n        schema: An OpenAPI schema.\n------------------------------\n------------------------------\nclass JWTAuth(Generic[UserType], BaseJWTAuth[UserType]):\n    \"\"\"JWT Authentication Configuration.\n\n    This class is the main entry point to the library, and it includes methods to create the middleware, provide login\n    functionality, and create OpenAPI documentation.\n    \"\"\"\n\n    token_secret: str\n    \"\"\"Key with which to generate the token hash.\n------------------------------\n------------------------------\nReturns:\n        A typescript type.\n    \"\"\"\n    if schema.all_of:\n        return TypeScriptIntersection(tuple(parse_schema(s) for s in schema.all_of if is_schema_value(s)))\n    if schema.one_of:\n        return TypeScriptUnion(tuple(parse_schema(s) for s in schema.one_of if is_schema_value(s)))\n    if is_schema_value(schema.items):\n        return TypeScriptArray(parse_schema(schema.items))\n    if schema.type == OpenAPIType.OBJECT:\n        return create_interface(\n------------------------------\n------------------------------\nclass OAuth2PasswordBearerAuth(Generic[UserType], BaseJWTAuth[UserType]):\n    \"\"\"OAUTH2 Schema for Password Bearer Authentication.\n\n    This class implements an OAUTH2 authentication flow entry point to the library, and it includes all the\n    functionality of the :class:`JWTAuth` class and adds support for passing JWT tokens ``HttpOnly`` cookies.\n\n    ``token_url`` is the only additional argument that is required, and it should point at your login route\n    \"\"\"\n------------------------------\n------------------------------\nReturns:\n        A tuple of namespaces, mapping response codes to data.\n    \"\"\"\n    result: list[TypeScriptNamespace] = []\n    for http_status, response in [\n        (status, get_openapi_type(res, components=components)) for status, res in responses.items()\n    ]:\n        if response.content and (\n            content := [get_openapi_type(v.schema, components) for v in response.content.values() if v.schema]\n        ):\n            ts_type = parse_schema(content[0])\n        else:\n------------------------------\n------------------------------\ndef render(self, request: Request, openapi_schema: dict[str, Any]) -> bytes:\n        \"\"\"Render an HTML page for Redoc.\n\n        .. note:: override this method to customize the template.\n\n        Args:\n            request: The request.\n            openapi_schema: The OpenAPI schema as a dictionary.\n\n        Returns:\n            A rendered html string.\n        \"\"\"\n------------------------------\n------------------------------\ndef to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        if field_definition.origin is ClassicPagination:\n            return Schema(\n                type=OpenAPIType.OBJECT,\n                properties={\n                    \"items\": Schema(\n                        type=OpenAPIType.ARRAY,\n                        items=schema_creator.for_field_definition(field_definition.inner_types[0]),\n                    ),\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n# Natural Language Annotations: \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    result = TypeScriptNamespace(namespace)\n\n    for path, path_item in openapi_schema.paths.items():\n        for operation in path_item.operations:\n            for parameter in operation.parameters:\n                if parameter.schema:\n                    result.add_type(parse_schema(parameter.schema))\n\n            if operation.request_body and operation.request_body.schema:\n                result.add_type(parse_request_body(operation.request_body, openapi_schema.components))\n\n            for response in operation.responses.values():\n                if response.content:\n                    for content in response.content.values():\n                        if content.schema:\n                            result.add_type(parse_schema(content.schema))\n\n    return result\n```", "```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\n    ts_namespace = TypeScriptNamespace(namespace)\n\n    for path, path_item in openapi_schema.paths.items():\n        for operation in [path_item.get, path_item.post, path_item.put, path_item.delete]:\n            if operation is not None:\n                for parameter in operation.parameters:\n                    ts_namespace.add_type(parse_schema(parameter.schema))\n                if operation.request_body is not None:\n                    ts_namespace.add_type(parse_request_body(operation.request_body, openapi_schema.components))\n\n    for component_name, component in openapi_schema.components.items():\n        if isinstance(component, Schema):\n            ts_namespace.add_type(parse_schema(component))\n\n    return ts_namespace\n```", "```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    result = TypeScriptNamespace(namespace)\n    for path, path_item in openapi_schema.paths.items():\n        for method, operation in path_item.operations.items():\n            if operation.request_body:\n                request_body_type = parse_request_body(operation.request_body, openapi_schema.components)\n                result.add_type(request_body_type)\n            for param in operation.parameters:\n                param_type = parse_schema(param.schema)\n                result.add_type(param_type)\n            for status, response in operation.responses.items():\n                if response.content:\n                    content_type = parse_schema(response.content)\n                    result.add_type(content_type)\n    return result\n```"]}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass TypeScriptInterface(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript interface.\"\"\"\n\n    name: str\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface.\n\n        Example:\n            export interface MyInterface {\n                key: string;\n                optional?: number;\n            };\n------------------------------\n------------------------------\nclass TypeScriptProperty(TypeScriptElement):\n    \"\"\"A class representing a TypeScript interface property.\"\"\"\n\n    required: bool\n    key: str\n    value: TypeScriptElement\n\n    def write(self) -> str:\n        \"\"\"Write a typescript property. This class is used exclusively inside interfaces.\n\n        Example:\n            key: string;\n            optional?: number;\n------------------------------\n------------------------------\nReturns:\n        A typescript interface or anonymous interface.\n    \"\"\"\n    parsed_properties = tuple(\n        TypeScriptProperty(\n            key=normalize_typescript_namespace(key, allow_quoted=True),\n            value=parse_schema(schema),\n            required=key in required if required is not None else True,\n        )\n        for key, schema in properties.items()\n    )\n    return (\n        TypeScriptInterface(name=name, properties=parsed_properties)\n        if name is not None\n------------------------------\n------------------------------\nclass TypeScriptConst(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript const.\"\"\"\n\n    name: str\n    value: TypeScriptPrimitive | TypeScriptLiteral\n\n    def write(self) -> str:\n        \"\"\"Write a typescript const.\n\n        Example:\n            export const MyConst: number;\n\n        Returns:\n            A typescript string\n        \"\"\"\n        return f\"export const {self.name}: {self.value.write()};\"\n------------------------------\n------------------------------\ndef create_interface(\n    properties: dict[str, Schema], required: set[str] | None = None, name: str | None = None\n) -> TypeScriptAnonymousInterface | TypeScriptInterface:\n    \"\"\"Create a typescript interface from the given schema.properties values.\n\n    Args:\n        properties: schema.properties mapping.\n        required: An optional list of required properties.\n        name: An optional string representing the interface name.\n------------------------------\n------------------------------\nclass TypeScriptNamespace(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript namespace.\"\"\"\n\n    name: str\n    values: tuple[TypeScriptContainer, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript namespace.\n\n        Example:\n            export MyNamespace {\n                export const MyConst: number;\n            }\n------------------------------\n------------------------------\nclass TypeScriptUnion(TypeScriptElement):\n    \"\"\"A class representing a TypeScript union type.\"\"\"\n\n    types: tuple[TypeScriptElement, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript union value.\n\n        Example:\n            string | number\n\n        Returns:\n            A typescript string\n        \"\"\"\n        return \" | \".join(sorted(t.write() for t in self.types))\n------------------------------\n------------------------------\nReturns:\n            A typescript string\n        \"\"\"\n        interface = TypeScriptAnonymousInterface(properties=self.properties)\n        return f\"export interface {self.name} {interface.write()};\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def write(self) -> str:\n# Natural Language Annotations: \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef write(self) -> str:\n    \"\"\"Write a typescript interface object, without a name.\n\n    Example:\n        {\n            key: string;\n            optional?: number;\n        }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    properties_str = \"\".join(prop.write() for prop in self.properties)\n    return f\"{{{properties_str}}}\"\n```", "```python\nclass TypeScriptAnonymousInterface(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript interface with no name.\"\"\"\n\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\n        return \"{\\n\" + \"\\n\".join(p.write() for p in self.properties) + \"\\n}\"\n```", "```python\nclass TypeScriptAnonymousInterface(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript anonymous interface.\"\"\"\n\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\n        properties_str = \"\".join(prop.write() for prop in self.properties)\n        return f\"{{{properties_str}}};\"\n```"]}, "litestar-litestar/testing/helpers.py-create_test_client": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\noutbound response data.\n            route_handlers: A sequence of route handlers, which can include instances of\n                :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n                callable decorated by the route handler decorators.\n            security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n                See\n------------------------------\n------------------------------\n:class:`AsyncTestClient <litestar.testing.AsyncTestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_async_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n------------------------------\n------------------------------\nsecurity: A sequence of dicts that will be added to the schema of all route handlers in the application.\n                See :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>`\n                for details.\n            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n            signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n------------------------------\n------------------------------\n@get(\"/\")\n                def my_handler(request: Request) -> None: ...\n\n\n                app = Litestar(route_handlers=[my_handler], middleware=[session_auth_config.middleware])\n\n\n        Returns:\n            An instance of DefineMiddleware including ``self`` as the config kwarg value.\n        \"\"\"\n        return DefineMiddleware(MiddlewareWrapper, config=self)\n\n    @property\n    def session_backend(self) -> BaseSessionBackendT:\n        \"\"\"Create a session backend.\n------------------------------\n------------------------------\ntags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n------------------------------\n------------------------------\nan instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n------------------------------\n------------------------------\nroute handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n------------------------------\n------------------------------\ndef create_response_handler(\n    after_request: AfterRequestHookHandler | None,\n    background: BackgroundTask | BackgroundTasks | None,\n    cookies: frozenset[Cookie],\n    headers: frozenset[ResponseHeader],\n    media_type: str,\n    status_code: int,\n    type_encoders: TypeEncodersMap | None,\n) -> AsyncAnyCallable:\n    \"\"\"Create a handler function for Litestar Responses.\n------------------------------\n------------------------------\n:class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n------------------------------\n------------------------------\n# We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor.\n# The hook handler will inject the JWT middleware and openapi configuration into the app.\napp = Litestar(\n    route_handlers=[login_handler, some_route_handler],\n    on_app_init=[jwt_auth.on_app_init],\n    openapi_config=openapi_config,\n)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_test_client(\n# Natural Language Annotations: \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        route_handlers: A sequence of route handlers, which can include instances of\n            :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_test_client(\n    route_handlers: Sequence[AnyRouteHandler] | AnyRouteHandler,\n    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n    backend_options: Mapping[str, Any] | None = None,\n    base_url: str | None = None,\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AfterResponseHookHandler | None = None,\n    allowed_hosts: AllowedHostsConfig | Sequence[str] | None = None,\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: Dependencies | None = None,\n    dto: AbstractDTO | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: type[BaseEventEmitterBackend] = DefaultEventEmitterBackend,\n    exception_handlers: ExceptionHandlers | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[Callable[[], AsyncContextManager[None]]] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: type[BaseLoggingConfig] = DefaultLoggingConfig,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = 1000,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHookHandler] | None = None,\n    on_startup: Sequence[LifespanHookHandler] | None = None,\n    openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,\n    opt: dict[str, Any] | None = None,\n    parameters: Parameters | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[PluginProtocol] | None = None,\n    request_class: type[Request] = Request,\n    response_class: type[Response] = Response,\n    response_cookies: Sequence[Cookie] | None = None,\n    response_headers: ResponseHeaders | None = None,\n    response_cache_config: ResponseCacheConfig | None = None,\n    return_dto: AbstractDTO | None = None,\n    security: Sequence[SecurityRequirement] | None = None,\n    signature_namespace: Mapping[str, Type[Any]] | None = None,\n    signature_types: Sequence[Type[Any]] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: Mapping[str, Store] | type[StoreRegistry] | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: float | None = None,\n    type_encoders: TypeEncodersMap | None = None,\n    websocket_class: type[WebSocket] | None = None,\n    experimental_features: Iterable[str] | None = None,\n) -> TestClient:\n    \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\n```", "```python\ndef create_test_client(\n    route_handlers: Any,\n    backend: str = \"asyncio\",\n    backend_options: dict[str, Any] | None = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler | AfterExceptionHookHandlerT] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AfterResponseHookHandler | None = None,\n    allowed_hosts: AllowedHostsConfig | Sequence[str] | None = None,\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: MutableMapping[str, Provide] | None = None,\n    dto: AbstractDTO | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: type[BaseEventEmitterBackend] | None = None,\n    exception_handlers: Mapping[int | Type[Exception], ExceptionHandler] | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[LifespanHook] | None = None,\n    listeners: Sequence[EventListener] = (),\n    logging_config: BaseLoggingConfig | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = 16384,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig | None = None,\n    opt: MutableMapping[str, Any] | None = None,\n    parameters: Mapping[str, ParameterDefinition] | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[PluginProtocol] | None = None,\n    request_class: type[Request] | None = None,\n    response_class: type[Response] | None = None,\n    response_cookies: Sequence[Cookie] | None = None,\n    response_headers: Mapping[str, ResponseHeader] | None = None,\n    response_cache_config: CacheConfig | None = None,\n    return_dto: AbstractDTO | None = None,\n    security: Sequence[dict[str, Any]] | None = None,\n    signature_namespace: Mapping[str, Any] | None = None,\n    signature_types: Sequence[Any] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: MutableMapping[str, Store] | StoreRegistry | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: float | None = None,\n    type_encoders: TypeEncodersMap | None = None,\n    websocket_class: type[WebSocket] | None = None,\n    experimental_features: set[Type[ExperimentalFeature]] | None = None,\n) -> TestClient:\n    app = Litestar(\n        route_handlers=route_handhandslers,\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_send,\n        cache_control=cache_control,\n        compression_config=compression_config,\n        cors_config=cors_config,\n        csrf_config=csrf_config,\n        debug=debug,\n        dependencies=dependencies,\n        dto=dto,\n        etag=etag,\n        event_emitter_backend=event_emitter_backend,\n        exception_handlers=exception_handlers,\n        guards=guards,\n        include_in_schema=include_in_schema,\n        lifespan=lifespan,\n        listeners=listeners,\n        logging_config=logging_config,\n        middleware=middleware,\n        multipart_form_part_limit=multipart_form_part_limit,\n        on_app_init=on_app_init,\n        on_shutdown=on_shutdown,\n        on_startup=on_startup,\n        openapi_config=openapi_config,\n        opt=opt,\n        parameters=parameters,\n        path=path,\n        pdb_on_exception=pdb_on_exception,\n        plugins=plugins,\n        request_class=request_class,\n        response_class=response_class,\n        response_cookies=response_cookies,\n        response_headers=response_headers,\n        response_cache_config=response_cache_config,\n        return_dto=return_dto,\n        security=security,\n        signature_namespace=signature_namespace,\n        signature_types=signature_types,\n        state=state,\n        static_files_config=static_files_config,\n        stores=stores,\n        tags=tags,\n        template_config=template_config,\n        timeout=timeout,\n        type_encoders=type_encoders,\n        websocket_class=websocket_class,\n        experimental_features=experimental_features,\n    )\n    return TestClient(app)\n```", "```python\ndef create_test_client(\n    route_handlers: Sequence[RouteHandlerType],\n    backend: Any = None,\n    backend_options: dict[str, Any] | None = None,\n    base_url: str | None = None,\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: SessionConfig | None = None,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AfterResponseHookHandler | None = None,\n    allowed_hosts: AllowedHostsConfig | Sequence[str] | None = None,\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = False,\n    dependencies: DependencyRegistry | None = None,\n    dto: AbstractDTO | None = None,\n    etag: ETag | None = None,\n    event_emitter_backend: Type[BaseEventEmitterBackend] = DefaultEventEmitterBackend,\n    exception_handlers: ExceptionHandlers | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool = True,\n    lifespan: Sequence[LifespanHook] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: BaseLoggingConfig | None = None,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = DEFAULT_MULTIPART_FORM_PART_LIMIT,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,\n    opt: dict[str, Any] | None = None,\n    parameters: dict[str, ParameterDefinition] | None = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Sequence[PluginProtocol] | None = None,\n    request_class: Type[Request[Any, Any, Any, Any]] = Request,\n    response_class: Type[Response[Any]] = Response,\n    response_cookies: Sequence[Cookie] | None = None,\n    response_headers: MutableMapping[str, ResponseHeader] | None = None,\n    response_cache_config: ResponseCacheConfig | None = None,\n    return_dto: AbstractDTO | None = None,\n    security: Sequence[SecurityRequirement] | None = None,\n    signature_namespace: dict[str, Any] | None = None,\n    signature_types: Sequence[Any] | None = None,\n    state: State | None = None,\n    static_files_config: Sequence[StaticFilesConfig] | None = None,\n    stores: Store | dict[str, Store] | None = None,\n    tags: Sequence[str] | None = None,\n    template_config: TemplateConfig | None = None,\n    timeout: float | None = None,\n    type_encoders: TypeEncodersMap | None = None,\n    websocket_class: Type[WebSocket] | None = None,\n    experimental_features: Sequence[ExperimentalFeature] | None = None,\n) -> TestClient:\n    app = Litestar(\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n        root_path=root_path,\n        session_config=session_config,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_send,\n        cache_control=cache_control,\n        compression_config=compression_config,\n        cors_config=cors_config,\n        csrf_config=csrf_config,\n        debug=debug,\n        dependencies=dependencies,\n        dto=dto,\n        etag=etag,\n        event_emitter_backend=event_emitter_backend,\n        exception_handlers=exception_handlers,\n        guards=guards,\n        include_in_schema=include_in_schema,\n        lifespan=lifespan,\n        listeners=listeners,\n        logging_config=logging_config,\n        middleware=middleware,\n        multipart_form_part_limit=multipart_form_part_limit,\n        on_app_init=on_app_init,\n        on_shutdown=on_shutdown,\n        on_startup=on_startup,\n        openapi_config=openapi_config,\n        opt=opt,\n        parameters=parameters,\n        path=path,\n        pdb_on_exception=pdb_on_exception,\n        plugins=plugins,\n        request_class=request_class,\n        response_class=response_class,\n        response_cookies=response_cookies,\n        response_headers=response_headers,\n        response_cache_config=response_cache_config,\n        return_dto=return_dto,\n        route_handlers=route_handlers,\n        security=security,\n        signature_namespace=signature_namespace,\n        signature_types=signature_types,\n        state=state,\n        static_files_config=static_files_config,\n        stores=stores,\n        tags=tags,\n        template_config=template_config,\n        timeout=timeout,\n        type_encoders=type_encoders,\n        websocket_class=websocket_class,\n        experimental_features=experimental_features,\n    )\n    return TestClient(app)\n```"]}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n------------------------------\n------------------------------\nasync def websocket_connect(\n        self,\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n------------------------------\n------------------------------\nextensions: Mapping[str, Any] | None = None,\n    ) -> WebSocketTestSession:\n        \"\"\"Sends a GET request to establish a websocket connection.\n------------------------------\n------------------------------\nReturns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\n        try:\n            await self.send(\n                self._prepare_ws_connect_request(\n                    url=url,\n                    subprotocols=subprotocols,\n                    params=params,\n                    headers=headers,\n                    cookies=cookies,\n                    extensions=extensions,\n                    timeout=timeout,\n                ),\n------------------------------\n------------------------------\ncookies: The response cookies.\n            encoded_headers: A list of encoded headers.\n            encoding: The response encoding.\n            etag: An etag.\n            file_info: A file info.\n            file_path: A path to a file.\n            file_system: A file system adapter.\n            filename: The name of the file.\n            headers: A dictionary of headers.\n            headers: The response headers.\n------------------------------\n------------------------------\nclass WebSocket(Generic[UserT, AuthT, StateT], ASGIConnection[\"WebsocketRouteHandler\", UserT, AuthT, StateT]):\n    \"\"\"The Litestar WebSocket class.\"\"\"\n\n    __slots__ = (\"connection_state\",)\n\n    scope: WebSocketScope  # pyright: ignore\n    \"\"\"The ASGI scope attached to the connection.\"\"\"\n    receive: Receive\n    \"\"\"The ASGI receive function.\"\"\"\n    send: Send\n    \"\"\"The ASGI send function.\"\"\"\n------------------------------\n------------------------------\nbackend_options: ``anyio`` options.\n            session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n                route handlers.\n            timeout: Request timeout\n            cookies: Cookies to set on the client.\n        \"\"\"\n        BaseTestClient.__init__(\n            self,\n            app=app,\n            base_url=base_url,\n            backend=backend,\n            backend_options=backend_options,\n------------------------------\n------------------------------\nArgs:\n            app: The instance of :class:`Litestar <litestar.app.Litestar>` under test.\n            base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n            raise_server_exceptions: Flag for the underlying test client to raise server exceptions instead of\n                wrapping them in an HTTP response.\n            root_path: Path prefix for requests.\n            backend: The async backend to use, options are \"asyncio\" or \"trio\".\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def websocket_connect(\n# Natural Language Annotations: \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def websocket_connect(\n        self,\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: Mapping[str, Any] | None = None,\n    ) -> WebSocketTestSession:\n        try:\n            await self.send(\n                self._prepare_ws_connect_request(\n                    url=url,\n                    subprotocols=subprotocols,\n                    params=params,\n                    headers=headers,\n                    cookies=cookies,\n                    extensions=extensions,\n                    timeout=timeout,\n                )\n            )\n```", "```python\nasync def websocket_connect(\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: Mapping[str, Any] | None = None,\n    ) -> WebSocketTestSession:\n\n    try:\n        await self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            )\n        )\n    except Exception as exc:\n        raise exc\n```", "```python\ndef websocket_connect(\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: Mapping[str, Any] | None = None,\n) -> WebSocketTestSession:\n    \"\"\"Sends a GET request to establish a websocket connection.\n\n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n\n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    try:\n        await self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            ),\n        return WebSocketTestSession()\n```"]}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n------------------------------\n------------------------------\n@staticmethod\n    def is_constrained_field(field_definition: FieldDefinition) -> bool:\n        return is_pydantic_constrained_field(field_definition.annotation)\n\n    def to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        \"\"\"Given a type annotation, transform it into an OpenAPI schema class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n------------------------------\n------------------------------\nArgs:\n            field_definition: An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n            schema_creator: An instance of the openapi SchemaCreator.\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n        raise NotImplementedError()\n------------------------------\n------------------------------\nreturn schema\n\n    @staticmethod\n    def for_typevar() -> Schema:\n        \"\"\"Create a schema for a TypeVar.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n\n        return Schema(type=OpenAPIType.OBJECT)\n\n    def for_optional_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for an optional FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n------------------------------\n------------------------------\n@staticmethod\n    def for_upload_file(field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create schema for UploadFile.\n\n        Args:\n            field_definition: A field definition instance.\n\n        Returns:\n            A Schema instance.\n        \"\"\"\n\n        property_key = \"file\"\n        schema = Schema(\n            type=OpenAPIType.STRING,\n            content_media_type=\"application/octet-stream\",\n            format=OpenAPIFormat.BINARY,\n        )\n------------------------------\n------------------------------\ndef for_constrained_field(self, field: FieldDefinition) -> Schema:\n        \"\"\"Create Schema for Pydantic Constrained fields (created using constr(), conint() and so forth, or by subclassing\n        Constrained*)\n\n        Args:\n            field: A signature field instance.\n------------------------------\n------------------------------\nArgs:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        if field_definition.has_inner_subclass_of(UploadFile):\n            return self.for_upload_file(field_definition)\n------------------------------\n------------------------------\ndef to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        if field_definition.origin is ClassicPagination:\n            return Schema(\n                type=OpenAPIType.OBJECT,\n                properties={\n                    \"items\": Schema(\n                        type=OpenAPIType.ARRAY,\n                        items=schema_creator.for_field_definition(field_definition.inner_types[0]),\n                    ),\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n# Natural Language Annotations: \"\"\"Create a schema object for a given pydantic model class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    properties = {}\n\n    for name, field in cls.__fields__.items():\n        field_definition = FieldDefinition(annotation=field.annotation)\n        properties[name] = schema_creator.to_openapi_schema(field_definition=field_definition, schema_creator=schema_creator)\n\n    return Schema(\n        type=OpenAPIType.OBJECT,\n        properties=properties,\n    )\n```", "```\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    properties = {}\n    for name, field in cls.__fields__.items():\n        properties[name] = schema_creator.for_field_definition(field)\n    return Schema(type=OpenAPIType.OBJECT, properties=properties)\n```", "```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    properties = {}\n    required = []\n    for field in cls.__fields__.values():\n        if field.required:\n            required.append(field.alias)\n        properties[field.alias] = schema_creator.for_field_definition(field)\n    return Schema(type=OpenAPIType.OBJECT, properties=properties, required=required)\n```"]}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nSimplify cleanup by wrapping :func:`next` / :func:`anext` calls and providing facilities to\n    :meth:`throw <generator.throw>` / :meth:`athrow <agen.athrow>` into all generators consecutively. An instance of\n    this class can be used as a contextmanager, which will automatically throw any exceptions into its generators. All\n    exceptions caught in this manner will be re-raised after they have been thrown in the generators.\n    \"\"\"\n\n    __slots__ = (\"_generators\", \"_closed\")\n------------------------------\n------------------------------\n__slots__ = (\"_generators\", \"_closed\")\n\n    def __init__(self, generators: list[AnyGenerator] | None = None) -> None:\n        \"\"\"Initialize ``DependencyCleanupGroup``.\n\n        Args:\n            generators: An optional list of generators to be called at cleanup\n        \"\"\"\n        self._generators = generators or []\n        self._closed = False\n\n    def add(self, generator: Generator[Any, None, None] | AsyncGenerator[Any, None]) -> None:\n        \"\"\"Add a new generator to the group.\n------------------------------\n------------------------------\nIf include is specified, all fields not specified in include will be excluded by default.\n------------------------------\n------------------------------\nThe order of the tags can be used to reflect on their order by the parsing tools. Not all tags that are used by the\n    `Operation Object <https://spec.openapis.org/oas/v3.1.0#operationObject>`_ must be declared. The tags that are not\n    declared MAY be organized randomly or based on the tools' logic. Each tag name in the list MUST be unique.\n    \"\"\"\n\n    external_docs: ExternalDocumentation | None = None\n    \"\"\"Additional external documentation.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            generator: The generator to add\n\n        Returns:\n            None\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Cannot call cleanup on a closed DependencyCleanupGroup\")\n        self._generators.append(generator)\n\n    @staticmethod\n    def _wrap_next(generator: AnyGenerator) -> Callable[[], Awaitable[None]]:\n        if isasyncgen(generator):\n\n            async def wrapped_async() -> None:\n                await async_next(generator, None)\n------------------------------\n------------------------------\nheaders: A string keyed dictionary of response headers. Header keys are insensitive.\n            media_type: A value for the response ``Content-Type`` header. If not provided, the value will be either\n                derived from the filename if provided and supported by the stdlib, or will default to\n                ``application/octet-stream``.\n            stat_result: An optional result of calling :func:os.stat:. If not provided, this will be done by the\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nfrom inspect import Traceback, isasyncgen\nfrom typing import TYPE_CHECKING, Any, AsyncGenerator, Awaitable, Callable, Generator\n\nfrom anyio import create_task_group\n\nfrom litestar.utils import ensure_async_callable\nfrom litestar.utils.compat import async_next\n\n__all__ = (\"DependencyCleanupGroup\",)\n\n\nif TYPE_CHECKING:\n    from litestar.types import AnyGenerator\n\n\n# Code for: class DependencyCleanupGroup:\n------------------------------\n------------------------------\nclass DependencyCleanupGroup:\n    \"\"\"Wrapper for generator based dependencies.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def cleanup(self) -> None:\n# Natural Language Annotations: \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n        If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    if self._closed:\n        raise RuntimeError(\"Cannot call cleanup on a closed DependencyCleanupGroup\")\n    self._closed = True\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            task_group.start_soon(self._wrap_next(generator))\n```", "Sure, here is the function based on the signature and the natural language annotations:\n\n```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\"\"\"\n\n    if self._closed:\n        raise RuntimeError(\"Cannot call cleanup on a closed DependencyCleanupGroup\")\n\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            task_group.start_soon(ensure_async_callable(self._wrap_next(generator)))\n```", "```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    self._closed = True\n\n    if not self._generators:\n        return\n\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            await task_group.spawn(self._wrap_next(generator))\n```"]}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        app: The Litestar app instance.\n        mount_routes: A dictionary mapping static routes to trie nodes.\n        plain_routes: A set of routes that do not have path parameters.\n        root_node: The root trie node.\n        route: The route that is being added.\n\n    Returns:\n        A RouteTrieNode instance.\n    \"\"\"\n    current_node = root_node\n\n    has_path_parameters = bool(route.path_parameters)\n------------------------------\n------------------------------\ndef configure_node(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    node: RouteTrieNode,\n) -> None:\n    \"\"\"Set required attributes and route handlers on route_map tree node.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        node: The trie node being configured.\n\n    Returns:\n        None\n    \"\"\"\n    from litestar.routes import HTTPRoute, WebSocketRoute\n------------------------------\n------------------------------\nArgs:\n            app: An ASGIApp, this value is the next ASGI handler to call in the middleware stack.\n            config: An instance of SessionAuth.\n        \"\"\"\n        self.app = app\n        self.config = config\n        self.has_wrapped_middleware = False\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"Handle creating a middleware stack and calling it.\n------------------------------\n------------------------------\napp = Litestar(\n                    route_handlers=[my_handler],\n                    logging_config=logging_config,\n                    middleware=[logging_middleware_config.middleware],\n                )\n\n        Returns:\n            An instance of DefineMiddleware including ``self`` as the config kwarg value.\n        \"\"\"\n        return DefineMiddleware(self.middleware_class, config=self)\n------------------------------\n------------------------------\ndef add_mount_route(\n    current_node: RouteTrieNode,\n    mount_routes: dict[str, RouteTrieNode],\n    root_node: RouteTrieNode,\n    route: ASGIRoute,\n) -> RouteTrieNode:\n    \"\"\"Add a node for a mount route.\n\n    Args:\n        current_node: The current trie node that is being mapped.\n        mount_routes: A dictionary mapping static routes to trie nodes.\n        root_node: The root trie node.\n        route: The route that is being added.\n\n    Returns:\n        A trie node.\n    \"\"\"\n------------------------------\n------------------------------\napp = Litestar(route_handlers=[my_handler], middleware=[throttle_config.middleware])\n\n        Returns:\n            An instance of :class:`DefineMiddleware <.middleware.base.DefineMiddleware>` including ``self`` as the\n            config kwarg value.\n        \"\"\"\n        return DefineMiddleware(self.middleware_class, config=self)\n------------------------------\n------------------------------\ndef wrap_in_exception_handler(app: ASGIApp) -> ASGIApp:\n    \"\"\"Wrap the given ASGIApp in an instance of ExceptionHandlerMiddleware.\n\n    Args:\n        app: The ASGI app that is being wrapped.\n\n    Returns:\n        A wrapped ASGIApp.\n    \"\"\"\n    from litestar.middleware._internal.exceptions import ExceptionHandlerMiddleware\n\n    return ExceptionHandlerMiddleware(app=app, debug=None)\n------------------------------\n------------------------------\nclass ASGIHandlerTuple(NamedTuple):\n    \"\"\"Encapsulation of a route handler node.\"\"\"\n\n    asgi_app: ASGIApp\n    \"\"\"An ASGI stack, composed of a handler function and layers of middleware that wrap it.\"\"\"\n    handler: RouteHandlerType\n    \"\"\"The route handler instance.\"\"\"\n------------------------------\n------------------------------\ndef __call__(self, app: ASGIApp) -> ASGIApp:\n        \"\"\"Call the middleware constructor or factory.\n\n        Args:\n            app: An ASGIApp, this value is the next ASGI handler to call in the middleware stack.\n\n        Returns:\n            Calls :class:`DefineMiddleware.middleware <.DefineMiddleware>` and returns the ASGIApp created.\n        \"\"\"\n\n        return self.middleware(*self.args, app=app, **self.kwargs)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_route_middleware_stack(\n# Natural Language Annotations: \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef build_route_middleware_stack(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    route_handler: RouteHandlerType,\n) -> ASGIApp:\n    middleware_stack = [m for m in app._middleware if m.config.exclude != route.path]\n    for middleware_cls, config in reversed(middleware_stack):\n        route_handler = middleware_cls(app=route_handler, config=config)\n    return route_handler\n```", "```python\ndef build_route_middleware_stack(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    route_handler: ASGIApp,\n) -> ASGIApp:\n    from litestar.middleware._internal.exceptions import ExceptionHandlerMiddleware\n    from litestar.middleware.base import DefineMiddleware\n\n    middleware_stack = [\n        DefineMiddleware(middleware, config=config)\n        for middleware, config in app.middleware\n    ]\n\n    middleware_stack.append(ExceptionHandlerMiddleware(None))\n\n    for middleware in reversed(middleware_stack):\n        route_handler = middleware(route_handler)\n\n    return route_handler\n```", "```python\ndef build_route_middleware_stack(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    route_handler: Callable,\n) -> ASGIApp:\n    middleware_stack = app.middleware.copy()\n    if route.opt.get(\"exclude_middleware\"):\n        middleware_stack = []\n    middleware_stack.append(route_handler)\n    return wrap_in_exception_handler(middleware_stack)\n```"]}, "litestar-litestar/utils/signature.py-from_fn": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n:data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n    \"\"\"\n    signature_namespace: dict[str, Any] = field(default_factory=dict)\n    \"\"\"A mapping of names to types for use in forward reference resolution during signature modeling.\"\"\"\n    signature_types: list[Any] = field(default_factory=list)\n    \"\"\"A sequence of types for use in forward reference resolution during signature modeling.\n------------------------------\n------------------------------\nArgs:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n        parameters = tuple(\n            FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n            for name, parameter in signature.parameters.items()\n            if name not in (\"self\", \"cls\")\n        )\n------------------------------\n------------------------------\nSee\n                :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n            signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n                These types will be added to the signature namespace using their ``__name__`` attribute.\n------------------------------\n------------------------------\ndef __call__(self, fn: AnyCallable) -> Self:\n        parsed_signature = ParsedSignature.from_fn(fn, self.resolve_signature_namespace())\n\n        if \"data\" not in parsed_signature.parameters:\n            raise ImproperlyConfiguredException(\"Websocket listeners must accept a 'data' parameter\")\n------------------------------\n------------------------------\nsignature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n------------------------------\n------------------------------\ndef get_fn_type_hints(fn: Any, namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Resolve type hints for ``fn``.\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n------------------------------\n------------------------------\nsecurity: A sequence of dicts that will be added to the schema of all route handlers in the application.\n                See :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>`\n                for details.\n            signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n            signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n------------------------------\n------------------------------\nparameters: dict[str, FieldDefinition]\n    \"\"\"A mapping of parameter names to ParsedSignatureParameter instances.\"\"\"\n    return_type: FieldDefinition\n    \"\"\"The return annotation of the callable.\"\"\"\n    original_signature: Signature\n    \"\"\"The raw signature as returned by :func:`inspect.signature`\"\"\"\n------------------------------\n------------------------------\noutbound response data.\n            signature_namespace: A mapping of names to types for use in forward reference resolution during signature\n                modelling.\n            type_decoders: A sequence of tuples, each composed of a predicate testing for type identity and a msgspec\n                hook for deserialization.\n            type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n------------------------------\n------------------------------\nprovider.parsed_fn_signature = ParsedSignature.from_signature(signature, init_type_hints)\n            else:\n                provider.parsed_fn_signature = ParsedSignature.from_fn(dependency, self.resolve_signature_namespace())\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n# Natural Language Annotations: \"\"\"Parse a function signature.\n\n        Args:\n            fn: Any callable.\n            signature_namespace: mapping of names to types for forward reference resolution\n\n        Returns:\n            ParsedSignature\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    signature = inspect.signature(fn)\n    fn_type_hints = get_fn_type_hints(fn, signature_namespace)\n    parameters = tuple(\n        FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n        for name, parameter in signature.parameters.items()\n        if name not in (\"self\", \"cls\")\n    )\n    return_type = FieldDefinition.from_type_hint(signature.return_annotation, fn_type_hints)\n    return cls(\n        parameters={parameter.name: parameter for parameter in parameters},\n        return_type=return_type,\n        original_signature=signature,\n    )\n```", "```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    signature = inspect.signature(fn)\n    fn_type_hints = get_fn_type_hints(fn, signature_namespace)\n    parameters = tuple(\n        FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n        for name, parameter in signature.parameters.items()\n        if name not in (\"self\", \"cls\")\n    )\n    return_type = FieldDefinition.from_annotation(signature.return_annotation, fn_type_hints)\n    original_signature = signature\n    return cls(parameters, return_type, original_signature)\n```", "```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    signature = inspect.signature(fn)\n    fn_type_hints = get_fn_type_hints(fn, signature_namespace)\n    return cls.from_signature(signature, fn_type_hints)\n```"]}, "litestar-litestar/utils/deprecation.py-deprecated": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            path: A path fragment for the route handler function or a sequence of path fragments.\n                If not given defaults to ``/``\n            after_request: A sync or async function executed before a :class:`Request <.connection.Request>` is passed\n                to any route handler. If this function returns a value, the request will not reach the route handler,\n                and instead this value will be used.\n------------------------------\n------------------------------\nArgs:\n        version: Litestar version where the deprecation will occur\n        deprecated_name: Name of the deprecated function\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated thing\n    \"\"\"\n    parts = []\n------------------------------\n------------------------------\ndef warn_deprecation(\n    version: str,\n    deprecated_name: str,\n    kind: DeprecatedKind,\n    *,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n) -> None:\n    \"\"\"Warn about a call to a (soon to be) deprecated function.\n------------------------------\n------------------------------\nparts.extend(\n        (\n            f\"Deprecated in litestar {version}\",\n            f\"This {kind} will be removed in {removal_in or 'the next major version'}\",\n        )\n    )\n    if alternative:\n        parts.append(f\"Use {alternative!r} instead\")\n\n    if info:\n        parts.append(info)\n\n    text = \". \".join(parts)\n    warning_class = PendingDeprecationWarning if pending else DeprecationWarning\n\n    warn(text, warning_class, stacklevel=2)\n------------------------------\n------------------------------\nfrom typing import Any\n\nfrom litestar.utils.deprecation import deprecated, warn_deprecation\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nimport inspect\nfrom functools import wraps\nfrom typing import Callable, Literal, TypeVar\nfrom warnings import warn\n\nfrom typing_extensions import ParamSpec\n\n__all__ = (\"deprecated\", \"warn_deprecation\")\n\n\nT = TypeVar(\"T\")\nP = ParamSpec(\"P\")\nDeprecatedKind = Literal[\"function\", \"method\", \"classmethod\", \"attribute\", \"property\", \"class\", \"parameter\", \"import\"]\n\n\n# Code for: def warn_deprecation(\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def deprecated(\n# Natural Language Annotations: \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n):\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            if kind is None:\n                if inspect.ismethod(func):\n                    _kind: DeprecatedKind = \"method\"\n                else:\n                    _kind = \"function\"\n            else:\n                _kind = kind\n            warn_deprecation(\n                version=version,\n                deprecated_name=func.__qualname__,\n                kind=_kind,\n                removal_in=removal_in,\n                alternative=alternative,\n                info=info,\n                pending=pending,\n            )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```", "```python\nfrom typing import Any, Callable, Literal, TypeVar\nfrom warnings import warn\n\nfrom typing_extensions import ParamSpec\n\nT = TypeVar(\"T\")\nP = ParamSpec(\"P\")\nDeprecatedKind = Literal[\"function\", \"method\", \"classmethod\", \"attribute\", \"property\", \"class\", \"parameter\", \"import\"]\n\n\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        if kind is None:\n            if inspect.ismethod(func) or (inspect.isfunction(func) and \"self\" in inspect.signature(func).parameters):\n                kind = \"method\" if inspect.ismethod(func) else \"function\"\n            else:\n                kind = \"function\"\n\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            warn_deprecation(version, func.__qualname__, kind, removal_in=removal_in, alternative=alternative, info=info, pending=pending)\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```", "```python\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n):\n    def decorator(func: Callable[P, T]) -> Callable[P, T]:\n        @wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            deprecated_kind = kind or (\n                \"method\" if args and inspect.ismethod(func) else \"function\"\n            )\n            warn_deprecation(\n                version=version,\n                deprecated_name=func.__qualname__,\n                kind=deprecated_kind,\n                removal_in=removal_in,\n                alternative=alternative,\n                info=info,\n                pending=pending,\n            )\n            return func(*args, **kwargs)\n\n        return wrapper\n\n    return decorator\n```"]}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            key: Key associated with the value\n            renew_for: If given and the value had an initial expiry time set, renew the\n                expiry time for ``renew_for`` seconds. If the value has not been set\n                with an expiry time this is a no-op\n\n        Returns:\n            The value associated with ``key`` if it exists and is not expired, else\n            ``None``\n        \"\"\"\n        raise NotImplementedError\n------------------------------\n------------------------------\ndef __call__(self, fn: AnyCallable) -> HTTPRouteHandler:\n        \"\"\"Replace a function with itself.\"\"\"\n        if not is_async_callable(fn):\n            if self.sync_to_thread is None:\n                warn_implicit_sync_to_thread(fn, stacklevel=3)\n        elif self.sync_to_thread is not None:\n            warn_sync_to_thread_with_async_callable(fn, stacklevel=3)\n\n        super().__call__(fn)\n        return self\n------------------------------\n------------------------------\nThis is wrapped in a try except block - and if an exception is raised,\n        it tries to pass it to an appropriate exception handler - if defined.\n        \"\"\"\n        response_data: Any = None\n        cleanup_group: DependencyCleanupGroup | None = None\n\n        if before_request_handler := route_handler.resolve_before_request():\n            response_data = await before_request_handler(request)\n------------------------------\n------------------------------\ndef __call__(self, fn: AnyCallable) -> EventListener:\n        \"\"\"Decorate a callable by wrapping it inside an instance of EventListener.\n\n        Args:\n            fn: Callable to decorate.\n\n        Returns:\n            An instance of EventListener\n        \"\"\"\n        if not callable(fn):\n            raise ImproperlyConfiguredException(\"EventListener instance should be called as a decorator on a callable\")\n\n        self.fn = self.wrap_in_error_handler(ensure_async_callable(fn))\n------------------------------\n------------------------------\nIf the \"items\" subschema is applied to any positions within the instance array, it produces an annotation result of\n    boolean true, indicating that all remaining array elements have been evaluated against this keyword's subschema.\n\n    Omitting this keyword has the same assertion behavior as an empty schema.\n------------------------------\n------------------------------\n@property\n    def fn(self) -> AsyncAnyCallable:\n        \"\"\"Get the handler function.\n\n        Raises:\n            ImproperlyConfiguredException: if handler fn is not set.\n\n        Returns:\n            Handler function\n        \"\"\"\n        if not hasattr(self, \"_fn\"):\n            raise ImproperlyConfiguredException(\"No callable has been registered for this handler\")\n        return self._fn\n------------------------------\n------------------------------\nRaises:\n            ImproperlyConfiguredException: If ``auth`` is not set in scope via an ``AuthMiddleware``, raises an exception\n\n        Returns:\n            A type correlating to the generic variable Auth.\n        \"\"\"\n        if \"auth\" not in self.scope:\n            raise ImproperlyConfiguredException(\"'auth' is not defined in scope, install an AuthMiddleware to set it\")\n\n        return cast(\"AuthT\", self.scope[\"auth\"])\n------------------------------\n------------------------------\nif not is_async_callable(self.fn):\n            raise ImproperlyConfiguredException(f\"{self}: WebSocket handler functions must be asynchronous\")\n------------------------------\n------------------------------\nReturns:\n        The ``typing`` module equivalent of the given type, if it exists. Otherwise, the original type is returned.\n    \"\"\"\n    if origin_type is None:\n        return safe_generic_origin_map.get(annotation)\n    return safe_generic_origin_map.get(origin_type, origin_type)\n------------------------------\n------------------------------\nif self.has_sync_callable and self.sync_to_thread:\n            self._fn = ensure_async_callable(self.fn)\n            self.has_sync_callable = False\n\n    def _validate_handler_function(self) -> None:\n        \"\"\"Validate the route handler function once it is set by inspecting its return annotations.\"\"\"\n        super()._validate_handler_function()\n\n        return_type = self.parsed_fn_signature.return_type\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n# Natural Language Annotations: \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    \n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if not asyncio.iscoroutinefunction(fn):\n        fn = asyncio.coroutine(fn)\n    return fn\n```", "```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if is_async_callable(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```", "```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return async_tools.AsyncCallable(fn)\n```"]}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n        parameters = tuple(\n            FieldDefinition.from_parameter(parameter=parameter, fn_type_hints=fn_type_hints)\n            for name, parameter in signature.parameters.items()\n            if name not in (\"self\", \"cls\")\n        )\n------------------------------\n------------------------------\ntype_hints = get_type_hints(origin, globalns=globalns, localns=localns, include_extras=include_extras)\n        # the __parameters__ is only available on the origin itself and not the annotation\n        typevar_map = dict(zip(origin.__parameters__, get_args(annotation)))\n------------------------------\n------------------------------\ndef create_schema_for_annotation(annotation: Any) -> Schema:\n    \"\"\"Get a schema from the type mapping - if possible.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A schema instance or None.\n    \"\"\"\n\n    return copy(TYPE_MAP[annotation]) if annotation in TYPE_MAP else Schema()\n------------------------------\n------------------------------\nmodel_annotations = get_type_hints(\n                origin, globalns=globalns, localns=localns, include_extras=include_extras\n            )\n        args = annotation.__pydantic_generic_metadata__[\"args\"]\n        parameters = origin.__pydantic_generic_metadata__[\"parameters\"]\n        typevar_map = dict(zip(parameters, args))\n------------------------------\n------------------------------\nwill drop older messages in favour of new ones.\n            subscriber_class: A :class:`Subscriber` subclass to return from :meth:`subscribe`\n            type_encoders: An additional mapping of type encoders used to encode data before sending\n------------------------------\n------------------------------\ndef get_typed_init(self, type_: Any) -> tuple[Signature, dict[str, Any]]:\n        parameters = []\n        type_hints = {}\n        for field_info in msgspec.structs.fields(type_):\n            type_hints[field_info.name] = field_info.type\n            parameters.append(\n                inspect.Parameter(\n                    name=field_info.name,\n                    kind=inspect.Parameter.KEYWORD_ONLY,\n                    annotation=field_info.type,\n------------------------------\n------------------------------\nArgs:\n        origin_type: A type - would be the return value of :func:`get_origin()`.\n        annotation: Type annotation associated with the origin type. Should be unwrapped from any wrapper types, such\n            as ``Annotated``.\n\n    Returns:\n        A builtin type that is safe to instantiate for the given origin type.\n    \"\"\"\n    if origin_type is None:\n        return instantiable_type_mapping.get(annotation)\n    return instantiable_type_mapping.get(origin_type, origin_type)\n------------------------------\n------------------------------\ndef get_fn_type_hints(fn: Any, namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Resolve type hints for ``fn``.\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n------------------------------\n------------------------------\noutbound response data.\n            signature_namespace: A mapping of names to types for use in forward reference resolution during signature\n                modelling.\n            type_decoders: A sequence of tuples, each composed of a predicate testing for type identity and a msgspec\n                hook for deserialization.\n            type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n------------------------------\n------------------------------\ntype_hints = field_definition.get_type_hints(include_extras=True, resolve_generics=True)\n        struct_fields = fields(field_definition.type_)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n    return {name: namespace.get(type_, type_) for name, type_ in type_hint.items()}\n```", "```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n\n    new_type_hint = {}\n    for param, type_ in type_hint.items():\n        if isinstance(type_, TypeVar):\n            new_type_hint[param] = namespace.get(type_.__name__, type_)\n        else:\n            new_type_hint[param] = type_\n\n    return new_type_hint\n```", "```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    if namespace is None:\n        return type_hint\n    return {name: namespace[type_] if type_ in namespace else type_ for name, type_ in type_hint.items()}\n```"]}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A tuple of key/value pairs.\n    \"\"\"\n    dataclass_fields = extract_dataclass_fields(dt, exclude_none, exclude_empty, include, exclude)\n    return tuple((field.name, getattr(dt, field.name)) for field in dataclass_fields)\n------------------------------\n------------------------------\nArgs:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n\n    Returns:\n        A tuple of dataclass fields.\n    \"\"\"\n    include = include or set()\n    exclude = exclude or set()\n\n    if common := (include & exclude):\n        raise ValueError(f\"Fields {common} are both included and excluded.\")\n------------------------------\n------------------------------\ndef extract_dataclass_items(\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    include: AbstractSet[str] | None = None,\n    exclude: AbstractSet[str] | None = None,\n) -> tuple[tuple[str, Any], ...]:\n    \"\"\"Extract dataclass name, value pairs.\n\n    Unlike the 'asdict' method exports by the stlib, this function does not pickle values.\n------------------------------\n------------------------------\nArgs:\n            extract_body: Whether to extract the body.\n            extract_cookies: Whether to extract the cookies.\n            extract_headers: Whether to extract the headers.\n            extract_status_code: Whether to extract the status code.\n            obfuscate_cookies: cookie keys to obfuscate. Obfuscated values are replaced with '*****'.\n            obfuscate_headers: headers keys to obfuscate. Obfuscated values are replaced with '*****'.\n        \"\"\"\n------------------------------\n------------------------------\ndef _obfuscate(values: dict[str, Any], fields_to_obfuscate: set[str]) -> dict[str, Any]:\n    \"\"\"Obfuscate values in a dictionary, replacing values with `******`\n\n    Args:\n        values: A dictionary of strings\n        fields_to_obfuscate: keys to obfuscate\n\n    Returns:\n        A dictionary with obfuscated strings\n    \"\"\"\n    return {key: \"*****\" if key.lower() in fields_to_obfuscate else value for key, value in values.items()}\n------------------------------\n------------------------------\nArgs:\n            extract_body: Whether to extract body, (for requests only).\n            extract_client: Whether to extract the client (host, port) mapping.\n            extract_content_type: Whether to extract the content type and any options.\n            extract_cookies: Whether to extract cookies.\n            extract_headers: Whether to extract headers.\n            extract_method: Whether to extract the HTTP method, (for requests only).\n------------------------------\n------------------------------\ndef extract_dataclass_fields(\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    include: AbstractSet[str] | None = None,\n    exclude: AbstractSet[str] | None = None,\n) -> tuple[Field[Any], ...]:\n    \"\"\"Extract dataclass fields.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def simple_asdict(\n# Natural Language Annotations: \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    exclude = exclude or set()\n    result = {}\n    for field in fields(obj):\n        if field.name in exclude:\n            continue\n        value = getattr(obj, field.name)\n        if exclude_none and value is None:\n            continue\n        if exclude_empty and not value:\n            continue\n        if convert_nested and is_dataclass(value):\n            result[field.name] = simple_asdict(value)\n        else:\n            result[field.name] = value\n    return result\n```", "```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    exclude = exclude or set()\n    if exclude_none and exclude_empty:\n        return {field.name: getattr(obj, field.name) for field in fields(obj) if getattr(obj, field.name) is not None and getattr(obj, field.name) != \"\" and field.name not in exclude}\n    elif exclude_none:\n        return {field.name: getattr(obj, field.name) for field in fields(obj) if getattr(obj, field.name) is not None and field.name not in exclude}\n    elif exclude_empty:\n        return {field.name: getattr(obj, field.name) for field in fields(obj) if getattr(obj, field.name) != \"\" and field.name not in exclude}\n    else:\n        return {field.name: getattr(obj, field.name) for field in fields(obj) if field.name not in exclude}\n```", "```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    dataclass_fields = extract_dataclass_fields(obj, exclude_none, exclude_empty, exclude=exclude)\n    return {field.name: getattr(obj, field.name) for field in dataclass_fields}\n```"]}, "litestar-litestar/utils/path.py-join_paths": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            path: A path fragment for the route handler function or a sequence of path fragments. If not given defaults\n                to ``/``\n            dependencies: A string keyed mapping of dependency :class:`Provider <.di.Provide>` instances.\n            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n                validation of request data.\n------------------------------\n------------------------------\ndef normalize_path(path: str) -> str:\n    \"\"\"Normalize a given path by ensuring it starts with a slash and does not end with a slash.\n\n    Args:\n        path: Path string\n\n    Returns:\n        Path string\n    \"\"\"\n    path = path.strip(\"/\")\n    path = f\"/{path}\"\n    return multi_slash_pattern.sub(\"/\", path)\n------------------------------\n------------------------------\nArgs:\n            path: A path fragment for the route handler function or a sequence of path fragments. If not given defaults\n                to ``/``\n            connection_accept_handler: A callable that accepts a :class:`WebSocket <.connection.WebSocket>` instance\n                and returns a coroutine that when awaited, will accept the connection. Defaults to ``WebSocket.accept``.\n------------------------------\n------------------------------\nReturns:\n            A tuple composed of the ASGIApp of the route, the route handler instance, the resolved and normalized path and any parsed path params.\n        \"\"\"\n        return parse_path_to_route(\n            mount_paths_regex=self._mount_paths_regex,\n            mount_routes=self._mount_routes,\n            path=path,\n            plain_routes=self._plain_routes,\n            root_node=self.root_route_map_node,\n            method=method,\n        )\n------------------------------\n------------------------------\nReturns:\n            A 3-tuple of the normalized path, the OpenAPI formatted path, and the list of parsed components.\n        \"\"\"\n        path = normalize_path(path)\n\n        parsed_components: list[str | PathParameterDefinition] = []\n        path_format_components = []\n        path_parameters: dict[str, PathParameterDefinition] = {}\n------------------------------\n------------------------------\nArgs:\n            path: A path fragment for the route handler function or a sequence of path fragments. If not given defaults\n                to ``/``\n            dependencies: A string keyed mapping of dependency :class:`Provider <.di.Provide>` instances.\n            exception_handlers: A mapping of status codes and/or exception types to handler functions.\n            guards: A sequence of :class:`Guard <.types.Guard>` callables.\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\n__all__ = (\"join_paths\", \"normalize_path\")\n\n\nmulti_slash_pattern = re.compile(\"//+\")\n\n\n# Code for: def normalize_path(path: str) -> str:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def join_paths(paths: Iterable[str]) -> str:\n# Natural Language Annotations: \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return multi_slash_pattern.sub(\"/\", \"/\".join(paths))\n```", "```python\nfrom __future__ import annotations\n\nimport re\nfrom typing import Iterable\n\n__all__ = (\"join_paths\", \"normalize_path\")\n\n\nmulti_slash_pattern = re.compile(\"//+\")\n\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    path = \"/\".join(paths)\n    path = multi_slash_pattern.sub(\"/\", path)\n    return path\n```", "```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\"\"\"\n    return \"/\" + \"/\".join(normalize_path(path) for path in paths)\n```"]}, "litestar-litestar/utils/helpers.py-get_name": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_enum_string_value(value: Enum | str) -> str:\n    \"\"\"Return the string value of a string enum.\n\n    See: https://github.com/litestar-org/litestar/pull/633#issuecomment-1286519267\n\n    Args:\n        value: An enum or string.\n\n    Returns:\n        A string.\n    \"\"\"\n    return value.value if isinstance(value, Enum) else value  # type: ignore[no-any-return]\n------------------------------\n------------------------------\ndef _get_default_labels(self, request: Request[Any, Any, Any]) -> dict[str, str | int | float]:\n        \"\"\"Get default label values from the request.\n\n        Args:\n            request: The request object.\n\n        Returns:\n            A dictionary of default labels.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            An integer\n        \"\"\"\n        return len(self._state)\n\n    def __getattr__(self, key: str) -> Any:\n        \"\"\"Get the value for the corresponding key from the wrapped state object using attribute notation.\n\n        Args:\n            key: Key to retrieve\n\n        Raises:\n            AttributeError: if the given attribute is not set.\n------------------------------\n------------------------------\ndef decode_msgpack(  # type: ignore[misc]\n    value: bytes,\n    target_type: type[T] | EmptyType = Empty,  # pyright: ignore[reportInvalidTypeVarUse]\n    type_decoders: TypeDecodersSequence | None = None,\n) -> Any:\n    \"\"\"Decode a MessagePack string/bytes into an object.\n\n    Args:\n        value: Value to decode\n        target_type: An optional type to decode the data into\n        type_decoders: Optional sequence of type decoders\n\n    Returns:\n        An object\n------------------------------\n------------------------------\ndef _get_request_from_context(context: Mapping[str, Any]) -> Request:\n    \"\"\"Get the request from the template context.\n\n    Args:\n        context: The template context.\n\n    Returns:\n        The request object.\n    \"\"\"\n    return cast(\"Request\", context[\"request\"])\n------------------------------\n------------------------------\nExample:\n            number[]\n\n        Returns:\n            A typescript string\n        \"\"\"\n        value = (\n            f\"({self.item_type.write()})\"\n            if isinstance(self.item_type, (TypeScriptUnion, TypeScriptIntersection))\n            else self.item_type.write()\n        )\n        return f\"{value}[]\"\n------------------------------\n------------------------------\nReturns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    async def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n------------------------------\n------------------------------\ndef decode_json(  # type: ignore[misc]\n    value: str | bytes,\n    target_type: type[T] | EmptyType = Empty,  # pyright: ignore\n    type_decoders: TypeDecodersSequence | None = None,\n) -> Any:\n    \"\"\"Decode a JSON string/bytes into an object.\n\n    Args:\n        value: Value to decode\n        target_type: An optional type to decode the data into\n        type_decoders: Optional sequence of type decoders\n\n    Returns:\n        An object\n------------------------------\n------------------------------\n@classmethod\n    def get_id_attribute_value(cls, item: T | type[T], id_attribute: str | None = None) -> Any:\n        \"\"\"Get value of attribute named as :attr:`id_attribute <AbstractAsyncRepository.id_attribute>` on ``item``.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_name(value: object) -> str:\n# Natural Language Annotations: \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```", "```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```", "```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```"]}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef is_any(annotation: Any) -> TypeGuard[Any]:\n    \"\"\"Given a type annotation determine if the annotation is Any.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Any <typing.Any>`.\n    \"\"\"\n    return (\n        annotation is Any\n        or getattr(annotation, \"_name\", \"\") == \"typing.Any\"\n        or (get_origin_or_inner_type(annotation) in UnionTypes and Any in get_args(annotation))\n    )\n------------------------------\n------------------------------\ndef is_pydantic_model_instance(\n    annotation: Any,\n) -> TypeGuard[pydantic_v1.BaseModel | pydantic_v2.BaseModel]:  # pyright: ignore\n    \"\"\"Given a type annotation determine if the annotation is an instance of pydantic's BaseModel.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`BaseModel pydantic.BaseModel>`.\n    \"\"\"\n    tests: list[bool] = []\n------------------------------\n------------------------------\ndef is_dataclass_instance(obj: Any) -> TypeGuard[DataclassProtocol]:\n    \"\"\"Check if an object is a dataclass instance.\n\n    Args:\n        obj: An object to check.\n\n    Returns:\n        True if the object is a dataclass instance.\n    \"\"\"\n    return hasattr(type(obj), \"__dataclass_fields__\")\n------------------------------\n------------------------------\ndef create_schema_for_annotation(annotation: Any) -> Schema:\n    \"\"\"Get a schema from the type mapping - if possible.\n\n    Args:\n        annotation: A type annotation.\n\n    Returns:\n        A schema instance or None.\n    \"\"\"\n\n    return copy(TYPE_MAP[annotation]) if annotation in TYPE_MAP else Schema()\n------------------------------\n------------------------------\ndef is_class_and_subclass(annotation: Any, type_or_type_tuple: type[T] | tuple[type[T], ...]) -> TypeGuard[type[T]]:\n    \"\"\"Return ``True`` if ``value`` is a ``class`` and is a subtype of ``t_type``.\n\n    See https://github.com/litestar-org/litestar/issues/367\n\n    Args:\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n------------------------------\n------------------------------\ndef is_attrs_class(annotation: Any) -> TypeGuard[type[attrs.AttrsInstance]]:  # pyright: ignore\n    \"\"\"Given a type annotation determine if the annotation is a class that includes an attrs attribute.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is an attrs class.\n    \"\"\"\n    return attrs.has(annotation) if attrs is not Empty else False  # type: ignore[comparison-overlap]\n------------------------------\n------------------------------\ndef is_pydantic_model_class(\n    annotation: Any,\n) -> TypeGuard[type[pydantic_v1.BaseModel | pydantic_v2.BaseModel]]:  # pyright: ignore\n    \"\"\"Given a type annotation determine if the annotation is a subclass of pydantic's BaseModel.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`BaseModel pydantic.BaseModel>`.\n    \"\"\"\n    tests: list[bool] = []\n------------------------------\n------------------------------\ndef is_mapping(annotation: Any) -> TypeGuard[Mapping[Any, Any]]:\n    \"\"\"Given a type annotation determine if the annotation is a mapping type.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type can be cast as :class:`Mapping <typing.Mapping>`.\n    \"\"\"\n    _type = get_origin_or_inner_type(annotation) or annotation\n    return isclass(_type) and issubclass(_type, (dict, defaultdict, DefaultDict, Mapping))\n------------------------------\n------------------------------\ndef _is_sync_or_async_generator(obj: Any) -> TypeGuard[AnyGenerator]:\n    \"\"\"Check if the given annotation is a sync or async generator.\n\n    Args:\n        obj: type to be tested for sync or async generator.\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isgeneratorfunction(obj) or isasyncgenfunction(obj)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n# Natural Language Annotations: \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_dataclass(annotation)\n```", "```python\nfrom typing import Any, TypeGuard\nfrom dataclasses import is_dataclass\nfrom typing_extensions import TypeGuard\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[Type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_dataclass(annotation)\n```", "```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_dataclass(annotation) or (hasattr(annotation, \"__dataclass_fields__\") and not isinstance(annotation, type))\n```"]}, "litestar-litestar/utils/predicates.py-is_class_var": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef is_annotated_type(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is an Annotated.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _AnnotatedAlias) and getattr(annotation, \"__args__\", None) is not None\n------------------------------\n------------------------------\ndef is_pydantic_constrained_field(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a constrained pydantic type.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        True if pydantic is installed and the type is a constrained type, otherwise False.\n    \"\"\"\n    if pydantic_v1 is Empty:  # pragma: no cover\n        return False  # type: ignore[unreachable]\n------------------------------\n------------------------------\ndef is_any(annotation: Any) -> TypeGuard[Any]:\n    \"\"\"Given a type annotation determine if the annotation is Any.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Any <typing.Any>`.\n    \"\"\"\n    return (\n        annotation is Any\n        or getattr(annotation, \"_name\", \"\") == \"typing.Any\"\n        or (get_origin_or_inner_type(annotation) in UnionTypes and Any in get_args(annotation))\n    )\n------------------------------\n------------------------------\ndef _is_sync_or_async_generator(obj: Any) -> TypeGuard[AnyGenerator]:\n    \"\"\"Check if the given annotation is a sync or async generator.\n\n    Args:\n        obj: type to be tested for sync or async generator.\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isgeneratorfunction(obj) or isasyncgenfunction(obj)\n------------------------------\n------------------------------\nArgs:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Union typing.Union>` with a\n            None value or :data:`Optional <typing.Optional>` which is equivalent.\n    \"\"\"\n    origin = get_origin_or_inner_type(annotation)\n    return origin is Optional or (\n        get_origin_or_inner_type(annotation) in UnionTypes and NoneType in get_args(annotation)\n    )\n------------------------------\n------------------------------\ndef is_non_string_sequence(annotation: Any) -> TypeGuard[Sequence[Any]]:\n    \"\"\"Given a type annotation determine if the annotation is a sequence.\n\n    Args:\n    annotation: A type.\n------------------------------\n------------------------------\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        True if the annotation is a subclass of :data:`Generic <typing.Generic>` otherwise ``False``.\n    \"\"\"\n    return is_class_and_subclass(annotation, Generic)  # type: ignore[arg-type]\n------------------------------\n------------------------------\ndef is_non_string_iterable(annotation: Any) -> TypeGuard[Iterable[Any]]:\n    \"\"\"Given a type annotation determine if the annotation is an iterable.\n\n    Args:\n    annotation: A type.\n------------------------------\n------------------------------\ndef is_union(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation infers an optional union.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A boolean determining whether the type is :data:`Union typing.Union>`.\n    \"\"\"\n    return get_origin_or_inner_type(annotation) in UnionTypes\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_class_var(annotation: Any) -> bool:\n# Natural Language Annotations: \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return getattr(annotation, '_name', '') == 'typing.ClassVar'\n```", "```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _ClassVarAlias)\n```", "```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, ClassVar)\n```"]}, "litestar-litestar/utils/module_loader.py-import_string": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef module_to_os_path(dotted_path: str = \"app\") -> Path:\n    \"\"\"Find Module to OS Path.\n\n    Return a path to the base directory of the project or the module\n    specified by `dotted_path`.\n\n    Args:\n        dotted_path: The path to the module. Defaults to \"app\".\n\n    Raises:\n        TypeError: The module could not be found.\n------------------------------\n------------------------------\ndef get_module_global_imports(module_import_path: str, reference_target_source_obj: str) -> set[str]:\n    \"\"\"Return a set of names that are imported globally within the containing module of ``reference_target_source_obj``,\n    including imports in ``if TYPE_CHECKING`` blocks.\n    \"\"\"\n    module = importlib.import_module(module_import_path)\n    obj = getattr(module, reference_target_source_obj)\n------------------------------\n------------------------------\ndef is_pydantic_v2(module: ModuleType) -> bool:\n    \"\"\"Determine if the given module is pydantic v2.\n\n    Given a module we expect to be a pydantic version, determine if it is pydantic v2.\n\n    Args:\n        module: A module.\n\n    Returns:\n        True if the module is pydantic v2, otherwise False.\n    \"\"\"\n    return bool(module.__version__.startswith(\"2.\"))\n------------------------------\n------------------------------\nReturns:\n        Path: The path to the module.\n    \"\"\"\n    try:\n        if (src := find_spec(dotted_path)) is None:  # pragma: no cover\n            raise TypeError(f\"Couldn't find the path for {dotted_path}\")\n    except ModuleNotFoundError as e:\n        raise TypeError(f\"Couldn't find the path for {dotted_path}\") from e\n\n    return Path(str(src.origin).rsplit(os.path.sep + \"__init__.py\", maxsplit=1)[0])\n------------------------------\n------------------------------\ndef has_path(self, path: str) -> bool:\n        \"\"\"Check if the plugin has a path.\n\n        Args:\n            path: The path to check.\n\n        Returns:\n            True if the plugin has the path, False otherwise.\n        \"\"\"\n        return path in self.paths\n------------------------------\n------------------------------\n\"\"\"General utility functions.\"\"\"\n\nfrom __future__ import annotations\n\nimport os.path\nimport sys\nfrom importlib import import_module\nfrom importlib.util import find_spec\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nif TYPE_CHECKING:\n    from types import ModuleType\n\n__all__ = (\n    \"import_string\",\n    \"module_to_os_path\",\n)\n\n\n# Code for: def module_to_os_path(dotted_path: str = \"app\") -> Path:\n------------------------------\n------------------------------\ndef _path_to_dotted_path(path: Path) -> str:\n    if path.stem == \"__init__\":\n        path = path.parent\n    return \".\".join(path.with_suffix(\"\").parts)\n------------------------------\n------------------------------\nReturns:\n        The ``typing`` module equivalent of the given type, if it exists. Otherwise, the original type is returned.\n    \"\"\"\n    if origin_type is None:\n        return safe_generic_origin_map.get(annotation)\n    return safe_generic_origin_map.get(origin_type, origin_type)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def import_string(dotted_path: str) -> Any:\n# Natural Language Annotations: \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as e:\n        raise ImportError(f\"{dotted_path} doesn't look like a module path\") from e\n\n    module = import_module(module_path)\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError as e:\n        raise ImportError(f\"Module {module_path} does not define a {class_name} attribute/class\") from e\n```", "```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError:\n        raise ImportError(f\"{dotted_path} doesn't look like a module path\")\n\n    module = import_module(module_path)\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError:\n        raise ImportError(f\"Module {module_path} does not define a {class_name} attribute/class\")\n```", "```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n        module = import_module(module_path)\n        return getattr(module, class_name)\n    except (ImportError, AttributeError) as e:\n        raise ImportError(f\"Could not import {dotted_path}\") from e\n```"]}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Unsubscribe from ``channels``\"\"\"\n        self._channels -= set(channels)\n        try:\n            for channel in channels:\n                del self._history[channel]\n        except KeyError:\n            pass\n------------------------------\n------------------------------\n@abstractmethod\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Start listening for events on ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        ...\n------------------------------\n------------------------------\nArgs:\n            channels: Channels to unsubscribe from. If ``None``, unsubscribe from all channels\n            subscriber: :class:`Subscriber` to unsubscribe\n        \"\"\"\n        if channels is None:\n            channels = list(self._channels.keys())\n        elif isinstance(channels, str):\n            channels = [channels]\n\n        channels_to_unsubscribe: set[str] = set()\n\n        for channel in channels:\n            channel_subscribers = self._channels[channel]\n------------------------------\n------------------------------\nreturn subscriber\n\n    async def unsubscribe(self, subscriber: Subscriber, channels: str | Iterable[str] | None = None) -> None:\n        \"\"\"Unsubscribe a :class:`Subscriber` from ``channels``. If the subscriber has a running sending task, it will\n        be stopped.\n------------------------------\n------------------------------\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        await self._pub_sub.unsubscribe(*channels)\n        # if we have no active subscriptions, or only subscriptions which are pending\n        # to be unsubscribed we consider the backend to be unsubscribed from all\n        # channels, so we reset the event\n        if not self._pub_sub.channels.keys() - self._pub_sub.pending_unsubscribe_channels:\n------------------------------\n------------------------------\nasync def wait_published(self, data: LitestarEncodableType, channels: str | Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\"\"\"\n        if isinstance(channels, str):\n            channels = [channels]\n        data = self.encode_data(data)\n\n        await self._backend.publish(data, channels)\n------------------------------\n------------------------------\nasync def on_startup(self) -> None:\n        \"\"\"Called on application startup\"\"\"\n\n    async def on_shutdown(self) -> None:\n        \"\"\"Called on application shutdown\"\"\"\n\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Subscribe to ``channels``\"\"\"\n        self._subscribed_channels.update(channels)\n        self._has_subscribed_channels.set()\n------------------------------\n------------------------------\n# subscribed to anymore\n            if channel.encode() in self._pub_sub.channels.keys() - self._pub_sub.pending_unsubscribe_channels:\n                yield channel, data\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def unsubscribe(self, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Unsubscribe from ``channels``\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```"]}, "litestar-litestar/channels/backends/redis.py-publish": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\n\n        .. note::\n            This operation is performed atomically, using a lua script\n        \"\"\"\n        await self._publish_script(keys=list(set(channels)), args=[data])\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n------------------------------\n------------------------------\nreturn app_config\n\n    def publish(self, data: LitestarEncodableType, channels: str | Iterable[str]) -> None:\n        \"\"\"Schedule ``data`` to be published to ``channels``.\n\n        .. note::\n            This is a synchronous method that returns immediately. There are no\n            guarantees that when this method returns the data will have been published\n            to the backend. For that, use :meth:`wait_published`\n------------------------------\n------------------------------\nasync def wait_published(self, data: LitestarEncodableType, channels: str | Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\"\"\"\n        if isinstance(channels, str):\n            channels = [channels]\n        data = self.encode_data(data)\n\n        await self._backend.publish(data, channels)\n------------------------------\n------------------------------\nasync def on_shutdown(self) -> None:\n        self._queue = None\n\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``. If a channel has not yet been subscribed to,\n        this will be a no-op.\n\n        Args:\n            data: Data to publish\n            channels: Channels to publish to\n\n        Returns:\n            None\n------------------------------\n------------------------------\n@staticmethod\n    def render_oauth2_redirect() -> bytes:\n        \"\"\"Render an HTML oauth2-redirect.html page for Swagger-UI.\n\n        .. note:: Override this method to customize the template.\n------------------------------\n------------------------------\n\"\"\"\n        if isinstance(channels, str):\n            channels = [channels]\n        data = self.encode_data(data)\n        try:\n            self._pub_queue.put_nowait((data, list(channels)))  # type: ignore[union-attr]\n        except AttributeError as e:\n            raise RuntimeError(\"Plugin not yet initialized. Did you forget to call on_startup?\") from e\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```", "```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```", "```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```"]}, "litestar-litestar/channels/backends/redis.py-stream_events": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nIf no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\n\n        while True:\n            await self._has_subscribed.wait()\n            message = await self._pub_sub.get_message(\n                ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n            )\n            if message is None:\n                continue\n------------------------------\n------------------------------\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        if self._queue is None:\n            raise RuntimeError(\"Backend not yet initialized. Did you forget to call on_startup?\")\n\n        while True:\n            channel, message = await self._queue.get()\n            self._queue.task_done()\n------------------------------\n------------------------------\n@abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        ...\n\n    @abstractmethod\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        ...\n------------------------------\n------------------------------\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\n\n        .. note::\n            This operation is performed atomically, using a lua script\n        \"\"\"\n        await self._publish_script(keys=list(set(channels)), args=[data])\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n------------------------------\n------------------------------\nArgs:\n            redis: A :class:`redis.asyncio.Redis` instance\n            key_prefix: Key prefix to use for storing data in redis\n            stream_sleep_no_subscriptions: Amount of time in milliseconds to pause the\n                :meth:`stream_events` generator, should no subscribers exist\n        \"\"\"\n        self._redis = redis\n        self._key_prefix = key_prefix\n        self._stream_sleep_no_subscriptions = stream_sleep_no_subscriptions\n------------------------------\n------------------------------\nasync def _get_subscribed_channels(self) -> set[str]:\n        \"\"\"Get subscribed channels. If no channels are currently subscribed, wait\"\"\"\n        await self._has_subscribed_channels.wait()\n        return self._subscribed_channels\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    async def flush_all(self) -> int:\n        \"\"\"Delete all stream keys with the ``key_prefix``.\n------------------------------\n------------------------------\nArgs:\n            redis: A :class:`redis.asyncio.Redis` instance\n            key_prefix: Key prefix to use for storing data in redis\n            stream_sleep_no_subscriptions: Amount of time in milliseconds to pause the\n                :meth:`stream_events` generator, should no subscribers exist\n        \"\"\"\n        super().__init__(\n            redis=redis, stream_sleep_no_subscriptions=stream_sleep_no_subscriptions, key_prefix=key_prefix\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n# Natural Language Annotations: \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n    if self._queue is None:\n        raise RuntimeError(\"Backend not yet initialized. Did you forget to call on_startup?\")\n\n    while True:\n        channel, message = await self._queue.get()\n        self._queue.task_done()\n```", "```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n\n    if self._queue is None:\n        raise RuntimeError(\"Backend not yet initialized. Did you forget to call on_startup?\")\n\n    while True:\n        channel, message = await self._queue.get()\n        self._queue.task_done()\n```", "```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n    if self._queue is None:\n        raise RuntimeError(\"Backend not yet initialized. Did you forget to call on_startup?\")\n\n    while True:\n        channel, message = await self._queue.get()\n        self._queue.task_done()\n```"]}, "litestar-litestar/channels/backends/redis.py-get_history": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        history = list(self._history[channel])\n        if limit:\n            history = history[-limit:]\n        return history\n------------------------------\n------------------------------\n@abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        ...\n\n    @abstractmethod\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        ...\n------------------------------\n------------------------------\nclass MemoryChannelsBackend(ChannelsBackend):\n    \"\"\"An in-memory channels backend\"\"\"\n\n    def __init__(self, history: int = 0) -> None:\n        self._max_history_length = history\n        self._channels: set[str] = set()\n        self._queue: Queue[tuple[str, bytes]] | None = None\n        self._history: defaultdict[str, deque[bytes]] = defaultdict(lambda: deque(maxlen=self._max_history_length))\n\n    async def on_startup(self) -> None:\n        self._queue = Queue()\n------------------------------\n------------------------------\nArgs:\n            block: Block until a message is received\n            timeout: If ``block`` is ``True``, block at most ``timeout`` seconds\n\n        Returns:\n            A string value.\n        \"\"\"\n        message = self.receive(block=block, timeout=timeout)\n        return cast(\"bytes\", message.get(\"bytes\", b\"\"))\n------------------------------\n------------------------------\nArgs:\n            block: Block until a message is received\n            timeout: If ``block`` is ``True``, block at most ``timeout`` seconds\n\n        Notes:\n            - you can use one of the other receive methods to extract the data from the message.\n\n        Returns:\n            A websocket message.\n        \"\"\"\n        message = cast(\"WebSocketSendMessage\", self.send_queue.get(block=block, timeout=timeout))\n\n        if isinstance(message, BaseException):\n            raise message\n------------------------------\n------------------------------\nreturn message\n------------------------------\n------------------------------\n@staticmethod\n    def is_undefined_sentinel(value: Any) -> bool:\n        \"\"\"Return ``True`` if ``value`` should be treated as an undefined field\"\"\"\n        return False\n\n    @staticmethod\n    def is_constrained_field(field_definition: FieldDefinition) -> bool:\n        \"\"\"Return ``True`` if the field should be treated as constrained. If returning\n        ``True``, constraints should be defined in the field's extras\n        \"\"\"\n        return False\n------------------------------\n------------------------------\nchannel_subscribers.add(subscriber)\n\n        if channels_to_subscribe:\n            await self._backend.subscribe(channels_to_subscribe)\n\n        if history:\n            await self.put_subscriber_history(subscriber=subscriber, limit=history, channels=channels)\n\n        return subscriber\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n# Natural Language Annotations: \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```"]}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef build_annotation_for_backend(\n    model_type: type[Any], field_definition: FieldDefinition, transfer_model: type[Struct]\n) -> Any:\n    \"\"\"A helper to re-build a generic outer type with new inner type.\n\n    Args:\n        model_type: The original model type.\n        field_definition: The parsed type that represents the handler annotation for which the DTO is being applied.\n        transfer_model: The transfer model generated to represent the model type.\n------------------------------\n------------------------------\nArgs:\n        destination_type: the model type received by the DTO on type narrowing.\n        source_instance: primitive data that has been parsed and validated via the backend.\n        field_definitions: model field definitions.\n        is_data_field: whether the given field is a 'data' kwarg field.\n\n    Returns:\n        Data parsed into ``model_type``.\n    \"\"\"\n    unstructured_data = {}\n------------------------------\n------------------------------\nArgs:\n        destination_type: the model type received by the DTO on type narrowing.\n        source_data: data that has been parsed and validated via the backend.\n        field_definitions: model field definitions.\n        field_definition: the parsed type that represents the handler annotation for which the DTO is being applied.\n        is_data_field: whether the DTO is being applied to a ``data`` field.\n------------------------------\n------------------------------\nclass TransferType:\n    \"\"\"Type for representing model types for data transfer.\"\"\"\n\n    __slots__ = (\"field_definition\",)\n\n    field_definition: FieldDefinition\n------------------------------\n------------------------------\n# generated transfer model type in the type arguments.\n            transfer_model = backend.transfer_model_type\n            generic_args = tuple(transfer_model if a is cls.model_type else a for a in field_definition.args)\n            annotation = field_definition.safe_generic_origin[generic_args]\n        else:\n            annotation = backend.annotation\n------------------------------\n------------------------------\nReturns:\n            The type and config object extracted from the annotation.\n        \"\"\"\n        return next((item for item in field_definition.metadata if isinstance(item, DTOConfig)), None)\n\n    @classmethod\n    def resolve_model_type(cls, field_definition: FieldDefinition) -> FieldDefinition:\n        \"\"\"Resolve the data model type from a parsed type.\n\n        Args:\n            field_definition: A parsed type annotation that represents the annotation used to narrow the DTO type.\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return _transfer_data(\n            destination_type=self.model_type,\n            source_data=builtins,\n            field_definitions=self.parsed_field_definitions,\n            field_definition=self.field_definition,\n            is_data_field=self.is_data_field,\n        )\n------------------------------\n------------------------------\nreturn name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def parse_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Struct | Collection[Struct]:\n        \"\"\"Parse raw bytes into transfer model type.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The raw bytes parsed into transfer model type.\n        \"\"\"\n        request_encoding = RequestEncodingType.JSON\n------------------------------\n------------------------------\ndef _transfer_data(\n    destination_type: type[Any],\n    source_data: Any | Collection[Any],\n    field_definitions: tuple[TransferDTOFieldDefinition, ...],\n    field_definition: FieldDefinition,\n    is_data_field: bool,\n) -> Any:\n    \"\"\"Create instance or iterable of instances of ``destination_type``.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_transfer_model_type(\n# Natural Language Annotations: \"\"\"Create a model for data transfer.\n\n        Args:\n            model_name: name for the type that should be unique across all transfer types.\n            field_definitions: field definitions for the container type.\n\n        Returns:\n            A ``BackendT`` class.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_transfer_model_type(model_name: str, field_definitions: tuple[TransferDTOFieldDefinition, ...]) -> type:\n    \"\"\"Create a model for data transfer.\n\n    Args:\n        model_name: name for the type that should be unique across all transfer types.\n        field_definitions: field definitions for the container type.\n\n    Returns:\n        A ``BackendT`` class.\n    \"\"\"\n    namespace = {field.name: field.annotation for field in field_definitions}\n    return types.new_class(model_name, (TransferType,), {}, lambda ns: ns.update(namespace))\n```", "```python\ndef create_transfer_model_type(model_name: str, field_definitions: tuple[TransferDTOFieldDefinition, ...]) -> type[BackendT]:\n    fields = {f.alias: (f.type_, f.field_info) for f in field_definitions}\n    return type(model_name, (BackendT,), {\"__annotations__\": fields})\n```", "```python\ndef create_transfer_model_type(\n    model_name: str,\n    field_definitions: tuple[TransferDTOFieldDefinition, ...],\n) -> type[Struct]:\n    \"\"\"Create a model for data transfer.\n\n    Args:\n        model_name: name for the type that should be unique across all transfer types.\n        field_definitions: field definitions for the container type.\n\n    Returns:\n        A ``BackendT`` class.\n    \"\"\"\n    fields = {fd.name: fd.type for fd in field_definitions}\n    return type(model_name, (Struct,), {\"__annotations__\": fields})\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n------------------------------\n------------------------------\ndef transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return self._transfer_data_from_builtins(builtins)\n\n    def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse raw bytes into instance of `model_type`.\n------------------------------\n------------------------------\nArgs:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The builtin type parsed into transfer model type.\n        \"\"\"\n        return convert(\n            obj=builtins,\n            type=self.annotation,\n            dec_hook=asgi_connection.route_handler.default_deserializer,\n            strict=False,\n            str_keys=True,\n        )\n------------------------------\n------------------------------\ndef transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n            )\n        return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n------------------------------\n------------------------------\nArgs:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n            )\n        return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n        )\n    return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n```", "```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n        )\n    return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n```", "```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    return convert(\n        obj=builtins,\n        type=self.annotation,\n        dec_hook=asgi_connection.route_handler.default_deserializer,\n        strict=False,\n        str_keys=True,\n    )\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n            )\n        return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n------------------------------\n------------------------------\ndef transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return self._transfer_data_from_builtins(builtins)\n\n    def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse raw bytes into instance of `model_type`.\n------------------------------\n------------------------------\nreturn name\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def parse_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Struct | Collection[Struct]:\n        \"\"\"Parse raw bytes into transfer model type.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The raw bytes parsed into transfer model type.\n        \"\"\"\n        request_encoding = RequestEncodingType.JSON\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return _transfer_data(\n            destination_type=self.model_type,\n            source_data=builtins,\n            field_definitions=self.parsed_field_definitions,\n            field_definition=self.field_definition,\n            is_data_field=self.is_data_field,\n        )\n------------------------------\n------------------------------\nArgs:\n            connection: An :class:`ASGIConnection <litestar.connection.ASGIConnection>` instance.\n\n        Returns:\n            Either a dictionary with the connection's parsed query string or the raw query byte-string.\n        \"\"\"\n        return connection.query_params.dict() if self.parse_query else connection.scope.get(\"query_string\", b\"\")\n------------------------------\n------------------------------\nArgs:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The builtin type parsed into transfer model type.\n        \"\"\"\n        return convert(\n            obj=builtins,\n            type=self.annotation,\n            dec_hook=asgi_connection.route_handler.default_deserializer,\n            strict=False,\n            str_keys=True,\n        )\n------------------------------\n------------------------------\nReturns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n            )\n        return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n```", "```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n```", "```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n        )\n    return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n```"]}, "litestar-litestar/dto/_backend.py-encode_data": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n        \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\n        if self.wrapper_attribute_name:\n            wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n            setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n            return cast(\"LitestarEncodableType\", data)\n------------------------------\n------------------------------\n@staticmethod\n    def deserialize_data(data: Any) -> dict[str, Any]:\n        \"\"\"Deserialize data into a dictionary for use in the application scope.\n\n        Args:\n            data: Data to be deserialized\n\n        Returns:\n            Deserialized data as a dictionary\n        \"\"\"\n        return cast(\"dict[str, Any]\", decode_json(value=data))\n------------------------------\n------------------------------\nArgs:\n            app: The :class:`Litestar <litestar.app.Litestar>` app instance\n            data: Either an instance of a :class:`Response <.response.Response>`,\n                a Response instance or an arbitrary value.\n            request: A :class:`Request <.connection.Request>` instance\n\n        Returns:\n            A Response instance\n        \"\"\"\n        if return_dto_type := self.resolve_return_dto():\n            data = return_dto_type(request).data_to_encodable_type(data)\n------------------------------\n------------------------------\nArgs:\n            data: Data to send.\n            encoding: Encoding to use.\n\n        Returns:\n            None\n        \"\"\"\n        self.send(data=data, mode=\"binary\", encoding=encoding)\n\n    def send_json(self, data: Any, mode: Literal[\"text\", \"binary\"] = \"text\") -> None:\n        \"\"\"Sends the given data as JSON.\n\n        Args:\n            data: The data to send.\n            mode: Either ``text`` or ``binary``\n------------------------------\n------------------------------\nArgs:\n            data: Either a string or a byte string.\n            mode: The key to use - ``text`` or ``bytes``\n            encoding: The encoding to use when encoding or decoding data.\n------------------------------\n------------------------------\nArgs:\n            data: Data to send\n            encoding: Encoding to use for binary data.\n\n        Returns:\n            None\n        \"\"\"\n        await self.send_data(data=data, mode=\"binary\", encoding=encoding)\n\n    async def send_json(\n        self,\n        data: Any,\n        mode: WebSocketMode = \"text\",\n        encoding: str = \"utf-8\",\n        serializer: Serializer = default_serializer,\n    ) -> None:\n        \"\"\"Send data as JSON.\n------------------------------\n------------------------------\n__all__ = (\n    \"LitestarEncodableType\",\n    \"EncodableBuiltinType\",\n    \"EncodableBuiltinCollectionType\",\n    \"EncodableStdLibType\",\n    \"EncodableStdLibIPType\",\n    \"EncodableMsgSpecType\",\n    \"DataContainerType\",\n)\n------------------------------\n------------------------------\ndef send_text(self, data: str, encoding: str = \"utf-8\") -> None:\n        \"\"\"Sends the data using the ``text`` key.\n\n        Args:\n            data: Data to send.\n            encoding: Encoding to use.\n\n        Returns:\n            None\n        \"\"\"\n        self.send(data=data, encoding=encoding)\n\n    def send_bytes(self, data: bytes, encoding: str = \"utf-8\") -> None:\n        \"\"\"Sends the data using the ``bytes`` key.\n------------------------------\n------------------------------\nbackend = self._dto_backends[self.asgi_connection.route_handler.handler_id][\"data_backend\"]  # pyright: ignore\n        return backend.populate_data_from_raw(value, self.asgi_connection)\n\n    def data_to_encodable_type(self, data: T | Collection[T]) -> LitestarEncodableType:\n        backend = self._dto_backends[self.asgi_connection.route_handler.handler_id][\"return_backend\"]  # pyright: ignore\n        return backend.encode_data(data)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def encode_data(self, data: Any) -> LitestarEncodableType:\n# Natural Language Annotations: \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n```", "```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n```", "```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n```"]}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# generated transfer model type in the type arguments.\n            transfer_model = backend.transfer_model_type\n            generic_args = tuple(transfer_model if a is cls.model_type else a for a in field_definition.args)\n            annotation = field_definition.safe_generic_origin[generic_args]\n        else:\n            annotation = backend.annotation\n------------------------------\n------------------------------\ndef build_annotation_for_backend(\n    model_type: type[Any], field_definition: FieldDefinition, transfer_model: type[Struct]\n) -> Any:\n    \"\"\"A helper to re-build a generic outer type with new inner type.\n\n    Args:\n        model_type: The original model type.\n        field_definition: The parsed type that represents the handler annotation for which the DTO is being applied.\n        transfer_model: The transfer model generated to represent the model type.\n------------------------------\n------------------------------\nReturns:\n            The type and config object extracted from the annotation.\n        \"\"\"\n        return next((item for item in field_definition.metadata if isinstance(item, DTOConfig)), None)\n\n    @classmethod\n    def resolve_model_type(cls, field_definition: FieldDefinition) -> FieldDefinition:\n        \"\"\"Resolve the data model type from a parsed type.\n\n        Args:\n            field_definition: A parsed type annotation that represents the annotation used to narrow the DTO type.\n------------------------------\n------------------------------\nReturns:\n        Annotation with new inner type if applicable.\n    \"\"\"\n    if not field_definition.inner_types:\n        if field_definition.is_subclass_of(model_type):\n            return transfer_model\n        return field_definition.annotation\n\n    inner_types = tuple(\n        build_annotation_for_backend(model_type, inner_type, transfer_model)\n        for inner_type in field_definition.inner_types\n    )\n\n    return field_definition.safe_generic_origin[inner_types]\n------------------------------\n------------------------------\nArgs:\n        destination_type: the model type received by the DTO on type narrowing.\n        source_data: data that has been parsed and validated via the backend.\n        field_definitions: model field definitions.\n        field_definition: the parsed type that represents the handler annotation for which the DTO is being applied.\n        is_data_field: whether the DTO is being applied to a ``data`` field.\n------------------------------\n------------------------------\nfield_type = _create_transfer_model_type_annotation(field_definition.transfer_type)\n        if field_definition.is_partial:\n            field_type = Union[field_type, UnsetType]\n\n        if (field_meta := _create_struct_field_meta_for_field_definition(field_definition)) is not None:\n            field_type = Annotated[field_type, field_meta]\n------------------------------\n------------------------------\nArgs:\n            destination_type: the model type received by the DTO on type narrowing.\n            field_definition: the parsed type that represents the handler annotation for which the DTO is being applied.\n\n        Returns:\n            Data parsed into ``destination_type``.\n        \"\"\"\n------------------------------\n------------------------------\ndef _create_transfer_model_mapping_type(transfer_type: MappingType) -> Any:\n    key_type = _create_transfer_model_type_annotation(transfer_type.key_type)\n    value_type = _create_transfer_model_type_annotation(transfer_type.value_type)\n    return transfer_type.field_definition.safe_generic_origin[key_type, value_type]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n# Natural Language Annotations: \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if isinstance(transfer_type, ScalarType):\n        return transfer_type.field_definition.annotation\n    elif isinstance(transfer_type, SequenceType):\n        item_type = _create_transfer_model_type_annotation(transfer_type.item_type)\n        return transfer_type.field_definition.safe_generic_origin[item_type]\n    elif isinstance(transfer_type, MappingType):\n        key_type = _create_transfer_model_type_annotation(transfer_type.key_type)\n        value_type = _create_transfer_model_type_annotation(transfer_type.value_type)\n        return transfer_type.field_definition.safe_generic_origin[key_type, value_type]\n    elif isinstance(transfer_type, ModelType):\n        if transfer_type.field_definition.is_subclass_of(transfer_type.model_type):\n            return transfer_type.transfer_model\n        else:\n            return transfer_type.field_definition.annotation\n    else:\n        raise TypeError(f\"Unsupported transfer type: {transfer_type}\")\n```", "```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if isinstance(transfer_type, UnionType):\n        return Union[\n            _create_transfer_model_type_annotation(inner_type) for inner_type in transfer_type.inner_types\n        ]\n    elif isinstance(transfer_type, TupleType):\n        return Tuple[\n            _create_transfer_model_type_annotation(inner_type) for inner_type in transfer_type.inner_types\n        ]\n    elif isinstance(transfer_type, MappingType):\n        key_type = _create_transfer_model_type_annotation(transfer_type.key_type)\n        value_type = _create_transfer_model_type_annotation(transfer_type.value_type)\n        return transfer_type.field_definition.safe_generic_origin[key_type, value_type]\n    elif isinstance(transfer_type, ListType):\n        return List[_create_transfer_model_type_annotation(transfer_type.inner_type)]\n    elif isinstance(transfer_type, OptionalType):\n        return Optional[_create_transfer_model_type_annotation(transfer_type.inner_type)]\n    elif isinstance(transfer_type, PrimitiveType):\n        return transfer_type.annotation\n    else:\n        return transfer_type.annotation\n```", "```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    if isinstance(transfer_type, SimpleType):\n        return transfer_type.field_definition.safe_generic_origin\n    elif isinstance(transfer_type, MappingType):\n        return _create_transfer_model_mapping_type(transfer_type)\n    elif isinstance(transfer_type, SequenceType):\n        return _create_transfer_model_sequence_type(transfer_type)\n    elif isinstance(transfer_type, OptionalType):\n        return _create_transfer_model_optional_type(transfer_type)\n    elif isinstance(transfer_type, UnionType):\n        return _create_transfer_model_union_type(transfer_type)\n    elif isinstance(transfer_type, ModelType):\n        return _create_transfer_model_model_type(transfer_type)\n    else:\n        raise ValueError(f\"Unsupported transfer type: {transfer_type}\")\n```"]}, "litestar-litestar/response/file.py-start_response": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            None\n        \"\"\"\n        if self.background is not None:\n            await self.background()\n\n    async def start_response(self, send: Send) -> None:\n        \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n------------------------------\n------------------------------\nReturns:\n            None\n        \"\"\"\n        event: HTTPResponseStartEvent = {\n            \"type\": \"http.response.start\",\n            \"status\": self.status_code,\n            \"headers\": self.encode_headers(),\n        }\n        await send(event)\n\n    async def send_body(self, send: Send, receive: Receive) -> None:\n        \"\"\"Emit the response body.\n\n        Args:\n            send: The ASGI send function.\n            receive: The ASGI receive function.\n------------------------------\n------------------------------\nArgs:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n------------------------------\n------------------------------\nasync def send_body(self, send: Send, receive: Receive) -> None:\n        \"\"\"Emit a stream of events correlating with the response body.\n\n        Args:\n            send: The ASGI send function.\n            receive: The ASGI receive function.\n\n        Returns:\n            None\n        \"\"\"\n------------------------------\n------------------------------\nvalidate_node(node=self.root_route_map_node)\n        if self._mount_routes:\n            self._mount_paths_regex = re.compile(\"|\".join(sorted(set(self._mount_routes))))  # pyright: ignore\n\n    async def lifespan(self, receive: LifeSpanReceive, send: LifeSpanSend) -> None:\n        \"\"\"Handle the ASGI \"lifespan\" event on application startup and shutdown.\n\n        Args:\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n------------------------------\n------------------------------\nArgs:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        await self.start_response(send=send)\n\n        if self.is_head_response:\n            event: HTTPResponseBodyEvent = {\"type\": \"http.response.body\", \"body\": b\"\", \"more_body\": False}\n            await send(event)\n        else:\n            await self.send_body(send=send, receive=receive)\n------------------------------\n------------------------------\nasync def _stream(self, send: Send) -> None:\n        \"\"\"Send the chunks from the iterator as a stream of ASGI 'http.response.body' events.\n\n        Args:\n            send: The ASGI Send function.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def start_response(self, send: Send) -> None:\n# Natural Language Annotations: \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```"]}, "litestar-litestar/connection/request.py-json": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def msgpack(self) -> Any:\n        \"\"\"Retrieve the MessagePack request body from the request.\n------------------------------\n------------------------------\nrequest_body: RequestBody | Reference | None = None\n    \"\"\"The request body applicable for this operation.\n------------------------------\n------------------------------\nReturns:\n            An arbitrary value\n        \"\"\"\n        if self._msgpack is Empty:\n            if (msgpack := self._connection_state.msgpack) is not Empty:\n                self._msgpack = msgpack\n            else:\n                body = await self.body()\n                self._msgpack = self._connection_state.msgpack = decode_msgpack(\n                    body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n                )\n        return self._msgpack\n------------------------------\n------------------------------\ndef __call__(self, connection: ASGIConnection[Any, Any, Any, Any]) -> ExtractedRequestData:\n        \"\"\"Extract data from the connection, returning a dictionary of values.\n\n        Notes:\n            - The value for ``body`` - if present - is an unresolved Coroutine and as such should be awaited by the receiver.\n\n        Args:\n            connection: An ASGI connection or its subclasses.\n------------------------------\n------------------------------\nasync def form(self) -> FormMultiDict:\n        \"\"\"Retrieve form data from the request. If the request is either a 'multipart/form-data' or an\n        'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the\n        request, otherwise, an empty instance.\n------------------------------\n------------------------------\nReturns:\n        The Body value.\n    \"\"\"\n    values[\"body\"] = connection.body()\n------------------------------\n------------------------------\ndescription: str | None = None\n    \"\"\"A brief description of the request body. This could contain examples of use.\n\n    `CommonMark syntax <https://spec.commonmark.org/>`_ MAY be used for rich text representation.\n    \"\"\"\n\n    required: bool = False\n    \"\"\"Determines if the request body is required in the request.\n\n    Defaults to ``False``.\n    \"\"\"\n------------------------------\n------------------------------\nReturns:\n            Either the parsed request body or the raw byte-string.\n        \"\"\"\n        if request.method == HttpMethod.GET:\n            return None\n        if not self.parse_body:\n            return await request.body()\n        try:\n            request_encoding_type = request.content_type[0]\n            if request_encoding_type == RequestEncodingType.JSON:\n                return await request.json()\n            form_data = await request.form()\n------------------------------\n------------------------------\nReturns:\n            A byte-string representing the body of the request.\n        \"\"\"\n        if self._body is Empty:\n            if (body := self._connection_state.body) is not Empty:\n                self._body = body\n            else:\n                self._body = self._connection_state.body = b\"\".join([c async for c in self.stream()])\n        return self._body\n------------------------------\n------------------------------\nasync def extract_body(self, request: Request[Any, Any, Any]) -> Any:\n        \"\"\"Extract the body from an ``ASGIConnection``\n\n        Args:\n            request: A :class:`Request <litestar.connection.Request>` instance.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def json(self) -> Any:\n# Natural Language Annotations: \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if self._json is Empty:\n        if (json := self._connection_state.json) is not Empty:\n            self._json = json\n        else:\n            body = await self.body()\n            self._json = self._connection_state.json = decode_json(\n                body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n            )\n    return self._json\n```", "```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if self._json is Empty:\n        if (json := self._connection_state.json) is not Empty:\n            self._json = json\n        else:\n            body = await self.body()\n            self._json = self._connection_state.json = decode_json(\n                body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n            )\n    return self._json\n```", "```python\nasync def json(self) -> Any:\n    if self._json is Empty:\n        if (json := self._connection_state.json) is not Empty:\n            self._json = json\n        else:\n            body = await self.body()\n            self._json = self._connection_state.json = decode_json(\n                body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n            )\n    return self._json\n```"]}, "litestar-litestar/datastructures/multi_dicts.py-close": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            Boolean dictating whether all origins are allowed.\n        \"\"\"\n        return \"*\" in self.allow_origins\n\n    @cached_property\n    def is_allow_all_methods(self) -> bool:\n        \"\"\"Get a cached boolean flag dictating whether all methods are allowed.\n\n        Returns:\n            Boolean dictating whether all methods are allowed.\n        \"\"\"\n        return \"*\" in self.allow_methods\n------------------------------\n------------------------------\nReturns:\n            A :class:`MultiDict <.datastructures.multi_dicts.MultiDict>` with query parameters\n------------------------------\n------------------------------\nArgs:\n            buffer: A bytes IO buffer to write the compressed data into.\n            compression_encoding: The compression encoding used.\n            config: The app compression config.\n        \"\"\"\n        ...\n\n    def write(self, body: bytes) -> None:\n        \"\"\"Write compressed bytes.\n\n        Args:\n            body: Message body to process\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n    def close(self) -> None:\n        \"\"\"Close the compression stream.\n------------------------------\n------------------------------\nReturns:\n        A dictionary of parsed results.\n    \"\"\"\n\n    fields: defaultdict[str, list[Any]] = defaultdict(list)\n\n    for form_part in parse_body(body=body, boundary=boundary, multipart_form_part_limit=multipart_form_part_limit):\n        file_name = None\n        content_type = \"text/plain\"\n        content_charset = \"utf-8\"\n        field_name = None\n        line_index = 2\n        line_end_index = 0\n        headers: list[tuple[str, str]] = []\n------------------------------\n------------------------------\nNote that the path cannot contain path parameters.\n    \"\"\"\n    directories: list[PathType]\n    \"\"\"A list of directories to serve files from.\"\"\"\n    html_mode: bool = False\n    \"\"\"Flag dictating whether serving html.\n\n    If true, the default file will be 'index.html'.\n    \"\"\"\n    name: str | None = None\n    \"\"\"An optional string identifying the static files handler.\"\"\"\n    file_system: Any = BaseLocalFileSystem()  # noqa: RUF009\n    \"\"\"The file_system spec to use for serving files.\n------------------------------\n------------------------------\ndef to_dict(self) -> dict[str, Any]:\n        \"\"\"Normalize access to the signature model's dictionary method, because different backends use different methods\n        for this.\n\n        Returns: A dictionary of string keyed values.\n        \"\"\"\n        return asdict(self)\n------------------------------\n------------------------------\ndef get_template(self, template_name: str) -> MakoTemplate:\n        \"\"\"Retrieve a template by matching its name (dotted path) with files in the directory or directories provided.\n\n        Args:\n            template_name: A dotted path\n\n        Returns:\n            MakoTemplate instance\n------------------------------\n------------------------------\n)\n        return MultiDict(self._parsed_query)\n------------------------------\n------------------------------\ndef get_template(self, template_name: str) -> JinjaTemplate:\n        \"\"\"Retrieve a template by matching its name (dotted path) with files in the directory or directories provided.\n\n        Args:\n            template_name: A dotted path\n\n        Returns:\n            JinjaTemplate instance\n------------------------------\n------------------------------\nArgs:\n            args: Mapping-like structure to create the ``MultiDict`` from\n        \"\"\"\n        super().__init__(args or {})\n\n    def immutable(self) -> ImmutableMultiDict[T]:\n        \"\"\"Create an.\n\n        :class:`ImmutableMultiDict` view.\n\n        Returns:\n            An immutable multi dict\n        \"\"\"\n        return ImmutableMultiDict[T](self)  # pyright: ignore\n\n    def copy(self) -> Self:\n        \"\"\"Return a shallow copy\"\"\"\n        return type(self)(list(self.multi_items()))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def close(self) -> None:\n# Natural Language Annotations: \"\"\"Close all files in the multi-dict.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\"\"\"\n    for key, value in self._files.items():\n        if isinstance(value, StarletteUploadFile):\n            await value.close()\n        elif isinstance(value, list):\n            for file in value:\n                await file.close()\n```", "```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\"\"\"\n    return None\n```", "```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\"\"\"\n    for key in self.keys():\n        for value in self.getlist(key):\n            if isinstance(value, AsyncFile) and not value.closed:\n                await value.close()\n        self[key] = [self.multiple_files_to_file(v) for v in self.getlist(key)]\n```"]}, "litestar-litestar/datastructures/url.py-from_scope": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass MutableScopeHeaders(MutableMapping):\n    \"\"\"A case-insensitive, multidict-like structure that can be used to mutate headers within a\n    :class:`Scope <.types.Scope>`\n    \"\"\"\n\n    def __init__(self, scope: Optional[\"HeaderScope\"] = None) -> None:\n        \"\"\"Initialize ``MutableScopeHeaders`` from a ``HeaderScope``.\n------------------------------\n------------------------------\nReturns:\n            A URL instance constructed from the request's scope.\n        \"\"\"\n        if self._url is Empty:\n            if (url := self._connection_state.url) is not Empty:\n                self._url = url\n            else:\n                self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n        return self._url\n\n    @property\n    def base_url(self) -> URL:\n        \"\"\"Return the base URL of this connection's ``Scope``.\n------------------------------\n------------------------------\ndef make_absolute_url(path: str | URL, base: str | URL) -> str:\n    \"\"\"Create an absolute URL.\n\n    Args:\n        path: URL path to make absolute\n        base: URL to use as a base\n\n    Returns:\n        A string representing the new, absolute URL\n    \"\"\"\n    url = base if isinstance(base, URL) else URL(base)\n    netloc = url.netloc\n    path = url.path.rstrip(\"/\") + str(path)\n    return str(URL.from_components(scheme=url.scheme, netloc=netloc, path=path))\n------------------------------\n------------------------------\nReturns:\n            A URL instance constructed from the request's scope, representing only the base part\n            (host + domain + prefix) of the request.\n        \"\"\"\n        if self._base_url is Empty:\n            if (base_url := self._connection_state.base_url) is not Empty:\n                self._base_url = base_url\n            else:\n                scope = cast(\n                    \"Scope\",\n                    {\n                        **self.scope,\n------------------------------\n------------------------------\nArgs:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n        \"\"\"\n        self.scope = scope\n        self.receive = receive\n        self.send = send\n        self._connection_state = ScopeState.from_scope(scope)\n        self._base_url: URL | EmptyType = Empty\n        self._url: URL | EmptyType = Empty\n        self._parsed_query: tuple[tuple[str, str], ...] | EmptyType = Empty\n------------------------------\n------------------------------\n@classmethod\n    def from_scope(cls, scope: Scope) -> Self:\n        \"\"\"Create a new `ConnectionState` object from a scope.\n\n        Object is cached in the scope's state under the `SCOPE_STATE_NAMESPACE` key.\n\n        Args:\n            scope: The ASGI connection scope.\n------------------------------\n------------------------------\nReturns:\n            A new URL with the given components\n        \"\"\"\n        return cls(\n            SplitResult(\n                scheme=scheme,\n                netloc=netloc,\n                path=path,\n                fragment=fragment,\n                query=query,\n            )\n        )\n\n    @classmethod\n------------------------------\n------------------------------\nArgs:\n            request:\n                A :class:`Request <.connection.Request>` instance.\n\n        Returns:\n            A rendered html string.\n        \"\"\"\n        schema = self.get_schema_from_request(request)\n------------------------------\n------------------------------\nArgs:\n            scheme: URL scheme\n            netloc: Network location\n            path: Hierarchical path\n            query: Raw query string\n            fragment: Fragment identifier\n\n        Returns:\n            A new URL with the given components replaced\n        \"\"\"\n        if isinstance(query, MultiDict):\n            query = urlencode(query=query)\n\n        query = (query if query is not Empty else self.query) or \"\"\n------------------------------\n------------------------------\n@property\n    def state(self) -> StateT:\n        \"\"\"Return the ``State`` of this connection.\n\n        Returns:\n            A State instance constructed from the scope[\"state\"] value.\n        \"\"\"\n        return cast(\"StateT\", State(self.scope.get(\"state\")))\n\n    @property\n    def url(self) -> URL:\n        \"\"\"Return the URL of this connection's ``Scope``.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_scope(cls, scope: Scope) -> Self:\n# Natural Language Annotations: \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n        Args:\n            scope: A scope\n\n        Returns:\n            A URL\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    if self._url is Empty:\n        if (url := self._connection_state.url) is not Empty:\n            self._url = url\n        else:\n            self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n    return self._url\n```", "```python\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    if self._url is Empty:\n        if (url := self._connection_state.url) is not Empty:\n            self._url = url\n        else:\n            self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n    return self._url\n```", "```python\n@classmethod\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    if self._url is Empty:\n        if (url := self._connection_state.url) is not Empty:\n            self._url = url\n        else:\n            self._connection_state.url = self._url = URL.from_scope(self.scope)\n\n    return self._url\n```"]}, "litestar-litestar/datastructures/headers.py-to_header": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            headers: A dictionary of headers, the cookie header will be added to it.\n            cookies: A string representing the cookie header or a list of \"Cookie\" instances.\n                This value can include multiple cookies.\n        \"\"\"\n        if not cookies:\n            return\n------------------------------\n------------------------------\ndef _get_header_value(self) -> str:\n        \"\"\"Get the header value as string.\"\"\"\n\n        cc_items = [\n            key.replace(\"_\", \"-\") if isinstance(value, bool) else f\"{key.replace('_', '-')}={value}\"\n            for key, value in simple_asdict(self, exclude_none=True, exclude={\"documentation_only\"}).items()\n        ]\n        return \", \".join(cc_items)\n------------------------------\n------------------------------\n@classmethod\n    def from_header(cls, header_value: str) -> \"CacheControlHeader\":\n        \"\"\"Create a ``CacheControlHeader`` instance from the header value.\n\n        Args:\n            header_value: the header value as string\n\n        Returns:\n            An instance of ``CacheControlHeader``\n        \"\"\"\n------------------------------\n------------------------------\ndef getall(self, key: str, default: Optional[List[str]] = None) -> List[str]:\n        \"\"\"Get all values of a header.\n\n        Args:\n            key: Header key.\n            default: Default value to return if ``name`` is not found.\n\n        Returns:\n            A list of strings.\n------------------------------\n------------------------------\nThis value is added by ``event-header`` extension of HTMX to the ``Triggering-Event`` header to requests.\n        \"\"\"\n        if value := self._get_header_value(HTMXHeaders.TRIGGERING_EVENT):\n            with suppress(SerializationException):\n                return decode_json(value=value, type_decoders=self.request.route_handler.resolve_type_decoders())\n        return None\n------------------------------\n------------------------------\nReturns:\n        A string keyed dictionary of normalized values\n    \"\"\"\n    return {\n        header.name: cast(\"str\", header.value)  # we know value to be a string at this point because we validate it\n        # that it's not None when initializing a header with documentation_only=True\n        for header in headers\n        if not header.documentation_only\n    }\n------------------------------\n------------------------------\nclass MyController(Controller):\n    etag = ETag(value=\"foo\")\n\n    @get(\"/chance_of_rain\")\n    def get_chance_of_rain(self) -> float:\n        \"\"\"This endpoint uses the etag value in the controller which overrides the app value.\n\n        The returned header will be `etag: \"foo\"`\n        \"\"\"\n        return 0.5\n\n    @get(\"/timestamp\", etag=ETag(value=\"bar\"))\n    def get_server_time(self) -> float:\n        \"\"\"This endpoint overrides the etag defined in the controller.\n------------------------------\n------------------------------\ndef set_header(self, key: str, value: Any) -> None:\n        \"\"\"Set a header on the response.\n\n        Args:\n            key: Header key.\n            value: Header value.\n\n        Returns:\n            None.\n        \"\"\"\n        self.headers[key] = value\n\n    def set_etag(self, etag: str | ETag) -> None:\n        \"\"\"Set an etag header.\n\n        Args:\n            etag: An etag value.\n------------------------------\n------------------------------\nReturns:\n            None\n        \"\"\"\n        existing = self.get(key)\n        if existing is not None:\n            value = \",\".join([*existing.split(\",\"), value])\n        self[key] = value\n\n    def __getitem__(self, key: str) -> str:\n        \"\"\"Get the first header matching ``name``\"\"\"\n        name = key.lower()\n        for header in self.headers:\n            if header[0].decode(\"latin-1\").lower() == name:\n                return header[1].decode(\"latin-1\")\n        raise KeyError\n------------------------------\n------------------------------\nclass Header(ABC):\n    \"\"\"An abstract type for HTTP headers.\"\"\"\n\n    HEADER_NAME: ClassVar[str] = \"\"\n\n    documentation_only: bool = False\n    \"\"\"Defines the header instance as for OpenAPI documentation purpose only.\"\"\"\n\n    @abstractmethod\n    def _get_header_value(self) -> str:\n        \"\"\"Get the header value as string.\"\"\"\n        raise NotImplementedError\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_header(self, include_header_name: bool = False) -> str:\n# Natural Language Annotations: \"\"\"Get the header as string.\n\n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    if not include_header_name:\n        return self._get_header_value()\n    else:\n        return f\"{self.HEADER_NAME}: {self._get_header_value()}\"\n```", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    if include_header_name:\n        return f\"{self.HEADER_NAME}: {self._get_header_value()}\"\n    else:\n        return self._get_header_value()\n```", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    if include_header_name:\n        return f\"{self.HEADER_NAME}: {self._get_header_value()}\"\n    return self._get_header_value()\n```"]}, "litestar-litestar/middleware/session/server_side.py-delete": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            config: A subclass of ``ServerSideSessionConfig``\n        \"\"\"\n        super().__init__(config=config)\n\n    async def get(self, session_id: str, store: Store) -> bytes | None:\n        \"\"\"Retrieve data associated with ``session_id``.\n\n        Args:\n            session_id: The session-ID\n            store: Store to retrieve the session data from\n------------------------------\n------------------------------\nIf there is already data associated with ``session_id``, replace\n        it with ``data`` and reset its expiry time\n\n        Args:\n            session_id: The session-ID\n            data: Serialized session data\n            store: Store to save the session data in\n\n        Returns:\n            None\n        \"\"\"\n        expires_in = int(self.config.max_age) if self.config.max_age is not None else None\n        await store.set(session_id, data, expires_in=expires_in)\n------------------------------\n------------------------------\nThe session-ID will be gathered from a cookie with the key set in\n        :attr:`BaseBackendConfig.key`. If a cookie is found, its value will be used as the session-ID and data associated\n        with this ID will be loaded using :meth:`get <ServerSideSessionBackend.get>`.\n        If no cookie was found or no data was loaded from the store, this will return an\n        empty dictionary.\n\n        Args:\n            connection: An ASGIConnection instance\n------------------------------\n------------------------------\ndef delete_session_handler(request: Request) -> None:\n    \"\"\"Handler to clear the session.\"\"\"\n    if request.session:\n        request.clear_session()\n------------------------------\n------------------------------\nIf the session is empty, a null-cookie will be set. Otherwise, the serialised\n        data will be stored using :meth:`set <ServerSideSessionBackend.set>`, under the current session-id. If no session-ID\n        exists, a new ID will be generated using :meth:`generate_session_id <ServerSideSessionBackend.generate_session_id>`.\n------------------------------\n------------------------------\nReturns:\n            The session data, if existing, otherwise ``None``.\n        \"\"\"\n        max_age = int(self.config.max_age) if self.config.max_age is not None else None\n        return await store.get(session_id, renew_for=max_age if self.config.renew_on_access else None)\n\n    async def set(self, session_id: str, data: bytes, store: Store) -> None:\n        \"\"\"Store ``data`` under the ``session_id`` for later retrieval.\n------------------------------\n------------------------------\nIf no such key exists, this is a no-op.\n\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        async with self._lock:\n            self._store.pop(key, None)\n\n    async def delete_all(self) -> None:\n        \"\"\"Delete all stored values.\"\"\"\n        async with self._lock:\n            self._store.clear()\n\n    async def delete_expired(self) -> None:\n        \"\"\"Delete expired items.\n------------------------------\n------------------------------\ndef get_session_id(self, connection: ASGIConnection) -> str:\n        \"\"\"Try to fetch session id from the connection. If one does not exist, generate one.\n\n        If a session ID already exists in the cookies, it is returned.\n        If there is no ID in the cookies but one in the connection state, then the session exists but has not yet\n        been returned to the user.\n        Otherwise, a new session must be created.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def delete(self, session_id: str, store: Store) -> None:\n# Natural Language Annotations: \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n        Args:\n            session_id: The session-ID\n            store: Store to delete the session data from\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    await store.delete(session_id)\n```", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        await store.delete(session_id)\n    except KeyError:\n        pass\n```", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        await store.delete(session_id)\n    except KeyError:\n        pass\n```"]}, "marimo-marimo/_islands/island_generator.py-add_code": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n*Args:*\n\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n        - str: The HTML code.\n        \"\"\"\n------------------------------\n------------------------------\n*Args:*\n\n        - filename (str): Marimo .py filename to convert to reactive HTML.\n        - display_code (bool): Whether to display the code in HTML snippets.\n        \"\"\"\n        path = MarimoPath(filename)\n        file_router = AppFileRouter.from_filename(path)\n        file_key = file_router.get_unique_file_key()\n        assert file_key is not None\n        file_manager = file_router.get_file_manager(file_key)\n------------------------------\n------------------------------\n- str: The HTML code.\n        \"\"\"\n\n        is_reactive = (\n            is_reactive if is_reactive is not None else self._is_reactive\n        )\n        display_code = (\n            display_code if display_code is not None else self._display_code\n        )\n        display_output = (\n            display_output\n            if display_output is not None\n            else self._display_output\n        )\n------------------------------\n------------------------------\n- `value`: initial value of the code editor\n    - `language`: language of the code editor, defaults to `\"python\"`; most\n        major languages are supported, including \"sql\", \"javascript\",\n        \"typescript\", \"html\", \"css\", \"c\", \"cpp\", \"rust\", and more\n    - `placeholder`: placeholder text to display when the code editor is empty\n    - `theme`: theme of the code editor, defaults to the editor's default\n    - `disabled`: whether the input is disabled\n------------------------------\n------------------------------\ndef render(\n        self,\n        display_code: Optional[bool] = None,\n        display_output: Optional[bool] = None,\n        is_reactive: Optional[bool] = None,\n    ) -> str:\n        \"\"\"\n        Render the HTML island code for the cell.\n        Note: This will override construction defaults.\n\n        *Args:*\n------------------------------\n------------------------------\nclass MarimoIslandGenerator:\n    \"\"\"\n    Generates Marimo islands for embedding in other pages.\n\n    This is a great way to use another SSG framework that converts\n    Python code to HTML using marimo-islands.\n\n    Generally you will want to:\n\n    1. Find all the code snippets and add them to the generator.\n    2. Build the app.\n    3. Replace all code snippets with the rendered HTML.\n    4. Include the header in the <head> tag.\n\n    # Example\n------------------------------\n------------------------------\n@app.cell\n# Code for: def __(w_reactive):\n\n\n@app.cell\n# Code for: def __():\n\n\n@app.cell\n# Code for: def __(mo):\n\n\n@app.cell(hide_code=True)\n# Code for: def __(alt, dd_widget, mo, pd):\n\n\nif __name__ == \"__main__\":\n    app.run()\n------------------------------\n------------------------------\n**Args.**\n\n    - `value`: the value to display\n    - `label`: the label to display\n    - `caption`: the caption to display\n    - `direction`: the direction of the statistic,\n        either `increase` or `decrease`\n    - `bordered`: whether to display a border around the statistic\n\n    **Returns.**\n------------------------------\n------------------------------\nself._unparsable = False\n        self._initialized = False\n\n        self._app_kernel_runner: AppKernelRunner | None = None\n\n    def cell(\n        self,\n        func: Callable[..., Any] | None = None,\n        *,\n        disabled: bool = False,\n        hide_code: bool = False,\n        **kwargs: Any,\n    ) -> Cell | Callable[[Callable[..., Any]], Cell]:\n        \"\"\"A decorator to add a cell to the app\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_code(\n# Natural Language Annotations: \"\"\"Add a code cell to the app.\n\n        *Args:*\n\n        - code (str): The code to add to the app.\n        - display_code (bool): Whether to display the code in the HTML.\n        - display_output (bool): Whether to display the output in the HTML.\n        - is_raw (bool): Whether to handled the code without formatting.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_code(\n    code: str,\n    display_code: bool = True,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = False,\n):\n    \"\"\"Add a code cell to the app.\n\n    *Args:*\n\n    - code (str): The code to add to the app.\n    - display_code (bool): Whether to display the code in the HTML.\n    - display_output (bool): Whether to display the output in the HTML.\n    - is_raw (bool): Whether to handled the code without formatting.\n    - is_reactive (bool): Whether this code block will run with pyodide.\n    \"\"\"\n    # Your code here\n```", "```python\ndef add_code(\n    code: str,\n    display_code: bool = True,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = False\n):\n    # Your code here\n    pass\n```", "```python\ndef add_code(\n        code: str,\n        display_code: bool = True,\n        display_output: bool = True,\n        is_raw: bool = False,\n        is_reactive: bool = False,\n    ) -> None:\n    \"\"\"Add a code cell to the app.\"\"\"\n\n    # Logic to add the code cell to the app\n```"]}, "marimo-marimo/_islands/island_generator.py-build": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass MarimoIslandGenerator:\n    \"\"\"\n    Generates Marimo islands for embedding in other pages.\n\n    This is a great way to use another SSG framework that converts\n    Python code to HTML using marimo-islands.\n\n    Generally you will want to:\n\n    1. Find all the code snippets and add them to the generator.\n    2. Build the app.\n    3. Replace all code snippets with the rendered HTML.\n    4. Include the header in the <head> tag.\n\n    # Example\n------------------------------\n------------------------------\ndef _register(func: Callable[..., Any]) -> Cell:\n            cell = cell_factory(func, cell_id=self.create_cell_id())\n            cell._cell.configure(cell_config)\n            self._register_cell(cell, app=app)\n            return cell\n------------------------------\n------------------------------\ndef render_head(\n        self,\n        *,\n        version_override: str = __version__,\n        _development_url: Union[str | bool] = False,\n    ) -> str:\n        \"\"\"\n        Render the header for the app.\n        This should be included in the <head> tag of the page.\n\n        *Args:*\n------------------------------\n------------------------------\nself._unparsable = False\n        self._initialized = False\n\n        self._app_kernel_runner: AppKernelRunner | None = None\n\n    def cell(\n        self,\n        func: Callable[..., Any] | None = None,\n        *,\n        disabled: bool = False,\n        hide_code: bool = False,\n        **kwargs: Any,\n    ) -> Cell | Callable[[Callable[..., Any]], Cell]:\n        \"\"\"A decorator to add a cell to the app\n------------------------------\n------------------------------\n*Args:*\n\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n        - str: The HTML code.\n        \"\"\"\n------------------------------\n------------------------------\n{as_html(list(self.refs))}\n\n            **Definitions:**\n\n            {as_html(list(self.defs))}\n            \"\"\"\n        )\n\n    def _register_app(self, app: InternalApp) -> None:\n        self._app = app\n\n    def run(\n        self, **refs: Any\n    ) -> (\n        tuple[Any, Mapping[str, Any]]\n        | Awaitable[tuple[Any, Mapping[str, Any]]]\n    ):\n        \"\"\"Run this cell and return its visual output and definitions\n------------------------------\n------------------------------\nreturn init_island\n\n    def render_body(\n        self,\n        *,\n        include_init_island: bool = True,\n        max_width: Optional[str] = None,\n        margin: Optional[str] = None,\n        style: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Render the body for the app.\n        This should be included in the <body> tag of the page.\n------------------------------\n------------------------------\n@app.cell\n# Code for: def __(mo):\n\n\n@app.cell\n# Code for: def __(mo):\n\n\n@app.cell\n# Code for: def __(dict, mo):\n\n\nif __name__ == \"__main__\":\n    app.run()\n------------------------------\n------------------------------\n- `element`: the element to wrap\n    - `bordered`: whether the form should have a border\n    - `loading`: whether the form should be in a loading state\n    - `submit_button_label`: the label of the submit button\n    - `submit_button_tooltip`: the tooltip of the submit button\n    - `submit_button_disabled`: whether the submit button should be disabled\n    - `clear_on_submit`: whether the form should clear its contents after\n        submitting\n------------------------------\n------------------------------\n@app.cell\n# Code for: def __(mo, solved):\n\n\n@app.cell\n# Code for: def __():\n\n\n@app.cell\n# Code for: def __():\n\n\nif __name__ == \"__main__\":\n    app.run()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def build(self) -> App:\n# Natural Language Annotations: \"\"\"\n        Build the app. This should be called after adding all the code cells.\n\n        *Returns:*\n\n        - App: The built app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def build(self) -> App:\n    self._app.run()\n    self._app._initialized = True\n    self._app._unparsable = False\n    return self._app\n```", "```python\nasync def build(self) -> App:\n    self._build_app()\n    return self._app\n```", "```python\nasync def build(self) -> App:\n    def _register(func: Callable[..., Any]) -> Cell:\n        cell = cell_factory(func, cell_id=self.create_cell_id())\n        cell._cell.configure(cell_config)\n        self._register_cell(cell, app=app)\n        return cell\n\n    def render_head(\n        self,\n        *,\n        version_override: str = __version__,\n        _development_url: Union[str | bool] = False,\n    ) -> str:\n        self._unparsable = False\n        self._initialized = False\n        self._app_kernel_runner: AppKernelRunner | None = None\n        return f\"<head>{as_html(list(self.refs))}{as_html(list(self.defs))}</head>\"\n\n    def _register_app(self, app: InternalApp) -> None:\n        self._app = app\n\n    def run(\n        self, **refs: Any\n    ) -> (\n        tuple[Any, Mapping[str, Any]]\n        | Awaitable[tuple[Any, Mapping[str, Any]]]\n    ):\n        return init_island\n\n    def render_body(\n        self,\n        *,\n        include_init_island: bool = True,\n        max_width: Optional[str] = None,\n        margin: Optional[str] = None,\n        style: Optional[str] = None,\n    ) -> str:\n        return f\"<body>{include_init_island}{max_width}{margin}{style}</body>\"\n\n    return App(self._app)\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __():\n    from dataclasses import dataclass\n    return dataclass,\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom dataclasses import dataclass\nfrom typing import TYPE_CHECKING, Any, Iterator, Optional\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\n\"\"\"Specification of a code completion result\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\n# Code for: class CompletionOption:\n------------------------------\n------------------------------\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n------------------------------\n------------------------------\n# Opinionated or known types\n            if isinstance(obj, pd.DataFrame):\n                return obj.to_dict(\"records\")\n            elif isinstance(obj, pd.Series):\n                return obj.to_list()\n            elif isinstance(obj, pd.Categorical):\n                return obj.tolist()\n            elif isinstance(obj, pd.CategoricalDtype):\n                return str(obj)\n            elif isinstance(obj, pd.Timestamp):\n                return str(obj)\n------------------------------\n------------------------------\n@staticmethod\n    def is_type(value: Any) -> bool:\n        return isinstance(value, (list, tuple, dict))\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    return cls(**values)\n```", "```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    return cls(**values)\n```", "```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    return cls(**values)\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def handle_message(self, request: ControlRequest) -> None:\n        \"\"\"Handle a message from the client.\n\n        The message is dispatched to the appropriate method based on its type.\n------------------------------\n------------------------------\nprocessed_classes: Dict[Any, str] = {\n        JSONType: \"JSONType\",\n    }\n    component_schemas: Dict[str, Any] = {\n        # Hand-written schema to avoid circular dependencies\n        \"JSONType\": {\n            \"oneOf\": [\n                {\"type\": \"string\"},\n                {\"type\": \"number\"},\n                {\"type\": \"object\"},\n                {\"type\": \"array\"},\n                {\"type\": \"boolean\"},\n                {\"type\": \"null\"},\n            ]\n        }\n    }\n------------------------------\n------------------------------\nThis is an abstract class. `UIElement`s are responsible for mapping values\n    sent by the frontend (of type S) to values expected by the Python object\n    (of type T): a subclass can be made concrete by implementing the\n    `_convert_value` method.\n\n    Type Parameters:\n\n    - S: The type of the values sent by the frontend to the kernel; must be\n         JSON-serializable\n    - T: The type of the UIElement's value; can be any type\n\n    **Attributes.**\n------------------------------\n------------------------------\ndef convert_dataclass(\n        self,\n        cls: Type[Any],\n        processed_classes: Dict[Any, str],\n    ) -> Dict[str, Any]:\n        \"\"\"Convert a dataclass to an OpenAPI schema.\n\n        Args:\n            cls (Type[Any]): The dataclass to convert.\n\n        Raises:\n            ValueError: If cls is not a dataclass.\n------------------------------\n------------------------------\n# S: Type of frontend value\n#   - the initial value sent to the frontend must be of type S\n#   - values received from the frontend must be of type S\nS = TypeVar(\"S\", bound=JSONType)\n\n# T: Type of `UIElement.value`\n#   - UIElement's `_convert_value` method is used to convert a frontend\n#   value (of type S) to a value of type T\nT = TypeVar(\"T\")\n\nLOGGER = _loggers.marimo_logger()\n\n\n@dataclass\n# Code for: class Lens:\n\n\n# Code for: class MarimoConvertValueException(Exception):\n------------------------------\n------------------------------\nasync def parse_request(request: Request, cls: Type[T]) -> T:\n    \"\"\"Parse the request body as a dataclass of type `cls`\"\"\"\n    return parse_raw(await request.body(), cls=cls)\n------------------------------\n------------------------------\ndef send_message(\n        self, message: JSONType, buffers: Optional[Sequence[bytes]]\n    ) -> None:\n        \"\"\"\n        Send a message to the element rendered on the frontend\n        from the backend.\n        \"\"\"\n\n        from marimo._messaging.ops import SendUIElementMessage\n------------------------------\n------------------------------\ndef serialize(datacls: Any) -> Dict[str, JSONType]:\n    try:\n        # Try to serialize as a dataclass\n        return cast(\n            Dict[str, JSONType],\n            asdict(datacls),\n        )\n    except Exception:\n        # If that fails, try to serialize using the WebComponentEncoder\n        return cast(\n            Dict[str, JSONType],\n            json.loads(json.dumps(datacls, cls=WebComponentEncoder)),\n        )\n------------------------------\n------------------------------\ndef save_layout_config(\n    directory: str, app_name: str, config: LayoutConfig\n) -> str:\n    \"\"\"\n    Save the layout configuration to disk\n    at the given directory.\n\n    The layout is saved as a JSON file under\n        <directory>/layouts/<app_name>.{type}.json\n    This allows:\n        - all layouts to be saved in the same directory\n        - multiple layouts to be saved for the same app\n        - multiple apps can live in the same directory\n\n    Returns: the path to the layout file\n    \"\"\"\n------------------------------\n------------------------------\n# Frontend type is a tuple (index, value update)\n# Python type is a sequence of values, one for each UI element\n@mddoc\n# Code for: class array(UIElement[Dict[str, JSONType], Sequence[object]]):\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nfrom typing import Union, TypeVar, Type, Any, Dict\nimport json\nfrom dataclasses import asdict\nfrom humps import decamelize\n\nT = TypeVar(\"T\")\n\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[T]) -> T:\n    # Convert bytes to string\n    if isinstance(message, bytes):\n        message = message.decode()\n\n    # Load the message as JSON\n    parsed_message = json.loads(message)\n\n    # Transform all fields in the parsed JSON from camel case to snake case\n    parsed_message = {decamelize(key): value for key, value in parsed_message.items()}\n\n    # Instantiate the type and return\n    return cls(**parsed_message)\n```", "```python\nfrom typing import Union, Type, Any\nimport json\nimport re\nfrom dataclasses import is_dataclass\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    if isinstance(message, bytes):\n        message = json.loads(message.decode('utf-8'))\n    if is_dataclass(cls):\n        message = {re.sub(r'(?<=[a-z])(?=[A-Z])', '_', k).lower(): v for k, v in message.items()}\n        return cls(**message)\n    else:\n        raise ValueError(f\"cls must be a dataclass, not {cls}\")\n```", "```python\nimport re\nimport json\nfrom typing import Union, Type, Any, TypeVar, get_args, get_origin\n\nT = TypeVar(\"T\")\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    def snake_case(s: str) -> str:\n        return re.sub(r'(?<=[a-z])(?=[A-Z])', '_', s).lower()\n\n    def cast_value(value: Any, type_arg: Type[Any]) -> Any:\n        if isinstance(value, list):\n            return [cast_value(v, get_args(type_arg)[0]) for v in value]\n        elif isinstance(value, dict):\n            return {snake_case(k): cast_value(v, get_args(type_arg)[1]) for k, v in value.items()}\n        elif get_origin(type_arg) is Union:\n            return cast_value(value, get_args(type_arg)[0])  # Assuming only one Union branch\n        else:\n            return value\n\n    data = json.loads(message) if isinstance(message, bytes) else message\n    return cls(**{snake_case(k): cast_value(v, get_args(cls.__init__.__annotations__[k])[0]) for k, v in data.items()})\n```"]}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n- `start`: the minimum value of the interval\n    - `stop`: the maximum value of the interval\n    - `step`: the slider increment\n    - `value`: default value\n    - `debounce`: whether to debounce the slider to only send\n        the value on mouse-up or drag-end\n    - `orientation`: the orientation of the slider,\n        either \"horizontal\" or \"vertical\"\n    - `show_value`: whether to display the current value of the slider\n------------------------------\n------------------------------\n**Args.**\n\n    - `value`: the value to display\n    - `label`: the label to display\n    - `caption`: the caption to display\n    - `direction`: the direction of the statistic,\n        either `increase` or `decrease`\n    - `bordered`: whether to display a border around the statistic\n\n    **Returns.**\n------------------------------\n------------------------------\ndef style(item: object, styles: dict[str, Any]) -> Html:\n    \"\"\"Wrap an object in a styled container.\n\n    **Example.**\n\n    ```python\n    mo.style(item, styles={\"max-height\": \"300px\", \"overflow\": \"auto\"})\n    ```\n\n    **Args.**\n\n    - `item`: an object to render as HTML\n    - `styles`: a dict of CSS styles, keyed by property name\n    \"\"\"\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in styles.items()])\n    return Html(h.div(children=as_html(item).text, style=style_str))\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: the URL of the video or a file-like object\n    - `controls`: whether to show the controls\n    - `muted`: whether to mute the video\n    - `autoplay`: whether to autoplay the video.\n        the video will only autoplay if `muted` is `True`\n    - `loop`: whether to loop the video\n    - `width`: the width of the video\n    - `height`: the height of the video\n    - `rounded`: whether to round the corners of the video\n\n    **Returns.**\n------------------------------\n------------------------------\ndef __(mo):\n    mo.hstack(\n        [\n            mo.md(\"Icon sets\"),\n            mo.icon(\"lucide:leaf\", size=20),\n            mo.icon(\"material-symbols:rocket-launch\", size=20),\n            mo.icon(\"ic:twotone-rocket-launch\", size=20),\n        ],\n        justify=\"start\",\n    )\n    return\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: the URL of the pdf or a file-like object\n    - `initial_page`: the page to open the pdf to.\n        only works if `src` is a URL\n    - `width`: the width of the pdf\n    - `height`: the height of the pdf. for a percentage\n        of the user's viewport, use a string like `\"50vh\"`\n    - `style`: a dictionary of CSS styles to apply to the pdf\n\n    **Returns.**\n------------------------------\n------------------------------\ndef __(mo):\n    mo.hstack(\n        [\n            mo.md(\"Flip\"),\n            mo.icon(\"lucide:leaf\", size=20),\n            mo.icon(\"lucide:leaf\", size=20, flip=\"vertical\"),\n            mo.icon(\"lucide:leaf\", size=20, flip=\"horizontal\"),\n            mo.icon(\"lucide:leaf\", size=20, flip=\"vertical,horizontal\"),\n        ],\n        justify=\"start\",\n    )\n    return\n------------------------------\n------------------------------\n**Examples.**\n\n    ```python\n    nav_menu = mo.nav_menu(\n        {\n            \"/overview\": \"Overview\",\n            \"/sales\": f\"{mo.icon('lucide:shopping-cart')} Sales\",\n            \"/products\": f\"{mo.icon('lucide:package')} Products\",\n        }\n    )\n    ```\n------------------------------\n------------------------------\ndef interactive(figure: \"Figure | Axes\") -> Html:  # type: ignore[name-defined] # noqa:F821,E501\n    \"\"\"Render a matplotlib figure using an interactive viewer.\n\n    The interactive viewer allows you to pan, zoom, and see plot coordinates\n    on mouse hover.\n\n    **Example**:\n\n    ```python\n    plt.plot([1, 2])\n    # plt.gcf() gets the current figure\n    mo.mpl.interactive(plt.gcf())\n    ```\n\n    **Args**:\n\n    - figure: a matplotlib `Figure` or `Axes` object\n\n    **Returns**:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def icon(\n# Natural Language Annotations: \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef icon(\n    icon_name: str,\n    size: Optional[int] = None,\n    color: Optional[str] = None,\n    inline: bool = False,\n    flip: Optional[str] = None,\n    rotate: Optional[int] = None,\n    style: Optional[Dict[str, Any]] = None,\n) -> Html:\n    style_dict = style or {}\n    if size is not None:\n        style_dict[\"font-size\"] = f\"{size}px\"\n    if color is not None:\n        style_dict[\"color\"] = color\n    if inline:\n        style_dict[\"display\"] = \"inline-block\"\n    if flip is not None:\n        flips = flip.split(\",\")\n        if \"horizontal\" in flips:\n            style_dict[\"-moz-transform\"] = \"scaleX(-1)\"\n            style_dict[\"-webkit-transform\"] = \"scaleX(-1)\"\n            style_dict[\"transform\"] = \"scaleX(-1)\"\n        if \"vertical\" in flips:\n            style_dict[\"-moz-transform\"] = \"scaleY(-1)\"\n            style_dict[\"-webkit-transform\"] = \"scaleY(-1)\"\n            style_dict[\"transform\"] = \"scaleY(-1)\"\n    if rotate is not None:\n        style_dict[\"-ms-transform\"] = f\"rotate({rotate}deg)\"\n        style_dict[\"-moz-transform\"] = f\"rotate({rotate}deg)\"\n        style_dict[\"-webkit-transform\"] = f\"rotate({rotate}deg)\"\n        style_dict[\"-o-transform\"] = f\"rotate({rotate}deg)\"\n        style_dict[\"transform\"] = f\"rotate({rotate}deg)\"\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in style_dict.items()])\n    return Html(h.span(style=style_str, children=[icon_name]))\n```", "```python\ndef style(item: object, styles: dict[str, Any]) -> Html:\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in styles.items()])\n    return Html(h.div(children=as_html(item).text, style=style_str))\n\ndef icon(\n    icon_name: str,\n    size: int = 20,\n    color: str = \"currentColor\",\n    inline: bool = False,\n    flip: str = None,\n    rotate: int = 0,\n    style: dict[str, str] = None,\n) -> Html:\n    icon_style = {\n        \"font-size\": f\"{size}px\",\n        \"color\": color,\n        \"display\": \"inline-block\" if inline else \"block\",\n        \"transform\": f\"rotate({rotate}deg)\",\n    }\n    if flip:\n        if \"horizontal\" in flip:\n            icon_style[\"transform\"] += \" scaleX(-1)\"\n        if \"vertical\" in flip:\n            icon_style[\"transform\"] += \" scaleY(-1)\"\n    if style:\n        icon_style.update(style)\n    icon_style_str = \";\".join([f\"{key}:{value}\" for key, value in icon_style.items()])\n    return Html(\n        h.div(\n            children=h.iconify(icon_name),\n            style=icon_style_str,\n        )\n    )\n```", "```python\ndef icon(\n    icon_name: str,\n    size: int = 24,\n    color: str = \"inherit\",\n    inline: bool = False,\n    flip: str = \"\",\n    rotate: int = 0,\n    style: dict[str, Any] = {},\n) -> Html:\n    icon_set, icon_name = icon_name.split(\":\")\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in style.items()])\n    style_str += f\";font-size: {size}px; color: {color};\"\n    if flip:\n        style_str += f\";transform: scaleX({'-1' if 'horizontal' in flip else '1'}); scaleY({'-1' if 'vertical' in flip else '1'});\"\n    if rotate:\n        style_str += f\";transform: rotate({rotate}deg);\"\n    style_str += f\";display: {'inline' if inline else 'block'};\"\n    return Html(\n        f'<span style=\"{style_str}\">'\n        f'<span class=\"iconify\" data-icon=\"{icon_set}:{icon_name}\"></span>'\n        \"</span>\"\n    )\n```"]}, "marimo-marimo/_plugins/stateless/image.py-image": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef audio(\n    src: Union[str, io.BytesIO],\n) -> Html:\n    \"\"\"Render an audio file as HTML.\n\n    **Example.**\n\n    ```python3\n    mo.audio(\n        src=\"https://upload.wikimedia.org/wikipedia/commons/8/8c/Ivan_Ili%C4%87-Chopin_-_Prelude_no._1_in_C_major.ogg\"\n    )\n\n    mo.audio(src=\"path/to/local/file.wav\")\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an audio file, bytes,\n        or a file-like object opened in binary mode\n\n    **Returns.**\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: the URL of the pdf or a file-like object\n    - `initial_page`: the page to open the pdf to.\n        only works if `src` is a URL\n    - `width`: the width of the pdf\n    - `height`: the height of the pdf. for a percentage\n        of the user's viewport, use a string like `\"50vh\"`\n    - `style`: a dictionary of CSS styles to apply to the pdf\n\n    **Returns.**\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: the URL of the video or a file-like object\n    - `controls`: whether to show the controls\n    - `muted`: whether to mute the video\n    - `autoplay`: whether to autoplay the video.\n        the video will only autoplay if `muted` is `True`\n    - `loop`: whether to loop the video\n    - `width`: the width of the video\n    - `height`: the height of the video\n    - `rounded`: whether to round the corners of the video\n\n    **Returns.**\n------------------------------\n------------------------------\ndef style(item: object, styles: dict[str, Any]) -> Html:\n    \"\"\"Wrap an object in a styled container.\n\n    **Example.**\n\n    ```python\n    mo.style(item, styles={\"max-height\": \"300px\", \"overflow\": \"auto\"})\n    ```\n\n    **Args.**\n\n    - `item`: an object to render as HTML\n    - `styles`: a dict of CSS styles, keyed by property name\n    \"\"\"\n    style_str = \";\".join([f\"{key}:{value}\" for key, value in styles.items()])\n    return Html(h.div(children=as_html(item).text, style=style_str))\n------------------------------\n------------------------------\n**Example.**\n\n        ```python\n        mo.md(\"...\").style({\"max-height\": \"300px\", \"overflow\": \"auto\"})\n        ```\n\n        **Args.**\n\n        - `styles`: a dict of CSS styles, keyed by property name\n        \"\"\"\n        from marimo._plugins.stateless import style as _style\n\n        return _style.style(self, style)\n------------------------------\n------------------------------\n# Verify that this is a image object\n    if not isinstance(src, (str, bytes, io.BytesIO, io.BufferedReader)):\n        raise ValueError(\n            f\"Expected an image object, but got {type(src)} instead.\"\n        )\n    return src\n------------------------------\n------------------------------\n*Args:*\n\n        - filename (str): Marimo .py filename to convert to reactive HTML.\n        - display_code (bool): Whether to display the code in HTML snippets.\n        \"\"\"\n        path = MarimoPath(filename)\n        file_router = AppFileRouter.from_filename(path)\n        file_key = file_router.get_unique_file_key()\n        assert file_key is not None\n        file_manager = file_router.get_file_manager(file_key)\n------------------------------\n------------------------------\n**Args.**\n\n    - `routes`: a dictionary of routes, where the key is the URL path\n      and the value is a function that returns the content to display.\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n\n    _name: Final[str] = \"marimo-routes\"\n\n    CATCH_ALL = \"/(.*)\"\n    DEFAULT = \"/\"\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: An image-like object. This can be a list, array, tensor, or a\n        file-like object.\n\n    **Returns.**\n\n    A BytesIO object or other Image type.\n\n    **Raises.**\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def image(\n# Natural Language Annotations: \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef image(\n    src: Union[str, io.BytesIO, np.ndarray, List],\n    alt: str = \"\",\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, str]] = None,\n) -> Html:\n    # Verify that this is a image object\n    if not isinstance(src, (str, bytes, io.BytesIO, io.BufferedReader, np.ndarray, List)):\n        raise ValueError(\n            f\"Expected an image object, but got {type(src)} instead.\"\n        )\n    # Create HTML attributes\n    attributes = {\"src\": src, \"alt\": alt}\n    if width is not None:\n        attributes[\"width\"] = width\n    if height is not None:\n        attributes[\"height\"] = height\n    if rounded:\n        attributes[\"style\"] = \"border-radius: 50%;\"\n    if style is not None:\n        attributes[\"style\"] = \";\".join([f\"{key}:{value}\" for key, value in style.items()])\n    return Html(h.img(attributes))\n```", "```python\ndef image(\n    src: Union[str, bytes, io.BytesIO, io.BufferedReader, ArrayLike],\n    alt: Optional[str] = None,\n    width: Optional[Union[str, int]] = None,\n    height: Optional[Union[str, int]] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, Any]] = None,\n) -> Html:\n    if not isinstance(src, (str, bytes, io.BytesIO, io.BufferedReader, ArrayLike)):\n        raise ValueError(\n            f\"Expected an image object, but got {type(src)} instead.\"\n        )\n    image_html = h.img(src=src, alt=alt, width=width, height=height, style=style)\n    if rounded:\n        image_html.style[\"border-radius\"] = \"50%\"\n    return Html(image_html)\n```", "```python\ndef image(\n    src: Union[str, bytes, io.BytesIO, np.ndarray, io.BufferedReader],\n    alt: str = \"\",\n    width: Optional[Union[str, int]] = None,\n    height: Optional[Union[str, int]] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, str]] = None,\n) -> Html:\n    # Verify that this is a image object\n    if not isinstance(src, (str, bytes, io.BytesIO, np.ndarray, io.BufferedReader)):\n        raise ValueError(\n            f\"Expected an image object, but got {type(src)} instead.\"\n        )\n\n    # Convert the image object to BytesIO if needed\n    if isinstance(src, (str, bytes, io.BytesIO)):\n        src = src if isinstance(src, BytesIO) else open(src, \"rb\") if isinstance(src, str) else BytesIO(src)\n    elif isinstance(src, np.ndarray):\n        src = BytesIO()\n        PIL.Image.fromarray(src).save(src, format=\"PNG\")\n        src.seek(0)\n\n    # Create the img tag\n    img = h.img(src=\"data:image/jpeg;base64,\" + base64.b64encode(src.getvalue()).decode(), alt=alt)\n\n    # Add width and height attributes if provided\n    if width:\n        img.attrs[\"width\"] = str(width)\n    if height:\n        img.attrs[\"height\"] = str(height)\n\n    # Add rounded border if specified\n    if rounded:\n        img.attrs[\"style\"] = \"border-radius: 50%;\"\n\n    # Add additional style if specified\n    if style:\n        img.attrs[\"style\"] = \"; \".join([f\"{k}: {v}\" for k, v in style.items()])\n\n    return Html(img)\n```"]}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n**Args.**\n\n    - `items`: A list of items.\n    - `align`: Align items horizontally: start, end, center, or stretch.\n    - `justify`: Justify items vertically: start, center, end,\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `heights`: \"equal\" to give items equal height;\n        or a list of relative heights with same length as `items`,\n        eg, [1, 2] means the second item is twice as tall\n        as the first; or `None` for a sensible default\n------------------------------\n------------------------------\n**Example.**\n\n    ```python3\n    # Build a column of items\n    mo.vstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.vstack(\n        [\n            mo.hstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.hstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n------------------------------\n------------------------------\ndef vstack(\n    items: Sequence[object],\n    *,\n    align: Optional[Literal[\"start\", \"end\", \"center\", \"stretch\"]] = None,\n    justify: Literal[\n        \"start\", \"center\", \"end\", \"space-between\", \"space-around\"\n    ] = \"start\",\n    gap: float = 0.5,\n    heights: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items vertically, in a column.\n\n    Combine with `hstack` to build a grid of items.\n\n    **Example.**\n------------------------------\n------------------------------\ndef carousel(\n    items: Sequence[object],\n) -> Html:\n    \"\"\"Create a carousel of items.\n\n    **Example.**\n\n    ```python3\n    mo.carousel([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    item_content = \"\".join(\n        [\n            (md(item).text if isinstance(item, str) else as_html(item).text)\n            for item in items\n        ]\n    )\n------------------------------\n------------------------------\ndef _spaced(\n    items: Sequence[object],\n    justify: Literal[\"left\", \"right\", \"center\", \"normal\"] = \"center\",\n    items_per_row: Optional[int] = None,\n    column_gap: float = 1,\n    row_gap: float = 1,\n) -> Html:\n    \"\"\"Space items evenly in row-major order.\n\n    A grid built with this function has a fixed number of items per row.\n    For more flexibility, use `hstack` and `vstack`.\n\n    **Args.**\n------------------------------\n------------------------------\n**Args.**\n\n    - `items`: Items to arrange\n    - `justify`: Justify items normally, left, right, or center.\n    - `items_per_row`: Number of items to place in each row\n    - `column_gap`: Minimum gap in rem between columns\n    - `row_gap`: Minimum gap in rem between rows\n\n    **Returns.**\n------------------------------\n------------------------------\nwhere `expensive_item` is the item to render, or a callable that\n    returns the item to render.\n\n    **Args.**\n\n    - `items`: a dictionary of item names to item content; strings are\n      interpreted as markdown\n    - `multiple`: whether to allow multiple items to be open simultaneously\n    - `lazy`: a boolean, whether to lazily load the accordion content.\n              This is a convenience that wraps each accordion in a `mo.lazy`\n              component.\n\n    **Returns.**\n------------------------------\n------------------------------\nstacks = mo.vstack(\n        [\n            mo.hstack([justify, align, gap], justify=\"center\"),\n            horizontal,\n            mo.md(\"-----------------------------\"),\n            vertical,\n        ],\n        align=\"stretch\",\n        gap=1,\n    )\n\n    create_wrapper(\n        stacks,\n        \"stacks\",\n    )\n    return horizontal, stacks, vertical\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def hstack(\n# Natural Language Annotations: \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python3\ndef hstack(\n    items: Sequence[object],\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Optional[Literal[\"start\", \"end\", \"center\", \"stretch\"]] = None,\n    wrap: bool = False,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n```", "```python3\ndef hstack(\n    items: Sequence[object],\n    *,\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Optional[Literal[\"start\", \"end\", \"center\", \"stretch\"]] = None,\n    wrap: bool = False,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    item_content = \"\".join(\n        [\n            (md(item).text if isinstance(item, str) else as_html(item).text)\n            for item in items\n        ]\n    )\n    return Html(f'<div style=\"display: flex; justify-content: {justify}; align-items: {align}; flex-wrap: {\"wrap\" if wrap else \"nowrap\"}; gap: {gap}rem; width: {widths}\">{item_content}</div>')\n```", "```python3\ndef hstack(\n    items: Sequence[object],\n    *,\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Optional[Literal[\"start\", \"end\", \"center\", \"stretch\"]] = None,\n    wrap: bool = False,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    # The function body would depend on the specific implementation details of the Html object and its creation.\n```"]}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass progress_bar:\n    \"\"\"Iterate over a collection and show a progress bar\n\n    **Example.**\n\n    ```python\n    for i in mo.status.progress_bar(range(10)):\n        ...\n    ```\n\n    You can optionally provide a title and subtitle to show\n    during iteration, and a title/subtitle to show upon completion.\n\n    You can also use progress_bar with a context manager and manually update\n    the bar:\n------------------------------\n------------------------------\n**Args.**\n\n    - `collection`: optional collection to iterate over\n    - `title`: optional title\n    - `subtitle`: optional subtitle\n    - `completion_title`: optional title to show during completion\n    - `completion_subtitle`: optional subtitle to show during completion\n    - `total`: optional total number of items to iterate over\n    - `show_rate`: if True, show the rate of progress (items per second)\n    - `show_eta`: if True, show the estimated time of completion\n    \"\"\"\n------------------------------\n------------------------------\n```python\n    with mo.status.progress_bar(total=10) as bar:\n        for i in range(10):\n            ...\n            bar.update()\n    ```\n\n    The `update` method accepts the optional keyword\n    arguments `increment` (defaults to `1`), `title`,\n    and `subtitle`.\n\n    For performance reasons, the progress bar is only updated in the UI\n    every 150ms.\n\n    **Args.**\n------------------------------\n------------------------------\ndef update(\n        self,\n        increment: int = 1,\n        title: str | None = None,\n        subtitle: str | None = None,\n    ) -> None:\n        super().update_progress(\n            increment=increment, title=title, subtitle=subtitle\n        )\n------------------------------\n------------------------------\n```python\n    mo.status.spinner(title=\"Loading ...\") if condition else mo.md(\"Done!\")\n    ```\n\n    **Args:**\n\n    - `title`: optional title\n    - `subtitle`: optional subtitle\n    - `remove_on_exit`: if True, the spinner is removed from output on exit\n    \"\"\"\n------------------------------\n------------------------------\n**Example.**\n\n        ```python\n        mo.md(\"...\").style({\"max-height\": \"300px\", \"overflow\": \"auto\"})\n        ```\n\n        **Args.**\n\n        - `styles`: a dict of CSS styles, keyed by property name\n        \"\"\"\n        from marimo._plugins.stateless import style as _style\n\n        return _style.style(self, style)\n------------------------------\n------------------------------\ndef _finish(self) -> None:\n        self.progress.update(\n            increment=0,\n            title=self.completion_title,\n            subtitle=self.completion_subtitle,\n        )\n        self.progress.close()\n------------------------------\n------------------------------\n**Args.**\n\n    - `value`: the value to display\n    - `label`: the label to display\n    - `caption`: the caption to display\n    - `direction`: the direction of the statistic,\n        either `increase` or `decrease`\n    - `bordered`: whether to display a border around the statistic\n\n    **Returns.**\n------------------------------\n------------------------------\nclass Spinner(_Progress):\n    \"\"\"A spinner output representing a loading state\"\"\"\n\n    def __init__(self, title: str | None, subtitle: str | None) -> None:\n        super().__init__(\n            title=title,\n            subtitle=subtitle,\n            total=None,\n            show_rate=False,\n            show_eta=False,\n        )\n\n    def update(\n        self, title: str | None = None, subtitle: str | None = None\n    ) -> None:\n        \"\"\"Update the title and subtitle of the spinner\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def update_progress(\n# Natural Language Annotations: \"\"\"Update the progress indicator.\n\n        **Example.**\n\n        ```python\n        # Increment by 1\n        progress.update()\n\n        # Increment by 10 and update title and subtitle\n        progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n        ```\n\n        **Args.**\n\n        - increment: amount to increment by. Defaults to 1.\n        - title: new title. Defaults to None.\n        - subtitle: new subtitle. Defaults to None.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef update_progress(self, increment: int = 1, title: str | None = None, subtitle: str | None = None) -> None:\n    \"\"\"Update the progress indicator.\"\"\"\n\n    # Increment by 1\n    self.update()\n\n    # Increment by 10 and update title and subtitle\n    self.update(10, title=\"Loading\", subtitle=\"Still going...\")\n```", "```python\ndef update_progress(\n    self,\n    increment: int = 1,\n    title: str | None = None,\n    subtitle: str | None = None,\n) -> None:\n    \"\"\"Update the progress indicator.\"\"\"\n    super().update_progress(\n        increment=increment, title=title, subtitle=subtitle\n    )\n```", "```python\ndef update_progress(\n    self,\n    increment: int = 1,\n    title: str | None = None,\n    subtitle: str | None = None,\n) -> None:\n    \"\"\"Update the progress indicator.\n\n    **Example.**\n\n    ```python\n    # Increment by 1\n    progress.update()\n\n    # Increment by 10 and update title and subtitle\n    progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    **Args.**\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    super().update_progress(\n        increment=increment, title=title, subtitle=subtitle\n    )\n```"]}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef build_stateless_plugin(\n    component_name: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a stateless plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n------------------------------\n------------------------------\nReturns:\n    -------\n    HTML text for the component\n    \"\"\"\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    return (\n        f\"<{component_name} {' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n------------------------------\n------------------------------\ndef __init__(\n        self,\n        html: Html,\n        elements: dict[str, UIElement[JSONType, object]],\n        label: str = \"\",\n        on_change: Optional[Callable[[Dict[str, object]], None]] = None,\n    ) -> None:\n        self._elements = elements\n        super().__init__(\n            component_name=_batch_base._name,\n            initial_value={\n                key: e._initial_value_frontend\n                for key, e in self._elements.items()\n            },\n            label=label,\n------------------------------\n------------------------------\nArgs:\n        ----\n        component_name: tag name of the custom element\n        initial_value: initial value of the element in the frontend\n        label: markdown string, label of element\n        on_change: callback, called with element's new value on change\n        args: arguments that the element takes\n        slotted_html: any html to slot in the custom element\n        functions: any functions to register with the graph\n        \"\"\"\n        # Validate parameters from a user\n------------------------------\n------------------------------\ndef __init__(\n        self,\n        elements: Sequence[UIElement[Any, Any]],\n        *,\n        label: str = \"\",\n        on_change: Optional[Callable[[Sequence[object]], None]] = None,\n    ) -> None:\n        self._elements = [e._clone() for e in elements]\n        self._label = label\n        slotted_html = json_output(\n            json_data=format_structure(self._elements),\n            name=\"array\" if not label else label,\n        )\n        super().__init__(\n------------------------------\n------------------------------\ndef parse_initial_value(text: str) -> JSONType:\n    \"\"\"Get initial value from HTML for a UI element.\"\"\"\n    match = re.search(\"data-initial-value='(.*?)'\", text)\n    if match is None:\n        raise ValueError(\"Invalid component HTML: \", text)\n    return cast(JSONType, json.loads(unescape(match.groups()[0])))\n------------------------------\n------------------------------\n_value_frontend: S\n    _value: T\n\n    def __init__(\n        self,\n        component_name: str,\n        initial_value: S,\n        label: Optional[str],\n        on_change: Optional[Callable[[T], None]],\n        args: dict[str, JSONType],\n        slotted_html: str = \"\",\n        functions: tuple[Function[Any, Any], ...] = (),\n    ) -> None:\n        \"\"\"Initialize a UIElement\n------------------------------\n------------------------------\nYou just detected some change points. Every time the non-noise\n                    component jumps is a change point. (If the component doesn't\n                    look piecewise-constant, you may need to adjust the weights.)\n------------------------------\n------------------------------\ndef _initialize(\n        self,\n        component_name: str,\n        initial_value: S,\n        label: Optional[str],\n        on_change: Optional[Callable[[T], None]],\n        args: dict[str, JSONType],\n        slotted_html: str,\n        functions: tuple[Function[Any, Any], ...] = (),\n    ) -> None:\n        \"\"\"Initialize the UIElement\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_ui_plugin(\n# Natural Language Annotations: \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["Sure, here is the function based on the given signature and annotations:\n\n```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str = \"\",\n    args: dict[str, JSONType] = {},\n    slotted_html: str = \"\",\n) -> str:\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    return (\n        f\"<{component_name} {' '.join(attrs)} data-initial-value='{escape(json.dumps(initial_value))}'>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n```", "```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\"\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    return (\n        f\"<{component_name} data-initial-value='{escape(json.dumps(initial_value))}' \"\n        f\"{' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n```", "```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str = \"\",\n    args: dict[str, JSONType] = {},\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    return (\n        f\"<{component_name} data-initial-value='{escape(json.dumps(initial_value))}' label='{escape(label)}' {' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n```"]}, "marimo-marimo/_output/formatting.py-as_html": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass Html(MIME):\n    \"\"\"A wrapper around HTML text that can be used as an output.\n\n    Output an `Html` object as the last expression of a cell to render it in\n    your app.\n\n    Use f-strings to embed Html objects as text into other HTML or markdown\n    strings. For example:\n\n    ```python3\n    hello_world = Html(\"<h2>Hello, World</h2>\")\n    Html(\n        f'''\n        <h1>Hello, Universe!</h1>\n        {hello_world}\n        '''\n    )\n    ```\n\n    **Attributes.**\n\n    - `text`: a string of HTML\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## Interpolating Python values\n\n        You can interpolate Python values into markdown using\n        `f-strings` and marimo's ` as_html` function. This lets you create \n        markdown whose contents depend on data that changes at runtime.\n\n        Here are some examples.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n                apps. This function compiles your Markdown into HTML that marimo\n                can display.\n                '''\n            )\n            ```\n            \\\"\\\"\\\"\n        )\n        \"\"\"\n        ),\n        generator.add_code(\n            \"\"\"\n        mo.md(\n            r\\\"\\\"\\\"\n            ## LaTeX\n            You can embed LaTeX in Markdown.\n\n            For example,\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n            apps. This function compiles Markdown into HTML that marimo\n            can display.\n\n            For example, here's the code that rendered the above title and\n            paragraph:\n\n            ```python3\n            mo.md(\n                '''\n                # Hello, Markdown!\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n            apps. This function compiles your Markdown into HTML that marimo\n            can display.\n            '''\n        )\n        ```\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nif apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n\n\n@mddoc\n------------------------------\n------------------------------\n**Args.**\n\n    - `src`: An image-like object. This can be a list, array, tensor, or a\n        file-like object.\n\n    **Returns.**\n\n    A BytesIO object or other Image type.\n\n    **Raises.**\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        **Explanation.** By lifting Markdown into Python, marimo lets you construct\n        dynamic Markdown parametrized by arbitrary Python elements. marimo knows\n        how to render its own elements, and you can use `mo.as_html` to render other\n        objects, like plots.\n\n        _Tip: toggle a markdown view via `Cmd/Ctrl-Shift-M` in an empty cell._\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\n**Args.**\n\n    - `tabs`: a dictionary of tab names to tab content; strings are interpreted\n    as markdown\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return tabs_impl(tabs)\n------------------------------\n------------------------------\nUse `mo.as_html` to convert objects to HTML. This function\n        generates rich HTML for many Python types, including:\n\n        - lists, dicts, and tuples,\n        - `pandas` dataframes and series,\n        - `seaborn` figures,\n        - `plotly` figures, and\n        - `altair` figures.\n\n        For example, here's a pandas dataframe:\n\n        {mo.as_html(make_dataframe())}\n        \"\"\"\n    )\n    return make_dataframe,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def as_html(value: object) -> Html:\n# Natural Language Annotations: \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown.\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\"\"\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \"\"\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    html_text = _convert_to_html(value)\n    if apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n```", "Here is the function based on the given function signature and annotations:\n\n```python\ndef as_html(value: object) -> Html:\n    \"\"\"\n    Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    Args:\n    - value: An object\n\n    Returns:\n    - An `Html` object\n    \"\"\"\n    # Your code here\n```", "```python\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    if apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n```"]}, "marimo-marimo/_output/md.py-md": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __(mo):\n    mo.md(\n        r\"\"\"\n        ## LaTeX\n        You can embed LaTeX in Markdown.\n\n        For example,\n\n        ```python3\n        mo.md(r'$f : \\mathbf{R} \\to \\mathbf{R}$')\n        ```\n\n        renders $f : \\mathbf{R} \\to \\mathbf{R}$, while\n\n        ```python3\n        mo.md(\n            r'''\n            \\[\n            f: \\mathbf{R} \\to \\mathbf{R}\n            \\]\n            '''\n        )\n        ```\n\n        renders the display math\n------------------------------\n------------------------------\ndef __(create_wrapper, mo):\n    create_wrapper(\n        mo.md(\n            r\"\"\"\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        \"\"\"\n        ),\n        \"latex\",\n    )\n    return\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## Interpolating Python values\n\n        You can interpolate Python values into markdown using\n        `f-strings` and marimo's ` as_html` function. This lets you create \n        markdown whose contents depend on data that changes at runtime.\n\n        Here are some examples.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nclass Html(MIME):\n    \"\"\"A wrapper around HTML text that can be used as an output.\n\n    Output an `Html` object as the last expression of a cell to render it in\n    your app.\n\n    Use f-strings to embed Html objects as text into other HTML or markdown\n    strings. For example:\n\n    ```python3\n    hello_world = Html(\"<h2>Hello, World</h2>\")\n    Html(\n        f'''\n        <h1>Hello, Universe!</h1>\n        {hello_world}\n        '''\n    )\n    ```\n\n    **Attributes.**\n\n    - `text`: a string of HTML\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n            apps. This function compiles Markdown into HTML that marimo\n            can display.\n\n            For example, here's the code that rendered the above title and\n            paragraph:\n\n            ```python3\n            mo.md(\n                '''\n                # Hello, Markdown!\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        # Hello, Markdown!\n\n        Use marimo's \"`md`\" function to write markdown. This function compiles Markdown into HTML that marimo can display.\n\n        For example, here's the code that rendered the above title and \n        paragraph:\n\n        ```python3\n        mo.md(\n            '''\n            # Hello, Markdown!\n------------------------------\n------------------------------\nclass Cell:\n    \"\"\"An executable notebook cell\n\n    A `Cell` object can be executed as a function via its `run()` method, which\n    returns the cell's last expression (output) and a mapping from its defined\n    names to its values.\n\n    Cells can be named via the marimo editor in the browser, or by\n    changing the cell's function name in the notebook file. Named\n    cells can then be executed for use in other notebooks, or to test\n    in unit tests.\n\n    For example:\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        **Explanation.** By lifting Markdown into Python, marimo lets you construct\n        dynamic Markdown parametrized by arbitrary Python elements. marimo knows\n        how to render its own elements, and you can use `mo.as_html` to render other\n        objects, like plots.\n\n        _Tip: toggle a markdown view via `Cmd/Ctrl-Shift-M` in an empty cell._\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nUse marimo's \"`md`\" function to embed rich text into your marimo\n                apps. This function compiles your Markdown into HTML that marimo\n                can display.\n                '''\n            )\n            ```\n            \\\"\\\"\\\"\n        )\n        \"\"\"\n        ),\n        generator.add_code(\n            \"\"\"\n        mo.md(\n            r\\\"\\\"\\\"\n            ## LaTeX\n            You can embed LaTeX in Markdown.\n\n            For example,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def md(text: str) -> Html:\n# Natural Language Annotations: r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python3\ndef md(text: str) -> Html:\n    \"\"\"\n    Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2\u00a0mil} + \\frac{x^3}{3\u00a0mil} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2\u00a0mil} + \\frac{x^3}{3\u00a0mil} + \\ldots.\n    $$\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n    return Html(text)\n```", "```python\ndef md(text: str) -> Html:\n    \"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2\uff01} + \\frac{x^3}{3\uff01} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2\uff01} + \\frac{x^3}{3\uff01} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n    pass\n```", "```python3\ndef md(text: str) -> Html:\n    \"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2 !} + \\frac{x^3}{3 !} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2 !} + \\frac{x^3}{3 !} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n```"]}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nThe mutations that this method makes to the graph renders the\n        kernel inconsistent (stale).\n\n        This method does not register errors for cells that were previously\n        valid and are not descendants of any of the newly registered cells.\n        This is important for multiple definition errors, since a user may\n        absent-mindedly redefine an existing name when creating a new cell:\n        such a mistake shouldn't invalidate the program state.\n------------------------------\n------------------------------\n# Install formatters when marimo is being used without\n            # a kernel (eg, in a unit test or when run as a Python script)\n            register_formatters()\n\n    if isinstance(obj, Plain):\n        child_formatter = get_formatter(obj.child, include_opinionated=False)\n        if child_formatter:\n\n            def plain_formatter(obj: T) -> tuple[KnownMimeType, str]:\n                assert child_formatter is not None\n                return child_formatter(cast(Plain, obj).child)\n------------------------------\n------------------------------\n# install formatter import hooks, which will be shared by all\n            # threads (in edit mode, the single kernel process installs\n            # formatters ...)\n            register_formatters()\n------------------------------\n------------------------------\n# formatters aren't automatically registered when running as a\n            # script\n            from marimo._output.formatters.formatters import (\n                register_formatters,\n            )\n            from marimo._output.formatting import FORMATTERS\n\n            if not FORMATTERS:\n                register_formatters()\n\n            post_execute_hooks = []\n            if DependencyManager.has_matplotlib():\n                from marimo._output.mpl import close_figures\n------------------------------\n------------------------------\neditor. So don't worry that you'll botch a cell's signature when editing \n        it.\n        \"\"\",\n        \"The `app` object\": \"\"\"\n        At the top of the generated code, a variable named `app` is created. \n        This object collects the cells into a dataflow graph, using the `cell` \n        decorator. \n        \"\"\",\n        \"Runnable as a script\": \"\"\"\n        You can run marimo apps as scripts at the command line,\n        using Python. This will execute the cells in a\n------------------------------\n------------------------------\ndef __():\n    intro = \"\"\"\n    # File Format\n\n    marimo apps are stored as pure Python files.\n\n    These files are:\n\n    - easily versioned with git, producing small diffs\n    - legible for both humans and machines\n    - formattable using your tool of choice\n    - usable as Python  scripts, with UI  elements taking their default values\n    \"\"\"\n    return intro,\n------------------------------\n------------------------------\nUse this method to create a form that gates the submission\n        of a `UIElement`s value until a submit button is clicked.\n\n        The value of the `form` is the value of the underlying\n        element the last time the form was submitted.\n\n        **Examples.**\n\n        Convert any `UIElement` into a form:\n\n        ```python\n        prompt = mo.ui.text_area().form()\n        ```\n\n        Combine with `HTML.batch` to create a form made out of multiple\n        `UIElements`:\n------------------------------\n------------------------------\nif is_edit_mode:\n        # completions only provided in edit mode\n        kernel.start_completion_worker(completion_queue)\n\n        # In edit mode, kernel runs in its own process so it's interruptible.\n        from marimo._output.formatters.formatters import register_formatters\n------------------------------\n------------------------------\n# Map from formatter factory's package name to formatter, for third-party\n# modules. These formatters will be registered if and when their associated\n# packages are imported.\nTHIRD_PARTY_FACTORIES: dict[str, FormatterFactory] = {\n    AltairFormatter.package_name(): AltairFormatter(),\n    MatplotlibFormatter.package_name(): MatplotlibFormatter(),\n    PandasFormatter.package_name(): PandasFormatter(),\n    PolarsFormatter.package_name(): PolarsFormatter(),\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        ## Parting thoughts\n\n        marimo is a **reinvention** of the Python notebook as a reproducible, interactive, and shareable Python program, instead of an error-prone scratchpad.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_formatters() -> None:\n# Natural Language Annotations: \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\"\"\"\n    from marimo._output.formatters.formatters import THIRD_PARTY_FACTORIES\n    from marimo._utils.imports import import_hooks\n    for factory in THIRD_PARTY_FACTORIES.values():\n        import_hooks.register(factory.package_name(), factory.register_formatter)\n```\n\n```python\ndef __():\n    intro = \"\"\"\n    # File Format\n\n    marimo apps are stored as pure Python files.\n\n    These files are:\n\n    - easily versioned with git, producing small diffs\n    - legible for both humans and machines\n    - formattable using your tool of choice\n    - usable as Python  scripts, with UI  elements taking their default values\n    \"\"\"\n    return intro,\n```\n\n```python\ndef plain_formatter(obj: T) -> tuple[KnownMimeType, str]:\n    assert child_formatter is not None\n    return child_formatter(cast(Plain, obj).child)\n```\n\n```python\nif is_edit_mode:\n    # completions only provided in edit mode\n    kernel.start_completion_worker(completion_queue)\n\n    # In edit mode, kernel runs in its own process so it's interruptible.\n    from marimo._output.formatters.formatters import register_formatters\n```\n\n```python\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        ## Parting thoughts\n\n        marimo is a **reinvention** of the Python notebook as a reproducible, interactive, and shareable Python program, instead of an error-prone scratchpad.\n\n        marimo comes packaged with rich formatters for a number of third-party\n        libraries. This function hooks into Python's import system to register\n        these formatters with the kernel if and when a supported third-party\n        library is imported into a marimo notebook.\n\n        Hooking into the import system is more complicated than the alternative\n        of checking whether a package is installed (by importing it) and then\n        registering its formatters at kernel start-up. However, because some\n        packages imports take a long time, this alternative would add considerable\n        delay at program start-up, as the kernel would block as it registered\n        all formatters before running the notebook. Hooking into the import\n        system makes formatter registration completely lazy, improving\n        UX at the cost of increased complexity that we have to maintain. In this\n        case, the trade-off is worth it.\n        \"\"\"\n    )\n```", "```python\ndef register_formatters() -> None:\n    from marimo._output.formatters.formatters import (\n        THIRD_PARTY_FACTORIES,\n        FORMATTERS,\n        Formatter,\n    )\n    from marimo._output.formatters.base import get_formatter_for\n\n    for formatter_factory in THIRD_PARTY_FACTORIES.values():\n        if formatter_factory.package_name() in sys.modules:\n            formatter_factory.register_formatter()\n\n    if FORMATTERS:\n        return\n\n    for formatter in Formatter.__subclasses__():\n        FORMATTERS.append(formatter())\n\n    # Register the default formatter\n    default_formatter: Formatter = Formatter()\n    FORMATTERS.append(default_formatter)\n\n    # Make sure the default formatter is the last one, to avoid\n    # formatting conflicts\n    FORMATTERS.sort(key=lambda f: f is not default_formatter)\n```\n------------------------------\n```python\ndef __():\n    intro = \"\"\"\n    # File Format\n\n    marimo apps are stored as pure Python files.\n\n    These files are:\n\n    - easily versioned with git, producing small diffs\n    - legible for both humans and machines\n    - formattable using your tool of choice\n    - usable as Python  scripts, with UI  elements taking their default values\n    \"\"\"\n    return intro,\n```\n------------------------------\n```python\ndef __(mo):\n    mo.md(\n        rf\"\"\"\n        ## Parting thoughts\n\n        marimo is a **reinvention** of the Python notebook as a reproducible, interactive, and shareable Python program, instead of an error-prone scratchpad.\n\n        marimo comes packaged with rich formatters for a number of third-party\n        libraries. This function hooks into Python's import system to register\n        these formatters with the kernel if and when a supported third-party\n        library is imported into a marimo notebook.\n\n        Hooking into the import system is more complicated than the alternative\n        of checking whether a package is installed (by importing it) and then\n        registering its formatters at kernel start-up. However, because some\n        packages imports take a long time, this alternative would add considerable\n        delay at program start-up, as the kernel would block as it registered\n        all formatters before running the notebook. Hooking into the import\n        system makes formatter registration completely lazy, improving\n        UX at the cost of increased complexity that we have to maintain. In this\n        case, the trade-off is worth it.\n        \"\"\"\n    )\n```", "Sure, here is the code snippet based on the function signature and natural language annotations:\n\n```python\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\"\"\"\n\n    marimo.comes(\n        rf\"\"\"\n        ## Parting thoughts\n\n        marimo is a **reinvention** of the Python notebook as a reproducible, interactive, and shareable Python program, instead of an error-prone scratchpad.\n\n        marimo comes packaged with rich formatters for a number of third-party\n        libraries. This function hooks into Python's import system to register\n        these formatters with the kernel if and when a supported third-party\n        library is imported into a marimo notebook.\n\n        Hooking into the import system is more complicated than the alternative\n        of checking whether a package is installed (by importing it) and then\n        registering its formatters at kernel start-up. However, because some\n        packages imports take a long time, this alternative would add considerable\n        delay at program start-up, as the kernel would block as it registered\n        all formatters before running the notebook. Hooking into the import\n        system makes formatter registration completely lazy, improving\n        UX at the cost of increased complexity that we have to maintain. In this\n        case, the trade-off is worth it.\n        \"\"\"\n    )\n```"]}, "marimo-marimo/_data/series.py-get_category_series_info": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass CategorySeriesInfo:\n    \"\"\"\n    Represents a summary of a categorical series.\n    \"\"\"\n\n    categories: list[str]\n    label: str\n------------------------------\n------------------------------\nclass NumberSeriesInfo:\n    \"\"\"\n    Represents a summary of a numeric series.\n    \"\"\"\n\n    min: float\n    max: float\n    label: str\n------------------------------\n------------------------------\nclass DateSeriesInfo:\n    \"\"\"\n    Represents a summary of a date series.\n    \"\"\"\n\n    min: str\n    max: str\n    label: str\n------------------------------\n------------------------------\nclass ColumnSummary:\n    \"\"\"\n    Represents a summary of a column in a data table.\n\n    \"\"\"\n------------------------------\n------------------------------\ndef get_date_series_info(series: Any) -> DateSeriesInfo:\n    \"\"\"\n    Get the summary of a date series.\n    \"\"\"\n\n    def validate_date(value: Any) -> str:\n        if not isinstance(value, datetime.date):\n            raise ValueError(\"Expected a date. Got: \" + str(type(value)))\n        return value.strftime(\"%Y-%m-%d\")\n\n    if DependencyManager.has_pandas():\n        import pandas as pd\n------------------------------\n------------------------------\ndef get_number_series_info(series: Any) -> NumberSeriesInfo:\n    \"\"\"\n    Get the summary of a numeric series.\n    \"\"\"\n\n    def validate_number(value: Any) -> float:\n        value = float(value)\n        if not isinstance(value, (int, float)):\n            raise ValueError(\"Expected a number. Got: \" + str(type(value)))\n        return value\n\n    if DependencyManager.has_pandas():\n        import pandas as pd\n------------------------------\n------------------------------\n**Args.**\n\n    - `collection`: optional collection to iterate over\n    - `title`: optional title\n    - `subtitle`: optional subtitle\n    - `completion_title`: optional title to show during completion\n    - `completion_subtitle`: optional subtitle to show during completion\n    - `total`: optional total number of items to iterate over\n    - `show_rate`: if True, show the rate of progress (items per second)\n    - `show_eta`: if True, show the estimated time of completion\n    \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_category_series_info(series: Any) -> CategorySeriesInfo:\n# Natural Language Annotations: \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n\n    def validate_category(value: Any) -> str:\n        if not isinstance(value, str):\n            raise ValueError(\"Expected a category. Got: \" + str(type(value)))\n        return value\n\n    if DependencyManager.has_pandas():\n        import pandas as pd\n```", "```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    if DependencyManager.has_pandas():\n        import pandas as pd\n\n    def validate_category(value: Any) -> str:\n        if not isinstance(value, str):\n            raise ValueError(\"Expected a string. Got: \" + str(type(value)))\n        return value\n\n    categories = [validate_category(value) for value in series]\n    label = \"Categorical Series\"  # You may want to set the label based on the series name\n\n    return CategorySeriesInfo(categories, label)\n```", "```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n\n    def validate_category(value: Any) -> str:\n        if not isinstance(value, str):\n            raise ValueError(\"Expected a string category. Got: \" + str(type(value)))\n        return value\n\n    if DependencyManager.has_pandas():\n        import pandas as pd\n```"]}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass ColumnSummary:\n    \"\"\"\n    Represents a summary of a column in a data table.\n\n    \"\"\"\n------------------------------\n------------------------------\nclass DataTableColumn:\n    \"\"\"\n    Represents a column in a data table.\n\n    Attributes:\n        name (str): The name of the column.\n        type (DataType): The data type of the column.\n    \"\"\"\n\n    name: str\n    type: DataType\n    external_type: ExternalDataType\n------------------------------\n------------------------------\nasync def preview_dataset_column(\n        self, request: PreviewDatasetColumnRequest\n    ) -> None:\n        \"\"\"Preview a column of a dataset.\n------------------------------\n------------------------------\nmo.md(\n        f\"\"\"\n        **Here's a preview of the images you've selected**:\n\n        {mo.as_html(selected_images)}\n\n        Here's all the data you've selected.\n\n        {table}\n        \"\"\"\n    )\n    return selected_images,\n------------------------------\n------------------------------\nasync def preview_column(\n    request: Request,\n) -> BaseResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/PreviewDatasetColumnRequest\"\n    responses:\n        200:\n            description: Preview a column in a dataset\n            content:\n                application/json:\n                    schema:\n                        $ref: \"#/components/schemas/SuccessResponse\"\n    \"\"\"\n------------------------------\n------------------------------\n**Attributes.**\n\n    - `value`: a Pandas dataframe of the plot data filtered by the selections\n    - `dataframe`: a Pandas dataframe of the unfiltered chart data\n    - `selections`: the selection of the chart; this may be an interval along\n       the name of an axis or a selection of points\n\n    **Initialization Args.**\n------------------------------\n------------------------------\nThe dataset is loaded, and the column is displayed in the frontend.\n        \"\"\"\n        try:\n            dataset = self.globals[request.table_name]\n            column_preview = get_column_preview(dataset, request)\n            if column_preview is None:\n                DataColumnPreview(\n                    error=f\"Column {request.column_name} not found\",\n                    column_name=request.column_name,\n                    table_name=request.table_name,\n                ).broadcast()\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        r\"\"\"\n        Evaluate a variable, to use its value as the name of a column in a query.\n\n        E.g. Query for rows where `John` is the value in the column named `first_name`.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nclass PreviewDatasetColumnRequest:\n    # The source of the dataset\n    source: str\n    # The name of the dataset\n    # This currently corresponds to the variable name\n    table_name: str\n    # The name of the column\n    column_name: str\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_column_preview(\n# Natural Language Annotations: \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_column_preview(dataset: pd.DataFrame, request: PreviewDatasetColumnRequest):\n    if request.column_name in dataset.columns:\n        column_data = dataset[request.column_name]\n        # Return a chart and a summary of the column data\n        chart = create_chart(column_data)\n        summary = create_summary(column_data)\n        return chart, summary\n    else:\n        return None\n```", "```python\ndef get_column_preview(dataset: DataTableColumn, request: PreviewDatasetColumnRequest) -> ColumnSummary:\n    # Your implementation here\n    # This is a placeholder code, replace it with your actual implementation\n    pass\n```", "```python\ndef get_column_preview(dataset: DataTable, request: PreviewDatasetColumnRequest) -> ColumnSummary:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    # Code to get the column from the dataset and create the ColumnSummary object goes here.\n    # This will depend on the exact structure of your DataTable and ColumnSummary classes.\n```"]}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nhelp=\"Include notebook code in the app.\",\n)\n@click.option(\n    \"--watch\",\n    is_flag=True,\n    default=False,\n    show_default=True,\n    type=bool,\n    help=\"\"\"\n    Watch the file for changes and reload the app.\n    If watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"--base-url\",\n    default=\"\",\n    show_default=True,\n    type=str,\n    help=\"Base URL for the server. Should start with a /.\",\n------------------------------\n------------------------------\ndef get_session_for_key(self, key: MarimoFileKey) -> Optional[Session]:\n        for session in self.sessions.values():\n            if (\n                session.app_file_manager.path == os.path.abspath(key)\n                or session.initialization_id == key\n            ) and session.connection_state() == ConnectionState.OPEN:\n                return session\n        return None\n\n    async def start_lsp_server(self) -> None:\n        \"\"\"Starts the lsp server if it is not already started.\n------------------------------\n------------------------------\n)\n        if self.module_watcher is not None:\n            self.module_watcher.run_is_processed.set()\n------------------------------\n------------------------------\nIf watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=str,\n    default=None,\n    help=\"\"\"\n    Output file to save the HTML to.\n    If not provided, the HTML will be printed to stdout.\n    \"\"\",\n)\n@click.argument(\"name\", required=True)\n@click.argument(\"args\", nargs=-1, type=click.UNPROCESSED)\n# Code for: def html(\n------------------------------\n------------------------------\nasync def start() -> None:\n        # Watch the file for changes\n        watcher = FileWatcher.create(marimo_path.path, on_file_changed)\n        click.echo(\n            f\"Watching {green(marimo_path.relative_name)} for changes...\"\n        )\n        watcher.start()\n        try:\n            # Run forever\n            while True:\n                await asyncio.sleep(1)\n        except KeyboardInterrupt:\n            watcher.stop()\n\n    asyncio_run(start())\n------------------------------\n------------------------------\nRequires nbformat to be installed.\n\"\"\"\n)\n@click.option(\n    \"--watch/--no-watch\",\n    default=False,\n    show_default=True,\n    type=bool,\n    help=\"\"\"\n    Watch notebook for changes and regenerate the ipynb on modification.\n    If watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=str,\n    default=None,\n    help=\"\"\"\n------------------------------\n------------------------------\n# (e.g. recursive/broken symlinks)\n                    continue\n------------------------------\n------------------------------\n\\b\n    * marimo export script notebook.py -o notebook.script.py --watch\n\"\"\"\n)\n@click.option(\n    \"--watch/--no-watch\",\n    default=False,\n    show_default=True,\n    type=bool,\n    help=\"\"\"\n    Watch notebook for changes and regenerate the script on modification.\n    If watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=str,\n    default=None,\n    help=\"\"\"\n------------------------------\n------------------------------\n):\n                LOGGER.debug(\n                    \"Found a resumable RUN session: prev_id=%s\",\n                    new_session_id,\n                )\n                return maybe_session\n            return None\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start_file_watcher(self) -> Disposable:\n# Natural Language Annotations: \"\"\"Starts the file watcher if it is not already started\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef start_file_watcher(self) -> Disposable:\n    if self.file_watcher is None:\n        self.file_watcher = WatchdogFileWatcher(self.file_path) if self.has_watchdog() else PollFileWatcher(self.file_path)\n        self.file_watcher.start()\n    return self.file_watcher\n```", "```python\ndef start_file_watcher(self) -> Disposable:\n    if self.module_watcher is not None:\n        self.module_watcher.run_is_processed.set()\n```", "```python\ndef start_file_watcher(self) -> Disposable:\n    \"\"\"Starts the file watcher if it is not already started\"\"\"\n    if self.module_watcher is not None:\n        self.module_watcher.run_is_processed.set()\n```"]}, "marimo-marimo/_server/file_manager.py-save_app_config": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef save(self, request: SaveNotebookRequest) -> str:\n        \"\"\"Save the current app.\"\"\"\n        cell_ids, codes, configs, names, filename, layout = (\n            request.cell_ids,\n            request.codes,\n            request.configs,\n            request.names,\n            request.filename,\n            request.layout,\n        )\n        filename = canonicalize_filename(filename)\n        self.app.with_data(\n            cell_ids=cell_ids,\n            codes=codes,\n            names=names,\n------------------------------\n------------------------------\ndef merge_default_config(config: MarimoConfig) -> MarimoConfig:\n    \"\"\"Merge a user configuration with the default configuration.\"\"\"\n    return merge_config(DEFAULT_CONFIG, config)\n------------------------------\n------------------------------\nclass SaveAppConfigurationRequest:\n    # partial app config\n    config: Dict[str, Any]\n------------------------------\n------------------------------\nasync def save_app_config(\n    *,\n    request: Request,\n) -> PlainTextResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/SaveAppConfigurationRequest\"\n    responses:\n        200:\n            description: Save the app configuration\n            content:\n                text/plain:\n                    schema:\n                        type: string\n    \"\"\"\n    app_state = AppState(request)\n------------------------------\n------------------------------\nserver = (\n    marimo.create_asgi_app()\n    # Mount the dataframe app at /dataframes\n    .with_app(path=\"/dataframes\", root=\"../dataframe.py\")\n    # Mount the ansi app at /ansi\n    .with_app(path=\"/ansi\", root=\"../ansi.py\")\n    # Mount the buttons app at the root\n    .with_app(path=\"\", root=\"../buttons.py\")\n)\n\n# Create a FastAPI app\napp = FastAPI()\n------------------------------\n------------------------------\ndef merge_config(\n    config: MarimoConfig, new_config: MarimoConfig\n) -> MarimoConfig:\n    \"\"\"Merge a user configuration with a new configuration.\"\"\"\n    # Remove the keymap overrides from the incoming config,\n    # so that they don't get merged into the new config\n    if new_config.get(\"keymap\", {}).get(\"overrides\") is not None:\n        # Clone config to avoid modifying the original\n        config = _deep_copy(config)\n        config.get(\"keymap\", {}).pop(\"overrides\", {})\n------------------------------\n------------------------------\n# deleting state that the user might want to keep\n            self.app.update_config({\"layout_file\": None})\n        return self._save_file(\n            filename,\n            codes,\n            names,\n            configs,\n            self.app.config,\n            persist=request.persist,\n        )\n------------------------------\n------------------------------\nclass AppStateBase:\n    \"\"\"The app state.\"\"\"\n\n    @staticmethod\n    def from_request(request: Union[Request, WebSocket]) -> AppState:\n        \"\"\"Get the app state with a request.\"\"\"\n        return AppState(request)\n\n    @staticmethod\n    def from_app(asgi: Starlette) -> AppStateBase:\n        \"\"\"Get the app state with an ASGIApp app.\"\"\"\n        return AppStateBase(cast(Any, asgi).state)\n------------------------------\n------------------------------\n@router.post(\"/save_app_config\")\n@requires(\"edit\")\n# Code for: async def save_app_config(\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def save_app_config(self, config: Dict[str, Any]) -> str:\n# Natural Language Annotations: \"\"\"Save the app configuration.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n        \"\"\"Save the app configuration.\"\"\"\n        app_state = AppState.from_app(self.app)\n        request = SaveAppConfigurationRequest(config=config)\n        return app_state.save(request)\n```", "```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    app_state = AppState.from_app(self.app)\n    app_state.update_config(config)\n    return \"App configuration saved\"\n```", "```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    # Merge the new config with the default config\n    merged_config = merge_default_config(config)\n\n    # Save the merged config\n    self.app.update_config(merged_config)\n\n    # Return the saved config\n    return self.app.config\n```"]}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef write_operation(self, operation: MessageOperation) -> None:\n        \"\"\"Write an operation to the session consumer and the session view.\"\"\"\n        self.session_view.add_operation(operation)\n        self.room.broadcast(operation)\n\n    def close(self) -> None:\n        \"\"\"\n        Close the session.\n------------------------------\n------------------------------\nclass PyodideSession:\n    \"\"\"A client session that is compatible with Pyodide.\"\"\"\n------------------------------\n------------------------------\ndef put_control_request(self, request: requests.ControlRequest) -> None:\n        \"\"\"Put a control request in the control queue.\"\"\"\n        self._queue_manager.control_queue.put(request)\n        if isinstance(request, SetUIElementValueRequest):\n            self._queue_manager.set_ui_element_queue.put(request)\n        # Propagate the control request to the room\n        if isinstance(request, ExecuteMultipleRequest):\n            self.room.broadcast(\n                UpdateCellCodes(\n------------------------------\n------------------------------\nclass SessionView:\n    \"\"\"\n    This stores the current view of the session.\n\n    Which are the cell's outputs, status, and console.\n    \"\"\"\n------------------------------\n------------------------------\ndef maybe_resume_session(\n        self, new_session_id: SessionId, file_key: MarimoFileKey\n    ) -> Optional[Session]:\n        \"\"\"\n        Try to resume a session if one is resumable.\n        If it is resumable, return the session and update the session id.\n        \"\"\"\n------------------------------\n------------------------------\nclass StdinRequest:\n    text: str\n------------------------------\n------------------------------\n(session_id, session) = next(iter(sessions_with_the_same_file.items()))\n        connection_state = session.connection_state()\n        if connection_state == ConnectionState.ORPHANED:\n            LOGGER.debug(\n                f\"Found a resumable EDIT session: prev_id={session_id}\"\n            )\n            # Set new session and remove old session\n            self.sessions[new_session_id] = session\n            # If the ID is the same, we don't need to delete the old session\n------------------------------\n------------------------------\noperations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the consumer\",\n        )\n------------------------------\n------------------------------\nasync def start(self) -> None:\n        # Accept the websocket connection\n        await self.websocket.accept()\n        # Create a new queue for this session\n        self.message_queue = asyncio.Queue()\n\n        session_id = self.session_id\n        mgr = self.manager\n        LOGGER.debug(\n            \"Websocket open request for session with id %s\", session_id\n        )\n        LOGGER.debug(\"Existing sessions: %s\", mgr.sessions)\n------------------------------\n------------------------------\ndef put_completion_request(\n        self, request: requests.CodeCompletionRequest\n    ) -> None:\n        \"\"\"Put a code completion request in the completion queue.\"\"\"\n        self._queue_manager.completion_queue.put(request)\n\n    def put_input(self, text: str) -> None:\n        \"\"\"Put an input() request in the input queue.\"\"\"\n        self._queue_manager.input_queue.put(text)\n        self.session_view.add_stdin(text)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_stdin(self, stdin: str) -> None:\n# Natural Language Annotations: \"\"\"Add a stdin request to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    self.session_view.add_stdin(stdin)\n```", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    self.session_view.stdin.append(stdin)\n```", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    self.session_view.add_operation(MessageOperation(CreateStdin(stdin)))\n```"]}, "marimo-marimo/_server/session/session_view.py-add_operation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef write_operation(self, operation: MessageOperation) -> None:\n        \"\"\"Write an operation to the session consumer and the session view.\"\"\"\n        self.session_view.add_operation(operation)\n        self.room.broadcast(operation)\n\n    def close(self) -> None:\n        \"\"\"\n        Close the session.\n------------------------------\n------------------------------\noperations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the consumer\",\n        )\n------------------------------\n------------------------------\ndef require_current_session(self) -> Session:\n        \"\"\"Get the current session or raise an error.\"\"\"\n        session_id = self.require_current_session_id()\n        session = self.session_manager.get_session(session_id)\n        if session is None:\n            LOGGER.warning(\n                \"Valid sessions: %s\",\n                list(self.session_manager.sessions.keys()),\n            )\n            raise ValueError(f\"Invalid session id: {session_id}\")\n        return session\n------------------------------\n------------------------------\noperations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the kiosk consumer\",\n        )\n------------------------------\n------------------------------\n# Should only return an orphaned session\n        sessions_with_the_same_file: dict[SessionId, Session] = {\n            session_id: session\n            for session_id, session in self.sessions.items()\n            if session.app_file_manager.path == os.path.abspath(file_key)\n        }\n------------------------------\n------------------------------\nclass SessionView:\n    \"\"\"\n    This stores the current view of the session.\n\n    Which are the cell's outputs, status, and console.\n    \"\"\"\n------------------------------\n------------------------------\nif self.manager.mode == SessionMode.RUN:\n            # When the websocket is closed, we wait TTL_SECONDS before\n            # closing the session. This is to prevent the session from\n            # being closed if the during an intermittent network issue.\n            def _close() -> None:\n                if self.status != ConnectionState.OPEN:\n                    LOGGER.debug(\n                        \"Closing session %s (TTL EXPIRED)\",\n                        self.session_id,\n------------------------------\n------------------------------\n# Code for: class SessionView:\n\n\n# Code for: def merge_cell_operation(\n\n\n# Code for: def as_list(value: Union[Any, Optional[Any], list[Any]]) -> list[Any]:\n------------------------------\n------------------------------\ndef maybe_resume_session(\n        self, new_session_id: SessionId, file_key: MarimoFileKey\n    ) -> Optional[Session]:\n        \"\"\"\n        Try to resume a session if one is resumable.\n        If it is resumable, return the session and update the session id.\n        \"\"\"\n------------------------------\n------------------------------\nfor op in operations:\n            LOGGER.debug(\"Replaying operation %s\", serialize(op))\n            self.write_operation(op)\n\n    def _connect_kiosk(self, session: Session) -> None:\n        \"\"\"Connect to a kiosk session.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_operation(self, operation: MessageOperation) -> None:\n# Natural Language Annotations: \"\"\"Add an operation to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.session_view.add_operation(operation)\n```", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.session_view.add_operation(operation)\n```", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.session_view.add_operation(operation)\n```"]}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_cell_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, CellOutput]:\n        \"\"\"Get the outputs for the given cell ids.\"\"\"\n        outputs: dict[CellId_t, CellOutput] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.output is not None:\n                outputs[cell_id] = cell_op.output\n        return outputs\n------------------------------\n------------------------------\n)\n        # don't clear console because this cell was running and\n        # its console outputs are not stale\n        exception_type = type(run_result.exception).__name__\n        CellOp.broadcast_error(\n            data=[\n                MarimoExceptionRaisedError(\n                    msg=\"This cell raised an exception: %s%s\"\n                    % (\n                        exception_type,\n                        (\n                            f\"('{str(run_result.exception)}')\"\n------------------------------\n------------------------------\ncodes = [\"\" for _ in cell_ids]\n            configs = [CellConfig() for _ in cell_ids]\n            console_outputs = {}\n------------------------------\n------------------------------\ndef defining_cell(self, module_name: str) -> CellId_t | None:\n        \"\"\"Get the cell id of the cell importing module_name\"\"\"\n        for cell_id, cell in self.graph.cells.items():\n            if cell.namespace_to_variable(module_name) is not None:\n                return cell_id\n        return None\n------------------------------\n------------------------------\ncell_configs=list(configs),\n            cell_outputs=session_view.get_cell_outputs(cell_ids),\n            cell_console_outputs=console_outputs,\n            files=files,\n            asset_url=request.asset_url,\n        )\n------------------------------\n------------------------------\n# don't clear console because this cell was running and\n        # its console outputs are not stale\n        CellOp.broadcast_error(\n            data=[MarimoInterruptionError()],\n            clear_console=False,\n            cell_id=cell.cell_id,\n        )\n    elif run_result.exception is not None:\n        LOGGER.debug(\n            \"Cell %s raised %s\",\n            cell.cell_id,\n            type(run_result.exception).__name__,\n        )\n------------------------------\n------------------------------\nserialized_cell_outputs = {\n        cell_id: _serialize_to_base64(json.dumps(output.asdict()))\n        for cell_id, output in cell_outputs.items()\n    }\n    serialized_cell_console_outputs = {\n        cell_id: [_serialize_to_base64(json.dumps(o.asdict())) for o in output]\n        for cell_id, output in cell_console_outputs.items()\n        if output\n    }\n------------------------------\n------------------------------\ndef __():\n    plt_show_explainer = {\n        \"Using `plt.show()`\": \"\"\"\n        You can use `plt.show()` or `figure.show()` to display\n        plots in the console area of a cell. Keep in mind that console\n        outputs are not shown in the app view.\n        \"\"\"\n    }\n    return plt_show_explainer,\n------------------------------\n------------------------------\n# code and console outputs are grouped together, but\n        # we can split them up in the future if desired.\n        if request.include_code:\n            code = file_manager.to_code()\n            codes = file_manager.app.cell_manager.codes()\n            configs = file_manager.app.cell_manager.configs()\n            console_outputs = session_view.get_cell_console_outputs(cell_ids)\n        else:\n            code = \"\"\n            codes = [\"\" for _ in cell_ids]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_cell_console_outputs(\n# Natural Language Annotations: \"\"\"Get the console outputs for the given cell ids.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_cell_console_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, list[CellConsoleOutput]]:\n        \"\"\"Get the console outputs for the given cell ids.\"\"\"\n        console_outputs: dict[CellId_t, list[CellConsoleOutput]] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.console_output is not None:\n                console_outputs[cell_id] = cell_op.console_output\n        return console_outputs\n```", "```python\ndef get_cell_console_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, list[CellConsoleOutput]]:\n        \"\"\"Get the console outputs for the given cell ids.\"\"\"\n        console_outputs: dict[CellId_t, list[CellConsoleOutput]] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.console_outputs is not None:\n                console_outputs[cell_id] = cell_op.console_outputs\n        return console_outputs\n```", "```python\ndef get_cell_console_outputs(self, ids: list[CellId_t]) -> dict[CellId_t, list[CellConsoleOutput]]:\n    \"\"\"Get the console outputs for the given cell ids.\"\"\"\n    console_outputs: dict[CellId_t, list[CellConsoleOutput]] = {}\n    for cell_id in ids:\n        cell_op = self.cell_operations.get(cell_id)\n        if cell_op is not None and cell_op.console_outputs is not None:\n            console_outputs[cell_id] = cell_op.console_outputs\n    return console_outputs\n```"]}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Removes a cell from the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Returns the ids of the children of the removed cell.\n        \"\"\"\n        with self.lock:\n            if cell_id not in self.cells:\n                raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\ndef mutate_graph(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> set[CellId_t]:\n        \"\"\"Add and remove cells to/from the graph.\n\n        This method adds the cells in `execution_requests` to the kernel's\n        graph (deleting old versions of these cells, if any), and removes the\n        cells in `deletion_requests` from the kernel's graph.\n------------------------------\n------------------------------\ndef _try_registering_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> Optional[Error]:\n        \"\"\"Attempt to register a cell with given id and code.\n\n        Precondition: a cell with the supplied id must not already exist in the\n        graph.\n------------------------------\n------------------------------\ndef enable_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"\n        Enables a cell in the graph.\n\n        Does not mutate the graph (but does mutate cell statuses).\n\n        Returns:\n        - set of cells that were stale and should be re-run\n        \"\"\"\n        if cell_id not in self.cells:\n            raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\nIf `deletion` is `True`, the cell is being removed from the graph.\n        \"\"\"\n        from marimo._runtime.context import get_context\n------------------------------\n------------------------------\nwith graph.lock:\n        codes = [\n            graph.cells[cid].code\n            for cid in dataflow.topological_sort(\n                graph,\n                set(graph.cells.keys()) - set([request.cell_id]),\n            )\n        ]\n------------------------------\n------------------------------\nIn contrast to deleting a cell, which fully scrubs the cell\n        from the kernel and graph.\n        \"\"\"\n        if cell_id not in self.errors:\n            self._invalidate_cell_state(cell_id, deletion=True)\n            return self.graph.delete_cell(cell_id)\n        else:\n            # An errored cell can be thought of as a cell that's in the graph\n            # but that has no state in the kernel (because it was never run).\n------------------------------\n------------------------------\nmodules: dict[str, types.ModuleType] = {}\n        modname_to_cell_id: dict[str, CellId_t] = {}\n        with graph.lock:\n            for cell_id, cell in graph.cells.items():\n                for modname in modules_imported_by_cell(cell, sys_modules):\n                    if modname in sys_modules:\n                        modules[modname] = sys_modules[modname]\n                        modname_to_cell_id[modname] = cell_id\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n# Natural Language Annotations: \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```", "```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```", "```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists in the graph\")\n        self.cells[cell_id] = cell\n```"]}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Cells that define the same name\n    #\n    # siblings[cell_id] is a set of cell ids, one for each cell that shares a\n    # definition with cell_id.\n    #\n    # If this dict is non-empty, then the marimo program contains multiply\n    # defined names (and is therefore in an error state)\n    siblings: dict[CellId_t, set[CellId_t]] = field(default_factory=dict)\n\n    # A mapping from defs to the cells that define them\n    definitions: dict[Name, set[CellId_t]] = field(default_factory=dict)\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## References and definitions\n\n        A marimo notebook is a directed acyclic graph in which nodes represent \n        cells and edges represent data dependencies. marimo creates this graph by\n        analyzing each cell (without running it) to determine its\n\n        - references (\"refs*), the global variables it reads but doesn't define;\n        - definitions (\"defs\"), the global variables it defines.\n------------------------------\n------------------------------\nclass Runner:\n    \"\"\"Utility for running individual cells in a graph\n\n    This class provides methods to a run a cell in the graph and obtain its\n    output (last expression) and the values of its defs.\n\n    If needed, the runner will recursively compute the values of the cell's\n    refs by executing its ancestors. Refs can also be substituted by the\n    caller.\n\n    TODO(akshayka): Add an API for caching defs across cell runs.\n    \"\"\"\n------------------------------\n------------------------------\ndef check_for_multiple_definitions(\n    graph: DirectedGraph,\n) -> dict[CellId_t, list[MultipleDefinitionError]]:\n    \"\"\"Check whether multiple cells define the same global name.\"\"\"\n    errors = defaultdict(list)\n    defs = sorted(\n        list(set().union(*(cell.defs for _, cell in graph.cells.items())))\n    )\n    for name in defs:\n        defining_cells = graph.definitions[name]\n        if len(defining_cells) > 1:\n            for cid in defining_cells:\n                errors[cid].append(\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        Here's an **embedding of MNIST**: each point represents a digit,\n        with similar digits close to each other.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport itertools\nfrom collections import defaultdict\n\nfrom marimo._ast.cell import CellId_t\nfrom marimo._messaging.errors import (\n    CycleError,\n    DeleteNonlocalError,\n    Error,\n    MultipleDefinitionError,\n)\nfrom marimo._runtime.dataflow import DirectedGraph\n\n\n# Code for: def check_for_multiple_definitions(\n\n\n# Code for: def check_for_delete_nonlocal(\n------------------------------\n------------------------------\n# defs that we shouldn't remove from the graph\n        keep_alive_defs: set[Name] = set()\n        for cid in list(semantic_errors.keys()):\n            # If a cell was previously valid, don't invalidate it unless\n            # we have to, ie, unless it is a descendant of a just-registered\n            # cell that has an error\n            #\n            # Handles the introduction of a multiple definition error, eg\n            #\n            # cell 1: x = 0\n------------------------------\n------------------------------\n# Check for semantic errors, like multiple definition errors, cycle\n        # errors, and delete nonlocal errors.\n        semantic_errors = check_for_errors(self.graph)\n        LOGGER.debug(\"After mutation, syntax errors %s\", syntax_errors)\n        LOGGER.debug(\"Semantic errors %s\", semantic_errors)\n------------------------------\n------------------------------\n# with doing that:\n        #\n        # 1. Interacting with an element in the dict might cause the cell\n        # that created the dict to re-run (if the element were declared\n        # in another cell), causing the dict to be destroyed and recreated\n        # with a new object-id, which in turn will re-initialize the dict\n        # and interrupt all interactivity\n        #\n        # 2. Interacting with the original element in another cell may\n------------------------------\n------------------------------\ndef __(mo):\n    mo.accordion(\n        {\n            \"Tip: inspecting refs and defs\": f\"\"\"\n            Use `mo.refs()` and `mo.defs()` to inspect the refs and defs of any\n            given cell. This can help with debugging complex notebooks.\n\n            For example, here are the refs and defs of this cell:\n\n            {mo.as_html({\"refs\": mo.refs(), \"defs\": mo.defs()})}\n            \"\"\"\n        }\n    )\n    return\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check_for_errors(\n# Natural Language Annotations: \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef check_for_errors(graph: DirectedGraph) -> dict[CellId_t, list[Error]]:\n    errors = defaultdict(list)\n    \n    # Check for multiple definition errors\n    for name in sorted(graph.definitions.keys()):\n        defining_cells = graph.definitions[name]\n        if len(defining_cells) > 1:\n            for cid in defining_cells:\n                errors[cid].append(MultipleDefinitionError(name))\n\n    # Check for cycle errors\n    for cycle in graph.cycles():\n        for cid in cycle:\n            errors[cid].append(CycleError(cycle))\n\n    # Check for delete nonlocal errors\n    keep_alive_defs = set()\n    for cid in list(errors.keys()):\n        cell = graph.cells[cid]\n        for name in cell.defs:\n            if name in keep_alive_defs:\n                errors[cid].append(DeleteNonlocalError(name))\n        keep_alive_defs |= cell.defs\n\n    return errors\n```", "```python\ndef check_for_errors(graph: DirectedGraph) -> dict[CellId_t, list[Error]]:\n    errors = defaultdict(list)\n\n    # Check for multiple definitions\n    multiple_definition_errors = check_for_multiple_definitions(graph)\n    for cell_id, cell_errors in multiple_definition_errors.items():\n        errors[cell_id].extend(cell_errors)\n\n    # Check for delete nonlocal errors (not implemented)\n    # delete_nonlocal_errors = check_for_delete_nonlocal(graph)\n    # for cell_id, cell_errors in delete_nonlocal_errors.items():\n    #     errors[cell_id].extend(cell_errors)\n\n    # Check for cycle errors (not implemented)\n    # cycle_errors = check_for_cycles(graph)\n    # for cell_id, cell_errors in cycle_errors.items():\n    #     errors[cell_id].extend(cell_errors)\n\n    return errors\n```", "```python\ndef check_for_errors(graph: DirectedGraph) -> dict[CellId_t, list[Error]]:\n    errors = defaultdict(list)\n    defs = sorted(\n        list(set().union(*(cell.defs for _, cell in graph.cells.items())))\n    )\n    for name in defs:\n        defining_cells = graph.definitions[name]\n        if len(defining_cells) > 1:\n            for cid in defining_cells:\n                errors[cid].append(MultipleDefinitionError(name))\n    return errors\n```"]}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _try_registering_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> Optional[Error]:\n        \"\"\"Attempt to register a cell with given id and code.\n\n        Precondition: a cell with the supplied id must not already exist in the\n        graph.\n------------------------------\n------------------------------\nif cell_id in self.cell_metadata and cell is not None:\n            # If we already have a config for this cell id, restore it\n            # This can happen when a cell was previously deactivated (due to a\n            # syntax error or multiple definition error, for example) and then\n            # re-registered\n            cell.configure(self.cell_metadata[cell_id].config)\n        elif cell_id not in self.cell_metadata:\n            self.cell_metadata[cell_id] = CellMetadata()\n------------------------------\n------------------------------\ndef enable_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"\n        Enables a cell in the graph.\n\n        Does not mutate the graph (but does mutate cell statuses).\n\n        Returns:\n        - set of cells that were stale and should be re-run\n        \"\"\"\n        if cell_id not in self.cells:\n            raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\n# The set of cells that need to be re-run due to cells being\n        # deleted/re-registered.\n        cells_that_were_children_of_mutated_cells: set[CellId_t] = set()\n\n        # Cells that were unable to be added to the graph due to syntax errors\n        syntax_errors: dict[CellId_t, Error] = {}\n------------------------------\n------------------------------\ndef delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Removes a cell from the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Returns the ids of the children of the removed cell.\n        \"\"\"\n        with self.lock:\n            if cell_id not in self.cells:\n                raise ValueError(f\"Cell {cell_id} not found\")\n------------------------------\n------------------------------\n(3) means that a state update in a given cell will never re-trigger\n        the same cell to run. This is similar to how interacting with\n        a UI element in the cell that created it won't re-trigger the cell,\n        and this behavior is useful when tying UI elements together with a\n        state object.\n\n        **Arguments.**\n------------------------------\n------------------------------\n# Random token\n        #\n        # Every element is annotated with a random token, which by design is\n        # different every time the element is constructed (i.e., every time a\n        # cell runs): this guarantees that re-running a cell that creates a UI\n        # element will trigger a re-render and reset it to its initial value.\n        # We need this to ensure that the element on the page is synchronized\n        # with the element in the kernel.\n------------------------------\n------------------------------\n# Register and delete cells\n        for er in execution_requests:\n            old_children, error = self._maybe_register_cell(\n                er.cell_id, er.code\n            )\n            cells_that_were_children_of_mutated_cells |= old_children\n            if error is None:\n                registered_cell_ids.add(er.cell_id)\n            else:\n                syntax_errors[er.cell_id] = error\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _maybe_register_cell(\n# Natural Language Annotations: \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _maybe_register_cell(\n        self,\n        cell_id: CellId_t,\n        code: str\n    ) -> Tuple[set[CellId_t], Optional[Error]]:\n        \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\n        if cell_id in self.cells and self.cells[cell_id].code != code:\n            old_children = self.delete_cell(cell_id)\n        else:\n            old_children = set()\n\n        error = self._try_registering_cell(cell_id, code)\n        return old_children, error\n```", "```python\ndef _maybe_register_cell(self, cell_id: CellId_t, code: str) -> Tuple[set[CellId_t], Optional[Error]]:\n    old_children = set()\n    error = None\n\n    if cell_id in self.cell_metadata:\n        if self.cell_metadata[cell_id].code != code:\n            old_children = self.delete_cell(cell_id)\n\n    error = self._try_registering_cell(cell_id, code)\n\n    return old_children, error\n```", "```python\ndef _maybe_register_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> tuple[set[CellId_t], Error]:\n        \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\n        old_children = set()\n        error = None\n        if cell_id in self.cells and self.cells[cell_id].code != code:\n            old_children = self.delete_cell(cell_id)\n        if cell_id not in self.cells:\n            error = self._try_registering_cell(cell_id, code)\n        return old_children, error\n```"]}, "marimo-marimo/_runtime/runtime.py-run": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef mutate_graph(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> set[CellId_t]:\n        \"\"\"Add and remove cells to/from the graph.\n\n        This method adds the cells in `execution_requests` to the kernel's\n        graph (deleting old versions of these cells, if any), and removes the\n        cells in `deletion_requests` from the kernel's graph.\n------------------------------\n------------------------------\n# Runner always runs stale ancestors, if any.\n        cells_to_run = roots.union(\n            dataflow.transitive_closure(\n                graph,\n                roots,\n                children=False,\n                inclusive=False,\n                predicate=lambda cell: cell.stale,\n            )\n        )\n        if self.execution_mode == \"autorun\":\n            # in autorun/eager mode, descendants are also run\n------------------------------\n------------------------------\nThe mutations that this method makes to the graph renders the\n        kernel inconsistent (stale).\n\n        This method does not register errors for cells that were previously\n        valid and are not descendants of any of the newly registered cells.\n        This is important for multiple definition errors, since a user may\n        absent-mindedly redefine an existing name when creating a new cell:\n        such a mistake shouldn't invalidate the program state.\n------------------------------\n------------------------------\nasync def run_cell(\n    *,\n    request: Request,\n) -> BaseResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/RunRequest\"\n    responses:\n        200:\n            description: Run a cell. Updates cell code in the kernel if needed; registers new cells for unseen cell IDs. Only allowed in edit mode.\n            content:\n                application/json:\n                    schema:\n------------------------------\n------------------------------\n# The set of cells that need to be re-run due to cells being\n        # deleted/re-registered.\n        cells_that_were_children_of_mutated_cells: set[CellId_t] = set()\n\n        # Cells that were unable to be added to the graph due to syntax errors\n        syntax_errors: dict[CellId_t, Error] = {}\n------------------------------\n------------------------------\nThere is an edge from one cell to another if the latter cell references any\n        global variables defined by the former cell.\n\n        The rule for reactive execution can be restated in terms of the graph: when\n        a cell is run, its descendants are run automatically.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        Here is the dataflow graph for the cells that make the sine wave plot, plus\n        the cells that import libraries. Each cell is labeled with its defs.\n------------------------------\n------------------------------\nclass Runner:\n    \"\"\"Utility for running individual cells in a graph\n\n    This class provides methods to a run a cell in the graph and obtain its\n    output (last expression) and the values of its defs.\n\n    If needed, the runner will recursively compute the values of the cell's\n    refs by executing its ancestors. Refs can also be substituted by the\n    caller.\n\n    TODO(akshayka): Add an API for caching defs across cell runs.\n    \"\"\"\n------------------------------\n------------------------------\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ### Underscore-prefixed variables are local to cells\n\n        Global variables prefixed with an underscore are \"private\" to the cells \n        that define them. This means that multiple cells can define the same \n        underscore-prefixed name, and one cell's private variables won't be\n        made available to other cells.\n\n        **Example**.\n        \"\"\"\n    )\n    return\n------------------------------\n------------------------------\nRunner._substitute_refs(cell_impl, glbls, kwargs)\n        output = await execute_cell_async(\n            graph.cells[cell_impl.cell_id], glbls, graph\n        )\n        defs = Runner._returns(cell_impl, glbls)\n        return output, defs\n\n    def run_cell_sync(\n        self, cell_id: CellId_t, kwargs: dict[str, Any]\n    ) -> tuple[Any, dict[str, Any]]:\n        \"\"\"Run a synchronous cell and its ancestors\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run(\n# Natural Language Annotations: \"\"\"Run cells and their descendants.\n\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def run(\n    self,\n    execution_requests: Sequence[ExecutionRequest],\n    deletion_requests: Sequence[DeleteCellRequest]\n) -> None:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    # Add new cells to the graph and remove cells to be deleted from the graph\n    self.mutate_graph(execution_requests, deletion_requests)\n\n    # Run cells in the graph\n    for cell in execution_requests:\n        output, defs = self.run_cell_sync(cell.cell_id, cell.kwargs)\n        # Do something with output and defs\n\n    return\n```", "```python\nasync def run(\n    self,\n    execution_requests: Sequence[ExecutionRequest],\n    deletion_requests: Sequence[DeleteCellRequest],\n) -> None:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n\n    # Add and remove cells to/from the graph.\n    self.mutate_graph(execution_requests, deletion_requests)\n\n    # Runner always runs stale ancestors, if any.\n    cells_to_run = roots.union(\n        dataflow.transitive_closure(\n            graph,\n            roots,\n            children=False,\n            inclusive=False,\n            predicate=lambda cell: cell.stale,\n        )\n    )\n    if self.execution_mode == \"autorun\":\n        # in autorun/eager mode, descendants are also run\n        pass\n\n    # The set of cells that need to be re-run due to cells being\n    # deleted/re-registered.\n    cells_that_were_children_of_mutated_cells = set()\n\n    # Cells that were unable to be added to the graph due to syntax errors\n    syntax_errors = {}\n\n    # Run the cells\n    for cell in cells_to_run:\n        output, defs = self.run_cell_sync(cell.cell_id, {})\n\n    # TODO: Handle the results\n    pass\n```", "```python\nasync def run(\n    self,\n    execution_requests: Sequence[ExecutionRequest],\n    deletion_requests: Sequence[DeleteCellRequest],\n) -> None:\n    # Mutate the graph\n    cells_to_run = self.mutate_graph(execution_requests, deletion_requests)\n\n    # Runner always runs stale ancestors, if any.\n    cells_to_run = cells_to_run.union(\n        dataflow.transitive_closure(\n            self.graph,\n            cells_to_run,\n            children=False,\n            inclusive=False,\n            predicate=lambda cell: cell.stale,\n        )\n    )\n    if self.execution_mode == \"autorun\":\n        # in autorun/eager mode, descendants are also run\n        cells_to_run = cells_to_run.union(\n            dataflow.transitive_closure(\n                self.graph,\n                cells_to_run,\n                children=True,\n                inclusive=True,\n                predicate=lambda cell: True,\n            )\n        )\n\n    # The set of cells that need to be re-run due to cells being\n    # deleted/re-registered.\n    cells_that_were_children_of_mutated_cells = set()\n\n    # Cells that were unable to be added to the graph due to syntax errors\n    syntax_errors = {}\n\n    # Run the cells\n    for cell_id in cells_to_run:\n        try:\n            output, defs = self.run_cell_sync(cell_id, {})\n            # Update the defs of the cell\n            self.graph.cells[cell_id].defs = defs\n        except Exception as e:\n            # Register the error\n            self.graph.cells[cell_id].errors.append(e)\n            # If the cell was a child of a mutated cell, we need to re-run it\n            if cell_id in cells_that_were_children_of_mutated_cells:\n                cells_that_were_children_of_mutated_cells.add(cell_id)\n            # If the error is a syntax error, we need to mark it\n            if isinstance(e, SyntaxError):\n                syntax_errors[cell_id] = e\n\n    # If there were any syntax errors, print them\n    for cell_id, error in syntax_errors.items():\n        print(f\"Syntax error in cell {cell_id}: {error}\")\n```"]}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _has_parent_id(\n        self, child: UIElement[Any, Any], parent_id: UIElementId\n    ) -> bool:\n        \"\"\"Returns True if `child` has id `parent_id` or is a view of it\"\"\"\n        if child._id == parent_id:\n            return True\n        elif child._lens is not None:\n            element_ref = self._objects.get(child._lens.parent_id)\n            element = element_ref() if element_ref is not None else None\n            if element is not None:\n------------------------------\n------------------------------\n@staticmethod\n    def has_openai() -> bool:\n        \"\"\"Return True if openai is installed.\"\"\"\n        return importlib.util.find_spec(\"openai\") is not None\n\n    @staticmethod\n    def has_pandas() -> bool:\n        \"\"\"Return True if pandas is installed.\"\"\"\n        return importlib.util.find_spec(\"pandas\") is not None\n\n    @staticmethod\n    def has_pyarrow() -> bool:\n        \"\"\"Return True if pyarrow is installed.\"\"\"\n        return importlib.util.find_spec(\"pyarrow\") is not None\n------------------------------\n------------------------------\nLOGGER.debug(\n            \"Session is not resumable, current state: %s\",\n            connection_state,\n        )\n        return None\n\n    def any_clients_connected(self, key: MarimoFileKey) -> bool:\n        \"\"\"Returns True if at least one client has an open socket.\"\"\"\n        if key.startswith(AppFileRouter.NEW_FILE):\n            return False\n------------------------------\n------------------------------\nreturn True\n    else:\n        return True\n------------------------------\n------------------------------\ndef should_send_code_to_frontend(self) -> bool:\n        \"\"\"Returns True if the server can send messages to the frontend.\"\"\"\n        return self.mode == SessionMode.EDIT or self.include_code\n------------------------------\n------------------------------\n@staticmethod\n    def has_watchdog() -> bool:\n        \"\"\"Return True if watchdog is installed.\"\"\"\n        return importlib.util.find_spec(\"watchdog\") is not None\n\n    @staticmethod\n    def has_ipython() -> bool:\n        \"\"\"Return True if IPython is installed.\"\"\"\n        return importlib.util.find_spec(\"IPython\") is not None\n\n    @staticmethod\n    def has_nbformat() -> bool:\n        \"\"\"Return True if nbformat is installed.\"\"\"\n        return importlib.util.find_spec(\"nbformat\") is not None\n------------------------------\n------------------------------\ndef running_in_notebook() -> bool:\n    \"\"\"Returns True if running in a marimo notebook, False otherwise\"\"\"\n\n    try:\n        ctx = get_context()\n    except ContextNotInitializedError:\n        return False\n    else:\n        return isinstance(ctx, KernelRuntimeContext)\n------------------------------\n------------------------------\nif name is not None:\n        # Validate name, or download from URL\n        # The second return value is an optional temporary directory. It is\n        # unused, but must be kept around because its lifetime on disk is bound\n        # to the life of the Python object\n        name, _ = validate_name(\n            name, allow_new_file=True, allow_directory=True\n        )\n        is_dir = os.path.isdir(name)\n        if os.path.exists(name) and not is_dir:\n------------------------------\n------------------------------\ndef is_win11() -> bool:\n    \"\"\"\n    Check if the operating system is Windows 11.\n\n    Returns:\n        bool: True if the OS is Windows 11, False otherwise.\n    \"\"\"\n    if hasattr(sys, \"getwindowsversion\"):\n        return cast(Any, sys).getwindowsversion().build >= 22000  # type: ignore[no-any-return]\n    return False\n------------------------------\n------------------------------\ndef check_dependencies():\n        if missing_packages:\n            return module_not_found_explainer\n    return check_dependencies, module_not_found_explainer\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_python_isolated() -> bool:\n# Natural Language Annotations: \"\"\"Returns True if not using system Python\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_python_isolated() -> bool:\n    import sys\n    return sys.executable is None\n```", "```python\ndef is_python_isolated() -> bool:\n    import sys\n    return sys.executable.lower().find(\"embeddable\") != -1\n```", "```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python\"\"\"\n    import sys\n    return sys.base_prefix != sys.prefix\n```"]}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Construct sets of cells that will need to be re-run.\n------------------------------\n------------------------------\ndef __init__(self) -> None:\n        # Modules that failed to reload: {module: mtime-on-failed-reload, ...}\n        self.failed: dict[str, float] = {}\n        # For replacing old code objects\n        self.old_objects: OldObjectsMapping = {}\n        # module-name -> mtime (module modification timestamps)\n        self.modules_mtimes: dict[str, float] = {}\n        # set of modules names known to be stale but haven't been reloaded\n        self.stale_modules: set[str] = set()\n------------------------------\n------------------------------\nclass CloneError(Exception):\n    \"\"\"Thrown when strict execution fail to deep copy or clone.\"\"\"\n------------------------------\n------------------------------\ndef __():\n    import importlib\n    import modules.components as complib\n    import modules.intro_problem as intro_problem\n    import modules.problems as problems\n    import modules.explainer as explainer\n\n    problems.configure_matplotlib()\n    _ = importlib.reload(complib)\n    _ = importlib.reload(explainer)\n    _ = importlib.reload(problems)\n    _ = importlib.reload(intro_problem)\n    return complib, explainer, importlib, intro_problem, problems\n------------------------------\n------------------------------\ndef modules(self) -> set[str]:\n        \"\"\"Modules imported by cells.\"\"\"\n        return set(\n            mod\n            for cell in self.graph.cells.values()\n            for mod in cell.imported_namespaces\n        )\n------------------------------\n------------------------------\nasync def install_missing_packages(\n        self, request: InstallMissingPackagesRequest\n    ) -> None:\n        \"\"\"Attempts to install packages for modules that cannot be imported\n\n        Runs cells affected by successful installation.\n        \"\"\"\n        assert self.package_manager is not None\n        if request.manager != self.package_manager.name:\n            # Swap out the package manager\n            self.package_manager = create_package_manager(request.manager)\n------------------------------\n------------------------------\nclass run_button(UIElement[Any, Any]):\n    \"\"\"\n    A button that can be used to trigger computation.\n\n    **Example.**\n\n    ```python\n    # a button that when clicked will have its value set to True;\n    # any cells referencing that button will automatically run.\n    button = mo.ui.run_button()\n    button\n    ```\n\n    ```python\n    slider = mo.ui.slider(1, 10)\n    slider\n    ```\n\n    ```python\n    # if the button hasn't been clicked, don't run.\n    mo.stop(not button.value)\n------------------------------\n------------------------------\ntry:\n        import numpy as np\n\n        numpy_installed = True\n    except ModuleNotFoundError:\n        pass\n    return (\n        matplotlib_installed,\n        missing_matplotlib_msg,\n        missing_numpy_msg,\n        np,\n        numpy_installed,\n        plt,\n    )\n------------------------------\n------------------------------\n**Defined UI Elements.** If the cell's `output` has UI elements\n        that are in `defs`, interacting with the output in the frontend will\n        trigger reactive execution of cells that reference the `defs` object.\n        For example, if `output` has a slider defined by the cell, then\n        scrubbing the slider will cause cells that reference `defs` to run.\n------------------------------\n------------------------------\n# module itself has been modified\n            return {}\n        except Exception:\n            # some modules like numpy fail when called with run_script;\n            # run_script takes a long time before failing on them, so\n            # don't try to analyze them again\n            self._failed_module_filenames.add(file)\n            return {}\n        else:\n            # False positives\n            self._module_dependencies[file] = finder.modules  # type: ignore[assignment]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def missing_modules(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Modules that will fail to import.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef missing_modules(self) -> set[str]:\n    # Modules that will fail to import\n    return set(self.modules()) - set(self.modules_mtimes.keys())\n```", "```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    return set(\n        mod\n        for mod in self.modules()\n        if mod not in self.failed and mod not in self.modules_mtimes\n    )\n```", "```python\ndef missing_modules(self) -> set[str]:\n    return set(\n        mod\n        for mod in self.modules()\n        if mod not in self.old_objects and mod not in self.failed\n    )\n```"]}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass Memory:\n    \"\"\"\n    Memory is used to store all the conversations in the system,\n    which should be initialized when creating a session.\n    \"\"\"\n\n    def __init__(self, session_id: str) -> None:\n        self.session_id = session_id\n        self.conversation = Conversation.init()\n------------------------------\n------------------------------\ndef load_examples(\n        self,\n    ) -> List[Conversation]:\n        if self.config.load_example:\n            return load_examples(\n                folder=self.config.example_base_path,\n                role_set={self.alias, \"Planner\"},\n            )\n        return []\n\n    def get_plugin_pool(self) -> List[PluginEntry]:\n        return self.plugin_pool\n------------------------------\n------------------------------\nclass Post:\n    \"\"\"\n    A post is the message used to communicate between two roles.\n    It should always have a text_message to denote the string message,\n    while other data formats should be put in the attachment.\n    The role can be either a User, a Planner, or others.\n------------------------------\n------------------------------\nreturn reply_post\n\n    def get_examples(self) -> List[Conversation]:\n        example_conv_list = load_examples(\n            self.config.example_base_path,\n            role_set=set(self.recipient_alias_set) | {self.alias, \"User\"},\n        )\n        return example_conv_list\n------------------------------\n------------------------------\nclass Plugin(ABC):\n    \"\"\"\n    base class for all plugins\n\n    the instance of the plugin is a callable object, which is the entry point for\n    the execution of the plugin function. The execution context and\n    the configuration of the plugin are passed to the plugin instance when it is created.\n    \"\"\"\n\n    def __init__(self, name: str, ctx: PluginContext, config: Dict[str, Any]) -> None:\n        \"\"\"\n        create a plugin instance, this method will be called by the runtime\n------------------------------\n------------------------------\n# Code for: class DocumentRetriever(Role):\n------------------------------\n------------------------------\ndef register_plugin(func: Union[Callable[..., Any], Type[Plugin]]):\n    \"\"\"\n    register a plugin, the plugin could be a class or a callable function\n\n    :param func: the plugin class or a callable function\n    \"\"\"\n    global register_plugin_inner\n------------------------------\n------------------------------\nclass DocumentRetrieverConfig(RoleConfig):\n    def _configure(self):\n        # default is the directory where this file is located\n        self.index_folder = self._get_str(\n            \"index_folder\",\n            os.path.join(\n                os.path.dirname(__file__),\n                \"knowledge_base\",\n            ),\n        )\n        self.size = self._get_int(\"size\", 5)\n        self.target_length = self._get_int(\"target_length\", 256)\n------------------------------\n------------------------------\nArgs:\n        id: the unique id of the post.\n        send_from: the role who sends the post.\n        send_to: the role who receives the post.\n        message: the text message in the post.\n        attachment_list: a list of attachments in the post.\n\n    \"\"\"\n\n    id: str\n    send_from: RoleName\n    send_to: RoleName\n    message: str\n    attachment_list: List[Attachment]\n------------------------------\n------------------------------\nclass RoleRegistry(ComponentRegistry[RoleEntry]):\n    def __init__(\n        self,\n        file_glob: Union[str, List[str]],\n        ttl: Optional[timedelta] = None,\n    ) -> None:\n        super().__init__(file_glob, ttl)\n\n    def _load_component(self, path: str) -> Tuple[str, RoleEntry]:\n        entry: Optional[RoleEntry] = RoleEntry.from_yaml_file(file_path=path)\n        assert entry, f\"failed to loading role from {path}\"\n        return entry.name, entry\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def load_examples(\n# Natural Language Annotations: \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```\nfrom typing import List, Set\nimport os\n\ndef load_examples(folder: str, role_set: Set[str]) -> List[Conversation]:\n    examples = []\n    for root, _, files in os.walk(folder):\n        for file in files:\n            if file.endswith(\".txt\"):  # assuming examples are text files\n                with open(os.path.join(root, file), \"r\") as f:\n                    conversation = f.read()\n                    if any(role in conversation for role in role_set):\n                        examples.append(conversation)\n    return examples\n```", "```python\ndef load_examples(folder: str, role_set: Set[str]) -> List[Conversation]:\n    # logic to load examples from folder and filter by role_set\n    pass\n```", "```python\ndef load_examples(folder: str, role_set: Set[str]) -> List[Conversation]:\n    pass  # Your implementation here\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nself.logger.info(\n            f\"Selected plugin pool: {[p.name for p in self.selected_plugin_pool.get_plugins()]}\",\n        )\n------------------------------\n------------------------------\nclass Plugin(ABC):\n    \"\"\"\n    base class for all plugins\n\n    the instance of the plugin is a callable object, which is the entry point for\n    the execution of the plugin function. The execution context and\n    the configuration of the plugin are passed to the plugin instance when it is created.\n    \"\"\"\n\n    def __init__(self, name: str, ctx: PluginContext, config: Dict[str, Any]) -> None:\n        \"\"\"\n        create a plugin instance, this method will be called by the runtime\n------------------------------\n------------------------------\nimport json\nimport os\nimport re\nimport sys\n\nimport yaml\n\nhead = \"\"\"\nThe task is to complete the sample code described in the <TASK DESCRIPTION> block below.\nComplete the code, run it successfully, and finally present the code back. \nPlease \"copy and paste\" the following task description in your request to ensure \nthat the task description is correct and complete.\n\n<TASK DESCRIPTION>\n\"\"\"\n\ntail = \"\"\"\n</TASK DESCRIPTION>\n\"\"\"\n\n\n# Code for: def replace_with_same_indent(original, target, replacement):\n------------------------------\n------------------------------\ndef stop(self) -> None:\n        \"\"\"\n        Stop the TaskWeaver app. This function must be called before the app exits.\n        \"\"\"\n        self.session_manager.stop_all_sessions()\n\n    @staticmethod\n    def discover_app_dir(\n        app_dir: Optional[str] = None,\n    ) -> Tuple[str, bool, bool]:\n        \"\"\"\n        Discover the app directory from the given path or the current working directory.\n        \"\"\"\n        from taskweaver.utils.app_utils import discover_app_dir\n------------------------------\n------------------------------\nclass SelectedPluginPool:\n    def __init__(self):\n        self.selected_plugin_pool = []\n        self._previous_used_plugin_cache = []  # cache the plugins used in the previous code generation\n\n\n\n\n\n\n\n    def __len__(self) -> int:\n        return len(self.selected_plugin_pool)\n\n\n\n\n\n\n\n\n\n\n\n\n    def get_plugins(self) -> List[PluginEntry]:\n        return self.selected_plugin_pool\n------------------------------\n------------------------------\n:return: the id of the artifact\n        \"\"\"\n        ...\n------------------------------\n------------------------------\ndef select_plugins_for_prompt(\n        self,\n        query: str,\n    ) -> List[PluginEntry]:\n        selected_plugins = self.plugin_selector.plugin_select(\n            query,\n            self.config.auto_plugin_selection_topk,\n        )\n        self.selected_plugin_pool.add_selected_plugins(selected_plugins)\n        self.logger.info(f\"Selected plugins: {[p.name for p in selected_plugins]}\")\n        self.logger.info(\n------------------------------\n------------------------------\n@tracing_decorator\n    def update_session_var(\n        self,\n        variables: Dict[str, str],\n    ):\n        \"\"\"\n        Update the session variables.\n        :param variables: The variables to update.\n        \"\"\"\n        assert self.config.num_code_interpreters > 0, \"No code_interpreter role is provided.\"\n        self.session_var.update(variables)\n        # get the alias of the code_interpreter\n------------------------------\n------------------------------\ndef select_plugins_for_prompt(\n        self,\n        user_query: str,\n    ) -> List[PluginEntry]:\n        selected_plugins = self.plugin_selector.plugin_select(\n            user_query,\n            self.config.auto_plugin_selection_topk,\n        )\n        self.selected_plugin_pool.add_selected_plugins(selected_plugins)\n        self.logger.info(f\"Selected plugins: {[p.name for p in selected_plugins]}\")\n        self.logger.info(\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n# Natural Language Annotations: \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    self.selected_plugin_pool.extend(external_plugin_pool)\n```", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]) -> None:\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    self.selected_plugin_pool.extend(external_plugin_pool)\n```", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    self.selected_plugin_pool += external_plugin_pool\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nif self.config.enable_auto_plugin_selection:\n            # filter out plugins that are not used in the generated code\n            self.selected_plugin_pool.filter_unused_plugins(code=generated_code)\n\n        if prompt_log_path is not None:\n            self.logger.dump_prompt_file(prompt, prompt_log_path)\n\n        self.tracing.set_span_attribute(\"code\", generated_code)\n\n        return post_proxy.post\n------------------------------\n------------------------------\nif self.config.enable_auto_plugin_selection:\n                # here the code is in json format, not really code\n                self.selected_plugin_pool.filter_unused_plugins(\n                    code=llm_response[\"content\"],\n                )\n            return post_proxy.end()\n        else:\n            self.tracing.set_span_status(\n                \"ERROR\",\n                f\"Unexpected response from LLM {llm_response}\",\n            )\n------------------------------\n------------------------------\nclass Conversation:\n    \"\"\"A conversation denotes the interaction with the user, which is a collection of rounds.\n    The conversation is also used to construct the Examples.\n\n    Args:\n        id: the unique id of the conversation.\n        rounds: a list of rounds.\n        plugins: a list of plugins that are used in the conversation.\n        enabled: whether the conversation is enabled, used for Example only.\n    \"\"\"\n------------------------------\n------------------------------\nclass Plugin(ABC):\n    \"\"\"\n    base class for all plugins\n\n    the instance of the plugin is a callable object, which is the entry point for\n    the execution of the plugin function. The execution context and\n    the configuration of the plugin are passed to the plugin instance when it is created.\n    \"\"\"\n\n    def __init__(self, name: str, ctx: PluginContext, config: Dict[str, Any]) -> None:\n        \"\"\"\n        create a plugin instance, this method will be called by the runtime\n------------------------------\n------------------------------\nclass PluginSelector:\n    @inject\n    def __init__(\n        self,\n        plugin_registry: PluginRegistry,\n        llm_api: LLMApi,\n        plugin_only: bool = False,\n    ):\n        if plugin_only:\n            self.available_plugins = [p for p in plugin_registry.get_list() if p.plugin_only is True]\n        else:\n            self.available_plugins = plugin_registry.get_list()\n        self.llm_api = llm_api\n        self.plugin_embedding_dict: Dict[str, List[float]] = {}\n------------------------------\n------------------------------\n# This is used to define common functions/tools that could be used by different plugins\nfrom __future__ import annotations\n\nimport json\nfrom typing import Any, Dict, Union\nfrom urllib.parse import urljoin\n\n\n# Code for: def make_api_call(\n------------------------------\n------------------------------\nif len(plugins_to_embedded) == 0:\n            print(\"All plugins are up-to-date.\")\n            return\n\n        plugin_embeddings = self.llm_api.get_embedding_list([text for idx, text in plugins_to_embedded])\n------------------------------\n------------------------------\nimport json\nimport os\nimport re\nimport sys\n\nimport yaml\n\nhead = \"\"\"\nThe task is to complete the sample code described in the <TASK DESCRIPTION> block below.\nComplete the code, run it successfully, and finally present the code back. \nPlease \"copy and paste\" the following task description in your request to ensure \nthat the task description is correct and complete.\n\n<TASK DESCRIPTION>\n\"\"\"\n\ntail = \"\"\"\n</TASK DESCRIPTION>\n\"\"\"\n\n\n# Code for: def replace_with_same_indent(original, target, replacement):\n------------------------------\n------------------------------\nf\"Plugin {p.name} is using embedding model {p.meta_data.embedding_model}, \"\n                f\"which is different from the one used by current session\"\n                f\" ({self.llm_api.embedding_service.config.embedding_model}). \"\n                f\"Please use the same embedding model or refresh the plugin embedding.\"\n                + self.exception_message_for_refresh\n            )\n            # check if the plugin has been modified\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def filter_unused_plugins(self, code: str):\n# Natural Language Annotations: \"\"\"\n        Filter out plugins that are not used in the code generated by LLM\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = set()\n\n    # Extract the plugin names from the generated code\n    for plugin in self.selected_plugin_pool.get_list():\n        if plugin.name in code:\n            used_plugins.add(plugin.name)\n\n    # Filter out plugins that are not used in the generated code\n    self.selected_plugin_pool.plugins = [p for p in self.selected_plugin_pool.plugins if p.name in used_plugins]\n```", "```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = []\n    for plugin in self.available_plugins:\n        if plugin.name in code:\n            used_plugins.append(plugin)\n    self.available_plugins = used_plugins\n```", "```python\ndef filter_unused_plugins(self, code: str):\n    used_plugins = []\n    for plugin in self.selected_plugin_pool:\n        if plugin.name in code:\n            used_plugins.append(plugin)\n    self.selected_plugin_pool = used_plugins\n```"]}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nfor post in round.post_list:\n                post.message = PromptUtil.remove_parts(\n                    post.message,\n                    delimiter=PromptUtil.DELIMITER_TEMPORAL,\n                )\n        # Remove the delimiters from the text of the posts of the last round\n        for post in rounds_from_role[-1].post_list:\n            post.message = PromptUtil.remove_all_delimiters(post.message)\n------------------------------\n------------------------------\n@staticmethod\n    def remove_delimiter(text: str, delimiter: Tuple[str, str]):\n        \"\"\"Remove the specified delimiter from the text.\"\"\"\n        text = text.replace(delimiter[0], \"\")\n        text = text.replace(delimiter[1], \"\")\n        return text\n\n    @staticmethod\n------------------------------\n------------------------------\n@staticmethod\n    def remove_parts(text: str, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Remove the parts of the text that are wrapped by the specified delimiters.\"\"\"\n        while True:\n            # Find the start of the temporal part\n            start_index = text.find(delimiter[0])\n            # Find the end of the temporal part\n            end_index = text.find(delimiter[1], start_index + len(delimiter[0]))\n------------------------------\n------------------------------\n# extract all rounds from memory\n        rounds = memory.get_role_rounds(\n            role=self.alias,\n            include_failure_rounds=False,\n        )\n\n        # obtain the query from the last round\n        query = rounds[-1].post_list[-1].message\n------------------------------\n------------------------------\n@staticmethod\n    def get_all_delimiters() -> List[Tuple[str, str]]:\n        \"\"\"Get all the delimiters.\"\"\"\n        return [getattr(PromptUtil, attr) for attr in dir(PromptUtil) if attr.startswith(\"DELIMITER_\")]\n------------------------------\n------------------------------\ndef del_attachment(self, type_list: List[AttachmentType]) -> None:\n        \"\"\"Delete all the attachments of the given type.\"\"\"\n        self.attachment_list = [attachment for attachment in self.attachment_list if attachment.type not in type_list]\n------------------------------\n------------------------------\nclass PromptUtil:\n    DELIMITER_TEMPORAL: Tuple[str, str] = (\"{{DELIMITER_START_TEMPORAL}}\", \"{{DELIMITER_END_TEMPORAL}}\")\n\n    @staticmethod\n    def wrap_text_with_delimiter(text, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Wrap the provided text with the specified start and end delimiters.\"\"\"\n        return f\"{delimiter[0]}{text}{delimiter[1]}\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def remove_all_delimiters(text: str) -> str:\n# Natural Language Annotations: \"\"\"Remove all the delimiters from the text.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    for delimiter in PromptUtil.get_all_delimiters():\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```", "```python\ndef remove_all_delimiters(text: str) -> str:\n    for delimiter in PromptUtil.get_all_delimiters():\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    for delimiter in PromptUtil.get_all_delimiters():\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```"]}, "reflex-reflex/app.py-_enable_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"Base state for the app.\"\"\"\n\nimport reflex as rx\n\n\n# Code for: class State(rx.State):\n------------------------------\n------------------------------\nclass State(rx.State):\n    \"\"\"The app state.\"\"\"\n\n    ...\n------------------------------\n------------------------------\ndef _add_cors(self):\n        \"\"\"Add CORS middleware to the app.\"\"\"\n        self.api.add_middleware(\n            cors.CORSMiddleware,\n            allow_credentials=True,\n            allow_methods=[\"*\"],\n            allow_headers=[\"*\"],\n            allow_origins=[\"*\"],\n        )\n\n    @property\n    def state_manager(self) -> StateManager:\n        \"\"\"Get the state manager.\n\n        Returns:\n            The initialized state manager.\n------------------------------\n------------------------------\ndef compile_state(state: Type[BaseState]) -> dict:\n    \"\"\"Compile the state of the app.\n\n    Args:\n        state: The app state object.\n------------------------------\n------------------------------\nclass ScaleFade(Transition):\n    \"\"\"Fade component can be scaled and reverse your app.\"\"\"\n\n    tag = \"ScaleFade\"\n\n    # The initial scale of the element\n    initial_scale: Var[float]\n\n    # If true, the element will transition back to exit state\n    reverse: Var[bool]\n------------------------------\n------------------------------\ndef get_state_manager() -> StateManager:\n    \"\"\"Get the state manager for the app that is currently running.\n\n    Returns:\n        The state manager.\n    \"\"\"\n    app = getattr(prerequisites.get_app(), constants.CompileVars.APP)\n    return app.state_manager\n------------------------------\n------------------------------\n@abstractmethod\n    async def get_state(self, token: str) -> BaseState:\n        \"\"\"Get the state for a token.\n\n        Args:\n            token: The token to get the state for.\n\n        Returns:\n            The state for the token.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def set_state(self, token: str, state: BaseState):\n        \"\"\"Set the state for a token.\n------------------------------\n------------------------------\nArgs:\n        state: The app state object.\n\n    Returns:\n        A dictionary of the compiled state.\n    \"\"\"\n    try:\n        initial_state = state(_reflex_internal_init=True).dict(initial=True)\n    except Exception as e:\n        console.warn(\n            f\"Failed to compile initial state with computed vars, excluding them: {e}\"\n        )\n        initial_state = state(_reflex_internal_init=True).dict(include_computed=False)\n    return format.format_state(initial_state)\n------------------------------\n------------------------------\nclass Event(Base):\n    \"\"\"An event that describes any state change in the app.\"\"\"\n\n    # The token to specify the client that the event is for.\n    token: str\n\n    # The event name.\n    name: str\n\n    # The routing data where event occurred\n    router_data: Dict[str, Any] = {}\n\n    # The event payload.\n    payload: Dict[str, Any] = {}\n\n    @property\n    def substate_token(self) -> str:\n        \"\"\"Get the substate token for the event.\n------------------------------\n------------------------------\nclass State(State):\n    \"\"\"The app state.\"\"\"\n\n    # A dict from the chat name to the list of questions and answers.\n    chats: dict[str, list[QA]] = DEFAULT_CHATS\n\n    # The current chat name.\n    current_chat = \"Intros\"\n\n    # The current question.\n    question: str\n\n    # Whether we are processing the question.\n    processing: bool = False\n\n    # The name of the new chat.\n    new_chat_name: str = \"\"\n\n    # Whether the drawer is open.\n    drawer_open: bool = False\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _enable_state(self) -> None:\n# Natural Language Annotations: \"\"\"Enable state for the app.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n```", "```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    self.state = True\n```", "```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    self.state_manager.enable()\n```"]}, "reflex-reflex/app.py-_add_optional_endpoints": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __call__(self) -> FastAPI:\n        \"\"\"Run the backend api instance.\n\n        Returns:\n            The backend api.\n        \"\"\"\n        return self.api\n\n    def _add_default_endpoints(self):\n        \"\"\"Add default api endpoints (ping).\"\"\"\n        # To test the server.\n        self.api.get(str(constants.Endpoint.PING))(ping)\n------------------------------\n------------------------------\nlambda f: f.result()\n)\n# Wait for the compile to finish in prod mode to ensure all optional endpoints are mounted.\nif is_prod_mode():\n    compile_future.result()\n------------------------------\n------------------------------\n\"\"\"A file upload component.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom typing import Callable, ClassVar, Dict, List, Optional\n------------------------------\n------------------------------\n# Valid children components\n    _valid_children: List[str] = [\"Label\"]\n\n    # Array of endpoints in { x, y } format. These endpoints would be used to draw the ReferenceLine.\n    segment: List[Any] = []\n------------------------------\n------------------------------\nclass Endpoint(Enum):\n    \"\"\"Endpoints for the reflex backend API.\"\"\"\n\n    PING = \"ping\"\n    EVENT = \"_event\"\n    UPLOAD = \"_upload\"\n    AUTH_CODESPACE = \"auth-codespace\"\n\n    def __str__(self) -> str:\n        \"\"\"Get the string representation of the endpoint.\n\n        Returns:\n            The path for the endpoint.\n        \"\"\"\n        return f\"/{self.value}\"\n\n    def get_url(self) -> str:\n        \"\"\"Get the URL for the endpoint.\n------------------------------\n------------------------------\nclass AlertDialogDescription(RadixThemesComponent):\n    \"\"\"An optional accessible description that is announced when the dialog is opened.\n    This part is based on the Text component with a pre-defined font size.\n    \"\"\"\n\n    tag = \"AlertDialog.Description\"\n------------------------------\n------------------------------\nclass UploadValueError(ReflexError, ValueError):\n    \"\"\"Custom ValueError for upload related errors.\"\"\"\n------------------------------\n------------------------------\ndef add_imports(self) -> ImportDict | list[ImportDict]:\n        \"\"\"Add imports for the Theme component.\n------------------------------\n------------------------------\nclass UploadFilesProvider(Component):\n    \"\"\"AppWrap component that provides a dict of selected files by ID via useContext.\"\"\"\n\n    library = f\"/{Dirs.CONTEXTS_PATH}\"\n    tag = \"UploadFilesProvider\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_optional_endpoints(self):\n# Natural Language Annotations: \"\"\"Add optional api endpoints (_upload).\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    self.api.get(str(constants.Endpoint.UPLOAD))(upload)\n```", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    # To handle file uploads.\n    self.api.post(str(constants.Endpoint.UPLOAD))(self.upload)\n```", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    self.api.post(str(constants.Endpoint.UPLOAD))(self._upload)\n```"]}, "reflex-reflex/app.py-add_page": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            component: The component to display at the page.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n        \"\"\"\n        if component is None:\n            component = Default404Page.create()\n        self.add_page(\n------------------------------\n------------------------------\nNote: the decorated functions still need to be imported.\n\n    Args:\n        route: The route to reach the page.\n        title: The title of the page.\n        image: The favicon of the page.\n        description: The description of the page.\n        meta: Additional meta to add to the page.\n        on_load: The event handler(s) called when the page load.\n        script_tags: scripts to attach to the page\n\n    Returns:\n        The decorated function.\n    \"\"\"\n------------------------------\n------------------------------\ndef add_meta(\n    page: Component,\n    title: str,\n    image: str,\n    meta: list[dict],\n    description: str | None = None,\n) -> Component:\n    \"\"\"Add metadata to a page.\n\n    Args:\n        page: The component for the page.\n        title: The title of the page.\n        image: The image for the page.\n        meta: The metadata list.\n        description: The description of the page.\n------------------------------\n------------------------------\ndef page(\n    route: str | None = None,\n    title: str | None = None,\n    image: str | None = None,\n    description: str | None = None,\n    meta: list[Any] | None = None,\n    script_tags: list[Any] | None = None,\n    on_load: Any | list[Any] | None = None,\n):\n    \"\"\"Decorate a function as a page.\n\n    rx.App() will automatically call add_page() for any method decorated with page\n    when App.compile is called.\n\n    All defaults are None because they will use the one from add_page().\n------------------------------\n------------------------------\ndef make_default_page_title(app_name: str, route: str) -> str:\n    \"\"\"Make a default page title from a route.\n\n    Args:\n        app_name: The name of the app owning the page.\n        route: The route to make the title from.\n\n    Returns:\n        The default page title.\n    \"\"\"\n    title = constants.DefaultPage.TITLE.format(app_name, route)\n    return to_title_case(title, \" \")\n------------------------------\n------------------------------\n\"\"\"\n\n    COMPILE_PAGE_ARGS_BY_ROUTE = {}\n    COMPILE_APP_APP_ROOT: Component | None = None\n    CUSTOM_COMPONENTS: set[CustomComponent] | None = None\n    STYLE: ComponentStyle | None = None\n\n    @classmethod\n    def compile_page(cls, route: str):\n        \"\"\"Compile a page.\n\n        Args:\n            route: The route of the page to compile.\n\n        Returns:\n            The path and code of the compiled page.\n        \"\"\"\n        return compile_page(*cls.COMPILE_PAGE_ARGS_BY_ROUTE[route])\n------------------------------\n------------------------------\nself.add_page(\n            component=wait_for_client_redirect(self._generate_component(component)),\n            route=constants.Page404.SLUG,\n            title=title or constants.Page404.TITLE,\n            image=image or constants.Page404.IMAGE,\n            description=description or constants.Page404.DESCRIPTION,\n            on_load=on_load,\n            meta=meta,\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_page(\n# Natural Language Annotations: \"\"\"Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_page(\n    component: Component,\n    route: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    image: str | None = None,\n    on_load: Any | list[Any] | None = None,\n    meta: list[dict] | None = None,\n):\n    \"\"\"Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    if route is None:\n        if callable(component):\n            route = component.__name__\n        else:\n            raise ValueError(\"Route must be specified for non-callable components.\")\n\n    # Add the page to the app\n    # This method will depend on how your app class is structured\n    # This is a placeholder for the actual implementation\n    pass\n```", "```python\ndef add_page(\n    component: Component,\n    route: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    image: str | None = None,\n    on_load: Any | list[Any] | None = None,\n    meta: list[dict] | None = None,\n):\n    if route is None:\n        if callable(component):\n            route = component.__name__\n        else:\n            raise ValueError(\"A route must be provided if the component is not callable.\")\n\n    if route in self.pages:\n        raise ValueError(f\"The specified route name {route} already exists.\")\n\n    self.pages[route] = {\n        \"component\": component,\n        \"title\": title,\n        \"description\": description,\n        \"image\": image,\n        \"on_load\": on_load,\n        \"meta\": meta,\n    }\n```", "```python\ndef add_page(\n    component: Component,\n    route: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    image: str | None = None,\n    on_load: Any | list[Any] | None = None,\n    meta: list[Any] | None = None,\n):\n    if route is None:\n        if callable(component):\n            route = component.__name__\n        else:\n            raise ValueError(\"A route must be provided when the component is not a callable.\")\n\n    if route in self.routes:\n        raise ValueError(\"The specified route name already exists.\")\n\n    self.routes[route] = {\n        \"component\": component,\n        \"title\": title,\n        \"description\": description,\n        \"image\": image,\n        \"on_load\": on_load,\n        \"meta\": meta,\n    }\n```"]}, "reflex-reflex/app.py-_setup_overlay_component": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nraise ValueError(\n                    f\"Can not compile, the tag {import_name} is used multiple time from {lib} and {used_tags[import_name]}\"\n                )\n            if import_name is not None:\n                used_tags[import_name] = lib\n------------------------------\n------------------------------\n# When the component is referenced by more than one page, render it\n        # to be included in the STATEFUL_COMPONENTS module.\n        # Skip this step in dev mode, thereby avoiding potential hot reload errors for larger apps\n        if (\n            isinstance(component, StatefulComponent)\n            and component.references > 1\n            and is_prod_mode()\n        ):\n            # Reset this flag to render the actual component.\n            component.rendered_as_shared = False\n------------------------------\n------------------------------\ndef _dill_reduce_state(pickler, obj):\n    if obj is not State and issubclass(obj, State):\n        # Avoid serializing subclasses of State, instead get them by reference from the State class.\n        pickler.save_reduce(State.get_class_substate, (obj.get_full_name(),), obj=obj)\n    else:\n        dill.Pickler.dispatch[type](pickler, obj)\n------------------------------\n------------------------------\nclass ConnectionModal(Component):\n    \"\"\"A connection status modal window.\"\"\"\n\n    @classmethod\n    def create(cls, comp: Optional[Component] = None) -> Component:\n        \"\"\"Create a connection banner component.\n\n        Args:\n            comp: The component to render when there's a server connection error.\n------------------------------\n------------------------------\n# When true, signifies that it is purely visual, carries no semantic meaning, and ensures it is not present in the accessibility tree.\n    decorative: Var[bool]\n------------------------------\n------------------------------\nif stateful_component is not None:\n                return stateful_component\n        return component\n------------------------------\n------------------------------\nasync def test_connection_banner(connection_banner: AppHarness):\n    \"\"\"Test that the connection banner is displayed when the websocket drops.\n\n    Args:\n        connection_banner: AppHarness instance.\n    \"\"\"\n    assert connection_banner.app_instance is not None\n    assert connection_banner.backend is not None\n    driver = connection_banner.frontend()\n\n    ss = SessionStorage(driver)\n    assert connection_banner._poll_for(\n        lambda: ss.get(\"token\") is not None\n    ), \"token not found\"\n------------------------------\n------------------------------\nRaises:\n            ValueError: If the event namespace is not provided in the config.\n                        Also, if there are multiple client subclasses of rx.BaseState(Subclasses of rx.BaseState should consist\n                        of the DefaultState and the client app state).\n        \"\"\"\n        if \"connect_error_component\" in kwargs:\n            raise ValueError(\n                \"`connect_error_component` is deprecated, use `overlay_component` instead\"\n            )\n------------------------------\n------------------------------\ndef remove_tailwind_from_postcss() -> tuple[str, str]:\n    \"\"\"If tailwind is not to be used, remove it from postcss.config.js.\n\n    Returns:\n        The path and code of the compiled postcss.config.js.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = str(get_web_dir() / constants.Dirs.POSTCSS_JS)\n\n    code = [\n        line\n        for line in Path(output_path).read_text().splitlines(keepends=True)\n        if \"tailwindcss: \" not in line\n    ]\n------------------------------\n------------------------------\nif (\n            hasattr(render_fn, \"__qualname__\")\n            and render_fn.__qualname__ == ComponentState.create.__qualname__\n        ):\n            raise TypeError(\n                \"Using a ComponentState as `render_fn` inside `rx.foreach` is not supported yet.\"\n            )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _setup_overlay_component(self):\n# Natural Language Annotations: \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _setup_overlay_component(self):\n    if not isinstance(self.state, State) and self.overlay_component is None:\n        self.overlay_component = ConnectionModal.create(None)\n```", "```python\ndef _setup_overlay_component(self):\n    \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\n\n    if not self.state and not self.overlay_component:\n        return None\n```", "```python\ndef _setup_overlay_component(self):\n    if not hasattr(self.state, \"ConnectionModal\") and self.config.overlay_component is None:\n        return None\n    return self.state.ConnectionModal.create()\n```"]}, "reflex-reflex/app.py-_compile": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef compile_page(\n    path: str, component: Component, state: Type[BaseState]\n) -> tuple[str, str]:\n    \"\"\"Compile a single page.\n\n    Args:\n        path: The path to compile the page to.\n        component: The component to compile.\n        state: The app state.\n\n    Returns:\n        The path and code of the compiled page.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_page_path(path)\n------------------------------\n------------------------------\n\"\"\"Welcome to Reflex! This file outlines the steps to create a basic app.\"\"\"\n\nimport reflex as rx\n\nfrom rxconfig import config\n\n\n# Code for: class State(rx.State):\n\n\n# Code for: def index() -> rx.Component:\n\n\napp = rx.App()\napp.add_page(index)\n------------------------------\n------------------------------\ndef compile_app(app_root: Component) -> tuple[str, str]:\n    \"\"\"Compile the app root.\n\n    Args:\n        app_root: The app root component to compile.\n\n    Returns:\n        The path and code of the compiled app wrapper.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_page_path(constants.PageNames.APP_ROOT)\n\n    # Compile the document root.\n    code = _compile_app(app_root)\n    return output_path, code\n------------------------------\n------------------------------\ndef AppWithOnePage():\n    \"\"\"A reflex app with one page.\"\"\"\n    from rxconfig import config  # type: ignore\n\n    import reflex as rx\n\n    docs_url = \"https://reflex.dev/docs/getting-started/introduction/\"\n    filename = f\"{config.app_name}/{config.app_name}.py\"\n\n    class State(rx.State):\n        \"\"\"The app state.\"\"\"\n\n        pass\n------------------------------\n------------------------------\ndef get_compiled_app(reload: bool = False, export: bool = False) -> ModuleType:\n    \"\"\"Get the app module based on the default config after first compiling it.\n\n    Args:\n        reload: Re-import the app module from disk\n        export: Compile the app for export\n------------------------------\n------------------------------\n\"\"\"Base state for the app.\"\"\"\n\nimport reflex as rx\n\n\n# Code for: class State(rx.State):\n------------------------------\n------------------------------\ndef build(\n    deploy_url: str | None = None,\n    for_export: bool = False,\n):\n    \"\"\"Build the app for deployment.\n\n    Args:\n        deploy_url: The deployment URL.\n        for_export: Whether the build is for export.\n    \"\"\"\n    wdir = prerequisites.get_web_dir()\n\n    # Clean the static directory if it exists.\n    path_ops.rm(str(wdir / constants.Dirs.STATIC))\n\n    # The export command to run.\n    command = \"export\"\n------------------------------\n------------------------------\ndef NavigationApp():\n    \"\"\"Reflex app with links for navigation.\"\"\"\n    import reflex as rx\n\n    class State(rx.State):\n        is_external: bool = True\n\n    app = rx.App()\n------------------------------\n------------------------------\nThis has to be done in the MainThread for py38 and py39 compatibility, so the\n        decorated pages are added to the app before the app is compiled (in a thread)\n        to workaround REF-2172.\n\n        This can move back into `compile_` when py39 support is dropped.\n        \"\"\"\n        # Add the @rx.page decorated pages to collect on_load events.\n        for render, kwargs in DECORATED_PAGES[get_config().app_name]:\n            self.add_page(render, **kwargs)\n------------------------------\n------------------------------\n\"\"\"Welcome to Reflex! This file outlines the steps to create a basic app.\"\"\"\n\nfrom typing import Callable\n\nimport reflex as rx\n\nfrom .pages import chatapp_page, datatable_page, forms_page, graphing_page, home_page\nfrom .sidebar import sidebar\nfrom .state import State\nfrom .styles import *\n\nmeta = [\n    {\n        \"name\": \"viewport\",\n        \"content\": \"width=device-width, shrink-to-fit=no, initial-scale=1\",\n    },\n]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _compile(self, export: bool = False):\n# Natural Language Annotations: \"\"\"Compile the app and output it to the pages folder.\n\n        Args:\n            export: Whether to compile the app for export.\n\n        Raises:\n            ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n```", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n\n    # Get the app root.\n    app_root = self._app_root\n\n    # Compile the app root.\n    app_root_path, app_root_code = compile_app(app_root)\n\n    # Create the pages directory if it doesn't exist.\n    path_ops.mkdir(constants.Dirs.PAGES)\n\n    # Compile the app root.\n    app_root_path, app_root_code = compile_app(app_root)\n\n    # Compile each page.\n    for path, component in self._pages.items():\n        compile_page(path, component, self._state)\n\n    # If exporting, compile the app for export.\n    if export:\n        compile_app(app_root)\n```", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    # Compile the app root.\n    path, code = self._compile_app(self.app_root)\n\n    # Write the code to the output file.\n    self._write_to_path(path, code)\n\n    # Compile all pages.\n    for path, component, state in self.pages:\n        path, code = self._compile_page(path, component, state)\n        self._write_to_path(path, code)\n```"]}, "reflex-reflex/app.py-modify_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            token: The token to set the state for.\n            state: The state to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state for a token while holding exclusive lock.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state for the token.\n        \"\"\"\n        yield self.state()\n------------------------------\n------------------------------\nArgs:\n            token: The token to set the state for.\n            state: The state to set.\n        \"\"\"\n        pass\n\n    @contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state for a token while holding exclusive lock.\n\n        Args:\n            token: The token to modify the state for.\n------------------------------\n------------------------------\n@contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state associated with the given token and send update to frontend.\n\n        Args:\n            token: The state token to modify\n\n        Yields:\n            The state instance associated with the given token\n------------------------------\n------------------------------\nRaises:\n                RuntimeError: If the app has not been initialized yet.\n            \"\"\"\n            if self.event_namespace is None:\n                raise RuntimeError(\"App has not been initialized yet.\")\n------------------------------\n------------------------------\nYields:\n            The state for the token.\n        \"\"\"\n        async with self._lock(token) as lock_id:\n            state = await self.get_state(token)\n            yield state\n            await self.set_state(token, state, lock_id)\n\n    @staticmethod\n    def _lock_key(token: str) -> bytes:\n        \"\"\"Get the redis key for a token's lock.\n\n        Args:\n            token: The token to get the lock key for.\n------------------------------\n------------------------------\n# Wait for substates to be persisted.\n        for t in tasks:\n            await t\n\n    @contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state for a token while holding exclusive lock.\n\n        Args:\n            token: The token to modify the state for.\n------------------------------\n------------------------------\nArgs:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n# Natural Language Annotations: \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n\n    if self.event_namespace is None:\n        raise RuntimeError(\"App has not been initialized yet.\")\n\n    async with self._lock(token) as lock_id:\n        state = await self.get_state(token)\n        yield state\n        await self.set_state(token, state, lock_id)\n```", "```python\n@contextlib.asynccontextmanager\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state for a token while holding exclusive lock.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state for the token.\n    \"\"\"\n    async with self._lock(token) as lock_id:\n        state = await self.get_state(token)\n        yield state\n        await self.set_state(token, state, lock_id)\n```", "```python\n@contextlib.asynccontextmanager\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state associated with the given token and send update to frontend.\n\n    Args:\n        token: The state token to modify\n\n    Yields:\n        The state instance associated with the given token\n    \"\"\"\n    if self.event_namespace is None:\n        raise RuntimeError(\"App has not been initialized yet.\")\n\n    async with self._lock(token) as lock_id:\n        state = await self.get_state(token)\n        yield state\n        await self.set_state(token, state, lock_id)\n```"]}, "reflex-reflex/vars.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n------------------------------\n------------------------------\nclass Var:\n    \"\"\"An abstract var.\"\"\"\n\n    # The name of the var.\n    _var_name: str\n\n    # The type of the var.\n    _var_type: Type\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool\n\n    # Whether the var is a string literal.\n    _var_is_string: bool\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool\n\n    # Extra metadata associated with the Var\n    _var_data: Optional[VarData]\n\n    @classmethod\n------------------------------\n------------------------------\nReturns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n            TypeError: If _var_is_local or _var_is_string is not None.\n        \"\"\"\n        if _var_is_local is not None:\n            raise TypeError(\n                \"The _var_is_local argument is not supported for ImmutableVar.\"\n            )\n------------------------------\n------------------------------\nclass BaseVar(Var):\n    \"\"\"A base (non-computed) var of the app state.\"\"\"\n\n    # The name of the var.\n    _var_name: str = dataclasses.field()\n\n    # The type of the var.\n    _var_type: Type = dataclasses.field(default=Any)\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool = dataclasses.field(default=False)\n\n    # Whether the var is a string literal.\n    _var_is_string: bool = dataclasses.field(default=False)\n------------------------------\n------------------------------\n@classmethod\n    def create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n------------------------------\n------------------------------\nArgs:\n            fget: The getter function.\n            initial_value: The initial value of the computed var.\n            cache: Whether to cache the computed value.\n            deps: Explicit var dependencies to track.\n            auto_deps: Whether var dependencies should be auto-determined.\n            interval: Interval at which the computed var should be updated.\n            backend: Whether the computed var is a backend var.\n------------------------------\n------------------------------\nArgs:\n            key: The key to set.\n            value: The value to set.\n        \"\"\"\n        # Create a Var to collapse VarData encoded in f-string.\n        _var = Var.create(value, _var_is_string=False)\n        if _var is not None:\n            # Carry the imports/hooks when setting a Var as a value.\n            self._var_data = VarData.merge(self._var_data, _var._var_data)\n        super().__setitem__(key, value)\n------------------------------\n------------------------------\nArgs:\n        fget: The getter function.\n        initial_value: The initial value of the computed var.\n        cache: Whether to cache the computed value.\n        deps: Explicit var dependencies to track.\n        auto_deps: Whether var dependencies should be auto-determined.\n        interval: Interval at which the computed var should be updated.\n        backend: Whether the computed var is a backend var.\n------------------------------\n------------------------------\nArgs:\n            json: Whether to convert to a JSON string.\n\n        Returns:\n            The stringified var.\n        \"\"\"\n        fn = \"JSON.stringify\" if json else \"String\"\n        return self.operation(fn=fn, type_=str)\n\n    def to_int(self) -> Var:\n        \"\"\"Convert a var to an int.\n\n        Returns:\n            The parseInt var.\n        \"\"\"\n        return self.operation(fn=\"parseInt\", type_=int)\n\n    def __hash__(self) -> int:\n        \"\"\"Define a hash function for a var.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\n        if _var_is_local is not None:\n            raise TypeError(\n                \"The _var_is_local argument is not supported for ImmutableVar.\"\n            )\n\n        # Code to create and return the var\n```", "```python\ndef create(\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n    \"\"\"Create a var from a value.\"\"\"\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n\n    # Check if the value is JSON unserializable and raise an error if it is\n    if not is_json_serializable(value):\n        raise VarTypeError('The value is JSON-unserializable.')\n\n    # Create the var\n    _var = Var(value, _var_is_string=_var_is_string, _var_data=_var_data)\n\n    return _var\n```", "```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n    if _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_string argument is not supported for ImmutableVar.\"\n        )\n    # Create a Var to collapse VarData encoded in f-string.\n    _var = Var.create(value, _var_is_string=False)\n    if _var is not None:\n        # Carry the imports/hooks when setting a Var as a value.\n        self._var_data = VarData.merge(self._var_data, _var._var_data)\n    return _var\n```"]}, "reflex-reflex/vars.py-create_safe": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n------------------------------\n------------------------------\nclass Var:\n    \"\"\"An abstract var.\"\"\"\n\n    # The name of the var.\n    _var_name: str\n\n    # The type of the var.\n    _var_type: Type\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool\n\n    # Whether the var is a string literal.\n    _var_is_string: bool\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool\n\n    # Extra metadata associated with the Var\n    _var_data: Optional[VarData]\n\n    @classmethod\n------------------------------\n------------------------------\n@classmethod\n    def create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n------------------------------\n------------------------------\nclass BaseVar(Var):\n    \"\"\"A base (non-computed) var of the app state.\"\"\"\n\n    # The name of the var.\n    _var_name: str = dataclasses.field()\n\n    # The type of the var.\n    _var_type: Type = dataclasses.field(default=Any)\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool = dataclasses.field(default=False)\n\n    # Whether the var is a string literal.\n    _var_is_string: bool = dataclasses.field(default=False)\n------------------------------\n------------------------------\nArgs:\n            key: The key to set.\n            value: The value to set.\n        \"\"\"\n        # Create a Var to collapse VarData encoded in f-string.\n        _var = Var.create(value, _var_is_string=False)\n        if _var is not None:\n            # Carry the imports/hooks when setting a Var as a value.\n            self._var_data = VarData.merge(self._var_data, _var._var_data)\n        super().__setitem__(key, value)\n------------------------------\n------------------------------\n# The type of the var.\n    _var_type: Type = dataclasses.field(default=Any)\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool = dataclasses.field(default=False)\n\n    # Whether the var is a string literal.\n    _var_is_string: bool = dataclasses.field(default=False)\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool = dataclasses.field(default=False)\n------------------------------\n------------------------------\nArgs:\n            fget: The getter function.\n            initial_value: The initial value of the computed var.\n            cache: Whether to cache the computed value.\n            deps: Explicit var dependencies to track.\n            auto_deps: Whether var dependencies should be auto-determined.\n            interval: Interval at which the computed var should be updated.\n            backend: Whether the computed var is a backend var.\n------------------------------\n------------------------------\ndef const(name, value) -> Var:\n    \"\"\"Create a constant Var.\n\n    Args:\n        name: The name of the constant.\n        value: The value of the constant.\n\n    Returns:\n        The constant Var.\n    \"\"\"\n    if isinstance(name, list):\n        return Var.create_safe(\n            f\"const [{', '.join(name)}] = {value}\", _var_is_string=False\n        )\n    return Var.create_safe(f\"const {name} = {value}\", _var_is_string=False)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_safe(\n# Natural Language Annotations: \"\"\"Create a var from a value, asserting that it is not None.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create_safe(\n    cls,\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var:\n    assert value is not None, \"Value cannot be None\"\n    return cls.create(value, _var_is_local, _var_is_string, _var_data)\n```", "```python\ndef create_safe(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var:\n        \"\"\"Create a var from a value, asserting that it is not None.\"\"\"\n\n        assert value is not None, \"Value cannot be None\"\n        return Var.create(value, _var_is_local, _var_is_string, _var_data)\n```", "```python\ndef create_safe(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var:\n    \"\"\"Create a var from a value, asserting that it is not None.\"\"\"\n    assert value is not None, \"Value cannot be None.\"\n    return Var.create(value, _var_is_local, _var_is_string, _var_data)\n```"]}, "reflex-reflex/vars.py-foreach": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn self._replace(\n                _var_name=_var_name,\n                _var_type=bool,\n                _var_is_string=False,\n                merge_var_data=other._var_data,\n            )\n\n    def reverse(self) -> Var:\n        \"\"\"Reverse a list var.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n------------------------------\n------------------------------\nReturns:\n            The code to render the component.\n        \"\"\"\n        return self.component_fn(*self.get_prop_vars())\n------------------------------\n------------------------------\nRaises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\n        if not types._issubclass(self._var_type, list):\n            raise VarTypeError(f\"Cannot join non-list var {self._var_full_name}.\")\n------------------------------\n------------------------------\ndef call_event_fn(fn: Callable, arg: Union[Var, ArgsSpec]) -> list[EventSpec] | Var:\n    \"\"\"Call a function to a list of event specs.\n\n    The function should return a single EventSpec, a list of EventSpecs, or a\n    single Var. If the function takes in an arg, the arg will be passed to the\n    function. Otherwise, the function will be called with no args.\n\n    Args:\n        fn: The function to call.\n        arg: The argument to pass to the function.\n------------------------------\n------------------------------\n@classmethod\n    def create(\n        cls,\n        iterable: Var[Iterable] | Iterable,\n        render_fn: Callable,\n        **props,\n    ) -> Foreach:\n        \"\"\"Create a foreach component.\n\n        Args:\n            iterable: The iterable to create components from.\n            render_fn: A function from the render args to the component.\n            **props: The attributes to pass to each child component (deprecated).\n\n        Returns:\n            The foreach component.\n------------------------------\n------------------------------\nReturns:\n            The Var returned from calling the function.\n        \"\"\"\n        return self.fn(*args, **kwargs)\n------------------------------\n------------------------------\ndef upper(self) -> Var:\n        \"\"\"Convert a string var to uppercase.\n\n        Returns:\n            A var with the uppercase string.\n\n        Raises:\n            VarTypeError: If the var is not a string.\n        \"\"\"\n        if not types._issubclass(self._var_type, str):\n            raise VarTypeError(\n                f\"Cannot convert non-string var {self._var_full_name} to uppercase.\"\n            )\n------------------------------\n------------------------------\nArgs:\n            op: The operation to perform.\n            other: The other var to perform the operation on.\n            type_: The type of the operation result.\n            flip: Whether to flip the order of the operation.\n            fn: A function to apply to the operation.\n            invoke_fn: Whether to invoke the function.\n\n        Returns:\n            The operation result.\n------------------------------\n------------------------------\nReturns:\n            The indexed var.\n\n        Raises:\n            VarTypeError: If the var is not indexable.\n        \"\"\"\n        from reflex.utils import format\n------------------------------\n------------------------------\nReturns:\n            A var representing the type check.\n        \"\"\"\n        return self._replace(\n            _var_name=f\"typeof {self._var_full_name}\",\n            _var_type=str,\n            _var_is_string=False,\n            _var_full_name_needs_state_prefix=False,\n        )\n\n    def __eq__(self, other: Union[Var, Type]) -> Var:\n        \"\"\"Perform an equality comparison.\n\n        Args:\n            other: The other var to compare with.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def foreach(self, fn: Callable) -> Var:\n# Natural Language Annotations: \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not types._issubclass(self._var_type, list):\n        raise VarTypeError(f\"Cannot do foreach operation on non-list var {self._var_full_name}.\")\n\n    result = [fn(item) for item in self._var_data]\n\n    return self._replace(\n        _var_name=f\"foreach {self._var_name}\",\n        _var_type=list,\n        _var_is_string=False,\n        _var_data=result,\n    )\n```", "```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not types._issubclass(self._var_type, list):\n        raise VarTypeError(f\"Cannot apply foreach on non-list var {self._var_full_name}.\")\n\n    # Perform the foreach operation\n    result = [fn(component) for component in self._var_data]\n\n    # Create a new var to represent the result\n    return self._replace(\n        _var_name=f\"foreach {self._var_name}\",\n        _var_type=list,\n        _var_is_string=False,\n        _var_data=result,\n    )\n```", "```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not types._issubclass(self._var_type, list):\n        raise VarTypeError(f\"Cannot do foreach on non-list var {self._var_full_name}.\")\n    return [fn(item) for item in self._var_data]\n```"]}, "reflex-reflex/vars.py-get_default_value": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The value of the var.\n        \"\"\"\n        # If the state hasn't been initialized yet, return the default value.\n        if not super().__getattribute__(\"__dict__\"):\n            return super().__getattribute__(name)\n\n        inherited_vars = {\n            **super().__getattribute__(\"inherited_vars\"),\n            **super().__getattribute__(\"inherited_backend_vars\"),\n        }\n------------------------------\n------------------------------\ndef __neg__(self) -> Var:\n        \"\"\"Negate a var.\n\n        Returns:\n            The negated var.\n        \"\"\"\n        return self.operation(fn=\"-\")\n\n    def __abs__(self) -> Var:\n        \"\"\"Get the absolute value of a var.\n\n        Returns:\n            A var with the absolute value.\n        \"\"\"\n        return self.operation(fn=\"Math.abs\")\n\n    def length(self) -> Var:\n        \"\"\"Get the length of a list var.\n\n        Returns:\n            A var with the absolute value.\n------------------------------\n------------------------------\nArgs:\n            prop: The var to set the default value for.\n        \"\"\"\n        # Get the pydantic field for the var.\n        field = cls.get_fields()[prop._var_name]\n        if field.required:\n            default_value = prop.get_default_value()\n            if default_value is not None:\n                field.required = False\n                field.default = default_value\n        if (\n            not field.required\n            and field.default is None\n------------------------------\n------------------------------\nReturns:\n            The match component wrapped in a fragment or the match var.\n\n        Raises:\n            ValueError: If the return types are not vars when creating a match var for Var types.\n        \"\"\"\n        if default is None and types._issubclass(\n            type(match_cases[0][-1]), BaseComponent\n        ):\n            default = Fragment.create()\n------------------------------\n------------------------------\n# match cases and default should all be Vars at this point.\n        # Retrieve var data of every var in the match cases and default.\n        var_data = [\n            *[el._var_data for case in match_cases for el in case],\n            default._var_data,  # type: ignore\n        ]\n------------------------------\n------------------------------\nIf the value is already cached on the instance, return the cached value.\n\n        Args:\n            instance: the instance of the class accessing this computed var.\n            owner: the class that this descriptor is attached to.\n\n        Returns:\n            The value of the var for the given instance.\n        \"\"\"\n        if instance is None or not self._cache:\n            return super().__get__(instance, owner)\n------------------------------\n------------------------------\nArgs:\n            var: The variable to add a pydantic field for.\n            default_value: The default value of the field\n        \"\"\"\n        new_field = ModelField.infer(\n            name=var._var_name,\n            value=default_value,\n            annotation=var._var_type,\n            class_validators=None,\n            config=cls.__config__,  # type: ignore\n        )\n        cls.__fields__.update({var._var_name: new_field})\n------------------------------\n------------------------------\nReturns:\n            The indexed var.\n\n        Raises:\n            VarTypeError: If the var is not indexable.\n        \"\"\"\n        from reflex.utils import format\n------------------------------\n------------------------------\n# Validate the match cases (as well as the default case) to have Var return types.\n        if any(\n            case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n        ) or not types._isinstance(default, BaseVar):\n            raise ValueError(\"Return types of match cases should be Vars.\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_default_value(self) -> Any:\n# Natural Language Annotations: \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_default_value(self) -> Any:\n    # Get the pydantic field for the var.\n    field = super().__getattribute__(\"__dict__\").get(self._var_name)\n    if field and field.default is not Undefined:\n        return field.default\n    return None\n```", "```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\n\n    Returns:\n        The default value of the var.\n\n    Raises:\n        ImportError: If the var is a dataframe and pandas is not installed.\n    \"\"\"\n    if self._var_type == DataFrame:\n        try:\n            import pandas as pd\n        except ImportError:\n            raise ImportError(\"Pandas is not installed.\")\n        return pd.DataFrame()\n    else:\n        return self._default_value\n```", "```python\ndef get_default_value(self) -> Any:\n    field = super().__getattribute__(\"__dict__\").get(self._var_name)\n    if field is None:\n        return None\n    if field.required:\n        return None\n    return field.default\n```"]}, "reflex-reflex/state.py-get_skip_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_serializer_type(type_: Type) -> Optional[Type]:\n    \"\"\"Get the converted type for the type after serializing.\n\n    Args:\n        type_: The type to get the serializer type for.\n\n    Returns:\n        The serialized type for the type, or None if there is no type conversion registered.\n    \"\"\"\n    # First, check if the type is registered.\n    serializer = SERIALIZER_TYPES.get(type_)\n    if serializer is not None:\n        return serializer\n------------------------------\n------------------------------\ndef should_skip_compile() -> bool:\n    \"\"\"Whether the app should skip compile.\n\n    Returns:\n        True if the app should skip compile.\n    \"\"\"\n    return os.environ.get(constants.SKIP_COMPILE_ENV_VAR) == \"yes\"\n------------------------------\n------------------------------\nReturns:\n        The serialized value, or None if a serializer is not found.\n    \"\"\"\n    # Get the serializer for the type.\n    serializer = get_serializer(type(value))\n\n    # If there is no serializer, return None.\n    if serializer is None:\n        if get_type:\n            return None, None\n        return None\n\n    # Serialize the value.\n    serialized = serializer(value)\n------------------------------\n------------------------------\nfrom reflex import constants\n\n\n# Code for: def validate_field_name(bases: List[Type[\"BaseModel\"]], field_name: str) -> None:\n\n\n# monkeypatch pydantic validate_field_name method to skip validating\n# shadowed state vars when reloading app via utils.prerequisites.get_app(reload=True)\npydantic_main.validate_field_name = validate_field_name  # type: ignore\n\n\n# Code for: class Base(BaseModel):  # pyright: ignore [reportUnboundVariable]\n------------------------------\n------------------------------\ndef serialize_str(value: str) -> str:\n    \"\"\"Serialize a string.\n\n    Args:\n        value: The string to serialize.\n\n    Returns:\n        The serialized string.\n    \"\"\"\n    return value\n------------------------------\n------------------------------\ndef get_serializer(type_: Type) -> Optional[Serializer]:\n    \"\"\"Get the serializer for the type.\n\n    Args:\n        type_: The type to get the serializer for.\n\n    Returns:\n        The serializer for the type, or None if there is no serializer.\n    \"\"\"\n    # First, check if the type is registered.\n    serializer = SERIALIZERS.get(type_)\n    if serializer is not None:\n        return serializer\n------------------------------\n------------------------------\nReturns:\n            The match component wrapped in a fragment or the match var.\n\n        Raises:\n            ValueError: If the return types are not vars when creating a match var for Var types.\n        \"\"\"\n        if default is None and types._issubclass(\n            type(match_cases[0][-1]), BaseComponent\n        ):\n            default = Fragment.create()\n------------------------------\n------------------------------\n# Append expired computed vars to dirty_vars to trigger recalculation\n        self.dirty_vars.update(self._expired_computed_vars())\n\n        # have to mark computed vars dirty to allow access to newly computed\n        # values within the same ComputedVar function\n        self._mark_dirty_computed_vars()\n        self._mark_dirty_substates()\n------------------------------\n------------------------------\ndef serialize(\n    value: Any, get_type: bool = False\n) -> Union[\n    Optional[SerializedType],\n    Tuple[Optional[SerializedType], Optional[types.GenericType]],\n]:\n    \"\"\"Serialize the value to a JSON string.\n\n    Args:\n        value: The value to serialize.\n        get_type: Whether to return the type of the serialized value.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_skip_vars(cls) -> set[str]:\n# Natural Language Annotations: \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\"\"\"\n    return cls._skip_vars\n```", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    skip_vars = set()\n\n    # Iterate over all properties of the class\n    for var in vars(cls):\n        if isinstance(getattr(cls, var), Skip):\n            skip_vars.add(var)\n\n    return skip_vars\n```", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\"\"\"\n    return cls._skip_vars\n```"]}, "reflex-reflex/state.py-add_var": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef useState(var_name, default=None) -> Var:\n    \"\"\"Create a useState hook with a variable name and setter name.\n\n    Args:\n        var_name: The name of the variable.\n        default: The default value of the variable.\n------------------------------\n------------------------------\ndef is_backend_base_variable(name: str, cls: Type) -> bool:\n    \"\"\"Check if this variable name correspond to a backend variable.\n\n    Args:\n        name: The name of the variable to check\n        cls: The class of the variable to check\n\n    Returns:\n        bool: The result of the check\n    \"\"\"\n    if name in RESERVED_BACKEND_VAR_NAMES:\n        return False\n\n    if not name.startswith(\"_\"):\n        return False\n\n    if name.startswith(\"__\"):\n        return False\n------------------------------\n------------------------------\n@classmethod\n    def add_field(cls, var: Any, default_value: Any):\n        \"\"\"Add a pydantic field after class definition.\n\n        Used by State.add_var() to correctly handle the new variable.\n------------------------------\n------------------------------\ndef setvar(self, var_name: str, value: Any):\n        \"\"\"Set the state variable to the value of the event.\n\n        Note: `self` here will be an instance of the state, not EventHandlerSetVar.\n\n        Args:\n            var_name: The name of the variable to set.\n            value: The value to set the variable to.\n        \"\"\"\n        getattr(self, constants.SETTER_PREFIX + var_name)(value)\n------------------------------\n------------------------------\nArgs:\n            var: The variable to add a pydantic field for.\n            default_value: The default value of the field\n        \"\"\"\n        new_field = ModelField.infer(\n            name=var._var_name,\n            value=default_value,\n            annotation=var._var_type,\n            class_validators=None,\n            config=cls.__config__,  # type: ignore\n        )\n        cls.__fields__.update({var._var_name: new_field})\n------------------------------\n------------------------------\nArgs:\n            prop: The variable to initialize\n\n        Raises:\n            VarTypeError: if the variable has an incorrect type\n        \"\"\"\n        from reflex.utils.exceptions import VarTypeError\n------------------------------\n------------------------------\nArgs:\n                state: The state within which we add the setter function.\n                value: The value to set.\n            \"\"\"\n            if self._var_type in [int, float]:\n                try:\n                    value = self._var_type(value)\n                    setattr(state, self._var_name, value)\n                except ValueError:\n                    console.debug(\n------------------------------\n------------------------------\n# The expected variable name where the rx.App is stored.\n    APP = \"app\"\n    # The expected variable name where the API object is stored for deployment.\n    API = \"api\"\n    # The name of the router variable.\n    ROUTER = \"router\"\n    # The name of the socket variable.\n    SOCKET = \"socket\"\n    # The name of the variable to hold API results.\n    RESULT = \"result\"\n    # The name of the final variable.\n    FINAL = \"final\"\n    # The name of the process variable.\n    PROCESSING = \"processing\"\n------------------------------\n------------------------------\nArgs:\n            name: The name of the attribute.\n            value: The value of the attribute.\n        \"\"\"\n        if isinstance(value, MutableProxy):\n            # unwrap proxy objects when assigning back to the state\n            value = value.__wrapped__\n\n        # Set the var on the parent state.\n        inherited_vars = {**self.inherited_vars, **self.inherited_backend_vars}\n        if name in inherited_vars:\n            setattr(self.parent_state, name, value)\n            return\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_var(cls, name: str, type_: Any, default_value: Any = None):\n# Natural Language Annotations: \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"A variable named '{name}' already exists.\")\n\n    new_field = ModelField.infer(\n        name=name,\n        value=default_value,\n        annotation=type_,\n        class_validators=None,\n        config=cls.__config__,  # type: ignore\n    )\n    cls.__fields__.update({name: new_field})\n```", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"A variable with the name {name} already exists\")\n\n    new_field = ModelField.infer(\n        name=name,\n        value=default_value,\n        annotation=type_,\n        class_validators=None,\n        config=cls.__config__,  # type: ignore\n    )\n    cls.__fields__.update({name: new_field})\n```", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"Variable {name} already exists\")\n\n    new_field = ModelField.infer(\n        name=name,\n        value=default_value,\n        annotation=type_,\n        class_validators=None,\n        config=cls.__config__,  # type: ignore\n    )\n    cls.__fields__.update({name: new_field})\n    setattr(cls, name, default_value)\n```"]}, "reflex-reflex/state.py-reset": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _reset_client_storage(self):\n        \"\"\"Reset client storage base vars to their default values.\"\"\"\n        # Client-side storage is reset during hydrate so that clearing cookies\n        # on the browser also resets the values on the backend.\n        fields = self.get_fields()\n        for prop_name in self.base_vars:\n            field = fields[prop_name]\n            if isinstance(field.default, ClientStorageBase) or (\n                isinstance(field.type_, type)\n------------------------------\n------------------------------\n# Validate the match cases (as well as the default case) to have Var return types.\n        if any(\n            case for case in match_cases if not types._isinstance(case[-1], BaseVar)\n        ) or not types._isinstance(default, BaseVar):\n            raise ValueError(\"Return types of match cases should be Vars.\")\n------------------------------\n------------------------------\n# Backend base vars that are never sent to the client.\n    backend_vars: ClassVar[Dict[str, Any]] = {}\n\n    # Backend base vars inherited\n    inherited_backend_vars: ClassVar[Dict[str, Any]] = {}\n\n    # The event handlers.\n    event_handlers: ClassVar[Dict[str, EventHandler]] = {}\n\n    # A set of subclassses of this class.\n    class_subclasses: ClassVar[Set[Type[BaseState]]] = set()\n------------------------------\n------------------------------\nReturns:\n            The prop vars.\n        \"\"\"\n        return [\n            BaseVar(\n                _var_name=name,\n                _var_type=(\n                    prop._var_type if types._isinstance(prop, Var) else type(prop)\n                ),\n            )\n            for name, prop in self.props.items()\n        ]\n\n    def _get_vars(self, include_children: bool = False) -> list[Var]:\n        \"\"\"Walk all Vars used in this component.\n------------------------------\n------------------------------\nclass Slider(RadixThemesComponent):\n    \"\"\"Provides user selection from a range of values.\"\"\"\n\n    tag = \"Slider\"\n\n    # Change the default rendered element for the one passed as a child, merging their props and behavior.\n    as_child: Var[bool]\n\n    # Button size \"1\" - \"3\"\n    size: Var[Responsive[Literal[\"1\", \"2\", \"3\"]]]\n\n    # Variant of button\n    variant: Var[Literal[\"classic\", \"surface\", \"soft\"]]\n\n    # Override theme color for button\n    color_scheme: Var[LiteralAccentColor]\n------------------------------\n------------------------------\n# all values should be back to their defaults\n    c1 = driver.find_element(By.ID, \"c1\")\n    c2 = driver.find_element(By.ID, \"c2\")\n    c3 = driver.find_element(By.ID, \"c3\")\n    c4 = driver.find_element(By.ID, \"c4\")\n    c5 = driver.find_element(By.ID, \"c5\")\n    c6 = driver.find_element(By.ID, \"c6\")\n    c7 = driver.find_element(By.ID, \"c7\")\n    l1 = driver.find_element(By.ID, \"l1\")\n    l2 = driver.find_element(By.ID, \"l2\")\n    l3 = driver.find_element(By.ID, \"l3\")\n------------------------------\n------------------------------\nasync def _reset_backend_state_manager(self):\n        \"\"\"Reset the StateManagerRedis event loop affinity.\n------------------------------\n------------------------------\ndef cond(condition: Any, c1: Any, c2: Any) -> BaseVar: ...\n------------------------------\n------------------------------\n# Change the default rendered element for the one passed as a child, merging their props and behavior.\n    as_child = Var[bool]\n------------------------------\n------------------------------\n# match cases and default should all be Vars at this point.\n        # Retrieve var data of every var in the match cases and default.\n        var_data = [\n            *[el._var_data for case in match_cases for el in case],\n            default._var_data,  # type: ignore\n        ]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def reset(self):\n# Natural Language Annotations: \"\"\"Reset all the base vars to their default values.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef reset(self):\n    for prop_name in self.base_vars:\n        self.props[prop_name] = self.base_vars[prop_name]\n```", "```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    fields = self.get_fields()\n    for prop_name in self.base_vars:\n        field = fields[prop_name]\n        if isinstance(field.default, ClientStorageBase) or (\n            isinstance(field.type_, type)\n        ):\n            field.default = field.default_factory()\n```", "```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    fields = self.get_fields()\n    for prop_name in self.base_vars:\n        field = fields[prop_name]\n        if isinstance(field.default, ClientStorageBase) or (isinstance(field.type_, type)):\n            setattr(self, prop_name, field.default)\n```"]}, "reflex-reflex/state.py-get_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get an instance of the state associated with this token.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The state.\n------------------------------\n------------------------------\nArgs:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n\n        Raises:\n            RuntimeError: If redis is not used in this backend process.\n        \"\"\"\n        # Fetch all missing parent states from redis.\n        parent_state_of_state_cls = await self._populate_parent_states(state_cls)\n------------------------------\n------------------------------\nReturns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\n        if self.parent_state is None:\n            root_state = self\n        else:\n            root_state = self._get_parent_states()[-1][1]\n        return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n\n    async def _get_state_from_redis(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get a state instance from redis.\n------------------------------\n------------------------------\nasync def get_state(self, token: str) -> BaseState:\n        \"\"\"Get the state associated with the given token.\n\n        Args:\n            token: The state token to look up.\n\n        Returns:\n            The state instance associated with the given token\n------------------------------\n------------------------------\n# Return the direct parent of target_state_cls for subsequent linking.\n        return parent_state\n\n    def _get_state_from_cache(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get a state instance from the cache.\n\n        Args:\n            state_cls: The class of the state.\n------------------------------\n------------------------------\nArgs:\n            state: The state to start from.\n\n        Returns:\n            An instance of the top-level state (self.state).\n        \"\"\"\n        while type(state) != self.state and state.parent_state is not None:\n            state = state.parent_state\n        return state\n\n    async def _get_parent_state(self, token: str) -> BaseState | None:\n        \"\"\"Get the parent state for the state requested in the token.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n# Natural Language Annotations: \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The state.\n    \"\"\"\n    # Fetch all missing parent states from redis.\n    parent_state_of_state_cls = await self._populate_parent_states(state_cls)\n\n    # Return the direct parent of target_state_cls for subsequent linking.\n    return parent_state_of_state_cls\n```", "Here is the code snippet based on your specifications:\n\n```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n\n    # Fetch all missing parent states from redis.\n    parent_state_of_state_cls = await self._populate_parent_states(state_cls)\n\n    # Return the direct parent of target_state_cls for subsequent linking.\n    return parent_state_of_state_cls\n```", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    # Fetch all missing parent states from redis.\n    parent_state_of_state_cls = await self._populate_parent_states(state_cls)\n\n    # Return the direct parent of target_state_cls for subsequent linking.\n    return parent_state_of_state_cls\n```"]}, "reflex-reflex/state.py-_process": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nYields:\n        The state updates after processing the event.\n    \"\"\"\n    from reflex.utils import telemetry\n------------------------------\n------------------------------\nasync def process(\n    app: App, event: Event, sid: str, headers: Dict, client_ip: str\n) -> AsyncIterator[StateUpdate]:\n    \"\"\"Process an event.\n\n    Args:\n        app: The app to process the event for.\n        event: The event to process.\n        sid: The Socket.IO session id.\n        headers: The client headers.\n        client_ip: The client_ip.\n\n    Raises:\n        Exception: If a reflex specific error occurs during processing the event.\n------------------------------\n------------------------------\nYields:\n                Each state update as JSON followed by a new line.\n            \"\"\"\n            # Process the event.\n            async with app.state_manager.modify_state(event.substate_token) as state:\n                async for update in state._process(event):\n                    # Postprocess the event.\n                    update = await app._postprocess(state, event, update)\n                    yield update.json() + \"\\n\"\n------------------------------\n------------------------------\ndef _process_background(\n        self, state: BaseState, event: Event\n    ) -> asyncio.Task | None:\n        \"\"\"Process an event in the background and emit updates as they arrive.\n\n        Args:\n            state: The state to process the event for.\n            event: The event to process.\n------------------------------\n------------------------------\n# Preprocess the event.\n            update = await app._preprocess(state, event)\n\n            # If there was an update, yield it.\n            if update is not None:\n                yield update\n------------------------------\n------------------------------\ndef get_event(state, event):\n    \"\"\"Get the event from the given state.\n\n    Args:\n        state: The state.\n        event: The event.\n\n    Returns:\n        The event.\n    \"\"\"\n    return f\"{state.get_name()}.{event}\"\n------------------------------\n------------------------------\nYields:\n            tuple of (event_name, event_vars)\n        \"\"\"\n        for event_trigger, event in event_triggers.items():\n            if isinstance(event, Var):\n                yield event_trigger, [event]\n            elif isinstance(event, EventChain):\n                event_args = []\n                for spec in event.events:\n                    for args in spec.args:\n                        event_args.extend(args)\n                yield event_trigger, event_args\n------------------------------\n------------------------------\nasync def postprocess(\n        self, app: App, state: BaseState, event: Event, update: StateUpdate\n    ) -> StateUpdate:\n        \"\"\"Postprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to postprocess.\n            update: The current state update.\n\n        Returns:\n            An optional state to return.\n        \"\"\"\n        return update\n------------------------------\n------------------------------\n# Process the event synchronously.\n                async for update in state._process(event):\n                    # Postprocess the event.\n                    update = await app._postprocess(state, event, update)\n\n                    # Yield the update.\n                    yield update\n    except Exception as ex:\n        telemetry.send_error(ex, context=\"backend\")\n        raise\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n# Natural Language Annotations: \"\"\"Obtain event info and process event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Obtain event info.\n    event_info = self.get_event_info(event)\n\n    # Process event.\n    state_update = await self.process_event(event_info)\n\n    # Yield state update.\n    yield state_update\n```", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Preprocess the event.\n    update = await self._preprocess(event)\n\n    # If there was an update, yield it.\n    if update is not None:\n        yield update\n\n    # Process the event synchronously.\n    async with self.state_manager.modify_state(event.substate_token) as state:\n        async for update in state._process(event):\n            # Postprocess the event.\n            update = await self._postprocess(state, event, update)\n\n            # Yield the update.\n            yield update\n```", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Process an event.\"\"\"\n    # Obtain event info\n    event_name = event.name\n    event_vars = event.vars\n\n    # Process event\n    async with self.state_manager.modify_state(event.substate_token) as state:\n        async for update in state._process(event):\n            # Postprocess the event.\n            update = await self._postprocess(state, event, update)\n            yield update\n```"]}, "reflex-reflex/state.py-_dirty_computed_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _expired_computed_vars(self) -> set[str]:\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n        return set(\n            cvar\n            for cvar in self.computed_vars\n            if self.computed_vars[cvar].needs_update(instance=self)\n        )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n------------------------------\n------------------------------\n# Mapping of var name to set of computed variables that depend on it\n    _computed_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Mapping of var name to set of substates that depend on it\n    _substate_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Set of vars which always need to be recomputed\n    _always_dirty_computed_vars: ClassVar[Set[str]] = set()\n------------------------------\n------------------------------\ndef _mark_dirty_computed_vars(self) -> None:\n        \"\"\"Mark ComputedVars that need to be recalculated based on dirty_vars.\"\"\"\n        dirty_vars = self.dirty_vars\n        while dirty_vars:\n            calc_vars, dirty_vars = dirty_vars, set()\n            for cvar in self._dirty_computed_vars(from_vars=calc_vars):\n                self.dirty_vars.add(cvar)\n                dirty_vars.add(cvar)\n                actual_var = self.computed_vars.get(cvar)\n------------------------------\n------------------------------\nAllows the state to know which vars each ComputedVar depends on and\n        whether a ComputedVar depends on a var in its parent state.\n\n        Additional updates tracking dicts for vars and substates that always\n        need to be recomputed.\n        \"\"\"\n        # Initialize per-class var dependency tracking.\n        cls._computed_var_dependencies = defaultdict(set)\n        cls._substate_var_dependencies = defaultdict(set)\n------------------------------\n------------------------------\n# Append expired computed vars to dirty_vars to trigger recalculation\n        self.dirty_vars.update(self._expired_computed_vars())\n\n        # have to mark computed vars dirty to allow access to newly computed\n        # values within the same ComputedVar function\n        self._mark_dirty_computed_vars()\n        self._mark_dirty_substates()\n------------------------------\n------------------------------\ndef dict(\n        self, include_computed: bool = True, initial: bool = False, **kwargs\n    ) -> dict[str, Any]:\n        \"\"\"Convert the object to a dictionary.\n\n        Args:\n            include_computed: Whether to include computed vars.\n            initial: Whether to get the initial value of computed vars.\n            **kwargs: Kwargs to pass to the pydantic dict method.\n------------------------------\n------------------------------\nIf any dirty vars belong to this state, mark _was_touched.\n\n        This flag determines whether this state instance should be persisted to redis.\n\n        Returns:\n            Whether this state instance was ever modified.\n        \"\"\"\n        # Ensure the flag is up to date based on the current dirty_vars\n        self._update_was_touched()\n        return self._was_touched\n------------------------------\n------------------------------\nReturns:\n            The object as a dictionary.\n        \"\"\"\n        if include_computed:\n            # Apply dirty variables down into substates to allow never-cached ComputedVar to\n            # trigger recalculation of dependent vars\n            self.dirty_vars.update(self._always_dirty_computed_vars)\n            self._mark_dirty()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _dirty_computed_vars(\n# Natural Language Annotations: \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _dirty_computed_vars(\n    self, from_vars: Optional[Set[str]] = None, include_backend: bool = False\n) -> Set[str]:\n    if from_vars is None:\n        from_vars = self.dirty_vars\n\n    dirty_vars = set()\n\n    for cvar in self.computed_vars:\n        if any(dep in from_vars for dep in self._computed_var_dependencies[cvar]):\n            dirty_vars.add(cvar)\n\n    if include_backend:\n        for backend_var in self._backend_vars:\n            if backend_var in from_vars:\n                dirty_vars.update(self._computed_var_dependencies[backend_var])\n\n    return dirty_vars\n```", "```python\ndef _dirty_computed_vars(\n        self, from_vars: Optional[set[str]] = None, include_backend: bool = False\n    ) -> set[str]:\n        if from_vars is None:\n            from_vars = self.dirty_vars\n        dirty_computed_vars = set()\n        for var in from_vars:\n            if var in self._computed_var_dependencies:\n                dirty_computed_vars.update(self._computed_var_dependencies[var])\n            if var in self._substate_var_dependencies:\n                dirty_computed_vars.update(self._substate_var_dependencies[var])\n            if include_backend:\n                dirty_computed_vars.update(\n                    cvar\n                    for cvar in self.computed_vars\n                    if self.computed_vars[cvar].needs_update_backend(instance=self)\n                )\n        return dirty_computed_vars\n```", "```python\ndef _dirty_computed_vars(\n    self,\n    from_vars: Optional[Set[str]] = None,\n    include_backend: bool = True,\n) -> Set[str]:\n    \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = self.dirty_vars\n    dirty_computed_vars = set()\n    for cvar in from_vars:\n        if self.computed_vars[cvar].needs_update(instance=self):\n            dirty_computed_vars.add(cvar)\n    return dirty_computed_vars\n```"]}, "reflex-reflex/state.py-_potentially_dirty_substates": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nif all_substates:\n            # All substates are requested.\n            fetch_substates = state.get_substates()\n        else:\n            # Only _potentially_dirty_substates need to be fetched to recalc computed vars.\n            fetch_substates = state._potentially_dirty_substates()\n------------------------------\n------------------------------\n# Set of substates which always need to be recomputed\n    _always_dirty_substates: ClassVar[Set[str]] = set()\n\n    # The parent state.\n    parent_state: Optional[BaseState] = None\n\n    # The substates of the state.\n    substates: Dict[str, BaseState] = {}\n\n    # The set of dirty vars.\n    dirty_vars: Set[str] = set()\n\n    # The set of dirty substates.\n    dirty_substates: Set[str] = set()\n\n    # The routing path that triggered the state\n    router_data: Dict[str, Any] = {}\n------------------------------\n------------------------------\n# Mapping of var name to set of computed variables that depend on it\n    _computed_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Mapping of var name to set of substates that depend on it\n    _substate_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n    # Set of vars which always need to be recomputed\n    _always_dirty_computed_vars: ClassVar[Set[str]] = set()\n------------------------------\n------------------------------\ndef _expired_computed_vars(self) -> set[str]:\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n        return set(\n            cvar\n            for cvar in self.computed_vars\n            if self.computed_vars[cvar].needs_update(instance=self)\n        )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n------------------------------\n------------------------------\n# Any substate containing a ComputedVar with cache=False always needs to be recomputed\n        if cls._always_dirty_computed_vars:\n            # Tell parent classes that this substate has always dirty computed vars\n            state_name = cls.get_name()\n            parent_state = cls.get_parent_state()\n            while parent_state is not None:\n                parent_state._always_dirty_substates.add(state_name)\n                state_name, parent_state = (\n------------------------------\n------------------------------\n# Reset dirty substate tracking for this class.\n        cls._always_dirty_substates = set()\n\n        # Get the parent vars.\n        parent_state = cls.get_parent_state()\n        if parent_state is not None:\n            cls.inherited_vars = parent_state.vars\n            cls.inherited_backend_vars = parent_state.backend_vars\n------------------------------\n------------------------------\nAllows the state to know which vars each ComputedVar depends on and\n        whether a ComputedVar depends on a var in its parent state.\n\n        Additional updates tracking dicts for vars and substates that always\n        need to be recomputed.\n        \"\"\"\n        # Initialize per-class var dependency tracking.\n        cls._computed_var_dependencies = defaultdict(set)\n        cls._substate_var_dependencies = defaultdict(set)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n# Natural Language Annotations: \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n        Returns:\n            Set of State classes that may need to be fetched to recalc computed vars.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\"\"\"\n\n    potentially_dirty_substates = set()\n\n    # Check each computed var that could potentially be dirty.\n    for cvar in cls._computed_var_dependencies:\n        if cvar in cls.dirty_vars or cls.computed_vars[cvar].needs_update(instance=cls):\n            # This computed var is affected by a dirty var. Check if its substate needs to be fetched.\n            for substate_name in cls._substate_var_dependencies[cvar]:\n                potentially_dirty_substates.add(substate_name)\n\n    # Check each substate that always needs to be recomputed.\n    for substate_name in cls._always_dirty_substates:\n        potentially_dirty_substates.add(substate_name)\n\n    return potentially_dirty_substates\n```", "```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    potentially_dirty_substates = set()\n    for substate in cls.substates:\n        if cls.substates[substate].dirty_vars:\n            potentially_dirty_substates.add(type(cls.substates[substate]))\n        if cls.substates[substate].dirty_substates:\n            potentially_dirty_substates.add(type(cls.substates[substate]))\n    return potentially_dirty_substates\n```", "```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\"\"\"\n\n    # Initialize set of potentially dirty substates.\n    potentially_dirty_substates = set()\n\n    # Loop over all computed vars.\n    for cvar in cls.computed_vars:\n        # If the computed var depends on any dirty vars, add the substate to the list.\n        if cls.computed_vars[cvar].depends_on_any(cls.dirty_vars):\n            potentially_dirty_substates.add(cls.computed_vars[cvar].substate)\n\n    # Return the set of potentially dirty substates.\n    return potentially_dirty_substates\n```"]}, "reflex-reflex/state.py-get_delta": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_event(state, event):\n    \"\"\"Get the event from the given state.\n\n    Args:\n        state: The state.\n        event: The event.\n\n    Returns:\n        The event.\n    \"\"\"\n    return f\"{state.get_name()}.{event}\"\n------------------------------\n------------------------------\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get an instance of the state associated with this token.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The state.\n------------------------------\n------------------------------\n@classmethod\n    def get_substates(cls) -> set[Type[BaseState]]:\n        \"\"\"Get the substates of the state.\n\n        Returns:\n            The substates of the state.\n        \"\"\"\n        return cls.class_subclasses\n\n    @classmethod\n    @functools.lru_cache()\n    def get_name(cls) -> str:\n        \"\"\"Get the name of the state.\n\n        Returns:\n            The name of the state.\n        \"\"\"\n        return format.to_snake_case(cls.__name__)\n------------------------------\n------------------------------\nArgs:\n            state: The state to set or the full name of the state.\n\n        Returns:\n            The var with the set state.\n        \"\"\"\n        from reflex.utils import format\n------------------------------\n------------------------------\ndef get_hydrate_event(state) -> str:\n    \"\"\"Get the name of the hydrate event for the state.\n\n    Args:\n        state: The state.\n\n    Returns:\n        The name of the hydrate event.\n    \"\"\"\n    return get_event(state, constants.CompileVars.HYDRATE)\n------------------------------\n------------------------------\n# Create a fresh copy of the backend variables for this instance\n        self._backend_vars = copy.deepcopy(\n            {name: item for name, item in self.backend_vars.items()}\n        )\n\n    def __repr__(self) -> str:\n        \"\"\"Get the string representation of the state.\n\n        Returns:\n            The string representation of the state.\n        \"\"\"\n        return f\"{self.__class__.__name__}({self.dict()})\"\n------------------------------\n------------------------------\nReturns:\n            The state dict for serialization.\n        \"\"\"\n        state = super().__getstate__()\n        # Never serialize parent_state or substates\n        state[\"__dict__\"] = state[\"__dict__\"].copy()\n        state[\"__dict__\"][\"parent_state\"] = None\n        state[\"__dict__\"][\"substates\"] = {}\n        state[\"__dict__\"].pop(\"_was_touched\", None)\n        return state\n------------------------------\n------------------------------\nArgs:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_delta(self) -> Delta:\n# Natural Language Annotations: \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    from reflex.utils import diff\n    return diff.get_delta(self.old_state_dict, self.state_dict)\n```", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    # Your implementation here\n```", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    # Your code here\n```"]}, "reflex-reflex/model.py-get_db_engine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_engine(url: str | None = None) -> sqlalchemy.engine.Engine:\n    \"\"\"Get the database engine.\n\n    Args:\n        url: the DB url to use.\n\n    Returns:\n        The database engine.\n------------------------------\n------------------------------\nReturns:\n            DBConfig instance.\n        \"\"\"\n        return cls(\n            engine=\"sqlite\",\n            database=database,\n        )\n\n    def get_url(self) -> str:\n        \"\"\"Get database URL.\n------------------------------\n------------------------------\ndef session(url: str | None = None) -> sqlmodel.Session:\n    \"\"\"Get a sqlmodel session to interact with the database.\n\n    Args:\n        url: The database url.\n\n    Returns:\n        A database session.\n    \"\"\"\n    return sqlmodel.Session(get_engine(url))\n------------------------------\n------------------------------\nReturns:\n            True if the model metadata is empty, False otherwise.\n        \"\"\"\n        return len(model.metadata.tables) == 0\n\n    @classmethod\n    def get_metadata(cls) -> sqlalchemy.MetaData:\n        \"\"\"Get the database metadata.\n\n        Returns:\n            The database metadata.\n        \"\"\"\n        if cls._metadata is not None:\n            return cls._metadata\n\n        models = cls.get_models(include_empty=False)\n------------------------------\n------------------------------\n# get a reference to the counter\n    counter = driver.find_element(By.ID, \"counter\")\n\n    # get a reference to the iterations input\n    iterations_input = driver.find_element(By.ID, \"iterations\")\n------------------------------\n------------------------------\ndef sqla_session(url: str | None = None) -> sqlalchemy.orm.Session:\n    \"\"\"Get a bare sqlalchemy session to interact with the database.\n\n    Args:\n        url: The database url.\n\n    Returns:\n        A database session.\n    \"\"\"\n    return sqlalchemy.orm.Session(get_engine(url))\n------------------------------\n------------------------------\nArgs:\n            database: Database name.\n            username: Database username.\n            password: Database password.\n            host: Database host.\n            port: Database port.\n\n        Returns:\n            DBConfig instance.\n        \"\"\"\n        return cls(\n            engine=\"postgresql\",\n            username=username,\n            password=password,\n            host=host,\n            port=port,\n            database=database,\n        )\n------------------------------\n------------------------------\nReturns:\n            DBConfig instance.\n        \"\"\"\n        return cls(\n            engine=\"postgresql+psycopg2\",\n            username=username,\n            password=password,\n            host=host,\n            port=port,\n            database=database,\n        )\n\n    @classmethod\n    def sqlite(\n        cls,\n        database: str,\n    ) -> DBConfig:\n        \"\"\"Create an instance with sqlite engine.\n\n        Args:\n            database: Database name.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_db_engine():\n# Natural Language Annotations: \"\"\"Get the database engine.\n\n        Returns:\n            The database engine.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    pass\n```", "```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    # Your code here\n```", "```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    return get_engine()\n```"]}, "reflex-reflex/model.py-alembic_autogenerate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef makemigrations(\n    message: str = typer.Option(\n        None, help=\"Human readable identifier for the generated revision.\"\n    ),\n):\n    \"\"\"Create autogenerated alembic migration scripts.\"\"\"\n    from alembic.util.exc import CommandError\n\n    from reflex import model\n    from reflex.utils import prerequisites\n------------------------------\n------------------------------\n@classmethod\n    def _alembic_upgrade(\n        cls,\n        connection: sqlalchemy.engine.Connection,\n        to_rev: str = \"head\",\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n            to_rev: Revision to migrate towards.\n        \"\"\"\n        config, script_directory = cls._alembic_config()\n------------------------------\n------------------------------\n# Fired when the open state changes.\n    on_open_change: EventHandler[lambda e0: [e0]]\n------------------------------\n------------------------------\n# Used to force mounting when more control is needed. Useful when controlling animation with React animation libraries.\n    force_mount: Var[bool]\n\n    # By default, screenreaders will announce the content inside the component. If this is not descriptive enough, or you have content that cannot be announced, use aria-label as a more descriptive label.\n    aria_label: Var[str]\n\n    # Fired when the open state changes.\n    on_open_change: EventHandler[lambda e0: [e0.target.value]]\n------------------------------\n------------------------------\nThis method is called to provide python code for the given obj,\n        but currently it is only used to add `sqlmodel` to the import list\n        when generating migration scripts.\n\n        See https://alembic.sqlalchemy.org/en/latest/api/runtime.html\n------------------------------\n------------------------------\n# Check the alembic config.\n    if Path(constants.ALEMBIC_CONFIG).exists():\n        console.error(\n            \"Database is already initialized. Use \"\n            \"[bold]reflex db makemigrations[/bold] to create schema change \"\n            \"scripts and [bold]reflex db migrate[/bold] to apply migrations \"\n            \"to a new or existing database.\",\n        )\n        return\n------------------------------\n------------------------------\n\"\"\"Database built into Reflex.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nfrom collections import defaultdict\nfrom pathlib import Path\nfrom typing import Any, ClassVar, Optional, Type, Union\n\nimport alembic.autogenerate\nimport alembic.command\nimport alembic.config\nimport alembic.operations.ops\nimport alembic.runtime.environment\nimport alembic.script\nimport alembic.util\nimport sqlalchemy\nimport sqlalchemy.orm\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def alembic_autogenerate(\n# Natural Language Annotations: \"\"\"Generate migration scripts for alembic-detectable changes.\n\n        Args:\n            connection: SQLAlchemy connection to use when detecting changes.\n            message: Human readable identifier describing the generated revision.\n            write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n        Returns:\n            True when changes have been detected.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str = \"Auto generation\",\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config = alembic.config.Config()\n    config.set_main_option(\"script_location\", \"migrations\")\n    config.set_main_option(\"sqlalchemy.url\", str(connection.engine.url))\n\n    script = alembic.script.ScriptDirectory.from_config(config)\n\n    def detect_migrations(connection, script):\n        context = alembic.migration.MigrationContext.configure(connection)\n        return set(script.get_revisions(script.get_heads())) - \\\n            set(script.get_all_current(context._version))\n\n    detect_changes = detect_migrations(connection, script)\n\n    if detect_changes:\n        command.revision(config, message=message, autogenerate=True)\n        return True\n    else:\n        return False\n```", "```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: Optional[str] = None,\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    from alembic.autogenerate import compare_metadata\n    from alembic.operations import Operations\n    from sqlalchemy.schema import MetaData\n\n    config = alembic.config.Config()\n    config.set_main_option(\"script_location\", \"migrations\")\n\n    metadata = MetaData()\n    metadata.reflect(bind=connection)\n\n    operation = Operations(connection)\n    context = alembic.migration.MigrationContext.configure(connection)\n\n    diff = compare_metadata(context, metadata)\n\n    if diff:\n        operation.create_version_file(message or \"\", refresh=True)\n        if write_migration_scripts:\n            alembic.command.upgrade(config, \"head\")\n        return True\n\n    return False\n```", "```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str = typer.Option(\n        None, help=\"Human readable identifier for the generated revision.\"\n    ),\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n    alembic_command.upgrade(config, \"heads\")\n\n    with connection.begin() as trans:\n        context = migration.MigrationContext.configure(trans.connection)\n        diff = alembic_autogenerate.compare_metadata(context, metadata)\n\n    if diff:\n        if write_migration_scripts:\n            alembic_autogenerate.produce_migrations(config, diff)\n        return True\n    return False\n```"]}, "reflex-reflex/model.py-migrate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nRaises:\n                RuntimeError: If the app has not been initialized yet.\n            \"\"\"\n            if self.event_namespace is None:\n                raise RuntimeError(\"App has not been initialized yet.\")\n------------------------------\n------------------------------\n@classmethod\n    def _alembic_upgrade(\n        cls,\n        connection: sqlalchemy.engine.Connection,\n        to_rev: str = \"head\",\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n            to_rev: Revision to migrate towards.\n        \"\"\"\n        config, script_directory = cls._alembic_config()\n------------------------------\n------------------------------\ndef initialize_requirements_txt():\n    \"\"\"Initialize the requirements.txt file.\n    If absent, generate one for the user.\n    If the requirements.txt does not have reflex as dependency,\n    generate a requirement pinning current version and append to\n    the requirements.txt file.\n    \"\"\"\n    fp = Path(constants.RequirementsTxt.FILE)\n    encoding = \"utf-8\"\n    if not fp.exists():\n        fp.touch()\n    else:\n        # Detect the encoding of the original file\n        import charset_normalizer\n------------------------------\n------------------------------\ndef check_schema_up_to_date():\n    \"\"\"Check if the sqlmodel metadata matches the current database schema.\"\"\"\n    if get_config().db_url is None or not Path(constants.ALEMBIC_CONFIG).exists():\n        return\n    with model.Model.get_db_engine().connect() as connection:\n        try:\n            if model.Model.alembic_autogenerate(\n                connection=connection,\n                write_migration_scripts=False,\n            ):\n                console.error(\n------------------------------\n------------------------------\n# If true, the form control will be invalid. This has 2 side effects - The FormLabel and FormErrorIcon will have `data-invalid` set to true - The form element (e.g, Input) will have `aria-invalid` set to true\n    is_invalid: Var[bool]\n\n    # If true, the form control will be readonly.\n    is_read_only: Var[bool]\n------------------------------\n------------------------------\n# Check the alembic config.\n    if Path(constants.ALEMBIC_CONFIG).exists():\n        console.error(\n            \"Database is already initialized. Use \"\n            \"[bold]reflex db makemigrations[/bold] to create schema change \"\n            \"scripts and [bold]reflex db migrate[/bold] to apply migrations \"\n            \"to a new or existing database.\",\n        )\n        return\n------------------------------\n------------------------------\n# The dot is shown when a user enters an area chart and this chart has a tooltip. If set false, no active dot will be drawn. If set true, an active dot will be drawn which will have the props calculated internally.\n    active_dot: Var[bool]\n\n    # If set false, labels will not be drawn. If set true, labels will be drawn which have the props calculated internally.\n    label: Var[bool]\n------------------------------\n------------------------------\n# Initialize the database.\n    _skip_compile()\n    prerequisites.get_compiled_app()\n    model.Model.alembic_init()\n    model.Model.migrate(autogenerate=True)\n------------------------------\n------------------------------\n# If set false, dots will not be drawn. If set true, dots will be drawn which have the props calculated internally.\n    dot: Var[bool]\n\n    # The dot is shown when a user enters an area chart and this chart has a tooltip. If set false, no active dot will be drawn. If set true, an active dot will be drawn which will have the props calculated internally.\n    active_dot: Var[bool]\n------------------------------\n------------------------------\ndef check_db_initialized() -> bool:\n    \"\"\"Check if the database migrations are initialized.\n\n    Returns:\n        True if alembic is initialized (or if database is not used).\n    \"\"\"\n    if get_config().db_url is not None and not Path(constants.ALEMBIC_CONFIG).exists():\n        console.error(\n            \"Database is not initialized. Run [bold]reflex db init[/bold] first.\"\n        )\n        return False\n    return True\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def migrate(cls, autogenerate: bool = False) -> bool | None:\n# Natural Language Annotations: \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n        If alembic is not installed or has not been initialized for the project,\n        then no action is performed.\n\n        If there are no revisions currently tracked by alembic, then\n        an initial revision will be created based on sqlmodel metadata.\n\n        If models in the app have changed in incompatible ways that alembic\n        cannot automatically generate revisions for, the app may not be able to\n        start up until migration scripts have been corrected by hand.\n\n        Args:\n            autogenerate: If True, generate migration script and use it to upgrade schema\n                (otherwise, just bring the schema to current \"head\" revision).\n\n        Returns:\n            True - indicating the process was successful.\n            None - indicating the process was skipped.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    if not cls.check_db_initialized():\n        return None\n\n    with cls.get_db_engine().connect() as connection:\n        if cls.alembic_autogenerate(connection=connection, write_migration_scripts=autogenerate):\n            cls.alembic_upgrade(connection=connection)\n\n    return True\n```", "```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    if get_config().db_url is None or not Path(constants.ALEMBIC_CONFIG).exists():\n        return None\n    with model.Model.get_db_engine().connect() as connection:\n        model.Model.alembic_autogenerate(\n            connection=connection,\n            write_migration_scripts=autogenerate,\n        )\n    return True\n```", "```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    if get_config().db_url is None or not Path(constants.ALEMBIC_CONFIG).exists():\n        return None\n\n    with model.Model.get_db_engine().connect() as connection:\n        if model.Model.alembic_autogenerate(\n            connection=connection,\n            write_migration_scripts=autogenerate,\n        ):\n            cls._alembic_upgrade(connection=connection, to_rev=\"head\")\n\n    return True\n```"]}, "reflex-reflex/model.py-select": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *children: The children of the component.\n            rows (list[list], optional): The rows of the table body. Defaults to None.\n            **props: The properties of the component.\n\n        Returns:\n            Component: The table body component\n        \"\"\"\n        if len(children) == 0:\n            cls.validate_rows(rows) if rows is not None else None\n------------------------------\n------------------------------\ndef ask(\n    question: str,\n    choices: list[str] | None = None,\n    default: str | None = None,\n    show_choices: bool = True,\n) -> str:\n    \"\"\"Takes a prompt question and optionally a list of choices\n     and returns the user input.\n\n    Args:\n        question: The question to ask the user.\n        choices: A list of choices to select from.\n        default: The default option selected.\n        show_choices: Whether to show the choices.\n------------------------------\n------------------------------\ndef compile_import_statement(fields: list[ImportVar]) -> tuple[str, list[str]]:\n    \"\"\"Compile an import statement.\n\n    Args:\n        fields: The set of fields to import from the library.\n------------------------------\n------------------------------\nReturns:\n        A string with the user input.\n    \"\"\"\n    return Prompt.ask(\n        question, choices=choices, default=default, show_choices=show_choices\n    )  # type: ignore\n------------------------------\n------------------------------\n# Render the table.\n        return super()._render()\n------------------------------\n------------------------------\nReturns:\n            A list of keys.\n        \"\"\"\n        return self.driver.execute_script(\n            f\"var ls = window.{self.storage_key}, keys = []; \"\n            \"for (var i = 0; i < ls.length; ++i) \"\n            \"  keys[i] = ls.key(i); \"\n            \"return keys; \"\n        )\n\n    def get(self, key) -> str:\n        \"\"\"Get a key from local storage.\n\n        Args:\n            key: The key to get.\n------------------------------\n------------------------------\nArgs:\n            items: The items of the select.\n            **props: Additional properties to apply to the select component.\n\n        Returns:\n            The select component.\n        \"\"\"\n        trigger_prop_list = [\n            \"placeholder\",\n            \"variant\",\n            \"radius\",\n            \"width\",\n            \"flex_shrink\",\n            \"custom_attrs\",\n        ]\n------------------------------\n------------------------------\nReturns:\n            A var representing the greater than or equal to comparison.\n        \"\"\"\n        return self.compare(\">=\", other)\n\n    def __lt__(self, other: Var) -> Var:\n        \"\"\"Perform a less than comparison.\n\n        Args:\n            other: The other var to compare with.\n\n        Returns:\n            A var representing the less than comparison.\n        \"\"\"\n        return self.compare(\"<\", other)\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the data editor.\n            **props: The props of the data editor.\n\n        Raises:\n            ValueError: invalid input.\n\n        Returns:\n            The DataEditor component.&\n        \"\"\"\n        from reflex.components.el import Div\n\n        columns = props.get(\"columns\", [])\n        data = props.get(\"data\", [])\n        rows = props.get(\"rows\", None)\n------------------------------\n------------------------------\nReturns:\n        new string containing keywords.\n    \"\"\"\n    # /posts -> /post\n    # /posts/[slug] -> /posts/__SINGLE_SEGMENT__\n    # /posts/[slug]/comments -> /posts/__SINGLE_SEGMENT__/comments\n    # /posts/[[slug]] -> /posts/__DOUBLE_SEGMENT__\n    # / posts/[[...slug2]]-> /posts/__DOUBLE_CATCHALL_SEGMENT__\n    # /posts/[...slug3]-> /posts/__SINGLE_CATCHALL_SEGMENT__\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def select(cls):\n# Natural Language Annotations: \"\"\"Select rows from the table.\n\n        Returns:\n            The select statement.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n```", "```python\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    if len(cls.children) == 0:\n        cls.validate_rows(cls.rows) if cls.rows is not None else None\n```", "```python\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    # Implement your function here.\n    pass\n```"]}, "reflex-reflex/compiler/compiler.py-compile_components": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The path and code of the compiled custom components.\n\n        Raises:\n            ValueError: If the custom components are not set.\n        \"\"\"\n        if cls.CUSTOM_COMPONENTS is None:\n            raise ValueError(\"CUSTOM_COMPONENTS should be set\")\n        return compile_components(cls.CUSTOM_COMPONENTS)\n\n    @classmethod\n    def compile_theme(cls):\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n------------------------------\n------------------------------\ndef _compile_components(\n    components: set[CustomComponent],\n) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the components.\n\n    Args:\n        components: The components to compile.\n\n    Returns:\n        The compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n------------------------------\n------------------------------\ndef compile_custom_component(\n    component: CustomComponent,\n) -> tuple[dict, ParsedImportDict]:\n    \"\"\"Compile a custom component.\n\n    Args:\n        component: The custom component to compile.\n\n    Returns:\n        A tuple of the compiled component and the imports required by the component.\n    \"\"\"\n    # Render the component.\n    render = component.get_component(component)\n------------------------------\n------------------------------\n@classmethod\n    def compile_app(cls):\n        \"\"\"Compile the app.\n\n        Returns:\n            The path and code of the compiled app.\n\n        Raises:\n            ValueError: If the app root is not set.\n        \"\"\"\n        if cls.COMPILE_APP_APP_ROOT is None:\n            raise ValueError(\"COMPILE_APP_APP_ROOT should be set\")\n        return compile_app(cls.COMPILE_APP_APP_ROOT)\n\n    @classmethod\n    def compile_custom_components(cls):\n        \"\"\"Compile the custom components.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n------------------------------\ndef get_components_path() -> str:\n    \"\"\"Get the path of the compiled components.\n\n    Returns:\n        The path of the compiled components.\n    \"\"\"\n    return str(\n        get_web_dir()\n        / constants.Dirs.UTILS\n        / (constants.PageNames.COMPONENTS + constants.Ext.JS),\n    )\n------------------------------\n------------------------------\ndef _compile_component(component: Component | StatefulComponent) -> str:\n    \"\"\"Compile a single component.\n\n    Args:\n        component: The component to compile.\n\n    Returns:\n        The compiled component.\n    \"\"\"\n    return templates.COMPONENT.render(component=component)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def compile_components(\n# Natural Language Annotations: \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef compile_components(components: set[CustomComponent]) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the components.\n\n    Args:\n        components: The components to compile.\n\n    Returns:\n        The compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n\n    for component in components:\n        render, import_vars = compile_custom_component(component)\n        component_renders.append(render)\n\n        for path, import_var_list in import_vars.items():\n            if path not in imports:\n                imports[path] = []\n            imports[path].extend(import_var_list)\n\n    return component_renders, imports\n```", "```python\ndef compile_components(components: set[CustomComponent]) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the components.\n\n    Args:\n        components: The components to compile.\n\n    Returns:\n        The compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n\n    for component in components:\n        render, imports = compile_custom_component(component)\n        component_renders.append(render)\n\n    return (component_renders, imports)\n```", "```python\ndef compile_components(components: set[CustomComponent]) -> tuple[str, Dict[str, list[ImportVar]]]:\n    \"\"\"Compile the components.\n\n    Args:\n        components: The components to compile.\n\n    Returns:\n        The compiled components.\n    \"\"\"\n    imports = {\n        \"react\": [ImportVar(tag=\"memo\")],\n        f\"/{constants.Dirs.STATE_PATH}\": [ImportVar(tag=\"E\"), ImportVar(tag=\"isTrue\")],\n    }\n    component_renders = []\n```"]}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef version(value: bool):\n    \"\"\"Get the Reflex version.\n\n    Args:\n        value: Whether the version flag was passed.\n\n    Raises:\n        typer.Exit: If the version flag was passed.\n    \"\"\"\n    if value:\n        console.print(constants.Reflex.VERSION)\n        raise typer.Exit()\n------------------------------\n------------------------------\nand not get_or_set_last_reflex_version_check_datetime()\n        ):\n            # only show a warning when the host version is outdated and\n            # the last_version_check_datetime is not set in reflex.json\n            console.warn(\n                f\"Your version ({current_version}) of {package_name} is out of date. Upgrade to {latest_version} with 'pip install {package_name} --upgrade'\"\n            )\n    except Exception:\n        pass\n------------------------------\n------------------------------\nRaises:\n            ValueError: If the default case is not the last case or the tuple elements are less than 2.\n        \"\"\"\n        match_cases = []\n        for case in cases:\n            if not isinstance(case, tuple):\n                raise ValueError(\n                    \"rx.match should have tuples of cases and a default case as the last argument.\"\n                )\n            # There should be at least two elements in a case tuple(a condition and return value)\n------------------------------\n------------------------------\ndef get_reflex_version() -> str:\n    \"\"\"Get the Reflex version.\n\n    Returns:\n        The Reflex version.\n    \"\"\"\n    return constants.Reflex.VERSION\n------------------------------\n------------------------------\ndef check_latest_package_version(package_name: str):\n    \"\"\"Check if the latest version of the package is installed.\n------------------------------\n------------------------------\nif build:\n        # Need to check if the files here are for the version to be published.\n        if dist_dir.exists():\n            # Check if the distribution files are for the version to be published.\n            needs_rebuild = False\n            for suffix in CustomComponents.DISTRIBUTION_FILE_SUFFIXES:\n                if not list(dist_dir.glob(f\"*{version_to_publish}*{suffix}\")):\n                    console.debug(\n------------------------------\n------------------------------\n\"\"\"The pyi generator module.\"\"\"\n\nimport logging\nimport subprocess\nimport sys\nfrom pathlib import Path\n\nfrom reflex.utils.pyi_generator import PyiGenerator, _relative_to_pwd\n\nlogger = logging.getLogger(\"pyi_generator\")\n\nLAST_RUN_COMMIT_SHA_FILE = Path(\".pyi_generator_last_run\").resolve()\nGENERATOR_FILE = Path(__file__).resolve()\nGENERATOR_DIFF_FILE = Path(\".pyi_generator_diff\").resolve()\nDEFAULT_TARGETS = [\"reflex/components\", \"reflex/experimental\", \"reflex/__init__.py\"]\n------------------------------\n------------------------------\ndef _get_version_to_publish() -> str:\n    \"\"\"Get the version to publish from the pyproject.toml.\n\n    Returns:\n        The version to publish.\n    \"\"\"\n    return _get_package_config()[\"project\"][\"version\"]\n------------------------------\n------------------------------\nif existing_init_reflex_version is None:\n        # They clone a reflex app from git for the first time.\n        # That app may or may not be 0.4 compatible.\n        # So let's just show these instructions THIS TIME.\n        return True\n\n    if constants.Reflex.VERSION < \"0.4\":\n        return False\n    else:\n        return existing_init_reflex_version < \"0.4\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_or_set_last_reflex_version_check_datetime():\n# Natural Language Annotations: \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    last_check_datetime = None\n    # Fetch the last check datetime from the reflex.json file\n    # If it doesn't exist, set it to the current datetime\n    # Update the last check datetime in the reflex.json file\n    return last_check_datetime\n```", "Sure, here is the function based on the given function signature and natural language annotations:\n\n```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    # Implementation here\n    pass\n```\n\nThe implementation of this function would depend on how you want to store and retrieve the last check time. It could be a simple file in the user's home directory, a configuration file in the user's home directory, or a database. The specifics of the implementation would depend on your requirements and the platform you're targeting.", "```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    last_version_check_datetime = None\n    # TODO: Implement this function. You need to read and write from the reflex.json file.\n    return last_version_check_datetime\n```"]}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass Middleware(Base, ABC):\n    \"\"\"Middleware to preprocess and postprocess requests.\"\"\"\n\n    async def preprocess(\n        self, app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate]:\n        \"\"\"Preprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional state update to return.\n        \"\"\"\n        return None\n------------------------------\n------------------------------\nThis is where middleware can modify the event before it is processed.\n        Each middleware is called in the order it was added to the app.\n\n        If a middleware returns an update, the event is not processed and the\n        update is returned.\n\n        Args:\n            state: The state to preprocess.\n            event: The event to preprocess.\n------------------------------\n------------------------------\nasync def _postprocess(\n        self, state: BaseState, event: Event, update: StateUpdate\n    ) -> StateUpdate:\n        \"\"\"Postprocess the event.\n\n        This is where middleware can modify the delta after it is processed.\n        Each middleware is called in the order it was added to the app.\n\n        Args:\n            state: The state to postprocess.\n            event: The event to postprocess.\n            update: The current state update.\n------------------------------\n------------------------------\nasync def postprocess(\n        self, app: App, state: BaseState, event: Event, update: StateUpdate\n    ) -> StateUpdate:\n        \"\"\"Postprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to postprocess.\n            update: The current state update.\n\n        Returns:\n            An optional state to return.\n        \"\"\"\n        return update\n------------------------------\n------------------------------\nArgs:\n            middleware: The middleware to add.\n            index: The index to add the middleware at.\n        \"\"\"\n        if index is None:\n            self.middleware.append(middleware)\n        else:\n            self.middleware.insert(index, middleware)\n\n    async def _preprocess(self, state: BaseState, event: Event) -> StateUpdate | None:\n        \"\"\"Preprocess the event.\n------------------------------\n------------------------------\nReturns:\n            An optional state to return.\n        \"\"\"\n        for middleware in self.middleware:\n            if asyncio.iscoroutinefunction(middleware.preprocess):\n                out = await middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            else:\n                out = middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            if out is not None:\n                return out  # type: ignore\n------------------------------\n------------------------------\ndef get_event(state, event):\n    \"\"\"Get the event from the given state.\n\n    Args:\n        state: The state.\n        event: The event.\n\n    Returns:\n        The event.\n    \"\"\"\n    return f\"{state.get_name()}.{event}\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def preprocess(\n# Natural Language Annotations: \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def preprocess(\n        self, app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate]:\n        \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\n        for middleware in self.middleware:\n            if asyncio.iscoroutinefunction(middleware.preprocess):\n                out = await middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            else:\n                out = middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            if out is not None:\n                return out  # type: ignore\n```", "```python\nasync def preprocess(app: App, state: BaseState, event: Event) -> Optional[StateUpdate]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    return None\n```", "```python\nasync def preprocess(\n        self, app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate]:\n        \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\n        for middleware in self.middleware:\n            if asyncio.iscoroutinefunction(middleware.preprocess):\n                out = await middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            else:\n                out = middleware.preprocess(app=self, state=state, event=event)  # type: ignore\n            if out is not None:\n                return out  # type: ignore\n```"]}, "reflex-reflex/components/component.py-get_event_triggers": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\n------------------------------\n------------------------------\nfor child in children:\n            validate_child(child)\n\n    @staticmethod\n    def _get_vars_from_event_triggers(\n        event_triggers: dict[str, EventChain | Var],\n    ) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\n\n        Args:\n            event_triggers: The event triggers from the component instance.\n------------------------------\n------------------------------\n# The stroke color of brush\n    stroke: Var[Union[str, Color]]\n\n    def get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\n\n        Returns:\n            A dict mapping the event trigger to the var that is passed to the handler.\n        \"\"\"\n        return {\n            EventTriggers.ON_CHANGE: lambda: [],\n        }\n------------------------------\n------------------------------\nReturns:\n            A dict of event trigger name to a tuple of the memoized event trigger Var and\n            the hook code that memoizes the event handler.\n        \"\"\"\n        trigger_memo = {}\n        for event_trigger, event_args in component._get_vars_from_event_triggers(\n            component.event_triggers\n        ):\n            if event_trigger in {\n                EventTriggers.ON_MOUNT,\n                EventTriggers.ON_UNMOUNT,\n                EventTriggers.ON_SUBMIT,\n------------------------------\n------------------------------\nf\" is a third party component make sure to add `{key}` to the component's event triggers. \"\n                    f\"visit https://reflex.dev/docs/wrapping-react/guide/#event-triggers for more info.\"\n                )\n            if key in component_specific_triggers:\n                # Event triggers are bound to event chains.\n                field_type = EventChain\n            elif key in props:\n                # Set the field type.\n------------------------------\n------------------------------\nReturns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        return dict(\n            tag.add_props(\n                **self.event_triggers,\n                key=self.key,\n                sx=self.style,\n                id=self.id,\n                class_name=self.class_name,\n            ).set(\n                props=tag.format_props(),\n            ),\n            cond_state=f\"isTrue({self.cond._var_full_name})\",\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_event_triggers(self) -> Dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    return {\n        EventTriggers.ON_CHANGE: lambda: [],\n    }\n```", "```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    return {\n        EventTriggers.ON_CHANGE: lambda: [],\n    }\n```", "```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    return {\n        EventTriggers.ON_CHANGE: lambda: [],\n    }\n```"]}, "reflex-reflex/components/component.py-get_props": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@abstractmethod\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n------------------------------\nReturns:\n            The object with the fields set.\n        \"\"\"\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n        return self\n\n    @classmethod\n    def get_fields(cls) -> dict[str, Any]:\n        \"\"\"Get the fields of the object.\n\n        Returns:\n            The fields of the object.\n        \"\"\"\n        return cls.__fields__\n------------------------------\n------------------------------\nReturns:\n            The code to render the component.\n        \"\"\"\n        return self.component_fn(*self.get_prop_vars())\n------------------------------\n------------------------------\ndef get_unique_variable_name() -> str:\n    \"\"\"Get a unique variable name.\n\n    Returns:\n        The unique variable name.\n    \"\"\"\n    name = \"\".join([random.choice(string.ascii_lowercase) for _ in range(8)])\n    if name not in USED_VARIABLES:\n        USED_VARIABLES.add(name)\n        return name\n    return get_unique_variable_name()\n------------------------------\n------------------------------\nReturns:\n            The components props.\n        \"\"\"\n        return {\n            name\n            for name, field in cls.get_fields().items()\n            if name in cls.get_props()\n            and types._issubclass(field.outer_type_, Component)\n        }\n\n    @classmethod\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def add_style(self) -> dict[str, Any] | None:\n        \"\"\"Add style to the component.\n------------------------------\n------------------------------\n@abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            The hash of the component.\n        \"\"\"\n        return hash(self.tag)\n\n    @classmethod\n    def get_props(cls) -> Set[str]:\n        \"\"\"Get the props for the component.\n\n        Returns:\n            The set of component props.\n        \"\"\"\n        return set()\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> Set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n------------------------------\n------------------------------\ndef _replace(self, merge_var_data=None, **kwargs: Any):\n        \"\"\"Make a copy of this Var with updated fields.\n\n        Args:\n            merge_var_data: VarData to merge into the existing VarData.\n            **kwargs: Var fields to update.\n\n        Returns:\n            A new ImmutableVar with the updated fields overwriting the corresponding fields in this Var.\n------------------------------\n------------------------------\nReturns:\n            The set of custom components.\n        \"\"\"\n        custom_components = super()._get_all_custom_components(seen=seen)\n\n        # Get the custom components for each tag.\n        for component in self.component_map.values():\n            custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n                seen=seen\n            )\n\n        return custom_components\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_props(cls) -> Set[str]:\n# Natural Language Annotations: \"\"\"Get the unique fields for the component.\n\n        Returns:\n            The unique fields.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set()\n```", "```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set(cls.__fields__)\n```", "```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the props for the component.\n\n    Returns:\n        The set of component props.\n    \"\"\"\n    return set()\n```"]}, "reflex-reflex/components/component.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\n@classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create the Plotly component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The Plotly component.\n        \"\"\"\n        from plotly.io import templates\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n------------------------------\n------------------------------\n_memoization_mode = MemoizationMode(recursive=False)\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create a new memoization leaf component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of item to add as child of the component.\n            **props: The properties of the component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    pass\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n```"]}, "reflex-reflex/components/component.py-_add_style_recursive": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn _compile_component(self)\n\n    def _apply_theme(self, theme: Optional[Component]):\n        \"\"\"Apply the theme to this component.\n\n        Deprecated. Use add_style instead.\n\n        Args:\n            theme: The theme to apply.\n        \"\"\"\n        pass\n\n    def apply_theme(self, theme: Optional[Component]):\n        \"\"\"Apply a theme to the component and its children.\n------------------------------\n------------------------------\ndef create_theme(style: ComponentStyle) -> dict:\n    \"\"\"Create the base style for the app.\n\n    Args:\n        style: The style dict for the app.\n\n    Returns:\n        The base style for the app.\n    \"\"\"\n    # Get the global style from the style dict.\n    style_rules = Style({k: v for k, v in style.items() if not isinstance(k, Callable)})\n------------------------------\n------------------------------\ndef _get_style(self) -> dict:\n        \"\"\"Get the style for the component.\n\n        Returns:\n            The dictionary of the component style as value and the style notation as key.\n        \"\"\"\n        return {\"sx\": self.style}\n\n    @classmethod\n    @lru_cache(maxsize=None)\n    def _get_dependencies_imports(cls) -> ImportDict:\n        \"\"\"Get the imports from lib_dependencies for installing.\n------------------------------\n------------------------------\nDownstream components can override this method to return a style dict\n        that will be applied to the component.\n\n        Returns:\n            The style to add.\n        \"\"\"\n        return None\n\n    def _add_style(self) -> Style:\n        \"\"\"Call add_style for all bases in the MRO.\n\n        Downstream components should NOT override. Use add_style instead.\n\n        Returns:\n            The style to add.\n        \"\"\"\n        styles = []\n------------------------------\n------------------------------\ndef _get_style(self) -> dict:\n        \"\"\"Get the style for the component.\n\n        Returns:\n            The dictionary of the component style as value and the style notation as key.\n        \"\"\"\n        if isinstance(self.style, Var):\n            return {\"css\": self.style}\n        return {\"css\": Var.create(format_as_emotion(self.style))}\n------------------------------\n------------------------------\nreturn super().create(*children, value=value, **props, class_name=cls_name)\n\n    def add_style(self) -> dict[str, Any] | None:\n        \"\"\"Add style to the component.\n------------------------------\n------------------------------\nArgs:\n            theme: The theme to apply.\n        \"\"\"\n        self._apply_theme(theme)\n        for child in self.children:\n            if isinstance(child, Component):\n                child.apply_theme(theme)\n\n    def _exclude_props(self) -> list[str]:\n        \"\"\"Props to exclude when adding the component props to the Tag.\n\n        Returns:\n            A list of component props to exclude.\n        \"\"\"\n        return []\n------------------------------\n------------------------------\n# to style Chakra components, as well as tokens from your theme such as named colors.\n    # All of the style keys offered in the original package can be used in the chakraStyles prop\n    # except for menuPortal. Along with some other caveats, this is explained below.\n    # Most of the components rendered by this package use the basic Chakra <Box /> component with a few exceptions.\n    # Here are the style keys offered and the corresponding Chakra component that is rendered:\n------------------------------\n------------------------------\ndef add_style(self) -> dict[str, Any] | None:\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return {\n            \"direction\": \"column\",\n            \"list_style_position\": \"inside\",\n        }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_style_recursive(\n# Natural Language Annotations: \"\"\"Add additional style to the component and its children.\n\n        Apply order is as follows (with the latest overriding the earliest):\n        1. Default style from `_add_style`/`add_style`.\n        2. User-defined style from `App.style`.\n        3. User-defined style from `Component.style`.\n        4. style dict and css props passed to the component instance.\n\n        Args:\n            style: A dict from component to styling.\n            theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n        Raises:\n            UserWarning: If `_add_style` has been overridden.\n\n        Returns:\n            The component with the additional style.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _add_style_recursive(self, style: dict = None, theme: Optional[Component] = None):\n    if hasattr(self, '_add_style') and self._add_style != super()._add_style:\n        raise UserWarning('_add_style has been overridden')\n    \n    self._apply_theme(theme)\n    \n    style_dict = {**self._get_style(), **(style or {})}\n    self.style = {**self._add_style(), **style_dict}\n    \n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(style_dict, theme)\n    \n    return self\n```", "```python\ndef _add_style_recursive(self, style: Optional[dict] = None, theme: Optional[Component] = None):\n    # Apply order is as follows (with the latest overriding the earliest):\n    # 1. Default style from `_add_style`/`add_style`.\n    # 2. User-defined style from `App.style`.\n    # 3. User-defined style from `Component.style`.\n    # 4. style dict and css props passed to the component instance.\n\n    # Apply default style\n    default_style = self._add_style()\n\n    # Apply user-defined style from App.style\n    if hasattr(self, 'App') and hasattr(self.App, 'style'):\n        default_style.update(self.App.style)\n\n    # Apply user-defined style from Component.style\n    if hasattr(self, 'style'):\n        default_style.update(self.style)\n\n    # Apply style dict and css props passed to the component instance\n    if style:\n        default_style.update(style)\n\n    # Apply theme if provided\n    if theme:\n        self._apply_theme(theme)\n        for child in self.children:\n            if isinstance(child, Component):\n                child._apply_theme(theme)\n\n    # Apply the calculated style to the component and its children\n    self.style = default_style\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(style=style, theme=theme)\n\n    return self\n```", "```python\ndef _add_style_recursive(self, style: dict, theme: Optional[Component] = None) -> dict:\n    # Apply order is as follows (with the latest overriding the earliest):\n    # 1. Default style from `_add_style`/`add_style`.\n    # 2. User-defined style from `App.style`.\n    # 3. User-defined style from `Component.style`.\n    # 4. style dict and css props passed to the component instance.\n\n    # Raise a warning if _add_style has been overridden\n    if self._add_style.__func__ is not Component._add_style.__func__:\n        raise UserWarning(\"_add_style has been overridden. This may cause unexpected behavior.\")\n\n    # Apply the default style\n    default_style = self._add_style()\n    if default_style is not None:\n        self.style.update(default_style)\n\n    # Apply the theme\n    self.apply_theme(theme)\n\n    # Apply the user-defined style from App.style or Component.style\n    if hasattr(self, 'style'):\n        self.style.update(self.style)\n\n    # Apply the additional style passed as argument\n    self.style.update(style)\n\n    # Apply the style dict and css props passed to the component instance\n    if hasattr(self, 'css') and self.css is not None:\n        self.style.update(self.css)\n\n    # Recursively apply the style to the children\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(self.style, theme)\n\n    return self.style\n```"]}, "reflex-reflex/components/component.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn IterTag(\n            iterable=self.iterable,\n            render_fn=self.render_fn,\n            children=self.children,\n            **props,\n        )\n\n    def render(self):\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n------------------------------\n------------------------------\nReturns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        return dict(\n            tag.add_props(\n                **self.event_triggers,\n                key=self.key,\n                sx=self.style,\n                id=self.id,\n                class_name=self.class_name,\n            ).set(\n                props=tag.format_props(),\n            ),\n            cond_state=f\"isTrue({self.cond._var_full_name})\",\n        )\n------------------------------\n------------------------------\ndef _render(self) -> Tag:\n        return MatchTag(\n            cond=self.cond, match_cases=self.match_cases, default=self.default\n        )\n\n    def render(self) -> Dict:\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        tag.name = \"match\"\n        return dict(tag)\n\n    def add_imports(self) -> ImportDict:\n        \"\"\"Add imports for the Match component.\n------------------------------\n------------------------------\n# List here the dependencies that need to be transpiled by Next.js\n    transpile_packages: List[str] = []\n\n    # The tag to use when rendering the component.\n    tag: Optional[str] = None\n\n    @abstractmethod\n    def render(self) -> dict:\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of the component.\n        \"\"\"\n------------------------------\n------------------------------\nclass Html(Div):\n    \"\"\"Render the html.\n\n    Returns:\n        The code to render the html component.\n    \"\"\"\n\n    # The HTML to render.\n    dangerouslySetInnerHTML: Var[Dict[str, str]]\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Create a html component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props to pass to the component.\n\n        Returns:\n            The html component.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self) -> Dict:\n# Natural Language Annotations: \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef render(self) -> Dict:\n    tag = self._render()\n    return dict(\n        tag.add_props(\n            **self.event_triggers,\n            key=self.key,\n            sx=self.style,\n            id=self.id,\n            class_name=self.class_name,\n        ).set(\n            props=tag.format_props(),\n        ),\n        cond_state=f\"isTrue({self.cond._var_full_name})\",\n    )\n```", "```python\ndef render(self) -> Dict:\n    tag = self._render()\n    tag.name = \"match\"\n    return dict(tag)\n```", "```python\ndef render(self) -> Dict:\n    tag = self._render()\n    return dict(\n        tag.add_props(\n            **self.event_triggers,\n            key=self.key,\n            sx=self.style,\n            id=self.id,\n            class_name=self.class_name,\n        ).set(\n            props=tag.format_props(),\n        ),\n        cond_state=f\"isTrue({self.cond._var_full_name})\",\n    )\n```"]}, "reflex-reflex/components/component.py-_get_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\n        return super()._get_vars(include_children=include_children) + [\n            prop for prop in self.props.values() if isinstance(prop, Var)\n        ]\n\n    @lru_cache(maxsize=None)  # noqa\n    def get_component(self) -> Component:\n        \"\"\"Render the component.\n------------------------------\n------------------------------\ndef _get_vars(self, include_children: bool = False) -> Iterator[Var]:\n        \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Yields:\n            The contents if it is a Var, otherwise nothing.\n        \"\"\"\n        yield self.contents\n------------------------------\n------------------------------\nReturns:\n            The prop vars.\n        \"\"\"\n        return [\n            BaseVar(\n                _var_name=name,\n                _var_type=(\n                    prop._var_type if types._isinstance(prop, Var) else type(prop)\n                ),\n            )\n            for name, prop in self.props.items()\n        ]\n\n    def _get_vars(self, include_children: bool = False) -> list[Var]:\n        \"\"\"Walk all Vars used in this component.\n------------------------------\n------------------------------\nfor child in children:\n            validate_child(child)\n\n    @staticmethod\n    def _get_vars_from_event_triggers(\n        event_triggers: dict[str, EventChain | Var],\n    ) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\n\n        Args:\n            event_triggers: The event triggers from the component instance.\n------------------------------\n------------------------------\n# Get static imports required for event processing.\n        event_imports = Imports.EVENTS if self.event_triggers else {}\n\n        # Collect imports from Vars used directly by this component.\n        var_imports = [\n            var._var_data.imports for var in self._get_vars() if var._var_data\n        ]\n\n        added_import_dicts: list[ParsedImportDict] = []\n        for clz in self._iter_parent_classes_with_method(\"add_imports\"):\n            list_of_import_dict = clz.add_imports(self)\n------------------------------\n------------------------------\n# Return None to indicate this component should not be memoized.\n        return None\n\n    @staticmethod\n    def _child_var(child: Component) -> Var | Component:\n        \"\"\"Get the Var from a child component.\n\n        This method is used for special cases when the StatefulComponent should actually\n        wrap the parent component of the child instead of recursing into the children\n        and memoizing them independently.\n\n        Args:\n            child: The child component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_vars(self, include_children: bool = False) -> list[Var]:\n# Natural Language Annotations: \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars = super()._get_vars(include_children=include_children)\n    vars.extend([prop for prop in self.props.values() if isinstance(prop, Var)])\n    return vars\n```", "```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_list = [prop for prop in self.props.values() if isinstance(prop, Var)]\n    if include_children:\n        for child in children:\n            vars_list.extend(child._get_vars())\n    return vars_list\n```", "```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_list = []\n    if include_children:\n        for child in self.children:\n            vars_list.extend(child._get_vars())\n\n    vars_list.extend([prop for prop in self.props.values() if isinstance(prop, Var)])\n\n    return vars_list\n```"]}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            True if any of the component's event trigger values uses State.\n        \"\"\"\n        for trigger in self.event_triggers.values():\n            if isinstance(trigger, EventChain):\n                for event in trigger.events:\n                    if event.handler.state_full_name:\n                        return True\n            elif isinstance(trigger, Var) and trigger._var_state:\n                return True\n        return False\n------------------------------\n------------------------------\ndef _event_trigger_values_use_state(self) -> bool:\n        \"\"\"Check if the values of a component's event trigger use state.\n------------------------------\n------------------------------\ndef get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\n------------------------------\n------------------------------\n# Valid children components\n    _valid_children: List[str] = [\n        \"PolarAngleAxis\",\n        \"PolarRadiusAxis\",\n        \"PolarGrid\",\n        \"Legend\",\n        \"GraphingTooltip\",\n        \"Radar\",\n    ]\n\n    def get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\n------------------------------\n------------------------------\nfor child in children:\n            validate_child(child)\n\n    @staticmethod\n    def _get_vars_from_event_triggers(\n        event_triggers: dict[str, EventChain | Var],\n    ) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\n\n        Args:\n            event_triggers: The event triggers from the component instance.\n------------------------------\n------------------------------\ndef code_uses_state_contexts(javascript_code: str) -> bool:\n    \"\"\"Check if the rendered Javascript uses state contexts.\n\n    Args:\n        javascript_code: The Javascript code to check.\n\n    Returns:\n        True if the code attempts to access a member of StateContexts.\n    \"\"\"\n    return bool(\"useContext(StateContexts\" in javascript_code)\n------------------------------\n------------------------------\nReturns:\n            The memoized component tree.\n        \"\"\"\n        if isinstance(component, Component):\n            if component._memoization_mode.recursive:\n                # Recursively memoize stateful children (default).\n                component.children = [\n                    cls.compile_from(child) for child in component.children\n                ]\n            # Memoize this component if it depends on state.\n            stateful_component = cls.create(component)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _has_stateful_event_triggers(self):\n# Natural Language Annotations: \"\"\"Check if component or children have any event triggers that use state.\n\n        Returns:\n            True if the component or children have any event triggers that uses state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"Check if component or children have any event triggers that use state.\"\"\"\n\n    def _event_trigger_values_use_state(self) -> bool:\n        \"\"\"Check if the values of a component's event trigger use state.\"\"\"\n        for trigger in self.event_triggers.values():\n            if isinstance(trigger, EventChain):\n                for event in trigger.events:\n                    if event.handler.state_full_name:\n                        return True\n            elif isinstance(trigger, Var) and trigger._var_state:\n                return True\n        return False\n\n    if self._event_trigger_values_use_state():\n        return True\n\n    for child in self.children:\n        if child._event_trigger_values_use_state():\n            return True\n\n    return False\n```", "```python\ndef _has_stateful_event_triggers(self) -> bool:\n    \"\"\"Check if component or children have any event triggers that use state.\"\"\"\n    \n    def _event_trigger_uses_state(trigger) -> bool:\n        if isinstance(trigger, EventChain):\n            for event in trigger.events:\n                if event.handler.state_full_name:\n                    return True\n        elif isinstance(trigger, Var) and trigger._var_state:\n            return True\n        return False\n    \n    for trigger in self.event_triggers.values():\n        if _event_trigger_uses_state(trigger):\n            return True\n    \n    if self.children:\n        for child in self.children:\n            if child._has_stateful_event_triggers():\n                return True\n    \n    return False\n```", "```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"Check if component or children have any event triggers that use state.\"\"\"\n\n    def _event_trigger_values_use_state(self) -> bool:\n        \"\"\"Check if the values of a component's event trigger use state.\"\"\"\n\n        for trigger in self.event_triggers.values():\n            if isinstance(trigger, EventChain):\n                for event in trigger.events:\n                    if event.handler.state_full_name:\n                        return True\n            elif isinstance(trigger, Var) and trigger._var_state:\n                return True\n        return False\n\n    def get_event_triggers(self) -> dict[str, Union[Var, Any]]:\n        \"\"\"Get the event triggers that pass the component's value to the handler.\"\"\"\n\n    def _get_vars_from_event_triggers(event_triggers: dict[str, EventChain | Var]) -> Iterator[tuple[str, list[Var]]]:\n        \"\"\"Get the Vars associated with each event trigger.\"\"\"\n\n    if _event_trigger_values_use_state(self):\n        return True\n\n    for child in self.children:\n        if _has_stateful_event_triggers(child):\n            return True\n\n    return False\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_code": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The custom code.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_custom_code().union({self.code})\n\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_refs()\n------------------------------\n------------------------------\n@abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n------------------------------\ndef _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def _get_dynamic_imports(self) -> str | None:\n        \"\"\"Get dynamic import for the component.\n\n        Returns:\n            The dynamic import.\n        \"\"\"\n        return None\n\n    def _get_all_dynamic_imports(self) -> Set[str]:\n        \"\"\"Get dynamic imports for the component and its children.\n------------------------------\n------------------------------\n# Fetch custom components from props as well.\n        for child_component in self.component_props.values():\n            if child_component.tag is None:\n                continue\n            if child_component.tag not in seen:\n                seen.add(child_component.tag)\n                if isinstance(child_component, CustomComponent):\n                    custom_components |= {child_component}\n                custom_components |= child_component._get_all_custom_components(\n------------------------------\n------------------------------\n@abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            The custom code for the component.\n        \"\"\"\n        custom_code = super()._get_all_custom_code()\n        if self.auto_height is not None:\n            custom_code.add(AUTO_HEIGHT_JS)\n        if self.enter_key_submit is not None:\n            custom_code.add(ENTER_KEY_SUBMIT_JS)\n        return custom_code\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_code(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Get custom code for the component and its children.\n\n        Returns:\n            The custom code.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    if self.rendered_as_shared:\n        return set()\n    custom_code = self.component._get_all_custom_code().union({self.code})\n    for child_component in self.component_props.values():\n        if child_component.tag is None:\n            continue\n        if child_component.tag not in seen:\n            seen.add(child_component.tag)\n            if isinstance(child_component, CustomComponent):\n                custom_code |= {child_component}\n            custom_code |= child_component._get_all_custom_components()\n    return custom_code\n```", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    if self.rendered_as_shared:\n        return set()\n    custom_code = self.component._get_all_custom_code().union({self.code})\n    if self.auto_height is not None:\n        custom_code.add(AUTO_HEIGHT_JS)\n    if self.enter_key_submit is not None:\n        custom_code.add(ENTER_KEY_SUBMIT_JS)\n    return custom_code\n```", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    if self.rendered_as_shared:\n        return set()\n    custom_code = self.component._get_all_custom_code().union({self.code})\n    for child_component in self.component_props.values():\n        if child_component.tag is None:\n            continue\n        if child_component.tag not in seen:\n            seen.add(child_component.tag)\n            if isinstance(child_component, CustomComponent):\n                custom_code |= {child_component}\n            custom_code |= child_component._get_all_custom_components()\n    return custom_code\n```"]}, "reflex-reflex/components/component.py-_get_all_imports": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n        if self.rendered_as_shared:\n            return {\n                f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [\n                    ImportVar(tag=self.tag)\n                ]\n            }\n        return self.component._get_all_imports()\n------------------------------\n------------------------------\nreturn imports.merge_imports(_imports, *other_imports)\n\n    def _get_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The imports needed by the component.\n        \"\"\"\n        _imports = {}\n\n        # Import this component's tag from the main library.\n        if self.library is not None and self.tag is not None:\n            _imports[self.library] = {self.import_var}\n------------------------------\n------------------------------\n@abstractmethod\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n------------------------------\n------------------------------\ndef compile_imports(import_dict: ParsedImportDict) -> list[dict]:\n    \"\"\"Compile an import dict.\n\n    Args:\n        import_dict: The import dict to compile.\n\n    Returns:\n        The list of import dict.\n    \"\"\"\n    collapsed_import_dict: ParsedImportDict = imports.collapse_imports(import_dict)\n    validate_imports(collapsed_import_dict)\n    import_dicts = []\n    for lib, fields in collapsed_import_dict.items():\n        default, rest = compile_import_statement(fields)\n------------------------------\n------------------------------\ndef compile_custom_component(\n    component: CustomComponent,\n) -> tuple[dict, ParsedImportDict]:\n    \"\"\"Compile a custom component.\n\n    Args:\n        component: The custom component to compile.\n\n    Returns:\n        A tuple of the compiled component and the imports required by the component.\n    \"\"\"\n    # Render the component.\n    render = component.get_component(component)\n------------------------------\n------------------------------\ndef collapse_imports(imports: ParsedImportDict) -> ParsedImportDict:\n    \"\"\"Remove all duplicate ImportVar within an ImportDict.\n\n    Args:\n        imports: The import dict to collapse.\n\n    Returns:\n        The collapsed import dict.\n    \"\"\"\n    return {\n        lib: list(set(import_vars)) if isinstance(import_vars, list) else import_vars\n        for lib, import_vars in imports.items()\n    }\n------------------------------\n------------------------------\ndef _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def _get_dynamic_imports(self) -> str | None:\n        \"\"\"Get dynamic import for the component.\n\n        Returns:\n            The dynamic import.\n        \"\"\"\n        return None\n\n    def _get_all_dynamic_imports(self) -> Set[str]:\n        \"\"\"Get dynamic imports for the component and its children.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n# Natural Language Annotations: \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n        Args:\n            collapse: Whether to collapse the imports by removing duplicates.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    imports = {}\n    if self.rendered_as_shared:\n        imports[f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\"] = [ImportVar(tag=self.tag)]\n    else:\n        imports = {**imports, **self.component._get_all_imports()}\n\n    if collapse:\n        imports = collapse_imports(imports)\n\n    return imports\n```", "```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    _imports = self._get_imports()\n    if self.rendered_as_shared:\n        all_import_dicts = [\n            {\n                f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [\n                    ImportVar(tag=self.tag)\n                ]\n            }\n        ]\n    else:\n        all_import_dicts = [self.component._get_all_imports()]\n    all_import_dicts.extend(all_import_dicts)\n    imports = imports.merge_imports(_imports, *all_import_dicts)\n    return imports.collapse_imports(imports) if collapse else imports\n```", "```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    if self.rendered_as_shared:\n        import_dict = {\n            f\"/{Dirs.UTILS}/{PageNames.STATEFUL_COMPONENTS}\": [\n                ImportVar(tag=self.tag)\n            ]\n        }\n    else:\n        import_dict = self.component._get_all_imports()\n\n    if self.children:\n        for child in self.children:\n            child_imports = child._get_all_imports(collapse)\n            import_dict = imports.merge_imports(import_dict, child_imports)\n\n    if collapse:\n        import_dict = imports.collapse_imports(import_dict)\n\n    return import_dict\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n------------------------------\n------------------------------\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n------------------------------\n------------------------------\ndef _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def get_ref(self) -> str | None:\n        \"\"\"Get the name of the ref for the component.\n------------------------------\n------------------------------\n# Render the code for this component and hooks.\n        return STATEFUL_COMPONENT.render(\n            tag_name=tag_name,\n            memo_trigger_hooks=memo_trigger_hooks,\n            component=component,\n        )\n\n    @staticmethod\n    def _get_hook_deps(hook: str) -> list[str]:\n        \"\"\"Extract var deps from a hook.\n\n        Args:\n            hook: The hook line to extract deps from.\n------------------------------\n------------------------------\ndef _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def _get_dynamic_imports(self) -> str | None:\n        \"\"\"Get dynamic import for the component.\n\n        Returns:\n            The dynamic import.\n        \"\"\"\n        return None\n\n    def _get_all_dynamic_imports(self) -> Set[str]:\n        \"\"\"Get dynamic imports for the component and its children.\n------------------------------\n------------------------------\ndef _get_added_hooks(self) -> dict[str, ImportDict]:\n        \"\"\"Get the hooks added via `add_hooks` method.\n\n        Returns:\n            The deduplicated hooks and imports added by the component and parent components.\n        \"\"\"\n        code = {}\n------------------------------\n------------------------------\nReturns:\n            The custom code.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_custom_code().union({self.code})\n\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n            The refs for the children.\n        \"\"\"\n        if self.rendered_as_shared:\n            return set()\n        return self.component._get_all_refs()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks_internal(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {}\n```", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {}\n```", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {}\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n------------------------------\n------------------------------\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n------------------------------\n------------------------------\ndef _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def get_ref(self) -> str | None:\n        \"\"\"Get the name of the ref for the component.\n------------------------------\n------------------------------\ndef _get_special_hooks(self) -> dict[str, None]:\n        \"\"\"Get the hooks required by special actions referenced in this component.\n\n        Returns:\n            The hooks for special actions.\n        \"\"\"\n        return {Hooks.AUTOFOCUS: None} if self.autofocus else {}\n\n    def _get_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component managed by the framework.\n------------------------------\n------------------------------\ndef _render(self) -> Tag:\n        \"\"\"Define how to render the component in React.\n\n        Returns:\n            The tag to render.\n        \"\"\"\n        return super()._render(props=self.props)\n\n    def get_prop_vars(self) -> List[BaseVar]:\n        \"\"\"Get the prop vars.\n------------------------------\n------------------------------\ndef _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def _get_dynamic_imports(self) -> str | None:\n        \"\"\"Get dynamic import for the component.\n\n        Returns:\n            The dynamic import.\n        \"\"\"\n        return None\n\n    def _get_all_dynamic_imports(self) -> Set[str]:\n        \"\"\"Get dynamic imports for the component and its children.\n------------------------------\n------------------------------\nArgs:\n        page_components: The Components or StatefulComponents to compile.\n\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the React hooks for this component and its children.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    hooks = self._get_all_hooks_internal()\n    hooks.update(self._get_hooks_internal())\n    hooks.update(self._get_special_hooks())\n    hooks.update(self._get_custom_code())\n    return hooks\n```", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    hooks = self._get_all_hooks_internal()\n    for child in self.children:\n        hooks.update(child._get_all_hooks())\n\n    return hooks\n```", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    all_hooks = {}\n    all_hooks.update(self._get_all_hooks_internal())\n    all_hooks.update(self._get_all_hooks())\n    all_hooks.update(self._get_special_hooks())\n    all_hooks.update(self._get_hooks_internal())\n    return all_hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_components": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\n        assert self.tag is not None, \"The tag must be set.\"\n\n        # Store the seen components in a set to avoid infinite recursion.\n        if seen is None:\n            seen = set()\n        custom_components = {self} | super()._get_all_custom_components(seen=seen)\n------------------------------\n------------------------------\n# Create the component.\n        return super().create(\n            src,\n            component_map=component_map,\n            component_map_hash=cls._component_map_hash(component_map),\n            **props,\n        )\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n------------------------------\n------------------------------\nReturns:\n            The set of custom components.\n        \"\"\"\n        custom_components = super()._get_all_custom_components(seen=seen)\n\n        # Get the custom components for each tag.\n        for component in self.component_map.values():\n            custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n                seen=seen\n            )\n\n        return custom_components\n------------------------------\n------------------------------\nReturns:\n            The hash of the component.\n        \"\"\"\n        return hash(self.tag)\n\n    @classmethod\n    def get_props(cls) -> Set[str]:\n        \"\"\"Get the props for the component.\n\n        Returns:\n            The set of component props.\n        \"\"\"\n        return set()\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> Set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n------------------------------\n------------------------------\n# The name of the custom components source directory.\n    SRC_DIR = \"custom_components\"\n    # The name of the custom components pyproject.toml file.\n    PYPROJECT_TOML = \"pyproject.toml\"\n    # The name of the custom components package README file.\n    PACKAGE_README = \"README.md\"\n    # The name of the custom components package .gitignore file.\n    PACKAGE_GITIGNORE = \".gitignore\"\n    # The name of the distribution directory as result of a build.\n    DIST_DIR = \"dist\"\n------------------------------\n------------------------------\nseen=seen\n                )\n        return custom_components\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_components(\n# Natural Language Annotations: \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> Set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    custom_components = super()._get_all_custom_components(seen=seen)\n\n    # Get the custom components for each tag.\n    for component in self.component_map.values():\n        custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n            seen=seen\n        )\n\n    return custom_components\n```", "```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> set[CustomComponent]:\n    custom_components = super()._get_all_custom_components(seen=seen)\n\n    # Get the custom components for each tag.\n    for component in self.component_map.values():\n        custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n            seen=seen\n        )\n\n    return custom_components\n```", "```python\ndef _get_all_custom_components(\n    self, seen: set[str] | None = None\n) -> set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    if seen is None:\n        seen = set()\n    custom_components = {self} | super()._get_all_custom_components(seen=seen)\n\n    # Get the custom components for each tag.\n    for component in self.component_map.values():\n        custom_components |= component(_MOCK_ARG)._get_all_custom_components(\n            seen=seen\n        )\n\n    return custom_components\n```"]}, "reflex-reflex/components/core/upload.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an Input component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nclass StyledUpload(Upload):\n    \"\"\"The styled Upload Component.\"\"\"\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create the styled upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of item to add as child of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n------------------------------\n------------------------------\n@classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create the Plotly component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The Plotly component.\n        \"\"\"\n        from plotly.io import templates\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create an upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The upload component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    pass\n```", "```python\n@classmethod\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    pass\n```"]}, "reflex-reflex/components/next/image.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The props of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of items to add to the list.\n            list_style_type: The style of the list.\n            **props: The properties of the component.\n\n        Returns:\n            The list component.\n\n        \"\"\"\n        props[\"margin_left\"] = props.get(\"margin_left\", \"1.5rem\")\n        return super().create(\n            *children, items=items, list_style_type=list_style_type, **props\n        )\n------------------------------\n------------------------------\n# Fired when the image fails to load.\n    on_error: EventHandler[lambda: []]\n\n    # Fired when the image is loaded.\n    on_load: EventHandler[lambda: []]\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an Image component.\n\n        Args:\n            *children: The children of the image.\n            **props: The props of the image.\n------------------------------\n------------------------------\n@classmethod\n    def create(\n        cls,\n        *children,\n        width: Optional[str] = \"100%\",\n        **props,\n    ) -> Component:\n        \"\"\"Create a Slider component.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the slider.\n            **props: The properties of the component.\n\n        Returns:\n            The component.\n        \"\"\"\n        default_value = props.pop(\"default_value\", [50])\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            items: A list of item to add as child of the component.\n            **props: The properties of the component.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create an Image component from next/image.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the image.\n            height: The height of the image.\n            **props:The props of the component.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(\n    *children,\n    width: Optional[str] = \"100%\",\n    height: Optional[str] = \"100%\",\n    **props,\n) -> Component:\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props: The props of the component.\n\n    Returns:\n        The Image component.\n    \"\"\"\n    return Image(width, height, *children, **props)\n```", "```python\ndef create(self, *children, width: str = \"100%\", height: str = \"100%\", **props) -> Component:\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props:The props of the component.\n\n    Returns:\n        _type_: _description_\n    \"\"\"\n    pass\n```", "```python\ndef create(self, *children, width: Optional[str] = \"100%\", height: Optional[str] = \"100%\", **props) -> Component:\n    return super().create(*children, width=width, height=height, **props)\n```"]}, "reflex-reflex/components/lucide/icon.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass Icon(ChakraIconComponent):\n    \"\"\"An image icon.\"\"\"\n\n    tag = \"None\"\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n------------------------------\n------------------------------\nclass AccordionIcon(Icon):\n    \"\"\"An accordion icon component.\"\"\"\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create the Accordion icon component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n------------------------------\n------------------------------\nArgs:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Returns:\n            The created component.\n        \"\"\"\n        ARIA_LABEL_KEY = \"aria_label\"\n        if props.get(ARIA_LABEL_KEY) is not None:\n            props[format.to_kebab_case(ARIA_LABEL_KEY)] = props.pop(ARIA_LABEL_KEY)\n\n        return super().create(*children, **props)\n------------------------------\n------------------------------\nReturns:\n            The created component.\n        \"\"\"\n        if children:\n            raise AttributeError(\n                f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n            )\n        if \"tag\" not in props:\n            raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n        if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n            raise ValueError(\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Raises:\n            ValueError: If no children are passed.\n------------------------------\n------------------------------\ndef get_component(self, tag: str, **props) -> Component:\n        \"\"\"Get the component for a tag and props.\n\n        Args:\n            tag: The tag of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n\n        Raises:\n            ValueError: If the tag is invalid.\n        \"\"\"\n        # Check the tag is valid.\n        if tag not in self.component_map:\n            raise ValueError(f\"No markdown component found for tag: {tag}.\")\n------------------------------\n------------------------------\nReturns:\n            The IconButton component.\n        \"\"\"\n        if children:\n            if isinstance(children[0], str):\n                children = [\n                    Icon.create(\n                        children[0],\n                    )\n                ]\n        else:\n            raise ValueError(\n                \"IconButton requires a child icon. Pass a string as the first child or a rx.icon.\"\n            )\n        if \"size\" in props:\n------------------------------\n------------------------------\nArgs:\n            *children: The children of the component.\n            icon: The icon of the alert.\n            title: The title of the alert.\n            desc: The description of the alert\n            **props: The properties of the component.\n\n        Returns:\n            The alert component.\n        \"\"\"\n        if len(children) == 0:\n            children = []\n\n            if icon:\n                children.append(AlertIcon.create())\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n            f\"Invalid tag value: {props['tag']}. Valid values are {ICON_LIST}\"\n        )\n    return super().create(*children, **props)\n```", "```python\nclass Icon(ChakraIconComponent):\n    \"\"\"An image icon.\"\"\"\n\n    tag = \"None\"\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\n        if children:\n            raise AttributeError(\n                f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n            )\n        if \"tag\" not in props:\n            raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n        if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n            raise ValueError(\n                f\"Invalid icon tag: {props['tag']}. Must be one of {ICON_LIST}\"\n            )\n\n        return super().create(*children, **props)\n```", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n```"]}, "reflex-reflex/components/tags/tag.py-format_props": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef format_props(*single_props, **key_value_props) -> list[str]:\n    \"\"\"Format the tag's props.\n\n    Args:\n        single_props: Props that are not key-value pairs.\n        key_value_props: Props that are key-value pairs.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Format all the props.\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(key_value_props.items())\n        if prop is not None\n    ] + [str(prop) for prop in single_props]\n------------------------------\n------------------------------\ndef format_component(self, tag: str, **props) -> str:\n        \"\"\"Format a component for rendering in the component map.\n\n        Args:\n            tag: The tag of the component.\n            **props: Extra props to pass to the component function.\n\n        Returns:\n            The formatted component.\n        \"\"\"\n        return str(self.get_component(tag, **props)).replace(\"\\n\", \"\")\n\n    def format_component_map(self) -> dict[str, str]:\n        \"\"\"Format the component map for rendering.\n------------------------------\n------------------------------\ndef format_prop(\n    prop: Union[Var, EventChain, ComponentStyle, str],\n) -> Union[int, float, str]:\n    \"\"\"Format a prop.\n\n    Args:\n        prop: The prop to format.\n\n    Returns:\n        The formatted prop to display within a tag.\n------------------------------\n------------------------------\ndef format_string(string: str) -> str:\n    \"\"\"Format the given string as a JS string literal..\n\n    Args:\n        string: The string to format.\n\n    Returns:\n        The formatted string.\n    \"\"\"\n    return _wrap_js_string(_escape_js_string(string))\n------------------------------\n------------------------------\ndef format_data_editor_column(col: str | dict):\n    \"\"\"Format a given column into the proper format.\n\n    Args:\n        col: The column.\n\n    Raises:\n        ValueError: invalid type provided for column.\n\n    Returns:\n        The formatted column.\n    \"\"\"\n    if isinstance(col, str):\n        return {\"title\": col, \"id\": col.lower(), \"type\": \"str\"}\n------------------------------\n------------------------------\nReturns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n        return dict(\n            tag.add_props(\n                **self.event_triggers,\n                key=self.key,\n                sx=self.style,\n                id=self.id,\n                class_name=self.class_name,\n            ).set(\n                props=tag.format_props(),\n            ),\n            cond_state=f\"isTrue({self.cond._var_full_name})\",\n        )\n------------------------------\n------------------------------\nReturns:\n            The hash of the component.\n        \"\"\"\n        return hash(self.tag)\n\n    @classmethod\n    def get_props(cls) -> Set[str]:\n        \"\"\"Get the props for the component.\n\n        Returns:\n            The set of component props.\n        \"\"\"\n        return set()\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> Set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n------------------------------\n------------------------------\nReturns:\n            The formatted component map.\n        \"\"\"\n        components = {\n            tag: f\"{{({{node, {_CHILDREN._var_name}, {_PROPS._var_name}}}) => {self.format_component(tag)}}}\"\n            for tag in self.component_map\n        }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def format_props(self) -> List:\n# Natural Language Annotations: \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef format_props(self) -> list:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    formatted_props = []\n    for name, prop in sorted(self.key_value_props.items()):\n        if prop is not None:\n            formatted_props.append(f\"{name}={prop}\")\n    formatted_props.extend([str(prop) for prop in self.single_props])\n    return formatted_props\n```", "```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Format all the props.\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(self.props.items())\n        if prop is not None\n    ] + [str(prop) for prop in self.single_props]\n```", "```python\ndef format_props(self) -> list[str]:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    return [\n        f\"{name}={format_prop(prop)}\"\n        for name, prop in sorted(self.props.items())\n        if prop is not None\n    ]\n```"]}, "textual-src/textual/screen.py-focus_next": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn widgets\n\n    def _move_focus(\n        self, direction: int = 0, selector: str | type[QueryType] = \"*\"\n    ) -> Widget | None:\n        \"\"\"Move the focus in the given direction.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n------------------------------\n------------------------------\nReturns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        # TODO: This shouldn't be required\n        self._compositor._full_map_invalidated = True\n        if not isinstance(selector, str):\n            selector = selector.__name__\n        selector_set = parse_selectors(selector)\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\nArgs:\n            direction: 1 to move forward, -1 to move backward, or\n                0 to keep the current focus.\n            selector: CSS selector to filter\n                what nodes can be focused.\n------------------------------\n------------------------------\ndef filter(self, selector: str) -> DOMQuery[QueryType]:\n        \"\"\"Filter this set by the given CSS selector.\n\n        Args:\n            selector: A CSS selector.\n\n        Returns:\n            New DOM Query.\n        \"\"\"\n\n        return DOMQuery(\n            self.node,\n            filter=selector,\n            deep=self._deep,\n            parent=self,\n        )\n\n    def exclude(self, selector: str) -> DOMQuery[QueryType]:\n        \"\"\"Exclude nodes that match a given selector.\n------------------------------\n------------------------------\ndef get_focusable_widget_at(self, x: int, y: int) -> Widget | None:\n        \"\"\"Get the focusable widget under a given coordinate.\n\n        If the widget directly under the given coordinate is not focusable, then this method will check\n        if any of the ancestors are focusable. If no ancestors are focusable, then `None` will be returned.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n------------------------------\n------------------------------\nArgs:\n            selector: A CSS selector, widget type, or `None` for all nodes.\n\n        Returns:\n            A query object.\n        \"\"\"\n        from .css.query import DOMQuery, QueryType\n        from .widget import Widget\n\n        if isinstance(selector, str) or selector is None:\n            return DOMQuery[Widget](self, filter=selector)\n        else:\n            return DOMQuery[QueryType](self, filter=selector.__name__)\n\n    if TYPE_CHECKING:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n    focused = self.screen.focused\n    if focused is not None and focused.loading:\n        return None\n    return focused\n```", "```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: This shouldn't be required\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n    # TODO: Implement logic to focus next widget\n    # This logic may involve:\n    # 1. Getting all focusable widgets\n    # 2. Filtering these widgets by the provided selector\n    # 3. Finding the next widget in this filtered list\n    # 4. Setting this as the focused widget\n    pass\n```", "```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n\n    focused = self.screen.focused\n    if focused is not None and focused.loading:\n        return None\n    return focused\n```"]}, "textual-src/textual/screen.py-focus_previous": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nreturn widgets\n\n    def _move_focus(\n        self, direction: int = 0, selector: str | type[QueryType] = \"*\"\n    ) -> Widget | None:\n        \"\"\"Move the focus in the given direction.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n------------------------------\n------------------------------\nReturns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        # TODO: This shouldn't be required\n        self._compositor._full_map_invalidated = True\n        if not isinstance(selector, str):\n            selector = selector.__name__\n        selector_set = parse_selectors(selector)\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\nArgs:\n            direction: 1 to move forward, -1 to move backward, or\n                0 to keep the current focus.\n            selector: CSS selector to filter\n                what nodes can be focused.\n------------------------------\n------------------------------\ndef filter(self, selector: str) -> DOMQuery[QueryType]:\n        \"\"\"Filter this set by the given CSS selector.\n\n        Args:\n            selector: A CSS selector.\n\n        Returns:\n            New DOM Query.\n        \"\"\"\n\n        return DOMQuery(\n            self.node,\n            filter=selector,\n            deep=self._deep,\n            parent=self,\n        )\n\n    def exclude(self, selector: str) -> DOMQuery[QueryType]:\n        \"\"\"Exclude nodes that match a given selector.\n------------------------------\n------------------------------\ndef get_focusable_widget_at(self, x: int, y: int) -> Widget | None:\n        \"\"\"Get the focusable widget under a given coordinate.\n\n        If the widget directly under the given coordinate is not focusable, then this method will check\n        if any of the ancestors are focusable. If no ancestors are focusable, then `None` will be returned.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n------------------------------\n------------------------------\nArgs:\n            selector: A CSS selector, widget type, or `None` for all nodes.\n\n        Returns:\n            A query object.\n        \"\"\"\n        from .css.query import DOMQuery, QueryType\n        from .widget import Widget\n\n        if isinstance(selector, str) or selector is None:\n            return DOMQuery[Widget](self, filter=selector)\n        else:\n            return DOMQuery[QueryType](self, filter=selector.__name__)\n\n    if TYPE_CHECKING:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    focused_widget = self.focused\n    if focused_widget is not None:\n        # Find the previous focusable widget\n        previous_widget = focused_widget.get_previous_focusable()\n        if previous_widget is not None and self._is_matching_selector(previous_widget, selector):\n            return self._move_focus(0, previous_widget)\n\n    # If no previous focusable widget was found, focus the first focusable widget\n    return self._move_focus(0, \"*\")\n```", "```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n\n    focused = self.screen.focused\n    if focused is not None and focused.loading:\n        return None\n    return focused\n```", "```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n    focused = self.focused\n    if focused is None:\n        return self._move_focus(0, selector)\n    else:\n        return self._move_focus(-1, selector)\n```"]}, "textual-src/textual/screen.py-set_focus": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n        \"\"\"Focus (or unfocus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\n        self.screen.set_focus(widget, scroll_visible)\n\n    def _set_mouse_over(self, widget: Widget | None) -> None:\n        \"\"\"Called when the mouse is over another widget.\n------------------------------\n------------------------------\ndef _start_widget(self, parent: Widget, widget: Widget) -> None:\n        \"\"\"Start a widget (run it's task) so that it can receive messages.\n\n        Args:\n            parent: The parent of the Widget.\n            widget: The Widget to start.\n        \"\"\"\n\n        widget._attach(parent)\n        widget._start_messages()\n        self.app._registry.add(widget)\n\n    def is_mounted(self, widget: Widget) -> bool:\n        \"\"\"Check if a widget is mounted.\n\n        Args:\n            widget: A widget.\n------------------------------\n------------------------------\n@property\n    def focused(self) -> Widget | None:\n        \"\"\"The widget that is focused on the currently active screen, or `None`.\n\n        Focused widgets receive keyboard input.\n\n        Returns:\n            The currently focused widget, or `None` if nothing is focused.\n        \"\"\"\n        focused = self.screen.focused\n        if focused is not None and focused.loading:\n            return None\n        return focused\n------------------------------\n------------------------------\ndef focus(self, scroll_visible: bool = True) -> Self:\n        \"\"\"Give focus to this widget.\n\n        Args:\n            scroll_visible: Scroll parent to make this widget visible.\n\n        Returns:\n            The `Widget` instance.\n        \"\"\"\n\n        def set_focus(widget: Widget) -> None:\n            \"\"\"Callback to set the focus.\"\"\"\n            try:\n                widget.screen.set_focus(self, scroll_visible=scroll_visible)\n            except NoScreen:\n                pass\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n# Natural Language Annotations: \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    self.screen.set_focus(widget, scroll_visible)\n```", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is None:\n        self.screen.set_focus(None, scroll_visible)\n    else:\n        self.screen.set_focus(widget, scroll_visible)\n```", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is None:\n        self.screen.set_focus(None, scroll_visible)\n    else:\n        self.screen.set_focus(widget, scroll_visible)\n```"]}, "textual-src/textual/strip.py-index_to_cell_position": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef index_to_cell_position(segments: Iterable[Segment], index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character within\n    an Iterable of Segments. This is the sum of the cell lengths of all the characters\n    *before* the character at `index`.\n\n    Args:\n        segments: The segments to find the cell position within.\n        index: The index to convert into a cell position.\n\n    Returns:\n        The cell position of the character at `index`.\n------------------------------\n------------------------------\nArgs:\n            start: The start cell position (inclusive).\n            end: The end cell position (exclusive).\n------------------------------\n------------------------------\nReturns:\n            The index in the document's text.\n        \"\"\"\n        row, column = location\n        index = row * len(self.newline) + column\n        for line_index in range(row):\n            index += len(self.get_line(line_index))\n        return index\n\n    def get_location_from_index(self, index: int) -> Location:\n        \"\"\"Given an index in the document's text, returns the corresponding location.\n\n        Args:\n            index: The index in the document's text.\n------------------------------\n------------------------------\nArgs:\n            cursor: The current position of the cursor.\n            target_cell: The cell we're checking for the need to highlight.\n            type_of_cursor: The type of cursor that is currently active.\n------------------------------\n------------------------------\ndef cell_width_to_column_index(line: str, cell_width: int, tab_width: int) -> int:\n    \"\"\"Retrieve the column index corresponding to the given cell width.\n\n    Args:\n        line: The line of text to search within.\n        cell_width: The cell width to convert to column index.\n        tab_width: The tab stop width to expand tabs contained within the line.\n------------------------------\n------------------------------\nArgs:\n            cell_width: The cell width to convert.\n            row_index: The index of the row to examine.\n\n        Returns:\n            The column corresponding to the cell width on that row.\n        \"\"\"\n        line = self.document[row_index]\n        return cell_width_to_column_index(line, cell_width, self.indent_width)\n\n    def clamp_visitable(self, location: Location) -> Location:\n        \"\"\"Clamp the given location to the nearest visitable location.\n------------------------------\n------------------------------\nreturn replace_result\n\n    def get_line(self, line_index: int) -> str:\n        \"\"\"Return the string representing the line, not including new line characters.\n\n        Args:\n            line_index: The index of the line.\n\n        Returns:\n            The string representing the line.\n        \"\"\"\n        line_string = self[line_index]\n        return line_string\n------------------------------\n------------------------------\nArgs:\n            coordinate: The coordinate to retrieve the value from.\n\n        Returns:\n            The value of the cell at the coordinate.\n\n        Raises:\n            CellDoesNotExist: If there is no cell with the given coordinate.\n        \"\"\"\n        row_key, column_key = self.coordinate_to_cell_key(coordinate)\n        return self.get_cell(row_key, column_key)\n------------------------------\n------------------------------\ndef get_column_at(self, column_index: int) -> Iterable[CellType]:\n        \"\"\"Get the values from the column at a given index.\n\n        Args:\n            column_index: The index of the column.\n\n        Returns:\n            A generator which yields the cells in the column.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def index_to_cell_position(self, index: int) -> int:\n# Natural Language Annotations: \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\n    cell_position = 0\n    for segment in self.segments:\n        if index >= len(segment):\n            cell_position += len(segment)\n            index -= len(segment)\n        else:\n            cell_position += index\n            break\n    return cell_position\n```", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\n    position = 0\n    for segment in self.segments:\n        if index >= segment.length():\n            position += segment.cell_length()\n            index -= segment.length()\n        else:\n            position += index * segment.cell_length() / segment.length()\n            break\n    return position\n```", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    cell_position = 0\n    for segment in self.segments:\n        if index >= segment.start and index < segment.end:\n            cell_position += segment.cell_length\n        elif index < segment.start:\n            break\n    return cell_position\n```"]}, "textual-src/textual/strip.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n------------------------------\n------------------------------\nif y != last_y:\n                yield new_line\n\n    def render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Raw data with escape sequences.\n        \"\"\"\n\n        sequences: list[str] = []\n        append = sequences.append\n------------------------------\n------------------------------\nclass CompositorUpdate:\n    \"\"\"An update generated by the compositor, which also doubles as console renderables.\"\"\"\n\n    def render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Raw data with escape sequences.\n        \"\"\"\n        return \"\"\n------------------------------\n------------------------------\nclass StripRenderable:\n    \"\"\"A renderable which renders a list of strips in to lines.\"\"\"\n\n    def __init__(self, strips: list[Strip], width: int | None = None) -> None:\n        self._strips = strips\n        self._width = width\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RenderResult:\n        new_line = Segment.line()\n        for strip in self._strips:\n            yield from strip\n            yield new_line\n------------------------------\n------------------------------\nReturns:\n            Raw data with escape sequences.\n        \"\"\"\n        sequences: list[str] = []\n        append = sequences.append\n        for last, strip in loop_last(self.strips):\n            append(strip.render(console))\n            if not last:\n                append(\"\\n\")\n        if self.clear:\n            append(\"\\n\\x1b[J\")  # Clear down\n        if len(self.strips) > 1:\n            back_lines = len(self.strips) if self.clear else len(self.strips) - 1\n------------------------------\n------------------------------\nelse:\n                            segments = console.render(renderable)\n                            terminal_sequence = console._render_buffer(segments)\n                    except Exception as error:\n                        self._handle_exception(error)\n                    else:\n                        if WINDOWS:\n                            # Combat a problem with Python on Windows.\n                            #\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self, console: Console) -> str:\n# Natural Language Annotations: \"\"\"Render the strip into terminal sequences.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Rendered sequences.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    sequences: list[str] = []\n    append = sequences.append\n    for last, strip in loop_last(self.strips):\n        append(strip.render(console))\n        if not last:\n            append(\"\\n\")\n    if self.clear:\n        append(\"\\n\\x1b[J\")  # Clear down\n    if len(self.strips) > 1:\n        back_lines = len(self.strips) if self.clear else len(self.strips) - 1\n    return \"\".join(sequences)\n```", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    sequences: list[str] = []\n    append = sequences.append\n    for last, strip in loop_last(self.strips):\n        append(strip.render(console))\n        if not last:\n            append(\"\\n\")\n    if self.clear:\n        append(\"\\n\\x1b[J\")  # Clear down\n    if len(self.strips) > 1:\n        back_lines = len(self.strips) if self.clear else len(self.strips) - 1\n    return \"\".join(sequences)\n```", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    sequences: list[str] = []\n    append = sequences.append\n    for last, strip in loop_last(self.strips):\n        append(strip.render(console))\n        if not last:\n            append(\"\\n\")\n    if self.clear:\n        append(\"\\n\\x1b[J\")  # Clear down\n    if len(self.strips) > 1:\n        back_lines = len(self.strips) if self.clear else len(self.strips) - 1\n    return \"\".join(sequences)\n```"]}, "textual-src/textual/app.py-batch_update": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@on(Driver.SignalResume)\n    def _resume_signal(self) -> None:\n        \"\"\"Signal that the application is being resumed from a suspension.\"\"\"\n        self.app_resume_signal.publish(self)\n\n    @contextmanager\n    def suspend(self) -> Iterator[None]:\n        \"\"\"A context manager that temporarily suspends the app.\n------------------------------\n------------------------------\n@contextmanager\n    def batch_update(self) -> Generator[None, None, None]:\n        \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n        self._begin_batch()\n        try:\n            yield\n        finally:\n            self._end_batch()\n\n    def _begin_batch(self) -> None:\n        \"\"\"Begin a batch update.\"\"\"\n        self._batch_count += 1\n------------------------------\n------------------------------\n@asynccontextmanager\n    async def batch(self) -> AsyncGenerator[None, None]:\n        \"\"\"Async context manager that combines widget locking and update batching.\n\n        Use this async context manager whenever you want to acquire the widget lock and\n        batch app updates at the same time.\n------------------------------\n------------------------------\nFor drivers that support the application being suspended by the\n        operating system, this context manager is used to mark a body of\n        code as one that will manage its own stop and start.\n        \"\"\"\n        auto_restart = self._auto_restart\n        self._auto_restart = False\n        try:\n            yield\n        finally:\n            self._auto_restart = auto_restart\n\n    def close(self) -> None:\n        \"\"\"Perform any final cleanup.\"\"\"\n------------------------------\n------------------------------\ndef __enter__(self) -> Self:\n        \"\"\"Use as context manager when composing.\"\"\"\n        self.app._compose_stacks[-1].append(self)\n        return self\n------------------------------\n------------------------------\n# Refresh according to descriptor flags\n            if self._layout or self._repaint or self._recompose:\n                obj.refresh(\n                    repaint=self._repaint,\n                    layout=self._layout,\n                    recompose=self._recompose,\n                )\n\n    @classmethod\n    def _check_watchers(cls, obj: Reactable, name: str, old_value: Any) -> None:\n        \"\"\"Check watchers, and call watch methods / computes\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def batch_update(self) -> Generator[None, None, None]:\n# Natural Language Annotations: \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n```", "```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n\ndef _begin_batch(self) -> None:\n    \"\"\"Begin a batch update.\"\"\"\n    self._batch_count += 1\n```", "```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n\ndef _begin_batch(self) -> None:\n    \"\"\"Begin a batch update.\"\"\"\n    self._batch_count += 1\n```"]}, "textual-src/textual/app.py-call_from_thread": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nThis method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n------------------------------\n------------------------------\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n------------------------------\n------------------------------\nRaises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\n\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n------------------------------\n------------------------------\nif self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            \"\"\"Run the callback, set the result or error on the future.\"\"\"\n            self._set_active()\n            return await invoke(callback_with_args)\n------------------------------\n------------------------------\nArgs:\n            requester: The object requesting the callback.\n            callback: The callback.\n            future: A Future to hold the result.\n        \"\"\"\n        self._result_callbacks.append(\n            ResultCallback[ScreenResultType](requester, callback, future)\n        )\n\n    def _pop_result_callback(self) -> None:\n        \"\"\"Remove the latest result callback from the stack.\"\"\"\n        self._result_callbacks.pop()\n------------------------------\n------------------------------\nArgs:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n------------------------------\n------------------------------\nArgs:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_from_thread(\n# Natural Language Annotations: \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        \"\"\"\n        Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\n\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n\n        if self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            \"\"\"Run the callback, set the result or error on the future.\"\"\"\n            self._set_active()\n            return await invoke(callback_with_args)\n```", "```python\ndef call_from_thread(\n        self,\n        callback: Callable[..., CallThreadReturnType | Awaitable[CallThreadReturnType]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> CallThreadReturnType:\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n\n        if self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> CallThreadReturnType:\n            self._set_active()\n            return await invoke(callback_with_args)\n```", "```python\nimport threading\nfrom typing import Any, Awaitable, Callable\n\ndef call_from_thread(\n        self,\n        callback: Callable[..., Any | Awaitable[Any]],\n        *args: Any,\n        **kwargs: Any,\n    ) -> Any:\n        if self._loop is None:\n            raise RuntimeError(\"App is not running\")\n\n        if self._thread_id == threading.get_ident():\n            raise RuntimeError(\n                \"The `call_from_thread` method must run in a different thread from the app\"\n            )\n\n        callback_with_args = partial(callback, *args, **kwargs)\n\n        async def run_callback() -> Any:\n            self._set_active()\n            return await invoke(callback_with_args)\n\n        return run_callback()\n```"]}, "textual-src/textual/app.py-run_test": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nUse this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n------------------------------\n------------------------------\n@asynccontextmanager\n    async def run_test(\n        self,\n        *,\n        headless: bool = True,\n        size: tuple[int, int] | None = (80, 24),\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncGenerator[Pilot[ReturnType], None]:\n        \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_test(\n# Natural Language Annotations: \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def run_test(\n    self,\n    *,\n    headless: bool = True,\n    size: tuple[int, int] | None = (80, 24),\n    tooltips: bool = False,\n    notifications: bool = False,\n    message_hook: Callable[[Message], None] | None = None,\n) -> AsyncGenerator[Pilot[ReturnType], None]:\n    \"\"\"An asynchronous context manager for testing apps.\n\n    !!! tip\n\n        See the guide for [testing](/guide/testing) Textual apps.\n\n    Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n    Example:\n\n        ```python\n        async with app.run_test() as pilot:\n            await pilot.click(\"#Button.ok\")\n            assert ...\n        ```\n\n    Args:\n        headless: Run in headless mode (no output or input).\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        tooltips: Enable tooltips when testing.\n        notifications: Enable notifications when testing.\n        message_hook: An optional callback that will be called each time any message arrives at any\n            message pump in the app.\n    \"\"\"\n```", "```python\nasync def run_test(\n    self,\n    *,\n    headless: bool = True,\n    size: tuple[int, int] | None = (80, 24),\n    tooltips: bool = False,\n    notifications: bool = False,\n    message_hook: Callable[[Message], None] | None = None,\n) -> AsyncGenerator[Pilot[ReturnType], None]:\n    async with self.run_test(\n        headless=headless,\n        size=size,\n        tooltips=tooltips,\n        notifications=notifications,\n        message_hook=message_hook\n    ) as pilot:\n        await pilot.click(\"#Button.ok\")\n        assert ...\n```", "```python\nasync def run_test(\n        self,\n        *,\n        headless: bool = True,\n        size: tuple[int, int] | None = (80, 24),\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncGenerator[Pilot[ReturnType], None]:\n        \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n```"]}, "textual-src/textual/app.py-run": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n------------------------------\n------------------------------\nArgs:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n        from .pilot import Pilot\n------------------------------\n------------------------------\nself._exit_renderables.clear()\n\n    def _build_driver(\n        self, headless: bool, inline: bool, mouse: bool, size: tuple[int, int] | None\n    ) -> Driver:\n        \"\"\"Construct a driver instance.\n\n        Args:\n            headless: Request headless driver.\n            inline: Request inline driver.\n            mouse: Request mouse support.\n            size: Initial size.\n------------------------------\n------------------------------\nreturn app.return_value\n\n    def run(\n        self,\n        *,\n        headless: bool = False,\n        inline: bool = False,\n        inline_no_clear: bool = False,\n        mouse: bool = True,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> ReturnType | None:\n        \"\"\"Run the app.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def run(\n# Natural Language Annotations: \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef run(\n    self,\n    *,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n```", "```python\ndef run(\n    self,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    # You did not provide the implementation for this function,\n    # so I'm leaving this blank for you to fill out.\n    pass\n```", "```python\ndef run(\n        self,\n        headless: bool = False,\n        inline: bool = False,\n        inline_no_clear: bool = False,\n        mouse: bool = True,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    # Your function implementation here\n```"]}, "textual-src/textual/app.py-switch_mode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef _init_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Do internal initialization of a new screen stack mode.\n\n        Args:\n            mode: Name of the mode.\n\n        Returns:\n            An optionally awaitable object which can be awaited until the screen\n            associated with the mode has been mounted.\n        \"\"\"\n------------------------------\n------------------------------\ndef switch_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\n        if mode not in self.MODES:\n            raise UnknownModeError(f\"No known mode {mode!r}\")\n------------------------------\n------------------------------\nRaises:\n            ActiveModeError: If trying to remove the active mode.\n            UnknownModeError: If trying to remove an unknown mode.\n        \"\"\"\n        if mode == self._current_mode:\n            raise ActiveModeError(f\"Can't remove active mode {mode!r}\")\n        elif mode not in self.MODES:\n            raise UnknownModeError(f\"Unknown mode {mode!r}\")\n        else:\n            del self.MODES[mode]\n------------------------------\n------------------------------\nself.log.system(f\"{self._current_mode!r} is the current mode\")\n        self.log.system(f\"{self.screen} is active\")\n\n        return await_mount\n\n    def add_mode(\n        self, mode: str, base_screen: str | Screen | Callable[[], Screen]\n    ) -> None:\n        \"\"\"Adds a mode and its corresponding base screen to the app.\n\n        Args:\n            mode: The new mode.\n            base_screen: The base screen associated with the given mode.\n------------------------------\n------------------------------\nReturns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        if self.app._exit:\n            return AwaitMount(self, [])\n        await_mount = self.mount(*widgets, before=before, after=after)\n        return await_mount\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_mode(self, mode: str) -> AwaitMount:\n# Natural Language Annotations: \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"No known mode {mode}\")\n\n    self._current_mode = mode\n    base_screen = self.MODES[mode]\n\n    self.log.system(f\"{self._current_mode} is the current mode\")\n    self.log.system(f\"{self.screen} is active\")\n\n    return self._init_mode(mode)\n```", "```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"No known mode {mode}\")\n    else:\n        # Code to switch to the mode\n        # This is a placeholder and will depend on the specific implementation\n        pass\n    return AwaitMount(self, [])\n```", "```\ndef switch_mode(self, mode: str) -> AwaitMount:\n    \"\"\"Switch to a given mode.\n\n    Args:\n        mode: The mode to switch to.\n\n    Returns:\n        An optionally awaitable object which waits for the screen associated\n            with the mode to be mounted.\n\n    Raises:\n        UnknownModeError: If trying to switch to an unknown mode.\n    \"\"\"\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"No known mode {mode}\")\n    \n    # Perform the mode switch logic here\n    # ...\n\n    return AwaitMount(self, [])\n```"]}, "textual-src/textual/app.py-push_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n------------------------------\n------------------------------\nNote that this method may only be called when running in a worker.\n\n        Args:\n            screen: A screen or the name of an installed screen.\n\n        Returns:\n            The screen's result.\n        \"\"\"\n        await self._flush_next_callbacks()\n        return await self.push_screen(screen, wait_for_dismiss=True)\n------------------------------\n------------------------------\nRaises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"push_screen requires a Screen instance or str; not {screen!r}\"\n            )\n------------------------------\n------------------------------\nasync def push_screen_wait(\n        self, screen: Screen[ScreenResultType] | str\n    ) -> ScreenResultType | Any:\n        \"\"\"Push a screen and wait for the result (received from [`Screen.dismiss`][textual.screen.Screen.dismiss]).\n\n        Note that this method may only be called when running in a worker.\n\n        Args:\n            screen: A screen or the name of an installed screen.\n------------------------------\n------------------------------\nthis method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n------------------------------\n------------------------------\nIf `result` is provided and a callback was set when the screen was [pushed][textual.app.App.push_screen], then\n        the callback will be invoked with `result`.\n\n        Args:\n            result: The optional result to be passed to the result callback.\n\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def push_screen(\n# Natural Language Annotations: \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n        Args:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n                this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n        Raises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef push_screen(\n        self, \n        screen: Screen | str, \n        callback: Callable = None, \n        wait_for_dismiss: bool = False\n    ) -> Union[Awaitable, Future]:\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(\n            f\"push_screen requires a Screen instance or str; not {screen}\"\n        )\n    if wait_for_dismiss and not self._is_worker:\n        raise NoActiveWorker(\"Cannot use wait_for_dismiss outside of a worker\")\n    await self._flush_next_callbacks()\n    return await self.push_screen(screen, wait_for_dismiss=wait_for_dismiss)\n```", "```python\ndef push_screen(\n    self, \n    screen: Screen | str, \n    callback: Callable[[ScreenResultType], None] = None, \n    wait_for_dismiss: bool = False\n) -> ScreenResultType | Any:\n    \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(\n            f\"push_screen requires a Screen instance or str; not {screen}\"\n        )\n    if wait_for_dismiss:\n        raise NoActiveWorker(\"wait_for_dismiss should only be set to True when running in a worker.\")\n    \n    self._callback = callback\n    self._wait_for_dismiss = wait_for_dismiss\n    self._screen = screen\n\n    return self._screen\n```", "```python\nasync def push_screen(\n        self, \n        screen: Screen | str, \n        callback: Optional[Callable[[ScreenResultType], Awaitable[None]]] = None, \n        wait_for_dismiss: bool = False\n) -> ScreenResultType | Any:\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(f\"push_screen requires a Screen instance or str; not {screen}\")\n\n    if wait_for_dismiss:\n        await self._flush_next_callbacks()\n        return await self.push_screen(screen, wait_for_dismiss=True)\n\n    return await self.push_screen(screen, wait_for_dismiss=True)\n```"]}, "textual-src/textual/app.py-switch_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_screen(self, screen: Screen | str) -> Screen:\n        \"\"\"Get an installed screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Raises:\n            KeyError: If the named screen doesn't exist.\n------------------------------\n------------------------------\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n        \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"switch_screen requires a Screen instance or str; not {screen!r}\"\n            )\n------------------------------\n------------------------------\ndef is_screen_installed(self, screen: Screen | str) -> bool:\n        \"\"\"Check if a given screen has been installed.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Returns:\n            True if the screen is currently installed,\n        \"\"\"\n        if isinstance(screen, str):\n            return screen in self._installed_screens\n        else:\n            return screen in self._installed_screens.values()\n------------------------------\n------------------------------\nawait await_mount()\n            await self._replace_screen(top_screen)\n\n        return AwaitComplete(do_switch()).call_next(self)\n\n    def install_screen(self, screen: Screen, name: str) -> None:\n        \"\"\"Install a screen.\n------------------------------\n------------------------------\nasync def _replace_screen(self, screen: Screen) -> Screen:\n        \"\"\"Handle the replaced screen.\n\n        Args:\n            screen: A screen object.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(f\"switch_screen requires a Screen instance or str; not {screen}\")\n\n    if isinstance(screen, str):\n        screen = self.get_screen(screen)\n\n    if not self.is_screen_installed(screen):\n        raise KeyError(f\"Screen {screen.name} is not installed\")\n\n    self._screen_stack.pop()\n    self._screen_stack.append(screen)\n\n    return AwaitComplete(do_switch()).call_next(self)\n```", "```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(\n            f\"switch_screen requires a Screen instance or str; not {screen}\")\n\n    # Logic to switch screen goes here\n    # ...\n\n    return AwaitComplete(do_switch()).call_next(self)\n```", "```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n\n    Raises:\n        TypeError: If screen is not an instance of Screen or str.\n    \"\"\"\n    if not isinstance(screen, (Screen, str)):\n        raise TypeError(f\"switch_screen requires a Screen instance or str; not {screen}\")\n\n    # Your logic to switch screens goes here\n\n    return AwaitComplete(do_switch()).call_next(self)\n```"]}, "textual-src/textual/app.py-pop_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nReturns:\n            The screen that was replaced.\n        \"\"\"\n        if self._screen_stack:\n            self.screen.refresh()\n        screen.post_message(events.ScreenSuspend())\n        self.log.system(f\"{screen} SUSPENDED\")\n        if not self.is_screen_installed(screen) and all(\n            screen not in stack for stack in self._screen_stacks.values()\n        ):\n            await screen.remove()\n            self.log.system(f\"{screen} REMOVED\")\n        return screen\n------------------------------\n------------------------------\ndef pop_screen(self) -> AwaitComplete:\n        \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\n\n        screen_stack = self._screen_stack\n        if len(screen_stack) <= 1:\n            raise ScreenStackError(\n                \"Can't pop screen; there must be at least one screen on the stack\"\n            )\n------------------------------\n------------------------------\nReturns:\n            A snapshot of the current state of the screen stack.\n        \"\"\"\n        return self._screen_stacks[self._current_mode].copy()\n\n    @property\n    def _screen_stack(self) -> list[Screen[Any]]:\n        \"\"\"A reference to the current screen stack.\n\n        Note:\n            Consider using [`screen_stack`][textual.app.App.screen_stack] instead.\n------------------------------\n------------------------------\ndef push_screen(\n        self,\n        screen: Screen[ScreenResultType] | str,\n        callback: ScreenResultCallbackType[ScreenResultType] | None = None,\n        wait_for_dismiss: bool = False,\n    ) -> AwaitMount | asyncio.Future[ScreenResultType]:\n        \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n------------------------------\n------------------------------\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n        \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if not isinstance(screen, (Screen, str)):\n            raise TypeError(\n                f\"switch_screen requires a Screen instance or str; not {screen!r}\"\n            )\n------------------------------\n------------------------------\n- Clicking to move the cursor elsewhere in the document should create a new batch.\n            - Movement of the cursor via a keyboard action that is NOT an edit.\n            - Blurring the TextArea creates a new checkpoint.\n        - The current edit involves a deletion/replacement and the previous edit did not.\n        - The current edit is a pure insertion and the previous edit was not.\n        - The edit involves insertion or deletion of one or more newline characters.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def pop_screen(self) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    screen_stack = self._screen_stack\n    if len(screen_stack) <= 1:\n        raise ScreenStackError(\n            \"Can't pop screen; there must be at least one screen on the stack\"\n        )\n    screen = screen_stack.pop()\n    screen.refresh()\n    screen.post_message(events.ScreenSuspend())\n    self._current_mode = self._mode_stack[-1] if self._mode_stack else None\n    self.log.system(f\"{screen} SUSPENDED\")\n    if not self.is_screen_installed(screen) and all(\n        screen not in stack for stack in self._screen_stacks.values()\n    ):\n        await screen.remove()\n        self.log.system(f\"{screen} REMOVED\")\n    return screen\n```", "```python\ndef pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    screen_stack = self._screen_stack\n    if len(screen_stack) <= 1:\n        raise ScreenStackError(\n            \"Can't pop screen; there must be at least one screen on the stack\"\n        )\n    screen = screen_stack.pop()\n    if screen_stack:\n        screen_stack[-1].refresh()\n    return screen\n```", "```python\ndef pop_screen(self) -> AwaitComplete:\n        \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\n        screen_stack = self._screen_stack\n        if len(screen_stack) <= 1:\n            raise ScreenStackError(\n                \"Can't pop screen; there must be at least one screen on the stack\"\n            )\n        screen = screen_stack.pop()\n        self.screen = screen_stack[-1]\n        return screen\n```"]}, "textual-src/textual/app.py-run_action": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            keys: A comma separated list of keys, i.e.\n            action: Action to bind to.\n            description: Short description of action.\n            show: Show key in UI.\n            key_display: Replacement text for key, or None to use default.\n        \"\"\"\n        self._bindings.bind(\n            keys, action, description, show=show, key_display=key_display\n        )\n------------------------------\n------------------------------\nasync def run_action(\n        self,\n        action: str | ActionParseResult,\n        default_namespace: DOMNode | None = None,\n    ) -> bool:\n        \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n------------------------------\n------------------------------\nReturns:\n            A renderable.\n        \"\"\"\n        renderable = self.render()\n        if isinstance(renderable, str):\n            return Text.from_markup(renderable)\n        return renderable\n\n    async def run_action(self, action: str) -> None:\n        \"\"\"Perform a given action, with this widget as the default namespace.\n\n        Args:\n            action: Action encoded as a string.\n        \"\"\"\n        await self.app.run_action(action, self)\n------------------------------\n------------------------------\nArgs:\n            keys: The keys to bind. Can be a comma-separated list of keys.\n            action: The action to bind the keys to.\n            description: An optional description for the binding.\n            show: A flag to say if the binding should appear in the footer.\n            key_display: Optional string to display in the footer for the key.\n            priority: Is this a priority binding, checked form app down to focused widget?\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            True if the event has been handled.\n        \"\"\"\n        action_target, action_name, params = self._parse_action(\n            action, self if default_namespace is None else default_namespace\n        )\n\n        if action_target.check_action(action_name, params):\n            return await self._dispatch_action(action_target, action_name, params)\n        else:\n            return False\n------------------------------\n------------------------------\nif isinstance(action, str):\n            await self.run_action(action, default_namespace)\n        elif isinstance(action, tuple) and len(action) == 2:\n            action_name, action_params = action\n            namespace, parsed_action, _ = actions.parse(action_name)\n            await self.run_action(\n                (namespace, parsed_action, action_params),\n                default_namespace,\n            )\n        elif callable(action):\n            await action()\n        else:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_action(\n# Natural Language Annotations: \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def run_action(self, action: str, default_namespace: DOMNode | None = None) -> bool:\n    action_target, action_name, params = self._parse_action(\n        action, self if default_namespace is None else default_namespace\n    )\n\n    if action_target.check_action(action_name, params):\n        return await self._dispatch_action(action_target, action_name, params)\n    else:\n        return False\n```", "```python\nasync def run_action(action: str, default_namespace: DOMNode | None = None) -> bool:\n    \"\"\"Perform an [action](/guide/actions).\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    action_target, action_name, params = self._parse_action(\n        action, self if default_namespace is None else default_namespace\n    )\n\n    if action_target.check_action(action_name, params):\n        return await self._dispatch_action(action_target, action_name, params)\n    else:\n        return False\n```", "```python\nasync def run_action(action: str, default_namespace: DOMNode | None = None) -> bool:\n    \"\"\"Perform an [action](/guide/actions).\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    action_target, action_name, params = self._parse_action(\n        action, self if default_namespace is None else default_namespace\n    )\n\n    if action_target.check_action(action_name, params):\n        return await self._dispatch_action(action_target, action_name, params)\n    else:\n        return False\n```"]}, "textual-src/textual/file_monitor.py-check": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef check(self) -> bool:\n        \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n        modified = self._get_last_modified_time()\n        changed = modified != self._modified\n        self._modified = modified\n        return changed\n\n    def add_paths(self, paths: Iterable[Path]) -> None:\n        \"\"\"Adds paths to start being monitored.\n------------------------------\n------------------------------\ndef _get_last_modified_time(self) -> float:\n        \"\"\"Get the most recent modified time out of all files being watched.\"\"\"\n        modified_times = []\n        for path in self._paths:\n            try:\n                modified_time = os.stat(path).st_mtime\n            except FileNotFoundError:\n                modified_time = 0\n            modified_times.append(modified_time)\n        return max(modified_times, default=0)\n------------------------------\n------------------------------\nArgs:\n        x: The relative x coordinate.\n        y: The relative y coordinate.\n        delta_x: Change in x since the last message.\n        delta_y: Change in y since the last message.\n        button: Indexed of the pressed button.\n        shift: True if the shift key is pressed.\n        meta: True if the meta key is pressed.\n        ctrl: True if the ctrl key is pressed.\n        screen_x: The absolute x coordinate.\n        screen_y: The absolute y coordinate.\n------------------------------\n------------------------------\ndef is_last_wrapped_line(self, location: Location) -> bool:\n        \"\"\"Check if the given location is on the last wrapped section of the last line.\n\n        That is, the cursor is *visually* on the last rendered row.\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the cursor is on the last section of the last line.\n        \"\"\"\n        if not self.is_last_document_line(location):\n            return False\n------------------------------\n------------------------------\ndef undo(self) -> None:\n        \"\"\"Undo the edits since the last checkpoint (the most recent batch of edits).\"\"\"\n        if edits := self.history._pop_undo():\n            self._undo_batch(edits)\n\n    def action_undo(self) -> None:\n        \"\"\"Undo the edits since the last checkpoint (the most recent batch of edits).\"\"\"\n        self.undo()\n------------------------------\n------------------------------\nArgs:\n            paths: The paths to be monitored.\n        \"\"\"\n        self._paths.update(paths)\n\n    async def __call__(self) -> None:\n        if self.check():\n            await self.on_change()\n\n    async def on_change(self) -> None:\n        \"\"\"Called when any of the monitored files change.\"\"\"\n        await invoke(self.callback)\n------------------------------\n------------------------------\nelse:\n                hidden, shown, resized = self._compositor.reflow(self, size)\n                Hide = events.Hide\n                Show = events.Show\n\n                for widget in hidden:\n                    widget.post_message(Hide())\n\n                # We want to send a resize event to widgets that were just added or change since last layout\n                send_resize = shown | resized\n------------------------------\n------------------------------\nclass FileMonitor:\n    \"\"\"Monitors files for changes and invokes a callback when it does.\"\"\"\n\n    _paths: set[Path]\n\n    def __init__(self, paths: Sequence[Path], callback: Callable[[], None]) -> None:\n        \"\"\"Monitor the given file paths for changes.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check(self) -> bool:\n# Natural Language Annotations: \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    modified = self._get_last_modified_time()\n    changed = modified != self._modified\n    self._modified = modified\n    return changed\n```", "```python\ndef check(self) -> bool:\n    modified = self._get_last_modified_time()\n    changed = modified != self._modified\n    self._modified = modified\n    return changed\n```", "```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    modified = self._get_last_modified_time()\n    changed = modified != self._modified\n    self._modified = modified\n    return changed\n```"]}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_tab_widths(line: str, tab_size: int = 4) -> list[tuple[str, int]]:\n    \"\"\"Splits a string line into tuples (str, int).\n\n    Each tuple represents a section of the line which precedes a tab character.\n    The string is the string text that appears before the tab character (excluding the tab).\n    The integer is the width that the tab character is expanded to.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n------------------------------\n------------------------------\nArgs:\n        line: The `Text` instance to expand tabs in.\n        tab_widths: The widths to expand tabs to.\n\n    Returns:\n        A new text instance with tab characters converted to spaces.\n    \"\"\"\n    if \"\\t\" not in line.plain:\n        return line\n\n    parts = line.split(\"\\t\", include_separator=True)\n    tab_widths_iter = iter(tab_widths)\n------------------------------\n------------------------------\ndef expand_text_tabs_from_widths(line: Text, tab_widths: list[int]) -> Text:\n    \"\"\"Expand tabs to the widths defined in the `tab_widths` list.\n\n    This will return a new Text instance with tab characters expanded into a\n    number of spaces. Each time a tab is encountered, it's expanded into the\n    next integer encountered in the `tab_widths` list. Consequently, the length\n    of `tab_widths` should match the number of tab characters in `line`.\n------------------------------\n------------------------------\ndef cell_width_to_column_index(line: str, cell_width: int, tab_width: int) -> int:\n    \"\"\"Retrieve the column index corresponding to the given cell width.\n\n    Args:\n        line: The line of text to search within.\n        cell_width: The cell width to convert to column index.\n        tab_width: The tab stop width to expand tabs contained within the line.\n------------------------------\n------------------------------\nfolded_word = [\"\".join(line) for line in lines]\n                    for last, line in loop_last(folded_word):\n                        if start:\n                            append(start)\n                        if last:\n                            # Since cell_len ignores tabs, we need to check the width\n                            # of the tabs in this line. The width of tabs within the\n                            # line is computed by taking the difference between the\n------------------------------\n------------------------------\nArgs:\n        text: The text to examine.\n        width: The available cell width.\n        tab_size: The tab stop width.\n        fold: If True, words longer than `width` will be folded onto a new line.\n        precomputed_tab_sections: The output of `get_tab_widths` can be passed here directly,\n            to prevent us from having to recompute the value.\n------------------------------\n------------------------------\nReturns:\n        A list of tuples representing the line split on tab characters,\n            and the widths of the tabs after tab expansion is applied.\n    \"\"\"\n\n    parts: list[tuple[str, int]] = []\n    add_part = parts.append\n    cell_position = 0\n    matches = _TABS_SPLITTER_RE.findall(line)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n# Natural Language Annotations: \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    return line.replace('\\t', ' ' * tab_size)\n```", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    result = \"\"\n    i = 0\n    while i < len(line):\n        if line[i] == \"\\t\":\n            if i + 1 < len(line) and line[i + 1] == \"\\t\":\n                result += \" \" * tab_size * 2\n                i += 1\n            else:\n                result += \" \" * tab_size\n        else:\n            result += line[i]\n        i += 1\n    return result\n```", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    return line.expandtabs(tab_size)\n```"]}, "textual-src/textual/_resolve.py-resolve": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n        dimensions: A list of Scalars or Nones for each dimension.\n        widgets: Widgets in resolve.\n        size: Size of container.\n        viewport_size: Viewport size.\n        margin: Total space occupied by margin\n        resolve_dimension: Which dimension to resolve.\n\n    Returns:\n        List of resolved box models.\n    \"\"\"\n    margin_width, margin_height = margin\n------------------------------\n------------------------------\n@lru_cache(maxsize=4096)\n    def resolve(\n        self, size: Size, viewport: Size, fraction_unit: Fraction | None = None\n    ) -> Fraction:\n        \"\"\"Resolve scalar with units in to a dimensions.\n\n        Args:\n            size: Size of the container.\n            viewport: Size of the viewport (typically terminal size)\n\n        Raises:\n            ScalarResolveError: If the unit is unknown.\n------------------------------\n------------------------------\ndef _arrange_dock_widgets(\n    dock_widgets: Sequence[Widget], size: Size, viewport: Size\n) -> tuple[list[WidgetPlacement], Spacing]:\n    \"\"\"Arrange widgets which are *docked*.\n\n    Args:\n        dock_widgets: Widgets with a non-empty dock.\n        size: Size of the container.\n        viewport: Size of the viewport.\n------------------------------\n------------------------------\ndef resolve(self, size: Size, viewport: Size) -> Offset:\n        \"\"\"Resolve the offset in to cells.\n\n        Args:\n            size: Size of container.\n            viewport: Size of viewport.\n\n        Returns:\n            Offset in cells.\n        \"\"\"\n        x, y = self\n        return Offset(\n            round(x.resolve(size, viewport)),\n            round(y.resolve(size, viewport)),\n        )\n------------------------------\n------------------------------\ncolumns = resolve(column_scalars, size.width, gutter_vertical, size, viewport)\n------------------------------\n------------------------------\ndef resolve_box_models(\n    dimensions: list[Scalar | None],\n    widgets: list[Widget],\n    size: Size,\n    viewport_size: Size,\n    margin: Size,\n    resolve_dimension: Literal[\"width\", \"height\"] = \"width\",\n) -> list[BoxModel]:\n    \"\"\"Resolve box models for a list of dimensions\n------------------------------\n------------------------------\ndef layout_resolve(total: int, edges: Sequence[EdgeProtocol]) -> list[int]:\n    \"\"\"Divide total space to satisfy size, fraction, and min_size, constraints.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def resolve(\n# Natural Language Annotations: \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef resolve(dimensions: list[Scalar], total: int, gutter: int, size: Size, viewport: Size) -> list[tuple[int, int]]:\n    \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    resolved_dimensions = []\n    offset = 0\n    for dimension in dimensions:\n        length = dimension.resolve(size, viewport)\n        resolved_dimensions.append((offset, length))\n        offset += length + gutter\n    return resolved_dimensions\n```", "```python\ndef resolve(dimensions: list[Scalar | None], total: int, gutter: Scalar, size: Size, viewport: Size) -> list[tuple[int, int]]:\n    resolved_dimensions = []\n    offset = 0\n    for dimension in dimensions:\n        if dimension is None:\n            continue\n        resolved_dimension = dimension.resolve(size, viewport)\n        length = min(total - offset, resolved_dimension)\n        resolved_dimensions.append((offset, length))\n        offset += length + gutter.resolve(size, viewport)\n    return resolved_dimensions\n```", "```python\ndef resolve(\n        dimensions: list[Scalar | None],\n        total: int,\n        gutter: int,\n        size: Size,\n        viewport: Size\n) -> list[tuple[int, int]]:\n    resolved_dimensions = []\n    for dimension in dimensions:\n        if dimension is None:\n            resolved_dimensions.append((0, 0))\n        else:\n            resolved_dimension = dimension.resolve(size, viewport)\n            resolved_dimensions.append((resolved_dimension, gutter))\n    return resolved_dimensions\n```"]}, "textual-src/textual/widget.py-mount": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def mount(\n# Natural Language Annotations: \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef mount(self, *widgets, before=None, after=None):\n    if before is not None and after is not None:\n        raise MountError(\"Only one of before or after can be provided.\")\n\n    # Add your code here to mount the widgets\n```", "```python\ndef mount(self, *widgets, before=None, after=None):\n    # your code here\n```", "```python\ndef mount(self, *widgets, before=None, after=None):\n    if before is not None and after is not None:\n        raise MountError(\"Only one of `before` or `after` can be provided.\")\n\n    # Your implementation here\n\n    return awaitable_object\n```"]}, "textual-src/textual/widget.py-move_child": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\nArgs:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n------------------------------\n------------------------------\ndef _register_child(\n        self, parent: DOMNode, child: Widget, before: int | None, after: int | None\n    ) -> None:\n        \"\"\"Register a widget as a child of another.\n\n        Args:\n            parent: Parent node.\n            child: The child widget to register.\n            widgets: The widget to register.\n            before: A location to mount before.\n            after: A location to mount after.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            An optionally awaitable object that waits for the tab to be mounted and\n                internal state to be fully updated to reflect the new tab.\n\n        Raises:\n            Tabs.TabError: If there is a problem with the addition request.\n\n        Note:\n            Only one of `before` or `after` can be provided. If both are\n            provided a `Tabs.TabError` will be raised.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        return self.mount(*widgets, before=before, after=after)\n------------------------------\n------------------------------\nReturns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        return self.screen.mount(*widgets, before=before, after=after)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def move_child(\n# Natural Language Annotations: \"\"\"Move a child widget within its parent's list of children.\n\n        Args:\n            child: The child widget to move.\n            before: Child widget or location index to move before.\n            after: Child widget or location index to move after.\n\n        Raises:\n            WidgetError: If there is a problem with the child or target.\n\n        Note:\n            Only one of `before` or `after` can be provided. If neither\n            or both are provided a `WidgetError` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef move_child(self, child: Widget, before: int | None, after: int | None) -> None:\n    if (before is not None and after is not None) or (before is None and after is None):\n        raise WidgetError(\"Either before or after should be provided, but not both.\")\n\n    # Fetch current parent and children\n    parent = child.parent\n    children = parent.children\n\n    # Find the current index of the child\n    current_index = children.index(child)\n\n    # Remove the child from its current position\n    children.pop(current_index)\n\n    # Insert the child at the new position\n    if before is not None:\n        if isinstance(before, int):\n            # Insert before a certain index\n            children.insert(before, child)\n        else:\n            # Find the widget before which to insert the child and insert the child before it\n            insertion_index = children.index(before)\n            children.insert(insertion_index, child)\n    else:\n        if isinstance(after, int):\n            # Insert after a certain index\n            children.insert(after + 1, child)\n        else:\n            # Find the widget after which to insert the child and insert the child after it\n            insertion_index = children.index(after)\n            children.insert(insertion_index + 1, child)\n```", "```python\ndef move_child(self, child: Widget, before: int | Widget | None = None, after: int | Widget | None = None):\n    # Check for invalid inputs\n    if (before is not None and after is not None) or (before is None and after is None):\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n\n    # Convert before and after to indices if they are widgets\n    if isinstance(before, Widget):\n        before = self._children.index(before)\n    if isinstance(after, Widget):\n        after = self._children.index(after)\n\n    # Remove the child from its current location\n    self._children.remove(child)\n\n    # Insert the child at the new location\n    if before is not None:\n        self._children.insert(before, child)\n    elif after is not None:\n        self._children.insert(after + 1, child)\n```", "```python\ndef move_child(self, child: Widget, before: int | str | None = None, after: int | str | None = None):\n    if (before is not None and after is not None) or (before is None and after is None):\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n    \n    # Your code to move the child widget goes here\n```"]}, "textual-src/textual/widget.py-_get_box_model": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n------------------------------\n------------------------------\ndef arrange(\n    widget: Widget, children: Sequence[Widget], size: Size, viewport: Size\n) -> DockArrangeResult:\n    \"\"\"Arrange widgets by applying docks and calling layouts\n\n    Args:\n        widget: The parent (container) widget.\n        size: The size of the available area.\n        viewport: The size of the viewport (terminal).\n\n    Returns:\n        Widget arrangement information.\n    \"\"\"\n------------------------------\n------------------------------\nReturns:\n            An iterable of widget location\n        \"\"\"\n\n    def get_content_width(self, widget: Widget, container: Size, viewport: Size) -> int:\n        \"\"\"Get the optimal content width by arranging children.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport size.\n------------------------------\n------------------------------\nresolve_dimension,\n        )\n        width_fraction = fraction_unit\n        height_fraction = Fraction(margin_size.height)\n    else:\n        total_remaining = int(\n            sum(\n                [\n                    box_model.height\n                    for widget, box_model in zip(widgets, box_models)\n                    if (box_model is not None and widget.styles.overlay != \"screen\")\n                ]\n            )\n        )\n------------------------------\n------------------------------\ndef _resolve_fraction(\n    value: float, size: Size, viewport: Size, fraction_unit: Fraction\n) -> Fraction:\n    \"\"\"Resolves a fraction unit i.e. width: 2fr\n\n    Args:\n        value: Scalar value.\n        size: Size of widget.\n        viewport: Size of viewport.\n        fraction_unit: Size of fraction, i.e. size of 1fr as a Fraction.\n\n    Returns:\n        Resolved unit.\n    \"\"\"\n    return fraction_unit * Fraction(value)\n------------------------------\n------------------------------\nmargin_size = size - margin\n\n    # Fixed box models\n    box_models: list[BoxModel | None] = [\n        (\n            None\n            if _dimension is not None and _dimension.is_fraction\n            else widget._get_box_model(\n                size, viewport_size, fraction_width, fraction_height\n            )\n        )\n        for (_dimension, widget) in zip(dimensions, widgets)\n    ]\n------------------------------\n------------------------------\ndef resolve_fraction_unit(\n    widget_styles: Iterable[RenderStyles],\n    size: Size,\n    viewport_size: Size,\n    remaining_space: Fraction,\n    resolve_dimension: Literal[\"width\", \"height\"] = \"width\",\n) -> Fraction:\n    \"\"\"Calculate the fraction.\n\n    Args:\n        widget_styles: Styles for widgets with fraction units.\n        size: Container size.\n        viewport_size: Viewport size.\n        remaining_space: Remaining space for fr units.\n        resolve_dimension: Which dimension to resolve.\n------------------------------\n------------------------------\nbox_model = dock_widget._get_box_model(\n            size, viewport, Fraction(size.width), Fraction(size.height)\n        )\n        widget_width_fraction, widget_height_fraction, margin = box_model\n\n        widget_width = int(widget_width_fraction) + margin.width\n        widget_height = int(widget_height_fraction) + margin.height\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_box_model(\n# Natural Language Annotations: \"\"\"Process the box model for this widget.\n\n        Args:\n            container: The size of the container widget (with a layout)\n            viewport: The viewport size.\n            width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n            height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n        Returns:\n            The size and margin for this widget.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_box_model(\n    self,\n    container: Size,\n    viewport: Size,\n    width_fraction: Fraction,\n    height_fraction: Fraction,\n) -> tuple[Fraction, Fraction, Size]:\n    margin_size = container - self.margin\n\n    # Fixed box models\n    box_model = (\n        None\n        if self._dimension is not None and self._dimension.is_fraction\n        else self._get_box_model(\n            container, viewport, width_fraction, height_fraction\n        )\n    )\n\n    widget_width_fraction, widget_height_fraction, margin = box_model\n\n    widget_width = int(widget_width_fraction) + margin.width\n    widget_height = int(widget_height_fraction) + margin.height\n\n    return widget_width, widget_height, margin\n```", "```python\ndef _get_box_model(\n    container: Size, \n    viewport: Size, \n    width_fraction: Fraction, \n    height_fraction: Fraction\n) -> Tuple[Fraction, Fraction, Margin]:\n    \"\"\"Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n\n    # Implementation\n    pass\n```", "```python\ndef _get_box_model(\n    self,\n    container: Size,\n    viewport: Size,\n    width_fraction: Fraction,\n    height_fraction: Fraction\n) -> tuple[Fraction, Fraction, Size]:\n    margin_size = container - self._get_margin()\n    \n    box_model = self.styles.get_box_model(\n        width_fraction, \n        height_fraction, \n        viewport, \n        margin_size, \n        self._dimension\n    )\n\n    return (\n        box_model.width, \n        box_model.height, \n        Size(box_model.margin_left, box_model.margin_top)\n    )\n```"]}, "textual-src/textual/widget.py-get_content_width": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef on_mount(self):\n        self._refresh_scrollbars()\n\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Gets the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return self.virtual_size.width\n------------------------------\n------------------------------\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Called by textual to get the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return DigitsRenderable.get_width(self._value)\n------------------------------\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n------------------------------\n------------------------------\nReturns:\n            An iterable of widget location\n        \"\"\"\n\n    def get_content_width(self, widget: Widget, container: Size, viewport: Size) -> int:\n        \"\"\"Get the optimal content width by arranging children.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport size.\n------------------------------\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Gets the height (number of lines) in the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_width(self, container: Size, viewport: Size) -> int:\n# Natural Language Annotations: \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    return self.virtual_size.width\n```", "```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    pass\n```", "```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    pass\n```"]}, "textual-src/textual/widget.py-get_content_height": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Gets the height (number of lines) in the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n------------------------------\n------------------------------\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n------------------------------\n------------------------------\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Called by textual to get the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return DigitsRenderable.get_width(self._value)\n------------------------------\n------------------------------\ndef on_mount(self):\n        self._refresh_scrollbars()\n\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Gets the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return self.virtual_size.width\n------------------------------\n------------------------------\nArgs:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n# Natural Language Annotations: \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n```", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    # Replace the following line with your implementation\n    pass\n```", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    return self.virtual_size.height\n```"]}, "textual-src/textual/suggester.py-_get_suggestion": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            selector: A selector to specify a widget that should be used as the reference\n                for the event offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the event may not land on the widget you specified.\n------------------------------\n------------------------------\n@abstractmethod\n    async def get_suggestion(self, value: str) -> str | None:\n        \"\"\"Try to get a completion suggestion for the given input value.\n\n        Custom suggesters should implement this method.\n\n        Note:\n            The value argument will be casefolded if `self.case_sensitive` is `False`.\n\n        Note:\n            If your implementation is not deterministic, you may need to disable caching.\n------------------------------\n------------------------------\nArgs:\n            value: The current value of the requester widget.\n\n        Returns:\n            A valid suggestion or `None`.\n        \"\"\"\n        pass\n------------------------------\n------------------------------\nArgs:\n            sender: The sender.\n\n        Note:\n            When creating a message the sender is automatically set.\n            Normally there will be no need for this method to be called.\n            This method will be used when strict control is required over\n            the sender of a message.\n\n        Returns:\n            Self.\n        \"\"\"\n        self._sender = sender\n        return self\n------------------------------\n------------------------------\nclass SuggestionReady(Message):\n    \"\"\"Sent when a completion suggestion is ready.\"\"\"\n\n    value: str\n    \"\"\"The value to which the suggestion is for.\"\"\"\n    suggestion: str\n    \"\"\"The string suggestion.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            value: The value\n\n        Returns:\n            The key\n        \"\"\"\n        return self._reverse.get(value)\n\n    def contains_value(self, value: Value) -> bool:\n        \"\"\"Check if `value` is a value within this TwoWayDict.\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            True if the value is within the values of this dict.\n        \"\"\"\n        return value in self._reverse\n\n    def __len__(self):\n        return len(self._forward)\n------------------------------\n------------------------------\nclass Suggester(ABC):\n    \"\"\"Defines how widgets generate completion suggestions.\n\n    To define a custom suggester, subclass `Suggester` and implement the async method\n    `get_suggestion`.\n    See [`SuggestFromList`][textual.suggester.SuggestFromList] for an example.\n    \"\"\"\n\n    cache: LRUCache[str, str | None] | None\n    \"\"\"Suggestion cache, if used.\"\"\"\n\n    def __init__(self, *, use_cache: bool = True, case_sensitive: bool = False) -> None:\n        \"\"\"Create a suggester object.\n------------------------------\n------------------------------\nNote:\n            The exceptions that can be raised by this method are all of\n            those that can be raised by calling [`Path.read_text`][pathlib.Path.read_text].\n        \"\"\"\n        path, anchor = self.sanitize_location(str(path))\n        data = await asyncio.get_running_loop().run_in_executor(\n            None, partial(path.read_text, encoding=\"utf-8\")\n        )\n        await self.update(data)\n        if anchor:\n            self.goto_anchor(anchor)\n------------------------------\n------------------------------\nArgs:\n            selector: A selector to specify a widget that should be used as the reference\n                for the events offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the events may not land on the widget you specified.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n# Natural Language Annotations: \"\"\"Used by widgets to get completion suggestions.\n\n        Note:\n            When implementing custom suggesters, this method does not need to be\n            overridden.\n\n        Args:\n            requester: The message target that requested a suggestion.\n            value: The current value to complete.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    pass\n```", "```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    pass\n```", "```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n```"]}, "textual-src/textual/dom.py-add_class": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nShould be called whenever CSS classes / pseudo classes change.\n        \"\"\"\n        try:\n            self.app.update_styles(self)\n        except NoActiveAppError:\n            pass\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def remove_class(self, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Remove class names from this Node.\n\n        Args:\n            *class_names: CSS class names to remove.\n            update: Also update styles.\n------------------------------\n------------------------------\nArgs:\n            *class_names: CSS class names to toggle.\n\n        Returns:\n            Self.\n        \"\"\"\n        check_identifiers(\"class name\", *class_names)\n        old_classes = self._classes.copy()\n        self._classes.symmetric_difference_update(class_names)\n        if old_classes == self._classes:\n            return self\n        self._update_styles()\n        return self\n------------------------------\n------------------------------\nReturns:\n            Self.\n        \"\"\"\n        check_identifiers(\"class name\", *class_names)\n        old_classes = self._classes.copy()\n        self._classes.difference_update(class_names)\n        if old_classes == self._classes:\n            return self\n        if update:\n            self._update_styles()\n        return self\n\n    def toggle_class(self, *class_names: str) -> Self:\n        \"\"\"Toggle class names on this Node.\n------------------------------\n------------------------------\ndef add_class(self, *class_names: str) -> DOMQuery[QueryType]:\n        \"\"\"Add the given class name(s) to nodes.\"\"\"\n        for node in self:\n            node.add_class(*class_names)\n        return self\n\n    def remove_class(self, *class_names: str) -> DOMQuery[QueryType]:\n        \"\"\"Remove the given class names from the nodes.\"\"\"\n        for node in self:\n            node.remove_class(*class_names)\n        return self\n------------------------------\n------------------------------\ndef set_class(self, add: bool, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Add or remove class(es) based on a condition.\n\n        Args:\n            add: Add the classes if True, otherwise remove them.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\n        if add:\n            self.add_class(*class_names, update=update)\n        else:\n            self.remove_class(*class_names, update=update)\n        return self\n------------------------------\n------------------------------\nArgs:\n            add: Add the classes if True, otherwise remove them.\n\n        Returns:\n            Self.\n        \"\"\"\n        for node in self:\n            node.set_class(add, *class_names)\n        return self\n\n    def set_classes(self, classes: str | Iterable[str]) -> DOMQuery[QueryType]:\n        \"\"\"Set the classes on nodes to exactly the given set.\n\n        Args:\n            classes: A string of space separated classes, or an iterable of class names.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_class(self, *class_names: str, update: bool = True) -> Self:\n# Natural Language Annotations: \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\"\"\"\n    for node in self:\n        node.add_class(*class_names, update=update)\n    return self\n```", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```"]}, "textual-src/textual/reactive.py-_initialize_object": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n# Refresh according to descriptor flags\n            if self._layout or self._repaint or self._recompose:\n                obj.refresh(\n                    repaint=self._repaint,\n                    layout=self._layout,\n                    recompose=self._recompose,\n                )\n\n    @classmethod\n    def _check_watchers(cls, obj: Reactable, name: str, old_value: Any) -> None:\n        \"\"\"Check watchers, and call watch methods / computes\n------------------------------\n------------------------------\nArgs:\n            obj: Object containing attribute to watch.\n            attribute_name: Attribute to watch.\n            callback: A callback to run when attribute changes.\n            init: Check watchers on first call.\n        \"\"\"\n        _watch(self, obj, attribute_name, callback, init=init)\n\n    def get_pseudo_classes(self) -> Iterable[str]:\n        \"\"\"Get any pseudo classes applicable to this Node, e.g. hover, focus.\n------------------------------\n------------------------------\n@classmethod\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def _reset_object(cls, obj: object) -> None:\n        \"\"\"Reset reactive structures on object (to avoid reference cycles).\n\n        Args:\n            obj: A reactive object.\n        \"\"\"\n        getattr(obj, \"__watchers\", {}).clear()\n        getattr(obj, \"__computes\", []).clear()\n------------------------------\n------------------------------\nArgs:\n            obj: The ``Styles`` object.\n            objtype: The ``Styles`` class.\n\n        Returns:\n            An ``Edges`` object describing the type and style of each edge.\n        \"\"\"\n\n        return Edges(*self._get_properties(obj))\n\n    def __set__(\n        self,\n        obj: StylesBase,\n        border: BorderDefinition | None,\n    ) -> None:\n        \"\"\"Set the border.\n------------------------------\n------------------------------\nArgs:\n        node: The node that created the watcher.\n        obj: The parent object.\n        attribute_name: The attribute to watch.\n        callback: A callable to call when the attribute changes.\n        init: True to call watcher initialization.\n    \"\"\"\n    if not hasattr(obj, \"__watchers\"):\n        setattr(obj, \"__watchers\", {})\n    watchers: dict[str, list[tuple[Reactable, WatchCallbackType]]] = getattr(\n        obj, \"__watchers\"\n    )\n------------------------------\n------------------------------\nArgs:\n            id: The ID to search for in the subtree.\n            expect_type: Require the object be of the supplied type, or None for any type.\n\n        Returns:\n            The first descendant encountered with this ID.\n------------------------------\n------------------------------\nclass reactive(Reactive[ReactiveType]):\n    \"\"\"Create a reactive attribute.\n\n    Args:\n        default: A default value or callable that returns a default.\n        layout: Perform a layout on change.\n        repaint: Perform a repaint on change.\n        init: Call watchers on initialize (post mount).\n        always_update: Call watchers even when the new value equals the old value.\n        bindings: Refresh bindings when the reactive changes.\n    \"\"\"\n------------------------------\n------------------------------\nArgs:\n            obj: An object with reactive attributes.\n            name: Name of attribute.\n        \"\"\"\n        _rich_traceback_omit = True\n        internal_name = f\"_reactive_{name}\"\n        if hasattr(obj, internal_name):\n            # Attribute already has a value\n            return\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _initialize_object(cls, obj: Reactable) -> None:\n# Natural Language Annotations: \"\"\"Set defaults and call any watchers / computes for the first time.\n\n        Args:\n            obj: An object with Reactive descriptors\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attribute_name, default in cls.__dict__.items():\n        if isinstance(default, Reactive):\n            if not hasattr(obj, attribute_name):\n                setattr(obj, attribute_name, default.default())\n            default.post_mount(obj, attribute_name)\n```", "```\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    _reset_object(obj)\n    for attribute_name in dir(obj):\n        if (\n            attribute_name.startswith(\"_\")\n            and attribute_name.endswith(\"_reactive\")\n            and attribute_name not in obj.__watchers\n        ):\n            _check_watchers(obj, attribute_name, None, init=True)\n    obj._default_reactive()\n```", "```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attribute_name, descriptor in vars(obj.__class__).items():\n        if isinstance(descriptor, Reactive):\n            descriptor._initialize(obj)\n\n    for attribute_name, descriptor in vars(obj.__class__).items():\n        if isinstance(descriptor, Reactive):\n            descriptor._check_watchers(obj, attribute_name, None, init=True)\n```"]}, "textual-src/textual/message_pump.py-call_after_refresh": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n------------------------------\n------------------------------\ndef call_next(self, callback: Callback, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Schedule a callback to run immediately after processing the current message.\n------------------------------\n------------------------------\ndef _invoke_later(self, callback: CallbackType, sender: MessagePump) -> None:\n        \"\"\"Enqueue a callback to be invoked after the screen is repainted.\n\n        Args:\n            callback: A callback.\n            sender: The sender (active message pump) of the callback.\n        \"\"\"\n\n        self._callbacks.append((callback, sender))\n        self.check_idle()\n------------------------------\n------------------------------\nIf `result` is provided and a callback was set when the screen was [pushed][textual.app.App.push_screen], then\n        the callback will be invoked with `result`.\n\n        Args:\n            result: The optional result to be passed to the result callback.\n\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n------------------------------\n------------------------------\nThis method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n------------------------------\n------------------------------\nReturns:\n            True if the messages was posted successfully, False if the message was not posted\n                (because the message pump was in the process of closing).\n        \"\"\"\n        return self.post_message(message)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    async def on_callback(self, event: events.Callback) -> None:\n        await invoke(event.callback)\n------------------------------\n------------------------------\nasync def _invoke_and_clear_callbacks(self) -> None:\n        \"\"\"If there are scheduled callbacks to run, call them and clear\n        the callback queue.\"\"\"\n        if self._callbacks:\n            callbacks = self._callbacks[:]\n            self._callbacks.clear()\n            for callback, message_pump in callbacks:\n                reset_token = active_message_pump.set(message_pump)\n                try:\n                    await invoke(callback)\n                finally:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if not self._message_pump.is_closing:\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        self._callbacks.append(callback_message)\n        return True\n    else:\n        return False\n```", "```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if not self._callbacks:\n        return False\n\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._next_callbacks.append(callback_message)\n    self.check_idle()\n\n    return True\n```", "```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self._closed:\n        return False\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._callbacks.append(callback_message)\n    self.check_idle()\n    return True\n```"]}, "textual-src/textual/message_pump.py-call_later": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n------------------------------\n------------------------------\ndef call_next(self, callback: Callback, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Schedule a callback to run immediately after processing the current message.\n------------------------------\n------------------------------\nThis method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n------------------------------\n------------------------------\nasync def invoke(callback: Callable[..., Any], *params: object) -> Any:\n    \"\"\"Invoke a callback with an arbitrary number of parameters.\n\n    Args:\n        callback: The callable to be invoked.\n\n    Returns:\n        The return value of the invoked callable.\n    \"\"\"\n\n    app: App | None\n    try:\n        app = active_app.get()\n    except LookupError:\n        # May occur if this method is called outside of an app context (i.e. in a unit test)\n        app = None\n------------------------------\n------------------------------\nArgs:\n            event: An Event object.\n        \"\"\"\n        await self._on_message(event)\n\n    async def _on_message(self, message: Message) -> None:\n        \"\"\"Called to process a message.\n\n        Args:\n            message: A Message object.\n        \"\"\"\n        _rich_traceback_guard = True\n        handler_name = message.handler_name\n------------------------------\n------------------------------\nasync def _invoke(callback: Callable, *params: object) -> Any:\n    \"\"\"Invoke a callback with an arbitrary number of parameters.\n\n    Args:\n        callback: The callable to be invoked.\n\n    Returns:\n        The return value of the invoked callable.\n    \"\"\"\n    _rich_traceback_guard = True\n    parameter_count = count_parameters(callback)\n    result = callback(*params[:parameter_count])\n    if isawaitable(result):\n        result = await result\n    return result\n------------------------------\n------------------------------\nArgs:\n        event_target: The object which will receive the timer events.\n        interval: The time between timer events, in seconds.\n        name: A name to assign the event (for debugging).\n        callback: A optional callback to invoke when the event is handled.\n        repeat: The number of times to repeat the timer, or None to repeat forever.\n        skip: Enable skipping of scheduled events that couldn't be sent in time.\n        pause: Start the timer paused.\n    \"\"\"\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    from functools import partial\n    from .events import Callback\n\n    if self._is_closed:\n        return False\n\n    callback_message = Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._later_callbacks.append(callback_message)\n    self.check_idle()\n\n    return True\n```", "```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run next after all messages are processed in this object.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if not self._pumping:\n        return False\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._next_callbacks.append(callback_message)\n    return True\n```", "```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self._is_closed:\n        return False\n\n    callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n    callback_message._prevent.update(self._get_prevented_messages())\n    self._next_callbacks.append(callback_message)\n    self.check_idle()\n    return True\n```"]}, "textual-src/textual/message_pump.py-post_message": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef check_message_enabled(self, message: Message) -> bool:\n        \"\"\"Check if a given message is enabled (allowed to be sent).\n\n        Args:\n            message: A message object.\n\n        Returns:\n            `True` if the message will be sent, or `False` if it is disabled.\n        \"\"\"\n        return type(message) not in self._disabled_messages\n------------------------------\n------------------------------\ndef post_message(self, message: Message) -> bool:\n        \"\"\"Post a message to this widget.\n\n        Args:\n            message: Message to post.\n------------------------------\n------------------------------\nasync def _dispatch_message(self, message: Message) -> None:\n        \"\"\"Dispatch a message received from the message queue.\n\n        Args:\n            message: A message object\n        \"\"\"\n        _rich_traceback_guard = True\n        if message.no_dispatch:\n            return\n\n        try:\n            message_hook = message_hook_context_var.get()\n        except LookupError:\n            pass\n        else:\n            message_hook(message)\n------------------------------\n------------------------------\nArgs:\n            event: An Event object.\n        \"\"\"\n        await self._on_message(event)\n\n    async def _on_message(self, message: Message) -> None:\n        \"\"\"Called to process a message.\n\n        Args:\n            message: A Message object.\n        \"\"\"\n        _rich_traceback_guard = True\n        handler_name = message.handler_name\n------------------------------\n------------------------------\ndef check_message_enabled(self, message: Message) -> bool:\n        \"\"\"Check if a given message is enabled (allowed to be sent).\n\n        Args:\n            message: A message object\n------------------------------\n------------------------------\nArgs:\n            value: The current value of the requester widget.\n\n        Returns:\n            A valid suggestion or `None`.\n        \"\"\"\n        pass\n------------------------------\n------------------------------\ndef check_idle(self) -> None:\n        \"\"\"Prompt the message pump to call idle if the queue is empty.\"\"\"\n        if self._running and self._message_queue.empty():\n            self.post_message(messages.Prompt())\n\n    async def _post_message(self, message: Message) -> bool:\n        \"\"\"Post a message or an event to this message pump.\n\n        This is an internal method for use where a coroutine is required.\n\n        Args:\n            message: A message object.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def post_message(self, message: Message) -> bool:\n# Natural Language Annotations: \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    if not self.check_message_enabled(message):\n        return False\n\n    self._message_queue.put(message)\n    self.check_idle()\n\n    return True\n```", "```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    if self.check_message_enabled(message):\n        self._message_queue.put(message)\n        self.check_idle()\n        return True\n    else:\n        return False\n```", "```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    if self.check_message_enabled(message):\n        self._message_queue.put(message)\n        return True\n    else:\n        return False\n```"]}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@lru_cache(maxsize=4096)\n    def intersection(self, region: Region) -> Region:\n        \"\"\"Get the overlapping portion of the two regions.\n\n        Args:\n            region: A region that overlaps this region.\n------------------------------\n------------------------------\ndef _region_to_grid_coordinates(self, region: Region) -> Iterable[GridCoordinate]:\n        \"\"\"Get the grid squares under a region.\n\n        Args:\n            region: A region.\n------------------------------\n------------------------------\nReturns:\n            Set of placements.\n        \"\"\"\n        if self.total_region in region:\n            # Short circuit for when we want all the placements\n            return self.placements\n        visible_placements = self.spatial_map.get_values_in_region(region)\n        overlaps = region.overlaps\n        culled_placements = [\n            placement\n            for placement in visible_placements\n            if placement.fixed or overlaps(placement.region)\n        ]\n------------------------------\n------------------------------\ndef get_rectangle(region: Region) -> Rectangle:\n            \"\"\"Get a canvas Rectangle that wraps a region.\n\n            Args:\n                region: Widget region.\n\n            Returns:\n                A Rectangle that encloses the widget.\n            \"\"\"\n            offset = region.offset - container_offset - (1, 1)\n            width, height = region.size\n            return Rectangle(offset, width + 2, height + 2, keyline_color, line_style)\n------------------------------\n------------------------------\nArgs:\n            regions_and_values: An iterable of (REGION, FIXED, OVERLAY, VALUE).\n        \"\"\"\n        append_fixed = self._fixed.append\n        get_grid_list = self._map.__getitem__\n        _region_to_grid = self._region_to_grid_coordinates\n        total_region = self.total_region\n        for region, fixed, overlay, value in regions_and_values:\n            if fixed:\n                append_fixed(value)\n            else:\n                if not overlay:\n------------------------------\n------------------------------\nArgs:\n            region: A region.\n------------------------------\n------------------------------\nReturns:\n            A Region that encloses all other regions.\n        \"\"\"\n        if not regions:\n            raise ValueError(\"At least one region expected\")\n        min_x = min(regions, key=itemgetter(0)).x\n        max_x = max(regions, key=attrgetter(\"right\")).right\n        min_y = min(regions, key=itemgetter(1)).y\n        max_y = max(regions, key=attrgetter(\"bottom\")).bottom\n        return cls(min_x, min_y, max_x - min_x, max_y - min_y)\n------------------------------\n------------------------------\ndef _arrange_scrollbars(self, region: Region) -> Iterable[tuple[Widget, Region]]:\n        \"\"\"Arrange the 'chrome' widgets (typically scrollbars) for a layout element.\n\n        Args:\n            region: The containing region.\n\n        Returns:\n            Tuples of scrollbar Widget and region.\n        \"\"\"\n        show_vertical_scrollbar, show_horizontal_scrollbar = self.scrollbars_enabled\n------------------------------\n------------------------------\nreturn self._spatial_map\n\n    @property\n    def total_region(self) -> Region:\n        \"\"\"The total area occupied by the arrangement.\n\n        Returns:\n            A Region.\n        \"\"\"\n        _top, right, bottom, _left = self.scroll_spacing\n        return self.spatial_map.total_region.grow((0, right, bottom, 0))\n\n    def get_visible_placements(self, region: Region) -> list[WidgetPlacement]:\n        \"\"\"Get the placements visible within the given region.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_values_in_region(self, region: Region) -> list[ValueType]:\n# Natural Language Annotations: \"\"\"Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    visible_placements = self.spatial_map.get_values_in_region(region)\n    overlaps = region.overlaps\n    culled_placements = [\n        placement\n        for placement in visible_placements\n        if placement.fixed or overlaps(placement.region)\n    ]\n    return culled_placements\n```", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    visible_placements = self.spatial_map.get_values_in_region(region)\n    overlaps = region.overlaps\n    culled_placements = [\n        placement\n        for placement in visible_placements\n        if placement.fixed or overlaps(placement.region)\n    ]\n    return culled_placements\n```", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    visible_placements = self.spatial_map.get_values_in_region(region)\n    overlaps = region.overlaps\n    culled_placements = [\n        placement\n        for placement in visible_placements\n        if placement.fixed or overlaps(placement.region)\n    ]\n    return culled_placements\n```"]}, "textual-src/textual/validation.py-validate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@abstractmethod\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validate the value and return a ValidationResult describing the outcome of the validation.\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n\n    def describe_failure(self, failure: Failure) -> str | None:\n        \"\"\"Return a string description of the Failure.\n------------------------------\n------------------------------\nArgs:\n            value: The value\n\n        Returns:\n            The key\n        \"\"\"\n        return self._reverse.get(value)\n\n    def contains_value(self, value: Value) -> bool:\n        \"\"\"Check if `value` is a value within this TwoWayDict.\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            True if the value is within the values of this dict.\n        \"\"\"\n        return value in self._reverse\n\n    def __len__(self):\n        return len(self._forward)\n------------------------------\n------------------------------\nclass Integer(Number):\n    \"\"\"Validator which ensures the value is an integer which falls within a range.\"\"\"\n\n    class NotAnInteger(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid integer.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Ensure that `value` is an integer, optionally within a range.\n\n        Args:\n            value: The value to validate.\n------------------------------\n------------------------------\nclass NotANumber(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid number (decimal/integer, inc. scientific notation)\"\"\"\n\n    class NotInRange(Failure):\n        \"\"\"Indicates a failure due to the number not being within the range [minimum, maximum].\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Ensure that `value` is a valid number, optionally within a range.\n\n        Args:\n            value: The value to validate.\n------------------------------\n------------------------------\nReturns:\n            A ValidationResult indicating success if the function returned True,\n                and failure if the function return False.\n        \"\"\"\n        is_valid = self.function(value)\n        if is_valid:\n            return self.success()\n        return self.failure(failures=Function.ReturnedFalse(self, value))\n\n    def describe_failure(self, failure: Failure) -> str | None:\n        \"\"\"Describes why the validator failed.\n------------------------------\n------------------------------\nReturns:\n            A string description of the failure.\n        \"\"\"\n        return self.failure_description\n\n    def success(self) -> ValidationResult:\n        \"\"\"Shorthand for `ValidationResult(True)`.\n\n        You can return success() from a `Validator.validate` method implementation to signal\n        that validation has succeeded.\n\n        Returns:\n            A ValidationResult indicating validation succeeded.\n        \"\"\"\n        return ValidationResult()\n------------------------------\n------------------------------\nclass Incorrect(Failure):\n        \"\"\"Indicates a failure due to the length of the value being outside the range.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Ensure that value falls within the maximum and minimum length constraints.\n\n        Args:\n            value: The value to validate.\n------------------------------\n------------------------------\nclass ReturnedFalse(Failure):\n        \"\"\"Indicates validation failed because the supplied function returned False.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validate that the supplied function returns True.\n\n        Args:\n            value: The value to pass into the supplied function.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def validate(self, value: str) -> ValidationResult:\n# Natural Language Annotations: \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\nclass URLValidator(Validator):\n    class NotAURL(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid URL.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n        result = urllib.parse.urlparse(value)\n        if result.scheme and result.netloc:\n            return self.success()\n        return self.failure(failures=URLValidator.NotAURL(self, value))\n```", "```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    try:\n        result = urlparse(value)\n        if all([result.scheme, result.netloc]):\n            return ValidationResult(True)\n        else:\n            return ValidationResult(False, UrlValidator.MissingScheme(self, value))\n    except ValueError:\n        return ValidationResult(False, UrlValidator.NotAUrl(self, value))\n```", "```python\nclass URL(Validator):\n    class NotAURL(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid URL (does not contain a scheme).\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n        try:\n            result = urlparse(value)\n            if all([result.scheme, result.netloc]):\n                return self.success()\n        except ValueError:\n            pass\n        return self.failure(failures=URL.NotAURL(self, value))\n\n    def describe_failure(self, failure: Failure) -> str | None:\n        \"\"\"Describes why the validator failed.\n\n        Returns:\n            A string description of the failure.\n        \"\"\"\n        return self.failure_description\n\n    def success(self) -> ValidationResult:\n        \"\"\"Shorthand for `ValidationResult(True)`.\n\n        You can return success() from a `Validator.validate` method implementation to signal\n        that validation has succeeded.\n\n        Returns:\n            A ValidationResult indicating validation succeeded.\n        \"\"\"\n        return ValidationResult()\n```"]}, "textual-src/textual/geometry.py-clamp": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef __contains__(self, other: Any) -> bool:\n        try:\n            x: int\n            y: int\n            x, y = other\n        except Exception:\n            raise TypeError(\n                \"Dimensions.__contains__ requires an iterable of two integers\"\n            )\n        width, height = self\n        return width > x >= 0 and height > y >= 0\n\n    def clamp_offset(self, offset: Offset) -> Offset:\n        \"\"\"Clamp an offset to fit within the width x height.\n------------------------------\n------------------------------\nArgs:\n            offset: An offset.\n\n        Returns:\n            A new offset that will fit inside the dimensions defined in the Size.\n        \"\"\"\n        return offset.clamp(self.width, self.height)\n------------------------------\n------------------------------\nReturns:\n            A new region.\n        \"\"\"\n        expand_width, expand_height = size\n        x, y, width, height = self\n        return Region(\n            x - expand_width,\n            y - expand_height,\n            width + expand_width * 2,\n            height + expand_height * 2,\n        )\n\n    def clip_size(self, size: tuple[int, int]) -> Region:\n        \"\"\"Clip the size to fit within minimum values.\n\n        Args:\n            size: Maximum width and height.\n------------------------------\n------------------------------\nArgs:\n            width: Width of bounds.\n            height: Height of bounds.\n\n        Returns:\n            Clipped region.\n        \"\"\"\n        x1, y1, x2, y2 = self.corners\n\n        _clamp = clamp\n        new_region = Region.from_corners(\n            _clamp(x1, 0, width),\n            _clamp(y1, 0, height),\n            _clamp(x2, 0, width),\n            _clamp(y2, 0, height),\n        )\n        return new_region\n------------------------------\n------------------------------\ndef with_height(self, height: int) -> Size:\n        \"\"\"Get a new Size with just the height changed.\n\n        Args:\n            width: New height.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(self.width, height)\n------------------------------\n------------------------------\nReturns:\n            An offset to add to the X coordinate.\n        \"\"\"\n        offset_x = 0\n        align_horizontal = self.align_horizontal\n        if align_horizontal != \"left\":\n            if align_horizontal == \"center\":\n                offset_x = (parent_width - width) // 2\n            else:\n                offset_x = parent_width - width\n        return offset_x\n\n    def _align_height(self, height: int, parent_height: int) -> int:\n        \"\"\"Align the height dimensions\n------------------------------\n------------------------------\n@lru_cache(maxsize=4096)\n    def __contains__(self, other: Any) -> bool:\n        \"\"\"Check if a point is in this region.\"\"\"\n        if isinstance(other, Region):\n            return self.contains_region(other)\n        else:\n            try:\n                return self.contains_point(other)\n            except TypeError:\n                return False\n\n    def clip(self, width: int, height: int) -> Region:\n        \"\"\"Clip this region to fit within width, height.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def clamp(self, width: int, height: int) -> Offset:\n# Natural Language Annotations: \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef clamp(self, width: int, height: int) -> Offset:\n        \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\n        return Offset(max(0, min(width, self.width)), max(0, min(height, self.height)))\n```", "```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    offset_x = 0\n    align_horizontal = self.align_horizontal\n    if align_horizontal != \"left\":\n        if align_horizontal == \"center\":\n            offset_x = (width - self.width) // 2\n        else:\n            offset_x = width - self.width\n    return Offset(offset_x, 0)\n```", "```python\ndef clamp(self, width: int, height: int) -> Offset:\n        \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\n        x = max(0, min(self.x, width))\n        y = max(0, min(self.y, height))\n        return Offset(x, y)\n```"]}, "textual-src/textual/constants.py-_get_textual_animations": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nAnimationLevel = Literal[\"none\", \"basic\", \"full\"]\n\"\"\"The levels that the [`TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS] env var can be set to.\"\"\"\n------------------------------\n------------------------------\nself.animation_level: AnimationLevel = constants.TEXTUAL_ANIMATIONS\n        \"\"\"Determines what type of animations the app will display.\n\n        See [`textual.constants.TEXTUAL_ANIMATIONS`][textual.constants.TEXTUAL_ANIMATIONS].\n        \"\"\"\n\n        self._last_focused_on_app_blur: Widget | None = None\n        \"\"\"The widget that had focus when the last `AppBlur` happened.\n\n        This will be used to restore correct focus when an `AppFocus`\n        happens.\n        \"\"\"\n------------------------------\n------------------------------\nReturns:\n        The integer associated with the environment variable if it's set to a valid int\n            or the default value otherwise.\n    \"\"\"\n    try:\n        return int(os.environ[name])\n    except KeyError:\n        return default\n    except ValueError:\n        return default\n------------------------------\n------------------------------\ndef _get_environ_bool(name: str) -> bool:\n    \"\"\"Check an environment variable switch.\n\n    Args:\n        name: Name of environment variable.\n\n    Returns:\n        `True` if the env var is \"1\", otherwise `False`.\n    \"\"\"\n    has_environ = get_environ(name) == \"1\"\n    return has_environ\n------------------------------\n------------------------------\nAttributes:\n        EXPECT: The initial expectation of the tokenizer. Since we start tokenizing\n            at the root scope, we might expect to see either a variable or selector, for example.\n        STATE_MAP: Maps token names to Expects, defines the sets of valid tokens\n            that we'd expect to see next, given the current token. For example, if\n            we've just processed a variable declaration name, we next expect to see\n            the value of that variable.\n    \"\"\"\n------------------------------\n------------------------------\ndef _get_environ_int(name: str, default: int) -> int:\n    \"\"\"Retrieves an integer environment variable.\n\n    Args:\n        name: Name of environment variable.\n        default: The value to use if the value is not set, or set to something other\n            than a valid integer.\n------------------------------\n------------------------------\ndef with_reference(self, by: ReferencedBy | None) -> \"Token\":\n        \"\"\"Return a copy of the Token, with reference information attached.\n        This is used for variable substitution, where a variable reference\n        can refer to tokens which were defined elsewhere. With the additional\n        ReferencedBy data attached, we can track where the token we are referring\n        to is used.\n        \"\"\"\n        return Token(\n            name=self.name,\n            value=self.value,\n------------------------------\n------------------------------\nlevel: Minimum level required for the animation to take place (inclusive).\n        \"\"\"\n        self._animate(\n            attribute,\n            value,\n            final_value=final_value,\n            duration=duration,\n            speed=speed,\n            delay=delay,\n            easing=easing,\n            on_complete=on_complete,\n            level=level,\n        )\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_textual_animations() -> AnimationLevel:\n# Natural Language Annotations: \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _get_textual_animations() -> AnimationLevel:\n    name = \"TEXTUAL_ANIMATIONS\"\n    default = \"full\"\n    level = get_environ(name, default)\n\n    if level in [\"none\", \"basic\", \"full\"]:\n        return level\n    else:\n        return default\n```", "```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    default_value = \"full\"\n    value = get_environ(\"TEXTUAL_ANIMATIONS\", default_value)\n    if value not in AnimationLevel.__args__:\n        value = default_value\n    return value\n```", "```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    value = constants.TEXTUAL_ANIMATIONS\n    if value not in [\"none\", \"basic\", \"full\"]:\n        return \"full\"\n    return value\n```"]}, "textual-src/textual/color.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef get_color(self, position: float) -> Color:\n        \"\"\"Get a color from the gradient at a position between 0 and 1.\n\n        Positions that are between stops will return a blended color.\n\n        Args:\n            position: A number between 0 and 1, where 0 is the first stop, and 1 is the last.\n------------------------------\n------------------------------\nFor example, `\"#46b3de\"`.\n        \"\"\"\n        r, g, b, _a = self.clamped\n        return f\"#{r:02X}{g:02X}{b:02X}\"\n\n    @property\n    def css(self) -> str:\n        \"\"\"The color in CSS RGB or RGBA form.\n\n        For example, `\"rgb(10,20,30)\"` for an RGB color, or `\"rgb(50,70,80,0.5)\"` for an RGBA color.\n        \"\"\"\n        r, g, b, a = self\n        return f\"rgb({r},{g},{b})\" if a == 1 else f\"rgba({r},{g},{b},{a})\"\n------------------------------\n------------------------------\nThis method calculates a new color on a gradient.\n        The position on the gradient is given by `factor`, which is a float between 0 and 1, where 0 is the original color, and 1 is the `destination` color.\n        A value of `gradient` between the two extremes produces a color somewhere between the two end points.\n\n        Args:\n            destination: Another color.\n            factor: A blend factor, 0 -> 1.\n            alpha: New alpha for result.\n------------------------------\n------------------------------\nFor example, `\"#46b3de\"` for an RGB color, or `\"#3342457f\"` for a color with alpha.\n        \"\"\"\n        r, g, b, a = self.clamped\n        return (\n            f\"#{r:02X}{g:02X}{b:02X}\"\n            if a == 1\n            else f\"#{r:02X}{g:02X}{b:02X}{int(a*255):02X}\"\n        )\n\n    @property\n    def hex6(self) -> str:\n        \"\"\"The color in CSS hex form, with 6 digits for RGB. Alpha is ignored.\n------------------------------\n------------------------------\nArgs:\n            destination: Point where factor would be 1.0.\n            factor: A value between 0 and 1.0.\n\n        Returns:\n            A new point on a line between self and destination.\n        \"\"\"\n        x1, y1 = self\n        x2, y2 = destination\n        return Offset(\n            int(x1 + (x2 - x1) * factor),\n            int(y1 + (y2 - y1) * factor),\n        )\n\n    def get_distance_to(self, other: Offset) -> float:\n        \"\"\"Get the distance to another offset.\n------------------------------\n------------------------------\nHSL color is an alternative way of representing a color, which can be used in certain color calculations.\n\n        Returns:\n            Color encoded in HSL format.\n        \"\"\"\n        r, g, b = self.normalized\n        h, l, s = rgb_to_hls(r, g, b)\n        return HSL(h, s, l)\n\n    @property\n    def brightness(self) -> float:\n        \"\"\"The human perceptual brightness.\n------------------------------\n------------------------------\nclass Gradient:\n    \"\"\"Defines a color gradient.\"\"\"\n\n    def __init__(self, *stops: tuple[float, Color]) -> None:\n        \"\"\"Create a color gradient that blends colors to form a spectrum.\n\n        A gradient is defined by a sequence of \"stops\" consisting of a float and a color.\n        The stop indicate the color at that point on a spectrum between 0 and 1.\n\n        Args:\n            stops: A colors stop.\n------------------------------\n------------------------------\nArgs:\n            obj: The ``Styles`` object.\n            color: The color to set. Pass a ``Color`` instance directly,\n                or pass a ``str`` which will be parsed into a color (e.g. ``\"red\"\"``, ``\"rgb(20, 50, 80)\"``,\n                ``\"#f4e32d\"``).\n------------------------------\n------------------------------\nThe rules of this method are:\n\n        - Given an ``int``, parent is ``self`` and location is the integer value.\n        - Given a ``Widget``, parent is the widget's parent and location is\n          where the widget is found in the parent's ``children``. If it\n          can't be found a ``MountError`` will be raised.\n        - Given a string, it is used to perform a ``query_one`` and then the\n          result is used as if a ``Widget`` had been given.\n        \"\"\"\n------------------------------\n------------------------------\nA value of 1 is returned for pure white, and 0 for pure black.\n        Other colors lie on a gradient between the two extremes.\n        \"\"\"\n        r, g, b = self.normalized\n        brightness = (299 * r + 587 * g + 114 * b) / 1000\n        return brightness\n\n    @property\n    def hex(self) -> str:\n        \"\"\"The color in CSS hex form, with 6 digits for RGB, and 8 digits for RGBA.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(cls, color_text: str | Color) -> Color:\n# Natural Language Annotations: \"\"\"Parse a string containing a named color or CSS-style color.\n\n        Colors may be parsed from the following formats:\n\n        - Text beginning with a `#` is parsed as a hexadecimal color code,\n         where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n            - `#RGB`\n            - `#RGBA`\n            - `#RRGGBB`\n            - `#RRGGBBAA`\n\n        - Alternatively, RGB colors can also be specified in the format\n         that follows, where R, G, and B must be numbers between 0 and 255\n         and A must be a value between 0 and 1:\n\n            - `rgb(R,G,B)`\n            - `rgb(R,G,B,A)`\n\n        - The HSL model can also be used, with a syntax similar to the above,\n         if H is a value between 0 and 360, S and L are percentages, and A\n         is a value between 0 and 1:\n\n            - `hsl(H,S,L)`\n            - `hsla(H,S,L,A)`\n\n        Any other formats will raise a `ColorParseError`.\n\n        Args:\n            color_text: Text with a valid color format. Color objects will\n                be returned unmodified.\n\n        Raises:\n            ColorParseError: If the color is not encoded correctly.\n\n        Returns:\n            Instance encoding the color specified by the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n\n    if isinstance(color_text, str):\n        if color_text.startswith(\"#\"):\n            # Hexadecimal color\n            if len(color_text) == 4:\n                r = int(color_text[1], 16) * 17\n                g = int(color_text[2], 16) * 17\n                b = int(color_text[3], 16) * 17\n                a = 1\n            elif len(color_text) == 5:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[3:5], 16)\n                b = int(color_text[5:7], 16)\n                a = 1\n            elif len(color_text) == 7:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[3:5], 16)\n                b = int(color_text[5:7], 16)\n                a = 1\n            elif len(color_text) == 9:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[3:5], 16)\n                b = int(color_text[5:7], 16)\n                a = int(color_text[7:9], 16) / 255\n            else:\n                raise ColorParseError(\"Invalid hex color\")\n\n        elif color_text.startswith(\"rgb(\") or color_text.startswith(\"rgba(\"):\n            # Rgb or rgba\n            parts = color_text[4:-1].split(\",\")\n            if len(parts) in (3, 4):\n                r = int(parts[0])\n                g = int(parts[1])\n                b = int(parts[2])\n                a = int(parts[3]) if len(parts) == 4 else 1\n            else:\n                raise ColorParseError(\"Invalid rgb color\")\n\n        elif color_text.startswith(\"hsl(\") or color_text.startswith(\"hsla(\"):\n            # Hsl or hsla\n            parts = color_text[4:-1].split(\",\")\n            if len(parts) in (3, 4):\n                h = int(parts[0])\n                s = int(parts[1][:-1]) / 100\n                l = int(parts[2][:-1]) / 100\n                a = float(parts[3]) if len(parts) == 4 else 1\n                r, g, b = hls_to_rgb(h / 360, l, s)\n                r, g, b = (r * 255, g * 255, b * 255)\n            else:\n                raise ColorParseError(\"Invalid hsl color\")\n\n        else:\n            raise ColorParseError(\"Invalid color format\")\n\n        return cls(r, g, b, a)\n```", "```python\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n    color_text = color_text.strip().lower()\n    if color_text.startswith('#'):\n        if len(color_text) == 4:\n            r, g, b = [int(n*2, 16) for n in color_text[1:]]\n            return Color(r, g, b)\n        elif len(color_text) == 7:\n            r, g, b = [int(color_text[i:i+2], 16) for i in range(1, 6, 2)]\n            return Color(r, g, b)\n        elif len(color_text) == 9:\n            r, g, b, a = [int(color_text[i:i+2], 16) for i in range(1, 8, 2)]\n            return Color(r, g, b, a / 255)\n    elif color_text.startswith('rgb('):\n        r, g, b = [int(n) for n in color_text[4:-1].split(',')]\n        return Color(r, g, b)\n    elif color_text.startswith('rgba('):\n        r, g, b, a = [float(n) for n in color_text[5:-1].split(',')]\n        return Color(r, g, b, a)\n    elif color_text.startswith('hsl('):\n        h, s, l = [int(n) for n in color_text[4:-1].split(',')]\n        r, g, b = hsl_to_rgb(h, s/100, l/100)\n        return Color(r, g, b)\n    elif color_text.startswith('hsla('):\n        h, s, l, a = [float(n) for n in color_text[5:-1].split(',')]\n        r, g, b = hsl_to_rgb(h, s/100, l/100)\n        return Color(r, g, b, a)\n    else:\n        raise ColorParseError(f'Unable to parse color \"{color_text}\"')\n```", "```python\ndef parse(cls, color_text: str | Color) -> Color:\n    if isinstance(color_text, Color):\n        return color_text\n\n    if isinstance(color_text, str):\n        if color_text.startswith(\"#\"):\n            if len(color_text) == 4:\n                color_text = \"#\" + \"\".join([2 * c for c in color_text[1:]])\n            elif len(color_text) == 7:\n                color_text += \"FF\"\n            try:\n                r = int(color_text[1:3], 16)\n                g = int(color_text[3:5], 16)\n                b = int(color_text[5:7], 16)\n                a = int(color_text[7:9], 16)\n                return cls(r, g, b, a / 255.0)\n            except ValueError:\n                raise ColorParseError(color_text)\n        elif color_text.startswith(\"rgb\"):\n            try:\n                r, g, b = [int(c) for c in color_text[4:-1].split(\",\")]\n                return cls(r, g, b, 1)\n            except ValueError:\n                raise ColorParseError(color_text)\n        elif color_text.startswith(\"rgba\"):\n            try:\n                r, g, b, a = [int(c) for c in color_text[5:-1].split(\",\")]\n                return cls(r, g, b, a / 255.0)\n            except ValueError:\n                raise ColorParseError(color_text)\n        elif color_text.startswith(\"hsl\"):\n            try:\n                h, s, l = [int(c) for c in color_text[4:-1].split(\",\")]\n                return cls.from_hsl(h, s, l, 1)\n            except ValueError:\n                raise ColorParseError(color_text)\n        elif color_text.startswith(\"hsla\"):\n            try:\n                h, s, l, a = [int(c) for c in color_text[5:-1].split(\",\")]\n                return cls.from_hsl(h, s, l, a / 255.0)\n            except ValueError:\n                raise ColorParseError(color_text)\n        else:\n            raise ColorParseError(color_text)\n\n    raise ColorParseError(color_text)\n```"]}, "textual-src/textual/_slug.py-slug": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef slug(text: str) -> str:\n    \"\"\"Create a Markdown-friendly slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n------------------------------\n------------------------------\nclass TrackedSlugs:\n    \"\"\"Provides a class for generating tracked slugs.\n\n    While [`slug`][textual._slug.slug] will generate a slug for a given\n    string, it does not guarantee that it is unique for a given context. If\n    you want to ensure that the same string generates unique slugs (perhaps\n    heading slugs within a Markdown document, as an example), use an\n    instance of this class to generate them.\n------------------------------\n------------------------------\nReturns:\n        A slug for the given text.\n\n    The rules used in generating the slug are based on observations of how\n    GitHub-flavoured Markdown works.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    return quote(result)\n------------------------------\n------------------------------\n\"\"\"Provides a utility function and class for creating Markdown-friendly slugs.\n\nThe approach to creating slugs is designed to be as close to\nGitHub-flavoured Markdown as possible. However, because there doesn't appear\nto be any actual documentation for this 'standard', the code here involves\nsome guesswork and also some pragmatic shortcuts.\n\nExpect this to grow over time.\n\nThe main rules used in here at the moment are:\n------------------------------\n------------------------------\ndef __init__(self) -> None:\n        \"\"\"Initialise the tracked slug object.\"\"\"\n        self._used: defaultdict[str, int] = defaultdict(int)\n        \"\"\"Keeps track of how many times a particular slug has been used.\"\"\"\n------------------------------\n------------------------------\ndef goto_anchor(self, anchor: str) -> bool:\n        \"\"\"Try and find the given anchor in the current document.\n\n        Args:\n            anchor: The anchor to try and find.\n\n        Note:\n            The anchor is found by looking at all of the headings in the\n            document and finding the first one whose slug matches the\n            anchor.\n\n            Note that the slugging method used is similar to that found on\n            GitHub.\n------------------------------\n------------------------------\ndef __init__(self, markdown: Markdown, *args, **kwargs) -> None:\n        self._markdown: Markdown = markdown\n        \"\"\"A reference to the Markdown document that contains this block.\"\"\"\n        self._text = Text()\n        self._token: Token | None = None\n        self._blocks: list[MarkdownBlock] = []\n        super().__init__(*args, **kwargs)\n\n    def compose(self) -> ComposeResult:\n        yield from self._blocks\n        self._blocks.clear()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def slug(self, text: str) -> str:\n# Natural Language Annotations: \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n        Args:\n            text: The text to generate a slug from.\n\n        Returns:\n            A slug for the given text.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    slug = quote(result)\n    if slug in self._used:\n        self._used[slug] += 1\n        slug += str(self._used[slug])\n    else:\n        self._used[slug] = 0\n    return slug\n```", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    slug = quote(result)\n    if slug in self._used:\n        self._used[slug] += 1\n        slug += \"-\" + str(self._used[slug])\n    else:\n        self._used[slug] = 0\n    return slug\n```", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    for rule, replacement in (\n        (STRIP_RE, \"\"),\n        (WHITESPACE_RE, WHITESPACE_REPLACEMENT),\n    ):\n        result = rule.sub(replacement, result)\n    if result in self._used:\n        self._used[result] += 1\n        result += f\"-{self._used[result]}\"\n    else:\n        self._used[result] = 0\n    return quote(result)\n```"]}, "textual-src/textual/_styles_cache.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            styles: Styles object.\n            y: The y coordinate of the line (relative to widget screen offset).\n            size: Size of the widget.\n            content_size: Size of the content area.\n            padding: Padding.\n            base_background: Background color of widget beneath this line.\n            background: Background color of widget.\n            render_content_line: Callback to render a line of content.\n            console: The console in use by the app.\n------------------------------\n------------------------------\nArgs:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n------------------------------\n------------------------------\nbase_background, background = widget._opacity_background_colors\n        styles = widget.styles\n        strips = self.render(\n            styles,\n            widget.region.size,\n            base_background,\n            background,\n            widget.render_line,\n            widget.app.console,\n            (\n                None\n                if border_title is None\n                else (\n                    border_title,\n------------------------------\n------------------------------\ncontent_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n------------------------------\n------------------------------\nborder_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            opacity: Opacity of line.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(\n# Natural Language Annotations: \"\"\"Render a widget content plus CSS styles.\n\n        Args:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            content_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef render(\n    styles,\n    size,\n    base_background,\n    background,\n    render_content_line,\n    console,\n    border_title=None,\n    border_subtitle=None,\n    content_size=None,\n    padding=None,\n    crop=None,\n    filters=None,\n    opacity=1.0\n):\n    # Your code here\n    pass\n```", "```python\ndef render(\n    styles,\n    size,\n    base_background,\n    background,\n    render_content_line,\n    console,\n    border_title=None,\n    border_subtitle=None,\n    content_size=None,\n    padding=None,\n    crop=None,\n    filters=None,\n    opacity=1.0,\n):\n    # Here goes the implementation of your function\n    pass\n```", "```python\ndef render(\n    styles,\n    size,\n    base_background,\n    background,\n    render_content_line,\n    console,\n    border_title=None,\n    border_subtitle=None,\n    content_size=None,\n    padding=None,\n    crop=None,\n    filters=None,\n    opacity=1.0,\n):\n    # Your code here\n    pass\n```"]}, "textual-src/textual/document/_document.py-replace_range": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n        top, bottom = sorted((start, end))\n------------------------------\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def text(self) -> str:\n        \"\"\"The text from the document as a string.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            query: The tree-sitter Query to perform.\n            start_point: The (row, column byte) to start the query at.\n            end_point: The (row, column byte) to end the query at.\n\n        Returns:\n            A tuple containing the nodes and text captured by the query.\n        \"\"\"\n\n        if not TREE_SITTER:\n            raise SyntaxAwareDocumentError(\n                \"tree-sitter is not available on this architecture.\"\n            )\n------------------------------\n------------------------------\nArgs:\n            start: The start location.\n            end: The end location.\n\n        Returns:\n            The text between start and end.\n        \"\"\"\n        start, end = sorted((start, end))\n        return self.document.get_text_range(start, end)\n\n    def edit(self, edit: Edit) -> EditResult:\n        \"\"\"Perform an Edit.\n\n        Args:\n            edit: The Edit to perform.\n------------------------------\n------------------------------\nArgs:\n            query: The tree-sitter Query to perform.\n            start_point: The (row, column byte) to start the query at.\n            end_point: The (row, column byte) to end the query at.\n\n        Returns:\n            A tuple containing the nodes and text captured by the query.\n        \"\"\"\n        return []\n\n    def prepare_query(self, query: str) -> Query | None:\n        return None\n------------------------------\n------------------------------\nArgs:\n            insert: The text to insert into the document.\n            start: The start location of the text to replace.\n            end: The end location of the text to replace.\n\n        Returns:\n            An EditResult or None if no edit was performed (e.g. on read-only mode).\n        \"\"\"\n        if self.read_only:\n            return None\n        return self.replace(insert, start, end, maintain_selection_offset=False)\n------------------------------\n------------------------------\ndef undo(self, text_area: TextArea) -> EditResult:\n        \"\"\"Undo the edit operation.\n\n        Looks at the data stored in the edit, and performs the inverse operation of `Edit.do`.\n\n        Args:\n            text_area: The `TextArea` to undo the insert operation on.\n\n        Returns:\n            An `EditResult` containing information about the replace operation.\n        \"\"\"\n        replaced_text = self._edit_result.replaced_text\n        edit_end = self._edit_result.end_location\n------------------------------\n------------------------------\nselection_start, selection_end = text_area.selection\n        selection_start_row, selection_start_column = selection_start\n        selection_end_row, selection_end_column = selection_end\n\n        edit_result = text_area.document.replace_range(self.top, self.bottom, text)\n\n        new_edit_to_row, new_edit_to_column = edit_result.end_location\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n# Natural Language Annotations: \"\"\"Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    # Replace text at the given range.\n\n    # This is the only method by which a document may be updated.\n\n    # Args:\n    #     start: A tuple (row, column) where the edit starts.\n    #     end: A tuple (row, column) where the edit ends.\n    #     text: The text to insert between start and end.\n\n    # Returns:\n    #     The EditResult containing information about the completed\n    #     replace operation.\n\n    top, bottom = sorted((start, end))\n\n    edit_result = self.document.replace_range(top, bottom, text)\n\n    return edit_result\n```", "```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    top, bottom = sorted((start, end))\n    replaced_text = self.document.get_text_range(top, bottom)\n    edit_end = self.document.replace_range(top, bottom, text)\n    new_edit_to_row, new_edit_to_column = edit_end.end_location\n    return EditResult(start, new_edit_to_row, new_edit_to_column, replaced_text)\n```", "```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    top, bottom = sorted((start, end))\n    edit_result = self.replace(text, top, bottom, maintain_selection_offset=False)\n    return edit_result\n```"]}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n        top, bottom = sorted((start, end))\n------------------------------\n------------------------------\nArgs:\n            insert: The text to insert into the document.\n            start: The start location of the text to replace.\n            end: The end location of the text to replace.\n\n        Returns:\n            An EditResult or None if no edit was performed (e.g. on read-only mode).\n        \"\"\"\n        if self.read_only:\n            return None\n        return self.replace(insert, start, end, maintain_selection_offset=False)\n------------------------------\n------------------------------\nArgs:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def text(self) -> str:\n        \"\"\"The text from the document as a string.\"\"\"\n------------------------------\n------------------------------\nArgs:\n            start: The start location of the selection.\n            end: The end location of the selection.\n\n        Returns:\n            The text between start (inclusive) and end (exclusive).\n        \"\"\"\n        if start == end:\n            return \"\"\n------------------------------\n------------------------------\nArgs:\n            start: The start location.\n            end: The end location.\n\n        Returns:\n            The text between start and end.\n        \"\"\"\n        start, end = sorted((start, end))\n        return self.document.get_text_range(start, end)\n\n    def edit(self, edit: Edit) -> EditResult:\n        \"\"\"Perform an Edit.\n\n        Args:\n            edit: The Edit to perform.\n------------------------------\n------------------------------\ndef _delete_via_keyboard(\n        self,\n        start: Location,\n        end: Location,\n    ) -> EditResult | None:\n        \"\"\"Handle a deletion performed using a keyboard (as opposed to the API).\n\n        Args:\n            start: The start location of the text to delete.\n            end: The end location of the text to delete.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def wrap_range(\n# Natural Language Annotations: \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n        This must be called *after* the source document has been edited.\n\n        Args:\n            start: The start location of the edit that was performed in document-space.\n            old_end: The old end location of the edit in document-space.\n            new_end: The new end location of the edit in document-space.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef wrap_range(start: Location, old_end: Location, new_end: Location) -> None:\n    # Incrementally recompute wrapping based on a performed edit.\n\n    # This must be called *after* the source document has been edited.\n\n    # Args:\n    #     start: The start location of the edit that was performed in document-space.\n    #     old_end: The old end location of the edit in document-space.\n    #     new_end: The new end location of the edit in document-space.\n\n    # Compute the incremental change in wrapping based on the edit performed.\n    # Implementation details would depend on the specific wrapping algorithm being used.\n    pass\n```", "```python\ndef wrap_range(\n        self,\n        start: Location,\n        old_end: Location,\n        new_end: Location,\n):\n    # Incrementally recompute wrapping based on a performed edit.\n\n    # This must be called *after* the source document has been edited.\n\n    # Args:\n    #     start: The start location of the edit that was performed in document-space.\n    #     old_end: The old end location of the edit in document-space.\n    #     new_end: The new end location of the edit in document-space.\n\n    # TODO: Implement this function based on the provided arguments and logic\n    pass\n```", "```python\ndef wrap_range(\n    self,\n    start: Location,\n    old_end: Location,\n    new_end: Location,\n):\n    # Incrementally recompute wrapping based on a performed edit.\n    # This must be called *after* the source document has been edited.\n    # Args:\n    #     start: The start location of the edit that was performed in document-space.\n    #     old_end: The old end location of the edit in document-space.\n    #     new_end: The new end location of the edit in document-space.\n    pass\n```"]}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef location_to_offset(self, location: Location) -> Offset:\n        \"\"\"\n        Convert a location in the document to an offset within the wrapped/visual display of the document.\n\n        Args:\n            location: The location in the document.\n\n        Returns:\n            The Offset in the document's visual display corresponding to the given location.\n        \"\"\"\n        line_index, column_index = location\n------------------------------\n------------------------------\nArgs:\n             line_index: The index of the line in the document.\n             x_offset: The x-offset within the wrapped line.\n             y_offset: The y-offset within the wrapped line (supports negative indexing).\n\n        Returns:\n            The column index corresponding to the line index and y offset.\n        \"\"\"\n------------------------------\n------------------------------\nreturn target_location\n\n    def get_location_below(self, location: Location) -> Location:\n        \"\"\"Given a location in the raw document, return the raw document\n        location corresponding to moving down in the wrapped representation\n        of the document.\n\n        Args:\n            location: The location in the raw document.\n------------------------------\n------------------------------\nReturns:\n            The index in the document's text.\n        \"\"\"\n        row, column = location\n        index = row * len(self.newline) + column\n        for line_index in range(row):\n            index += len(self.get_line(line_index))\n        return index\n\n    def get_location_from_index(self, index: int) -> Location:\n        \"\"\"Given an index in the document's text, returns the corresponding location.\n\n        Args:\n            index: The index in the document's text.\n------------------------------\n------------------------------\nArgs:\n            line_index: The index of the line within the document.\n\n        Raises:\n            ValueError: When `line_index` is out of bounds.\n------------------------------\n------------------------------\nReturns:\n            The location corresponding to the end of the wrapped line.\n        \"\"\"\n        line_index, column_offset = location\n        wrap_offsets = self._wrapped_document.get_offsets(line_index)\n        if wrap_offsets:\n            # Get the next wrap offset to the right\n            next_offset_right = bisect(wrap_offsets, column_offset)\n            # There's no more wrapping to the right of this location - go to line end.\n------------------------------\n------------------------------\ndef get_target_document_column(\n        self,\n        line_index: int,\n        x_offset: int,\n        y_offset: int,\n    ) -> int:\n        \"\"\"Given a line index and the offsets within the wrapped version of that\n        line, return the corresponding column index in the raw document.\n------------------------------\n------------------------------\nReturns:\n            The offsets within the line where wrapping should occur.\n        \"\"\"\n        wrap_offsets = self._wrap_offsets\n        out_of_bounds = line_index < 0 or line_index >= len(wrap_offsets)\n        if out_of_bounds:\n            raise ValueError(\n                f\"The document line index {line_index!r} is out of bounds. \"\n                f\"The document contains {len(wrap_offsets)!r} lines.\"\n            )\n        return wrap_offsets[line_index]\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def offset_to_location(self, offset: Offset) -> Location:\n# Natural Language Annotations: \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\n    line_index = self._get_line_index_from_offset(offset)\n    y_offset = offset - self._get_line_offset(line_index)\n    x_offset = self._x_offset(y_offset, line_index)\n    return Location(line_index, x_offset, y_offset)\n\ndef _get_line_index_from_offset(self, offset: Offset) -> int:\n    cumulative_offset = 0\n    for i, line in enumerate(self._wrapped_document.lines):\n        cumulative_offset += len(line)\n        if cumulative_offset > offset:\n            return i - 1\n    raise ValueError(\"The given offset does not correspond to a line in the document.\")\n\ndef _get_line_offset(self, line_index: int) -> int:\n    return sum(len(line) for line in self._wrapped_document.lines[:line_index])\n\ndef _x_offset(self, y_offset: int, line_index: int) -> int:\n    wrap_offsets = self._wrapped_document.get_offsets(line_index)\n    if wrap_offsets:\n        # Get the next wrap offset to the right\n        next_offset_right = bisect(wrap_offsets, y_offset)\n        # There's no more wrapping to the right of this location - go to line end.\n        if next_offset_right == len(wrap_offsets):\n            return len(self._wrapped_document.get_line(line_index))\n        return y_offset - wrap_offsets[next_offset_right - 1]\n    return y_offset\n```", "```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    line_index, y_offset = offset\n    if line_index < 0 or line_index >= len(self._wrapped_document):\n        raise ValueError(\n            f\"The document line index {line_index} is out of bounds. \"\n            f\"The document contains {len(self._wrapped_document)} lines.\"\n        )\n    return (line_index, y_offset)\n```", "```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    line_index, column_offset = offset\n    wrap_offsets = self._wrapped_document.get_offsets(line_index)\n    if wrap_offsets:\n        # Get the next wrap offset to the right\n        next_offset_right = bisect(wrap_offsets, column_offset)\n        # There's no more wrapping to the right of this location - go to line end.\n        if next_offset_right >= len(wrap_offsets):\n            column_index = len(self._wrapped_document.get_line(line_index))\n        else:\n            column_index = wrap_offsets[next_offset_right]\n    else:\n        column_index = column_offset\n    return (line_index, column_index)\n```"]}, "textual-src/textual/css/parse.py-substitute_references": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef with_reference(self, by: ReferencedBy | None) -> \"Token\":\n        \"\"\"Return a copy of the Token, with reference information attached.\n        This is used for variable substitution, where a variable reference\n        can refer to tokens which were defined elsewhere. With the additional\n        ReferencedBy data attached, we can track where the token we are referring\n        to is used.\n        \"\"\"\n        return Token(\n            name=self.name,\n            value=self.value,\n------------------------------\n------------------------------\ntokens = declaration.tokens\n\n        important = tokens[-1].name == \"important\"\n        if important:\n            tokens = tokens[:-1]\n            self.styles.important.add(rule_name)\n------------------------------\n------------------------------\ndef _unresolved(variable_name: str, variables: Iterable[str], token: Token) -> NoReturn:\n    \"\"\"Raise a TokenError regarding an unresolved variable.\n\n    Args:\n        variable_name: A variable name.\n        variables: Possible choices used to generate suggestion.\n        token: The Token.\n------------------------------\n------------------------------\ndef get_token(self, expect: Expect) -> Token:\n        \"\"\"Get the next token.\n\n        Args:\n            expect: Expect object which describes which tokens may be read.\n\n        Raises:\n            EOFError: If there is an unexpected end of file.\n            TokenError: If there is an error with the token.\n\n        Returns:\n            A new Token.\n        \"\"\"\n------------------------------\n------------------------------\ndef tokenize_values(values: dict[str, str]) -> dict[str, list[Token]]:\n    \"\"\"Tokenizes the values in a dict of strings.\n\n    Args:\n        values: A mapping of CSS variable name on to a value, to be\n            added to the CSS context.\n\n    Returns:\n        A mapping of name on to a list of tokens,\n    \"\"\"\n    value_tokens = {\n        name: list(tokenize_value(value, (\"__name__\", \"\")))\n        for name, value in values.items()\n    }\n    return value_tokens\n------------------------------\n------------------------------\nReturns:\n            A Rich Text object.\n        \"\"\"\n        tokens = Text.styled(self.__class__.__name__)\n        if self.id is not None:\n            tokens.append(f\"#{self.id}\", style=\"bold\")\n        if self.classes:\n            tokens.append(\".\")\n            tokens.append(\".\".join(class_name for class_name in self.classes), \"italic\")\n        if self.name:\n            tokens.append(f\"[name={self.name}]\", style=\"underline\")\n        return tokens\n------------------------------\n------------------------------\ndef __rich_repr__(self) -> rich.repr.Result:\n        yield list(self.source.keys())\n\n    @property\n    def _variable_tokens(self) -> dict[str, list[Token]]:\n        if self.__variable_tokens is None:\n            self.__variable_tokens = tokenize_values(self._variables)\n        return self.__variable_tokens\n\n    @property\n    def rules(self) -> list[RuleSet]:\n        \"\"\"List of rule sets.\n------------------------------\n------------------------------\nArgs:\n                tokens: List of tokens\n\n            Yields:\n                Widgets for mounting.\n            \"\"\"\n\n            stack: list[MarkdownBlock] = []\n            stack_append = stack.append\n            block_id: int = 0\n------------------------------\n------------------------------\nwhile tokens:\n                yield popleft()\n\n    def parse(\n        self, on_token: ByteStreamTokenCallback\n    ) -> Generator[Awaitable, bytes, None]:\n        \"\"\"Implement in a sub-class to define parse behavior.\n\n        Args:\n            on_token: A callable which accepts the token type, and returns None.\n\n        \"\"\"\n        yield from ()\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def substitute_references(\n# Natural Language Annotations: \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            value_tokens = tokenize_value(token.value, (\"__name__\", \"\"))\n            for value_token in value_tokens:\n                yield value_token.with_reference(by=token)\n        else:\n            yield token\n```", "```python\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            variable_value_tokens = variable_ref_to_value_tokens(token)\n            for value_token in variable_value_tokens:\n                yield value_token.with_reference(token)\n        else:\n            yield token\n```", "```python\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            value_tokens = values[token.value]\n            for value_token in value_tokens:\n                value_token.referenced_by.add(token.referenced_by)\n                yield value_token\n        else:\n            yield token\n```"]}, "textual-src/textual/css/parse.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n------------------------------\n------------------------------\ndef parse_declarations(css: str, read_from: CSSLocation) -> Styles:\n    \"\"\"Parse declarations and return a Styles object.\n\n    Args:\n        css: String containing CSS.\n        read_from: The location where the CSS was read from.\n\n    Returns:\n        A styles object.\n    \"\"\"\n\n    tokens = iter(tokenize_declarations(css, read_from))\n    styles_builder = StylesBuilder()\n------------------------------\n------------------------------\nArgs:\n            specificity: A node specificity.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n------------------------------\n------------------------------\ndef add_source(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_css: bool = False,\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n------------------------------\n------------------------------\nclass CssSource(NamedTuple):\n    \"\"\"Contains the CSS content and whether or not the CSS comes from user defined stylesheets\n    vs widget-level stylesheets.\n\n    Args:\n        content: The CSS as a string.\n        is_defaults: True if the CSS is default (i.e. that defined at the widget level).\n            False if it's user CSS (which will override the defaults).\n        tie_breaker: Specificity tie breaker.\n        scope: Scope of CSS.\n    \"\"\"\n------------------------------\n------------------------------\nArgs:\n            css: Textual CSS.\n            read_from: Location where the CSS was read from.\n            node: Node to associate with the Styles.\n\n        Returns:\n            A Styles instance containing result of parsing CSS.\n        \"\"\"\n        from .parse import parse_declarations\n\n        styles = parse_declarations(css, read_from)\n        styles.node = node\n        return styles\n\n    def _get_transition(self, key: str) -> Transition | None:\n        \"\"\"Get a transition.\n------------------------------\n------------------------------\ndef extract_rules(\n        self,\n        specificity: Specificity3,\n        is_default_rules: bool = False,\n        tie_breaker: int = 0,\n    ) -> list[tuple[str, Specificity6, Any]]:\n        \"\"\"Extract rules from Styles object, and apply !important css specificity as\n        well as higher specificity of user CSS vs widget CSS.\n------------------------------\n------------------------------\n)\n            return\n        self.source[read_from] = CssSource(css, is_default_css, tie_breaker, scope)\n        self._require_parse = True\n        self._rules_map = None\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(\n# Natural Language Annotations: \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse(\n        scope: str,\n        css: str,\n        read_from: str,\n        variables: dict[str, str],\n        is_default_rules: bool = False,\n) -> list[tuple[str, Specificity6, Any]]:\n    \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n    # Tokenize the CSS\n    tokens = tokenize_declarations(css, read_from)\n\n    # Perform variable substitution\n    for var, value in variables.items():\n        css = css.replace(var, value)\n\n    # Generate rule sets\n    rules = []\n    for token in tokens:\n        # Generate rule set\n        rule = generate_rule_set(token, scope)\n        rules.append(rule)\n\n    return rules\n```", "```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation,\n    variables: dict[str, str],\n    is_default_rules: bool = False,\n) -> list[tuple[str, Specificity3, Any]]:\n    tokens = iter(tokenize_declarations(css, read_from))\n    styles_builder = StylesBuilder()\n    styles_builder.add_source(css, read_from, is_default_css=is_default_rules)\n    styles = styles_builder.generate_styles(scope)\n    return styles.rules\n```", "```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation,\n    variables: dict[str, str],\n    is_default_rules: bool = False,\n) -> list[tuple[str, CSSLocation, Any]]:\n    tokens = iter(tokenize_declarations(css, read_from))\n    styles_builder = StylesBuilder()\n\n    # Token substitution\n    for token in tokens:\n        if token in variables:\n            token = variables[token]\n\n    # Generate rule sets\n    rule_sets = []\n    for rule in styles_builder.rules:\n        rule_sets.append((rule.selector, read_from, rule.declarations))\n\n    return rule_sets\n```"]}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nArgs:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n------------------------------\n------------------------------\nArgs:\n            specificity: A node specificity.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n------------------------------\n------------------------------\nArgs:\n            css: Textual CSS.\n            read_from: Location where the CSS was read from.\n            node: Node to associate with the Styles.\n\n        Returns:\n            A Styles instance containing result of parsing CSS.\n        \"\"\"\n        from .parse import parse_declarations\n\n        styles = parse_declarations(css, read_from)\n        styles.node = node\n        return styles\n\n    def _get_transition(self, key: str) -> Transition | None:\n        \"\"\"Get a transition.\n------------------------------\n------------------------------\nclass CssSource(NamedTuple):\n    \"\"\"Contains the CSS content and whether or not the CSS comes from user defined stylesheets\n    vs widget-level stylesheets.\n\n    Args:\n        content: The CSS as a string.\n        is_defaults: True if the CSS is default (i.e. that defined at the widget level).\n            False if it's user CSS (which will override the defaults).\n        tie_breaker: Specificity tie breaker.\n        scope: Scope of CSS.\n    \"\"\"\n------------------------------\n------------------------------\ndef parse_declarations(css: str, read_from: CSSLocation) -> Styles:\n    \"\"\"Parse declarations and return a Styles object.\n\n    Args:\n        css: String containing CSS.\n        read_from: The location where the CSS was read from.\n\n    Returns:\n        A styles object.\n    \"\"\"\n\n    tokens = iter(tokenize_declarations(css, read_from))\n    styles_builder = StylesBuilder()\n------------------------------\n------------------------------\n)\n            return\n        self.source[read_from] = CssSource(css, is_default_css, tie_breaker, scope)\n        self._require_parse = True\n        self._rules_map = None\n------------------------------\n------------------------------\ndef add_source(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_css: bool = False,\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _parse_rules(\n# Natural Language Annotations: \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef _parse_rules(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_rules: bool = False,\n        scope: str = \"\",\n    ) -> List[RuleSet]:\n        \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\n\n        tokens = iter(tokenize_rules(css, read_from))\n        rules = []\n        while True:\n            try:\n                rule = parse_rule(tokens)\n                if rule:\n                    rule.is_default_rules = is_default_rules\n                    rule.scope = scope\n                    rules.append(rule)\n            except StopIteration:\n                break\n        return rules\n```", "```python\ndef _parse_rules(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_rules: bool = False,\n        scope: str = \"\",\n    ) -> list[RuleSet]:\n        \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\n        from .parse import parse_declarations\n\n        declarations = parse_declarations(css, read_from)\n        rule_sets = []\n\n        for declaration in declarations:\n            selectors = declaration.selectors\n            declarations = declaration.declarations\n\n            for selector in selectors:\n                rule_set = RuleSet(selector, declarations, is_default_rules, scope)\n                rule_sets.append(rule_set)\n\n        return rule_sets\n```", "```python\ndef _parse_rules(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_rules: bool = False,\n        scope: str = \"\",\n    ) -> List[RuleSet]:\n        \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\n        tokens = iter(tokenize_declarations(css, read_from))\n        rules_builder = RuleSetBuilder()\n        # Add your logic here to parse the CSS and return rules.\n```"]}, "textual-src/textual/css/stylesheet.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nRaises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n        # Do this in a fresh Stylesheet so if there are errors we don't break self.\n        stylesheet = Stylesheet(variables=self._variables)\n        for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n            stylesheet.add_source(\n                css,\n                read_from=read_from,\n------------------------------\n------------------------------\nRaises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n        if read_from is None:\n            read_from = (\"\", str(hash(css)))\n------------------------------\n------------------------------\nRaises:\n            TabError: If there are any issues with the request.\n        \"\"\"\n        return super().show(ContentTab.add_prefix(tab_id))\n------------------------------\n------------------------------\ndef has_source(self, path: str, class_var: str = \"\") -> bool:\n        \"\"\"Check if the stylesheet has this CSS source already.\n\n        Args:\n            path: The file path of the source in question.\n            class_var: The widget class variable we might be reading the CSS from.\n\n        Returns:\n            Whether the stylesheet is aware of this CSS source or not.\n        \"\"\"\n        return (path, class_var) in self.source\n------------------------------\n------------------------------\nRaises:\n            Tabs.TabError: If there are any issues with the request.\n        \"\"\"\n\n        self.get_child_by_type(ContentTabs).disable(tab_id)\n\n    def enable_tab(self, tab_id: str) -> None:\n        \"\"\"Enables the tab with the given ID.\n\n        Args:\n            tab_id: The ID of the [`TabPane`][textual.widgets.TabPane] to enable.\n\n        Raises:\n            Tabs.TabError: If there are any issues with the request.\n        \"\"\"\n------------------------------\n------------------------------\nclass StylesheetParseError(StylesheetError):\n    \"\"\"Raised when the stylesheet could not be parsed.\"\"\"\n\n    def __init__(self, errors: StylesheetErrors) -> None:\n        self.errors = errors\n\n    def __rich__(self) -> RenderableType:\n        return self.errors\n------------------------------\n------------------------------\nArgs:\n            tab_id: The ID of the [`TabPane`][textual.widgets.TabPane] to show.\n\n        Raises:\n            Tabs.TabError: If there are any issues with the request.\n        \"\"\"\n\n        self.get_child_by_type(ContentTabs).show(tab_id)\n------------------------------\n------------------------------\nRaises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n        filename = os.path.expanduser(filename)\n        try:\n            with open(filename, \"rt\") as css_file:\n                css = css_file.read()\n            path = os.path.abspath(filename)\n        except Exception:\n            raise StylesheetError(f\"unable to read CSS file {filename!r}\") from None\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(self) -> None:\n# Natural Language Annotations: \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    errors = []\n    for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n        try:\n            self.stylesheet.add_source(\n                css,\n                read_from=read_from,\n                is_defaults=is_defaults,\n                tie_breaker=tie_breaker,\n                scope=scope,\n            )\n        except StylesheetParseError as parse_error:\n            errors.append(parse_error)\n\n    if errors:\n        raise StylesheetParseError(errors)\n```", "```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    errors = StylesheetErrors()\n    for read_from, (css, is_defaults, tie_breaker, scope) in self.source.items():\n        try:\n            parsed_css = parse_css(css)\n            stylesheet.add_parsed_source(\n                parsed_css,\n                read_from=read_from,\n                is_defaults=is_defaults,\n                tie_breaker=tie_breaker,\n                scope=scope,\n            )\n        except ParserError as error:\n            errors.add_error(\n                read_from,\n                str(error),\n                style=Errors.PARSER_ERROR if is_defaults else Errors.DEFAULT_PARSER_ERROR,\n            )\n    if errors:\n        raise StylesheetParseError(errors)\n```", "```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    errors = StylesheetErrors()\n    for (css, is_defaults, tie_breaker, scope), read_from in self.source.items():\n        try:\n            stylesheet.add_source(\n                css,\n                read_from=read_from,\n            )\n        except (StylesheetError, StylesheetParseError) as e:\n            errors.append(e)\n\n    if errors:\n        raise StylesheetParseError(errors)\n```"]}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n- parse_diffs: Parses a string containing diffs in the unified git diff format, extracting the changes described\n  in the diffs and organizing them into a dictionary of Diff objects, keyed by the filename to which each diff applies.\n\n- parse_diff_block: Parses a single block of text from a diff string, translating it into a Diff object that\n  represents the changes described in that block of text.\n------------------------------\n------------------------------\ndef parse_diff_block(diff_block: str) -> dict:\n    \"\"\"\n    Parses a block of diff text into a Diff object.\n\n    Args:\n    - diff_block (str): A single block of diff text.\n------------------------------\n------------------------------\nReturns:\n    - dict: A dictionary containing a single Diff object keyed by the post-edit filename.\n    \"\"\"\n    lines = diff_block.strip().split(\"\\n\")[1:-1]  # Exclude the opening and closing ```\n    diffs = {}\n    current_diff = None\n    hunk_lines = []\n    filename_pre = None\n    filename_post = None\n    hunk_header = None\n------------------------------\n------------------------------\ndef apply_diffs(diffs: Dict[str, Diff], files: FilesDict) -> FilesDict:\n    \"\"\"\n    Applies diffs to the provided files.\n\n    Args:\n    - diffs (Dict[str, Diff]): A dictionary of diffs to apply, keyed by filename.\n    - files (FilesDict): The original files to which diffs will be applied.\n------------------------------\n------------------------------\ndef parse_hunk_header(header_line) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Parses the header of a hunk from a diff.\n\n    Args:\n    - header_line (str): The header line of a hunk.\n\n    Returns:\n    - tuple: A tuple containing start and length information for pre- and post-edit.\n    \"\"\"\n    pattern = re.compile(r\"^@@ -\\d{1,},\\d{1,} \\+\\d{1,},\\d{1,} @@$\")\n------------------------------\n------------------------------\n\"\"\"\nThis Python script provides functionalities for parsing chat transcripts that contain file paths and code blocks,\napplying diffs to these files, and parsing unified git diff format strings. The script is designed to work within\na larger system that involves processing and manipulating code files based on chat inputs and diff information.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_diffs(diff_string: str) -> dict:\n# Natural Language Annotations: \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef parse_diffs(diff_string: str) -> dict:\n    diff_blocks = diff_string.split(\"diff --git\")\n    diffs = {}\n    for diff_block in diff_blocks:\n        if not diff_block:\n            continue\n        diff_dict = parse_diff_block(diff_block)\n        diffs.update(diff_dict)\n    return diffs\n```", "```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diff_blocks = diff_string.split(\"diff --git\")\n    diffs = {}\n    for diff_block in diff_blocks:\n        if diff_block.strip():\n            diffs.update(parse_diff_block(diff_block))\n    return diffs\n```", "```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diff_blocks = diff_string.split(\"diff --git\")\n    diffs = {}\n    for diff_block in diff_blocks:\n        if diff_block:\n            diffs.update(parse_diff_block(diff_block))\n    return diffs\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nMethods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n------------------------------\n------------------------------\nlogger.debug(f\"Using model {self.model_name}\")\n\n    def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n        \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n------------------------------\n------------------------------\nParameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\n\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n------------------------------\n------------------------------\nReturns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\n\n        messages: List[Message] = [\n            SystemMessage(content=system),\n            HumanMessage(content=user),\n        ]\n        return self.next(messages, step_name=step_name)\n------------------------------\n------------------------------\nParameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        answer : str\n            The answer from the AI.\n        step_name : str\n            The name of the step.\n        \"\"\"\n        prompt_tokens = self._tokenizer.num_tokens_from_messages(messages)\n        completion_tokens = self._tokenizer.num_tokens(answer)\n        total_tokens = prompt_tokens + completion_tokens\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n# Natural Language Annotations: \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    logger.debug(f\"Using model {self.model_name}\")\n\n    messages: List[Message] = [\n        SystemMessage(content=system),\n        HumanMessage(content=user),\n    ]\n    return self.next(messages, step_name=step_name)\n```", "```python\ndef start(self, system: str, user: str, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    logger.debug(f\"Using model {self.model_name}\")\n\n    messages = [\n        SystemMessage(content=system),\n        HumanMessage(content=user),\n    ]\n\n    return self.next(messages, step_name=step_name)\n```", "```python\ndef start(self, system: str, user: str, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n\n    logger.debug(f\"Using model {self.model_name}\")\n\n    messages: List[Message] = [\n        SystemMessage(content=system),\n        HumanMessage(content=user),\n    ]\n    return self.next(messages, step_name=step_name)\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nMethods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n------------------------------\n------------------------------\nParameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\n\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n------------------------------\n------------------------------\ncollapsed_messages.append(previous_message.__class__(content=combined_content))\n        return collapsed_messages\n\n    def next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n------------------------------\n------------------------------\nParameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        answer : str\n            The answer from the AI.\n        step_name : str\n            The name of the step.\n        \"\"\"\n        prompt_tokens = self._tokenizer.num_tokens_from_messages(messages)\n        completion_tokens = self._tokenizer.num_tokens(answer)\n        total_tokens = prompt_tokens + completion_tokens\n------------------------------\n------------------------------\nReturns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\n\n        messages: List[Message] = [\n            SystemMessage(content=system),\n            HumanMessage(content=user),\n        ]\n        return self.next(messages, step_name=step_name)\n------------------------------\n------------------------------\ndef next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        \"\"\"\n        Not yet fully supported\n        \"\"\"\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n\n        logger.debug(f\"Creating a new chat completion: {messages}\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def next(\n# Natural Language Annotations: \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n\n        logger.debug(f\"Creating a new chat completion: {messages}\")\n```", "```python\ndef next(\n    self,\n    messages: List[Message],\n    prompt: Optional[str] = None,\n    *,\n    step_name: str,\n) -> List[Message]:\n    \"\"\"\n    Advances the conversation by sending message history\n    to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    if prompt:\n        messages.append(HumanMessage(content=prompt))\n\n    logger.debug(f\"Creating a new chat completion: {messages}\")\n```", "```python\ndef next(\n        self,\n        messages: List[Message],\n        prompt: Optional[str] = None,\n        *,\n        step_name: str,\n    ) -> List[Message]:\n        if prompt:\n            messages.append(HumanMessage(content=prompt))\n\n        logger.debug(f\"Creating a new chat completion: {messages}\")\n\n        # Call the LLM with the updated messages\n        response = self.backoff_inference(messages)\n\n        # Update the messages with the response\n        messages.append(AIMessage(content=response))\n\n        return messages\n```"]}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"\nFunctions for reading and writing the `gpt-engineer.toml` configuration file.\n\nThe `gpt-engineer.toml` file is a TOML file that contains project-specific configuration used by the GPT Engineer CLI and gptengineer.app.\n\"\"\"\nfrom dataclasses import asdict, dataclass, field\nfrom pathlib import Path\n\nimport tomlkit\n\ndefault_config_filename = \"gpt-engineer.toml\"\n\nexample_config = \"\"\"\n[run]\nbuild = \"npm run build\"\ntest = \"npm run test\"\nlint = \"quick-lint-js\"\n------------------------------\n------------------------------\nif os.getenv(\"GPTE_TEST_MODE\"):\n            # In test mode, retrieve files from a predefined TOML configuration\n            assert self.FILE_LIST_NAME in self.metadata_db\n            selected_files = self.get_files_from_toml(self.project_path, self.toml_path)\n        else:\n            # Otherwise, use the editor file selector for interactive selection\n            if self.FILE_LIST_NAME in self.metadata_db:\n                print(\n------------------------------\n------------------------------\n# Code for: def read_config(config_file: Path) -> tomlkit.TOMLDocument:\n------------------------------\n------------------------------\ndef is_new_file(self) -> bool:\n        \"\"\"Determines if the diff represents a new file.\"\"\"\n        if self.filename_pre == \"/dev/null\":\n            return True\n        return any(hunk.is_new_file for hunk in self.hunks)\n------------------------------\n------------------------------\n@classmethod\n    def from_toml(cls, config_file: Path | str):\n        if isinstance(config_file, str):\n            config_file = Path(config_file)\n        config_dict = read_config(config_file)\n        return cls.from_dict(config_dict)\n------------------------------\n------------------------------\ndef get_agent(path):\n    \"\"\"\n    Dynamically imports and returns the default configuration agent from the given path.\n\n    Parameters\n    ----------\n    path : str\n        The file path to the module containing the default configuration agent.\n------------------------------\n------------------------------\n# add comments on all lines that match = \"selected\"\n            s = \"\\n\".join(\n                [\n                    \"# \" + line if line.endswith(' = \"selected\"') else line\n                    for line in s.split(\"\\n\")\n                ]\n            )\n            # Write to the toml file\n            with open(toml_file, \"w\") as f:\n                f.write(self.COMMENT)\n                f.write(self.LINTING_STRING)\n                f.write(s)\n------------------------------\n------------------------------\ndef ask_for_files(self) -> tuple[FilesDict, bool]:\n        \"\"\"\n        Prompts the user to select files for context improvement.\n\n        This method supports selection from the terminal or using a previously saved list.\n        In test mode, it retrieves files from a predefined TOML configuration.\n\n        Returns\n        -------\n        FilesDict\n            A dictionary with file paths as keys and file contents as values.\n        \"\"\"\n------------------------------\n------------------------------\ndef get_files_from_toml(\n        self, input_path: Union[str, Path], toml_file: Union[str, Path]\n    ) -> List[str]:\n        \"\"\"\n        Retrieves a list of selected files from a .toml configuration file.\n\n        Parameters\n        ----------\n        input_path : Union[str, Path]\n            The path where file selection was performed.\n        toml_file : Union[str, Path]\n            The path to the .toml file containing the file selection.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_toml(self, config_file: Path | str, save=True) -> str:\n# Natural Language Annotations: \"\"\"Write the configuration to a TOML file.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n    config_dict = asdict(self)\n    toml_doc = tomlkit.document()\n    toml_doc.update(config_dict)\n    toml_string = tomlkit.dumps(toml_doc)\n    if save:\n        with open(config_file, \"w\") as f:\n            f.write(toml_string)\n    return toml_string\n```", "```python\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n    config_dict = asdict(self)\n    toml_config = tomlkit.document()\n    for key, value in config_dict.items():\n        toml_config[key] = value\n    if save:\n        with open(config_file, \"w\") as f:\n            tomlkit.dump(toml_config, f)\n    return tomlkit.dumps(toml_config)\n```", "```python\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n\n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n\n    config_dict = asdict(self)\n    toml_doc = tomlkit.document()\n    toml_doc.update(config_dict)\n\n    if save:\n        with open(config_file, \"w\") as f:\n            f.write(tomlkit.dumps(toml_doc))\n\n    return tomlkit.dumps(toml_doc)\n```"]}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\ndef count_ratio(str1, str2) -> float:\n    \"\"\"\n    Computes the ratio of common characters to the length of the longer string, ignoring spaces and case.\n\n    Parameters:\n    - str1, str2 (str): The strings to compare.\n\n    Returns:\n    - float: The ratio of common characters to the length of the longer string.\n    \"\"\"\n    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n------------------------------\n------------------------------\n4. Utility functions `is_similar` and `count_ratio` offer the capability to compare strings for similarity, accounting for variations in spacing and case. This aids in the validation process by allowing a flexible comparison of code lines.\n\nDependencies:\n------------------------------\n------------------------------\nParameters\n        ----------\n        file_path : Union[str, Path]\n            The path to the file to be checked.\n\n        Returns\n        -------\n        bool\n            True if the file is UTF-8 encoded, False otherwise.\n        \"\"\"\n\n        try:\n            with open(file_path, \"rb\") as file:\n                file.read().decode(\"utf-8\")\n                return True\n        except UnicodeDecodeError:\n            return False\n------------------------------\n------------------------------\ndef ask_yes_no(question: str) -> bool:\n    \"\"\"\n    Asks a yes/no question and returns the response as a boolean value.\n\n    Parameters\n    ----------\n    question : str\n        The yes/no question to ask.\n\n    Returns\n    -------\n    bool\n        True if the answer is 'yes', False if 'no'.\n\n    \"\"\"\n------------------------------\n------------------------------\nParameters\n        ----------\n        input_path : Union[str, Path]\n            The path where file selection is to be performed.\n        init : bool, optional\n            Indicates whether to initialize the .toml file with the file tree.\n\n        Returns\n        -------\n        List[str]\n            A list of strings representing the paths of selected files.\n        \"\"\"\n------------------------------\n------------------------------\n2. `Diff`: Class representing the entire set of changes in a file, containing multiple `Hunk` instances and methods for overall diff management.\n\n3. `is_similar(str1, str2, similarity_threshold)`: Function to compare two strings for similarity, useful in validating line changes in hunks.\n\n4. `count_ratio(str1, str2)`: Function that computes the ratio of common characters to the length of the longer string, aiding in the assessment of line similarity.\n------------------------------\n------------------------------\nRaises\n        ------\n        TypeError\n            If the key is not a string or Path, or if the value is not a string.\n        \"\"\"\n        if not isinstance(key, (str, Path)):\n            raise TypeError(\"Keys must be strings or Path's\")\n        if not isinstance(value, str):\n            raise TypeError(\"Values must be strings\")\n        super().__setitem__(key, value)\n------------------------------\n------------------------------\n\"\"\"\n\n    while True:\n        response = input(question + \" (y/n): \").lower().strip()\n        if response == \"y\":\n            return True\n        elif response == \"n\":\n            return False\n        else:\n            print(\"Please enter either 'y' or 'n'.\")\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n# Natural Language Annotations: \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n    common_chars = sum(el1 == el2 for el1, el2 in zip(str1, str2))\n    similarity_ratio = common_chars / max(len(str1), len(str2))\n    return similarity_ratio >= similarity_threshold\n```", "```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n    common_chars = sum(el1 == el2 for el1, el2 in zip(str1, str2))\n    similarity_ratio = common_chars / max(len(str1), len(str2))\n    return similarity_ratio >= similarity_threshold\n```", "```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1, str2 = str1.replace(\" \", \"\").lower(), str2.replace(\" \", \"\").lower()\n    common_chars = sum(el1 == el2 for el1, el2 in zip(str1, str2))\n    similarity_ratio = common_chars / max(len(str1), len(str2))\n    return similarity_ratio >= similarity_threshold\n```"]}}