{"langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Loads matching {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param pathMatcher    Only files whose paths match the provided {@link PathMatcher} will be loaded.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directoryPath)) {\n        for (Path path : directoryStream) {\n            if (Files.isRegularFile(path)) {\n                try {\n                    String text = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n                    Document document = documentParser.parse(text);\n                    documents.add(document);\n                } catch (IOException e) {\n                    // Skip this file\n                }\n            }\n        }\n    } catch (IOException e) {\n        // Handle exception\n    }\n\n    return documents;\n}\n```\n", "```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path filePath : stream) {\n            if (!Files.isRegularFile(filePath)) {\n                continue;\n            }\n\n            String content = new String(Files.readAllBytes(filePath), StandardCharsets.UTF_8);\n            Document document = documentParser.parseDocument(content);\n            if (document != null) {\n                documents.add(document);\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return documents;\n}\n```\n", "```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directoryPath)) {\n        for (Path path : directoryStream) {\n            if (Files.isRegularFile(path)) {\n                String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n                Document document = documentParser.parse(content);\n                if (document != null) {\n                    documents.add(document);\n                }\n            }\n        }\n    } catch (IOException e) {\n        // Handle IOException\n    }\n\n    return documents;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n------------------------------\n------------------------------\n/**\n     * Recursively loads matching {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param pathMatcher    Only files whose paths match the provided {@link PathMatcher} will be loaded.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) throws IllegalArgumentException {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directoryPath)) {\n        for (Path path : directoryStream) {\n            if (Files.isDirectory(path)) {\n                documents.addAll(loadDocumentsRecursively(path, documentParser));\n            } else {\n                try {\n                    Document document = documentParser.parse(path);\n                    documents.add(document);\n                } catch (Exception e) {\n                    // Skip this document\n                }\n            }\n        }\n    } catch (IOException e) {\n        // Handle exception\n    }\n\n    return documents;\n}\n```\n", "```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (DirectoryStream<Path> directoryStream = Files.newDirectoryStream(directoryPath)) {\n        for (Path path : directoryStream) {\n            if (Files.isDirectory(path)) {\n                documents.addAll(loadDocumentsRecursively(path, documentParser));\n            } else {\n                try {\n                    String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n                    Document document = documentParser.parse(content);\n                    documents.add(document);\n                } catch (IOException e) {\n                    // Skip file\n                }\n            }\n        }\n    } catch (IOException e) {\n        // Handle exception\n    }\n\n    return documents;\n}\n```\n", "```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    List<Document> documents = new ArrayList<>();\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory.\");\n    }\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path path : stream) {\n            if (Files.isDirectory(path)) {\n                documents.addAll(loadDocumentsRecursively(path, documentParser));\n            } else {\n                try {\n                    String content = new String(Files.readAllBytes(path), StandardCharsets.UTF_8);\n                    Document document = documentParser.parse(content);\n                    documents.add(document);\n                } catch (IOException e) {\n                    // Skip this file\n                }\n            }\n        }\n    } catch (IOException e) {\n        // Handle exception\n    }\n    return documents;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns the current size of the segment (as returned by the {@code sizeFunction}).\n     * @return The current size of the segment.\n     */\n    public int getSize() {\n        return segmentSize;\n    }\n\n    /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\n------------------------------\n------------------------------\n/**\n     * Returns {@code true} if the provided size can be added to the current segment.\n     * @param size The size to check.\n     * @return {@code true} if the provided size can be added to the current segment.\n     */\n    public boolean hasSpaceFor(int size) {\n        int totalSize = size;\n        if (isNotEmpty()) {\n            totalSize += segmentSize + joinSeparatorSize;\n        }\n        return totalSize <= maxSegmentSize;\n    }\n------------------------------\n------------------------------\n/**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Returns {@code true} if the current segment is not empty.\n     * @return {@code true} if the current segment is not empty.\n     */\n    public boolean isNotEmpty() {\n        return !segment.isEmpty();\n    }\n\n    @Override\n    public String toString() {\n        return segment.trim();\n    }\n------------------------------\n------------------------------\n/**\n     * Returns the size of the provided text (as returned by the {@code sizeFunction}).\n     * @param text The text to check.\n     * @return The size of the provided text.\n     */\n    public int sizeOf(String text) {\n        return sizeFunction.apply(text);\n    }\n\n    /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\n------------------------------\n------------------------------\n/**\n     * Moderates the given text segment.\n     * @param textSegment the text segment to moderate.\n     * @return the moderation {@code Response}.\n     */\n    default Response<Moderation> moderate(TextSegment textSegment) {\n        return moderate(textSegment.text());\n    }\n}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public boolean hasSpaceFor(String text) {\n# Natural Language Annotations: /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic boolean hasSpaceFor(String text) {\n    int size = sizeOf(text);\n    int totalSize = size;\n    if (isNotEmpty()) {\n        totalSize += segmentSize + joinSeparatorSize;\n    }\n    return totalSize <= maxSegmentSize;\n}\n```\n", "```java\npublic boolean hasSpaceFor(String text) {\n    int size = sizeOf(text);\n    int totalSize = size;\n    if (isNotEmpty()) {\n        totalSize += segmentSize + joinSeparatorSize;\n    }\n    return totalSize <= maxSegmentSize;\n}\n```\n", "```java\npublic boolean hasSpaceFor(String text) {\n    int size = sizeOf(text);\n    return hasSpaceFor(size);\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns the size of the provided text (as returned by the {@code sizeFunction}).\n     * @param text The text to check.\n     * @return The size of the provided text.\n     */\n    public int sizeOf(String text) {\n        return sizeFunction.apply(text);\n    }\n\n    /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\n------------------------------\n------------------------------\n/**\n     * Returns the current size of the segment (as returned by the {@code sizeFunction}).\n     * @return The current size of the segment.\n     */\n    public int getSize() {\n        return segmentSize;\n    }\n\n    /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\n------------------------------\n------------------------------\n/**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Returns {@code true} if the current segment is not empty.\n     * @return {@code true} if the current segment is not empty.\n     */\n    public boolean isNotEmpty() {\n        return !segment.isEmpty();\n    }\n\n    @Override\n    public String toString() {\n        return segment.trim();\n    }\n------------------------------\n------------------------------\n/**\n     * Creates a new text segment.\n     *\n     * @param text     the text.\n     * @param metadata the metadata.\n     * @return the text segment.\n     */\n    public static TextSegment from(String text, Metadata metadata) {\n        return new TextSegment(text, metadata);\n    }\n\n    /**\n     * Creates a new text segment.\n     *\n     * @param text the text.\n     * @return the text segment.\n     */\n    public static TextSegment textSegment(String text) {\n        return from(text);\n    }\n------------------------------\n------------------------------\n/**\n     * Splits the provided text into parts.\n     * Implementation API.\n     * @param text The text to be split.\n     * @return An array of parts.\n     */\n    protected abstract String[] split(String text);\n\n    /**\n     * Delimiter string to use to re-join the parts.\n     * @return The delimiter.\n     */\n    protected abstract String joinDelimiter();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void append(String text) {\n# Natural Language Annotations: /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void append(String text) {\n    segment.append(text);\n    segmentSize += sizeOf(text);\n}\n```\n", "```java\npublic void append(String text) {\n    if (sizeOf(text) + segmentSize <= maxSize) {\n        segment.append(joinDelimiter()).append(text);\n        segmentSize += sizeOf(text);\n    }\n}\n```\n", "```java\npublic void append(String text) {\n    // Append the provided text to the current segment\n    this.segment += text;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Returns {@code true} if the current segment is not empty.\n     * @return {@code true} if the current segment is not empty.\n     */\n    public boolean isNotEmpty() {\n        return !segment.isEmpty();\n    }\n\n    @Override\n    public String toString() {\n        return segment.trim();\n    }\n------------------------------\n------------------------------\n/**\n     * Returns the size of the provided text (as returned by the {@code sizeFunction}).\n     * @param text The text to check.\n     * @return The size of the provided text.\n     */\n    public int sizeOf(String text) {\n        return sizeFunction.apply(text);\n    }\n\n    /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\n------------------------------\n------------------------------\n/**\n     * Returns the current size of the segment (as returned by the {@code sizeFunction}).\n     * @return The current size of the segment.\n     */\n    public int getSize() {\n        return segmentSize;\n    }\n\n    /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\n------------------------------\n------------------------------\n/**\n     * Creates a new text segment.\n     *\n     * @param text     the text.\n     * @param metadata the metadata.\n     * @return the text segment.\n     */\n    public static TextSegment from(String text, Metadata metadata) {\n        return new TextSegment(text, metadata);\n    }\n\n    /**\n     * Creates a new text segment.\n     *\n     * @param text the text.\n     * @return the text segment.\n     */\n    public static TextSegment textSegment(String text) {\n        return from(text);\n    }\n------------------------------\n------------------------------\n/**\n     * Splits the provided text into parts.\n     * Implementation API.\n     * @param text The text to be split.\n     * @return An array of parts.\n     */\n    protected abstract String[] split(String text);\n\n    /**\n     * Delimiter string to use to re-join the parts.\n     * @return The delimiter.\n     */\n    protected abstract String joinDelimiter();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void prepend(String text) {\n# Natural Language Annotations: /**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void prepend(String text) {\n    if (text == null) {\n        throw new IllegalArgumentException(\"Text cannot be null\");\n    }\n    segment = text + segment;\n}\n```\n", "```java\npublic void prepend(String text) {\n    segment = text + segment;\n}\n```\n", "```java\npublic void prepend(String text) {\n    segment = text + segment;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n------------------------------\n------------------------------\n/**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n------------------------------\n------------------------------\n*\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\n------------------------------\n------------------------------\n* a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\n------------------------------\n------------------------------\n/**\n     * Configures a retrieval augmentor to be invoked on every method call.\n     *\n     * @param retrievalAugmentor The retrieval augmentor to be used by the AI Service.\n     * @return builder\n     */\n    public AiServices<T> retrievalAugmentor(RetrievalAugmentor retrievalAugmentor) {\n        if (retrieverSet || contentRetrieverSet) {\n            throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n        }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public AiServices<T> retriever(Retriever<TextSegment> retriever) {\n# Natural Language Annotations: /**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    if (retrieverSet || contentRetrieverSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    this.retriever = retriever;\n    retrieverSet = true;\n    return this;\n}\n```\n", "```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    if (retrieverSet || contentRetrieverSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    this.retriever = retriever;\n    retrieverSet = true;\n    return this;\n}\n```\n", "```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    if (retrieverSet || contentRetrieverSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    this.retriever = retriever;\n    this.retrieverSet = true;\n    return this;\n}\n```\n"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n------------------------------\n------------------------------\n* a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\n------------------------------\n------------------------------\n/**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n------------------------------\n------------------------------\n/**\n     * Configures a moderation model to be used for automatic content moderation.\n     * If a method in the AI Service is annotated with {@link Moderate}, the moderation model will be invoked\n     * to check the user content for any inappropriate or harmful material.\n     *\n     * @param moderationModel The moderation model to be used for content moderation.\n     * @return builder\n     * @see Moderate\n     */\n    public AiServices<T> moderationModel(ModerationModel moderationModel) {\n------------------------------\n------------------------------\n*\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n# Natural Language Annotations: /**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n     * a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    // Code to configure the content retriever goes here\n    // This could involve setting the content retriever in the AI Service\n    // and potentially configuring a RetrievalAugmentor with it\n}\n```\n", "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    // Configures a content retriever to be invoked on every method call for retrieving relevant content\n    // related to the user's message from an underlying data source\n    // (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n    // The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n    // <br>\n    // This method provides a straightforward approach for those who do not require\n    // a customized {@link RetrievalAugmentor}.\n    // It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n    //\n    // @param contentRetriever The content retriever to be used by the AI Service.\n    // @return builder\n    // */\n    // TODO: Implement the function based on the provided information\n    return null;\n}\n```\n", "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    // Implementation goes here\n}\n```\n"]}, "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n------------------------------\n------------------------------\n/**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n------------------------------\n------------------------------\npublic interface EmbeddingStore<Embedded> {\n\n    /**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n    String add(Embedding embedding);\n------------------------------\n------------------------------\n/**\n     * Adds a given embedding and the corresponding content that has been embedded to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @param embedded  Original content that was embedded.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n    String add(Embedding embedding, Embedded embedded);\n------------------------------\n------------------------------\n/**\n     * Adds a given embedding and the corresponding content that has been embedded to the store.\n     *\n     * @param embedding   The embedding to be added to the store.\n     * @param textSegment Original content that was embedded.\n     * @return The auto-generated ID associated with the added embedding.\n     */\n    @Override\n    public String add(Embedding embedding, TextSegment textSegment) {\n        String id = randomUUID();\n        addInternal(id, embedding, textSegment);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public String add(Embedding embedding) {\n# Natural Language Annotations: /**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic String add(Embedding embedding) {\n    String id = randomUUID();\n    addInternal(id, embedding, null);\n    return id;\n}\n```\n", "```java\n@Override\npublic String add(Embedding embedding) {\n    String id = randomUUID();\n    addInternal(id, embedding, null);\n    return id;\n}\n```\n", "```java\npublic String add(Embedding embedding) {\n    String id = UUID.randomUUID().toString();\n    addInternal(id, embedding, null);\n    return id;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class ToolSpecifications {\n\n    private ToolSpecifications() {\n    }\n\n    /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\n------------------------------\n------------------------------\n/**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool}\n     * within the class of the specified object.\n     *\n     * @param objectWithTools the object.\n     * @return the {@link ToolSpecification}s.\n     */\n    public static List<ToolSpecification> toolSpecificationsFrom(Object objectWithTools) {\n        return toolSpecificationsFrom(objectWithTools.getClass());\n    }\n------------------------------\n------------------------------\n/**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\n------------------------------\n------------------------------\n/**\n     * Configures the tools that the LLM can use.\n     *\n     * @param objectsWithTools One or more objects whose methods are annotated with {@link Tool}.\n     *                         All these tools (methods annotated with {@link Tool}) will be accessible to the LLM.\n     *                         Note that inherited methods are ignored.\n     * @return builder\n     * @see Tool\n     */\n    public AiServices<T> tools(Object... objectsWithTools) {\n------------------------------\n------------------------------\n/**\n     * Configures the tools that the LLM can use.\n     *\n     * @param objectsWithTools A list of objects whose methods are annotated with {@link Tool}.\n     *                         All these tools (methods annotated with {@link Tool}) are accessible to the LLM.\n     *                         Note that inherited methods are ignored.\n     * @return builder\n     * @see Tool\n     */\n    public AiServices<T> tools(List<Object> objectsWithTools) { // TODO Collection?\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n# Natural Language Annotations: /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    Method[] methods = classWithTools.getDeclaredMethods();\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            toolSpecifications.add(toolSpecificationFrom(method));\n        }\n    }\n    return toolSpecifications;\n}\n```\n", "```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            toolSpecifications.add(toolSpecificationFrom(method));\n        }\n    }\n    return toolSpecifications;\n}\n```\n", "```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    Method[] methods = classWithTools.getMethods();\n\n    for (Method method : methods) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            toolSpecifications.add(toolSpecificationFrom(method));\n        }\n    }\n\n    return toolSpecifications;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\n------------------------------\n------------------------------\npublic class ToolSpecifications {\n\n    private ToolSpecifications() {\n    }\n\n    /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\n------------------------------\n------------------------------\n/**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool}\n     * within the class of the specified object.\n     *\n     * @param objectWithTools the object.\n     * @return the {@link ToolSpecification}s.\n     */\n    public static List<ToolSpecification> toolSpecificationsFrom(Object objectWithTools) {\n        return toolSpecificationsFrom(objectWithTools.getClass());\n    }\n------------------------------\n------------------------------\n* - Static user message templates, configured via @{@link UserMessage} annotation on top of the method\n * - Dynamic user message templates, configured via method parameter annotated with @{@link UserMessage}\n * - Single (shared) {@link ChatMemory}, configured via {@link #chatMemory(ChatMemory)}\n * - Separate (per-user) {@code ChatMemory}, configured via {@link #chatMemoryProvider(ChatMemoryProvider)} and a method parameter annotated with @{@link MemoryId}\n------------------------------\n------------------------------\n* which will be resolved using the values of method parameters annotated with @{@link V}.\n *\n * @see SystemMessage\n */\n@Retention(RUNTIME)\n@Target({METHOD, PARAMETER})\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ToolSpecification toolSpecificationFrom(Method method) {\n# Natural Language Annotations: /**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    if (method.isAnnotationPresent(Tool.class)) {\n        Tool toolAnnotation = method.getAnnotation(Tool.class);\n        // Convert the annotation to a ToolSpecification\n        // This is a placeholder, you need to fill in the logic to convert the Tool annotation to a ToolSpecification\n        return new ToolSpecification();\n    } else {\n        throw new IllegalArgumentException(\"The method is not annotated with @Tool\");\n    }\n}\n```\n", "```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    if (method.isAnnotationPresent(Tool.class)) {\n        // Implementation of the method\n    }\n    return null;\n}\n```\n", "```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    if (method.isAnnotationPresent(Tool.class)) {\n        // Here you can create and return a ToolSpecification object based on the method annotation\n        // For simplicity, we'll return null\n        return null;\n    } else {\n        throw new IllegalArgumentException(\"The method does not have the @Tool annotation\");\n    }\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\n------------------------------\n------------------------------\n/**\n     * Deserializes a JSON string to a list of {@link ChatMessage} objects.\n     * @param json the JSON string.\n     * @return the deserialized list of {@link ChatMessage} objects.\n     */\n    List<ChatMessage> messagesFromJson(String json);\n\n    /**\n     * Serializes a {@link ChatMessage} object to a JSON string.\n     * @param message the {@link ChatMessage} object.\n     * @return the serialized JSON string.\n     */\n    String messageToJson(ChatMessage message);\n------------------------------\n------------------------------\n/**\n         * Adds a parameter to the tool.\n         * @param name the name of the parameter.\n         * @param jsonSchemaProperties the properties of the parameter.\n         * @return {@code this}\n         */\n        public Builder addParameter(String name, JsonSchemaProperty... jsonSchemaProperties) {\n            return addParameter(name, asList(jsonSchemaProperties));\n        }\n------------------------------\n------------------------------\n/**\n         * Adds a parameter to the tool.\n         * @param name the name of the parameter.\n         * @param jsonSchemaProperties the properties of the parameter.\n         * @return {@code this}\n         */\n        public Builder addParameter(String name, Iterable<JsonSchemaProperty> jsonSchemaProperties) {\n            addOptionalParameter(name, jsonSchemaProperties);\n            this.parameters.required().add(name);\n            return this;\n        }\n------------------------------\n------------------------------\n* a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n# Natural Language Annotations: /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    // Convert the Parameter to a JsonSchemaProperty\n    // This will depend on the specifics of your Parameter and JsonSchemaProperty classes\n    // Here is a placeholder implementation:\n    List<JsonSchemaProperty> jsonSchemaProperties = new ArrayList<>();\n    // Get the properties from the parameter and add them to the list\n    // jsonSchemaProperties.add(new JsonSchemaProperty(parameter.getName(), parameter.getType()));\n    // For example, assuming parameter has a method getName() and getType()\n\n    return jsonSchemaProperties;\n}\n```\n", "```java\npublic static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    // Implementation here\n}\n```\n", "```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    // Your code here\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calculates cosine similarity between two vectors.\n     * <p>\n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n------------------------------\n------------------------------\n* <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n------------------------------\n------------------------------\n* @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\n------------------------------\n------------------------------\n/**\n     * Converts relevance score into cosine similarity.\n     *\n     * @param relevanceScore Relevance score in the range [0..1] where 0 is not relevant and 1 is relevant.\n     * @return Cosine similarity in the range [-1..1] where -1 is not relevant and 1 is relevant.\n     */\n    public static double fromRelevanceScore(double relevanceScore) {\n        return relevanceScore * 2 - 1;\n    }\n}\n------------------------------\n------------------------------\n/**\n * Represents a dense vector embedding of a text.\n * This class encapsulates a float array that captures the \"meaning\" or semantic information of the text.\n * Texts with similar meanings will have their vectors located close to each other in the embedding space.\n * The embeddings are typically created by embedding models.\n * @see dev.langchain4j.model.embedding.EmbeddingModel\n */\n// Code for: public class Embedding {\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double between(Embedding embeddingA, Embedding embeddingB) {\n# Natural Language Annotations: /**\n     * Calculates cosine similarity between two vectors.\n     * <p>\n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    float[] vectorA = embeddingA.getVector();\n    float[] vectorB = embeddingB.getVector();\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n    for (int i = 0; i < vectorA.length; i++) {\n        dotProduct += vectorA[i] * vectorB[i];\n        normA += Math.pow(vectorA[i], 2);\n        normB += Math.pow(vectorB[i], 2);\n    }\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n```\n", "```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    float[] vectorA = embeddingA.getVector();\n    float[] vectorB = embeddingB.getVector();\n\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n\n    for (int i = 0; i < vectorA.length; i++) {\n        dotProduct += vectorA[i] * vectorB[i];\n        normA += Math.pow(vectorA[i], 2);\n        normB += Math.pow(vectorB[i], 2);\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n```\n", "```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    float[] vectorA = embeddingA.getVector();\n    float[] vectorB = embeddingB.getVector();\n\n    double dotProduct = 0.0;\n    double normA = 0.0;\n    double normB = 0.0;\n\n    for (int i = 0; i < vectorA.length; i++) {\n        dotProduct += vectorA[i] * vectorB[i];\n        normA += Math.pow(vectorA[i], 2);\n        normB += Math.pow(vectorB[i], 2);\n    }\n\n    normA = Math.sqrt(normA);\n    normB = Math.sqrt(normB);\n\n    if (normA == 0.0 || normB == 0.0) {\n        return 0.0;\n    }\n\n    return dotProduct / (normA * normB);\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     */\n    public Map<String, Object> toMap() {\n        return new HashMap<>(metadata);\n    }\n------------------------------\n------------------------------\n/**\n     * Constructs a Metadata object from a map of key-value pairs.\n     *\n     * @param metadata the map of key-value pairs\n     * @return a Metadata object\n     */\n    public static Metadata from(Map<String, ?> metadata) {\n        return new Metadata(metadata);\n    }\n------------------------------\n------------------------------\n/**\n     * Constructs a Metadata object from a map of key-value pairs.\n     *\n     * @param metadata the map of key-value pairs; must not be {@code null}. {@code null} values are not permitted.\n     *                 Supported value types: {@link String}, {@link Integer}, {@link Long}, {@link Float}, {@link Double}\n     */\n    public Metadata(Map<String, ?> metadata) {\n        ensureNotNull(metadata, \"metadata\").forEach((key, value) -> {\n            validate(key, value);\n------------------------------\n------------------------------\n/**\n     * Adds a key-value pair to the metadata.\n     *\n     * @param key   the key\n     * @param value the value\n     * @return {@code this}\n     * @deprecated as of 0.31.0, use {@link #put(String, String)}, {@link #put(String, int)}, {@link #put(String, long)},\n     * {@link #put(String, float)}, {@link #put(String, double)} instead.\n     */\n    @Deprecated\n    public Metadata add(String key, String value) {\n        validate(key, value);\n        this.metadata.put(key, value);\n------------------------------\n------------------------------\n/**\n     * Adds a key-value pair to the metadata.\n     *\n     * @param key   the key\n     * @param value the value\n     * @return {@code this}\n     * @deprecated as of 0.31.0, use {@link #put(String, String)}, {@link #put(String, int)}, {@link #put(String, long)},\n     * {@link #put(String, float)}, {@link #put(String, double)} instead.\n     */\n    @Deprecated\n    public Metadata add(String key, Object value) {\n        return put(key, value.toString());\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public Map<String, String> asMap() {\n# Natural Language Annotations: /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> stringMap = new HashMap<>();\n    metadata.forEach((key, value) -> stringMap.put(key, value.toString()));\n    return stringMap;\n}\n```\n", "```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> stringMap = new HashMap<>();\n    this.metadata.forEach((key, value) -> stringMap.put(key, value.toString()));\n    return stringMap;\n}\n```\n", "```java\n/**\n * Get a copy of the metadata as a map of key-value pairs.\n *\n * @return the metadata as a map of key-value pairs.\n * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n */\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> stringMap = new HashMap<>();\n    for (Map.Entry<String, Object> entry : metadata.entrySet()) {\n        stringMap.put(entry.getKey(), entry.getValue().toString());\n    }\n    return stringMap;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class DocumentLoader {\n\n    private DocumentLoader() {\n    }\n\n    /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\n------------------------------\n------------------------------\n/**\n     * Loads a {@link Document} from the specified file path.\n     * <br>\n     * The file is parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Returned {@code Document} contains all the textual information from the file.\n     *\n     * @param filePath       The path to the file.\n     * @param documentParser The parser to be used for parsing text from the file.\n     * @return document\n     * @throws IllegalArgumentException If specified path is not a file.\n     */\n------------------------------\n------------------------------\n/**\n     * Loads a {@link Document} from the specified file {@link Path}.\n     * <br>\n     * The file is parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Returned {@code Document} contains all the textual information from the file.\n     *\n     * @param filePath       The path to the file.\n     * @param documentParser The parser to be used for parsing text from the file.\n     * @return document\n     * @throws IllegalArgumentException If specified path is not a file.\n------------------------------\n------------------------------\n/**\n     * Parses a given {@link InputStream} into a {@link Document}.\n     * The specific implementation of this method will depend on the type of the document being parsed.\n     *\n     * @param inputStream The {@link InputStream} that contains the content of the {@link Document}.\n     * @return The parsed {@link Document}.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\n    Document parse(InputStream inputStream);\n}\n------------------------------\n------------------------------\n/**\n     * Returns the metadata associated with the source of the document.\n     * This could include details such as the source location, date of creation, owner, etc.\n     *\n     * @return A Metadata object containing information associated with the source of the document.\n     */\n    Metadata metadata();\n}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Document load(DocumentSource source, DocumentParser parser) {\n# Natural Language Annotations: /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    // Load the document from the source using the parser\n    Document document = parser.parse(source.getInputStream());\n\n    // Forward the source Metadata to the parsed Document\n    document.setMetadata(source.metadata());\n\n    // Check if the document is blank/empty\n    if (document.isEmpty()) {\n        throw new BlankDocumentException(\"The parsed document is blank/empty\");\n    }\n\n    return document;\n}\n```\n", "```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    try {\n        Document document = parser.parse(source.getInputStream());\n        document.setMetadata(source.metadata());\n        return document;\n    } catch (BlankDocumentException e) {\n        throw new RuntimeException(\"The parsed document is blank/empty\", e);\n    }\n}\n```\n", "```java\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source.getInputStream());\n    document.setMetadata(source.metadata());\n    return document;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\n------------------------------\n------------------------------\n/**\n     * Whether this message contains a single {@link TextContent}.\n     *\n     * @return {@code true} if this message contains a single {@link TextContent}, {@code false} otherwise.\n     */\n    public boolean hasSingleText() {\n        return contents.size() == 1 && contents.get(0) instanceof TextContent;\n    }\n------------------------------\n------------------------------\n/**\n     * {@link UserMessage} can contain not just a single {@code String text}, but also multiple {@link Content}s,\n     * which can be either {@link TextContent} or {@link ImageContent}.\n     * Therefore, this method is deprecated. Please use {@link #singleText()} if you only expect a single text,\n     * or use {@link #contents()} otherwise.\n     *\n     * @deprecated Use {@link #singleText()} or {@link #contents()} instead.\n     */\n    @Deprecated\n    public String text() {\n------------------------------\n------------------------------\n* is initialized with a sensible default implementation:\n * <pre>\n * - {@link DefaultQueryTransformer}\n * - {@link DefaultQueryRouter}\n * - {@link DefaultContentAggregator}\n * - {@link DefaultContentInjector}\n * </pre>\n * Nonetheless, you are encouraged to use one of the advanced ready-to-use implementations or create a custom one.\n * <br>\n * <br>\n * When there is only a single {@link Query} and a single {@link ContentRetriever},\n------------------------------\n------------------------------\n/**\n * Represents a message from a user, typically an end user of the application.\n * <br>\n * Depending on the supported modalities (text, image, audio, video, etc.) of the model,\n * user messages can contain either a single text (a {@code String}) or multiple {@link Content}s,\n * which can be either {@link TextContent}, {@link ImageContent}, {@link AudioContent},\n * {@link VideoContent}, or {@link PdfFileContent}.\n * <br>\n * Optionally, user message can contain a {@link #name} of the user.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String singleText() {\n# Natural Language Annotations: /**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"The message contains multiple contents or is not a TextContent\");\n    }\n    return ((TextContent) contents.get(0)).getText();\n}\n```\n", "```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"This message contains multiple contents or non-text content.\");\n    }\n    return ((TextContent) contents.get(0)).getText();\n}\n```\n", "```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"The message contains multiple contents or the content is not a TextContent\");\n    }\n    return ((TextContent) contents.get(0)).getText();\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n------------------------------\n------------------------------\n/**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n------------------------------\n------------------------------\n* @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n     */\n------------------------------\n------------------------------\n/**\n * Augments the provided {@link ChatMessage} with retrieved {@link Content}s.\n * <br>\n * This serves as an entry point into the RAG flow in LangChain4j.\n * <br>\n * You are free to use the default implementation ({@link DefaultRetrievalAugmentor}) or to implement a custom one.\n *\n * @see DefaultRetrievalAugmentor\n */\n// Code for: @Experimental\n------------------------------\n------------------------------\n* <br>\n * <br>\n * This implementation employs Reciprocal Rank Fusion (see {@link ReciprocalRankFuser}) in two stages\n * to aggregate all {@code Collection<List<Content>>} into a single {@code List<Content>}.\n * The {@link Content}s in both the input and output lists are expected to be sorted by relevance,\n * with the most relevant {@link Content}s at the beginning of the {@code List<Content>}.\n * <br>\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default AugmentationResult augment(AugmentationRequest augmentationRequest) {\n# Natural Language Annotations: /**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n     * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Your implementation here\n}\n```\n", "```java\npublic AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Code for the method\n}\n```\n", "```java\npublic AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Implementation goes here\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n * @deprecated use {@link EmbeddingStoreContentRetriever} instead.\n */\n// Code for: @Deprecated\n------------------------------\n------------------------------\nprivate static ExecutorService createDefaultExecutor() {\n        return new ThreadPoolExecutor(\n                0, Integer.MAX_VALUE,\n                1, SECONDS,\n                new SynchronousQueue<>()\n        );\n    }\n\n    /**\n     * @deprecated use {@link #augment(AugmentationRequest)} instead.\n     */\n\n\n\n\n\n\n\n    @Override\n    public AugmentationResult augment(AugmentationRequest augmentationRequest) {\n------------------------------\n------------------------------\n/**\n     * @deprecated use {@link #inject(List, ChatMessage)} instead.\n     */\n    @Override\n    @Deprecated\n    public UserMessage inject(List<Content> contents, UserMessage userMessage) {\n\n        if (contents.isEmpty()) {\n            return userMessage;\n        }\n------------------------------\n------------------------------\n/**\n     * Augments the provided {@link UserMessage} with retrieved content.\n     *\n     * @param userMessage The {@link UserMessage} to be augmented.\n     * @param metadata    The {@link Metadata} that may be useful or necessary for retrieval and augmentation.\n     * @return The augmented {@link UserMessage}.\n     * @deprecated Use/implement {@link #augment(AugmentationRequest)} instead.\n     */\n    @Deprecated\n    UserMessage augment(UserMessage userMessage, Metadata metadata);\n}\n------------------------------\n------------------------------\n/**\n     * {@link UserMessage} can contain not just a single {@code String text}, but also multiple {@link Content}s,\n     * which can be either {@link TextContent} or {@link ImageContent}.\n     * Therefore, this method is deprecated. Please use {@link #singleText()} if you only expect a single text,\n     * or use {@link #contents()} otherwise.\n     *\n     * @deprecated Use {@link #singleText()} or {@link #contents()} instead.\n     */\n    @Deprecated\n    public String text() {\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    @Deprecated    public UserMessage augment(UserMessage userMessage, Metadata metadata) {\n# Natural Language Annotations: /**\n     * @deprecated use {@link #augment(AugmentationRequest)} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Your code here\n}\n```\n", "```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Your implementation here\n}\n```\n", "```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Your implementation here\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n------------------------------\n------------------------------\n/**\n     * Injects given {@link Content}s into a given {@link UserMessage}.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param userMessage The {@link UserMessage} into which the {@link Content}s are to be injected.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     * @deprecated Use/implement {@link #inject(List, ChatMessage)} instead.\n     */\n    @Deprecated\n------------------------------\n------------------------------\n/**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n------------------------------\n------------------------------\n*                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     */\n------------------------------\n------------------------------\n* <br>\n * 3. All {@link Content}s retrieved by all {@link ContentRetriever}s using all {@link Query}s are\n * aggregated (fused/re-ranked/filtered/etc.) into a final list of {@link Content}s using a {@link ContentAggregator}.\n * <br>\n * 4. Lastly, a final list of {@link Content}s is injected into the original {@link UserMessage}\n * using a {@link ContentInjector}.\n * <br>\n * <br>\n * By default, each base component (except for {@link ContentRetriever}, which needs to be provided by you)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n# Natural Language Annotations: /**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n     *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    // Implement the logic to inject the contents into the chatMessage\n    // This is a placeholder, replace with your actual implementation\n    return chatMessage;\n}\n```\n", "```java\npublic ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    // TODO: Implement your logic here\n    return chatMessage;\n}\n```\n", "```java\nChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    // Implement your logic here\n    return chatMessage;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n   * Is the given string not {@code null} and not empty (\"\")?\n   * @param string The string to check.\n   * @return true if the given string is not {@code null} and not empty (\"\")?\n   */\n  public static boolean isNotNullOrEmpty(String string) {\n    return !isNullOrEmpty(string);\n  }\n\n  /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\n------------------------------\n------------------------------\n/**\n   * Is the given string not {@code null} and not blank?\n   * @param string The string to check.\n   * @return true if there's something in the string.\n   */\n  public static boolean isNotNullOrBlank(String string) {\n    return !isNullOrBlank(string);\n  }\n------------------------------\n------------------------------\n/**\n   * Is the given string {@code null} or blank?\n   * @param string The string to check.\n   * @return true if the string is {@code null} or blank.\n   */\n  public static boolean isNullOrBlank(String string) {\n    return string == null || string.trim().isEmpty();\n  }\n------------------------------\n------------------------------\n/**\n   * Is the given string {@code null} or empty (\"\")?\n   * @param string The string to check.\n   * @return true if the string is {@code null} or empty.\n   */\n  public static boolean isNullOrEmpty(String string) {\n    return string == null || string.isEmpty();\n  }\n------------------------------\n------------------------------\nreturn map;\n    }\n\n    /**\n     * Ensures that the given string is not null and not blank.\n     * @param string The string to check.\n     * @param name The name of the string to be used in the exception message.\n     * @return The string if it is not null and not blank.\n     * @throws IllegalArgumentException if the string is null or blank.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static boolean areNotNullOrBlank(String... strings) {\n# Natural Language Annotations: /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static boolean areNotNullOrBlank(String... strings) {\n  for (String string : strings) {\n    if (isNullOrBlank(string)) {\n      return false;\n    }\n  }\n  return true;\n}\n```\n", "```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (isNullOrBlank(string)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n", "```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (isNullOrBlank(string)) {\n            return false;\n        }\n    }\n    return true;\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n   * Internal method to get a SHA-256 instance of {@link MessageDigest}.\n   * @return a {@link MessageDigest}.\n   */\n  @JacocoIgnoreCoverageGenerated\n  private static MessageDigest getSha256Instance() {\n    try {\n      return MessageDigest.getInstance(\"SHA-256\");\n    } catch (NoSuchAlgorithmException e) {\n      throw new IllegalArgumentException(e);\n    }\n  }\n\n  /**\n   * Generates a UUID from a hash of the given input string.\n   * @param input The input string.\n   * @return A UUID.\n   */\n------------------------------\n------------------------------\n/**\n     * Creates a new {@link TokenUsage} instance with the given input token count.\n     *\n     * @param inputTokenCount The input token count.\n     */\n    public TokenUsage(Integer inputTokenCount) {\n        this(inputTokenCount, null);\n    }\n------------------------------\n------------------------------\n@FunctionalInterface\npublic interface Chain<Input, Output> {\n\n    /**\n     * Execute the chain step.\n     *\n     * @param input the input\n     * @return the output\n     */\n    Output execute(Input input);\n}\n------------------------------\n------------------------------\npublic interface PromptTemplateFactory {\n    /**\n     * Interface for input for the factory.\n     */\n    interface Input {\n        /**\n         * Get the template string.\n         * @return the template string.\n         */\n        String getTemplate();\n\n        /**\n         * Get the name of the template.\n         * @return the name of the template.\n         */\n        default String getName() { return \"template\"; }\n    }\n------------------------------\n------------------------------\n/**\n     * Interface for a prompt template.\n     */\n    interface Template {\n        /**\n         * Render the template.\n         * @param variables the variables to use.\n         * @return the rendered template.\n         */\n        String render(Map<String, Object> variables);\n    }\n\n    /**\n     * Create a new prompt template.\n     * @param input the input to the factory.\n     * @return the prompt template.\n     */\n    Template create(Input input);\n\n}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String generateUUIDFrom(String input) {\n# Natural Language Annotations: /**\n   * Generates a UUID from a hash of the given input string.\n   * @param input The input string.\n   * @return A UUID.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest sha256Instance = getSha256Instance();\n    byte[] hashBytes = sha256Instance.digest(input.getBytes(StandardCharsets.UTF_8));\n    UUID uuid = UUID.nameUUIDFromBytes(hashBytes);\n    return uuid.toString();\n}\n```\n", "```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest sha256 = getSha256Instance();\n    byte[] hash = sha256.digest(input.getBytes(StandardCharsets.UTF_8));\n    return UUID.nameUUIDFromBytes(hash).toString();\n}\n```\n", "```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest sha256 = getSha256Instance();\n    byte[] hash = sha256.digest(input.getBytes(StandardCharsets.UTF_8));\n    return Base64.getUrlEncoder().withoutPadding().encodeToString(hash);\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n   * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n   * and from files stored on the local filesystem.\n   *\n   * @param url The URL to read from.\n   * @return The content as bytes.\n   * @throws RuntimeException if the request fails.\n   */\n------------------------------\n------------------------------\n/**\n     * Loads a document from the specified URL.\n     *\n     * @param url            The URL of the file.\n     * @param documentParser The parser to be used for parsing text from the URL.\n     * @return document\n     * @throws RuntimeException If specified URL is malformed.\n     */\n    public static Document load(String url, DocumentParser documentParser) {\n        return load(createUrl(url), documentParser);\n    }\n------------------------------\n------------------------------\n/**\n     * Creates a WebSearchOrganicResult object from the given title, URL, snippet and/or content.\n     *\n     * @param title   The title of the search result.\n     * @param url    The URL associated with the search result.\n     * @param snippet The snippet of the search result, in plain text.\n     * @param content The most query related content from the scraped url.\n     * @return The created WebSearchOrganicResult object.\n     */\n------------------------------\n------------------------------\n/**\n     * Creates a WebSearchOrganicResult object from the given title, URL, snippet and/or content, and result metadata.\n     *\n     * @param title           The title of the search result.\n     * @param url            The URL associated with the search result.\n     * @param snippet         The snippet of the search result, in plain text.\n     * @param content The most query related content from the scraped url.\n     * @param metadata  The metadata associated with the search result.\n------------------------------\n------------------------------\n/**\n     * Constructs a WebSearchOrganicResult object with the given title, URL, snippet and/or content, and metadata.\n     *\n     * @param title           The title of the search result.\n     * @param url             The URL associated with the search result.\n     * @param snippet         The snippet of the search result, in plain text.\n     * @param content The most query related content from the scraped url.\n     * @param metadata  The metadata associated with the search result.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static byte[] readBytes(String url) {\n# Natural Language Annotations: /**\n   * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n   * and from files stored on the local filesystem.\n   *\n   * @param url The URL to read from.\n   * @return The content as bytes.\n   * @throws RuntimeException if the request fails.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        if (urlObj.getProtocol().equals(\"file\")) {\n            return Files.readAllBytes(Paths.get(urlObj.toURI()));\n        } else {\n            URLConnection connection = urlObj.openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0\");\n            connection.setConnectTimeout(5000);\n            connection.setReadTimeout(5000);\n            connection.connect();\n\n            try (InputStream inputStream = connection.getInputStream()) {\n                return IOUtils.toByteArray(inputStream);\n            }\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to read bytes from URL: \" + url, e);\n    }\n}\n```\n", "```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        URLConnection connection = urlObj.openConnection();\n        InputStream inputStream = connection.getInputStream();\n        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = inputStream.read(buffer)) != -1) {\n            outputStream.write(buffer, 0, length);\n        }\n\n        return outputStream.toByteArray();\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to read bytes from URL\", e);\n    }\n}\n```\n", "```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL u = new URL(url);\n        try (InputStream is = u.openStream()) {\n            return IOUtils.toByteArray(is);\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to read bytes from URL: \" + url, e);\n    }\n}\n```\n"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\n------------------------------\n------------------------------\n/**\n         * This method returns the raw delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The raw delay in milliseconds.\n         */\n        public double rawDelayMs(int attempt) {\n            return ((double) delayMillis) * Math.pow(backoffExp, attempt - 1);\n        }\n------------------------------\n------------------------------\n/**\n             * Sets the base delay in milliseconds.\n             *\n             * <p>The delay is calculated as follows:\n             * <ol>\n             *     <li>Calculate the raw delay in milliseconds as\n             *         {@code delayMillis * Math.pow(backoffExp, attempt - 1)}.</li>\n             *     <li>Calculate the jitter delay in milliseconds as\n             *         {@code rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale))}.</li>\n------------------------------\n------------------------------\n*     <li>Sleep for the jitter delay in milliseconds.</li>\n             * </ol>\n             *\n             * @param delayMillis The delay in milliseconds.\n             * @return {@code this}\n             */\n            public Builder delayMillis(int delayMillis) {\n                this.delayMillis = delayMillis;\n                return this;\n            }\n------------------------------\n------------------------------\n/**\n         * This method sleeps for a given attempt.\n         * @param attempt The attempt number.\n         */\n        @JacocoIgnoreCoverageGenerated\n        public void sleep(int attempt) {\n            try {\n                Thread.sleep(jitterDelayMillis(attempt));\n            } catch (InterruptedException ignored) {\n                // pass\n            }\n        }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int jitterDelayMillis(int attempt) {\n# Natural Language Annotations: /**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelay = rawDelayMs(attempt);\n    return (int) (rawDelay + rand.nextInt((int) (rawDelay * jitterScale)));\n}\n```\n", "```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelay = rawDelayMs(attempt);\n    return (int) (rawDelay + rand.nextInt((int) (rawDelay * jitterScale)));\n}\n```\n", "```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelay = rawDelayMs(attempt);\n    return (int) (rawDelay + rand.nextInt((int) (rawDelay * jitterScale)));\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nstatic {\n        /** \u5185\u7f6e\u4e86 uuid \u7684\u751f\u6210\u5668\uff0c\u56e0\u6b64\u4e3b\u952e\u914d\u7f6e\u7684\u65f6\u5019\u53ef\u4ee5\u76f4\u63a5\u914d\u7f6e\u4e3a @Id(keyType = KeyType.Generator, value = \"uuid\")\n         * {@link com.mybatisflex.annotation.Id}\n         */\n        register(KeyGenerators.uuid, new UUIDKeyGenerator());\n        register(KeyGenerators.flexId, new FlexIDKeyGenerator());\n        register(KeyGenerators.snowFlakeId, new SnowFlakeIDKeyGenerator());\n    }\n\n\n    /**\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\n------------------------------\n------------------------------\npublic class KeyGenerators {\n\n    private KeyGenerators() {\n    }\n\n    /**\n     * uuid \u4e3b\u952e\u751f\u6210\u5668\n     * {@link com.mybatisflex.core.keygen.impl.UUIDKeyGenerator}\n     */\n    public static final String uuid = \"uuid\";\n\n    /**\n     * flexId \u4e3b\u952e\u751f\u6210\u5668\n     * {@link com.mybatisflex.core.keygen.impl.FlexIDKeyGenerator}\n     */\n    public static final String flexId = \"flexId\";\n------------------------------\n------------------------------\n/**\n     * Adds the mappers.\n     *\n     * @param packageName the package name\n     * @since 3.2.2\n     */\n    public void addMappers(String packageName) {\n        addMappers(packageName, Object.class);\n    }\n}\n------------------------------\n------------------------------\n/**\n     * \u6839\u636e MAC + PID \u7684 hashCode \u83b7\u53d6 16 \u4e2a\u4f4e\u4f4d\u751f\u6210\u5de5\u4f5c\u673a\u5668 ID\u3002\n     */\n    protected long getWorkerId(long dataCenterId, long maxWorkerId) {\n        StringBuilder mpId = new StringBuilder();\n        mpId.append(dataCenterId);\n        String name = ManagementFactory.getRuntimeMXBean().getName();\n        if (StringUtil.isNotBlank(name)) {\n            // GET jvmPid\n            mpId.append(name.split(\"@\")[0]);\n        }\n        // MAC + PID \u7684 hashCode \u83b7\u53d616\u4e2a\u4f4e\u4f4d\n------------------------------\n------------------------------\n/**\n     * {@code IS NOT NULL}\n     *\n     * @param column      \u5217\u540d, lambda \u5c55\u793a\n     * @param isEffective \u662f\u5426\u6709\u6548\n     */\n    public <T> QueryWrapper isNotNull(LambdaGetter<T> column, BooleanSupplier isEffective) {\n        and(QueryMethods.column(column).isNotNull(isEffective));\n        return this;\n    }\n\n\n    ////////\u5185\u90e8\u65b9\u6cd5////////\n\n    /**\n     * \u83b7\u53d6 queryWrapper \u7684\u53c2\u6570\n     * \u5728\u6784\u5efa sql \u7684\u65f6\u5019\uff0c\u9700\u8981\u4fdd\u8bc1 where \u5728 having \u7684\u524d\u9762\n     */\n    Object[] getAllValueArray() {\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static IKeyGenerator getKeyGenerator(String name) {\n# Natural Language Annotations: /**\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return keyGeneratorMap.get(name);\n}\n```\n", "```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    if (KeyGenerators.uuid.equals(name)) {\n        return new UUIDKeyGenerator();\n    } else if (KeyGenerators.flexId.equals(name)) {\n        return new FlexIDKeyGenerator();\n    } else if (KeyGenerators.snowFlakeId.equals(name)) {\n        return new SnowFlakeIDKeyGenerator();\n    } else {\n        throw new IllegalArgumentException(\"Invalid key generator name: \" + name);\n    }\n}\n```\n", "```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    switch (name) {\n        case KeyGenerators.uuid:\n            return new UUIDKeyGenerator();\n        case KeyGenerators.flexId:\n            return new FlexIDKeyGenerator();\n        case KeyGenerators.snowFlakeId:\n            return new SnowFlakeIDKeyGenerator();\n        default:\n            throw new IllegalArgumentException(\"Invalid key generator name: \" + name);\n    }\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic Object getValue() {\n        return checkEffective() ? value : null;\n    }\n\n    public void setValue(Object value) {\n        this.value = value;\n    }\n\n    public String getLogic() {\n        return logic;\n    }\n\n    public void setLogic(String logic) {\n        this.logic = logic;\n    }\n\n    /**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\n------------------------------\n------------------------------\n/**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param fn \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\n    public QueryCondition when(BooleanSupplier fn) {\n        if (notEmpty()) {\n            this.effective = fn.getAsBoolean();\n        }\n        return this;\n    }\n\n    public boolean checkEffective() {\n        return effective;\n    }\n\n\n    public QueryCondition and(String sql) {\n        return and(new RawQueryCondition(sql));\n    }\n------------------------------\n------------------------------\n/**\n     * \u53c2\u8003 druid  \u548c MyBatis-plus \u7684 JdbcUtils\n     * {@link com.alibaba.druid.util.JdbcUtils#getDbType(String, String)}\n     * {@link com.baomidou.mybatisplus.extension.toolkit.JdbcUtils#getDbType(String)}\n     *\n     * @param jdbcUrl jdbcURL\n     * @return \u8fd4\u56de\u6570\u636e\u5e93\u7c7b\u578b\n     */\n------------------------------\n------------------------------\n/**\n     * \u6dfb\u52a0 \u5b9e\u4f53\u7c7b \u4e0e {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u63a5\u53e3 \u5bf9\u5e94\uff0c\u4e24\u8005\u7686\u4e3a\u975e\u52a8\u6001\u4ee3\u7406\u7c7b\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param mapperClass {@link BaseMapper} \u5b9e\u73b0\u63a5\u53e3\n     */\n    static void addMapping(Class<?> entityClass, Class<?> mapperClass) {\n        ENTITY_MAPPER_MAP.put(entityClass, mapperClass);\n    }\n\n    /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\n------------------------------\n------------------------------\npublic interface MapperQueryChain<T> extends ChainQuery<T> {\n\n    /**\n     * \u8be5\u5b9e\u73b0\u7c7b\u5bf9\u5e94\u7684 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @return {@link BaseMapper}\n     */\n    BaseMapper<T> baseMapper();\n\n    /**\n     * \u5c06\u8be5\u5b9e\u73b0\u7c7b\u8f6c\u6362\u4e3a {@link QueryWrapper} \u5bf9\u8c61\u3002\n     *\n     * @return {@link QueryWrapper}\n     */\n    QueryWrapper toQueryWrapper();\n\n    /**\n     * \u67e5\u8be2\u6570\u636e\u6570\u91cf\u3002\n     *\n     * @return \u6570\u636e\u6570\u91cf\n     */\n    default long count() {\n        return baseMapper().selectCountByQuery(toQueryWrapper());\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public QueryCondition when(boolean effective) {\n# Natural Language Annotations: /**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic QueryCondition when(boolean effective) {\n    if (notEmpty()) {\n        this.effective = effective;\n    }\n    return this;\n}\n```\n", "```java\npublic QueryCondition when(boolean effective) {\n    if (notEmpty()) {\n        this.effective = effective;\n    }\n    return this;\n}\n```\n", "```java\npublic QueryCondition when(boolean effective) {\n    this.effective = effective;\n    return this;\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class StringUtil {\n\n    private StringUtil() {\n    }\n\n    /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\n------------------------------\n------------------------------\n/**\n     * \u6267\u884c\u539f\u751f sql \u7684\u65b9\u6cd5\n     *\n     * @param params \u65b9\u6cd5\u53c2\u6570\n     * @return SQL \u8bed\u53e5\n     * @see RowMapper#insertBySql(String, Object...)\n     * @see RowMapper#deleteBySql(String, Object...)\n     * @see RowMapper#updateBySql(String, Object...)\n     */\n    public static String providerRawSql(Map params) {\n        ProviderUtil.flatten(params);\n        return ProviderUtil.getSqlString(params);\n    }\n------------------------------\n------------------------------\n/**\n     * \u6279\u91cf\u63d2\u5165\u5b9e\u4f53\u7c7b\u6570\u636e\uff0c\u53ea\u4f1a\u6839\u636e\u7b2c\u4e00\u6761\u6570\u636e\u6765\u6784\u5efa\u63d2\u5165\u7684\u5b57\u6bb5\u5185\u5bb9\u3002\n     *\n     * @param entities \u63d2\u5165\u7684\u6570\u636e\u5217\u8868\n     * @return \u53d7\u5f71\u54cd\u7684\u884c\u6570\n     * @see com.mybatisflex.core.provider.EntitySqlProvider#insertBatch(Map, ProviderContext)\n     * @see com.mybatisflex.core.FlexConsts#METHOD_INSERT_BATCH\n     */\n    @InsertProvider(type = EntitySqlProvider.class, method = FlexConsts.METHOD_INSERT_BATCH)\n    int insertBatch(@Param(FlexConsts.ENTITIES) List<T> entities);\n------------------------------\n------------------------------\n/**\n     * \u66f4\u65b0 entity\uff0c\u4e3b\u8981\u7528\u4e8e\u8fdb\u884c\u6279\u91cf\u66f4\u65b0\u7684\u573a\u666f\n     *\n     * @param entity \u5b9e\u4f53\u7c7b\n     * @see RowSqlProvider#updateEntity(Map)\n     * @see Db#updateEntitiesBatch(Collection, int)\n     */\n    @UpdateProvider(value = RowSqlProvider.class, method = \"updateEntity\")\n    int updateEntity(@Param(FlexConsts.ENTITY) Object entity);\n\n\n\n    ///////select /////\n------------------------------\n------------------------------\n/**\n     * insertBatch \u7684 SQL \u6784\u5efa\u3002\n     *\n     * @param params  \u65b9\u6cd5\u53c2\u6570\n     * @param context \u4e0a\u4e0b\u6587\u5bf9\u8c61\n     * @return SQL \u8bed\u53e5\n     * @see com.mybatisflex.core.BaseMapper#insertBatch(List)\n     * @see com.mybatisflex.core.FlexConsts#METHOD_INSERT_BATCH\n     */\n    public static String insertBatch(Map params, ProviderContext context) {\n        List<Object> entities = ProviderUtil.getEntities(params);\n\n        FlexAssert.notEmpty(entities, \"entities\");\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String methodToProperty(String name) {\n# Natural Language Annotations: /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        throw new RuntimeException(\"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n\n    return name;\n}\n```\n", "```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        throw new RuntimeException(\"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n\n    return name;\n}\n```\n", "```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        throw new UnsupportedOperationException(\n                \"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase(Locale.ENGLISH) + name.substring(1);\n    }\n\n    return name;\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * \u7b2c\u4e00\u4e2a\u5b57\u7b26\u8f6c\u6362\u4e3a\u5927\u5199\n     *\n     * @param string\n     */\n    public static String firstCharToUpperCase(String string) {\n        char firstChar = string.charAt(0);\n        if (firstChar >= 'a' && firstChar <= 'z') {\n            char[] chars = string.toCharArray();\n            chars[0] -= ('a' - 'A');\n            return new String(chars);\n        }\n        return string;\n    }\n\n\n    /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\n------------------------------\n------------------------------\n/**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\n------------------------------\n------------------------------\n/**\n     * \u67e5\u770b\u67d0\u4e2a string \u5bf9\u8c61\u662f\u5426\u6709\u6587\u672c\u5185\u5bb9\n     */\n    public static boolean hasText(String string) {\n        return StringUtil.isNotBlank(string);\n    }\n\n}\n------------------------------\n------------------------------\n/**\n     * \u7b2c\u4e00\u4e2a\u5b57\u7b26\u8f6c\u6362\u4e3a\u5c0f\u5199\n     *\n     * @param string\n     */\n    public static String firstCharToLowerCase(String string) {\n        char firstChar = string.charAt(0);\n        if (firstChar >= 'A' && firstChar <= 'Z') {\n            char[] chars = string.toCharArray();\n            chars[0] += ('a' - 'A');\n            return new String(chars);\n        }\n        return string;\n    }\n------------------------------\n------------------------------\n/**\n     * \u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u662f\u5168\u662f\u6570\u5b57\n     *\n     * @param string\n     * @return \u5168\u90e8\u6570\u6570\u503c\u65f6\u8fd4\u56de true\uff0c\u5426\u5219\u8fd4\u56de false\n     */\n    public static boolean isNumeric(String string) {\n        if (isBlank(string)) {\n            return false;\n        }\n        for (int i = string.length(); --i >= 0; ) {\n            int chr = string.charAt(i);\n            if (chr < 48 || chr > 57) {\n                return false;\n            }\n        }\n        return true;\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String camelToUnderline(String string) {\n# Natural Language Annotations: /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String camelToUnderline(String string) {\n    StringBuilder sb = new StringBuilder(string.length() + 1);\n    for (char c : string.toCharArray()) {\n        if (Character.isUpperCase(c)) {\n            sb.append('_');\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String camelToUnderline(String string) {\n    StringBuilder sb = new StringBuilder(string.length() + 1);\n    for (char c : string.toCharArray()) {\n        if (Character.isUpperCase(c)) {\n            sb.append('_');\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String camelToUnderline(String string) {\n    StringBuilder sb = new StringBuilder(string);\n    for (int i = 1; i < sb.length(); i++) {\n        if (Character.isUpperCase(sb.charAt(i))) {\n            sb.insert(i++, '_');\n        }\n    }\n    return sb.toString().toLowerCase();\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\n------------------------------\n------------------------------\n/**\n     * \u7b2c\u4e00\u4e2a\u5b57\u7b26\u8f6c\u6362\u4e3a\u5927\u5199\n     *\n     * @param string\n     */\n    public static String firstCharToUpperCase(String string) {\n        char firstChar = string.charAt(0);\n        if (firstChar >= 'a' && firstChar <= 'z') {\n            char[] chars = string.toCharArray();\n            chars[0] -= ('a' - 'A');\n            return new String(chars);\n        }\n        return string;\n    }\n\n\n    /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\n------------------------------\n------------------------------\n/**\n     * \u67e5\u770b\u67d0\u4e2a string \u5bf9\u8c61\u662f\u5426\u6709\u6587\u672c\u5185\u5bb9\n     */\n    public static boolean hasText(String string) {\n        return StringUtil.isNotBlank(string);\n    }\n\n}\n------------------------------\n------------------------------\n/**\n     * \u7b2c\u4e00\u4e2a\u5b57\u7b26\u8f6c\u6362\u4e3a\u5c0f\u5199\n     *\n     * @param string\n     */\n    public static String firstCharToLowerCase(String string) {\n        char firstChar = string.charAt(0);\n        if (firstChar >= 'A' && firstChar <= 'Z') {\n            char[] chars = string.toCharArray();\n            chars[0] += ('a' - 'A');\n            return new String(chars);\n        }\n        return string;\n    }\n------------------------------\n------------------------------\n/**\n     * \u8fd9\u4e2a\u5b57\u7b26\u4e32\u662f\u5426\u662f\u5168\u662f\u6570\u5b57\n     *\n     * @param string\n     * @return \u5168\u90e8\u6570\u6570\u503c\u65f6\u8fd4\u56de true\uff0c\u5426\u5219\u8fd4\u56de false\n     */\n    public static boolean isNumeric(String string) {\n        if (isBlank(string)) {\n            return false;\n        }\n        for (int i = string.length(); --i >= 0; ) {\n            int chr = string.charAt(i);\n            if (chr < 48 || chr > 57) {\n                return false;\n            }\n        }\n        return true;\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String underlineToCamel(String string) {\n# Natural Language Annotations: /**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String underlineToCamel(String string) {\n    if (string == null || string.isEmpty()) {\n        return \"\";\n    }\n    StringBuilder sb = new StringBuilder();\n    boolean toUpper = false;\n    for (char c : string.toCharArray()) {\n        if (c == '_') {\n            toUpper = true;\n        } else {\n            sb.append(toUpper ? Character.toUpperCase(c) : c);\n            toUpper = false;\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String underlineToCamel(String string) {\n    if (string == null || \"\".equals(string)) {\n        return \"\";\n    }\n    String[] words = string.split(\"_\");\n    StringBuilder sb = new StringBuilder(words[0]);\n    for (int i = 1; i < words.length; i++) {\n        sb.append(firstCharToUpperCase(words[i]));\n    }\n    return sb.toString();\n}\n```\n", "```java\npublic static String underlineToCamel(String string) {\n    if (string == null || \"\".equals(string)) {\n        return \"\";\n    }\n    String[] words = string.split(\"_\");\n    for (int i = 0; i < words.length; i++) {\n        if (i == 0) {\n            words[i] = firstCharToLowerCase(words[i]);\n        } else {\n            words[i] = firstCharToUpperCase(words[i]);\n        }\n    }\n    return String.join(\"\", words);\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic static <K, V> HashMap<K, V> newHashMap() {\n        return new HashMap<>();\n    }\n\n    /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\n------------------------------\n------------------------------\n/**\n * \u4e3b\u952e\u903b\u8f91\u5220\u9664\u5904\u7406\u5668\u3002\n *\n * @author \u738b\u5e05\n * @see <a href=\"https://gitee.com/mybatis-flex/mybatis-flex/issues/I7O1VV\">I7O1VV</a>\n * @since 2023-07-26\n */\n// Code for: public class PrimaryKeyLogicDeleteProcessor extends NullableColumnLogicDeleteProcessor {\n------------------------------\n------------------------------\n/**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n\n\n\n\n\n\n\n\n\n\n\n    public static <K, V> Map.Entry<K, V> entry(K key, V value) {\n        return new AbstractMap.SimpleImmutableEntry<>(key, value);\n    }\n\n\n}\n------------------------------\n------------------------------\n/**\n     * \u6267\u884c\u539f\u751f sql \u7684\u65b9\u6cd5\n     *\n     * @param params \u65b9\u6cd5\u53c2\u6570\n     * @return SQL \u8bed\u53e5\n     * @see RowMapper#insertBySql(String, Object...)\n     * @see RowMapper#deleteBySql(String, Object...)\n     * @see RowMapper#updateBySql(String, Object...)\n     */\n    public static String providerRawSql(Map params) {\n        ProviderUtil.flatten(params);\n        return ProviderUtil.getSqlString(params);\n    }\n------------------------------\n------------------------------\n/**\n     * \u6279\u91cf\u63d2\u5165\u5b9e\u4f53\u7c7b\u6570\u636e\uff0c\u53ea\u4f1a\u6839\u636e\u7b2c\u4e00\u6761\u6570\u636e\u6765\u6784\u5efa\u63d2\u5165\u7684\u5b57\u6bb5\u5185\u5bb9\u3002\n     *\n     * @param entities \u63d2\u5165\u7684\u6570\u636e\u5217\u8868\n     * @return \u53d7\u5f71\u54cd\u7684\u884c\u6570\n     * @see com.mybatisflex.core.provider.EntitySqlProvider#insertBatch(Map, ProviderContext)\n     * @see com.mybatisflex.core.FlexConsts#METHOD_INSERT_BATCH\n     */\n    @InsertProvider(type = EntitySqlProvider.class, method = FlexConsts.METHOD_INSERT_BATCH)\n    int insertBatch(@Param(FlexConsts.ENTITIES) List<T> entities);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n# Natural Language Annotations: /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        V newValue = mappingFunction.apply(key);\n        if (newValue != null) {\n            concurrentHashMap.put(key, newValue);\n            return newValue;\n        }\n    }\n    return value;\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    if (concurrentHashMap instanceof ConcurrentHashMap) {\n        ConcurrentHashMap<K, V> concurrentMap = (ConcurrentHashMap<K, V>) concurrentHashMap;\n        return concurrentMap.computeIfAbsent(key, mappingFunction);\n    } else {\n        if (!concurrentHashMap.containsKey(key)) {\n            V value = mappingFunction.apply(key);\n            concurrentHashMap.put(key, value);\n        }\n        return concurrentHashMap.get(key);\n    }\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value != null) {\n        return value;\n    }\n    return concurrentHashMap.computeIfAbsent(key, mappingFunction);\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\n\n\n\n\n\n\n\n\n\n\n\n    public static <K, V> Map.Entry<K, V> entry(K key, V value) {\n        return new AbstractMap.SimpleImmutableEntry<>(key, value);\n    }\n\n\n}\n------------------------------\n------------------------------\n/**\n * \u4e3b\u952e\u903b\u8f91\u5220\u9664\u5904\u7406\u5668\u3002\n *\n * @author \u738b\u5e05\n * @see <a href=\"https://gitee.com/mybatis-flex/mybatis-flex/issues/I7O1VV\">I7O1VV</a>\n * @since 2023-07-26\n */\n// Code for: public class PrimaryKeyLogicDeleteProcessor extends NullableColumnLogicDeleteProcessor {\n------------------------------\n------------------------------\npublic static <K, V> HashMap<K, V> newHashMap() {\n        return new HashMap<>();\n    }\n\n    /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\n------------------------------\n------------------------------\npublic class StringUtil {\n\n    private StringUtil() {\n    }\n\n    /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\n------------------------------\n------------------------------\n/**\n     * update \u7684 SQL \u6784\u5efa\u3002\n     *\n     * @param params  \u65b9\u6cd5\u53c2\u6570\n     * @param context \u4e0a\u4e0b\u6587\u5bf9\u8c61\n     * @return SQL \u8bed\u53e5\n     * @see com.mybatisflex.core.BaseMapper#update(Object, boolean)\n     */\n    public static String update(Map params, ProviderContext context) {\n        Object entity = ProviderUtil.getEntity(params);\n\n        FlexAssert.notNull(entity, \"entity can not be null for execute update\");\n\n        boolean ignoreNulls = ProviderUtil.isIgnoreNulls(params);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n# Natural Language Annotations: /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value != null) {\n        return value;\n    }\n    return map.computeIfAbsent(key, mappingFunction);\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value != null) {\n        return value;\n    }\n    return map.computeIfAbsent(key, mappingFunction);\n}\n```\n", "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value != null) {\n        return value;\n    }\n    return map.computeIfAbsent(key, mappingFunction);\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * \u6dfb\u52a0 \u5b9e\u4f53\u7c7b \u4e0e {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u63a5\u53e3 \u5bf9\u5e94\uff0c\u4e24\u8005\u7686\u4e3a\u975e\u52a8\u6001\u4ee3\u7406\u7c7b\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param mapperClass {@link BaseMapper} \u5b9e\u73b0\u63a5\u53e3\n     */\n    static void addMapping(Class<?> entityClass, Class<?> mapperClass) {\n        ENTITY_MAPPER_MAP.put(entityClass, mapperClass);\n    }\n\n    /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\n------------------------------\n------------------------------\n/**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\n\n\n\n\n\n\n\n\n    private static class MapperHandler implements InvocationHandler {\n\n        private final Class<?> mapperClass;\n        private final ExecutorType executorType;\n        private final SqlSessionFactory sqlSessionFactory;\n------------------------------\n------------------------------\n/**\n * <p>\u94fe\u5f0f {@link BaseMapper} \u67e5\u8be2\u3002\n *\n * <p>\u8981\u6c42\u5b9e\u73b0\u7c7b\u9664\u4e86\u5305\u542b\u6709 {@link BaseMapper} \u63a5\u53e3\u7684\u5f15\u7528\u5916\uff0c\u8fd8\u5fc5\u987b\u5177\u6709 {@link QueryWrapper}\n * \u7684\u67e5\u8be2\u6761\u4ef6\u6784\u5efa\u529f\u80fd\u3002\u5728\u4f7f\u7528\u65f6\uff1a\n * <ul>\n *     <li>\u901a\u8fc7 {@link #baseMapper()} \u83b7\u53d6\u8be5\u5b9e\u73b0\u7c7b\u5bf9\u5e94\u7684 {@link BaseMapper} \u5f15\u7528\u3002\n *     <li>\u901a\u8fc7 {@link #toQueryWrapper()} \u5c06\u8be5\u5b9e\u73b0\u7c7b\u8f6c\u6362\u4e3a {@link QueryWrapper} \u5bf9\u8c61\u3002\n * </ul>\n *\n * @param <T> \u5b9e\u4f53\u7c7b\u7c7b\u578b\n * @author \u738b\u5e05\n * @since 2023-08-08\n */\n// Code for: public interface MapperQueryChain<T> extends ChainQuery<T> {\n------------------------------\n------------------------------\npublic interface MapperQueryChain<T> extends ChainQuery<T> {\n\n    /**\n     * \u8be5\u5b9e\u73b0\u7c7b\u5bf9\u5e94\u7684 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @return {@link BaseMapper}\n     */\n    BaseMapper<T> baseMapper();\n\n    /**\n     * \u5c06\u8be5\u5b9e\u73b0\u7c7b\u8f6c\u6362\u4e3a {@link QueryWrapper} \u5bf9\u8c61\u3002\n     *\n     * @return {@link QueryWrapper}\n     */\n    QueryWrapper toQueryWrapper();\n\n    /**\n     * \u67e5\u8be2\u6570\u636e\u6570\u91cf\u3002\n     *\n     * @return \u6570\u636e\u6570\u91cf\n     */\n    default long count() {\n        return baseMapper().selectCountByQuery(toQueryWrapper());\n    }\n------------------------------\n------------------------------\npublic interface QueryBuilder<T> {\n\n    /**\n     * \u6784\u5efa\u67e5\u8be2\u5c5e\u6027\u7684 {@link QueryWrapper} \u5bf9\u8c61\u3002\n     *\n     * @param entity \u5b9e\u4f53\u7c7b\n     * @return \u67e5\u8be2\u6761\u4ef6\n     */\n    QueryWrapper build(T entity);\n\n}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    Class<?> mapperClass = ENTITY_MAPPER_MAP.get(entityClass);\n    if (mapperClass == null) {\n        throw new IllegalArgumentException(\"No mapper found for entity class: \" + entityClass.getName());\n    }\n    return (BaseMapper<E>) new MapperHandler(mapperClass, ExecutorType.SIMPLE, sqlSessionFactory).getMapper();\n}\n```\n", "```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    Class<?> mapperClass = ENTITY_MAPPER_MAP.get(entityClass);\n    if (mapperClass != null) {\n        return (BaseMapper<E>) new MapperHandler(mapperClass, ExecutorType.SIMPLE, sqlSessionFactory).newInstance();\n    } else {\n        throw new IllegalArgumentException(\"No BaseMapper found for entity class: \" + entityClass);\n    }\n}\n```\n", "```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    Class<?> mapperClass = ENTITY_MAPPER_MAP.get(entityClass);\n    if (mapperClass != null) {\n        return (BaseMapper<E>) new MapperHandler(mapperClass, ExecutorType.SIMPLE, sqlSessionFactory).getProxy();\n    } else {\n        throw new IllegalArgumentException(\"No mapper class found for entity class: \" + entityClass.getName());\n    }\n}\n```\n"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\n\n\n\n\n\n\n\n\n    private static class MapperHandler implements InvocationHandler {\n\n        private final Class<?> mapperClass;\n        private final ExecutorType executorType;\n        private final SqlSessionFactory sqlSessionFactory;\n------------------------------\n------------------------------\n/**\n     * \u6dfb\u52a0 \u5b9e\u4f53\u7c7b \u4e0e {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u63a5\u53e3 \u5bf9\u5e94\uff0c\u4e24\u8005\u7686\u4e3a\u975e\u52a8\u6001\u4ee3\u7406\u7c7b\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param mapperClass {@link BaseMapper} \u5b9e\u73b0\u63a5\u53e3\n     */\n    static void addMapping(Class<?> entityClass, Class<?> mapperClass) {\n        ENTITY_MAPPER_MAP.put(entityClass, mapperClass);\n    }\n\n    /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\n------------------------------\n------------------------------\npublic interface MapperModel<T> {\n\n    /**\n     * \u83b7\u53d6\u5b9e\u4f53\u7c7b\u5bf9\u5e94\u7684 {@link BaseMapper} \u63a5\u53e3\u3002\n     *\n     * @return {@link BaseMapper} \u63a5\u53e3\n     */\n    default BaseMapper<T> baseMapper() {\n        return Mappers.ofEntityClass((Class<T>) getClass());\n    }\n------------------------------\n------------------------------\n/**\n * <p>\u94fe\u5f0f {@link BaseMapper} \u67e5\u8be2\u3002\n *\n * <p>\u8981\u6c42\u5b9e\u73b0\u7c7b\u9664\u4e86\u5305\u542b\u6709 {@link BaseMapper} \u63a5\u53e3\u7684\u5f15\u7528\u5916\uff0c\u8fd8\u5fc5\u987b\u5177\u6709 {@link QueryWrapper}\n * \u7684\u67e5\u8be2\u6761\u4ef6\u6784\u5efa\u529f\u80fd\u3002\u5728\u4f7f\u7528\u65f6\uff1a\n * <ul>\n *     <li>\u901a\u8fc7 {@link #baseMapper()} \u83b7\u53d6\u8be5\u5b9e\u73b0\u7c7b\u5bf9\u5e94\u7684 {@link BaseMapper} \u5f15\u7528\u3002\n *     <li>\u901a\u8fc7 {@link #toQueryWrapper()} \u5c06\u8be5\u5b9e\u73b0\u7c7b\u8f6c\u6362\u4e3a {@link QueryWrapper} \u5bf9\u8c61\u3002\n * </ul>\n *\n * @param <T> \u5b9e\u4f53\u7c7b\u7c7b\u578b\n * @author \u738b\u5e05\n * @since 2023-08-08\n */\n// Code for: public interface MapperQueryChain<T> extends ChainQuery<T> {\n------------------------------\n------------------------------\npublic interface MapperQueryChain<T> extends ChainQuery<T> {\n\n    /**\n     * \u8be5\u5b9e\u73b0\u7c7b\u5bf9\u5e94\u7684 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @return {@link BaseMapper}\n     */\n    BaseMapper<T> baseMapper();\n\n    /**\n     * \u5c06\u8be5\u5b9e\u73b0\u7c7b\u8f6c\u6362\u4e3a {@link QueryWrapper} \u5bf9\u8c61\u3002\n     *\n     * @return {@link QueryWrapper}\n     */\n    QueryWrapper toQueryWrapper();\n\n    /**\n     * \u67e5\u8be2\u6570\u636e\u6570\u91cf\u3002\n     *\n     * @return \u6570\u636e\u6570\u91cf\n     */\n    default long count() {\n        return baseMapper().selectCountByQuery(toQueryWrapper());\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <M> M ofMapperClass(Class<M> mapperClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return (M) Proxy.newProxyInstance(\n            mapperClass.getClassLoader(),\n            new Class<?>[]{mapperClass},\n            new MapperHandler(mapperClass)\n    );\n}\n```\n", "```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return (M) Proxy.newProxyInstance(\n            mapperClass.getClassLoader(),\n            new Class[]{mapperClass},\n            new MapperHandler(mapperClass, ExecutorType.SIMPLE, sqlSessionFactory)\n    );\n}\n```\n", "```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    MapperHandler handler = new MapperHandler(mapperClass, null, null);\n    return (M) Proxy.newProxyInstance(MapperHandler.class.getClassLoader(),\n            new Class[]{mapperClass}, handler);\n}\n```\n"]}, "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Streams the audio response for the given speech prompt.\n\t * @param speechPrompt The speech prompt containing the text and options for speech\n\t * synthesis.\n\t * @return A Flux of SpeechResponse objects containing the streamed audio and\n\t * metadata.\n\t */\n\n\n\n\n\n\n\n\n\n\n\n\n\tprivate OpenAiAudioApi.SpeechRequest createRequest(SpeechPrompt request) {\n\t\tOpenAiAudioSpeechOptions options = this.defaultOptions;\n------------------------------\n------------------------------\n/**\n\t * Sends a speech request to the OpenAI TTS API and returns the resulting speech\n\t * response.\n\t * @param request the speech prompt containing the input text and other parameters\n\t * @return the speech response containing the generated audio\n\t */\n\tSpeechResponse call(SpeechPrompt request);\n\n}\n------------------------------\n------------------------------\n/**\n\t * Sends a speech request to the OpenAI TTS API and returns a stream of the resulting\n\t * speech responses.\n\t * @param prompt the speech prompt containing the input text and other parameters\n\t * @return a Flux of speech responses, each containing a portion of the generated\n\t * audio\n\t */\n\t@Override\n\tFlux<SpeechResponse> stream(SpeechPrompt prompt);\n\n}\n------------------------------\n------------------------------\n/**\n\t * Creates a new instance of SpeechResponse with the given speech result and speech\n\t * response metadata.\n\t * @param speech the speech result to be set in the SpeechResponse\n\t * @param speechResponseMetadata the speech response metadata to be set in the\n\t * SpeechResponse\n\t * @see Speech\n\t * @see OpenAiAudioSpeechResponseMetadata\n\t */\n\tpublic SpeechResponse(Speech speech, OpenAiAudioSpeechResponseMetadata speechResponseMetadata) {\n\t\tthis.speech = speech;\n------------------------------\n------------------------------\n/**\n\t * Streams audio generated from the input text.\n\t *\n\t * This method sends a POST request to the OpenAI API to generate audio from the\n\t * provided text. The audio is streamed back as a Flux of ResponseEntity objects, each\n\t * containing a byte array of the audio data.\n\t * @param requestBody The request body containing the details for the audio\n\t * generation, such as the input text, model, voice, and response format.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n# Natural Language Annotations: /**\n\t * Streams the audio response for the given speech prompt.\n\t * @param speechPrompt The speech prompt containing the text and options for speech\n\t * synthesis.\n\t * @return A Flux of SpeechResponse objects containing the streamed audio and\n\t * metadata.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    OpenAiAudioApi.SpeechRequest request = createRequest(speechPrompt);\n    return OpenAiAudioApi.stream(request)\n            .map(response -> new SpeechResponse(response.getSpeech(), response.getSpeechResponseMetadata()));\n}\n```\n", "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    OpenAiAudioApi.SpeechRequest request = createRequest(speechPrompt);\n    OpenAiAudioApi.SpeechResponse response = call(request);\n    return Flux.just(new SpeechResponse(response.getSpeech(), response.getSpeechResponseMetadata()));\n}\n```\n", "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    OpenAiAudioApi.SpeechRequest request = createRequest(speechPrompt);\n    return OpenAiAudioApi.stream(request)\n        .flatMap(speechResult -> {\n            Speech speech = new Speech(speechResult.getAudioData());\n            OpenAiAudioSpeechResponseMetadata metadata = speechResult.getMetadata();\n            return Flux.just(new SpeechResponse(speech, metadata));\n        });\n}\n```\n"]}, "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\n\tBedrockCohereEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n\n\t\tBedrockCohereEmbeddingOptions options = (this.defaultOptions != null) ? this.defaultOptions\n\t\t\t\t: BedrockCohereEmbeddingOptions.builder()\n\t\t\t\t\t.withInputType(CohereEmbeddingRequest.InputType.SEARCH_DOCUMENT)\n\t\t\t\t\t.withTruncate(CohereEmbeddingRequest.Truncate.NONE)\n\t\t\t\t\t.build();\n------------------------------\n------------------------------\n/**\n\t * Merge two ChatResponseMessage instances into a single ChatResponseMessage instance.\n\t * @param left the left ChatResponseMessage instance to merge.\n\t * @param right the right ChatResponseMessage instance to merge.\n\t * @return a merged ChatResponseMessage instance.\n\t */\n\tprivate static ChatResponseMessage mergeChatResponseMessage(ChatResponseMessage left, ChatResponseMessage right) {\n------------------------------\n------------------------------\n/**\n\t * Merge two ChatCompletionsToolCall instances into a single ChatCompletionsToolCall\n\t * instance.\n\t * @param left the left ChatCompletionsToolCall instance to merge.\n\t * @param right the right ChatCompletionsToolCall instance to merge.\n\t * @return a merged ChatCompletionsToolCall instance.\n\t */\n\tprivate static ChatCompletionsToolCall mergeChatCompletionsToolCall(ChatCompletionsToolCall left,\n\t\t\tChatCompletionsToolCall right) {\n------------------------------\n------------------------------\n/**\n\t * Filter out the non-supported fields from the options.\n\t * @param options The options to filter.\n\t * @return The filtered options.\n\t */\n\tpublic static Map<String, Object> filterNonSupportedFields(Map<String, Object> options) {\n\t\treturn options.entrySet().stream()\n\t\t\t.filter(e -> !NON_SUPPORTED_FIELDS.contains(e.getKey()))\n\t\t\t.collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));\n\t}\n\n\t@Override\n\tpublic OllamaOptions copy() {\n\t\treturn fromOptions(this);\n\t}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n# Natural Language Annotations: /**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions options = (this.defaultOptions != null) ? this.defaultOptions\n            : PostgresMlEmbeddingOptions.builder()\n                // Assuming there is a default configuration for PostgresMlEmbeddingOptions\n                .build();\n\n    // Merge the request options into the default options\n    // This would depend on the specific fields in PostgresMlEmbeddingOptions and EmbeddingOptions\n    // For example, if EmbeddingOptions has a field called 'inputType', you might do something like:\n    // options.setInputType(requestOptions.getInputType());\n\n    return options;\n}\n```\n", "```java\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions options = (this.defaultOptions != null) ? this.defaultOptions\n            : PostgresMlEmbeddingOptions.builder()\n                .withInputType(PostgresMlEmbeddingRequest.InputType.SEARCH_DOCUMENT)\n                .withTruncate(PostgresMlEmbeddingRequest.Truncate.NONE)\n                .build();\n\n    // Merge the request options with the default options\n    // ...\n\n    return options;\n}\n```\n", "```java\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions options = (this.defaultOptions != null) ? this.defaultOptions\n            : PostgresMlEmbeddingOptions.builder()\n                // Assuming the default options are constructed using a builder pattern\n                .build();\n\n    // Add your logic to merge the default and request options\n\n    return options;\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Return the dimension of the requested embedding generative name. If the generative\n\t * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n\t * count the response dimensions.\n\t * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n\t * @param modelName Embedding generative name to retrieve the dimensions for.\n\t * @param dummyContent Dummy content to use for the empirical dimension calculation.\n------------------------------\n------------------------------\n* @return Returns the embedding dimensions for the modelName.\n\t */\n------------------------------\n------------------------------\n/**\n\t * @return the number of dimensions of the embedded vectors. It is generative\n\t * specific.\n\t */\n\tdefault int dimensions() {\n\t\treturn embed(\"Test String\").length;\n\t}\n\n}\n------------------------------\n------------------------------\n*/\n\t@JsonProperty(\"p\") Float topP;\n\t/**\n\t * (optional) Specify the number of token choices the generative uses to generate the\n\t * next token.\n\t */\n\t@JsonProperty(\"k\") Integer topK;\n\t/**\n\t * (optional) Specify the maximum number of tokens to use in the generated response.\n\t */\n\t@JsonProperty(\"max_tokens\") Integer maxTokens;\n\t/**\n\t * (optional) Configure up to four sequences that the generative recognizes. After a\n------------------------------\n------------------------------\n/**\n\t * Titan Embedding request parameters.\n\t *\n\t * @param inputText The text to compute the embedding for.\n\t * @param inputImage The image to compute the embedding for. Only applicable for the 'Titan Multimodal Embeddings\n\t * G1' model.\n\t */\n\t@JsonInclude(Include.NON_NULL)\n\tpublic record TitanEmbeddingRequest(\n\t\t\t@JsonProperty(\"inputText\") String inputText,\n\t\t\t@JsonProperty(\"inputImage\") String inputImage) {\n\n\n\t\tpublic static Builder builder() {\n\t\t\treturn new Builder();\n\t\t}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n# Natural Language Annotations: /**\n\t * Return the dimension of the requested embedding generative name. If the generative\n\t * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n\t * count the response dimensions.\n\t * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n\t * @param modelName Embedding generative name to retrieve the dimensions for.\n\t * @param dummyContent Dummy content to use for the empirical dimension calculation.\n\t * @return Returns the embedding dimensions for the modelName.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    EmbeddingModel.TitanEmbeddingRequest request = EmbeddingModel.TitanEmbeddingRequest.builder()\n            .inputText(dummyContent)\n            .build();\n    float[] embeddings = embeddingModel.embed(modelName, request);\n    return embeddings.length;\n}\n```\n", "```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (embeddingModel.getName().equals(modelName)) {\n        return embeddingModel.embed(dummyContent).length;\n    } else {\n        TitanEmbeddingRequest request = new TitanEmbeddingRequest(dummyContent, null);\n        EmbeddingModel fallbackModel = new EmbeddingModel(modelName, request);\n        return fallbackModel.dimensions();\n    }\n}\n```\n", "```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (embeddingModel.supportsModel(modelName)) {\n        return embeddingModel.embed(dummyContent).length;\n    } else {\n        throw new IllegalArgumentException(\"Unknown model name: \" + modelName);\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\n------------------------------\n------------------------------\n/**\n\t\t * Factory method used to construct a new {@link PromptFilterMetadata} with the\n\t\t * given prompt index and content filter metadata.\n\t\t * @param promptIndex index of the prompt filter metadata contained in the AI\n\t\t * response.\n\t\t * @param contentFilterMetadata underlying AI provider metadata for filtering\n\t\t * applied to prompt content.\n\t\t * @return a new instance of {@link PromptFilterMetadata} with the given prompt\n\t\t * index and content filter metadata.\n\t\t */\n------------------------------\n------------------------------\n/**\n\t * Factory method used to create a new {@link PromptMetadata} composed of an\n\t * {@link Iterable} of {@link PromptFilterMetadata}.\n\t * @param iterable {@link Iterable} of {@link PromptFilterMetadata} used to compose\n\t * the {@link PromptMetadata}.\n\t * @return a new {@link PromptMetadata} composed of an {@link Iterable} of\n\t * {@link PromptFilterMetadata}.\n\t */\n\tstatic PromptMetadata of(Iterable<PromptFilterMetadata> iterable) {\n------------------------------\n------------------------------\n/**\n\t * Factory method used to create a new {@link PromptMetadata} composed of an array of\n\t * {@link PromptFilterMetadata}.\n\t * @param array array of {@link PromptFilterMetadata} used to compose the\n\t * {@link PromptMetadata}.\n\t * @return a new {@link PromptMetadata} composed of an array of\n\t * {@link PromptFilterMetadata}.\n\t */\n\tstatic PromptMetadata of(PromptFilterMetadata... array) {\n\t\treturn of(Arrays.asList(array));\n\t}\n------------------------------\n------------------------------\n/**\n\t * Creates an embedding vector representing the input text or token array.\n\t *\n\t * @param embeddingRequest The embedding request.\n\t * @return Returns list of {@link Embedding} wrapped in {@link EmbeddingList}.\n\t * @param <T> Type of the entity in the data list. Can be a {@link String} or {@link List} of tokens (e.g.\n\t * Integers). For embedding multiple inputs in a single request, You can pass a {@link List} of {@link String} or\n\t * {@link List} of {@link List} of tokens. For example:\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n# Natural Language Annotations: /**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"The prompt index must be greater than or equal to 0.\");\n    }\n    for (PromptFilterMetadata metadata : this) {\n        if (metadata.getPromptIndex() == promptIndex) {\n            return Optional.of(metadata);\n        }\n    }\n    return Optional.empty();\n}\n```\n", "```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index cannot be less than 0.\");\n    }\n    // Implementation to find PromptFilterMetadata by prompt index\n    // This will depend on the actual implementation of PromptMetadata\n    // For example, if PromptMetadata is a List, you might use a stream like this:\n    // return this.stream().filter(pm -> pm.getPromptIndex() == promptIndex).findFirst();\n}\n```\n", "```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"The prompt index cannot be less than 0.\");\n    }\n    // Implementation of finding PromptFilterMetadata by index goes here\n    // This is a placeholder and will depend on the specific implementation of the PromptMetadata class\n    return Optional.empty();\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\n\n\n\n\n\n\n\n\n}\n------------------------------\n------------------------------\npublic interface Usage {\n\n\t/**\n\t * Returns the number of tokens used in the {@literal prompt} of the AI request.\n\t * @return an {@link Long} with the number of tokens used in the {@literal prompt} of\n\t * the AI request.\n\t * @see #getGenerationTokens()\n\t */\n\tLong getPromptTokens();\n------------------------------\n------------------------------\n/**\n\t * Returns the number of tokens returned in the {@literal generation (aka completion)}\n\t * of the AI's response.\n\t * @return an {@link Long} with the number of tokens returned in the\n\t * {@literal generation (aka completion)} of the AI's response.\n\t * @see #getPromptTokens()\n\t */\n\tLong getGenerationTokens();\n------------------------------\n------------------------------\n/**\n\t * Returns the maximum number of tokens that are permitted before exhausting the rate\n\t * limit.\n\t * @return an {@link Long} with the maximum number of tokens that are permitted before\n\t * exhausting the rate limit.\n\t * @see #getTokensRemaining()\n\t */\n\tLong getTokensLimit();\n------------------------------\n------------------------------\n// GenAI Usage\n\n\t/**\n\t * The number of tokens used in the model input.\n\t */\n\tUSAGE_INPUT_TOKENS(\"gen_ai.usage.input_tokens\"),\n\t/**\n\t * The number of tokens used in the model output.\n\t */\n\tUSAGE_OUTPUT_TOKENS(\"gen_ai.usage.output_tokens\"),\n\t/**\n\t * The total number of tokens used in the model exchange.\n\t */\n\tUSAGE_TOTAL_TOKENS(\"gen_ai.usage.total_tokens\"),\n\n\t// GenAI Content\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Long getTotalTokens() {\n# Natural Language Annotations: /**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\ndefault Long getTotalTokens() {\n    /**\n     * Return the total number of tokens from both the {@literal prompt} of an AI request\n     * and {@literal generation} of the AI's response.\n     * @return the total number of tokens from both the {@literal prompt} of an AI request\n     * and {@literal generation} of the AI's response.\n     * @see #getPromptTokens()\n     * @see #getGenerationTokens()\n     */\n    return getPromptTokens() + getGenerationTokens();\n}\n```\n", "```java\ndefault Long getTotalTokens() {\n\t/**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\n\treturn getPromptTokens() + getGenerationTokens();\n}\n```\n", "```java\ndefault Long getTotalTokens() {\n\t/**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\n\treturn getPromptTokens() + getGenerationTokens();\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Transforms the input expression into a semantically equivalent one with negation\n\t * operators propagated thought the expression tree by following the negation rules:\n\t *\n\t * <pre>\n\t * \tNOT(NOT(a)) = a\n\t *\n\t * \tNOT(a AND b) = NOT(a) OR NOT(b)\n\t * \tNOT(a OR b) = NOT(a) AND NOT(b)\n\t *\n\t * \tNOT(a EQ b) = a NE b\n\t * \tNOT(a NE b) = a EQ b\n\t *\n\t * \tNOT(a GT b) = a LTE b\n\t * \tNOT(a GTE b) = a LT b\n\t *\n\t * \tNOT(a LT b) = a GTE b\n\t * \tNOT(a LTE b) = a GT b\n\t *\n------------------------------\n------------------------------\n* \tNOT(a LTE b) = a GT b\n\t *\n\t * \tNOT(a IN [...]) = a NIN [...]\n\t * \tNOT(a NIN [...]) = a IN [...]\n\t * </pre>\n\t * @param operand Filter expression to negate.\n\t * @return Returns an negation of the input expression.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Expands the IN into a semantically equivalent boolean expressions of ORs of EQs.\n\t * Useful for providers that don't provide native IN support.\n\t *\n\t * For example the <pre>\n\t * foo IN [\"bar1\", \"bar2\", \"bar3\"]\n\t * </pre>\n\t *\n\t * expression is equivalent to\n\t *\n\t * <pre>\n\t * {@code foo == \"bar1\" || foo == \"bar2\" || foo == \"bar3\" (e.g. OR(foo EQ \"bar1\" OR(foo EQ \"bar2\" OR(foo EQ \"bar3\")))}\n\t * </pre>\n\t * @param exp input IN expression.\n\t * @param context Output native expression.\n------------------------------\n------------------------------\n/**\n\t *\n\t * Expands the NIN (e.g. NOT IN) into a semantically equivalent boolean expressions of\n\t * ANDs of NEs. Useful for providers that don't provide native NIN support.<br/>\n\t *\n\t * For example the\n\t *\n\t * <pre>\n\t * foo NIN [\"bar1\", \"bar2\", \"bar3\"] (or foo NOT IN [\"bar1\", \"bar2\", \"bar3\"])\n\t * </pre>\n\t *\n\t * express is equivalent to\n\t *\n\t * <pre>\n\t * {@code foo != \"bar1\" && foo != \"bar2\" && foo != \"bar3\" (e.g. AND(foo NE \"bar1\" AND( foo NE \"bar2\" OR(foo NE \"bar3\"))) )}\n\t * </pre>\n------------------------------\n------------------------------\n/**\n\t * Recursively aggregates a list of expression into a binary tree with 'aggregateType'\n\t * join nodes.\n\t * @param aggregateType type all tree splits.\n\t * @param expressions list of expressions to aggregate.\n\t * @return Returns a binary tree expression.\n\t */\n\tprivate static Filter.Expression aggregate(Filter.ExpressionType aggregateType,\n\t\t\tList<Filter.Expression> expressions) {\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Filter.Operand negate(Filter.Operand operand) {\n# Natural Language Annotations: /**\n\t * Transforms the input expression into a semantically equivalent one with negation\n\t * operators propagated thought the expression tree by following the negation rules:\n\t *\n\t * <pre>\n\t * \tNOT(NOT(a)) = a\n\t *\n\t * \tNOT(a AND b) = NOT(a) OR NOT(b)\n\t * \tNOT(a OR b) = NOT(a) AND NOT(b)\n\t *\n\t * \tNOT(a EQ b) = a NE b\n\t * \tNOT(a NE b) = a EQ b\n\t *\n\t * \tNOT(a GT b) = a LTE b\n\t * \tNOT(a GTE b) = a LT b\n\t *\n\t * \tNOT(a LT b) = a GTE b\n\t * \tNOT(a LTE b) = a GT b\n\t *\n\t * \tNOT(a IN [...]) = a NIN [...]\n\t * \tNOT(a NIN [...]) = a IN [...]\n\t * </pre>\n\t * @param operand Filter expression to negate.\n\t * @return Returns an negation of the input expression.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.BinaryExpression) {\n        Filter.BinaryExpression binaryExpression = (Filter.BinaryExpression) operand;\n        Filter.ExpressionType type = binaryExpression.getType();\n        Filter.Operand left = negate(binaryExpression.getLeft());\n        Filter.Operand right = negate(binaryExpression.getRight());\n\n        if (type == Filter.ExpressionType.AND) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.OR, left, right);\n        } else if (type == Filter.ExpressionType.OR) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.AND, left, right);\n        } else if (type == Filter.ExpressionType.EQ) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.NE, left, right);\n        } else if (type == Filter.ExpressionType.NE) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.EQ, left, right);\n        } else if (type == Filter.ExpressionType.GT) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.LTE, left, right);\n        } else if (type == Filter.ExpressionType.GTE) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.LT, left, right);\n        } else if (type == Filter.ExpressionType.LT) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.GTE, left, right);\n        } else if (type == Filter.ExpressionType.LTE) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.GT, left, right);\n        } else if (type == Filter.ExpressionType.IN) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.NIN, left, right);\n        } else if (type == Filter.ExpressionType.NIN) {\n            return new Filter.BinaryExpression(Filter.ExpressionType.IN, left, right);\n        }\n    } else if (operand instanceof Filter.UnaryExpression) {\n        Filter.UnaryExpression unaryExpression = (Filter.UnaryExpression) operand;\n        if (unaryExpression.getType() == Filter.ExpressionType.NOT) {\n            return unaryExpression.getOperand();\n        }\n    }\n\n    return new Filter.UnaryExpression(Filter.ExpressionType.NOT, operand);\n}\n```\n", "```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Not) {\n        return ((Filter.Not) operand).getOperand();\n    } else if (operand instanceof Filter.And) {\n        return new Filter.Or(\n            negate(((Filter.And) operand).getLeft()),\n            negate(((Filter.And) operand).getRight())\n        );\n    } else if (operand instanceof Filter.Or) {\n        return new Filter.And(\n            negate(((Filter.Or) operand).getLeft()),\n            negate(((Filter.Or) operand).getRight())\n        );\n    } else if (operand instanceof Filter.Eq) {\n        return new Filter.Ne(\n            ((Filter.Eq) operand).getLeft(),\n            ((Filter.Eq) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Ne) {\n        return new Filter.Eq(\n            ((Filter.Ne) operand).getLeft(),\n            ((Filter.Ne) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Gt) {\n        return new Filter.Lte(\n            ((Filter.Gt) operand).getLeft(),\n            ((Filter.Gt) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Gte) {\n        return new Filter.Lt(\n            ((Filter.Gte) operand).getLeft(),\n            ((Filter.Gte) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Lt) {\n        return new Filter.Gte(\n            ((Filter.Lt) operand).getLeft(),\n            ((Filter.Lt) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Lte) {\n        return new Filter.Gt(\n            ((Filter.Lte) operand).getLeft(),\n            ((Filter.Lte) operand).getRight()\n        );\n    } else if (operand instanceof Filter.In) {\n        return new Filter.Nin(\n            ((Filter.In) operand).getLeft(),\n            ((Filter.In) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Nin) {\n        return new Filter.In(\n            ((Filter.Nin) operand).getLeft(),\n            ((Filter.Nin) operand).getRight()\n        );\n    } else {\n        throw new IllegalArgumentException(\"Unsupported operand type: \" + operand.getClass().getName());\n    }\n}\n```\n", "```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Not) {\n        return ((Filter.Not) operand).getOperand();\n    } else if (operand instanceof Filter.And) {\n        return new Filter.Or(\n                negate(((Filter.And) operand).getLeft()),\n                negate(((Filter.And) operand).getRight())\n        );\n    } else if (operand instanceof Filter.Or) {\n        return new Filter.And(\n                negate(((Filter.Or) operand).getLeft()),\n                negate(((Filter.Or) operand).getRight())\n        );\n    } else if (operand instanceof Filter.Eq) {\n        return new Filter.Ne(\n                ((Filter.Eq) operand).getLeft(),\n                ((Filter.Eq) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Ne) {\n        return new Filter.Eq(\n                ((Filter.Ne) operand).getLeft(),\n                ((Filter.Ne) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Gt) {\n        return new Filter.Lte(\n                ((Filter.Gt) operand).getLeft(),\n                ((Filter.Gt) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Gte) {\n        return new Filter.Lt(\n                ((Filter.Gte) operand).getLeft(),\n                ((Filter.Gte) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Lt) {\n        return new Filter.Gte(\n                ((Filter.Lt) operand).getLeft(),\n                ((Filter.Lt) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Lte) {\n        return new Filter.Gt(\n                ((Filter.Lte) operand).getLeft(),\n                ((Filter.Lte) operand).getRight()\n        );\n    } else if (operand instanceof Filter.In) {\n        return new Filter.Nin(\n                ((Filter.In) operand).getLeft(),\n                ((Filter.In) operand).getRight()\n        );\n    } else if (operand instanceof Filter.Nin) {\n        return new Filter.In(\n                ((Filter.Nin) operand).getLeft(),\n                ((Filter.Nin) operand).getRight()\n        );\n    } else {\n        throw new IllegalArgumentException(\"Unsupported operand type: \" + operand.getClass().getName());\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n------------------------------\n------------------------------\n/**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. Returns the only field names that match the\n\t * {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n------------------------------\n------------------------------\n* empty, use the {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @param acceptedFieldNames the list of field names accepted for the target object.\n\t * @return the merged object represented by the given class.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n------------------------------\n------------------------------\n* @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @return the merged object represented by the given class.\n\t */\n\tpublic static <T> T merge(Object source, Object target, Class<T> clazz) {\n\t\treturn ModelOptionsUtils.merge(source, target, clazz, null);\n\t}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n\t * empty, use the {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @param acceptedFieldNames the list of field names accepted for the target object.\n\t * @return the merged object represented by the given class.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    // Implementation goes here\n}\n```\n", "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    if (acceptedFieldNames != null && !acceptedFieldNames.isEmpty()) {\n        return ModelOptionsUtils.merge(source, target, clazz, acceptedFieldNames);\n    } else {\n        return ModelOptionsUtils.merge(source, target, clazz, null);\n    }\n}\n```\n", "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    // Your implementation here\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Converts the given object to a Map.\n\t * @param source the object to convert to a Map.\n\t * @return the converted Map.\n\t */\n------------------------------\n------------------------------\nprivate static final AtomicReference<SchemaGenerator> SCHEMA_GENERATOR_CACHE = new AtomicReference<>();\n\n\t/**\n\t * Converts the given JSON string to a Map of String and Object.\n\t * @param json the JSON string to convert to a Map.\n\t * @return the converted Map.\n\t */\n\tpublic static Map<String, Object> jsonToMap(String json) {\n\t\ttry {\n\t\t\treturn OBJECT_MAPPER.readValue(json, MAP_TYPE_REF);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n------------------------------\n------------------------------\n/**\n\t * Converts the given object to a JSON string.\n\t * @param object the object to convert to a JSON string.\n\t * @return the JSON string.\n\t */\n\tpublic static String toJsonString(Object object) {\n\t\ttry {\n\t\t\treturn OBJECT_MAPPER.writeValueAsString(object);\n\t\t}\n\t\tcatch (JsonProcessingException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n------------------------------\n------------------------------\n/**\n\t * Converts the given Map to the given class.\n\t * @param <T> the type of the class to return.\n\t * @param source the Map to convert to the given class.\n\t * @param clazz the class to convert the Map to.\n\t * @return the converted class.\n\t */\n\tpublic static <T> T mapToClass(Map<String, Object> source, Class<T> clazz) {\n\t\ttry {\n\t\t\tString json = OBJECT_MAPPER.writeValueAsString(source);\n\t\t\treturn OBJECT_MAPPER.readValue(json, clazz);\n\t\t}\n\t\tcatch (JsonProcessingException e) {\n------------------------------\n------------------------------\n* @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @return the merged object represented by the given class.\n\t */\n\tpublic static <T> T merge(Object source, Object target, Class<T> clazz) {\n\t\treturn ModelOptionsUtils.merge(source, target, clazz, null);\n\t}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<String, Object> objectToMap(Object source) {\n# Natural Language Annotations: /**\n\t * Converts the given object to a Map.\n\t * @param source the object to convert to a Map.\n\t * @return the converted Map.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        return OBJECT_MAPPER.convertValue(source, MAP_TYPE_REF);\n    }\n    catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        return OBJECT_MAPPER.convertValue(source, MAP_TYPE_REF);\n    }\n    catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n", "```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        return OBJECT_MAPPER.convertValue(source, MAP_TYPE_REF);\n    }\n    catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n------------------------------\n------------------------------\n* @param targetBeanClazz the target class, a subclass of the ChatOptions, to convert\n\t * into.\n\t * @param <T> the target class type.\n\t * @return a new instance of the targetBeanClazz with the values from the sourceBean\n\t * instance.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n------------------------------\n------------------------------\n* subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. Returns the only field names that match the\n\t * {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param targetBeanClazz the target class, a subclass of the ChatOptions, to convert\n\t * into.\n\t * @param <T> the target class type.\n\t * @return a new instance of the targetBeanClazz with the values from the sourceBean\n\t * instance.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean = null;\n    try {\n        targetBean = targetBeanClazz.newInstance();\n        Method[] methods = sourceInterfaceClazz.getMethods();\n        for (Method method : methods) {\n            String methodName = method.getName();\n            if (methodName.startsWith(\"get\")) {\n                String fieldName = methodName.substring(3);\n                String setterName = \"set\" + fieldName;\n                Method setter = targetBeanClazz.getMethod(setterName, method.getReturnType());\n                Object value = method.invoke(sourceBean);\n                if (value != null) {\n                    setter.invoke(targetBean, value);\n                }\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n    return targetBean;\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    // Your code here\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    // Implementation goes here\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n------------------------------\n------------------------------\n* subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n------------------------------\n------------------------------\n/**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. Returns the only field names that match the\n\t * {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n------------------------------\n------------------------------\n/**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    for (Method getter : sourceInterfaceClazz.getMethods()) {\n        if (getter.getName().startsWith(\"get\")) {\n            try {\n                Object sourceValue = getter.invoke(source);\n                if (sourceValue != null) {\n                    String setterName = getter.getName().replaceFirst(\"get\", \"set\");\n                    Method setter = target.getClass().getMethod(setterName, getter.getReturnType());\n                    if (overrideNonNullTargetValues || setter.invoke(target) == null) {\n                        setter.invoke(target, sourceValue);\n                    }\n                }\n            } catch (Exception e) {\n                // handle exception\n            }\n        }\n    }\n    return target;\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Method[] sourceMethods = sourceInterfaceClazz.getMethods();\n    Method[] targetMethods = target.getClass().getMethods();\n\n    for (Method sourceMethod : sourceMethods) {\n        if (sourceMethod.getName().startsWith(\"get\")) {\n            String sourceFieldName = sourceMethod.getName().substring(3);\n            try {\n                Object sourceValue = sourceMethod.invoke(source);\n                if (sourceValue != null) {\n                    for (Method targetMethod : targetMethods) {\n                        if (targetMethod.getName().startsWith(\"set\") && targetMethod.getName().substring(3).equals(sourceFieldName)) {\n                            if (overrideNonNullTargetValues) {\n                                targetMethod.invoke(target, sourceValue);\n                            } else {\n                                Object targetValue = targetMethod.invoke(target);\n                                if (targetValue == null) {\n                                    targetMethod.invoke(target, sourceValue);\n                                }\n                            }\n                        }\n                    }\n                }\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n\n    return target;\n}\n```\n", "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Method[] sourceMethods = sourceInterfaceClazz.getMethods();\n    for (Method method : sourceMethods) {\n        if (method.getName().startsWith(\"get\")) {\n            String fieldName = method.getName().substring(3);\n            try {\n                Object sourceValue = method.invoke(source);\n                if (sourceValue != null) {\n                    Method targetMethod = target.getClass().getMethod(\"set\" + fieldName, method.getReturnType());\n                    Object targetValue = targetMethod.invoke(target);\n                    if (overrideNonNullTargetValues || targetValue == null) {\n                        targetMethod.invoke(target, sourceValue);\n                    }\n                }\n            } catch (Exception e) {\n                // Handle exception\n            }\n        }\n    }\n    return target;\n}\n```\n"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic abstract class AiRuntimeHints {\n\n\tprivate static final Logger log = LoggerFactory.getLogger(AiRuntimeHints.class);\n\n\t/**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageName The name of the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\n------------------------------\n------------------------------\n/**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageClass The class in the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\n\tpublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(Class<?> packageClass) {\n\t\treturn findJsonAnnotatedClassesInPackage(packageClass.getPackageName());\n\t}\n------------------------------\n------------------------------\n/**\n\t * Finds all classes in the specified package that match the given type filter.\n\t * @param packageName The name of the package to scan for classes.\n\t * @param typeFilter The type filter used to filter the scanned classes.\n\t * @return A set of TypeReference objects representing the found classes.\n\t */\n\tpublic static Set<TypeReference> findClassesInPackage(String packageName, TypeFilter typeFilter) {\n------------------------------\n------------------------------\n/**\n\t * Returns the list of name values of the {@link JsonProperty} annotations.\n\t * @param clazz the class that contains fields annotated with {@link JsonProperty}.\n\t * @return the list of values of the {@link JsonProperty} annotations.\n\t */\n\tpublic static List<String> getJsonPropertyValues(Class<?> clazz) {\n\t\tList<String> values = new ArrayList<>();\n\t\tField[] fields = clazz.getDeclaredFields();\n\t\tfor (Field field : fields) {\n------------------------------\n------------------------------\n/**\n\t * Delete a region to group text by. If the region does not exist, this method does\n\t * nothing.\n\t * @param regionName The name of the region to delete.\n\t */\n\tpublic void removeRegion(String regionName) {\n\t\tregions.remove(regionName);\n\t\tregionArea.remove(regionName);\n\t}\n\n\t/**\n\t * Get the list of regions that have been setup.\n\t * @return A list of java.lang.String objects to identify the region names.\n\t */\n\tpublic List<String> getRegions() {\n\t\treturn regions;\n\t}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n# Natural Language Annotations: /**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageName The name of the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    try {\n        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        String path = packageName.replace('.', '/');\n        Enumeration<URL> resources = classLoader.getResources(path);\n        while (resources.hasMoreElements()) {\n            URL resource = resources.nextElement();\n            File directory = new File(resource.getFile());\n            annotatedClasses.addAll(findClassesInPackage(directory, packageName, classInfo -> {\n                try {\n                    Class<?> clazz = Class.forName(classInfo.className, false, classLoader);\n                    return clazz.getAnnotation(JsonInclude.class) != null || clazz.getAnnotation(JacksonAnnotationsInside.class) != null;\n                } catch (ClassNotFoundException e) {\n                    throw new RuntimeException(e);\n                }\n            }));\n        }\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n    return annotatedClasses;\n}\n```\n", "```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> result = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> annotatedClasses = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    annotatedClasses.addAll(reflections.getTypesAnnotatedWith(JacksonAnnotationsInside.class));\n    annotatedClasses.addAll(reflections.getTypesAnnotatedWith(JacksonAnnotationsInside.class));\n    for (Class<?> clazz : annotatedClasses) {\n        result.add(new TypeReference<?>() {\n            @Override\n            public Type getType() {\n                return clazz;\n            }\n        });\n    }\n    return result;\n}\n```\n", "```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> allClasses = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    allClasses.addAll(reflections.getTypesAnnotatedWith(JacksonAnnotationsInside.class));\n    for (Class<?> clazz : allClasses) {\n        annotatedClasses.add(new TypeReference<?>() {\n            @Override\n            public Type getType() {\n                return clazz;\n            }\n        });\n    }\n    return annotatedClasses;\n}\n```\n"]}, "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nthis.config = config;\n\n\t\t\tthis.paragraphTextExtractor = new ParagraphManager(this.document);\n\n\t\t\tthis.resourceFileName = pdfResource.getFilename();\n\t\t}\n\t\tcatch (IllegalArgumentException iae) {\n\t\t\tthrow iae;\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\n\t/**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\n------------------------------\n------------------------------\n/**\n * Uses the PDF catalog (e.g. TOC) information to split the input PDF into text paragraphs\n * and output a single {@link Document} per paragraph.\n *\n * This class provides methods for reading and processing PDF documents. It uses the\n * Apache PDFBox library for parsing PDF content and converting it into text paragraphs.\n * The paragraphs are grouped into {@link Document} objects.\n *\n * @author Christian Tzolov\n */\n------------------------------\n------------------------------\n/**\n * A document reader that leverages Apache Tika to extract text from a variety of document\n * formats, such as PDF, DOC/DOCX, PPT/PPTX, and HTML. For a comprehensive list of\n * supported formats, refer to: https://tika.apache.org/2.9.0/formats.html.\n *\n * This reader directly provides the extracted text without any additional formatting. All\n * extracted texts are encapsulated within a {@link Document} instance.\n *\n * If you require more specialized handling for PDFs, consider using the\n------------------------------\n------------------------------\n/**\n\t * Represents a document paragraph metadata and hierarchy.\n\t *\n\t * @param parent Parent paragraph that will contain a children paragraphs.\n\t * @param title Paragraph title as it appears in the PDF document.\n\t * @param level The TOC deepness level for this paragraph. The root is at level 0.\n\t * @param startPageNumber The page number in the PDF where this paragraph begins.\n\t * @param endPageNumber The page number in the PDF where this paragraph ends.\n------------------------------\n------------------------------\npublic class TikaDocumentReader implements DocumentReader {\n\n\t/**\n\t * Metadata key representing the source of the document.\n\t */\n\tpublic static final String METADATA_SOURCE = \"source\";\n\n\t/**\n\t * Parser to automatically detect the type of document and extract text.\n\t */\n\tprivate final AutoDetectParser parser;\n\n\t/**\n\t * Handler to manage content extraction.\n\t */\n\tprivate final ContentHandler handler;\n\n\t/**\n\t * Metadata associated with the document being read.\n\t */\n\tprivate final Metadata metadata;\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic List<Document> get() {\n# Natural Language Annotations: /**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic List<Document> get() {\n    List<Document> paragraphs = new ArrayList<>();\n\n    try {\n        // Use the PDF catalog (e.g. TOC) information to split the input PDF into text paragraphs\n        // and output a single Document per paragraph.\n        ParagraphManager paragraphManager = new ParagraphManager(this.document);\n\n        // Get the resource file name\n        String resourceFileName = pdfResource.getFilename();\n\n        // Read and process the PDF document to extract paragraphs\n        List<String> paragraphTexts = paragraphManager.extractParagraphs(resourceFileName);\n\n        // Create a list of Document objects representing paragraphs\n        for (String paragraphText : paragraphTexts) {\n            Document paragraph = new Document(paragraphText);\n            paragraphs.add(paragraph);\n        }\n    } catch (IllegalArgumentException iae) {\n        throw iae;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n\n    return paragraphs;\n}\n```\n", "```java\n@Override\npublic List<Document> get() {\n    try {\n        this.config = config;\n        this.paragraphTextExtractor = new ParagraphManager(this.document);\n        this.resourceFileName = pdfResource.getFilename();\n    } catch (IllegalArgumentException iae) {\n        throw iae;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n\n    List<Document> paragraphs = new ArrayList<>();\n    try {\n        String text = this.paragraphTextExtractor.extractText();\n        String[] paragraphArray = text.split(\"\\\\n\");\n        for (String paragraph : paragraphArray) {\n            paragraphs.add(new Document(paragraph));\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n    return paragraphs;\n}\n```\n", "```java\n@Override\npublic List<Document> get() {\n    List<Document> documents = new ArrayList<>();\n\n    try {\n        // Read the PDF document using PDFBox\n        PDDocument pdfDocument = PDDocument.load(new File(resourceFileName));\n\n        // Get the catalog (TOC) information\n        PDDocumentCatalog catalog = pdfDocument.getDocumentCatalog();\n\n        // Extract paragraphs from the catalog\n        List<PDPage> pages = catalog.getPages();\n        for (PDPage page : pages) {\n            // Process each page and extract paragraphs\n            List<String> paragraphs = paragraphTextExtractor.extractParagraphs(page);\n\n            // Convert each paragraph into a Document object\n            for (String paragraph : paragraphs) {\n                Document document = new Document();\n                document.setContent(paragraph);\n                documents.add(document);\n            }\n        }\n\n        pdfDocument.close();\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to read PDF document\", e);\n    }\n\n    return documents;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * If the given {@link FixedBitSet} is large enough to hold {@code numBits+1}, returns the given\n     * bits, otherwise returns a new {@link FixedBitSet} which can hold the requested number of bits.\n     *\n     * <p><b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of the given {@code\n     * bits} if possible. Also, calling {@link #length()} on the returned bits may return a value\n     * greater than {@code numBits}.\n     */\n------------------------------\n------------------------------\n/**\n   * Converts a <code>float</code> value to a sortable signed <code>int</code>. The value is\n   * converted by getting their IEEE 754 floating-point &quot;float format&quot; bit layout and then\n   * some bits are swapped, to be able to compare the result as int. By this the precision is not\n   * reduced, but the value can easily used as an int. The sort order (including {@link Float#NaN})\n   * is defined by {@link Float#compareTo}; {@code NaN} is greater than positive infinity.\n   *\n------------------------------\n------------------------------\n/**\n     * Creates a new copy of this {@link RandomAccessVectorValues}. This is helpful when you need to\n     * access different values at once, to avoid overwriting the underlying float vector returned by\n     * a shared {@link RandomAccessVectorValues#getVector}.\n     * <p>\n     * Un-shared implementations may simply return `this`.\n     */\n    RandomAccessVectorValues copy();\n------------------------------\n------------------------------\n/**\n   * Returns the index of the last set bit before or on the index specified. -1 is returned if there\n   * are no more set bits.\n   */\n  public abstract int prevSetBit(int index);\n\n  /**\n   * Returns the index of the first set bit starting at the index specified. {@link\n   * DocIdSetIterator#NO_MORE_DOCS} is returned if there are no more set bits.\n   */\n  public abstract int nextSetBit(int index);\n------------------------------\n------------------------------\n/**\n   * A {@link VarHandle} to read/write big endian {@code int} from a byte array. Shape: {@code int\n   * vh.get(byte[] arr, int ofs)} and {@code void vh.set(byte[] arr, int ofs, int val)}\n   *\n   * @deprecated Better use little endian unless it is needed for backwards compatibility.\n   */\n  @Deprecated\n  public static final VarHandle VH_BE_INT =\n      MethodHandles.byteArrayViewVarHandle(int[].class, ByteOrder.BIG_ENDIAN);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n# Natural Language Annotations: /**\n     * If the given {@link FixedBitSet} is large enough to hold {@code numBits+1}, returns the given\n     * bits, otherwise returns a new {@link FixedBitSet} which can hold the requested number of bits.\n     *\n     * <p><b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of the given {@code\n     * bits} if possible. Also, calling {@link #length()} on the returned bits may return a value\n     * greater than {@code numBits}.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() >= numBits) {\n        return bits;\n    } else {\n        return new FixedBitSet(numBits);\n    }\n}\n```\n", "```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.size() >= numBits + 1) {\n        return bits;\n    } else {\n        return new FixedBitSet(numBits + 1);\n    }\n}\n```\n", "```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() > numBits) {\n        return bits;\n    } else {\n        return new FixedBitSet(numBits + 1);\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\n\n\n\n\n\n\n\n\n\n\n    @FunctionalInterface\n    public interface IntBiConsumer<T> {\n        void consume(int key, T value);\n    }\n}\n------------------------------\n------------------------------\n/**\n * A map (but not a Map) of int -> T where the int keys are dense-ish and start at zero,\n * but the size of the map is not known in advance.  This provides fast, concurrent\n * updates and minimizes contention when the map is resized.\n * <p>\n * \"Dense-ish\" means that space is allocated for all keys from 0 to the highest key, but\n * it is valid to have gaps in the keys.  The value associated with \"gap\" keys is null.\n */\n// Code for: public class DenseIntMap<T> {\n------------------------------\n------------------------------\n/**\n * Builder for Concurrent GraphIndex. See {@link GraphIndex} for a high level overview, and the\n * comments to `addGraphNode` for details on the concurrent building approach.\n * <p>\n * GIB allocates scratch space and copies of the RandomAccessVectorValues for each thread\n * that calls `addGraphNode`.  These allocations are retained until the GIB itself is no longer referenced.\n * Under most conditions this is not something you need to worry about, but it does mean\n------------------------------\n------------------------------\n/**\n     * @return the parallel-cost residuals for each subspace and cluster\n     */\n    private Residual[][] computeResiduals(VectorFloat<?> vector) {\n        Residual[][] residuals = new Residual[codebooks.length][];\n------------------------------\n------------------------------\n/**\n     * Write the compressed vectors to the given DataOutput at the current serialization version\n     */\n    default void write(DataOutput out) throws IOException {\n        write(out, OnDiskGraphIndex.CURRENT_VERSION);\n    }\n\n    /** @return the original size of each vector, in bytes, before compression */\n    int getOriginalSize();\n\n    /** @return the compressed size of each vector, in bytes */\n    int getCompressedSize();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void forEach(IntBiConsumer<T> consumer) {\n# Natural Language Annotations: /**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < size; i++) {\n        T value = get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```\n", "```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < size(); i++) {\n        T value = get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```\n", "```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < size(); i++) {\n        T value = get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns the least element of the LongHeap in constant time. It is up to the caller to verify\n     * that the heap is not empty; no checking is done, and if no elements have been added, 0 is\n     * returned.\n     */\n    public final long top() {\n        return heap[1];\n    }\n\n    /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\n------------------------------\n------------------------------\n/**\n     * Adds a value to an LongHeap in log(size) time.\n     *\n     * @return true if the new value was added. (A fixed-size heap will not add the new value\n     * if it is full, and the new value is worse than the existing ones.)\n     */\n    public abstract boolean push(long element);\n------------------------------\n------------------------------\n/**\n     * Adds a value to an LongHeap in log(size) time.\n     *\n     * @return true always\n     */\n    @Override\n    public boolean push(long element) {\n        add(element);\n        return true;\n    }\n}\n------------------------------\n------------------------------\n/**\n * A min heap that stores longs; a primitive priority queue that like all priority queues maintains\n * a partial ordering of its elements such that the least element can always be found in constant\n * time. Push()'s and pop()'s require log(size). {@link #push(long)} may either grow the heap or\n * replace the worst element, depending on the subclass implementation.\n * <p>\n * The heap is a min heap, meaning that the top element is the lowest value.\n */\n------------------------------\n------------------------------\nprivate float decodeScore(long heapValue) {\n        return NumericUtils.sortableIntToFloat((int) (order.apply(heapValue) >> 32));\n    }\n\n    private int decodeNodeId(long heapValue) {\n        return (int) ~(order.apply(heapValue));\n    }\n\n    /** Removes the top element and returns its node id. */\n    public int pop() {\n        return decodeNodeId(heap.pop());\n    }\n\n    /** Returns a copy of the internal nodes array. Not sorted by score! */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public final long pop() {\n# Natural Language Annotations: /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic final long pop() {\n    if (isEmpty()) {\n        throw new IllegalStateException(\"The LongHeap is empty!\");\n    }\n    long min = heap[1];\n    heap[1] = heap[size--];\n    sink(1);\n    return min;\n}\n```\n", "```java\npublic final long pop() {\n    if (size <= 0) {\n        throw new IllegalStateException(\"The LongHeap is empty.\");\n    }\n    long min = heap[1];\n    heap[1] = heap[size];\n    size--;\n    heapify(1);\n    return min;\n}\n```\n", "```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"The LongHeap is empty.\");\n    }\n    long min = heap[1];\n    heap[1] = heap[size--];\n    heapify(1);\n    return min;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n     * Should be called when the top value changes.\n     * Still log(n) worst case, but it's at least twice as fast to\n     *\n     * <pre class=\"prettyprint\">\n     * pq.updateTop(value);\n     * </pre>\n     * <p>\n     * instead of\n     *\n     * <pre class=\"prettyprint\">\n     * pq.pop();\n     * pq.push(value);\n     * </pre>\n     * <p>\n------------------------------\n------------------------------\n* pq.push(value);\n     * </pre>\n     * <p>\n     * Calling this method on an empty BoundedLongHeap has no visible effect.\n     *\n     * @param value the new element that is less than the current top.\n     * @return the new 'top' element after shuffling the heap.\n     */\n------------------------------\n------------------------------\n/**\n * A min heap that stores longs; a primitive priority queue that like all priority queues maintains\n * a partial ordering of its elements such that the least element can always be found in constant\n * time. Push()'s and pop()'s require log(size). {@link #push(long)} may either grow the heap or\n * replace the worst element, depending on the subclass implementation.\n * <p>\n * The heap is a min heap, meaning that the top element is the lowest value.\n */\n------------------------------\n------------------------------\n/**\n     * Adds a new graph node to the heap.  Will extend storage or replace the worst element\n     * depending on the type of heap it is.\n     *\n     * @param newNode  the node id\n     * @param newScore the relative similarity score to the node of the owner\n     *\n     * @return true if the new value was added.\n     */\n    public boolean push(int newNode, float newScore) {\n        return heap.push(encode(newNode, newScore));\n    }\n------------------------------\n------------------------------\n/**\n     * Adds a value to an LongHeap in log(size) time.\n     *\n     * @return true if the new value was added. (A fixed-size heap will not add the new value\n     * if it is full, and the new value is worse than the existing ones.)\n     */\n    public abstract boolean push(long element);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @VisibleForTesting    long updateTop(long value) {\n# Natural Language Annotations: /**\n     * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n     * Should be called when the top value changes.\n     * Still log(n) worst case, but it's at least twice as fast to\n     *\n     * <pre class=\"prettyprint\">\n     * pq.updateTop(value);\n     * </pre>\n     * <p>\n     * instead of\n     *\n     * <pre class=\"prettyprint\">\n     * pq.pop();\n     * pq.push(value);\n     * </pre>\n     * <p>\n     * Calling this method on an empty BoundedLongHeap has no visible effect.\n     *\n     * @param value the new element that is less than the current top.\n     * @return the new 'top' element after shuffling the heap.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (isEmpty()) {\n        return Long.MIN_VALUE;\n    }\n    long oldTop = getTop();\n    if (value >= oldTop) {\n        return oldTop;\n    }\n    removeTop();\n    insert(value);\n    return getTop();\n}\n```\n", "```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (isEmpty()) {\n        return Long.MIN_VALUE;\n    }\n\n    long oldTop = peek();\n    if (value >= oldTop) {\n        return oldTop;\n    }\n\n    remove(oldTop);\n    add(value);\n    return peek();\n}\n```\n", "```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (isEmpty()) {\n        return Long.MIN_VALUE;\n    }\n\n    long oldTop = heap[0];\n    heap[0] = value;\n    siftDown(0);\n\n    return oldTop;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n@Override\n    public ScoreFunction.ApproximateScoreFunction precomputedScoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n        return scoreFunctionFor(q, similarityFunction);\n    }\n\n    /**\n     * Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n     * is a useful approximation for cosine distance and not really anything else.\n     */\n------------------------------\n------------------------------\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.Objects;\nimport java.util.concurrent.ForkJoinPool;\nimport java.util.stream.IntStream;\n\n/**\n * Binary Quantization of float vectors: each float is compressed to a single bit,\n * and similarity is computed with a simple Hamming distance.\n */\n// Code for: public class BinaryQuantization implements VectorCompressor<long[]> {\n------------------------------\n------------------------------\n* @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n------------------------------\n------------------------------\n/**\n     * Chooses the initial centroids for clustering.\n     * The first centroid is chosen randomly from the data points. Subsequent centroids\n     * are selected with a probability proportional to the square of their distance\n     * to the nearest existing centroid. This ensures that the centroids are spread out\n     * across the data and not initialized too closely to each other, leading to better\n     * convergence and potentially improved final clusterings.\n     *\n------------------------------\n------------------------------\n/**\n   * Cosine similarity. NOTE: the preferred way to perform cosine similarity is to normalize all\n   * vectors to unit length, and instead use {@link VectorSimilarityFunction#DOT_PRODUCT}. You\n   * should only use this function if you need to preserve the original vectors and cannot normalize\n   * them in advance. The similarity score is normalised to assure it is positive.\n   */\n  COSINE {\n    @Override\n    public float compare(VectorFloat<?> v1, VectorFloat<?> v2) {\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n     * is a useful approximation for cosine distance and not really anything else.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    // Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n    // is a useful approximation for cosine distance and not really anything else.\n    // Implementation of the score function goes here.\n    // This could be a simple Hamming distance calculation or a more complex scoring function.\n}\n```\n", "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    // Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n    // is a useful approximation for cosine distance and not really anything else.\n    // Implementation of the function goes here...\n}\n```\n", "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    // Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n    // is a useful approximation for cosine distance and not really anything else.\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public float score(VectorFloat<?> v) {\n            // Implement your scoring function here\n            // For example, if `similarityFunction` is COSINE, you can use the following code:\n            // return 1 - (float) VectorSimilarityFunction.COSINE.compare(q, v);\n            // If you don't care about the `similarityFunction`, you can always return a constant score:\n            return 0;\n        }\n    };\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n* @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n------------------------------\n------------------------------\n/**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param clusterCount number of clusters per subspace\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n------------------------------\n------------------------------\n/**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     */\n    public static ProductQuantization compute(RandomAccessVectorValues ravv, int M, int clusterCount, boolean globallyCenter) {\n------------------------------\n------------------------------\n*                         an HNSW graph will be created, which is usually not what you want.\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n     *                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\n    public GraphIndexBuilder(BuildScoreProvider scoreProvider,\n                             int dimension,\n------------------------------\n------------------------------\n*                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ProductQuantization compute(\n# Natural Language Annotations: /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param clusterCount number of clusters per subspace\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     * @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n     *                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static ProductQuantization compute(\n    RandomAccessVectorValues ravv, \n    int M, \n    int clusterCount, \n    boolean globallyCenter,\n    double anisotropicThreshold,\n    ForkJoinPool simdExecutor,\n    ForkJoinPool parallelExecutor\n) {\n    // Your code here\n}\n```\n", "```java\npublic static ProductQuantization compute(\n    RandomAccessVectorValues ravv, \n    int M, \n    int clusterCount, \n    boolean globallyCenter, \n    double anisotropicThreshold, \n    ForkJoinPool simdExecutor, \n    ForkJoinPool parallelExecutor) {\n\n    // Your implementation here\n\n}\n```\n", "```java\npublic static ProductQuantization compute(\n    RandomAccessVectorValues ravv, \n    int M, \n    int clusterCount, \n    boolean globallyCenter, \n    double anisotropicThreshold, \n    ForkJoinPool simdExecutor, \n    ForkJoinPool parallelExecutor) {\n    // Implementation here...\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\n------------------------------\n------------------------------\n/**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     */\n    public ProductQuantization refine(RandomAccessVectorValues ravv) {\n        return refine(ravv, 1, UNWEIGHTED, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n    }\n------------------------------\n------------------------------\n/**\n     * Create a sequence from the given data.\n     *\n     * @param data the data to create the sequence from. Supported data types are implementation-dependent.\n     * @return the created vector.\n     */\n    ByteSequence<?> createByteSequence(Object data);\n\n    /**\n     * Create a zero-filled sequence of the given length.\n     * @param length the length of the sequence to create.\n     * @return the created sequence.\n     */\n    ByteSequence<?> createByteSequence(int length);\n------------------------------\n------------------------------\npublic interface VectorTypeSupport {\n    /**\n     * Create a vector from the given data.\n     *\n     * @param data the data to create the vector from. Supported data types are implementation-dependent.\n     * @return the created vector.\n     */\n    VectorFloat<?> createFloatVector(Object data);\n------------------------------\n------------------------------\n/**\n   * Calculates the sum of sparse points in a vector.\n   * <p>\n   * This assumes the data vector is a 2d matrix which has been flattened into 1 dimension\n   * so rather than data[n][m] it's data[n * m].  With this layout this method can quickly\n   * assemble the data from this heap and sum it.\n   *\n   * @param data the vector of all datapoints\n   * @param baseIndex the start of the data in the offset table\n   *                  (scaled by the index of the lookup table)\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ProductQuantization refine(RandomAccessVectorValues ravv,\n# Natural Language Annotations: /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Your implementation here\n}\n```\n", "```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Your implementation here\n}\n```\n", "```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Your implementation here\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\n------------------------------\n------------------------------\nprivate ByteSequence<?> encodeUnweighted(VectorFloat<?> vector) {\n        var encoded = vectorTypeSupport.createByteSequence(M);\n        for (int m = 0; m < M; m++) {\n            encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n        }\n        return encoded;\n    }\n\n    /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\n------------------------------\n------------------------------\n/**\n     * Encodes the given vectors in parallel using the PQ codebooks.\n     */\n    @Override\n    public ByteSequence<?>[] encodeAll(RandomAccessVectorValues ravv, ForkJoinPool simdExecutor) {\n        return simdExecutor.submit(() -> IntStream.range(0, ravv.size())\n                        .parallel()\n                        .mapToObj(i -> encode(ravv.getVector(i)))\n                        .toArray(ByteSequence<?>[]::new))\n                .join();\n    }\n------------------------------\n------------------------------\n// Uses the algorithm given in appendix 7.5 of \"Accelerating Large-Scale Inference with Anisotropic Vector Quantization\"\n    private void updateCentroidsAnisotropic() {\n        int dimensions = points[0].length();\n        float pcm = computeParallelCostMultiplier(anisotropicThreshold, dimensions);\n        // in most places we simplify\n        //   loss = pcm' * parallel + ocm' * orthogonal\n        // with pcm = pcm' / ocm', so\n        //   loss ~ pcm * parallel + orthogonal\n------------------------------\n------------------------------\n/**\n     * @return number of clusters per subspace\n     */\n    public int getClusterCount() {\n        return clusterCount;\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["Sure, here is the function `encodeAnisotropic` based on your specifications:\n\n```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```\n", "```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    int dimensions = points[0].length();\n    float pcm = computeParallelCostMultiplier(anisotropicThreshold, dimensions);\n    for (int m = 0; m < M; m++) {\n        float minLoss = Float.MAX_VALUE;\n        int minIndex = -1;\n        for (int i = 0; i < codebooks[m].size(); i++) {\n            VectorFloat<?> centroid = codebooks[m].get(i);\n            float parallel = vector.subtract(centroid).norm();\n            float orthogonal = vector.subtract(centroid).norm();\n            float loss = pcm * parallel + orthogonal;\n            if (loss < minLoss) {\n                minLoss = loss;\n                minIndex = i;\n            }\n        }\n        encoded.set(m, (byte) minIndex);\n    }\n    return encoded;\n}\n```\n", "```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    float pcm = computeParallelCostMultiplier(anisotropicThreshold, vector.length());\n    for (int m = 0; m < M; m++) {\n        float minLoss = Float.MAX_VALUE;\n        int bestIndex = -1;\n        for (int i = 0; i < codebooks[m].length; i++) {\n            float loss = vector.loss(codebooks[m][i]);\n            float parallelLoss = pcm * vector.parallelLoss(codebooks[m][i]);\n            float orthogonalLoss = loss - parallelLoss;\n            float totalLoss = parallelLoss + orthogonalLoss;\n            if (totalLoss < minLoss) {\n                minLoss = totalLoss;\n                bestIndex = i;\n            }\n        }\n        encoded.set(m, (byte) bestIndex);\n    }\n    return encoded;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\n------------------------------\n------------------------------\nprivate ByteSequence<?> encodeUnweighted(VectorFloat<?> vector) {\n        var encoded = vectorTypeSupport.createByteSequence(M);\n        for (int m = 0; m < M; m++) {\n            encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n        }\n        return encoded;\n    }\n\n    /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\n------------------------------\n------------------------------\n/**\n     * Encodes the given vectors in parallel using the PQ codebooks.\n     */\n    @Override\n    public ByteSequence<?>[] encodeAll(RandomAccessVectorValues ravv, ForkJoinPool simdExecutor) {\n        return simdExecutor.submit(() -> IntStream.range(0, ravv.size())\n                        .parallel()\n                        .mapToObj(i -> encode(ravv.getVector(i)))\n                        .toArray(ByteSequence<?>[]::new))\n                .join();\n    }\n------------------------------\n------------------------------\n/**\n     * @return number of clusters per subspace\n     */\n    public int getClusterCount() {\n        return clusterCount;\n    }\n------------------------------\n------------------------------\n/**\n     * Encodes the input vector\n     *\n     * @return one bit per original f32\n     */\n    @Override\n    public long[] encode(VectorFloat<?> v) {\n        int M = (int) Math.ceil(v.length() / 64.0);\n        long[] encoded = new long[M];\n        for (int i = 0; i < M; i++) {\n            long bits = 0;\n            for (int j = 0; j < 64; j++) {\n                int idx = i * 64 + j;\n                if (idx >= v.length()) {\n                    break;\n                }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ByteSequence<?> encode(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```\n", "```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```\n", "```java\nprivate ByteSequence<?> encode(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\n\n\n\n\n\n\n\n    /**\n     * @return how many bytes we are compressing to\n     */\n    public int getSubspaceCount() {\n        return M;\n    }\n------------------------------\n------------------------------\n* @param quantizedPartialSquaredMagnitudes The quantized precomputed squared magnitudes of each codebook entry. Quantized through the\n   *                                          same process as quantizedPartialSums.\n   * @param magnitudeDelta The delta used to quantize quantizedPartialSquaredMagnitudes.\n   * @param minMagnitude The minimum magnitude used to quantize quantizedPartialSquaredMagnitudes.\n   * @param queryMagnitudeSquared The squared magnitude of the query vector.\n------------------------------\n------------------------------\n*\n   * The caller is responsible for ensuring than no value in partialSums is larger than its corresponding partialBase.\n   *\n   * @param delta the divisor to use for quantization\n   * @param partials the values to quantize\n   * @param partialBases the base values to subtract from the partials\n   * @param quantizedPartials the output sequence to store the quantized values\n   */\n------------------------------\n------------------------------\n/**\n     * Create a zero-filled vector of the given length.\n     * @param length the length of the vector to create.\n     * @return the created vector.\n     */\n    VectorFloat<?> createFloatVector(int length);\n------------------------------\n------------------------------\n/**\n   * This method returns the maximum representation size of an object. <code>sizeSoFar</code> is the\n   * object's size measured so far. <code>f</code> is the field being probed.\n   *\n   * <p>The returned offset will be the maximum of whatever was measured so far and <code>f</code>\n   * field's offset and representation size (unaligned).\n   */\n  public static long adjustForField(long sizeSoFar, final Field f) {\n    final Class<?> type = f.getType();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Implementation goes here.\n}\n```\n", "```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Implementation here\n}\n```\n", "```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Your code here\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\n\n\n\n\n\n\n\n    /**\n     * @return how many bytes we are compressing to\n     */\n    public int getSubspaceCount() {\n        return M;\n    }\n------------------------------\n------------------------------\n/**\n     * Write the compressed vectors to the given DataOutput at the current serialization version\n     */\n    default void write(DataOutput out) throws IOException {\n        write(out, OnDiskGraphIndex.CURRENT_VERSION);\n    }\n\n    /** @return the original size of each vector, in bytes, before compression */\n    int getOriginalSize();\n\n    /** @return the compressed size of each vector, in bytes */\n    int getCompressedSize();\n------------------------------\n------------------------------\nimport static java.lang.Math.min;\n\n/**\n * NodeArray encodes nodeids and their scores relative to some other element \n * (a query vector, or another graph node) as a pair of growable arrays. \n * Nodes are arranged in the sorted order of their scores in descending order,\n * i.e. the most-similar nodes are first.\n */\n// Code for: public class NodeArray {\n------------------------------\n------------------------------\n*\n   * The caller is responsible for ensuring than no value in partialSums is larger than its corresponding partialBase.\n   *\n   * @param delta the divisor to use for quantization\n   * @param partials the values to quantize\n   * @param partialBases the base values to subtract from the partials\n   * @param quantizedPartials the output sequence to store the quantized values\n   */\n------------------------------\n------------------------------\n/**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    int size = encoded.size();\n    float[] targetArray = target.getArray();\n    float[] centroid = new float[size];\n    for (int i = 0; i < size; i++) {\n        centroid[i] = getCentroid(i);\n    }\n    for (int i = 0; i < size; i++) {\n        targetArray[i] = centroid[i] + encoded.get(i);\n    }\n}\n```\n", "```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Code to decode the quantized representation to its approximate original vector relative to the global centroid\n}\n```\n", "```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Decode the quantized representation to its approximate original vector, relative to the global centroid.\n    // The caller is responsible for ensuring that no value in partialSums is larger than its corresponding partialBase.\n\n    int delta = getSubspaceCount(); // get the divisor to use for quantization\n    int[] partials = encoded.getPartials(); // get the values to quantize\n    int[] partialBases = encoded.getPartialBases(); // get the base values to subtract from the partials\n    int[] quantizedPartials = new int[partials.length]; // output sequence to store the quantized values\n\n    for (int i = 0; i < partials.length; i++) {\n        quantizedPartials[i] = partials[i] - partialBases[i]; // subtract the base from the partial to get the quantized value\n        quantizedPartials[i] /= delta; // divide the quantized value by the delta to get the final value\n    }\n\n    // Set the quantized values in the target vector\n    for (int i = 0; i < target.getDimension(); i++) {\n        target.set(i, quantizedPartials[i]);\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (VectorFloat<?> row : data) {\n            sb.append(row.toString());\n            sb.append(\"\\n\");\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\n------------------------------\n------------------------------\n/**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\n------------------------------\n------------------------------\npackage io.github.jbellis.jvector.vector;\n\nimport io.github.jbellis.jvector.vector.types.VectorFloat;\nimport io.github.jbellis.jvector.vector.types.VectorTypeSupport;\n\nimport static java.lang.Math.abs;\n\n/**\n * Matrix object where each row is a VectorFloat; this makes multiplication of a matrix by a vector\n * a series of efficient dot products.\n */\n// Code for: public class Matrix {\n------------------------------\n------------------------------\n/**\n         * @return the node of the graph to start searches at\n         */\n        int entryNode();\n\n        /**\n         * Return a Bits instance indicating which nodes are live.  The result is undefined for\n         * ordinals that do not correspond to nodes in the graph.\n         */\n        Bits liveNodes();\n------------------------------\n------------------------------\n/**\n     * Chooses the initial centroids for clustering.\n     * The first centroid is chosen randomly from the data points. Subsequent centroids\n     * are selected with a probability proportional to the square of their distance\n     * to the nearest existing centroid. This ensures that the centroids are spread out\n     * across the data and not initialized too closely to each other, leading to better\n     * convergence and potentially improved final clusterings.\n     *\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public Matrix invert() {\n# Natural Language Annotations: /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic Matrix invert() {\n    int n = data.size();\n    Matrix result = new Matrix(n, n);\n    Matrix temp = new Matrix(this);\n\n    // Create identity matrix\n    for (int i = 0; i < n; i++) {\n        result.set(i, i, 1);\n    }\n\n    // Gaussian elimination\n    for (int i = 0; i < n; i++) {\n        int pivotRow = i;\n        for (int j = i + 1; j < n; j++) {\n            if (abs(temp.get(j, i)) > abs(temp.get(pivotRow, i))) {\n                pivotRow = j;\n            }\n        }\n        temp.swapRows(i, pivotRow);\n        result.swapRows(i, pivotRow);\n\n        for (int j = i + 1; j < n; j++) {\n            double factor = temp.get(j, i) / temp.get(i, i);\n            temp.rowSubtract(j, i, factor);\n            result.rowSubtract(j, i, factor);\n        }\n    }\n\n    // Back substitution\n    for (int i = n - 1; i >= 0; i--) {\n        for (int j = i - 1; j >= 0; j--) {\n            double factor = temp.get(j, i) / temp.get(i, i);\n            temp.rowSubtract(j, i, factor);\n            result.rowSubtract(j, i, factor);\n        }\n    }\n\n    // Normalize rows\n    for (int i = 0; i < n; i++) {\n        double factor = temp.get(i, i);\n        temp.rowDivide(i, factor);\n        result.rowDivide(i, factor);\n    }\n\n    return result;\n}\n```\n", "```java\npublic Matrix invert() {\n    // Implementation of the inverse function using Gaussian elimination goes here\n}\n```\n", "```java\npublic Matrix invert() {\n    // Your code here\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\n------------------------------\n------------------------------\npublic final class VectorUtil {\n\n  private static final VectorUtilSupport impl =\n      VectorizationProvider.getInstance().getVectorUtilSupport();\n\n  private VectorUtil() {}\n\n  /**\n   * Returns the vector dot product of the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\n------------------------------\n------------------------------\n/**\n   * Returns the sum of squared differences of the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\n  public static float squareL2Distance(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n      throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n    float r = impl.squareDistance(a, b);\n------------------------------\n------------------------------\npublic interface VectorUtilSupport {\n\n  /** Calculates the dot product of the given float arrays. */\n  float dotProduct(VectorFloat<?> a, VectorFloat<?> b);\n\n  /** Calculates the dot product of float arrays of differing sizes, or a subset of the data */\n  float dotProduct(VectorFloat<?> a, int aoffset, VectorFloat<?> b, int boffset, int length);\n\n  /** Returns the cosine similarity between the two vectors. */\n  float cosine(VectorFloat<?> v1, VectorFloat<?> v2);\n------------------------------\n------------------------------\n/** Calculates the cosine similarity of VectorFloats of differing sizes, or a subset of the data */\n  float cosine(VectorFloat<?> a, int aoffset, VectorFloat<?> b, int boffset, int length);\n\n  /** Returns the sum of squared differences of the two vectors. */\n  float squareDistance(VectorFloat<?> a, VectorFloat<?> b);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n# Natural Language Annotations: /**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n  if (a.length() != b.length()) {\n    throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!\" + b.length());\n  }\n  float dotProduct = impl.dotProduct(a, b);\n  float magnitudeA = impl.magnitude(a);\n  float magnitudeB = impl.magnitude(b);\n  return dotProduct / (magnitudeA * magnitudeB);\n}\n```\n", "```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n  if (a.length() != b.length()) {\n    throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!\" + b.length());\n  }\n  float dotProduct = VectorUtil.impl.dotProduct(a, b);\n  float magnitudeA = (float) Math.sqrt(VectorUtil.impl.dotProduct(a, a));\n  float magnitudeB = (float) Math.sqrt(VectorUtil.impl.dotProduct(b, b));\n  if (magnitudeA == 0 || magnitudeB == 0) {\n    throw new IllegalArgumentException(\"One or both vectors have zero magnitude\");\n  }\n  return dotProduct / (magnitudeA * magnitudeB);\n}\n```\n", "```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n  if (a.length() != b.length()) {\n    throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \" != \" + b.length());\n  }\n  float dotProduct = impl.dotProduct(a, b);\n  float magnitudeA = impl.magnitude(a);\n  float magnitudeB = impl.magnitude(b);\n  if (magnitudeA == 0 || magnitudeB == 0) {\n    throw new IllegalArgumentException(\"One or both vectors have zero magnitude\");\n  }\n  return dotProduct / (magnitudeA * magnitudeB);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Call GraphSearcher constructor instead\n     */\n    @Deprecated\n    public static class Builder {\n        private final GraphIndex.View view;\n\n        public Builder(GraphIndex.View view) {\n            this.view = view;\n        }\n------------------------------\n------------------------------\n*                        resurfaced if `resume` is called.  This is intended for use when combining results\n     *                        from multiple indexes.\n     * @param acceptOrds      a Bits instance indicating which nodes are acceptable results.\n     *                        If {@link Bits#ALL}, all nodes are acceptable.\n     *                        It is caller's responsibility to ensure that there are enough acceptable nodes\n------------------------------\n------------------------------\n*                        If {@link Bits#ALL}, all nodes are acceptable.\n     *                        It is caller's responsibility to ensure that there are enough acceptable nodes\n     *                        that we don't search the entire graph trying to satisfy topK.\n     * @return a SearchResult containing the topK results and the number of nodes visited during the search.\n     */\n    public SearchResult search(SearchScoreProvider scoreProvider,\n------------------------------\n------------------------------\n*                        If {@link Bits#ALL}, all nodes are acceptable.\n     *                        It is caller's responsibility to ensure that there are enough acceptable nodes\n     *                        that we don't search the entire graph trying to satisfy topK.\n     * @return a SearchResult containing the topK results and the number of nodes visited during the search.\n     */\n    public SearchResult search(SearchScoreProvider scoreProvider,\n------------------------------\n------------------------------\n/**\n     * Convenience method to create an ExactScoreFunction for reranking.  The resulting function is NOT thread-safe.\n     */\n\n\n\n\n\n\n\n\n\n\n\n}\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n# Natural Language Annotations: /**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    int n = vectors.size();\n    Object[] ids = vectors.getIDs();\n    float[] scores = new float[n];\n\n    for (int i = 0; i < n; i++) {\n        scores[i] = similarityFunction.similarity(queryVector, vectors.vectorAt(i));\n    }\n\n    PriorityQueue<SearchResult.Result> queue = new PriorityQueue<>(topK);\n    for (int i = 0; i < n; i++) {\n        if (acceptOrds.get(i)) {\n            queue.offer(new SearchResult.Result(ids[i], scores[i]));\n            if (queue.size() > topK) {\n                queue.poll();\n            }\n        }\n    }\n\n    List<SearchResult.Result> results = new ArrayList<>(queue);\n    Collections.sort(results, Collections.reverseOrder());\n\n    return new SearchResult(results, n);\n}\n```\n", "```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    GraphSearcher searcher = new GraphSearcher(graph, vectors, similarityFunction);\n    SearchScoreProvider scoreProvider = new ExactScoreFunction(queryVector, similarityFunction);\n    return searcher.search(scoreProvider, topK, acceptOrds);\n}\n```\n", "```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    // Create a new GraphSearcher instance\n    GraphSearcher searcher = new GraphSearcher(graph, vectors);\n\n    // Create a new ScoreProvider based on the query vector and similarity function\n    SearchScoreProvider scoreProvider = new ExactScoreFunction(queryVector, similarityFunction);\n\n    // Perform the search\n    return searcher.search(scoreProvider, acceptOrds, topK);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nprivate float decodeScore(long heapValue) {\n        return NumericUtils.sortableIntToFloat((int) (order.apply(heapValue) >> 32));\n    }\n\n    private int decodeNodeId(long heapValue) {\n        return (int) ~(order.apply(heapValue));\n    }\n\n    /** Removes the top element and returns its node id. */\n    public int pop() {\n        return decodeNodeId(heap.pop());\n    }\n\n    /** Returns a copy of the internal nodes array. Not sorted by score! */\n------------------------------\n------------------------------\n/**\n * NodeQueue uses a {@link io.github.jbellis.jvector.util.AbstractLongHeap} to store lists of nodes in a graph,\n * represented as a node id with an associated score packed together as a sortable long, which is sorted\n * primarily by score. The queue {@link #push(int, float)} operation provides either fixed-size\n * or unbounded operations, depending on the implementation subclasses, and either maxheap or minheap behavior.\n */\n// Code for: public class NodeQueue {\n------------------------------\n------------------------------\nimport static java.lang.Math.min;\n\n/**\n * NodeArray encodes nodeids and their scores relative to some other element \n * (a query vector, or another graph node) as a pair of growable arrays. \n * Nodes are arranged in the sorted order of their scores in descending order,\n * i.e. the most-similar nodes are first.\n */\n// Code for: public class NodeArray {\n------------------------------\n------------------------------\npublic interface GraphIndex extends AutoCloseable, Accountable {\n    /** Returns the number of nodes in the graph */\n    int size();\n\n    /**\n     * Get all node ordinals included in the graph. The nodes are NOT guaranteed to be\n     * presented in any particular order.\n     *\n     * @return an iterator over nodes where {@code nextInt} returns the next node.\n     */\n    NodesIterator getNodes();\n------------------------------\n------------------------------\npublic void markNodeDeleted(int node) {\n        graph.markDeleted(node);\n    }\n\n    /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int[] nodesCopy() {\n# Natural Language Annotations: /** Returns a copy of the internal nodes array. Not sorted by score! */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic int[] nodesCopy() {\n    int[] copy = new int[size()];\n    NodesIterator iterator = getNodes();\n    for (int i = 0; i < copy.length; i++) {\n        copy[i] = iterator.nextInt();\n    }\n    return copy;\n}\n```\n", "```java\npublic int[] nodesCopy() {\n    int[] copyArray = new int[size()];\n    NodesIterator iterator = getNodes();\n    for (int i = 0; iterator.hasNext(); i++) {\n        copyArray[i] = iterator.nextInt();\n    }\n    return copyArray;\n}\n```\n", "```java\npublic int[] nodesCopy() {\n    int[] copy = new int[size()];\n    NodesIterator iterator = getNodes();\n    for (int i = 0; i < copy.length; i++) {\n        copy[i] = iterator.nextInt();\n    }\n    return copy;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Rerank results and return the worst approximate score that made it into the topK.\n     * The topK results will be placed into `reranked`, and the remainder into `unused`.\n     * <p>\n     * Only the best result or results whose approximate score is at least `rerankFloor` will be reranked.\n     */\n------------------------------\n------------------------------\n* @param rerankFloor     (Experimental!) Candidates whose approximate similarity is at least this value\n     *                        will be reranked with the exact score (which requires loading a high-res vector from disk)\n     *                        and included in the final results.  (Potentially leaving fewer than topK entries\n     *                        in the results.)  Other candidates will be discarded, but will be potentially\n------------------------------\n------------------------------\n/**\n     * @param scoreProvider   provides functions to return the similarity of a given node to the query vector\n     * @param topK            the number of results to look for. With threshold=0, the search will continue until at least\n     *                        `topK` results have been found, or until the entire graph has been searched.\n     * @param rerankK         the number of (approximately-scored) results to rerank before returning the best `topK`.\n------------------------------\n------------------------------\n/**\n     * @param scoreProvider   provides functions to return the similarity of a given node to the query vector\n     * @param topK            the number of results to look for. With threshold=0, the search will continue until at least\n     *                        `topK` results have been found, or until the entire graph has been searched.\n     * @param threshold       the minimum similarity (0..1) to accept; 0 will accept everything. May be used\n------------------------------\n------------------------------\n/**\n     * @param scoreFunction the primary, fast scoring function\n     * @param reranker optional reranking function\n     * Generally, reranker will be null iff scoreFunction is an ExactScoreFunction.  However,\n     * it is allowed, and sometimes useful, to only perform approximate scoring without reranking.\n     * <p>\n     * Most often it will be convenient to get the reranker either using `ExactScoreFunction.from`\n     * or `ScoringView.rerankerFor`.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n# Natural Language Annotations: /**\n     * Rerank results and return the worst approximate score that made it into the topK.\n     * The topK results will be placed into `reranked`, and the remainder into `unused`.\n     * <p>\n     * Only the best result or results whose approximate score is at least `rerankFloor` will be reranked.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    // Your code here\n}\n```\n", "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    // Implement your function here\n}\n```\n", "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    // Initialize worst approximate score to be the lowest possible value\n    float worstApproximateScore = Float.MIN_VALUE;\n    // Initialize a priority queue to store the reranked results\n    PriorityQueue<Node> rerankedQueue = new PriorityQueue<>(topK, new Comparator<Node>() {\n        @Override\n        public int compare(Node n1, Node n2) {\n            return Float.compare(n1.getScore(), n2.getScore());\n        }\n    });\n    // Iterate over the unused nodes\n    while (!unused.isEmpty()) {\n        Node node = unused.poll();\n        // If the approximate score of the node is at least rerankFloor, rerank it\n        if (node.getApproximateScore() >= rerankFloor) {\n            node.setScore(reranker.rerank(node));\n            // If the reranked queue is full, remove the worst node\n            if (rerankedQueue.size() == topK) {\n                Node worstNode = rerankedQueue.poll();\n                // Update the worst approximate score\n                worstApproximateScore = Math.max(worstApproximateScore, worstNode.getApproximateScore());\n            }\n            // Add the reranked node to the queue\n            rerankedQueue.offer(node);\n        } else {\n            // Add the node to the reranked queue\n            rerankedQueue.offer(node);\n            // Update the worst approximate score\n            worstApproximateScore = Math.max(worstApproximateScore, node.getApproximateScore());\n        }\n    }\n    // Move the reranked nodes from the queue to the reranked queue\n    while (!rerankedQueue.isEmpty()) {\n        reranked.offer(rerankedQueue.poll());\n    }\n    return worstApproximateScore;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n// this idiosyncratic constructor exists for the benefit of subclass ConcurrentNeighborMap\n    protected NodeArray(NodeArray nodeArray) {\n        this.size = nodeArray.size();\n        this.nodes = nodeArray.nodes;\n        this.scores = nodeArray.scores;\n    }\n\n    /** always creates a new NodeArray to return, even when a1 or a2 is empty */\n------------------------------\n------------------------------\n/**\n     * Map old ordinals (in the graph as constructed) to new ordinals (written to disk).\n     * Should always return a valid ordinal (between 0 and maxOrdinal).\n     */\n    int oldToNew(int oldOrdinal);\n\n    /**\n     * Map new ordinals (written to disk) to old ordinals (in the graph as constructed).\n     * May return OMITTED if there is a \"hole\" at the new ordinal.\n     */\n    int newToOld(int newOrdinal);\n------------------------------\n------------------------------\n/**\n     * Returns a Bits that is true when `bits` is false, and false when `bits` is true\n     */\n    static Bits inverseOf(Bits bits) {\n        return new Bits() {\n            @Override\n            public boolean get(int index) {\n                return !bits.get(index);\n            }\n        };\n    }\n------------------------------\n------------------------------\n/**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\n------------------------------\n------------------------------\n*                        with a large topK to find (approximately) all nodes above the given threshold.\n     *                        If threshold > 0 then the search will stop when it is probabilistically unlikely\n     *                        to find more nodes above the threshold, even if `topK` results have not yet been found.\n     * @param acceptOrds      a Bits instance indicating which nodes are acceptable results.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static NodeArray merge(NodeArray a1, NodeArray a2) {\n# Natural Language Annotations: /** always creates a new NodeArray to return, even when a1 or a2 is empty */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray mergedArray = new NodeArray(a1.size + a2.size);\n    int i = 0, j = 0;\n    while (i < a1.size && j < a2.size) {\n        if (a1.scores[i] < a2.scores[j]) {\n            mergedArray.add(a1.nodes[i], a1.scores[i]);\n            i++;\n        } else {\n            mergedArray.add(a2.nodes[j], a2.scores[j]);\n            j++;\n        }\n    }\n    while (i < a1.size) {\n        mergedArray.add(a1.nodes[i], a1.scores[i]);\n        i++;\n    }\n    while (j < a2.size) {\n        mergedArray.add(a2.nodes[j], a2.scores[j]);\n        j++;\n    }\n    return mergedArray;\n}\n```\n", "```\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray mergedArray = new NodeArray();\n\n    if (a1 != null) {\n        for (int i = 0; i < a1.size(); i++) {\n            mergedArray.add(a1.get(i));\n        }\n    }\n\n    if (a2 != null) {\n        for (int i = 0; i < a2.size(); i++) {\n            mergedArray.add(a2.get(i));\n        }\n    }\n\n    return mergedArray;\n}\n```\n", "```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray mergedArray = new NodeArray();\n    int i = 0, j = 0;\n\n    while (i < a1.size() && j < a2.size()) {\n        if (a1.scores[i] < a2.scores[j]) {\n            mergedArray.add(a1.nodes[i], a1.scores[i]);\n            i++;\n        } else {\n            mergedArray.add(a2.nodes[j], a2.scores[j]);\n            j++;\n        }\n    }\n\n    while (i < a1.size()) {\n        mergedArray.add(a1.nodes[i], a1.scores[i]);\n        i++;\n    }\n\n    while (j < a2.size()) {\n        mergedArray.add(a2.nodes[j], a2.scores[j]);\n        j++;\n    }\n\n    return mergedArray;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\n------------------------------\n------------------------------\npublic class NodesUnsorted {\n    protected int size;\n    float[] score;\n    int[] node;\n\n    public NodesUnsorted(int initialSize) {\n        node = new int[initialSize];\n        score = new float[initialSize];\n    }\n\n    /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n    protected final void growArrays() {\n        node = ArrayUtil.grow(node);\n        score = ArrayUtil.growExact(score, node.length);\n    }\n------------------------------\n------------------------------\n*                 vectors using the same codebooks as the partials. Due to the transposition, rather than this being\n   *                 contiguous encoded vectors, the first component of all vectors is stored contiguously, then the second, and so on.\n   * @param codebookCount The number of codebooks used in the PQ encoding.\n   * @param quantizedPartials The quantized precomputed score fragments for each codebook entry. These are stored as a contiguous vector of all\n------------------------------\n------------------------------\n/**\n     * Adds a value to an LongHeap in log(size) time.\n     *\n     * @return true if the new value was added. (A fixed-size heap will not add the new value\n     * if it is full, and the new value is worse than the existing ones.)\n     */\n    public abstract boolean push(long element);\n------------------------------\n------------------------------\n/**\n     * Reads all the vectors from vector values, builds a graph connecting them by their dense\n     * ordinals, using the given hyperparameter settings, and returns the resulting graph.\n     *\n     * @param vectorValues     the vectors whose relations are represented by the graph - must provide a\n     *                         different view over those vectors than the one used to add via addGraphNode.\n     * @param M                \u2013 the maximum number of connections a node can have\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void addInOrder(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void addInOrder(int newNode, float newScore) {\n    if (size >= node.length) {\n        growArrays();\n    }\n\n    if (size == 0 || newScore > score[size - 1]) {\n        node[size] = newNode;\n        score[size] = newScore;\n        size++;\n    } else {\n        for (int i = 0; i < size; i++) {\n            if (newScore > score[i]) {\n                System.arraycopy(node, i, node, i + 1, size - i);\n                System.arraycopy(score, i, score, i + 1, size - i);\n                node[i] = newNode;\n                score[i] = newScore;\n                size++;\n                break;\n            }\n        }\n    }\n}\n```\n", "```java\npublic void addInOrder(int newNode, float newScore) {\n    if (size >= node.length) {\n        growArrays();\n    }\n\n    int insertionPoint = size;\n    for (int i = 0; i < size; i++) {\n        if (score[i] < newScore) {\n            insertionPoint = i;\n            break;\n        }\n    }\n\n    if (insertionPoint == size) {\n        node[size] = newNode;\n        score[size] = newScore;\n        size++;\n    } else if (node[insertionPoint] != newNode) {\n        System.arraycopy(node, insertionPoint, node, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(score, insertionPoint, score, insertionPoint + 1, size - insertionPoint);\n        node[insertionPoint] = newNode;\n        score[insertionPoint] = newScore;\n        size++;\n    }\n}\n```\n", "```java\npublic int addInOrder(int newNode, float newScore) {\n    if (size >= node.length) {\n        growArrays();\n    }\n\n    int insertionPoint = -1;\n    for (int i = 0; i < size; i++) {\n        if (newScore > score[i]) {\n            insertionPoint = i;\n            break;\n        }\n    }\n\n    if (insertionPoint != -1) {\n        System.arraycopy(node, insertionPoint, node, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(score, insertionPoint, score, insertionPoint + 1, size - insertionPoint);\n        node[insertionPoint] = newNode;\n        score[insertionPoint] = newScore;\n    } else {\n        node[size] = newNode;\n        score[size] = newScore;\n    }\n\n    size++;\n    return insertionPoint;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\n------------------------------\n------------------------------\n/**\n     * Adds a new graph node to the heap.  Will extend storage or replace the worst element\n     * depending on the type of heap it is.\n     *\n     * @param newNode  the node id\n     * @param newScore the relative similarity score to the node of the owner\n     *\n     * @return true if the new value was added.\n     */\n    public boolean push(int newNode, float newScore) {\n        return heap.push(encode(newNode, newScore));\n    }\n------------------------------\n------------------------------\npublic class NodesUnsorted {\n    protected int size;\n    float[] score;\n    int[] node;\n\n    public NodesUnsorted(int initialSize) {\n        node = new int[initialSize];\n        score = new float[initialSize];\n    }\n\n    /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n    protected final void growArrays() {\n        node = ArrayUtil.grow(node);\n        score = ArrayUtil.growExact(score, node.length);\n    }\n------------------------------\n------------------------------\n/**\n     * Connect `node` to the closest neighbor that is not already a connection target.\n     * @return true if such a neighbor was found.\n     */\n    private boolean connectToClosestNeighbor(int node, NodeArray neighbors, Set<Integer> connectionTargets) {\n        // connect this node to the closest neighbor that hasn't already been used as a connection target\n        // (since this edge is likely to be the \"worst\" one in that target's neighborhood, it's likely to be\n------------------------------\n------------------------------\n// is the candidate node with the given score closer to the base node than it is to any of the\n        // already-selected neighbors\n        private boolean isDiverse(int node, float score, NodeArray others, ScoreFunction sf, BitSet selected, float alpha) {\n            assert others.size() > 0;\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int insertSorted(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic int insertSorted(int newNode, float newScore) {\n    if (size == 0 || newScore < score[size - 1]) {\n        if (size == node.length) {\n            growArrays();\n        }\n        node[size] = newNode;\n        score[size] = newScore;\n        size++;\n        return size - 1;\n    } else {\n        for (int i = 0; i < size; i++) {\n            if (newNode == node[i]) {\n                return -1;\n            }\n            if (newScore < score[i]) {\n                if (size == node.length) {\n                    growArrays();\n                }\n                System.arraycopy(node, i, node, i + 1, size - i);\n                System.arraycopy(score, i, score, i + 1, size - i);\n                node[i] = newNode;\n                score[i] = newScore;\n                size++;\n                return i;\n            }\n        }\n    }\n    return -1;\n}\n```\n", "```java\npublic int insertSorted(int newNode, float newScore) {\n    if (size == 0 || newScore > score[size-1]) {\n        ensureCapacity(size + 1);\n        node[size] = newNode;\n        score[size] = newScore;\n        size++;\n        return size - 1;\n    } else if (newScore <= score[0]) {\n        ensureCapacity(size + 1);\n        System.arraycopy(node, 0, node, 1, size);\n        System.arraycopy(score, 0, score, 1, size);\n        node[0] = newNode;\n        score[0] = newScore;\n        size++;\n        return 0;\n    } else {\n        int insertionPoint = findInsertionPoint(newScore);\n        if (node[insertionPoint] == newNode) {\n            return -1;\n        }\n        ensureCapacity(size + 1);\n        System.arraycopy(node, insertionPoint, node, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(score, insertionPoint, score, insertionPoint + 1, size - insertionPoint);\n        node[insertionPoint] = newNode;\n        score[insertionPoint] = newScore;\n        size++;\n        return insertionPoint;\n    }\n}\n\nprivate int findInsertionPoint(float newScore) {\n    int low = 0;\n    int high = size - 1;\n    while (low < high) {\n        int mid = (low + high) / 2;\n        if (score[mid] < newScore) {\n            high = mid;\n        } else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\n\nprivate void ensureCapacity(int minCapacity) {\n    int oldCapacity = node.length;\n    if (minCapacity > oldCapacity) {\n        int newCapacity = oldCapacity + (oldCapacity >> 1);\n        if (newCapacity < minCapacity) {\n            newCapacity = minCapacity;\n        }\n        node = Arrays.copyOf(node, newCapacity);\n        score = Arrays.copyOf(score, newCapacity);\n    }\n}\n```\n", "```java\npublic int insertSorted(int newNode, float newScore) {\n    if (size >= node.length) {\n        growArrays();\n    }\n\n    int insertionPoint = -1;\n\n    for (int i = 0; i < size; i++) {\n        if (score[i] < newScore) {\n            insertionPoint = i;\n            break;\n        }\n    }\n\n    if (insertionPoint != -1) {\n        System.arraycopy(node, insertionPoint, node, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(score, insertionPoint, score, insertionPoint + 1, size - insertionPoint);\n        node[insertionPoint] = newNode;\n        score[insertionPoint] = newScore;\n        size++;\n    }\n\n    return insertionPoint;\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\n------------------------------\n------------------------------\n/**\n   * Returns the index of the last set bit before or on the index specified. -1 is returned if there\n   * are no more set bits.\n   */\n  public abstract int prevSetBit(int index);\n\n  /**\n   * Returns the index of the first set bit starting at the index specified. {@link\n   * DocIdSetIterator#NO_MORE_DOCS} is returned if there are no more set bits.\n   */\n  public abstract int nextSetBit(int index);\n------------------------------\n------------------------------\n/**\n     * A concurrent set of neighbors that encapsulates diversity/pruning mechanics.\n     * <p>\n     * Nothing is modified in place; all mutating methods return a new instance.  These methods\n     * are private and should only be exposed through the parent ConcurrentNeighborMap, which\n     * performs the appropriate CAS dance.\n     * <p>\n     * CNM is passed as an explicit parameter to these methods (instead of making this a non-static\n------------------------------\n------------------------------\n/**\n * A min heap that stores longs; a primitive priority queue that like all priority queues maintains\n * a partial ordering of its elements such that the least element can always be found in constant\n * time. Push()'s and pop()'s require log(size). {@link #push(long)} may either grow the heap or\n * replace the worst element, depending on the subclass implementation.\n * <p>\n * The heap is a min heap, meaning that the top element is the lowest value.\n */\n------------------------------\n------------------------------\n/**\n     * Returns the least element of the LongHeap in constant time. It is up to the caller to verify\n     * that the heap is not empty; no checking is done, and if no elements have been added, 0 is\n     * returned.\n     */\n    public final long top() {\n        return heap[1];\n    }\n\n    /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void retain(Bits selected) {\n# Natural Language Annotations: /**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void retain(Bits selected) {\n    int lastSetBit = selected.prevSetBit(selected.length());\n    if (lastSetBit == -1) {\n        // No bits are set, so clear the NodeArray\n        this.clear();\n    } else {\n        int nextClearBit = selected.nextClearBit(0);\n        while (nextClearBit <= lastSetBit) {\n            // Clear the element at the nextClearBit index\n            this.clear(nextClearBit);\n            // Find the next clear bit\n            nextClearBit = selected.nextClearBit(nextClearBit + 1);\n        }\n    }\n}\n```\n", "```java\npublic void retain(BitSet selected) {\n    int currentIndex = 0;\n    int lastSetBitIndex = selected.prevSetBit(selected.length() - 1);\n\n    while (lastSetBitIndex >= 0) {\n        currentIndex = selected.nextSetBit(currentIndex);\n        if (currentIndex < 0 || currentIndex > lastSetBitIndex) {\n            break;\n        }\n        if (currentIndex != lastSetBitIndex) {\n            swap(currentIndex, lastSetBitIndex);\n        }\n        lastSetBitIndex = selected.prevSetBit(lastSetBitIndex - 1);\n    }\n\n    // Truncate the array to the last set bit index\n    if (lastSetBitIndex >= 0) {\n        truncate(lastSetBitIndex + 1);\n    }\n}\n```\n", "```java\npublic void retain(Bits selected) {\n    int lastIndex = selected.length() - 1;\n    int nextSetBit = selected.nextSetBit(0);\n    int prevSetBit = selected.prevSetBit(lastIndex);\n\n    if (nextSetBit < 0 || prevSetBit < 0) {\n        // No bits set, clear the array\n        clear();\n        return;\n    }\n\n    if (nextSetBit == 0 && prevSetBit == lastIndex) {\n        // All bits set, nothing to do\n        return;\n    }\n\n    int currentIndex = 0;\n    int newIndex = 0;\n    while (currentIndex < prevSetBit) {\n        if (selected.get(currentIndex)) {\n            // Keep this element\n            set(newIndex, get(currentIndex));\n            newIndex++;\n        }\n        currentIndex++;\n    }\n\n    // Trim the array to the new size\n    trimToSize(newIndex);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\n------------------------------\n------------------------------\npublic class NodesUnsorted {\n    protected int size;\n    float[] score;\n    int[] node;\n\n    public NodesUnsorted(int initialSize) {\n        node = new int[initialSize];\n        score = new float[initialSize];\n    }\n\n    /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\n\n\n\n\n\n\n\n\n\n    protected final void growArrays() {\n        node = ArrayUtil.grow(node);\n        score = ArrayUtil.growExact(score, node.length);\n    }\n------------------------------\n------------------------------\n*                 vectors using the same codebooks as the partials. Due to the transposition, rather than this being\n   *                 contiguous encoded vectors, the first component of all vectors is stored contiguously, then the second, and so on.\n   * @param codebookCount The number of codebooks used in the PQ encoding.\n   * @param quantizedPartials The quantized precomputed score fragments for each codebook entry. These are stored as a contiguous vector of all\n------------------------------\n------------------------------\n/**\n     * Adds a value to an LongHeap in log(size) time.\n     *\n     * @return true if the new value was added. (A fixed-size heap will not add the new value\n     * if it is full, and the new value is worse than the existing ones.)\n     */\n    public abstract boolean push(long element);\n------------------------------\n------------------------------\n/**\n     * Reads all the vectors from vector values, builds a graph connecting them by their dense\n     * ordinals, using the given hyperparameter settings, and returns the resulting graph.\n     *\n     * @param vectorValues     the vectors whose relations are represented by the graph - must provide a\n     *                         different view over those vectors than the one used to add via addGraphNode.\n     * @param M                \u2013 the maximum number of connections a node can have\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void add(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic void add(int newNode, float newScore) {\n    if (size >= node.length) {\n        growArrays();\n    }\n\n    int insertionPoint = -1;\n    for (int i = 0; i < size; i++) {\n        if (score[i] < newScore) {\n            insertionPoint = i;\n            break;\n        }\n    }\n\n    if (insertionPoint != -1) {\n        System.arraycopy(node, insertionPoint, node, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(score, insertionPoint, score, insertionPoint + 1, size - insertionPoint);\n        node[insertionPoint] = newNode;\n        score[insertionPoint] = newScore;\n    } else {\n        node[size] = newNode;\n        score[size] = newScore;\n    }\n\n    size++;\n}\n```\n", "Sure, here is the function based on the function signature and natural language annotations provided:\n\n```java\npublic int add(int newNode, float newScore) {\n    if (size >= node.length) {\n        growArrays();\n    }\n    if (size == 0 || newScore < score[size-1]) {\n        node[size] = newNode;\n        score[size] = newScore;\n        size++;\n        return size - 1;\n    } else {\n        return -1;\n    }\n}\n```\n", "```java\npublic void add(int newNode, float newScore) {\n    if (size == node.length) {\n        growArrays();\n    }\n\n    node[size] = newNode;\n    score[size] = newScore;\n    size++;\n\n    for (int i = size - 1; i > 0; i--) {\n        if (score[i] > score[i - 1]) {\n            // Swap the nodes and scores\n            int tempNode = node[i];\n            node[i] = node[i - 1];\n            node[i - 1] = tempNode;\n\n            float tempScore = score[i];\n            score[i] = score[i - 1];\n            score[i - 1] = tempScore;\n        } else {\n            break;\n        }\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Only for internal use and by Builder loading a saved graph\n     */\n\n\n\n\n\n\n\n    public void addNode(int nodeId) {\n        addNode(nodeId, new NodeArray(0));\n    }\n\n    public NodesIterator nodesIterator() {\n        return neighbors.keysIterator();\n    }\n\n    public Neighbors remove(int node) {\n        return neighbors.remove(node);\n    }\n\n    public boolean contains(int nodeId) {\n        return neighbors.containsKey(nodeId);\n    }\n------------------------------\n------------------------------\n/**\n     * Only for use by Builder loading a saved graph\n     */\n    void addNode(int nodeId, NodeArray nodes) {\n        assert nodes != null;\n        this.nodes.addNode(nodeId, nodes);\n        maxNodeId.accumulateAndGet(nodeId, Math::max);\n    }\n\n    /**\n     * Mark the given node deleted.  Does NOT remove the node from the graph.\n     */\n    public void markDeleted(int node) {\n        deletedNodes.set(node);\n    }\n------------------------------\n------------------------------\npackage io.github.jbellis.jvector.annotations;\n\n/**\n * Methods or classes marked VisibleForTesting are intended for internal use only\n * and may change without warning, regardless of their visibility.\n */\n------------------------------\n------------------------------\n/**\n * Write a graph index to disk, for later loading as an OnDiskGraphIndex.\n * <p>\n * Implements `getFeatureSource` to allow incremental construction of a larger-than-memory graph\n * (using the writer as the source of INLINE_VECTORS).\n */\n// Code for: public class OnDiskGraphIndexWriter implements Closeable {\n------------------------------\n------------------------------\n/**\n     * Encapsulates the state of a graph for searching.  Re-usable across search calls,\n     * but each thread needs its own.\n     */\n    interface View extends Closeable {\n        /**\n         * Iterator over the neighbors of a given node.  Only the most recently instantiated iterator\n         * is guaranteed to be valid.\n         */\n        NodesIterator getNeighborsIterator(int node);\n\n        /**\n         * @return the number of nodes in the graph\n         */\n        int size();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void addNode(int nodeId, NodeArray nodes) {\n# Natural Language Annotations: /**\n     * Only for internal use and by Builder loading a saved graph\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nvoid addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```\n", "```java\npublic void addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```\n", "```java\npublic void addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic void markNodeDeleted(int node) {\n        graph.markDeleted(node);\n    }\n\n    /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\n------------------------------\n------------------------------\n/**\n     * Return a View with which to navigate the graph.  Views are not threadsafe -- that is,\n     * only one search at a time should be run per View.\n     * <p>\n     * Additionally, the View represents a point of consistency in the graph, and in-use\n     * Views prevent the removal of marked-deleted nodes from graphs that are being\n     * concurrently modified.  Thus, it is good (and encouraged) to re-use Views for\n------------------------------\n------------------------------\n/**\n * Builder for Concurrent GraphIndex. See {@link GraphIndex} for a high level overview, and the\n * comments to `addGraphNode` for details on the concurrent building approach.\n * <p>\n * GIB allocates scratch space and copies of the RandomAccessVectorValues for each thread\n * that calls `addGraphNode`.  These allocations are retained until the GIB itself is no longer referenced.\n * Under most conditions this is not something you need to worry about, but it does mean\n------------------------------\n------------------------------\n// Update neighbors with these candidates.\n            // The DiskANN paper calls for using the entire set of visited nodes along the search path as\n            // potential candidates, but in practice we observe neighbor lists being completely filled using\n            // just the topK results.  (Since the Robust Prune algorithm prioritizes closer neighbors,\n            // this means that considering additional nodes from the search path, that are by definition\n------------------------------\n------------------------------\n/**\n     * Inserts a node with the given vector value to the graph.\n     *\n     * <p>To allow correctness under concurrency, we track in-progress updates in a\n     * ConcurrentSkipListSet. After adding ourselves, we take a snapshot of this set, and consider all\n     * other in-progress updates as neighbor candidates.\n     *\n     * @param node the node ID to add\n     * @return an estimate of the number of extra bytes used by the graph after adding the given node\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized long removeDeletedNodes() {\n# Natural Language Annotations: /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["Sure, here is the function based on the given function signature and natural language annotations:\n\n```java\npublic synchronized long removeDeletedNodes() {\n    // Implementation goes here...\n}\n```\n", "```java\npublic synchronized long removeDeletedNodes() {\n    // Implementation here\n}\n```\n", "```java\npublic synchronized long removeDeletedNodes() {\n    // Your code here\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Write the inline features of the given ordinal to the output at the correct offset.\n     * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * @return the maximum ordinal written so far, or -1 if no ordinals have been written yet\n     */\n    public int getMaxOrdinal() {\n        return maxOrdinalWritten;\n    }\n------------------------------\n------------------------------\n/**\n     * Write the index header and completed edge lists to the given output.  Inline features given in\n     * `featureStateSuppliers` will also be written.  (Features that do not have a supplier are assumed\n     * to have already been written by calls to writeInline).  The output IS flushed.\n     * <p>\n     * Each supplier takes a node ordinal and returns a FeatureState suitable for Feature.writeInline.\n     */\n------------------------------\n------------------------------\n/**\n     * Write the given vector to the given DataOutput.\n     * @param out the output to write the vector to.\n     * @param vector the vector to write.\n     * @throws IOException\n     */\n    void writeFloatVector(DataOutput out, VectorFloat<?> vector) throws IOException;\n------------------------------\n------------------------------\n/**\n     * Writes the index header, including the graph size, so that OnDiskGraphIndex can open it.\n     * The output IS flushed.\n     * <p>\n     * Public so that you can write the index size (and thus usefully open an OnDiskGraphIndex against the index)\n     * to read Features from it before writing the edges.\n     */\n    public synchronized void writeHeader() throws IOException {\n        // graph-level properties\n        out.seek(startOffset);\n------------------------------\n------------------------------\n*\n   * The caller is responsible for ensuring than no value in partialSums is larger than its corresponding partialBase.\n   *\n   * @param delta the divisor to use for quantization\n   * @param partials the values to quantize\n   * @param partialBases the base values to subtract from the partials\n   * @param quantizedPartials the output sequence to store the quantized values\n   */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException\n# Natural Language Annotations: /**\n     * Write the inline features of the given ordinal to the output at the correct offset.\n     * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Check if the ordinal is valid\n    if (ordinal < 0 || ordinal > maxOrdinalWritten) {\n        throw new IllegalArgumentException(\"Invalid ordinal: \" + ordinal);\n    }\n\n    // Find the correct offset\n    long offset = startOffset + ordinal * featureSize;\n    out.seek(offset);\n\n    // Write the inline features\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        FeatureId featureId = entry.getKey();\n        Feature.State state = entry.getValue();\n        Feature feature = features.get(featureId);\n        feature.writeInline(out, state);\n    }\n}\n```\n", "```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Make sure the ordinal is within the bounds\n    if (ordinal < 0 || ordinal > maxOrdinalWritten) {\n        throw new IllegalArgumentException(\"Invalid ordinal: \" + ordinal);\n    }\n    // Calculate the offset\n    long offset = startOffset + ordinal * featureSize;\n    // Seek to the correct offset\n    out.seek(offset);\n    // Write the inline features\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        FeatureId featureId = entry.getKey();\n        Feature.State state = entry.getValue();\n        // Write the inline feature\n        featureId.writeInline(out, state);\n    }\n}\n```\n", "```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Calculate the offset for the ordinal\n    long offset = calculateOffset(ordinal);\n\n    // Seek to the calculated offset\n    out.seek(offset);\n\n    // Iterate over the stateMap\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        FeatureId featureId = entry.getKey();\n        Feature.State state = entry.getValue();\n\n        // Write the inline feature\n        featureId.writeInline(out, state);\n    }\n\n    // Update the max ordinal written if necessary\n    if (ordinal > maxOrdinalWritten) {\n        maxOrdinalWritten = ordinal;\n    }\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\n------------------------------\n------------------------------\n/**\n     * Map old ordinals (in the graph as constructed) to new ordinals (written to disk).\n     * Should always return a valid ordinal (between 0 and maxOrdinal).\n     */\n    int oldToNew(int oldOrdinal);\n\n    /**\n     * Map new ordinals (written to disk) to old ordinals (in the graph as constructed).\n     * May return OMITTED if there is a \"hole\" at the new ordinal.\n     */\n    int newToOld(int newOrdinal);\n------------------------------\n------------------------------\npublic interface GraphIndex extends AutoCloseable, Accountable {\n    /** Returns the number of nodes in the graph */\n    int size();\n\n    /**\n     * Get all node ordinals included in the graph. The nodes are NOT guaranteed to be\n     * presented in any particular order.\n     *\n     * @return an iterator over nodes where {@code nextInt} returns the next node.\n     */\n    NodesIterator getNodes();\n------------------------------\n------------------------------\n/**\n         * @return the node of the graph to start searches at\n         */\n        int entryNode();\n\n        /**\n         * Return a Bits instance indicating which nodes are live.  The result is undefined for\n         * ordinals that do not correspond to nodes in the graph.\n         */\n        Bits liveNodes();\n------------------------------\n------------------------------\n/**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n# Natural Language Annotations: /**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNew = new HashMap<>();\n    Map<Integer, Integer> newToOld = new HashMap<>();\n    int newOrdinal = 0;\n\n    NodesIterator iterator = graph.getNodes();\n    while (iterator.hasNext()) {\n        int oldOrdinal = iterator.nextInt();\n        oldToNew.put(oldOrdinal, newOrdinal);\n        newToOld.put(newOrdinal, oldOrdinal);\n        newOrdinal++;\n    }\n\n    return oldToNew;\n}\n```\n", "```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNewMap = new HashMap<>();\n    Map<Integer, Integer> newToOldMap = new HashMap<>();\n    int newOrdinal = 0;\n    NodesIterator nodes = graph.getNodes();\n    while (nodes.hasNext()) {\n        int oldOrdinal = nodes.next();\n        oldToNewMap.put(oldOrdinal, newOrdinal);\n        newToOldMap.put(newOrdinal, oldOrdinal);\n        newOrdinal++;\n    }\n    int entryNode = graph.entryNode();\n    Bits liveNodes = graph.liveNodes();\n    for (int i = 0; i < liveNodes.size(); i++) {\n        if (!liveNodes.get(i)) {\n            int oldOrdinal = newToOldMap.get(i);\n            oldToNewMap.remove(oldOrdinal);\n            newToOldMap.remove(i);\n        }\n    }\n    return oldToNewMap;\n}\n```\n", "Sure, here is the function that fulfills your requirements:\n\n```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNewMap = new HashMap<>();\n    Map<Integer, Integer> newToOldMap = new HashMap<>();\n    int newOrdinal = 0;\n\n    for (NodesIterator iterator = graph.getNodes(); iterator.hasNext(); ) {\n        int oldOrdinal = iterator.nextInt();\n        if (graph.liveNodes().get(oldOrdinal)) {\n            oldToNewMap.put(oldOrdinal, newOrdinal);\n            newToOldMap.put(newOrdinal++, oldOrdinal);\n        }\n    }\n\n    return oldToNewMap;\n}\n```\nThis function iterates over all nodes in the graph and, if the node is live (determined by the `liveNodes()` method), it assigns a new sequential ordinal to it. The old and new ordinals are stored in two maps for easy lookup. The new ordinal is incremented after each assignment.\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\n    public static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n        write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), path);\n    }\n\n    /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\n------------------------------\n------------------------------\n/**\n     * Convenience method to create an ExactScoreFunction for reranking.  The resulting function is NOT thread-safe.\n     */\n\n\n\n\n\n\n\n\n\n\n\n}\n------------------------------\n------------------------------\n/**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\n\n\n\n\n\n\n\n\n\n    /**\n     * Call GraphSearcher constructor instead\n     */\n    @Deprecated\n    public static class Builder {\n        private final GraphIndex.View view;\n\n        public Builder(GraphIndex.View view) {\n            this.view = view;\n        }\n------------------------------\n------------------------------\n/**\n   * Returns the index of the last set bit before or on the index specified. -1 is returned if there\n   * are no more set bits.\n   */\n  public abstract int prevSetBit(int index);\n\n  /**\n   * Returns the index of the first set bit starting at the index specified. {@link\n   * DocIdSetIterator#NO_MORE_DOCS} is returned if there are no more set bits.\n   */\n  public abstract int nextSetBit(int index);\n------------------------------\n------------------------------\nNUM_BYTES_OBJECT_HEADER = 8;\n      // For 32 bit JVMs, no extra alignment of array header:\n      NUM_BYTES_ARRAY_HEADER = NUM_BYTES_OBJECT_HEADER + Integer.BYTES;\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void write(GraphIndex graph,\n# Natural Language Annotations: /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), path);\n}\n```\n", "```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), path);\n}\n```\n", "```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), path);\n}\n```\n"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n     */\n------------------------------\n------------------------------\n/**\n     * Returns a BSP that performs approximate score comparisons using the given PQVectors,\n     * with reranking performed using RandomAccessVectorValues (which is intended to be\n     * InlineVectorValues for building incrementally, but should technically\n     * work with any RAVV implementation).\n     */\n    static BuildScoreProvider pqBuildScoreProvider(VectorSimilarityFunction vsf, PQVectors pqv) {\n        int dimension = pqv.getOriginalSize() / Float.BYTES;\n------------------------------\n------------------------------\n/**\n     * A SearchScoreProvider for a single-pass search based on exact similarity.\n     * Generally only suitable when your RandomAccessVectorValues is entirely in-memory,\n     * e.g. during construction.\n     */\n    public static SearchScoreProvider exact(VectorFloat<?> v, VectorSimilarityFunction vsf, RandomAccessVectorValues ravv) {\n        // don't use ESF.reranker, we need thread safety here\n        var sf = new ScoreFunction.ExactScoreFunction() {\n            @Override\n------------------------------\n------------------------------\n// default implementation used here because Panama SIMD can't express necessary SIMD operations and degrades to scalar\n  /**\n   * Calculates the similarity score of multiple product quantization-encoded vectors against a single query vector,\n   * using quantized precomputed similarity score fragments derived from codebook contents and evaluations during a search.\n   * @param shuffles a sequence of shuffles to be used against partial pre-computed fragments. These are transposed PQ-encoded\n------------------------------\n------------------------------\n// default implementation used here because Panama SIMD can't express necessary SIMD operations and degrades to scalar\n  /**\n   * Calculates the similarity score of multiple product quantization-encoded vectors against a single query vector,\n   * using quantized precomputed similarity score fragments derived from codebook contents and evaluations during a search.\n   * @param shuffles a sequence of shuffles to be used against partial pre-computed fragments. These are transposed PQ-encoded\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    // Implementation goes here\n}\n```\n", "```java\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public float score(int docId) {\n            // Implementation here based on the RandomAccessVectorValues and VectorSimilarityFunction\n            // This is a placeholder and needs to be filled with the actual implementation\n            return 0.0f;\n        }\n\n        @Override\n        public String toString() {\n            // Implementation here based on the RandomAccessVectorValues and VectorSimilarityFunction\n            // This is a placeholder and needs to be filled with the actual implementation\n            return \"RandomAccessScoreProvider\";\n        }\n    };\n}\n```\n", "```java\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    // Your implementation here\n}\n```\n"]}, "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class StatisticUtils {\n\n    private StatisticUtils() {\n        // This class is not instantiable\n    }\n\n    /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\n------------------------------\n------------------------------\n/**\n     * Reads a line from standard input\n     *\n     * @return A line read from standard input\n     */\n    String readLine();\n\n    PythonTraceback getTraceback();\n}\n------------------------------\n------------------------------\n/**\n     * Build an uncountable {@link ValueRange} of all {@code double} values between 2 bounds.\n     *\n     * @param from inclusive minimum\n     * @param to exclusive maximum, {@code >= from}\n     * @return never null\n     * @deprecated Prefer {@link #createBigDecimalValueRange(BigDecimal, BigDecimal)}.\n     */\n    @Deprecated(forRemoval = true, since = \"1.1.0\")\n    public static ValueRange<Double> createDoubleValueRange(double from, double to) {\n------------------------------\n------------------------------\n/**\n     * Build a {@link CountableValueRange} of all {@code int} values between 2 bounds.\n     *\n     * @param from inclusive minimum\n     * @param to exclusive maximum, {@code >= from}\n     * @return never null\n     */\n    public static CountableValueRange<Integer> createIntValueRange(int from, int to) {\n        return new IntValueRange(from, to);\n    }\n------------------------------\n------------------------------\n/**\n     * Build a {@link CountableValueRange} of all {@code long} values between 2 bounds.\n     *\n     * @param from inclusive minimum\n     * @param to exclusive maximum, {@code >= from}\n     * @return never null\n     */\n    public static CountableValueRange<Long> createLongValueRange(long from, long to) {\n        return new LongValueRange(from, to);\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double[] determineStandardDeviationDoubles(\n# Natural Language Annotations: /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double sum = 0.0, standardDeviation = 0.0;\n    int length = averageScore.length;\n\n    for(double num : averageScore) {\n        sum += num;\n    }\n\n    double mean = sum/length;\n\n    for(double num: averageScore) {\n        standardDeviation += Math.pow(num - mean, 2);\n    }\n\n    double standardDeviationResult = Math.sqrt(standardDeviation/length);\n\n    return new double[]{mean, standardDeviationResult};\n}\n```\n", "```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double sum = 0.0, standardDeviation = 0.0;\n    int length = averageScore.length;\n\n    for(double num : averageScore) {\n        sum += num;\n    }\n\n    double mean = sum/length;\n\n    for(double num: averageScore) {\n        standardDeviation += Math.pow(num - mean, 2);\n    }\n\n    double[] result = new double[2];\n    result[0] = mean;\n    result[1] = Math.sqrt(standardDeviation/length);\n\n    return result;\n}\n```\n", "```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double sum = 0.0, standardDeviation = 0.0;\n    int length = averageScore.length;\n\n    for(double num : averageScore) {\n        sum += num;\n    }\n\n    double mean = sum/length;\n\n    for(double num: averageScore) {\n        standardDeviation += Math.pow(num - mean, 2);\n    }\n\n    return new double[]{mean, Math.sqrt(standardDeviation/length)};\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic StackMetadata pushTemps(PythonLikeType... types) {\n        StackMetadata out = copy();\n        for (PythonLikeType type : types) {\n            out.stackValueSources.add(ValueSourceInfo.of(new OpcodeWithoutSource(), type));\n        }\n        return out;\n    }\n\n    /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\n------------------------------\n------------------------------\n/**\n     * Return a new StackMetadata with {@code types} added as the new\n     * elements. The last element of {@code types} is TOS.\n     *\n     * @param types The types to push to TOS\n     */\n    public StackMetadata push(ValueSourceInfo... types) {\n        StackMetadata out = copy();\n        out.stackValueSources.addAll(Arrays.asList(types));\n        return out;\n    }\n------------------------------\n------------------------------\n/**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\n------------------------------\n------------------------------\nreturn a.unifyWith(b);\n    }\n\n    /**\n     * Return a new StackMetadata with {@code type} added as the new\n     * TOS element.\n     *\n     * @param type The type to push to TOS\n     */\n    public StackMetadata push(ValueSourceInfo type) {\n        StackMetadata out = copy();\n        out.stackValueSources.add(type);\n        return out;\n    }\n------------------------------\n------------------------------\n/**\n     * Returns the value source for the given stack index (stack index is how many\n     * elements below TOS (i.e. 0 is TOS, 1 is TOS1)).\n     *\n     * @param index The stack index (how many elements below TOS)\n     * @return The type at the given stack index\n     */\n    public ValueSourceInfo getValueSourceForStackIndex(int index) {\n        return stackValueSources.get(getListIndexForStackIndex(index));\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata stack(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = new StackMetadata();\n    out.stackValueSources = new ArrayList<>(Arrays.asList(types));\n    return out;\n}\n```\n", "```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = copy();\n    out.stackValueSources.clear();\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```\n", "```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = copy();\n    out.stackValueSources.clear();\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\n------------------------------\n------------------------------\n/**\n     * Return a new StackMetadata with the local variable in slot {@code index} type set to\n     * {@code type}.\n     */\n    public StackMetadata setLocalVariableValueSource(int index, ValueSourceInfo type) {\n        StackMetadata out = copy();\n        out.localVariableValueSources.set(index, type);\n        return out;\n    }\n------------------------------\n------------------------------\npublic StackMetadata pushTemps(PythonLikeType... types) {\n        StackMetadata out = copy();\n        for (PythonLikeType type : types) {\n            out.stackValueSources.add(ValueSourceInfo.of(new OpcodeWithoutSource(), type));\n        }\n        return out;\n    }\n\n    /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\n------------------------------\n------------------------------\n/**\n     * Return a new StackMetadata with TOS popped\n     */\n    public StackMetadata pop() {\n        StackMetadata out = copy();\n        out.stackValueSources.remove(stackValueSources.size() - 1);\n        return out;\n    }\n------------------------------\n------------------------------\n/**\n     * Return a new StackMetadata with the top {@code count} items popped.\n     */\n    public StackMetadata pop(int count) {\n        StackMetadata out = copy();\n        out.stackValueSources.subList(stackValueSources.size() - count, stackValueSources.size()).clear();\n        return out;\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata locals(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"types.length != localVariableTypes.size()\");\n    }\n\n    StackMetadata out = copy();\n    out.localVariableValueSources = new ArrayList<>(Arrays.asList(types));\n    return out;\n}\n```\n", "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"types.length != localVariableTypes.size()\");\n    }\n    StackMetadata out = copy();\n    for (int i = 0; i < types.length; i++) {\n        out.localVariableValueSources.set(i, types[i]);\n    }\n    return out;\n}\n```\n", "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"types.length != localVariableTypes.size()\");\n    }\n    StackMetadata out = copy();\n    for (int i = 0; i < types.length; i++) {\n        out.localVariableValueSources.set(i, types[i]);\n    }\n    return out;\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\n------------------------------\n------------------------------\n/**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\n------------------------------\n------------------------------\n/**\n     * TOS is an object, and TOS1 is a value. Store TOS1 into the {@code attributeName} attribute of TOS.\n     * TOS and TOS1 are popped.\n     *\n     * @param attributeName The attribute to store.\n     * @return\n     */\n------------------------------\n------------------------------\n/**\n     * Execute the code generated by the parameter if TOS is True; skip it otherwise.\n     * TOS is popped.\n     *\n     * @param blockBuilder The code inside the if statement\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    /**\n     * Execute the code generated by the parameter if TOS is False; skip it otherwise.\n     * TOS is popped.\n     *\n     * @param blockBuilder The code inside the if statement\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the method name from co_names[namei]\n    String methodName = functionMetadata.getMethodName();\n\n    // Pop TOS (Top of Stack) from the stack\n    Object topOfStack = stackMetadata.pop();\n\n    // Check if TOS has a method with the correct name\n    if (topOfStack.hasMethod(methodName)) {\n        // If TOS has the method, push the unbound method and TOS\n        stackMetadata.push(topOfStack.getMethod(methodName));\n        stackMetadata.push(topOfStack);\n    } else {\n        // If TOS does not have the method, push NULL and the object returned by the attribute lookup\n        stackMetadata.push(null);\n        stackMetadata.push(topOfStack.getAttribute(methodName));\n    }\n}\n```\n", "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Implementation goes here\n}\n```\n", "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n    // if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n    // TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n    // Otherwise, NULL and the object return by the attribute lookup are pushed.\n\n    String methodName = functionMetadata.getMethodName();\n    Object tos = stackMetadata.pop();\n\n    if (tos instanceof PyObject) {\n        PyObject pyObject = (PyObject) tos;\n        PyObject method = pyObject.getMethod(methodName);\n        if (method != null) {\n            stackMetadata.push(method);\n            stackMetadata.push(tos);\n        } else {\n            stackMetadata.push(null);\n            stackMetadata.push(pyObject);\n        }\n    } else {\n        // Handle other types of objects as needed\n    }\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. argc is the number of positional arguments. Keyword arguments are stored in a local variable.\n     * Keyword arguments (if any) are at the top of the stack, followed by, positional arguments.\n     * Below them either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor,\n# Natural Language Annotations: /**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argc) {\n    // Pop the arguments from the stack\n    Object[] args = new Object[argc];\n    for (int i = 0; i < argc; i++) {\n        args[i] = stackMetadata.pop();\n    }\n\n    // Get the function to call\n    Object function = stackMetadata.pop();\n\n    // Call the function\n    Object result = functionMetadata.call(function, args);\n\n    // Push the result onto the stack\n    stackMetadata.push(result);\n}\n```\n", "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argc) {\n    // Implementation goes here\n}\n```\n", "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    // Implementation here\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. argc is the number of positional arguments. Keyword arguments are stored in a local variable.\n     * Keyword arguments (if any) are at the top of the stack, followed by, positional arguments.\n     * Below them either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunction(FunctionMetadata functionMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callFunction(FunctionMetadata functionMetadata, Object... TOS) {\n    // Get the function to call from the top of the stack\n    Function functionToCall = (Function) TOS[TOS.length - 1];\n    // Get the arguments from the stack\n    Object[] arguments = Arrays.copyOfRange(TOS, 0, TOS.length - 1);\n    // Call the function\n    Object result = functionToCall.apply(arguments);\n    // Push the result onto the stack\n    // Note: This depends on how the stack is implemented and manipulated\n    // In a real application, this would typically involve some sort of stack manipulation\n}\n```\n", "```java\npublic static void callFunction(FunctionMetadata functionMetadata, Object... args) {\n    // Implementation goes here\n}\n```\n", "```java\npublic static void callFunction(FunctionMetadata functionMetadata, Object... args) {\n    // Implementation of the function goes here\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. argc is the number of positional arguments. Keyword arguments are stored in a local variable.\n     * Keyword arguments (if any) are at the top of the stack, followed by, positional arguments.\n     * Below them either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the number of arguments\n    int argc = functionMetadata.getArgc();\n\n    // Get the keyword arguments\n    Tuple keywordArgs = stackMetadata.getTOS();\n\n    // Get the positional arguments\n    List<Object> positionalArgs = new ArrayList<>();\n    for (int i = keywordArgs.size() + 1; i <= argc; i++) {\n        positionalArgs.add(stackMetadata.getTOS(i));\n    }\n\n    // Get the function to call\n    Callable<Object> function = stackMetadata.getTOS(argc + 2);\n\n    // Call the function with keyword and positional arguments\n    Object result = function.call(keywordArgs, positionalArgs);\n\n    // Push the result onto the stack\n    stackMetadata.push(result);\n}\n```\n", "```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the function to call from TOS[argc + 2]\n    Function functionToCall = stackMetadata.getTOS(stackMetadata.getArgc() + 2);\n\n    // Get the keyword arguments from TOS[1]...TOS[len(TOS)]\n    Map<String, Object> keywordArgs = new HashMap<>();\n    for (int i = 1; i <= stackMetadata.getTOS().length(); i++) {\n        keywordArgs.put(stackMetadata.getTOS()[i - 1], stackMetadata.getTOS()[i]);\n    }\n\n    // Get the positional arguments from TOS[len(TOS) + 1]...TOS[argc + 1]\n    List<Object> positionalArgs = new ArrayList<>();\n    for (int i = stackMetadata.getTOS().length() + 1; i <= stackMetadata.getArgc() + 1; i++) {\n        positionalArgs.add(stackMetadata.getTOS()[i]);\n    }\n\n    // Call the function with keyword and positional arguments\n    Object result = functionToCall.call(keywordArgs, positionalArgs);\n\n    // Push the result onto the stack\n    stackMetadata.push(result);\n}\n```\n", "```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the number of positional arguments\n    int argc = stackMetadata.getArgCount();\n\n    // Get the function to call\n    Function functionToCall = stackMetadata.getFunction(argc + 2);\n\n    // Get the keyword names\n    Tuple keywordNames = stackMetadata.getTOS();\n\n    // Get the keyword arguments\n    List<Object> keywordArgs = new ArrayList<>();\n    for (int i = 1; i <= keywordNames.length(); i++) {\n        keywordArgs.add(stackMetadata.getArgument(i));\n    }\n\n    // Get the positional arguments\n    List<Object> positionalArgs = new ArrayList<>();\n    for (int i = keywordNames.length() + 1; i <= argc + 1; i++) {\n        positionalArgs.add(stackMetadata.getArgument(i));\n    }\n\n    // Call the function\n    Object result = functionToCall.call(keywordNames, keywordArgs, positionalArgs);\n\n    // Push the result onto the stack\n    stackMetadata.push(result);\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Calls a function. argc is the number of positional arguments. Keyword arguments are stored in a local variable.\n     * Keyword arguments (if any) are at the top of the stack, followed by, positional arguments.\n     * Below them either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\n------------------------------\n------------------------------\n/**\n     * Raise an exception, with the stack and effect varying depending on {@code instruction.arg}:\n     *\n     * instruction.arg = 0: Stack is empty. Reraise the last exception.\n     * instruction.arg = 1: TOS is an exception or exception type; raise it.\n     * instruction.arg = 2: TOS1 is an exception/exception type, and TOS is the cause. Raise TOS1 with TOS as the cause.\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    int arg = functionMetadata.getArg();\n    boolean lowestBitSet = (arg & 1) == 1;\n\n    if (lowestBitSet) {\n        Object tos = stackMetadata.getTOS();\n        if (tos instanceof Map) {\n            Map<?, ?> keywordArgs = (Map<?, ?>) tos;\n            Object positionalArgs = stackMetadata.get(1);\n            Callable<?> callable = (Callable<?>) stackMetadata.get(2);\n            callFunction(keywordArgs, positionalArgs, callable);\n        }\n    } else {\n        Object tos = stackMetadata.getTOS();\n        if (tos instanceof Iterable) {\n            Iterable<?> positionalArgs = (Iterable<?>) tos;\n            Callable<?> callable = (Callable<?>) stackMetadata.get(1);\n            callFunction(null, positionalArgs, callable);\n        }\n    }\n}\n\nprivate static void callFunction(Map<?, ?> keywordArgs, Iterable<?> positionalArgs, Callable<?> callable) {\n    // Implement the function call logic here\n}\n```\n\nPlease note that this is a simplified version of the code. In a real-world scenario, you would need to handle exceptions, check the types of the objects, and possibly do other things. Also, the `FunctionMetadata` and `StackMetadata` classes are not defined in the code snippet, so you need to replace them with the actual classes or interfaces that you have in your code.\n", "```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Your implementation here\n}\n```\n", "```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Your code here\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\n------------------------------\n------------------------------\npublic class VariableImplementor {\n\n    /**\n     * Loads the local variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\n    public static void loadLocalVariable(MethodVisitor methodVisitor, PythonBytecodeInstruction instruction,\n            LocalVariableHelper localVariableHelper) {\n        localVariableHelper.readLocal(methodVisitor, instruction.arg());\n    }\n------------------------------\n------------------------------\nlocalVariableHelper.readCell(methodVisitor, cellIndex);\n    }\n\n    /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\n------------------------------\n------------------------------\n/**\n     * Deletes the global variable or parameter indicated by the {@code instruction} argument.\n     */\n    public static void deleteGlobalVariable(MethodVisitor methodVisitor, String className,\n            PythonCompiledFunction pythonCompiledFunction,\n            PythonBytecodeInstruction instruction) {\n        String globalName = pythonCompiledFunction.co_names.get(instruction.arg());\n------------------------------\n------------------------------\n/**\n     * Stores TOS into the global variable or parameter indicated by the {@code instruction} argument.\n     */\n    public static void storeInGlobalVariable(MethodVisitor methodVisitor, String className,\n            PythonCompiledFunction pythonCompiledFunction,\n            PythonBytecodeInstruction instruction) {\n        String globalName = pythonCompiledFunction.co_names.get(instruction.arg());\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex,\n# Natural Language Annotations: /**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    String globalName = functionMetadata.getCoNames().get(globalIndex);\n    stackMetadata.push(globalName);\n}\n```\n", "```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // implementation here\n}\n```\n", "```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // Your code here\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nlocalVariableHelper.readCell(methodVisitor, cellIndex);\n    }\n\n    /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\n------------------------------\n------------------------------\n/**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\n------------------------------\n------------------------------\n/**\n     * Deletes the cell variable or parameter indicated by the {@code instruction} argument\n     * (which is an {@link PythonCell}, so changes in the parent function affect the variable in dependent functions).\n     */\n    public static void deleteCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n------------------------------\n------------------------------\n/**\n     * Stores TOS into the cell variable or parameter indicated by the {@code instruction} argument\n     * (which is an {@link PythonCell}, so changes in the parent function affect the variable in dependent functions).\n     */\n    public static void storeInCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n        MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n------------------------------\n------------------------------\n/**\n     * Loads the cell indicated by the {@code instruction} argument onto the stack.\n     * This is used by {@link VariableOpDescriptor#LOAD_CLOSURE} when creating a closure\n     * for a dependent function.\n     */\n    public static void createCell(MethodVisitor methodVisitor, LocalVariableHelper localVariableHelper, int cellIndex) {\n        methodVisitor.visitTypeInsn(Opcodes.NEW, Type.getInternalName(PythonCell.class));\n        methodVisitor.visitInsn(Opcodes.DUP);\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n# Natural Language Annotations: /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```\n", "```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```\n", "```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```\n"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class ObjectImplementor {\n\n    /**\n     * Replaces TOS with getattr(TOS, co_names[instruction.arg])\n     */\n------------------------------\n------------------------------\n/**\n     * Implements TOS = -TOS.\n     */\n    UNARY_NEGATIVE(PythonUnaryOperator.NEGATIVE),\n\n    /**\n     * Implements TOS = ~TOS.\n     */\n    UNARY_INVERT(PythonUnaryOperator.INVERT),\n\n    /**\n     * Implements TOS = TOS1 ** TOS.\n     */\n    BINARY_POWER(PythonBinaryOperator.POWER),\n\n    /**\n     * Implements TOS = TOS1 * TOS.\n     */\n    BINARY_MULTIPLY(PythonBinaryOperator.MULTIPLY),\n------------------------------\n------------------------------\n/**\n     * Implements TOS = TOS1 + TOS.\n     */\n    BINARY_ADD(PythonBinaryOperator.ADD),\n\n    /**\n     * Implements TOS = TOS1 - TOS.\n     */\n    BINARY_SUBTRACT(PythonBinaryOperator.SUBTRACT),\n\n    /**\n     * Implements TOS = TOS1[TOS].\n     */\n    BINARY_SUBSCR(PythonBinaryOperator.GET_ITEM),\n\n    /**\n     * Implements TOS = TOS2[TOS1:TOS]\n     */\n    BINARY_SLICE(GetSliceOpcode::new),\n\n    /**\n     * Implements TOS2[TOS1:TOS] = TOS3\n     */\n    STORE_SLICE(StoreSliceOpcode::new),\n------------------------------\n------------------------------\n/**\n     * Implements TOS = TOS1 &lt;&lt; TOS.\n     */\n    BINARY_LSHIFT(PythonBinaryOperator.LSHIFT),\n\n    /**\n     * Implements TOS = TOS1 &gt;&gt; TOS.\n     */\n    BINARY_RSHIFT(PythonBinaryOperator.RSHIFT),\n\n    /**\n     * Implements TOS = TOS1 &amp; TOS.\n     */\n    BINARY_AND(PythonBinaryOperator.AND),\n\n    /**\n     * Implements TOS = TOS1 ^ TOS.\n     */\n    BINARY_XOR(PythonBinaryOperator.XOR),\n------------------------------\n------------------------------\n/**\n     * Implements TOS = TOS1 @ TOS.\n     */\n    BINARY_MATRIX_MULTIPLY(PythonBinaryOperator.MATRIX_MULTIPLY),\n\n    /**\n     * Implements TOS = TOS1 // TOS.\n     */\n    BINARY_FLOOR_DIVIDE(PythonBinaryOperator.FLOOR_DIVIDE),\n\n    /**\n     * Implements TOS = TOS1 / TOS.\n     */\n    BINARY_TRUE_DIVIDE(PythonBinaryOperator.TRUE_DIVIDE),\n\n    /**\n     * Implements TOS = TOS1 % TOS.\n     */\n    BINARY_MODULO(PythonBinaryOperator.MODULO),\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n# Natural Language Annotations: /**\n     * Replaces TOS with getattr(TOS, co_names[instruction.arg])\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    // Get the top of stack (TOS)\n    Object topOfStack = stackMetadata.getTopOfStack();\n\n    // Get the attribute name from co_names using nameIndex\n    String attributeName = functionMetadata.getAttributeName(nameIndex);\n\n    // Replace TOS with getattr(TOS, co_names[instruction.arg])\n    Object attributeValue = getattr(topOfStack, attributeName);\n\n    // Update the top of stack with the new value\n    stackMetadata.setTopOfStack(attributeValue);\n}\n```\n", "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    // Get the current top of stack (TOS)\n    Object tos = stackMetadata.getTOS();\n\n    // Get the name from the code object\n    String name = functionMetadata.getCo_names()[nameIndex];\n\n    // Replace TOS with getattr(TOS, co_names[instruction.arg])\n    Object newTos = getattr(tos, name);\n\n    // Update the top of stack with the new value\n    stackMetadata.setTOS(newTos);\n}\n```\n", "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    // Get the current top of stack (TOS)\n    Object tos = stackMetadata.getTopOfStack();\n\n    // Get the attribute name from the co_names array\n    String attributeName = functionMetadata.getCoNames()[nameIndex];\n\n    // Replace TOS with getattr(TOS, attributeName)\n    Object newTos = getattr(tos, attributeName);\n    stackMetadata.setTopOfStack(newTos);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n     * @param solution never null\n     * @return {@code >= 0}\n     */\n------------------------------\n------------------------------\n/**\n     * Returns a scaled approximation of a log\n     * \n     * @param scale What to scale the result by. Typically, a power of 10.\n     * @param base The base of the log\n     * @param value The parameter to the log function\n     * @return A value approximately equal to {@code scale * log_base(value)}, rounded\n     *         to the nearest integer.\n     */\n    public static long getScaledApproximateLog(long scale, long base, long value) {\n------------------------------\n------------------------------\n/**\n     * @return {@code >= 0}\n     */\n    default int getConstraintMatchCount() {\n        return getConstraintMatchSet().size();\n    }\n\n    /**\n     * Sum of the {@link #getConstraintMatchSet()}'s {@link ConstraintMatch#getScore()}.\n     *\n     * @return never null\n     */\n    Score_ getScore();\n------------------------------\n------------------------------\n/**\n     * @return never null\n     */\n    Set<ConstraintMatch<Score_>> getConstraintMatchSet();\n\n    /**\n     * @return {@code >= 0}\n     */\n    default int getConstraintMatchCount() {\n        return getConstraintMatchSet().size();\n    }\n------------------------------\n------------------------------\n* @param constraintWeight never null\n     * @param matchWeigher never null, the result of this function (matchWeight) is multiplied by the constraintWeight\n     * @return never null\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n# Natural Language Annotations: /**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n     * @param solution never null\n     * @return {@code >= 0}\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    // Calculate the score\n    Score_ score = scoreDirector.calculateScore(solution);\n\n    // Get the constraint match set\n    Set<ConstraintMatch<Score_>> constraintMatchSet = score.getConstraintMatchSet();\n\n    // Calculate the total constraint match count\n    int totalConstraintMatchCount = constraintMatchSet.size();\n\n    // Get the total score\n    double totalScore = score.getScore().getTotalScore();\n\n    // Calculate the problem scale\n    double problemScale = getScaledApproximateLog(10, totalScore, totalConstraintMatchCount);\n\n    return problemScale;\n}\n```\n", "```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    long score = scoreDirector.calculateScore(solution);\n    long base = getScaledApproximateLog(10, 2, score);\n    return base;\n}\n```\n", "```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    int constraintMatchCount = scoreDirector.getConstraintMatchCount();\n    long score = scoreDirector.getScore().getInitScore();\n    long base = scoreDirector.getConstraintMatchSet().size();\n    long scale = 10; // Assuming base 10\n    return getScaledApproximateLog(scale, base, score);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given\n     * ClassCreator\n     */\n------------------------------\n------------------------------\n/**\n     * Generates the constructor and implementations of SolutionCloner\n     * methods for the given SolutionDescriptor using the given ClassCreator\n     */\n    public static void defineClonerFor(Supplier<GizmoSolutionClonerImplementor> implementorSupplier,\n            ClassCreator classCreator,\n            SolutionDescriptor<?> solutionDescriptor,\n            Set<Class<?>> solutionClassSet,\n------------------------------\n------------------------------\n/**\n     * Generates the constructor and implementations of {@link AbstractGizmoMemberAccessor} methods for the given\n     * {@link Member}.\n     *\n     * @param className never null\n     * @param classOutput never null, defines how to write the bytecode\n     * @param memberInfo never null, member to generate MemberAccessor methods implementation for\n     */\n    public static void defineAccessorFor(String className, ClassOutput classOutput, GizmoMemberInfo memberInfo) {\n------------------------------\n------------------------------\n* @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\n------------------------------\n------------------------------\n* @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void defineClonerFor(ClassCreator classCreator,\n# Natural Language Annotations: /**\n     * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given\n     * ClassCreator\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static void defineClonerFor(ClassCreator classCreator, SolutionDescriptor<?> solutionDescriptor, Set<Class<?>> solutionClassSet) {\n    // Your code here\n}\n```\n", "```java\npublic static void defineClonerFor(ClassCreator classCreator,\n        SolutionDescriptor<?> solutionDescriptor,\n        Set<Class<?>> solutionClassSet) {\n    // Your code here\n}\n```\n", "```java\npublic static void defineClonerFor(ClassCreator classCreator,\n        Supplier<GizmoSolutionClonerImplementor> implementorSupplier,\n        SolutionDescriptor<?> solutionDescriptor,\n        Set<Class<?>> solutionClassSet) {\n    // Your implementation here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Takes a look at the shadow variables of all entities and compares them against the recorded state. Every difference\n     * is added to the violation message. The first N differences up to the {@code violationDisplayLimit} are displayed\n     * in detail; the number of violations exceeding the display limit is reported at the end. The limit applies per each\n     * shadow variable descriptor.\n     * <p>\n------------------------------\n------------------------------\n* shadow variable descriptor.\n     * <p>\n     * This method should be called after a forceful trigger of variable listeners.\n     *\n     * @param violationDisplayLimit maximum number of violations reported per shadow variable descriptor\n     * @return description of the violations or {@code null} if there are none\n     */\n------------------------------\n------------------------------\n/**\n * Serves for detecting shadow variables' corruption. When a snapshot is created, it records the state of all shadow variables\n * of all entities. The {@link #createShadowVariablesViolationMessage} method takes a look at the shadow variables again,\n * compares their state with the recorded one and describes the difference in a violation message.\n */\n// Code for: public final class ShadowVariablesAssert {\n------------------------------\n------------------------------\n*\n     * <p>\n     * The score returned by {@link RecommendedFit#scoreAnalysisDiff()}\n     * is the difference between the score of the solution before and after fitting.\n     * Every recommendation will be in a state as if the solution was never changed;\n     * if it references entities,\n     * none of their genuine planning variables or shadow planning variables will be initialized.\n     * The input solution will be unchanged.\n     *\n     * <p>\n------------------------------\n------------------------------\n/**\n     * The source planning variable is a chained planning variable that leads to the anchor.\n     * <p>\n     * Both the genuine variable and the shadow variable should be consistent:\n     * if A chains to B, then A must have the same anchor as B (unless B is the anchor).\n     * <p>\n     * When the {@link Solver} changes a genuine variable, it adjusts the shadow variable accordingly.\n     * In practice, the {@link Solver} ignores shadow variables (except for consistency housekeeping).\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n# Natural Language Annotations: /**\n     * Takes a look at the shadow variables of all entities and compares them against the recorded state. Every difference\n     * is added to the violation message. The first N differences up to the {@code violationDisplayLimit} are displayed\n     * in detail; the number of violations exceeding the display limit is reported at the end. The limit applies per each\n     * shadow variable descriptor.\n     * <p>\n     * This method should be called after a forceful trigger of variable listeners.\n     *\n     * @param violationDisplayLimit maximum number of violations reported per shadow variable descriptor\n     * @return description of the violations or {@code null} if there are none\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    // Your code here\n}\n```\n", "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    // Your code here\n}\n```\n", "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    // Your code goes here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\n------------------------------\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\n    public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n------------------------------\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @param classLoader null or {@link GizmoClassLoader} if domainAccessType is {@link DomainAccessType#GIZMO}.\n------------------------------\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param domainAccessType never null\n     * @param classLoader null or {@link GizmoClassLoader} if domainAccessType is {@link DomainAccessType#GIZMO}.\n     * @return never null, new instance of the member accessor\n     */\n------------------------------\n------------------------------\n/**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n# Natural Language Annotations: /**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    // Implementation here\n}\n```\n", "```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    // Your code here\n}\n```\n", "```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    // Implementation goes here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class GizmoMemberAccessorFactory {\n    /**\n     * Returns the generated class name for a given member.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\n------------------------------\n------------------------------\npublic final class GizmoSolutionClonerFactory {\n    /**\n     * Returns the generated class name for a given solutionDescriptor.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param solutionDescriptor The solutionDescriptor to get the generated class name for\n     * @return The generated class name for solutionDescriptor\n     */\n    public static String getGeneratedClassName(SolutionDescriptor<?> solutionDescriptor) {\n------------------------------\n------------------------------\n/**\n     * Returns the declaring class name of the member in descriptor format.\n     * For instance, the declaring class name of Object.toString() is \"java/lang/Object\".\n     *\n     * @return Returns the declaring class name of the member in descriptor format\n     */\n    public String getDeclaringClassName() {\n        return memberHandler.getDeclaringClassName();\n    }\n\n    public Optional<MethodDescriptor> getSetter() {\n        return Optional.ofNullable(setter);\n    }\n------------------------------\n------------------------------\n/**\n     * Gets the {@code nameIndex} name from the class name list\n     *\n     * @param className The class currently being defined by the methodVisitor\n     * @param nameIndex The index of the name to load in the class name list\n     */\n    public static void loadName(MethodVisitor methodVisitor, String className, int nameIndex) {\n        methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, className,\n------------------------------\n------------------------------\n* return delegate.interfaceMethod1(arg0,arg1,...,finalArg);\n     * }\n     *\n     * #64;Override\n     * public Result interfaceMethod2(A0 arg0, A1 arg1, ..., A(N-1) finalArg) {\n     * return delegate.interfaceMethod2(arg0,arg1,...,finalArg);\n     * }\n     * }\n     *\n     * @param className The simple name of the generated class\n     * @param baseInterface the base interface\n     * @param delegateSupplier The Python class to delegate to\n     * @return never null\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String getGeneratedClassName(Member member) {\n# Natural Language Annotations: /**\n     * Returns the generated class name for a given member.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static String getGeneratedClassName(Member member) {\n    // Your code here\n}\n```\n", "```java\npublic static String getGeneratedClassName(Member member) {\n    // Implementation here\n}\n```\n", "```java\npublic static String getGeneratedClassName(Member member) {\n    // Function logic here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n------------------------------\n------------------------------\n* @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\n------------------------------\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @param classLoader null or {@link GizmoClassLoader} if domainAccessType is {@link DomainAccessType#GIZMO}.\n------------------------------\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\n------------------------------\n------------------------------\n/**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\n    public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass,\n# Natural Language Annotations: /**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    // Your code here\n}\n```\n", "```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    // Your implementation here\n}\n```\n", "```java\nstatic MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    // Implementation goes here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\n------------------------------\n------------------------------\n/**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\n------------------------------\n------------------------------\n/**\n     * Schedules a {@link ProblemChange} to be processed by the underlying {@link Solver} and returns immediately.\n     * <p>\n     * To learn more about problem change semantics, please refer to the {@link ProblemChange} Javadoc.\n     *\n     * @param problemChange never null\n     * @return completes after the best solution containing this change has been consumed.\n     * @throws IllegalStateException if the underlying {@link Solver} is not in the {@link SolverStatus#SOLVING_ACTIVE}\n------------------------------\n------------------------------\n*        or {@link #solveAndListen(Object, Object, Consumer)}\n     * @param problemChange never null\n     * @return completes after the best solution containing this change has been consumed.\n     * @throws IllegalStateException if there is no solver actively solving the problem associated with the problemId\n     */\n    CompletableFuture<Void> addProblemChange(ProblemId_ problemId, ProblemChange<Solution_> problemChange);\n------------------------------\n------------------------------\n* <p>\n     * In real-time planning\n     * If {@link Solver#addProblemChange(ProblemChange)} has been called once or more,\n     * all {@link ProblemChange}s in the queue will be processed and this method is called only once.\n     * In that case, the former best {@link PlanningSolution} is considered stale,\n     * so it doesn't matter whether the new {@link Score} is better than that or not.\n     *\n     * @param event never null\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n# Natural Language Annotations: /**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nvoid set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```\n", "```java\nvoid set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```\n", "```java\nvoid set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        // Replace the previous best solution with the new one\n        this.bestSolution = bestSolution;\n    }\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\n------------------------------\n------------------------------\n/**\n     * Schedules a {@link ProblemChange} to be processed by the underlying {@link Solver} and returns immediately.\n     * <p>\n     * To learn more about problem change semantics, please refer to the {@link ProblemChange} Javadoc.\n     *\n     * @param problemChange never null\n     * @return completes after the best solution containing this change has been consumed.\n     * @throws IllegalStateException if the underlying {@link Solver} is not in the {@link SolverStatus#SOLVING_ACTIVE}\n------------------------------\n------------------------------\n*        or {@link #solveAndListen(Object, Object, Consumer)}\n     * @param problemChange never null\n     * @return completes after the best solution containing this change has been consumed.\n     * @throws IllegalStateException if there is no solver actively solving the problem associated with the problemId\n     */\n    CompletableFuture<Void> addProblemChange(ProblemId_ problemId, ProblemChange<Solution_> problemChange);\n------------------------------\n------------------------------\n/**\n * This interface is deprecated.\n * A ProblemFactChange represents a change in 1 or more problem facts of a {@link PlanningSolution}.\n * Problem facts used by a {@link Solver} must not be changed while it is solving,\n * but by scheduling this command to the {@link Solver}, you can change them when the time is right.\n * <p>\n * Note that the {@link Solver} clones a {@link PlanningSolution} at will.\n------------------------------\n------------------------------\n/**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n# Natural Language Annotations: /**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    // Add the problem change to the solver\n    solver.addProblemChange(problemChange);\n\n    // Create a new CompletableFuture \n    CompletableFuture<Void> future = new CompletableFuture<>();\n\n    // Register a callback to the solver that will complete the future when the best solution containing this change is passed to a user-defined Consumer\n    solver.addBestSolutionChangedListener(bestSolution -> {\n        if (bestSolution.contains(problemChange)) {\n            future.complete(null);\n        }\n    });\n\n    return future;\n}\n```\n", "```java\npublic CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    solver.addProblemChange(problemChange);\n    return solver.take();\n}\n```\n", "```java\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    // Check if the solver is in the SOLVING_ACTIVE status\n    if (!solver.getSolverStatus().equals(SolverStatus.SOLVING_ACTIVE)) {\n        throw new IllegalStateException(\"The Solver is not in the SOLVING_ACTIVE status\");\n    }\n\n    // Add the problem change to the solver\n    solver.addProblemChange(problemChange);\n\n    // Create a CompletableFuture to be completed after the best solution containing this change is passed to a user-defined Consumer\n    CompletableFuture<Void> future = new CompletableFuture<>();\n\n    // Register a callback to be called when the best solution containing this change is passed to a user-defined Consumer\n    solver.setBestSolutionConsumer(bestSolution -> {\n        if (bestSolution.getProblemChanges().contains(problemChange)) {\n            future.complete(null);\n        }\n    });\n\n    return future;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic class RandomUtils {\n\n    /**\n     * Mimics {@link Random#nextInt(int)} for longs.\n     *\n     * @param random never null\n     * @param n {@code > 0L}\n     * @return like {@link Random#nextInt(int)} but for a long\n     * @see Random#nextInt(int)\n     */\n------------------------------\n------------------------------\n/**\n     * Mimics {@link Random#nextInt(int)} for doubles.\n     *\n     * @param random never null\n     * @param n {@code > 0.0}\n     * @return like {@link Random#nextInt(int)} but for a double\n     * @see Random#nextInt(int)\n     */\n    public static double nextDouble(Random random, double n) {\n        // This code is based on java.util.Random#nextInt(int)'s javadoc.\n        if (n <= 0.0) {\n            throw new IllegalArgumentException(\"n must be positive\");\n        }\n------------------------------\n------------------------------\n/**\n     * As specified by {@link ValueRangeDescriptor#extractValueRangeSize}.\n     *\n     * @param solution never null\n     * @return never null\n     * @see ValueRangeDescriptor#extractValueRangeSize\n     */\n    long extractValueRangeSize(Solution_ solution);\n\n}\n------------------------------\n------------------------------\n/**\n     * Parses the {@link String} and returns a {@link Score}.\n     *\n     * @param scoreString never null\n     * @return never null\n     * @see #formatScore(Score)\n     */\n    Score_ parseScore(String scoreString);\n------------------------------\n------------------------------\n/**\n     * Build a {@link CountableValueRange} of a subset of {@link LocalDate} values between 2 bounds.\n     * <p>\n     * Facade for {@link #createTemporalValueRange(Temporal, Temporal, long, TemporalUnit)}.\n     *\n     * @param from never null, inclusive minimum\n     * @param to never null, exclusive maximum, {@code >= from}\n     * @param incrementUnitAmount {@code > 0}\n     * @param incrementUnitType never null, must be {@link LocalDate#isSupported(TemporalUnit) supported}\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static long nextLong(Random random, long n) {\n# Natural Language Annotations: /**\n     * Mimics {@link Random#nextInt(int)} for longs.\n     *\n     * @param random never null\n     * @param n {@code > 0L}\n     * @return like {@link Random#nextInt(int)} but for a long\n     * @see Random#nextInt(int)\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static long nextLong(Random random, long n) {\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n\n    long bits, val;\n    do {\n        bits = (random.nextLong() << 1) >>> 1;\n        val = bits % n;\n    } while (bits - val + (n - 1) < 0L);\n    return val;\n}\n```\n", "```java\npublic static long nextLong(Random random, long n) {\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n\n    long bits, val;\n    do {\n        bits = (random.nextLong() << 1) >>> 1;\n        val = bits % n;\n    } while (bits - val + (n - 1) < 0L);\n    return val;\n}\n```\n", "```java\npublic static long nextLong(Random random, long n) {\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n    long bits, val;\n    do {\n        bits = (random.nextLong() << 1) >>> 1;\n        val = bits % n;\n    } while (bits - val + (n - 1) < 0L);\n    return val;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n/**\n     * Get the minimum number of overlapping ranges for any point contained by\n     * this {@link ConnectedRange}.\n     * \n     * @return never null, the minimum number of overlapping ranges for any point\n     *         in this {@link ConnectedRange}.\n     */\n    int getMinimumOverlap();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new IllegalArgumentException(\"solverScope cannot be null\");\n    }\n\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0 && timeGradient < minTimeGradient) {\n            minTimeGradient = timeGradient;\n        }\n    }\n\n    return minTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new IllegalArgumentException(\"solverScope cannot be null\");\n    }\n\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n\n    return minTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Get the minimum number of overlapping ranges for any point contained by\n     * this {@link ConnectedRange}.\n     * \n     * @return never null, the minimum number of overlapping ranges for any point\n     *         in this {@link ConnectedRange}.\n     */\n    int getMinimumOverlap();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : phaseScope.getTerminations()) {\n        if (termination.getTimeGradient() != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, termination.getTimeGradient());\n        }\n    }\n    return minTimeGradient;\n}\n```\n", "```java\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : phaseScope.getTerminations()) {\n        if (termination.getTimeGradient() != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, termination.getTimeGradient());\n        }\n    }\n    return minTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    if (phaseScope == null) {\n        throw new IllegalArgumentException(\"phaseScope cannot be null\");\n    }\n\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0 && timeGradient < minTimeGradient) {\n            minTimeGradient = timeGradient;\n        }\n    }\n\n    return minTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n/**\n     * Get the maximum number of overlapping ranges for any point contained by\n     * this {@link ConnectedRange}.\n     * \n     * @return never null, the maximum number of overlapping ranges for any point\n     *         in this {@link ConnectedRange}.\n     */\n    int getMaximumOverlap();\n\n    /**\n     * Get the length of this {@link ConnectedRange}.\n     * \n     * @return The difference between {@link #getEnd()} and {@link #getStart()}.\n     */\n    Difference_ getLength();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = Double.MIN_VALUE;\n    for (Termination termination : solverScope.getTerminations()) {\n        if (termination.getTimeGradient() != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, termination.getTimeGradient());\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new IllegalArgumentException(\"solverScope cannot be null\");\n    }\n\n    double maxTimeGradient = Double.MIN_VALUE;\n\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient > maxTimeGradient && timeGradient != -1.0) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = Double.MIN_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        if (termination.getTimeGradient() != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, termination.getTimeGradient());\n        }\n    }\n    return maxTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n\n\n\n\n\n\n\n\n\n\n\n\n    // ************************************************************************\n    // Other methods\n    // ************************************************************************\n------------------------------\n------------------------------\n// ************************************************************************\n    // Time gradient methods\n    // ************************************************************************\n\n    /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\n------------------------------\n------------------------------\n/**\n     * Get the maximum number of overlapping ranges for any point contained by\n     * this {@link ConnectedRange}.\n     * \n     * @return never null, the maximum number of overlapping ranges for any point\n     *         in this {@link ConnectedRange}.\n     */\n    int getMaximumOverlap();\n\n    /**\n     * Get the length of this {@link ConnectedRange}.\n     * \n     * @return The difference between {@link #getEnd()} and {@link #getStart()}.\n     */\n    Difference_ getLength();\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    if (phaseScope == null) {\n        throw new IllegalArgumentException(\"phaseScope cannot be null\");\n    }\n\n    double maxTimeGradient = Double.MIN_VALUE;\n    for (Termination termination : phaseScope.getTerminations()) {\n        if (termination.getTimeGradient() != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, termination.getTimeGradient());\n        }\n    }\n    return maxTimeGradient;\n}\n```\n", "```java\n@Override   \npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    if (phaseScope == null) {\n        throw new IllegalArgumentException(\"PhaseScope cannot be null.\");\n    }\n\n    double maxTimeGradient = Double.MIN_VALUE;\n\n    for (Termination termination : phaseScope.getTerminations()) {\n        if (termination.getTimeGradient() != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, termination.getTimeGradient());\n        }\n    }\n\n    return maxTimeGradient;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n     * <br />\n     * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n     * unique elements (p_1, p_2, ..., p_k) where\n     * <ul>\n     * <li>p_1 maps to p_2 in the permutation</li>\n     * <li>p_2 maps to p_3 in the permutation</li>\n     * <li>p_(k-1) maps to p_k in the permutation</li>\n     * <li>p_k maps to p_1 in the permutation</li>\n------------------------------\n------------------------------\n* <li>In general: p_i maps to p_(i+1) in the permutation</li>\n     * </ul>\n     * For instance, the permutation\n     * <ul>\n     * <li>1 -> 2</li>\n     * <li>2 -> 3</li>\n     * <li>3 -> 1</li>\n     * <li>4 -> 5</li>\n     * <li>5 -> 4</li>\n     * </ul>\n     * can be expressed as `(1, 2, 3)(4, 5)`.\n     *\n     * @return The {@link KOptCycle} corresponding to the permutation described by\n     *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n------------------------------\n------------------------------\n* described by this {@link KOptDescriptor}.<br />\n     * <br />\n     * The algorithm goal is to convert a signed permutation (p_1, p_2, ..., p_(2k)) into the identify permutation\n     * (+1, +2, +3, ..., +(2k - 1), +2k). It can be summarized as:\n     *\n     * <ul>\n     * <li>\n     * As long as there are oriented pairs, perform the reversal that corresponds to the oriented pair with the\n     * maximal score (described in {@link #countOrientedPairsForReversal}).\n     * </li>\n     * <li>\n------------------------------\n------------------------------\n/**\n * Describes the minimal amount of cycles a permutation can be expressed as\n * and provide a mapping of removed edge endpoint index to cycle identifier\n * (where all indices that are in the same k-cycle have the same identifier).\n *\n * @param cycleCount The total number of k-cycles in the permutation.\n *        This is one more than the maximal value in {@link KOptCycle#indexToCycleIdentifier}.\n------------------------------\n------------------------------\n* Oriented pairs are useful as they indicate reversals that cause adjacent integers to be\n     * consecutive in the resulting permutation. For example, the oriented pair (-2, +3) induces\n     * the reversal <br>\n     * (+1 -2 -5 +4 +3) -> (+1 -4 +5 +2 +3) <br>\n     * creating a permutation where +3 is consecutive to +2. <br />\n     * <br />\n     * In general, the reversal induced by and oriented pair (p_i, p_j) is <br />\n     * p(i, j-1), if p_i + p_j = +1, and <br />\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n# Natural Language Annotations: /**\n     * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n     * <br />\n     * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n     * unique elements (p_1, p_2, ..., p_k) where\n     * <ul>\n     * <li>p_1 maps to p_2 in the permutation</li>\n     * <li>p_2 maps to p_3 in the permutation</li>\n     * <li>p_(k-1) maps to p_k in the permutation</li>\n     * <li>p_k maps to p_1 in the permutation</li>\n     * <li>In general: p_i maps to p_(i+1) in the permutation</li>\n     * </ul>\n     * For instance, the permutation\n     * <ul>\n     * <li>1 -> 2</li>\n     * <li>2 -> 3</li>\n     * <li>3 -> 1</li>\n     * <li>4 -> 5</li>\n     * <li>5 -> 4</li>\n     * </ul>\n     * can be expressed as `(1, 2, 3)(4, 5)`.\n     *\n     * @return The {@link KOptCycle} corresponding to the permutation described by\n     *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n     * @param kOptDescriptor The descriptor to calculate cycles for\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    Map<Integer, Integer> removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    int cycleCount = 0;\n    Map<Integer, Integer> indexToCycleIdentifier = new HashMap<>();\n    for (int i = 0; i < removedEdgeIndexToTourOrder.size(); i++) {\n        if (indexToCycleIdentifier.get(i) == null) {\n            int j = i;\n            cycleCount++;\n            do {\n                indexToCycleIdentifier.put(j, cycleCount);\n                j = removedEdgeIndexToTourOrder.get(j);\n            } while (j != i);\n        }\n    }\n    return new KOptCycle(cycleCount, indexToCycleIdentifier);\n}\n```\n", "```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    Map<Integer, List<Integer>> cycles = new HashMap<>();\n    Map<Integer, Boolean> visited = new HashMap<>();\n    Map<Integer, Integer> edgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n\n    for (Map.Entry<Integer, Integer> entry : edgeIndexToTourOrder.entrySet()) {\n        if (!visited.containsKey(entry.getKey())) {\n            List<Integer> cycle = new ArrayList<>();\n            Integer current = entry.getKey();\n            cycle.add(current);\n            visited.put(current, true);\n\n            while (true) {\n                Integer next = edgeIndexToTourOrder.get(current);\n                if (next == null || visited.containsKey(next)) {\n                    break;\n                }\n                cycle.add(next);\n                visited.put(next, true);\n                current = next;\n            }\n            cycles.put(entry.getKey(), cycle);\n        }\n    }\n\n    // Build KOptCycle from cycles map\n    int cycleCount = cycles.size();\n    Map<Integer, Integer> indexToCycleIdentifier = new HashMap<>();\n    int cycleIdentifier = 0;\n    for (List<Integer> cycle : cycles.values()) {\n        for (Integer index : cycle) {\n            indexToCycleIdentifier.put(index, cycleIdentifier);\n        }\n        cycleIdentifier++;\n    }\n\n    return new KOptCycle(cycleCount, indexToCycleIdentifier);\n}\n```\n", "```java\npublic static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    Map<Integer, Integer> removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    Map<Integer, Integer> indexToCycleIdentifier = new HashMap<>();\n    int cycleCount = 0;\n    for (int i = 0; i < removedEdgeIndexToTourOrder.size(); i++) {\n        if (!indexToCycleIdentifier.containsKey(i)) {\n            cycleCount++;\n            int j = i;\n            do {\n                indexToCycleIdentifier.put(j, cycleCount);\n                j = removedEdgeIndexToTourOrder.get(j);\n            } while (j != i);\n        }\n    }\n    return new KOptCycle(cycleCount, indexToCycleIdentifier);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\n\n\n\n\n\n\n\n\n\n\n    record TriangleElement(int index, int level, int indexOnLevel) {\n------------------------------\n------------------------------\n* }\n     * </pre>\n     *\n     * @param variableDescriptor descriptor of a list variable, for example {@code Employee.taskList}\n     * @param leftEntity together with {@code leftIndex} identifies the left element to be moved\n     * @param leftIndex together with {@code leftEntity} identifies the left element to be moved\n     * @param rightEntity together with {@code rightIndex} identifies the right element to be moved\n------------------------------\n------------------------------\n/**\n     * The listener must unset all shadow variables it is responsible for when an element is unassigned from the source list\n     * variable. For example, a {@code Task}'s {@code startTime} shadow variable must be reset to {@code null} after a task\n     * is unassigned from {@code Employee.tasks} when the move that assigned it there is undone during Construction Heuristic\n     * phase.\n     *\n     * @param scoreDirector score director\n     * @param element the unassigned element\n------------------------------\n------------------------------\npublic interface IndexVariableSupply extends Supply {\n\n    /**\n     * Get {@code planningValue}'s index in the {@link PlanningListVariable list variable} it is an element of.\n     *\n     * @param planningValue never null\n     * @return {@code planningValue}'s index in the list variable it is an element of or {@code null} if the value is unassigned\n     */\n    Integer getIndex(Object planningValue);\n}\n------------------------------\n------------------------------\n/**\n * Specifies that a bean property (or a field) references the next element in the same {@link PlanningListVariable}.\n * The next element's index is 1 higher than this element's index.\n * It is {@code null} if this element is the last element in the list variable.\n * <p>\n * It is specified on a getter of a java bean property (or a field) of a {@link PlanningEntity} class.\n * <p>\n * The source variable must be a {@link PlanningListVariable list variable}.\n */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n# Natural Language Annotations: /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"listSize is less than minimumSubListSize\");\n    }\n\n    int level = (int) (Math.random() * (listSize + 1));\n    int indexOnLevel = (int) (Math.random() * (level + 1));\n    int index = level * (level + 1) / 2 + indexOnLevel;\n\n    return new TriangleElement(index, level, indexOnLevel);\n}\n```\n", "```java\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"listSize is less than minimumSubListSize\");\n    }\n\n    int randomIndex = new Random().nextInt(listSize);\n    int level = 0;\n    int indexOnLevel = randomIndex;\n\n    while (randomIndex >= 0) {\n        level++;\n        randomIndex -= level;\n    }\n\n    indexOnLevel += level;\n    return new TriangleElement(randomIndex, level, indexOnLevel);\n}\n```\n", "```java\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < 1) {\n        throw new IllegalArgumentException(\"listSize must be greater than 0\");\n    }\n\n    int level = (int) (Math.random() * listSize) + 1;\n    int indexOnLevel = (int) (Math.random() * level) + 1;\n\n    return new TriangleElement(listSize, level, indexOnLevel);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Return a list of justifications for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n     * (eg. [A, B] for a bi stream),\n     * unless a custom justification mapping was provided, in which case it throws an exception,\n------------------------------\n------------------------------\n/**\n     * Return a singular justification for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns {@link DefaultConstraintJustification} from the matching tuple\n     * (eg. [A, B] for a bi stream), unless a custom justification mapping was provided,\n     * in which case it returns the return value of that function.</li>\n------------------------------\n------------------------------\n/**\n     * Returns a set of objects indicted for causing this constraint match.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns the facts from the matching tuple\n     * (eg. [A, B] for a bi stream), unless a custom indictment mapping was provided,\n     * in which case it returns the return value of that function.</li>\n------------------------------\n------------------------------\n* pointing users towards {@link #getJustification()}.</li>\n     * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n     * @return never null\n     */\n------------------------------\n------------------------------\n* <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @return never null\n     */\n    public <Justification_ extends ConstraintJustification> Justification_ getJustification() {\n        return (Justification_) justification;\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true)    public List<Object> getJustificationList() {\n# Natural Language Annotations: /**\n     * Return a list of justifications for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n     * (eg. [A, B] for a bi stream),\n     * unless a custom justification mapping was provided, in which case it throws an exception,\n     * pointing users towards {@link #getJustification()}.</li>\n     * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    // TODO: Implement this method based on the score director and custom justification mapping\n    throw new UnsupportedOperationException(\"This method is deprecated. Use getJustification() or getIndictedObjectList() instead.\");\n}\n```\n", "```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    if (justification instanceof ConstraintJustification) {\n        return Arrays.asList(((ConstraintJustification) justification).getFacts());\n    } else if (justification instanceof DefaultConstraintJustification) {\n        return Arrays.asList(((DefaultConstraintJustification) justification).getFacts());\n    } else {\n        throw new IllegalStateException(\"Unexpected value: \" + justification);\n    }\n}\n```\n", "```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    if (justification instanceof List) {\n        return (List<Object>) justification;\n    } else {\n        return Arrays.asList(justification);\n    }\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n* @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n------------------------------\n------------------------------\n* @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n------------------------------\n------------------------------\n* @param subCollector4 never null, fourth collector to compose\n     * @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n------------------------------\n------------------------------\n* @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResultContainer3_> generic type of the third sub collector's result container\n     * @param <SubResultContainer4_> generic type of the fourth sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n------------------------------\n------------------------------\n* @param <SubResultContainer3_> generic type of the third sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n     * @param <SubResult3_> generic type of the third sub collector's return value\n     * @return never null\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>            UniConstraintCollector<A, ?, Result_> compose(\n# Natural Language Annotations: /**\n     * Returns a constraint collector the result of which is a composition of other constraint collectors.\n     * The return value of this collector, incl. the default return value, depends solely on the compose function.\n     *\n     * @param subCollector1 never null, first collector to compose\n     * @param subCollector2 never null, second collector to compose\n     * @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, ?, SubResult1_> subCollector1,\n                UniConstraintCollector<A, ?, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    // Your code here\n}\n```\n", "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, ?, SubResult1_> subCollector1,\n                UniConstraintCollector<A, ?, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    // Your implementation here\n}\n```\n", "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>            UniConstraintCollector<A, ?, Result_> compose(\n    ConstraintCollector<A, ?, SubResult1_> subCollector1,\n    ConstraintCollector<A, ?, SubResult2_> subCollector2,\n    BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return null; // You need to implement this function based on the provided signature and annotations\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n*                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n------------------------------\n------------------------------\n*                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n------------------------------\n------------------------------\n// *****************************************************************\n    // toConnectedRanges\n    // *****************************************************************\n    /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n------------------------------\n------------------------------\n*        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\n------------------------------\n------------------------------\n/**\n     * As defined by {@link #toConnectedRanges(Function,Function,BiFunction)}.\n     *\n     * @param intervalMap Maps both facts to an item in the cluster\n     * @param startInclusiveMap Maps the item to its start\n     * @param endExclusiveMap Maps the item to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>            toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n# Natural Language Annotations: /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n     *                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n     *                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\ntoConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap, BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    // Your implementation here\n}\n```\n", "```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\ntoConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap, BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    // Implementation goes here\n}\n```\n", "```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\ntoConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap, BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    // Your implementation here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Compare this {@link ScoreAnalysis} to another {@link ScoreAnalysis}\n     * and retrieve the difference between them.\n     * The comparison is in the direction of {@code this - other}.\n     * <p>\n     * Example: if {@code this} has a score of 100 and {@code other} has a score of 90,\n     * the returned {@link ScoreAnalysis#score} will be 10.\n     * If this and other were inverted, the score would have been -10.\n------------------------------\n------------------------------\n* The same applies to all other properties of {@link ScoreAnalysis}.\n     *\n     * <p>\n     * In order to properly diff {@link MatchAnalysis} against each other,\n     * we rely on the user implementing {@link ConstraintJustification} equality correctly.\n     * In other words, the diff will consider two justifications equal if the user says they are equal,\n     * and it expects the hash code to be consistent with equals.\n     *\n     * <p>\n------------------------------\n------------------------------\n*\n     * <p>\n     * If one {@link ScoreAnalysis} provides {@link MatchAnalysis} and the other doesn't, exception is thrown.\n     * Such {@link ScoreAnalysis} instances are mutually incompatible.\n     *\n     * @param other never null\n     * @return never null\n     */\n------------------------------\n------------------------------\n/**\n * Represents the breakdown of a {@link Score} into individual {@link ConstraintAnalysis} instances,\n * one for each constraint.\n * Compared to {@link ScoreExplanation}, this is JSON-friendly and faster to generate.\n *\n * <p>\n * In order to be fully serializable to JSON, {@link MatchAnalysis} instances must be serializable to JSON\n * and that requires any implementations of {@link ConstraintJustification} to be serializable to JSON.\n * This is the responsibility of the user.\n *\n * <p>\n------------------------------\n------------------------------\n*\n * <p>\n * For deserialization from JSON, the user needs to provide the deserializer themselves.\n * This is due to the fact that, once the {@link ScoreAnalysis} is received over the wire,\n * we no longer know which {@link Score} type or {@link ConstraintJustification} type was used.\n * The user has all of that information in their domain model,\n * and so they are the correct party to provide the deserializer.\n *\n * <p>\n * Note: the constructors of this record are off-limits.\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n# Natural Language Annotations: /**\n     * Compare this {@link ScoreAnalysis} to another {@link ScoreAnalysis}\n     * and retrieve the difference between them.\n     * The comparison is in the direction of {@code this - other}.\n     * <p>\n     * Example: if {@code this} has a score of 100 and {@code other} has a score of 90,\n     * the returned {@link ScoreAnalysis#score} will be 10.\n     * If this and other were inverted, the score would have been -10.\n     * The same applies to all other properties of {@link ScoreAnalysis}.\n     *\n     * <p>\n     * In order to properly diff {@link MatchAnalysis} against each other,\n     * we rely on the user implementing {@link ConstraintJustification} equality correctly.\n     * In other words, the diff will consider two justifications equal if the user says they are equal,\n     * and it expects the hash code to be consistent with equals.\n     *\n     * <p>\n     * If one {@link ScoreAnalysis} provides {@link MatchAnalysis} and the other doesn't, exception is thrown.\n     * Such {@link ScoreAnalysis} instances are mutually incompatible.\n     *\n     * @param other never null\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (this.getMatchAnalysis() == null && other.getMatchAnalysis() != null) {\n        throw new IllegalArgumentException(\"Mutually incompatible ScoreAnalysis instances.\");\n    }\n\n    Score_ diffScore = this.getScore().subtract(other.getScore());\n    List<ConstraintAnalysis<Score_>> diffConstraints = new ArrayList<>();\n\n    for (ConstraintAnalysis<Score_> thisConstraint : this.getConstraints()) {\n        boolean found = false;\n        for (ConstraintAnalysis<Score_> otherConstraint : other.getConstraints()) {\n            if (thisConstraint.getJustification().equals(otherConstraint.getJustification())) {\n                Score_ diffScoreConstraint = thisConstraint.getScore().subtract(otherConstraint.getScore());\n                ConstraintAnalysis<Score_> diffConstraint = new ConstraintAnalysis<>(diffScoreConstraint, thisConstraint.getJustification());\n                diffConstraints.add(diffConstraint);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            diffConstraints.add(thisConstraint);\n        }\n    }\n\n    return new ScoreAnalysis<>(diffScore, diffConstraints, this.getMatchAnalysis());\n}\n```\n\nPlease note that this function assumes that the `Score_` class has a `subtract` method that takes another `Score_` and returns the difference. Also, it assumes that the `ConstraintAnalysis` class has a `getJustification` method that returns the justification of the constraint, and a `getScore` method that returns the score of the constraint.\n", "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (other == null) {\n        throw new IllegalArgumentException(\"Other ScoreAnalysis cannot be null\");\n    }\n    if (this.getMatchAnalysis() == null && other.getMatchAnalysis() != null) {\n        throw new IllegalArgumentException(\"Mutually incompatible ScoreAnalysis instances\");\n    }\n    Score_ diffScore = this.getScore().subtract(other.getScore());\n    List<ConstraintAnalysis> diffConstraints = new ArrayList<>();\n    for (int i = 0; i < this.getConstraintAnalyses().size(); i++) {\n        ConstraintAnalysis thisAnalysis = this.getConstraintAnalyses().get(i);\n        ConstraintAnalysis otherAnalysis = other.getConstraintAnalyses().get(i);\n        ConstraintJustification diffJustification = thisAnalysis.getJustification().diff(otherAnalysis.getJustification());\n        ConstraintAnalysis diffAnalysis = new ConstraintAnalysis(diffJustification, diffJustification.getScore());\n        diffConstraints.add(diffAnalysis);\n    }\n    return new ScoreAnalysis<>(diffScore, diffConstraints, this.getMatchAnalysis());\n}\n```\n", "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    // Compare the score between this ScoreAnalysis and other ScoreAnalysis\n    Score_ scoreDiff = this.getScore().diff(other.getScore());\n\n    // Compare the matchAnalysis between this ScoreAnalysis and other ScoreAnalysis\n    MatchAnalysis matchAnalysisDiff = this.getMatchAnalysis().diff(other.getMatchAnalysis());\n\n    // Compare the constraintAnalysis between this ScoreAnalysis and other ScoreAnalysis\n    ConstraintAnalysis constraintAnalysisDiff = this.getConstraintAnalysis().diff(other.getConstraintAnalysis());\n\n    // Create a new ScoreAnalysis with the differences\n    ScoreAnalysis<Score_> diffScoreAnalysis = new ScoreAnalysis<>(scoreDiff, matchAnalysisDiff, constraintAnalysisDiff);\n\n    return diffScoreAnalysis;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n------------------------------\n------------------------------\n/**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintMatch} API to identify which\n     * constraints or planning entities cause that score quality.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, to provide this information in a UI or a service,\n------------------------------\n------------------------------\n/**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintMatch} API to identify which\n     * constraints or planning entities cause that score quality.\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     * <p>\n     * Do not parse this string.\n     * Instead, to provide this information in a UI or a service, use {@link #explainScore(Object)}\n------------------------------\n------------------------------\n* Instead, provide this information in a UI or a service,\n     * use {@link ScoreAnalysis#constraintAnalyses()}\n     * and convert those into a domain-specific API.\n     *\n     * @return never null\n     */\n------------------------------\n------------------------------\n/**\n     * Return name of the constraint that this analysis is for.\n     *\n     * @return equal to {@code constraintRef.constraintName()}\n     */\n    public String constraintName() {\n        return constraintRef.constraintName();\n    }\n\n    /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, provide this information in a UI or a service,\n     * use {@link ScoreAnalysis#constraintAnalyses()}\n     * and convert those into a domain-specific API.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    for (ConstraintAnalysis analysis : scoreAnalysis.constraintAnalyses()) {\n        if (!analysis.isFeasible()) {\n            sb.append(\"Constraint \").append(analysis.constraintName()).append(\" caused the infeasibility of the solution.\");\n        }\n    }\n    return sb.toString();\n}\n```\n", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Score Quality Explanation:\\n\");\n\n    for (ConstraintAnalysis constraintAnalysis : ScoreAnalysis.constraintAnalyses()) {\n        sb.append(\"Constraint: \").append(constraintAnalysis.constraintName()).append(\"\\n\");\n        sb.append(\"Score Quality: \").append(constraintAnalysis.score()).append(\"\\n\");\n        sb.append(\"Diagnostic Text: \").append(constraintAnalysis.diagnosticText()).append(\"\\n\");\n        sb.append(\"\\n\");\n    }\n\n    return sb.toString();\n}\n```\n", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n    summary.append(\"This is a summary of the solution:\\n\");\n\n    for (ConstraintAnalysis analysis : scoreAnalysis.constraintAnalyses()) {\n        if (analysis.isFeasible()) {\n            summary.append(\"Constraint \").append(analysis.constraintName()).append(\" is feasible.\\n\");\n        } else {\n            summary.append(\"Constraint \").append(analysis.constraintName()).append(\" is not feasible. Diagnostic: \").append(analysis.diagnostic()).append(\"\\n\");\n        }\n    }\n\n    return summary.toString();\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Return name of the constraint that this analysis is for.\n     *\n     * @return equal to {@code constraintRef.constraintName()}\n     */\n    public String constraintName() {\n        return constraintRef.constraintName();\n    }\n\n    /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\n------------------------------\n------------------------------\n/**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n------------------------------\n------------------------------\n/**\n     * Returns the {@link Class} of the actual {@link Score} implementation.\n     * For example: returns {@link HardSoftScore HardSoftScore.class} on {@link HardSoftScoreDefinition}.\n     *\n     * @return never null\n     */\n    Class<Score_> getScoreClass();\n\n    /**\n     * The score that represents zero.\n     *\n     * @return never null\n     */\n    Score_ getZeroScore();\n------------------------------\n------------------------------\n/**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintMatch} API to identify which\n     * constraints or planning entities cause that score quality.\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     * <p>\n     * Do not parse this string.\n     * Instead, to provide this information in a UI or a service, use {@link #explainScore(Object)}\n------------------------------\n------------------------------\n/**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintMatch} API to identify which\n     * constraints or planning entities cause that score quality.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, to provide this information in a UI or a service,\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    // Your implementation here\n}\n```\n", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    // Your code here\n}\n```\n", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    // Your code here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n------------------------------\n------------------------------\n/**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n------------------------------\n------------------------------\n* @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\n------------------------------\n------------------------------\n* @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\n------------------------------\n------------------------------\n* The rest of the tuple will be padded with the results of the padding functions,\n     * applied on the new instance.\n     *\n     * @param otherClass never null\n     * @param paddingFunctionB never null, function to find the padding for the second fact\n     * @param paddingFunctionC never null, function to find the padding for the third fact\n     * @param paddingFunctionD never null, function to find the padding for the fourth fact\n     * @return never null\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n# Natural Language Annotations: /**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(locale);\n    DecimalFormat localizedFormat = (DecimalFormat) NumberFormat.getNumberInstance(locale);\n    localizedFormat.setDecimalFormatSymbols(otherSymbols);\n    return localizedFormat.format(number);\n}\n```\n", "```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    decimalFormat.setLocale(locale);\n    return decimalFormat.format(number);\n}\n```\n", "```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormatSymbols otherSymbols = new DecimalFormatSymbols(locale);\n    DecimalFormat localizedFormat = (DecimalFormat) DecimalFormat.getInstance();\n    localizedFormat.setDecimalFormatSymbols(otherSymbols);\n    return localizedFormat.format(number);\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n/**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n------------------------------\n------------------------------\n/**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n------------------------------\n------------------------------\n* unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n------------------------------\n------------------------------\n* unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n------------------------------\n------------------------------\n/**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver terminates, the {@code finalBestSolutionConsumer} is called once with the final best solution,\n     * on a consumer {@link Thread}, as soon as one is available.\n     * To listen to intermediate best solutions too, use {@link #solveAndListen(Object, Object, Consumer)} instead.\n     * <p>\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true, since = \"1.6.0\")    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n# Natural Language Annotations: /**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n     * unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n     *        {@link #getSolverStatus(Object) to get the status} or if the problem changes while solving.\n     * @param problemFinder never null, a function that returns a {@link PlanningSolution}, usually with uninitialized planning\n     *        variables\n     * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n     * @deprecated It is recommended to use {@link #solveBuilder()} while also providing a consumer for the best solution\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<ProblemId_, PlanningSolution<Solution_>> problemFinder,\n        Consumer<Solution_> bestSolutionConsumer) {\n    // Code to submit a planning problem to solve and return immediately\n    // Code to solve the problem on a solver thread, as soon as one is available\n    // Code to handle the new best solution found by the solver\n    // Code to handle any exceptions and log them as errors\n    // Code to provide a way to stop the solver job early\n\n    return null;\n}\n```\n", "```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<ProblemId_, PlanningSolution<Solution_>> problemFinder,\n        Consumer<Solution_> bestSolutionConsumer) {\n    // Your code here\n}\n```\n", "```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n    BiFunction<ProblemId_, Solution_, PlanningSolution> problemFinder,\n    Consumer<Solution_> bestSolutionConsumer) {\n    // Your code here\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\npublic SolverConfig withTerminationConfig(TerminationConfig terminationConfig) {\n        this.terminationConfig = terminationConfig;\n        return this;\n    }\n\n    /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\n------------------------------\n------------------------------\n/**\n     * As defined by {@link ScoreDirectorFactoryConfig#withConstraintProviderClass(Class)}, but returns this.\n     *\n     * @param constraintProviderClass sometimes null\n     * @return this, never null\n     */\n------------------------------\n------------------------------\npublic SolverConfig withClassLoader(ClassLoader classLoader) {\n        this.setClassLoader(classLoader);\n        return this;\n    }\n\n    /**\n     * As defined by {@link ScoreDirectorFactoryConfig#withEasyScoreCalculatorClass(Class)}, but returns this.\n     *\n     * @param easyScoreCalculatorClass sometimes null\n     * @return this, never null\n     */\n------------------------------\n------------------------------\n/**\n     * As defined by {@link #createFromFreemarkerXmlResource(String)}.\n     *\n     * @param templateResource never null, a classpath resource as defined by {@link ClassLoader#getResource(String)}\n     * @param model sometimes null\n     * @return never null\n     */\n    public static PlannerBenchmarkFactory createFromFreemarkerXmlResource(String templateResource, Object model) {\n------------------------------\n------------------------------\n/**\n     * As defined by {@link #createFromFreemarkerXmlFile(File)}.\n     *\n     * @param templateFile never null\n     * @param model sometimes null\n     * @return never null\n     */\n    public static PlannerBenchmarkConfig createFromFreemarkerXmlFile(File templateFile, Object model) {\n        return createFromFreemarkerXmlFile(templateFile, model, null);\n    }\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n# Natural Language Annotations: /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (this.terminationConfig != null) {\n        this.terminationConfig.withSpentLimit(spentLimit);\n    }\n    return this;\n}\n```\n", "```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (this.terminationConfig == null) {\n        this.terminationConfig = new TerminationConfig();\n    }\n    this.terminationConfig.withSpentLimit(spentLimit);\n    return this;\n}\n```\n", "```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (this.terminationConfig == null) {\n        this.terminationConfig = new TerminationConfig();\n    }\n    this.terminationConfig.withSpentLimit(spentLimit);\n    return this;\n}\n```\n"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n* <p>\n     * Null-handling:\n     * <ul>\n     * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n     * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n     * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n     * {@link #mergeProperty(Object, Object)}</li>\n     * </ul>\n     *\n     * @see #mergeProperty(Object, Object)\n     * @param a property {@code a}\n------------------------------\n------------------------------\n/**\n     * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n     * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n     * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n     * property of the benchmark that didn't fail.\n     * <p>\n     * Null-handling:\n     * <ul>\n------------------------------\n------------------------------\n* @param a property {@code a}\n     * @param b property {@code b}\n     * @param <T> the type of property {@code a} and {@code b}\n     * @return sometimes null\n     */\n------------------------------\n------------------------------\n/**\n     * Create a new instance of clazz from a general source.\n     * <p>\n     * If the instantiation fails, the result of {@code ownerDescriptor} will be used to describe the owner of\n     * {@code propertyName}.\n     *\n     * @param ownerDescriptor describes the owner of {@code propertyName}\n     * @param propertyName property holding the {@code clazz}\n     * @param clazz {@code Class} representation of the type {@code T}\n     * @param <T> the new instance type\n------------------------------\n------------------------------\n/**\n     * Inherits each property of the {@code inheritedConfig} unless that property (or a semantic alternative)\n     * is defined by this instance (which overwrites the inherited behaviour).\n     * <p>\n     * After the inheritance, if a property on this {@link AbstractConfig} composition is replaced,\n     * it should not affect the inherited composition instance.\n     *\n     * @param inheritedConfig never null\n     * @return this\n     */\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T meldProperty(T a, T b) {\n# Natural Language Annotations: /**\n     * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n     * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n     * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n     * property of the benchmark that didn't fail.\n     * <p>\n     * Null-handling:\n     * <ul>\n     * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n     * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n     * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n     * {@link #mergeProperty(Object, Object)}</li>\n     * </ul>\n     *\n     * @see #mergeProperty(Object, Object)\n     * @param a property {@code a}\n     * @param b property {@code b}\n     * @param <T> the type of property {@code a} and {@code b}\n     * @return sometimes null\n     */\nPlease only return the code surrounded by ```, do not reply any explaination\n", "response": ["```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```\n", "```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```\n", "```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a == null) {\n        return b;\n    } else if (b == null) {\n        return a;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```\n"]}}