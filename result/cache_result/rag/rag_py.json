{"litestar-litestar/file_system.py-info": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n             event: Log message.\n             *args: Any args.\n             **kwargs: Any kwargs.\n        \"\"\"\n\n    def error(self, event: str, *args: Any, **kwargs: Any) -> Any:\n        \"\"\"Output a log message at 'ERROR' level.\n\n        Args:\n             event: Log message.\n             *args: Any args.\n             **kwargs: Any kwargs.\n        \"\"\"\n\n    def fatal(self, event: str, *args: Any, **kwargs: Any) -> Any:\n        \"\"\"Output a log message at 'FATAL' level.\n\n        Args:\n             event: Log message.\n             *args: Any args.\n\n------------------------------\n------------------------------\n        \"\"\"\n\n    def warning(self, event: str, *args: Any, **kwargs: Any) -> Any:\n        \"\"\"Output a log message at 'WARNING' level.\n\n        Args:\n             event: Log message.\n             *args: Any args.\n             **kwargs: Any kwargs.\n        \"\"\"\n\n    def warn(self, event: str, *args: Any, **kwargs: Any) -> Any:\n        \"\"\"Output a log message at 'WARN' level.\n\n        Args:\n             event: Log message.\n             *args: Any args.\n             **kwargs: Any kwargs.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n        Returns:\n            Template instance\n\n        Raises:\n            TemplateNotFoundException: if no template is found.\n        \"\"\"\n        raise NotImplementedError\n\n    def render_string(self, template_string: str, context: Mapping[str, Any]) -> str:\n        \"\"\"Render a template from a string with the given context.\n\n        Args:\n            template_string: The template string to render.\n            context: A dictionary of variables to pass to the template.\n\n        Returns:\n            The rendered template as a string.\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n        \"\"\"Output a log message at 'DEBUG' level.\n\n        Args:\n             event: Log message.\n             *args: Any args.\n             **kwargs: Any kwargs.\n        \"\"\"\n\n    def info(self, event: str, *args: Any, **kwargs: Any) -> Any:\n        \"\"\"Output a log message at 'INFO' level.\n\n        Args:\n             event: Log message.\n             *args: Any args.\n             **kwargs: Any kwargs.\n        \"\"\"\n\n    def warning(self, event: str, *args: Any, **kwargs: Any) -> Any:\n        \"\"\"Output a log message at 'WARNING' level.\n\n\n------------------------------\n------------------------------\n\n    def info(self, path: PathType, **kwargs: Any) -> FileInfo | Awaitable[FileInfo]:\n        \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\n        ...\n\n    @overload\n    def open(\n        self,\n        file: PathType,\n        mode: OpenBinaryMode,\n        buffering: int = -1,\n    ) -> IO[bytes] | Awaitable[AsyncFile[bytes]]: ...\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n# Natural Language Annotations: \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    pass\n```\n", "```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    # Your code here\n```\n", "```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    # Placeholder code, replace with actual implementation\n    pass\n```\n"]}, "litestar-litestar/typing.py-has_inner_subclass_of": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\ndef is_class_and_subclass(annotation: Any, type_or_type_tuple: type[T] | tuple[type[T], ...]) -> TypeGuard[type[T]]:\n    \"\"\"Return ``True`` if ``value`` is a ``class`` and is a subtype of ``t_type``.\n\n    See https://github.com/litestar-org/litestar/issues/367\n\n    Args:\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n\n    Returns:\n        bool\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n\n    Returns:\n        bool\n    \"\"\"\n    origin = get_origin_or_inner_type(annotation)\n    if not origin and not isclass(annotation):\n        return False\n    try:\n        return issubclass(origin or annotation, type_or_type_tuple)\n    except TypeError:  # pragma: no cover\n        return False\n\n\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n------------------------------\n------------------------------\n        return self.origin or self.annotation\n\n    def is_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n        \"\"\"Whether the annotation is a subclass of the given type.\n\n        Where ``self.annotation`` is a union type, this method will return ``True`` when all members of the union are\n        a subtype of ``cl``, otherwise, ``False``.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether the annotation is a subtype of the given type(s).\n        \"\"\"\n        if self.origin:\n            if self.origin in UnionTypes:\n                return all(t.is_subclass_of(cl) for t in self.inner_types)\n\n            return self.origin not in UnionTypes and is_class_and_subclass(self.origin, cl)\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n# Natural Language Annotations: \"\"\"Whether any generic args are a subclass of the given type.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether any of the type's generic args are a subclass of the given type.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    if self.origin:\n        if self.origin in UnionTypes:\n            return any(t.is_subclass_of(cl) for t in self.inner_types)\n\n        return self.origin not in UnionTypes and is_class_and_subclass(self.origin, cl)\n```\n", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    if self.origin:\n        if self.origin in UnionTypes:\n            return any(t.is_subclass_of(cl) for t in self.inner_types)\n\n        return self.origin not in UnionTypes and is_class_and_subclass(self.origin, cl)\n```\n", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    if self.origin:\n        if self.origin in UnionTypes:\n            return any(t.is_subclass_of(cl) for t in self.inner_types)\n\n        return self.origin not in UnionTypes and is_class_and_subclass(self.origin, cl)\n```\n"]}, "litestar-litestar/typing.py-get_type_hints": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Args:\n            *filters: Types for specific filtering operations.\n            **kwargs: Identifier of the instance to be retrieved.\n\n        Returns:\n            True if the instance was found.  False if not found.\n\n        \"\"\"\n\n    @abstractmethod\n    def get(self, item_id: Any, **kwargs: Any) -> T:\n        \"\"\"Get instance identified by ``item_id``.\n\n        Args:\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: Additional arguments\n\n        Returns:\n            The retrieved instance.\n\n------------------------------\n------------------------------\n        \"\"\"Add ``data`` to the collection.\n\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_annotation(cls, annotation: Any, **kwargs: Any) -> FieldDefinition:\n        \"\"\"Initialize FieldDefinition.\n\n        Args:\n            annotation: The type annotation. This should be extracted from the return of\n                ``get_type_hints(..., include_extras=True)`` so that forward references are resolved and recursive\n                ``Annotated`` types are flattened.\n            **kwargs: Additional keyword arguments to pass to the ``FieldDefinition`` constructor.\n\n        Returns:\n\n------------------------------\n------------------------------\ndef get_type_hints_with_generics_resolved(\n    annotation: Any,\n    globalns: dict[str, Any] | None = None,\n    localns: dict[str, Any] | None = None,\n    include_extras: bool = False,\n    type_hints: dict[str, Any] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Get the type hints for the given object after resolving the generic types as much as possible.\n\n    Args:\n        annotation: A type annotation.\n        globalns: The global namespace.\n        localns: The local namespace.\n        include_extras: A flag indicating whether to include the ``Annotated[T, ...]`` or not.\n        type_hints: Already resolved type hints\n    \"\"\"\n    origin = get_origin(annotation)\n\n    if origin is None:\n        # Implies the generic types have not been specified in the annotation\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the type hints for the annotation.\n\n        Args:\n            include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n            resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n        Returns:\n            The type hints.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    origin = get_origin(annotation)\n\n    if origin is None:\n        # Implies the generic types have not been specified in the annotation\n```\n", "```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    # Implementation goes here\n```\n", "```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n```\nPlease note that the actual implementation of the function depends on the specifics of your class and the business logic it needs to follow.\n"]}, "litestar-litestar/typing.py-from_kwarg": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Given a value of indeterminate type, determine if this value is supported by the plugin.\n\n        Args:\n            field_definition: A parsed type.\n\n        Returns:\n            Whether the type is supported by the plugin.\n        \"\"\"\n        raise NotImplementedError()\n\n    def create_dto_for_type(self, field_definition: FieldDefinition) -> type[AbstractDTO]:\n        \"\"\"Given a parsed type, create a DTO class.\n\n        Args:\n            field_definition: A parsed type.\n\n        Returns:\n            A DTO class.\n        \"\"\"\n        raise NotImplementedError()\n\n------------------------------\n------------------------------\n\n    default: Any\n    field_alias: str\n    field_name: str\n    is_required: bool\n    is_sequence: bool\n    param_type: ParamType\n\n\ndef create_parameter_definition(\n    field_definition: FieldDefinition,\n    field_name: str,\n    path_parameters: set[str],\n) -> ParameterDefinition:\n    \"\"\"Create a ParameterDefinition for the given FieldDefinition.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        field_name: The field's name.\n        path_parameters: A set of path parameter names.\n\n------------------------------\n------------------------------\n    \"\"\"Default factory of the field.\"\"\"\n    dto_field: DTOField\n    \"\"\"DTO field configuration.\"\"\"\n\n    @classmethod\n    def from_field_definition(\n        cls,\n        field_definition: FieldDefinition,\n        model_name: str,\n        default_factory: Callable[[], Any] | None,\n        dto_field: DTOField,\n    ) -> DTOFieldDefinition:\n        \"\"\"Create a :class:`FieldDefinition` from a :class:`FieldDefinition`.\n\n        Args:\n            field_definition: A :class:`FieldDefinition` to create a :class:`FieldDefinition` from.\n            model_name: The name of the model.\n            default_factory: Default factory function, if any.\n            dto_field: DTOField instance.\n\n\n------------------------------\n------------------------------\n\n    Args:\n        field_definition: FieldDefinition instance.\n        field_name: The field's name.\n        path_parameters: A set of path parameter names.\n\n    Returns:\n        A ParameterDefinition tuple.\n    \"\"\"\n    default = field_definition.default if field_definition.has_default else None\n    kwarg_definition = (\n        field_definition.kwarg_definition if isinstance(field_definition.kwarg_definition, ParameterKwarg) else None\n    )\n\n    field_alias = kwarg_definition.query if kwarg_definition and kwarg_definition.query else field_name\n    param_type = ParamType.QUERY\n\n    if field_name in path_parameters:\n        field_alias = field_name\n        param_type = ParamType.PATH\n\n------------------------------\n------------------------------\n            field_definition: A :class:`FieldDefinition` to create a :class:`FieldDefinition` from.\n            model_name: The name of the model.\n            default_factory: Default factory function, if any.\n            dto_field: DTOField instance.\n\n        Returns:\n            A :class:`FieldDefinition` instance.\n        \"\"\"\n        return DTOFieldDefinition(\n            annotation=field_definition.annotation,\n            args=field_definition.args,\n            default=field_definition.default,\n            default_factory=default_factory,\n            dto_field=dto_field,\n            extra=field_definition.extra,\n            inner_types=field_definition.inner_types,\n            instantiable_origin=field_definition.instantiable_origin,\n            kwarg_definition=field_definition.kwarg_definition,\n            metadata=field_definition.metadata,\n            model_name=model_name,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_kwarg(\n# Natural Language Annotations: \"\"\"Create a new FieldDefinition instance.\n\n        Args:\n            annotation: The type of the kwarg.\n            name: Field name.\n            default: A default value.\n            inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n            kwarg_definition: Kwarg Parameter.\n            extra: A mapping of extra values.\n\n        Returns:\n            FieldDefinition instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any,\n    inner_types: tuple[FieldDefinition, ...],\n    kwarg_definition: ParameterKwarg,\n    extra: dict[str, Any],\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(\n        annotation=annotation,\n        has_default=True,\n        default=default,\n        inner_types=inner_types,\n        kwarg_definition=kwarg_definition,\n        extra=extra,\n    )\n```\n", "```python\ndef from_kwarg(\n    annotation: type, \n    name: str, \n    default: Any, \n    inner_types: tuple[FieldDefinition], \n    kwarg_definition: ParameterKwarg, \n    extra: dict\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(\n        annotation=annotation,\n        args=(),\n        default=default,\n        default_factory=None,\n        inner_types=inner_types,\n        instantiable_origin=None,\n        kwarg_definition=kwarg_definition,\n        metadata=extra,\n        model_name=name,\n    )\n```\n", "```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any = None,\n    inner_types: Optional[Tuple[Any, ...]] = None,\n    kwarg_definition: Optional[ParameterKwarg] = None,\n    extra: Optional[Dict[str, Any]] = None,\n) -> FieldDefinition:\n    \"\"\"\n    Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition(\n        annotation=annotation,\n        args=(),\n        default=default,\n        default_factory=None,\n        has_default=default is not None,\n        inner_types=inner_types or (),\n        instantiable_origin=annotation,\n        kwarg_definition=kwarg_definition,\n        extra=extra or {},\n    )\n```\n"]}, "litestar-litestar/typing.py-from_parameter": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Add ``data`` to the collection.\n\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n    ``None``. In this case, we can use the annotation to determine the correct instantiable type, if one exists.\n\n    Args:\n        origin_type: A type - would be the return value of :func:`get_origin()`.\n        annotation: Type annotation associated with the origin type. Should be unwrapped from any wrapper types, such\n            as ``Annotated``.\n\n    Returns:\n        A builtin type that is safe to instantiate for the given origin type.\n    \"\"\"\n    if origin_type is None:\n        return instantiable_type_mapping.get(annotation)\n    return instantiable_type_mapping.get(origin_type, origin_type)\n\n\ndef get_type_hints_with_generics_resolved(\n    annotation: Any,\n    globalns: dict[str, Any] | None = None,\n    localns: dict[str, Any] | None = None,\n    include_extras: bool = False,\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_annotation(cls, annotation: Any, **kwargs: Any) -> FieldDefinition:\n        \"\"\"Initialize FieldDefinition.\n\n        Args:\n            annotation: The type annotation. This should be extracted from the return of\n                ``get_type_hints(..., include_extras=True)`` so that forward references are resolved and recursive\n                ``Annotated`` types are flattened.\n            **kwargs: Additional keyword arguments to pass to the ``FieldDefinition`` constructor.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_signature(cls, signature: Signature, fn_type_hints: dict[str, type]) -> Self:\n        \"\"\"Parse an :class:`inspect.Signature` instance.\n\n        Args:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n# Natural Language Annotations: \"\"\"Initialize ParsedSignatureParameter.\n\n        Args:\n            parameter: inspect.Parameter\n            fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n                :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n        Returns:\n            ParsedSignatureParameter.\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n```\n", "```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n```\n", "```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n```\n"]}, "litestar-litestar/_openapi/responses.py-create_success_response": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    contact: Contact | None = None\n    \"\"\"The contact information for the exposed API.\"\"\"\n\n    license: License | None = None\n    \"\"\"The license information for the exposed API.\"\"\"\n\n------------------------------\n------------------------------\n) -> list[Parameter]:\n    \"\"\"Create a list of path/query/header Parameter models for the given PathHandler.\"\"\"\n    factory = ParameterFactory(\n        context=context,\n        route_handler=route_handler,\n        path_parameters=path_parameters,\n    )\n    return factory.create_parameters_for_handler()\n\n------------------------------\n------------------------------\n        \"\"\"Return a shallow copy\"\"\"\n        return type(self)(self.items())\n\n\nclass FormMultiDict(ImmutableMultiDict[Any]):\n    \"\"\"MultiDict for form data.\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n    def create_description(self) -> str:\n        \"\"\"Create the description for a success response.\"\"\"\n        default_descriptions: dict[Any, str] = {\n            Stream: \"Stream Response\",\n            Redirect: \"Redirect Response\",\n            File: \"File Download\",\n        }\n        return (\n            self.route_handler.response_description\n            or default_descriptions.get(self.field_definition.annotation)\n            or HTTPStatus(self.route_handler.status_code).description\n        )\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def create_redirect_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a redirect response.\"\"\"\n        return OpenAPIResponse(\n            content=None,\n            description=self.create_description(),\n            headers={\n                \"location\": OpenAPIHeader(\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_success_response(self) -> OpenAPIResponse:\n# Natural Language Annotations: \"\"\"Create the schema for a success response.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    content = self.create_success_content()\n    return OpenAPIResponse(\n        content=content,\n        description=self.create_description(),\n        headers=self.create_headers()\n    )\n```\n", "```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    return OpenAPIResponse(\n        content=None,\n        description=self.create_description(),\n        headers={\n            \"location\": OpenAPIHeader(\n                schema=OpenAPIType.STRING,\n                description=\"The redirect location URL.\"\n            )\n        },\n        status_code=self.route_handler.status_code\n    )\n```\n", "```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    if self.field_definition.annotation is Stream:\n        content = {\n            \"application/octet-stream\": {\"schema\": {\"type\": \"string\", \"format\": \"binary\"}}\n        }\n    elif self.field_definition.annotation is Redirect:\n        content = {\"text/html\": {\"schema\": {\"type\": \"string\"}}}\n    elif self.field_definition.annotation is File:\n        content = {\"application/octet-stream\": {\"schema\": {\"type\": \"string\", \"format\": \"binary\"}}}\n    else:\n        content = None\n\n    return OpenAPIResponse(\n        content=content,\n        description=self.create_description(),\n        headers={\n            \"location\": OpenAPIHeader(\n                description=\"The location for the redirect response.\",\n                schema={\"type\": \"string\"},\n            )\n        }\n    )\n```\n"]}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def create_redirect_response(self) -> OpenAPIResponse:\n        \"\"\"Create the schema for a redirect response.\"\"\"\n        return OpenAPIResponse(\n            content=None,\n            description=self.create_description(),\n            headers={\n                \"location\": OpenAPIHeader(\n\n------------------------------\n------------------------------\n        self.context = context\n        self.route_handler = route_handler\n        self.field_definition = route_handler.parsed_fn_signature.return_type\n        self.schema_creator = SchemaCreator.from_openapi_context(context, prefer_alias=False)\n\n    def create_responses(self, raises_validation_error: bool) -> Responses | None:\n        \"\"\"Create the schema for responses, if any.\n\n        Args:\n            raises_validation_error: Boolean flag indicating whether the handler raises a ValidationException.\n\n        Returns:\n            Responses\n        \"\"\"\n        responses: Responses = {\n            str(self.route_handler.status_code): self.create_success_response(),\n        }\n\n        exceptions = list(self.route_handler.raises or [])\n        if raises_validation_error and ValidationException not in exceptions:\n\n------------------------------\n------------------------------\n\n    def provide_openapi(self) -> OpenAPI:\n        if not self._openapi:\n            self._openapi = self._build_openapi()\n        return self._openapi\n\n    def provide_openapi_schema(self) -> dict[str, Any]:\n        if not self._openapi_schema:\n            self._openapi_schema = self.provide_openapi().to_schema()\n        return self._openapi_schema\n\n    def create_openapi_router(self) -> Router:\n        \"\"\"Create a router for serving OpenAPI documentation and schema files.\n\n        For each OpenAPI render plugin, a route is created to serve the plugin's\n        documentation site.\n\n        A handler is added for serving a 404 page for any schema path that is not\n        configured by a plugin.\n\n\n------------------------------\n------------------------------\n                description=group_description,\n                content={MediaType.JSON: OpenAPIMediaType(schema=schema)},\n            ),\n        )\n\n\ndef create_responses_for_handler(\n    context: OpenAPIContext, route_handler: HTTPRouteHandler, raises_validation_error: bool\n) -> Responses | None:\n    \"\"\"Create the schema for responses, if any.\n\n    Args:\n        context: An OpenAPIContext instance.\n        route_handler: An HTTPRouteHandler instance.\n        raises_validation_error: Boolean flag indicating whether the handler raises a ValidationException.\n\n    Returns:\n        Responses\n    \"\"\"\n    return ResponseFactory(context, route_handler).create_responses(raises_validation_error=raises_validation_error)\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\ndef create_error_responses(exceptions: list[type[HTTPException]]) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for error responses, if any.\"\"\"\n    grouped_exceptions: dict[int, list[type[HTTPException]]] = {}\n    for exc in exceptions:\n        if not grouped_exceptions.get(exc.status_code):\n            grouped_exceptions[exc.status_code] = []\n        grouped_exceptions[exc.status_code].append(exc)\n    for status_code, exception_group in grouped_exceptions.items():\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n# Natural Language Annotations: \"\"\"Create the schema for additional responses, if any.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses: dict[str, OpenAPIResponse] = {}\n    for status_code, exception_group in self.grouped_exceptions.items():\n        if status_code not in additional_responses:\n            additional_responses[status_code] = self.create_error_response(exception_group)\n    return additional_responses.items()\n```\n", "```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses: dict[str, OpenAPIResponse] = {}\n    for status_code, response in self.route_handler.additional_responses.items():\n        additional_responses[str(status_code)] = OpenAPIResponse(\n            description=self.create_description(),\n            content={MediaType.JSON: OpenAPIMediaType(schema=schema)},\n        )\n    return additional_responses.items()\n```\n", "```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses: Responses = {}\n    for status_code, response in self.additional_responses.items():\n        additional_responses[str(status_code)] = self.create_success_response(response)\n    return additional_responses.items()\n```\n"]}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    from litestar.dto import AbstractDTO\n    from litestar.typing import FieldDefinition\n\n\ndef create_request_body(\n    context: OpenAPIContext,\n    handler_id: str,\n    resolved_data_dto: type[AbstractDTO] | None,\n    data_field: FieldDefinition,\n) -> RequestBody:\n    \"\"\"Create a RequestBody instance for the given route handler's data field.\n\n    Args:\n        context: The OpenAPIContext instance.\n        handler_id: The handler id.\n        resolved_data_dto: The resolved data dto.\n        data_field: The data field.\n\n    Returns:\n        A RequestBody instance.\n\n------------------------------\n------------------------------\n        Returns:\n            Template instance\n\n        Raises:\n            TemplateNotFoundException: if no template is found.\n        \"\"\"\n        raise NotImplementedError\n\n    def render_string(self, template_string: str, context: Mapping[str, Any]) -> str:\n        \"\"\"Render a template from a string with the given context.\n\n        Args:\n            template_string: The template string to render.\n            context: A dictionary of variables to pass to the template.\n\n        Returns:\n            The rendered template as a string.\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n\n\ndef default_operation_id_creator(\n    route_handler: HTTPRouteHandler,\n    http_method: Method,\n    path_components: list[str | PathParameterDefinition],\n) -> str:\n    \"\"\"Create a unique 'operationId' for an OpenAPI PathItem entry.\n\n    Args:\n        route_handler: The HTTP Route Handler instance.\n        http_method: The HTTP method for the given PathItem.\n        path_components: A list of path components.\n\n    Returns:\n        A camelCased operationId created from the handler function name,\n        http method and path components.\n    \"\"\"\n\n    handler_namespace = (\n\n------------------------------\n------------------------------\n\n\n\n\n    def create_operation_for_handler_method(\n        self, route_handler: HTTPRouteHandler, http_method: HttpMethod\n    ) -> Operation:\n        \"\"\"Create an Operation instance for a given route handler and http method.\n\n        Args:\n            route_handler: A route handler instance.\n            http_method: An HttpMethod enum value.\n\n        Returns:\n            An Operation instance.\n        \"\"\"\n        operation_id = self.create_operation_id(route_handler, http_method)\n        parameters = create_parameters_for_handler(self.context, route_handler, self.route.path_parameters)\n        signature_fields = route_handler.parsed_fn_signature.parameters\n\n\n------------------------------\n------------------------------\n        handler_description = route_handler.description\n        if handler_description is None and self.context.openapi_config.use_handler_docstrings:\n            fn = unwrap_partial(route_handler.fn)\n            return cleandoc(fn.__doc__) if fn.__doc__ else None\n        return handler_description\n\n\ndef create_path_item_for_route(openapi_context: OpenAPIContext, route: HTTPRoute) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Args:\n        openapi_context: The OpenAPIContext instance.\n        route: The route to create a PathItem for.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item_factory = PathItemFactory(openapi_context, route)\n    return path_item_factory.create_path_item()\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_path_item(self) -> PathItem:\n# Natural Language Annotations: \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n        Returns:\n            A PathItem instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem(\n        path=self.route.path,\n        operations={\n            http_method: self.create_operation_for_handler_method(route_handler, http_method)\n            for http_method, route_handler in self.route.route_handlers.items()\n        },\n    )\n    return path_item\n```\n", "```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem(\n        summary=self.route.data.get(\"summary\"),\n        description=self.route.data.get(\"description\"),\n        servers=self.route.data.get(\"servers\"),\n        parameters=self.route.data.get(\"parameters\"),\n    )\n\n    for http_method, handler in self.route.route_handlers.items():\n        operation = self.create_operation_for_handler_method(handler, http_method)\n        setattr(path_item, http_method.lower(), operation)\n\n    return path_item\n```\n", "```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem(\n        description=self.route.description,\n        summary=self.route.summary,\n        servers=self.context.servers,\n    )\n    for http_method in self.context.http_methods:\n        operation = self.create_operation_for_handler_method(self.route.route_handler_map.get(http_method), http_method)\n        if operation is not None:\n            setattr(path_item, http_method.lower(), operation)\n    return path_item\n```\n"]}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Given a value of indeterminate type, determine if this value is supported by the plugin.\n\n        Args:\n            field_definition: A parsed type.\n\n        Returns:\n            Whether the type is supported by the plugin.\n        \"\"\"\n        raise NotImplementedError()\n\n    def create_dto_for_type(self, field_definition: FieldDefinition) -> type[AbstractDTO]:\n        \"\"\"Given a parsed type, create a DTO class.\n\n        Args:\n            field_definition: A parsed type.\n\n        Returns:\n            A DTO class.\n        \"\"\"\n        raise NotImplementedError()\n\n------------------------------\n------------------------------\n        return self.for_field_definition(\n            FieldDefinition.from_kwarg(\n                annotation=unwrap_new_type(field_definition.annotation),\n                name=field_definition.name,\n                default=field_definition.default,\n            )\n        )\n\n    @staticmethod\n    def for_upload_file(field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create schema for UploadFile.\n\n        Args:\n            field_definition: A field definition instance.\n\n        Returns:\n            A Schema instance.\n        \"\"\"\n\n        property_key = \"file\"\n\n------------------------------\n------------------------------\n\n    def for_union_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for a union FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        inner_types = (f for f in (field_definition.inner_types or []) if not self.is_undefined(f.annotation))\n        values = list(map(self.for_field_definition, inner_types))\n        return Schema(one_of=values)\n\n    def for_object_type(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create schema for object types (dict, Mapping, list, Sequence etc.) types.\n\n        Args:\n            field_definition: A signature field instance.\n\n\n------------------------------\n------------------------------\n\n    default: Any\n    field_alias: str\n    field_name: str\n    is_required: bool\n    is_sequence: bool\n    param_type: ParamType\n\n\ndef create_parameter_definition(\n    field_definition: FieldDefinition,\n    field_name: str,\n    path_parameters: set[str],\n) -> ParameterDefinition:\n    \"\"\"Create a ParameterDefinition for the given FieldDefinition.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        field_name: The field's name.\n        path_parameters: A set of path parameter names.\n\n------------------------------\n------------------------------\n        \"\"\"Create a schema for a TypeVar.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n\n        return Schema(type=OpenAPIType.OBJECT)\n\n    def for_optional_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for an optional FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        schema_or_reference = self.for_field_definition(\n            FieldDefinition.from_kwarg(\n                annotation=make_non_optional_union(field_definition.annotation),\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n# Natural Language Annotations: \"\"\"Create a Schema for a given FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n```\n", "```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if self.is_supported(field_definition):\n        return self.create_dto_for_type(field_definition)\n    else:\n        return self.create_reference_for_type(field_definition)\n```\n", "```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if self.is_supported(field_definition):\n        return self.create_dto_for_type(field_definition)\n    elif self.is_upload_file(field_definition):\n        return self.for_upload_file(field_definition)\n    elif self.is_union(field_definition):\n        return self.for_union_field(field_definition)\n    elif self.is_object_type(field_definition):\n        return self.for_object_type(field_definition)\n    elif self.is_typevar(field_definition):\n        return self.for_typevar(field_definition)\n    elif self.is_optional(field_definition):\n        return self.for_optional_field(field_definition)\n    else:\n        raise NotImplementedError()\n```\n"]}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def render(self, request: Request, openapi_schema: dict[str, Any]) -> bytes:\n        \"\"\"Render an OpenAPI schema as JSON.\n\n        Args:\n            request: The request.\n            openapi_schema: The OpenAPI schema as a dictionary.\n\n        Returns:\n            The rendered OpenAPI schema as JSON.\n        \"\"\"\n        return self.render_json(request, openapi_schema)\n\n\nclass YamlRenderPlugin(OpenAPIRenderPlugin):\n    \"\"\"Render an OpenAPI schema as YAML.\"\"\"\n\n    def __init__(\n        self,\n        *,\n\n------------------------------\n------------------------------\n    ) -> Schema:\n        \"\"\"Create a schema for the components/schemas section of the OpenAPI spec.\n\n        These are schemas that can be referenced by other schemas in the document, including self references.\n\n        To support self referencing schemas, the schema is added to the registry before schemas for its properties\n        are created. This allows the schema to be referenced by its properties.\n\n        Args:\n            type_: ``FieldDefinition`` instance of the type to create a schema for.\n            required: A list of required fields.\n            property_fields: Mapping of name to ``FieldDefinition`` instances for the properties of the schema.\n            openapi_type: The OpenAPI type, defaults to ``OpenAPIType.OBJECT``.\n            title: The schema title, generated if not provided.\n            examples: A mapping of example names to ``Example`` instances, not required.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        schema = self.schema_registry.get_schema_for_key(_get_normalized_schema_key(type_.annotation))\n\n------------------------------\n------------------------------\n        Returns:\n            Template instance\n\n        Raises:\n            TemplateNotFoundException: if no template is found.\n        \"\"\"\n        raise NotImplementedError\n\n    def render_string(self, template_string: str, context: Mapping[str, Any]) -> str:\n        \"\"\"Render a template from a string with the given context.\n\n        Args:\n            template_string: The template string to render.\n            context: A dictionary of variables to pass to the template.\n\n        Returns:\n            The rendered template as a string.\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n    def to_openapi_schema(self, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n        \"\"\"Given a type annotation, transform it into an OpenAPI schema class.\n\n        Args:\n            field_definition: An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n            schema_creator: An instance of the openapi SchemaCreator.\n\n        Returns:\n            An :class:`OpenAPI <litestar.openapi.spec.schema.Schema>` instance.\n        \"\"\"\n        raise NotImplementedError()\n\n\nclass OpenAPISchemaPlugin(OpenAPISchemaPluginProtocol):\n    \"\"\"Plugin to extend the support of OpenAPI schema generation for non-library types.\"\"\"\n\n    __slots__ = ()\n\n    @staticmethod\n    def is_plugin_supported_type(value: Any) -> bool:\n\n------------------------------\n------------------------------\n\n\ndef parse_type_schema(schema: Schema) -> TypeScriptPrimitive | TypeScriptLiteral | TypeScriptUnion:\n    \"\"\"Parse an OpenAPI schema representing a primitive type(s).\n\n    Args:\n        schema: An OpenAPI schema.\n\n    Returns:\n        A typescript type.\n    \"\"\"\n    if schema.enum:\n        return TypeScriptUnion(types=tuple(TypeScriptLiteral(value=value) for value in schema.enum))\n    if schema.const:\n        return TypeScriptLiteral(value=schema.const)\n    if isinstance(schema.type, list):\n        return TypeScriptUnion(\n            tuple(TypeScriptPrimitive(openapi_to_typescript_type_map[s_type]) for s_type in schema.type)\n        )\n    if schema.type in openapi_to_typescript_type_map and isinstance(schema.type, OpenAPIType):\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n# Natural Language Annotations: \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\n    # Implementation goes here\n    pass\n```\n", "```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\n```\n", "```python\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\n    # The implementation of this function would depend on the specifics of your OpenAPI and TypeScript libraries.\n    # For the sake of this example, I'll make some assumptions about your data structures.\n\n    # First, we'll create a TypeScriptNamespace with the provided namespace.\n    ts_namespace = TypeScriptNamespace(namespace)\n\n    # Next, we'll iterate over each schema in the OpenAPI instance.\n    for schema_name, schema in openapi_schema.schemas.items():\n        # For each schema, we'll parse the schema into a TypeScript type.\n        ts_type = parse_type_schema(schema)\n\n        # Then, we'll create a TypeScriptInterface with the schema_name and add the parsed type to it.\n        ts_interface = TypeScriptInterface(schema_name)\n        ts_interface.add_type(ts_type)\n\n        # Finally, we'll add the TypeScriptInterface to the TypeScriptNamespace.\n        ts_namespace.add_interface(ts_interface)\n\n    # After all schemas have been processed, we return the generated TypeScriptNamespace.\n    return ts_namespace\n```\n"]}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    value: TypeScriptElement\n\n    def write(self) -> str:\n        \"\"\"Write a typescript property. This class is used exclusively inside interfaces.\n\n        Example:\n            key: string;\n            optional?: number;\n\n        Returns:\n            A typescript string\n        \"\"\"\n        return f\"{self.key}{':' if self.required else '?:'} {self.value.write()};\"\n\n\n@dataclass(unsafe_hash=True)\nclass TypeScriptAnonymousInterface(TypeScriptElement):\n    \"\"\"A class representing a TypeScript anonymous interface.\"\"\"\n\n    properties: tuple[TypeScriptProperty, ...]\n\n------------------------------\n------------------------------\n\n\n\n\n\n@dataclass(unsafe_hash=True)\nclass TypeScriptUnion(TypeScriptElement):\n    \"\"\"A class representing a TypeScript union type.\"\"\"\n\n    types: tuple[TypeScriptElement, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript union value.\n\n        Example:\n            string | number\n\n        Returns:\n            A typescript string\n        \"\"\"\n\n------------------------------\n------------------------------\n        return f\"export const {self.name}: {self.value.write()};\"\n\n\n@dataclass(unsafe_hash=True)\nclass TypeScriptNamespace(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript namespace.\"\"\"\n\n    name: str\n    values: tuple[TypeScriptContainer, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript namespace.\n\n        Example:\n            export MyNamespace {\n                export const MyConst: number;\n            }\n\n        Returns:\n            A typescript string\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n@dataclass(unsafe_hash=True)\nclass TypeScriptInterface(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript interface.\"\"\"\n\n    name: str\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface.\n\n        Example:\n            export interface MyInterface {\n                key: string;\n\n------------------------------\n------------------------------\n        \"\"\"Write a typescript interface.\n\n        Example:\n            export interface MyInterface {\n                key: string;\n                optional?: number;\n            };\n\n        Returns:\n            A typescript string\n        \"\"\"\n        interface = TypeScriptAnonymousInterface(properties=self.properties)\n        return f\"export interface {self.name} {interface.write()};\"\n\n\n@dataclass(unsafe_hash=True)\nclass TypeScriptEnum(TypeScriptContainer):\n    \"\"\"A class representing a TypeScript enum.\"\"\"\n\n    name: str\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def write(self) -> str:\n# Natural Language Annotations: \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\n@dataclass(unsafe_hash=True)\nclass TypeScriptAnonymousInterface(TypeScriptElement):\n    \"\"\"A class representing a TypeScript anonymous interface.\"\"\"\n\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\n        properties_str = '\\n'.join(f'    {prop.write()};' for prop in self.properties)\n        return f'{{\\n{properties_str}\\n}}'\n```\n", "```python\ndef write(self) -> str:\n    \"\"\"Write a typescript interface object, without a name.\n\n    Example:\n        {\n            key: string;\n            optional?: number;\n        }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    properties_str = ',\\n'.join(f'{prop.key}{\": \" if prop.required else \"?: \"}{prop.value.write()};' for prop in self.properties)\n    return f'{{\\n{properties_str}\\n}}'\n```\n", "```python\n@dataclass(unsafe_hash=True)\nclass TypeScriptUnnamedInterface(TypeScriptElement):\n    \"\"\"A class representing a TypeScript unnamed (or anonymous) interface.\"\"\"\n\n    properties: tuple[TypeScriptProperty, ...]\n\n    def write(self) -> str:\n        \"\"\"Write a typescript unnamed interface.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\n        properties = \"\\n\".join(f\"    {prop.write()};\" for prop in self.properties)\n        return f\"{{\\n{properties}\\n}}\"\n```\n"]}, "litestar-litestar/testing/helpers.py-create_test_client": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            after_response: A sync or async function called after the response has been awaited. It receives the\n                :class:`Request <.connection.Request>` object and should not return any values.\n            before_request: A sync or async function called immediately before calling the route handler. Receives\n                the :class:`litestar.connection.Request` instance and any non-``None`` return value is used for the\n                response, bypassing the route handler.\n            cache_control: A ``cache-control`` header of type\n                :class:`CacheControlHeader <.datastructures.CacheControlHeader>` to add to route handlers of\n                this router. Can be overridden by route handlers.\n            dependencies: A string keyed mapping of dependency :class:`Provide <.di.Provide>` instances.\n            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n                validation of request data.\n            etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            exception_handlers: A mapping of status codes and/or exception types to handler functions.\n            guards: A sequence of :data:`Guard <.types.Guard>` callables.\n            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n            middleware: A sequence of :data:`Middleware <.types.Middleware>`.\n            opt: A string keyed mapping of arbitrary values that can be accessed in :data:`Guards <.types.Guard>` or\n                wherever you have access to :class:`Request <.connection.Request>` or\n                :data:`ASGI Scope <.types.Scope>`.\n            parameters: A mapping of :func:`Parameter <.params.Parameter>` definitions available to all application\n\n------------------------------\n------------------------------\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n\n------------------------------\n------------------------------\n            event_emitter_backend: A subclass of\n                :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n            exception_handlers: A mapping of status codes and/or exception types to handler functions.\n            guards: A sequence of :class:`Guard <.types.Guard>` callables.\n            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n            lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n            listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n            logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n            middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n            multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n                is intended to protect from DoS attacks.\n            on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n                an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n                the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n                If more than one handler is registered they are called in the order they are provided.\n            on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n                shutdown.\n            on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n                application startup.\n            openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n\n------------------------------\n------------------------------\n            before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n                when the ASGI send function is called.\n            cache_control: A ``cache-control`` header of type\n                :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n                this app. Can be overridden by route handlers.\n            compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n                defined Compression middleware.\n            cors_config: If set, configures CORS handling for the application.\n            csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n            debug: If ``True``, app errors rendered as HTML with a stack trace.\n            dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n            dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n                validation of request data.\n            etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n                Can be overridden by route handlers.\n            event_emitter_backend: A subclass of\n                :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n            exception_handlers: A mapping of status codes and/or exception types to handler functions.\n            guards: A sequence of :class:`Guard <.types.Guard>` callables.\n            include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n\n------------------------------\n------------------------------\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_test_client(\n# Natural Language Annotations: \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        route_handlers: A sequence of route handlers, which can include instances of\n            :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom litestar import Litestar\nfrom litestar.testing import TestClient\n\ndef create_test_client(route_handlers, **kwargs):\n    app = Litestar(route_handlers=route_handlers, **kwargs)\n    return TestClient(app)\n```\n", "```python\ndef create_test_client(\n    route_handlers: Any,\n    backend: str = \"asyncio\",\n    backend_options: Optional[Dict[str, Any]] = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: Optional[SessionConfig] = None,\n    after_exception: Optional[Sequence[AfterExceptionHookHandler]] = None,\n    after_request: Optional[Union[AsyncAfterRequestHookHandler, SyncAfterRequestHookHandler]] = None,\n    after_response: Optional[Union[AsyncAfterResponseHookHandler, SyncAfterResponseHookHandler]] = None,\n    allowed_hosts: Optional[Union[AllowedHostsConfig, Sequence[str]]] = None,\n    before_request: Optional[Union[AsyncBeforeRequestHookHandler, SyncBeforeRequestHookHandler]] = None,\n    before_send: Optional[Sequence[BeforeMessageSendHookHandler]] = None,\n    cache_control: Optional[Union[str, CacheControlHeader]] = None,\n    compression_config: Optional[Union[CompressionConfig, Dict[str, Any]]] = None,\n    cors_config: Optional[CORSConfig] = None,\n    csrf_config: Optional[CSRFConfig] = None,\n    debug: bool = False,\n    dependencies: Optional[Dependencies] = None,\n    dto: Optional[AbstractDTO] = None,\n    etag: Optional[Union[str, ETag]] = None,\n    event_emitter_backend: Optional[Type[BaseEventEmitterBackend]] = None,\n    exception_handlers: Optional[ExceptionHandlers] = None,\n    guards: Optional[Sequence[Guard]] = None,\n    include_in_schema: bool = True,\n    lifespan: Optional[Sequence[AsyncLifespanContextManager]] = None,\n    listeners: Optional[Sequence[EventListener]] = None,\n    logging_config: Optional[Union[BaseLoggingConfig, Dict[str, Any]]] = None,\n    middleware: Optional[Sequence[Middleware]] = None,\n    multipart_form_part_limit: int = 1000,\n    on_app_init: Optional[Sequence[OnAppInitHandler]] = None,\n    on_shutdown: Optional[Sequence[LifespanHook]] = None,\n    on_startup: Optional[Sequence[LifespanHook]] = None,\n    openapi_config: Optional[OpenAPIConfig] = None,\n    opt: Optional[Dict[str, Any]] = None,\n    parameters: Optional[Dict[str, ParameterDefinition]] = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Optional[Sequence[PluginProtocol]] = None,\n    request_class: Optional[Type[Request]] = None,\n    response_class: Optional[Type[Response]] = None,\n    response_cookies: Optional[Sequence[Cookie]] = None,\n    response_headers: Optional[Dict[str, str]] = None,\n    response_cache_config: Optional[ResponseCacheConfig] = None,\n    return_dto: Optional[AbstractDTO] = None,\n    route_handlers: Optional[Sequence[RouteHandlerType]] = None,\n    security: Optional[Sequence[Dict[str, Any]]] = None,\n    signature_namespace: Optional[Dict[str, Any]] = None,\n    signature_types: Optional[Sequence[Any]] = None,\n    state: Optional[State] = None,\n    static_files_config: Optional[Sequence[StaticFilesConfig]] = None,\n    stores: Optional[Union[StoreRegistry, Dict[str, Store]]] = None,\n    tags: Optional[Sequence[str]] = None,\n    template_config: Optional[TemplateConfig] = None,\n    timeout: Optional[float] = None,\n    type_encoders: Optional[Dict[Type[Any], Callable[[Any], Any]]] = None,\n    websocket_class: Optional[Type[WebSocket]] = None,\n    experimental_features: Optional[Set[str]] = None,\n) -> TestClient:\n    pass\n```\n", "```python\ndef create_test_client(\n    route_handlers: Any,\n    backend: Optional[str] = None,\n    backend_options: Optional[Dict[str, Any]] = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: Optional[SessionConfig] = None,\n    after_exception: Optional[List[AfterExceptionHookHandler]] = None,\n    after_request: Optional[AfterRequestHookHandler] = None,\n    after_response: Optional[AfterResponseHookHandler] = None,\n    allowed_hosts: Optional[Union[Sequence[str], AllowedHostsConfig]] = None,\n    before_request: Optional[BeforeRequestHookHandler] = None,\n    before_send: Optional[List[BeforeMessageSendHookHandler]] = None,\n    cache_control: Optional[Union[CacheControlHeader, str]] = None,\n    compression_config: Optional[CompressionConfig] = None,\n    cors_config: Optional[CORSConfig] = None,\n    csrf_config: Optional[CSRFConfig] = None,\n    debug: bool = False,\n    dependencies: Optional[Dict[str, Provide]] = None,\n    dto: Optional[Type[AbstractDTO]] = None,\n    etag: Optional[Union[ETag, str]] = None,\n    event_emitter_backend: Optional[Type[BaseEventEmitterBackend]] = None,\n    exception_handlers: Optional[Dict[Union[int, Type[Exception]], ExceptionHandler]] = None,\n    guards: Optional[Sequence[Guard]] = None,\n    include_in_schema: bool = True,\n    lifespan: Optional[List[Callable[[], AsyncContextManager[None]]]] = None,\n    listeners: Optional[List[EventListener]] = None,\n    logging_config: Optional[Type[BaseLoggingConfig]] = None,\n    middleware: Optional[Sequence[Middleware]] = None,\n    multipart_form_part_limit: int = 50,\n    on_app_init: Optional[List[OnAppInitHandler]] = None,\n    on_shutdown: Optional[List[LifespanHook]] = None,\n    on_startup: Optional[List[LifespanHook]] = None,\n    openapi_config: Optional[OpenAPIConfig] = None,\n    opt: Optional[Dict[str, Any]] = None,\n    parameters: Optional[Dict[str, Parameter]] = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Optional[Sequence[PluginProtocol]] = None,\n    request_class: Optional[Type[Request]] = None,\n    response_class: Optional[Type[Response]] = None,\n    response_cookies: Optional[Sequence[Cookie]] = None,\n    response_headers: Optional[Dict[str, ResponseHeader]] = None,\n    response_cache_config: Optional[CacheConfig] = None,\n    return_dto: Optional[Type[AbstractDTO]] = None,\n    security: Optional[Sequence[SecurityRequirement]] = None,\n    signature_namespace: Optional[Dict[str, Type[Any]]] = None,\n    signature_types: Optional[Sequence[Type[Any]]] = None,\n    state: Optional[State] = None,\n    static_files_config: Optional[Sequence[StaticFilesConfig]] = None,\n    stores: Optional[Union[Dict[str, Store], StoreRegistry]] = None,\n    tags: Optional[Sequence[str]] = None,\n    template_config: Optional[TemplateConfig] = None,\n    timeout: float = float(\"inf\"),\n    type_encoders: Optional[Dict[Type[Any], Callable[[Any], Any]]] = None,\n    websocket_class: Optional[Type[WebSocket]] = None,\n    experimental_features: Optional[Iterable[ExperimentalFeature]] = None,\n) -> TestClient:\n    pass\n```\n"]}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                    subprotocols=subprotocols,\n                    params=params,\n                    headers=headers,\n                    cookies=cookies,\n                    extensions=extensions,\n                    timeout=timeout,\n                ),\n                auth=auth,\n                follow_redirects=follow_redirects,\n            )\n        except ConnectionUpgradeExceptionError as exc:\n            return exc.session\n\n        raise RuntimeError(\"Expected WebSocket upgrade\")  # pragma: no cover\n\n    async def get_session_data(self) -> dict[str, Any]:\n        \"\"\"Get session data.\n\n        Returns:\n            A dictionary containing session data.\n\n------------------------------\n------------------------------\n\n        Returns:\n            A dictionary with the connection's path parameters.\n        \"\"\"\n        return connection.path_params\n\n    @staticmethod\n    def extract_method(request: Request[Any, Any, Any]) -> Method:\n        \"\"\"Extract the method from an ``ASGIConnection``\n\n        Args:\n            request: A :class:`Request <litestar.connection.Request>` instance.\n\n        Returns:\n            The request's scope[\"method\"] value.\n        \"\"\"\n        return request.scope[\"method\"]\n\n    @staticmethod\n    def extract_content_type(request: Request[Any, Any, Any]) -> tuple[str, dict[str, str]]:\n\n------------------------------\n------------------------------\n        return _obfuscate(headers, self.obfuscate_headers) if self.obfuscate_headers else headers\n\n    def extract_cookies(self, connection: ASGIConnection[Any, Any, Any, Any]) -> dict[str, str]:\n        \"\"\"Extract cookies from an ``ASGIConnection``\n\n        Args:\n            connection: An :class:`ASGIConnection <litestar.connection.ASGIConnection>` instance.\n\n        Returns:\n            A dictionary with the connection's cookies.\n        \"\"\"\n        return _obfuscate(connection.cookies, self.obfuscate_cookies) if self.obfuscate_cookies else connection.cookies\n\n    def extract_query(self, connection: ASGIConnection[Any, Any, Any, Any]) -> Any:\n        \"\"\"Extract query from an ``ASGIConnection``\n\n        Args:\n            connection: An :class:`ASGIConnection <litestar.connection.ASGIConnection>` instance.\n\n        Returns:\n\n------------------------------\n------------------------------\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: Mapping[str, Any] | None = None,\n    ) -> WebSocketTestSession:\n        \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n\n------------------------------\n------------------------------\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\n        try:\n            await self.send(\n                self._prepare_ws_connect_request(\n                    url=url,\n                    subprotocols=subprotocols,\n                    params=params,\n                    headers=headers,\n                    cookies=cookies,\n                    extensions=extensions,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def websocket_connect(\n# Natural Language Annotations: \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef websocket_connect(\n    url: str,\n    subprotocols: Sequence[str] | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n    follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n    timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n    extensions: Mapping[str, Any] | None = None,\n) -> WebSocketTestSession:\n    \"\"\"Sends a GET request to establish a websocket connection.\n\n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n\n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    try:\n        await self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                auth=auth,\n                follow_redirects=follow_redirects,\n                timeout=timeout,\n            ),\n            auth=auth,\n            follow_redirects=follow_redirects,\n        )\n    except ConnectionUpgradeExceptionError as exc:\n        return exc.session\n\n    raise RuntimeError(\"Expected WebSocket upgrade\")  # pragma: no cover\n```\n", "```python\nasync def websocket_connect(\n        url: str,\n        subprotocols: Sequence[str] | None = None,\n        params: QueryParamTypes | None = None,\n        headers: HeaderTypes | None = None,\n        cookies: CookieTypes | None = None,\n        auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n        timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n        extensions: Mapping[str, Any] | None = None,\n) -> WebSocketTestSession:\n    \"\"\"Sends a GET request to establish a websocket connection.\n\n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n\n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    try:\n        return await self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            ),\n            auth=auth,\n            follow_redirects=follow_redirects,\n        )\n    except ConnectionUpgradeExceptionError as exc:\n        return exc.session\n\n    raise RuntimeError(\"Expected WebSocket upgrade\")  # pragma: no cover\n```\n", "```python\ndef websocket_connect(\n    url: str,\n    subprotocols: Sequence[str] | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n    follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n    timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n    extensions: Mapping[str, Any] | None = None,\n) -> WebSocketTestSession:\n    \"\"\"Sends a GET request to establish a websocket connection.\n\n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n\n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    try:\n        return self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                auth=auth,\n                follow_redirects=follow_redirects,\n                timeout=timeout,\n            )\n        )\n    except ConnectionUpgradeExceptionError as exc:\n        return exc.session\n\n    raise RuntimeError(\"Expected WebSocket upgrade\")  # pragma: no cover\n```\n"]}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def for_union_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for a union FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        inner_types = (f for f in (field_definition.inner_types or []) if not self.is_undefined(f.annotation))\n        values = list(map(self.for_field_definition, inner_types))\n        return Schema(one_of=values)\n\n    def for_object_type(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create schema for object types (dict, Mapping, list, Sequence etc.) types.\n\n        Args:\n            field_definition: A signature field instance.\n\n\n------------------------------\n------------------------------\n    \"\"\"Default factory of the field.\"\"\"\n    dto_field: DTOField\n    \"\"\"DTO field configuration.\"\"\"\n\n    @classmethod\n    def from_field_definition(\n        cls,\n        field_definition: FieldDefinition,\n        model_name: str,\n        default_factory: Callable[[], Any] | None,\n        dto_field: DTOField,\n    ) -> DTOFieldDefinition:\n        \"\"\"Create a :class:`FieldDefinition` from a :class:`FieldDefinition`.\n\n        Args:\n            field_definition: A :class:`FieldDefinition` to create a :class:`FieldDefinition` from.\n            model_name: The name of the model.\n            default_factory: Default factory function, if any.\n            dto_field: DTOField instance.\n\n\n------------------------------\n------------------------------\n        \"\"\"Create a schema for a TypeVar.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n\n        return Schema(type=OpenAPIType.OBJECT)\n\n    def for_optional_field(self, field_definition: FieldDefinition) -> Schema:\n        \"\"\"Create a Schema for an optional FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\n        schema_or_reference = self.for_field_definition(\n            FieldDefinition.from_kwarg(\n                annotation=make_non_optional_union(field_definition.annotation),\n\n------------------------------\n------------------------------\n        \"\"\"Given a value of indeterminate type, determine if this value is supported by the plugin.\n\n        Args:\n            field_definition: A parsed type.\n\n        Returns:\n            Whether the type is supported by the plugin.\n        \"\"\"\n        raise NotImplementedError()\n\n    def create_dto_for_type(self, field_definition: FieldDefinition) -> type[AbstractDTO]:\n        \"\"\"Given a parsed type, create a DTO class.\n\n        Args:\n            field_definition: A parsed type.\n\n        Returns:\n            A DTO class.\n        \"\"\"\n        raise NotImplementedError()\n\n------------------------------\n------------------------------\n\n    default: Any\n    field_alias: str\n    field_name: str\n    is_required: bool\n    is_sequence: bool\n    param_type: ParamType\n\n\ndef create_parameter_definition(\n    field_definition: FieldDefinition,\n    field_name: str,\n    path_parameters: set[str],\n) -> ParameterDefinition:\n    \"\"\"Create a ParameterDefinition for the given FieldDefinition.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        field_name: The field's name.\n        path_parameters: A set of path parameter names.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n# Natural Language Annotations: \"\"\"Create a schema object for a given pydantic model class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    \"\"\"Create a schema object for a given pydantic model class.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n```\n", "```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    \"\"\"Create a schema object for a given pydantic model class.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    # Your code here\n```\n", "```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    \"\"\"Create a schema object for a given pydantic model class.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    properties = {}\n    required = []\n\n    for field in cls.__fields__.values():\n        if isinstance(field.type_, type) and issubclass(field.type_, BaseModel):\n            schema = schema_creator.for_pydantic_model(field.type_, field_definition)\n        else:\n            schema = schema_creator.for_field_definition(field.type_)\n\n        properties[field.alias] = schema\n\n        if field.required:\n            required.append(field.alias)\n\n    return Schema(type=OpenAPIType.OBJECT, properties=properties, required=required)\n```\n"]}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            channels = [channels]\n        data = self.encode_data(data)\n\n        await self._backend.publish(data, channels)\n\n    async def subscribe(self, channels: str | Iterable[str], history: int | None = None) -> Subscriber:\n        \"\"\"Create a :class:`Subscriber`, providing a stream of all events in ``channels``.\n\n        The created subscriber will be passive by default and has to be consumed manually,\n        either by using :meth:`Subscriber.run_in_background` or iterating over events\n        using :meth:`Subscriber.iter_events`.\n\n        Args:\n            channels: Channel(s) to subscribe to\n            history: If a non-negative integer, add this amount of history entries from\n                each channel to the subscriber's event stream. Note that this will wait\n                until all history entries are fetched and pushed to the subscriber's\n                stream. For more control use :meth:`put_subscriber_history`.\n\n        Returns:\n\n------------------------------\n------------------------------\n    Background tasks are called once a Response finishes.\n    \"\"\"\n\n    __slots__ = (\"tasks\", \"run_in_task_group\")\n\n    def __init__(self, tasks: Iterable[BackgroundTask], run_in_task_group: bool = False) -> None:\n        \"\"\"Initialize ``BackgroundTasks``.\n\n        Args:\n            tasks: An iterable of :class:`BackgroundTask <.background_tasks.BackgroundTask>` instances.\n            run_in_task_group: If you set this value to ``True`` than the tasks will run concurrently, using\n                a :class:`TaskGroup <anyio.abc.TaskGroup>`. Note: This will not preserve execution order.\n        \"\"\"\n        self.tasks = tasks\n        self.run_in_task_group = run_in_task_group\n\n    async def __call__(self) -> None:\n        \"\"\"Call the wrapped background tasks.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n        Args:\n            generators: An optional list of generators to be called at cleanup\n        \"\"\"\n        self._generators = generators or []\n        self._closed = False\n\n    def add(self, generator: Generator[Any, None, None] | AsyncGenerator[Any, None]) -> None:\n        \"\"\"Add a new generator to the group.\n\n        Args:\n            generator: The generator to add\n\n        Returns:\n            None\n        \"\"\"\n        if self._closed:\n            raise RuntimeError(\"Cannot call cleanup on a closed DependencyCleanupGroup\")\n        self._generators.append(generator)\n\n\n------------------------------\n------------------------------\n        If no such key exists, this is a no-op.\n\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        async with self._lock:\n            self._store.pop(key, None)\n\n    async def delete_all(self) -> None:\n        \"\"\"Delete all stored values.\"\"\"\n        async with self._lock:\n            self._store.clear()\n\n    async def delete_expired(self) -> None:\n        \"\"\"Delete expired items.\n\n        Since expired items are normally only cleared on access (i.e. when calling\n        :meth:`.get`), this method should be called in regular intervals\n        to free memory.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\nclass DependencyCleanupGroup:\n    \"\"\"Wrapper for generator based dependencies.\n\n    Simplify cleanup by wrapping :func:`next` / :func:`anext` calls and providing facilities to\n    :meth:`throw <generator.throw>` / :meth:`athrow <agen.athrow>` into all generators consecutively. An instance of\n    this class can be used as a contextmanager, which will automatically throw any exceptions into its generators. All\n    exceptions caught in this manner will be re-raised after they have been thrown in the generators.\n    \"\"\"\n\n    __slots__ = (\"_generators\", \"_closed\")\n\n    def __init__(self, generators: list[AnyGenerator] | None = None) -> None:\n        \"\"\"Initialize ``DependencyCleanupGroup``.\n\n        Args:\n            generators: An optional list of generators to be called at cleanup\n        \"\"\"\n        self._generators = generators or []\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def cleanup(self) -> None:\n# Natural Language Annotations: \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n        If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    async with anyio.move_on_after(10.0):\n        async with anyio.create_task_group() as tg:\n            for generator in self._generators:\n                tg.start_soon(self._cleanup_generator, generator)\n```\n", "```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    if len(self._generators) > 1:\n        async with create_task_group() as tg:\n            for generator in self._generators:\n                tg.start_soon(generator.__anext__)\n    elif len(self._generators) == 1:\n        try:\n            await self._generators[0].__anext__()\n        except StopAsyncIteration:\n            pass\n```\n", "```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    async with anyio.TaskGroup() as task_group:\n        for generator in self._generators:\n            await task_group.spawn(cleanup_generator, generator)\n\nasync def cleanup_generator(generator):\n    try:\n        while True:\n            next(generator)\n    except StopIteration:\n        pass\n```\n"]}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    @abstractmethod\n    async def handle(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"ASGI App of the route.\n\n        Args:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        raise NotImplementedError(\"Route subclasses must implement handle which serves as the ASGI app entry point\")\n\n    @staticmethod\n    def _validate_path_parameter(param: str, path: str) -> None:\n        \"\"\"Validate that a path parameter adheres to the required format and datatypes.\n\n        Raises:\n\n------------------------------\n------------------------------\n\n    configure_node(route=route, app=app, node=current_node)\n    return current_node\n\n\ndef configure_node(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    node: RouteTrieNode,\n) -> None:\n    \"\"\"Set required attributes and route handlers on route_map tree node.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        node: The trie node being configured.\n\n    Returns:\n        None\n    \"\"\"\n\n------------------------------\n------------------------------\n        self,\n        scope: Scope,\n        request: Request[Any, Any, Any],\n        route_handler: HTTPRouteHandler,\n        parameter_model: KwargsModel,\n    ) -> ASGIApp:\n        \"\"\"Return a response for the request.\n\n        If caching is enabled and a response exist in the cache, the cached response will be returned.\n        If caching is enabled and a response does not exist in the cache, the newly created\n        response will be cached.\n\n        Args:\n            scope: The Request's scope\n            request: The Request instance\n            route_handler: The HTTPRouteHandler instance\n            parameter_model: The Handler's KwargsModel\n\n        Returns:\n            An instance of Response or a compatible ASGIApp or a subclass of it\n\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, cast\n\nif TYPE_CHECKING:\n    from litestar.routes import ASGIRoute, HTTPRoute, WebSocketRoute\n    from litestar.routes.base import BaseRoute\n    from litestar.types import ASGIApp, RouteHandlerType\n\n__all__ = (\"get_route_handlers\", \"wrap_in_exception_handler\")\n\n\ndef wrap_in_exception_handler(app: ASGIApp) -> ASGIApp:\n    \"\"\"Wrap the given ASGIApp in an instance of ExceptionHandlerMiddleware.\n\n    Args:\n        app: The ASGI app that is being wrapped.\n\n    Returns:\n        A wrapped ASGIApp.\n\n------------------------------\n------------------------------\n    Args:\n        app: The ASGI app that is being wrapped.\n\n    Returns:\n        A wrapped ASGIApp.\n    \"\"\"\n    from litestar.middleware._internal.exceptions import ExceptionHandlerMiddleware\n\n    return ExceptionHandlerMiddleware(app=app, debug=None)\n\n\ndef get_route_handlers(route: BaseRoute) -> list[RouteHandlerType]:\n    \"\"\"Retrieve handler(s) as a list for given route.\n\n    Args:\n        route: The route from which the route handlers are extracted.\n\n    Returns:\n        The route handlers defined on the route.\n    \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_route_middleware_stack(\n# Natural Language Annotations: \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef build_route_middleware_stack(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    route_handler: HTTPRouteHandler,\n) -> ASGIApp:\n    \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\n    from litestar.middleware._internal.exceptions import ExceptionHandlerMiddleware\n\n    asgi_app = route_handler.get_asgi_app(app, route)\n    exception_middleware = ExceptionHandlerMiddleware(app=asgi_app, debug=None)\n\n    return exception_middleware\n```\n", "```python\nfrom typing import Any, Callable, Sequence\nfrom litestar import Litestar\nfrom litestar.middleware import MiddlewareProtocol\n\ndef build_route_middleware_stack(\n    app: Litestar, \n    route: Any,\n    route_handler: Callable\n) -> Sequence[MiddlewareProtocol]:\n    \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\n\n    middleware_stack = []\n    for middleware in app.middleware:\n        if middleware.exclude is None or not any(route.path.startswith(path) for path in middleware.exclude):\n            middleware_stack.append(middleware.cls(route_handler=route_handler))\n    return middleware_stack\n```\n", "```python\nfrom typing import Any\nfrom litestar.routes import ASGIRoute, HTTPRoute, WebSocketRoute, BaseRoute\nfrom litestar.types import ASGIApp, RouteHandlerType\nfrom litestar.middleware._internal.exceptions import ExceptionHandlerMiddleware\n\ndef build_route_middleware_stack(\n    app: Litestar,\n    route: HTTPRoute | WebSocketRoute | ASGIRoute,\n    route_handler: RouteHandlerType,\n) -> ASGIApp:\n    \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\n    # In this function, we are going to wrap the route handler with the middlewares\n    # provided by the Litestar app instance. The middlewares will be applied in\n    # the order they are defined in the app instance.\n\n    # First, we need to retrieve the middlewares from the app instance\n    middleware = app.middleware\n\n    # Then, we need to reverse the order of the middlewares, as they are applied\n    # in the order they are defined in the app instance.\n    middleware = middleware[::-1]\n\n    # Now, we can start wrapping the route handler with the middlewares.\n    for middleware_cls in middleware:\n        route_handler = middleware_cls(route_handler)\n\n    # Finally, we wrap the route handler with the ExceptionHandlerMiddleware\n    # to catch any exceptions that may occur during the handling of the request.\n    route_handler = ExceptionHandlerMiddleware(route_handler)\n\n    # Return the ASGIApp that is composed of a \"stack\" of middlewares.\n    return route_handler\n```\n"]}, "litestar-litestar/utils/signature.py-from_fn": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def write(self, body: bytes) -> None:\n        \"\"\"Write compressed bytes.\n\n        Args:\n            body: Message body to process\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n    def close(self) -> None:\n        \"\"\"Close the compression stream.\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n\n\ndef _validate_signature_dependencies(\n    dependency_name_set: set[str], fn_name: str, parsed_signature: ParsedSignature\n) -> set[str]:\n    \"\"\"Validate dependencies of ``parsed_signature``.\n\n    Args:\n        dependency_name_set: A set of dependency names\n        fn_name: A callable's name.\n        parsed_signature: A parsed signature.\n\n    Returns:\n        A set of validated dependency names.\n    \"\"\"\n    dependency_names: set[str] = set(dependency_name_set)\n\n    for parameter in parsed_signature.parameters.values():\n        if isinstance(parameter.kwarg_definition, DependencyKwarg) and parameter.name not in dependency_name_set:\n            if not parameter.is_optional and parameter.default is Empty:\n\n------------------------------\n------------------------------\n\n    Args:\n        fn: Callable that is being inspected\n        namespace: Extra names for resolution of forward references.\n\n    Returns:\n        Mapping of names to types.\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n\n    # detect objects that are not functions and that have a `__call__` method\n    if callable(fn_to_inspect) and ismethod(fn_to_inspect.__call__):\n        fn_to_inspect = fn_to_inspect.__call__\n\n    # inspect the underlying function for methods\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_signature(cls, signature: Signature, fn_type_hints: dict[str, type]) -> Self:\n        \"\"\"Parse an :class:`inspect.Signature` instance.\n\n        Args:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n# Natural Language Annotations: \"\"\"Parse a function signature.\n\n        Args:\n            fn: Any callable.\n            signature_namespace: mapping of names to types for forward reference resolution\n\n        Returns:\n            ParsedSignature\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    pass\n```\n", "```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    fn_to_inspect: Any = fn\n\n    module_name = fn_to_inspect.__module__\n\n    if isclass(fn_to_inspect):\n        fn_to_inspect = fn_to_inspect.__init__\n\n    # detect objects that are not functions and that have a `__call__` method\n    if callable(fn_to_inspect) and ismethod(fn_to_inspect.__call__):\n        fn_to_inspect = fn_to_inspect.__call__\n\n    # inspect the underlying function for methods\n    signature = inspect.signature(fn_to_inspect, **signature_namespace)\n    # parse signature and return\n```\n", "```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    # Inspect the function to get the signature\n    signature = inspect.signature(fn)\n\n    # Parse the signature\n    parsed_signature = cls.from_signature(signature, fn_type_hints)\n\n    # Validate the signature dependencies\n    valid_dependency_names = cls._validate_signature_dependencies(\n        set(signature_namespace.keys()), fn.__name__, parsed_signature\n    )\n\n    # Return the parsed signature\n    return parsed_signature\n```\n"]}, "litestar-litestar/utils/deprecation.py-deprecated": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: Additional arguments\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n\n\n------------------------------\n------------------------------\n        annotation: Type annotation associated with the origin type. Should be unwrapped from any wrapper types, such\n            as ``Annotated``.\n\n    Returns:\n        The ``typing`` module equivalent of the given type, if it exists. Otherwise, the original type is returned.\n    \"\"\"\n    if origin_type is None:\n        return safe_generic_origin_map.get(annotation)\n    return safe_generic_origin_map.get(origin_type, origin_type)\n\n\ndef get_instantiable_origin(origin_type: Any, annotation: Any) -> Any:\n    \"\"\"Get a type that is safe to instantiate for the given origin type.\n\n    If a builtin collection type is annotated without generic args, e.g, ``a: dict``, then the origin type will be\n    ``None``. In this case, we can use the annotation to determine the correct instantiable type, if one exists.\n\n    Args:\n        origin_type: A type - would be the return value of :func:`get_origin()`.\n        annotation: Type annotation associated with the origin type. Should be unwrapped from any wrapper types, such\n\n------------------------------\n------------------------------\n                expiry time for ``renew_for`` seconds. If the value has not been set\n                with an expiry time this is a no-op\n\n        Returns:\n            The value associated with ``key`` if it exists and is not expired, else\n            ``None``\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, key: str) -> None:\n        \"\"\"Delete a value.\n\n        If no such key exists, this is a no-op.\n\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n        version: Litestar version where the deprecation will occur\n        deprecated_name: Name of the deprecated function\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated thing\n    \"\"\"\n    parts = []\n\n    if kind == \"import\":\n        access_type = \"Import of\"\n    elif kind in {\"function\", \"method\"}:\n        access_type = \"Call to\"\n    else:\n        access_type = \"Use of\"\n\n    if pending:\n        parts.append(f\"{access_type} {kind} awaiting deprecation {deprecated_name!r}\")\n    else:\n\n------------------------------\n------------------------------\n\n\ndef warn_deprecation(\n    version: str,\n    deprecated_name: str,\n    kind: DeprecatedKind,\n    *,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n) -> None:\n    \"\"\"Warn about a call to a (soon to be) deprecated function.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        deprecated_name: Name of the deprecated function\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def deprecated(\n# Natural Language Annotations: \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Callable, TypeVar, cast\nfrom warnings import warn\n\nT = TypeVar(\"T\", bound=Callable[..., Any])\n\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: str | None = None,\n) -> Callable[[T], T]:\n    def decorator(func: T) -> T:\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            warning_message = f\"DeprecationWarning: {func.__name__} is deprecated.\"\n            if kind:\n                warning_message += f\" Use {kind} instead.\"\n            if removal_in:\n                warning_message += f\" It will be removed in version {removal_in}.\"\n            if alternative:\n                warning_message += f\" Use {alternative} instead.\"\n            if info:\n                warning_message += f\" {info}\"\n            warning_class = PendingDeprecationWarning if pending else DeprecationWarning\n            warn(warning_message, category=warning_class, stacklevel=2)\n            return func(*args, **kwargs)\n\n        return cast(T, wrapper)\n\n    return decorator\n```\n", "```python\nfrom functools import wraps\nfrom typing import Any, Callable, TypeVar\n\nF = TypeVar(\"F\", bound=Callable[..., Any])\n\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: str | None = None\n) -> Callable[[F], F]:\n    def decorator(func: F) -> F:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            parts = []\n\n            if kind == \"import\":\n                access_type = \"Import of\"\n            elif kind in {\"function\", \"method\"}:\n                access_type = \"Call to\"\n            else:\n                access_type = \"Use of\"\n\n            if pending:\n                parts.append(f\"{access_type} {kind} awaiting deprecation {func.__name__}\")\n            else:\n                parts.append(f\"{access_type} deprecated {func.__name__}\")\n\n            if info:\n                parts.append(info)\n\n            if removal_in:\n                parts.append(f\"This will be removed in Litestar {removal_in}\")\n\n            if alternative:\n                parts.append(f\"Use {alternative} instead\")\n\n            warning_class = PendingDeprecationWarning if pending else DeprecationWarning\n            warnings.warn(\" \".join(parts), warning_class, stacklevel=2)\n\n            return func(*args, **kwargs)\n\n        return cast(F, wrapper)\n\n    return decorator\n```\n", "```python\nfrom functools import wraps\nfrom inspect import isfunction, ismethod\nfrom typing import Any, Callable, TypeVar, cast\nfrom warnings import warn\n\nT = TypeVar(\"T\", bound=Callable[..., Any])\n\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    *,\n    kind: str | None = None,\n) -> Callable[[T], T]:\n    def decorator(fn: T) -> T:\n        @wraps(fn)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            parts = []\n\n            if kind is None:\n                if isfunction(fn):\n                    parts.append(f\"Call to function {fn.__qualname__}\")\n                elif ismethod(fn):\n                    parts.append(f\"Call to method {fn.__qualname__}\")\n                else:\n                    parts.append(f\"Call to unknown callable {fn.__qualname__}\")\n            elif kind == \"import\":\n                parts.append(f\"Import of {fn.__qualname__}\")\n            elif kind in {\"function\", \"method\"}:\n                parts.append(f\"Call to {kind} {fn.__qualname__}\")\n            else:\n                parts.append(f\"Use of {kind} {fn.__qualname__}\")\n\n            if pending:\n                parts.append(f\"awaiting deprecation {deprecated_name!r}\")\n\n            if removal_in is not None:\n                parts.append(f\"This deprecation will be removed in Litestar version {removal_in}\")\n\n            if alternative is not None:\n                parts.append(f\"Use {alternative} instead\")\n\n            if info is not None:\n                parts.append(f\"Info: {info}\")\n\n            message = \". \".join(parts)\n\n            warn(message, category=PendingDeprecationWarning if pending else DeprecationWarning, stacklevel=2)\n\n            return fn(*args, **kwargs)\n\n        return cast(\"T\", wrapper)\n\n    return decorator\n```\n"]}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Raises:\n            ImproperlyConfiguredException: If ``auth`` is not set in scope via an ``AuthMiddleware``, raises an exception\n\n        Returns:\n            A type correlating to the generic variable Auth.\n        \"\"\"\n        if \"auth\" not in self.scope:\n            raise ImproperlyConfiguredException(\"'auth' is not defined in scope, install an AuthMiddleware to set it\")\n\n        return cast(\"AuthT\", self.scope[\"auth\"])\n\n    @property\n    def user(self) -> UserT:\n        \"\"\"Return the ``user`` data of this connection's ``Scope``.\n\n        Raises:\n            ImproperlyConfiguredException: If ``user`` is not set in scope via an ``AuthMiddleware``, raises an exception\n\n        Returns:\n            A type correlating to the generic variable User.\n\n------------------------------\n------------------------------\n        \"\"\"Check if a given ``key`` exists.\"\"\"\n        return key in self._store\n\n    async def expires_in(self, key: str) -> int | None:\n        \"\"\"Get the time in seconds ``key`` expires in. If no such ``key`` exists or no\n        expiry time was set, return ``None``.\n        \"\"\"\n        if storage_obj := self._store.get(key):\n            return storage_obj.expires_in\n        return None\n\n------------------------------\n------------------------------\n    encoding: dict[str, Encoding] | None = None\n    \"\"\"A map between a property name and its encoding information.\n\n    The key, being the property name, MUST exist in the schema as a property. The encoding object SHALL only apply to\n    ``requestBody`` objects when the media type is ``multipart`` or ``application/x-www-form-urlencoded``.\n    \"\"\"\n\n------------------------------\n------------------------------\n                expiry time for ``renew_for`` seconds. If the value has not been set\n                with an expiry time this is a no-op\n\n        Returns:\n            The value associated with ``key`` if it exists and is not expired, else\n            ``None``\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, key: str) -> None:\n        \"\"\"Delete a value.\n\n        If no such key exists, this is a no-op.\n\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    async def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``kwargs``.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n# Natural Language Annotations: \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return asyncio.coroutine(fn)\n```\n", "```python\nfrom typing import Any, Awaitable, Callable, TypeVar\nimport asyncio\n\nT = TypeVar('T')\nP = TypeVar('P')\n\nclass AsyncCallable:\n    def __init__(self, fn: Callable[P, Awaitable[T]]) -> None:\n        self._fn = fn\n\n    async def __call__(self, *args: P.args, **kwargs: P.kwargs) -> T:\n        return await self._fn(*args, **kwargs)\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```\n", "```python\nfrom typing import Callable, TypeVar, Awaitable, ParamSpec, Any\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    \n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    if iscoroutinefunction(fn):\n        return fn\n    else:\n        async def async_fn(*args: P.args, **kwargs: P.kwargs) -> T:\n            return fn(*args, **kwargs)\n        return async_fn\n```\n"]}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                        # collection type with the DTO supported type.\n                        specialized_annotation = attr_type.safe_generic_origin[model_field_definition.annotation]\n                        return model_field_definition, FieldDefinition.from_annotation(specialized_annotation), attr\n                    return model_field_definition, inner_field, attr\n        return None\n\n    @staticmethod\n    def get_model_type_hints(\n        model_type: type[Any], namespace: dict[str, Any] | None = None\n    ) -> dict[str, FieldDefinition]:\n        \"\"\"Retrieve type annotations for ``model_type``.\n\n        Args:\n            model_type: Any type-annotated class.\n            namespace: Optional namespace to use for resolving type hints.\n\n        Returns:\n            Parsed type hints for ``model_type`` resolved within the scope of its module.\n        \"\"\"\n        namespace = namespace or {}\n\n------------------------------\n------------------------------\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n\n    Returns:\n        bool\n    \"\"\"\n    origin = get_origin_or_inner_type(annotation)\n    if not origin and not isclass(annotation):\n        return False\n    try:\n        return issubclass(origin or annotation, type_or_type_tuple)\n    except TypeError:  # pragma: no cover\n        return False\n\n\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_annotation(cls, annotation: Any, **kwargs: Any) -> FieldDefinition:\n        \"\"\"Initialize FieldDefinition.\n\n        Args:\n            annotation: The type annotation. This should be extracted from the return of\n                ``get_type_hints(..., include_extras=True)`` so that forward references are resolved and recursive\n                ``Annotated`` types are flattened.\n            **kwargs: Additional keyword arguments to pass to the ``FieldDefinition`` constructor.\n\n        Returns:\n\n------------------------------\n------------------------------\n\ndef _is_sync_or_async_generator(obj: Any) -> TypeGuard[AnyGenerator]:\n    \"\"\"Check if the given annotation is a sync or async generator.\n\n    Args:\n        obj: type to be tested for sync or async generator.\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isgeneratorfunction(obj) or isasyncgenfunction(obj)\n\n\ndef is_annotated_type(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is an Annotated.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_signature(cls, signature: Signature, fn_type_hints: dict[str, type]) -> Self:\n        \"\"\"Parse an :class:`inspect.Signature` instance.\n\n        Args:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\n    if namespace is None:\n        return type_hint\n\n    for param, annotation in type_hint.items():\n        if isinstance(annotation, TypeVar):\n            type_hint[param] = namespace.get(annotation, annotation)\n\n    return type_hint\n```\n", "```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\n    if namespace:\n        updated_type_hint = {}\n        for param, type_annotation in type_hint.items():\n            if is_generic(type_annotation) and type_annotation.__origin__ in namespace:\n                updated_type_hint[param] = namespace[type_annotation.__origin__]\n            else:\n                updated_type_hint[param] = type_annotation\n        return updated_type_hint\n    else:\n        return type_hint\n```\n", "```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\n    new_type_hint = {}\n    for param, type_annotation in type_hint.items():\n        if hasattr(type_annotation, '__origin__') and type_annotation.__origin__ is TypeVar:\n            type_var_name = type_annotation.__name__\n            if type_var_name in namespace:\n                new_type_hint[param] = namespace[type_var_name]\n            else:\n                new_type_hint[param] = type_annotation\n        else:\n            new_type_hint[param] = type_annotation\n    return new_type_hint\n```\nThe function `expand_type_var_in_type_hint` takes in a dictionary of type hints and a namespace. It iterates over each parameter in the type hint dictionary. If the type annotation of the parameter is a TypeVar, it checks if the TypeVar name is in the namespace. If it is, it expands the TypeVar to the concrete type specified in the namespace. If it isn't, it leaves the TypeVar as is. The function returns a new dictionary with the expanded TypeVars.\n"]}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n\n    Returns:\n        A tuple of dataclass fields.\n    \"\"\"\n    include = include or set()\n    exclude = exclude or set()\n\n    if common := (include & exclude):\n        raise ValueError(f\"Fields {common} are both included and excluded.\")\n\n    dataclass_fields: Iterable[Field[Any]] = fields(dt)\n    if exclude_none:\n        dataclass_fields = (field for field in dataclass_fields if getattr(dt, field.name) is not None)\n    if exclude_empty:\n\n------------------------------\n------------------------------\n\n        Returns:\n            None\n        \"\"\"\n\n    @abstractmethod\n    async def load_from_connection(self, connection: ASGIConnection) -> dict[str, Any]:\n        \"\"\"Load session data from a connection and return it as a dictionary to be used in the current application\n        scope.\n\n        Args:\n            connection: An ASGIConnection instance\n\n        Returns:\n            The session data\n\n        Notes:\n            - This should not modify the connection's scope. The data returned by this\n              method will be stored in the application scope by the middleware\n\n\n------------------------------\n------------------------------\n    \"extract_dataclass_items\",\n    \"simple_asdict\",\n)\n\n\ndef extract_dataclass_fields(\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    include: AbstractSet[str] | None = None,\n    exclude: AbstractSet[str] | None = None,\n) -> tuple[Field[Any], ...]:\n    \"\"\"Extract dataclass fields.\n\n    Args:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n------------------------------\n------------------------------\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A tuple of key/value pairs.\n    \"\"\"\n    dataclass_fields = extract_dataclass_fields(dt, exclude_none, exclude_empty, include, exclude)\n    return tuple((field.name, getattr(dt, field.name)) for field in dataclass_fields)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    include: AbstractSet[str] | None = None,\n    exclude: AbstractSet[str] | None = None,\n) -> tuple[tuple[str, Any], ...]:\n    \"\"\"Extract dataclass name, value pairs.\n\n    Unlike the 'asdict' method exports by the stlib, this function does not pickle values.\n\n    Args:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        include: An iterable of fields to include.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A tuple of key/value pairs.\n    \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def simple_asdict(\n# Natural Language Annotations: \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef simple_asdict(\n    dt: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        dt: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    include = include or set()\n    exclude = exclude or set()\n\n    if common := (include & exclude):\n        raise ValueError(f\"Fields {common} are both included and excluded.\")\n\n    dataclass_fields: Iterable[Field[Any]] = fields(dt)\n    if exclude_none:\n        dataclass_fields = (field for field in dataclass_fields if getattr(dt, field.name) is not None)\n    if exclude_empty:\n        dataclass_fields = (field for field in dataclass_fields if getattr(dt, field.name) != \"\" or getattr(dt, field.name) != [] or getattr(dt, field.name) != {})\n\n    if convert_nested:\n        return {field.name: simple_asdict(getattr(dt, field.name)) for field in dataclass_fields}\n    else:\n        return {field.name: getattr(dt, field.name) for field in dataclass_fields}\n```\n", "```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: AbstractSet[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    exclude = exclude or set()\n\n    if is_dataclass(obj):\n        result = []\n        for f in fields(obj):\n            if f.name in exclude:\n                continue\n            value = getattr(obj, f.name)\n            if exclude_none and value is None:\n                continue\n            if exclude_empty and not value:\n                continue\n            if convert_nested and is_dataclass(value):\n                value = simple_asdict(value)\n            result.append((f.name, value))\n        return dict(result)\n    else:\n        raise TypeError(f\"Expected dataclass, got {obj.__class__.__name__}\")\n```\n", "```python\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: Iterable[str] = (),\n) -> Dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    exclude = set(exclude)\n    return {\n        field.name: getattr(obj, field.name)\n        for field in fields(obj)\n        if field.name not in exclude\n        and (\n            getattr(obj, field.name) is not None\n            if exclude_none\n            else True\n        )\n        and (\n            bool(getattr(obj, field.name))\n            if exclude_empty\n            else True\n        )\n        and (\n            simple_asdict(getattr(obj, field.name), exclude_none, exclude_empty)\n            if convert_nested and is_dataclass(field.type)\n            else True\n        )\n    }\n```\n"]}, "litestar-litestar/utils/path.py-join_paths": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def match_predicate_recursively(self, predicate: Callable[[FieldDefinition], bool]) -> bool:\n        \"\"\"Recursively test the passed in predicate against the field and any of its inner fields.\n\n        Args:\n            predicate: A callable that receives a field definition instance as an arg and returns a boolean.\n\n        Returns:\n            A boolean.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n    Args:\n        request: The request that triggered the exception.\n        exc: An exception.\n\n    Returns:\n        Response: Debug response constructed from exception details.\n    \"\"\"\n    return _debug_response.create_debug_response(request, exc)\n\n------------------------------\n------------------------------\n        Returns:\n            Template instance\n\n        Raises:\n            TemplateNotFoundException: if no template is found.\n        \"\"\"\n        raise NotImplementedError\n\n    def render_string(self, template_string: str, context: Mapping[str, Any]) -> str:\n        \"\"\"Render a template from a string with the given context.\n\n        Args:\n            template_string: The template string to render.\n            context: A dictionary of variables to pass to the template.\n\n        Returns:\n            The rendered template as a string.\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n\n\ndef parse_params(\n    params: list[Parameter],\n    components: Components,\n) -> tuple[TypeScriptInterface, ...]:\n    \"\"\"Parse request parameters.\n\n    Args:\n        params: An OpenAPI Operation parameters.\n        components: The OpenAPI schema Components section.\n\n    Returns:\n        A tuple of resolved interfaces.\n    \"\"\"\n    cookie_params: list[TypeScriptProperty] = []\n    header_params: list[TypeScriptProperty] = []\n    path_params: list[TypeScriptProperty] = []\n    query_params: list[TypeScriptProperty] = []\n\n\n------------------------------\n------------------------------\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A tuple of key/value pairs.\n    \"\"\"\n    dataclass_fields = extract_dataclass_fields(dt, exclude_none, exclude_empty, include, exclude)\n    return tuple((field.name, getattr(dt, field.name)) for field in dataclass_fields)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def join_paths(paths: Iterable[str]) -> str:\n# Natural Language Annotations: \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return os.path.normpath(os.path.join(*paths))\n```\n", "```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return os.path.normpath(os.path.join(*paths))\n```\n", "```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return '/'.join(str(path).strip('/') for path in paths)\n```\n"]}, "litestar-litestar/utils/helpers.py-get_name": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\ndef decode_json(  # type: ignore[misc]\n    value: str | bytes,\n    target_type: type[T] | EmptyType = Empty,  # pyright: ignore\n    type_decoders: TypeDecodersSequence | None = None,\n) -> Any:\n    \"\"\"Decode a JSON string/bytes into an object.\n\n    Args:\n        value: Value to decode\n        target_type: An optional type to decode the data into\n        type_decoders: Optional sequence of type decoders\n\n    Returns:\n        An object\n\n    Raises:\n        SerializationException: If error decoding ``value``.\n    \"\"\"\n\n------------------------------\n------------------------------\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n    @abstractmethod\n    def count(self, *filters: FilterTypes, **kwargs: Any) -> int:\n        \"\"\"Get the count of records returned by a query.\n\n        Args:\n            *filters: Types for specific filtering operations.\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The count of instances\n        \"\"\"\n\n    @abstractmethod\n    def delete(self, item_id: Any) -> T:\n        \"\"\"Delete instance identified by ``item_id``.\n\n------------------------------\n------------------------------\n        \"\"\"Add ``data`` to the collection.\n\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: Additional arguments\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n\n\n------------------------------\n------------------------------\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    async def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``kwargs``.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_name(value: object) -> str:\n# Natural Language Annotations: \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```\n", "```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```\n", "```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```\n"]}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\ndef is_optional_union(annotation: Any) -> TypeGuard[Any | None]:\n    \"\"\"Given a type annotation determine if the annotation infers an optional union.\n\n    Args:\n        annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type is :data:`Union typing.Union>` with a\n            None value or :data:`Optional <typing.Optional>` which is equivalent.\n    \"\"\"\n    origin = get_origin_or_inner_type(annotation)\n    return origin is Optional or (\n        get_origin_or_inner_type(annotation) in UnionTypes and NoneType in get_args(annotation)\n    )\n\n\n\n\n\n------------------------------\n------------------------------\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n\n    Returns:\n        bool\n    \"\"\"\n    origin = get_origin_or_inner_type(annotation)\n    if not origin and not isclass(annotation):\n        return False\n    try:\n        return issubclass(origin or annotation, type_or_type_tuple)\n    except TypeError:  # pragma: no cover\n        return False\n\n\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\ndef is_class_and_subclass(annotation: Any, type_or_type_tuple: type[T] | tuple[type[T], ...]) -> TypeGuard[type[T]]:\n    \"\"\"Return ``True`` if ``value`` is a ``class`` and is a subtype of ``t_type``.\n\n    See https://github.com/litestar-org/litestar/issues/367\n\n    Args:\n        annotation: The value to check if is class and subclass of ``t_type``.\n        type_or_type_tuple: Type used for :func:`issubclass` check of ``value``\n\n    Returns:\n        bool\n\n------------------------------\n------------------------------\n            ``True`` if ``field_definition`` represents a nested model field.\n        \"\"\"\n\n    @classmethod\n    def is_supported_model_type_field(cls, field_definition: FieldDefinition) -> bool:\n        \"\"\"Check support for the given type.\n\n        Args:\n            field_definition: A :class:`FieldDefinition <litestar.typing.FieldDefinition>` instance.\n\n        Returns:\n            Whether the type of the field definition is supported by the DTO.\n        \"\"\"\n        return field_definition.is_subclass_of(cls.model_type) or (\n            field_definition.origin\n            and any(\n                cls.resolve_model_type(inner_field).is_subclass_of(cls.model_type)\n                for inner_field in field_definition.inner_types\n            )\n        )\n\n------------------------------\n------------------------------\ndef is_generic(annotation: Any) -> bool:\n    \"\"\"Given a type annotation determine if the annotation is a generic class.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        True if the annotation is a subclass of :data:`Generic <typing.Generic>` otherwise ``False``.\n    \"\"\"\n    return is_class_and_subclass(annotation, Generic)  # type: ignore[arg-type]\n\n\ndef is_mapping(annotation: Any) -> TypeGuard[Mapping[Any, Any]]:\n    \"\"\"Given a type annotation determine if the annotation is a mapping type.\n\n    Args:\n    annotation: A type.\n\n    Returns:\n        A typeguard determining whether the type can be cast as :class:`Mapping <typing.Mapping>`.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n# Natural Language Annotations: \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_class_and_subclass(annotation, DataclassProtocol)\n```\n", "```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_class_and_subclass(annotation, DataclassProtocol)\n```\n", "```python\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_class_and_subclass(annotation, DataclassProtocol)\n```\n"]}, "litestar-litestar/utils/predicates.py-is_class_var": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\ndef is_pydantic_constrained_field(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a constrained pydantic type.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        True if pydantic is installed and the type is a constrained type, otherwise False.\n    \"\"\"\n    if pydantic_v1 is Empty:  # pragma: no cover\n        return False  # type: ignore[unreachable]\n\n    return any(\n        is_class_and_subclass(annotation, constrained_type)  # pyright: ignore\n        for constrained_type in (\n            pydantic_v1.ConstrainedBytes,\n            pydantic_v1.ConstrainedDate,\n            pydantic_v1.ConstrainedDecimal,\n\n------------------------------\n------------------------------\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _AnnotatedAlias) and getattr(annotation, \"__args__\", None) is not None\n\n\ndef is_undefined_sentinel(value: Any) -> bool:\n    \"\"\"Check if the given value is the undefined sentinel.\n\n    Args:\n        value: A value to be tested for undefined sentinel.\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return any(v is value for v in UNDEFINED_SENTINELS)\n\n------------------------------\n------------------------------\n        Returns:\n            Template instance\n\n        Raises:\n            TemplateNotFoundException: if no template is found.\n        \"\"\"\n        raise NotImplementedError\n\n    def render_string(self, template_string: str, context: Mapping[str, Any]) -> str:\n        \"\"\"Render a template from a string with the given context.\n\n        Args:\n            template_string: The template string to render.\n            context: A dictionary of variables to pass to the template.\n\n        Returns:\n            The rendered template as a string.\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n------------------------------\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef _is_sync_or_async_generator(obj: Any) -> TypeGuard[AnyGenerator]:\n    \"\"\"Check if the given annotation is a sync or async generator.\n\n    Args:\n\n------------------------------\n------------------------------\n\ndef _is_sync_or_async_generator(obj: Any) -> TypeGuard[AnyGenerator]:\n    \"\"\"Check if the given annotation is a sync or async generator.\n\n    Args:\n        obj: type to be tested for sync or async generator.\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isgeneratorfunction(obj) or isasyncgenfunction(obj)\n\n\ndef is_annotated_type(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is an Annotated.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_class_var(annotation: Any) -> bool:\n# Natural Language Annotations: \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, _ClassVarAlias)\n```\n", "```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, type) and getattr(annotation, '__classcell__', None) is not None\n```\n", "```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    if pydantic_v1 is Empty:  # pragma: no cover\n        return False  # type: ignore[unreachable]\n\n    return any(\n        is_class_and_subclass(annotation, classified_type)  # pyright: ignore\n        for classified_type in (\n            pydantic_v1.ClassVar,\n        )\n    )\n```\n"]}, "litestar-litestar/utils/module_loader.py-import_string": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            **kwargs: Identifier of the instance to be retrieved.\n\n        Returns:\n            True if the instance was found.  False if not found..\n\n        \"\"\"\n        existing = await self.count(*filters, **kwargs)\n        return bool(existing)\n\n    async def get(self, item_id: Any, **kwargs: Any) -> ModelT:\n        \"\"\"Get instance identified by ``item_id``.\n\n        Args:\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: additional arguments\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n\n------------------------------\n------------------------------\n\n        Args:\n            *filters: Types for specific filtering operations.\n            **kwargs: Identifier of the instance to be retrieved.\n\n        Returns:\n            True if the instance was found.  False if not found.\n\n        \"\"\"\n\n    @abstractmethod\n    def get(self, item_id: Any, **kwargs: Any) -> T:\n        \"\"\"Get instance identified by ``item_id``.\n\n        Args:\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: Additional arguments\n\n        Returns:\n            The retrieved instance.\n\n------------------------------\n------------------------------\n            *filters: Types for specific filtering operations.\n            **kwargs: Identifier of the instance to be retrieved.\n\n        Returns:\n            True if the instance was found.  False if not found.\n\n        \"\"\"\n\n    @abstractmethod\n    async def get(self, item_id: Any, **kwargs: Any) -> T:\n        \"\"\"Get instance identified by ``item_id``.\n\n        Args:\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: Additional arguments\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n\n------------------------------\n------------------------------\n    def __init__(self, directory: Path | list[Path] | None, engine_instance: Any | None) -> None:\n        \"\"\"Initialize the template engine with a directory.\n\n        Args:\n            directory: Direct path or list of directory paths from which to serve templates, if provided the\n                implementation has to create the engine instance.\n            engine_instance: A template engine object, if provided the implementation has to use it.\n        \"\"\"\n\n    def get_template(self, template_name: str) -> TemplateType_co:\n        \"\"\"Retrieve a template by matching its name (dotted path) with files in the directory or directories provided.\n\n        Args:\n            template_name: A dotted path\n\n        Returns:\n            Template instance\n\n        Raises:\n            TemplateNotFoundException: if no template is found.\n\n------------------------------\n------------------------------\n    \"import_string\",\n    \"module_to_os_path\",\n)\n\n\ndef module_to_os_path(dotted_path: str = \"app\") -> Path:\n    \"\"\"Find Module to OS Path.\n\n    Return a path to the base directory of the project or the module\n    specified by `dotted_path`.\n\n    Args:\n        dotted_path: The path to the module. Defaults to \"app\".\n\n    Raises:\n        TypeError: The module could not be found.\n\n    Returns:\n        Path: The path to the module.\n    \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def import_string(dotted_path: str) -> Any:\n# Natural Language Annotations: \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError:\n        raise ImportError(f\"{dotted_path} doesn't look like a module path\")\n\n    module = importlib.import_module(module_path)\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError:\n        raise ImportError(f'Module {module_path} does not define a {class_name} attribute/class')\n```\n", "```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError:\n        raise ImportError(f\"{dotted_path} does not look like a module path\")\n\n    module = import_module(module_path)\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError:\n        raise ImportError(f\"Module {module_path} does not define a {class_name} attribute/class\")\n```\n", "```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, _, attribute_name = dotted_path.rpartition('.')\n        module = __import__(module_path, fromlist=[attribute_name])\n        return getattr(module, attribute_name)\n    except (ImportError, AttributeError) as e:\n        raise ImportError(f\"Could not import from {dotted_path}\") from e\n```\n"]}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    async def on_shutdown(self) -> None:\n        \"\"\"Called on application shutdown\"\"\"\n\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Subscribe to ``channels``\"\"\"\n        self._subscribed_channels.update(channels)\n        self._has_subscribed_channels.set()\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n\n------------------------------\n------------------------------\n            self._queue.put_nowait((channel, data))\n        if self._max_history_length:\n            for channel in channels:\n                self._history[channel].append(data)\n\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Subscribe to ``channels``, and enable publishing to them\"\"\"\n        self._channels.update(channels)\n\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Unsubscribe from ``channels``\"\"\"\n        self._channels -= set(channels)\n        try:\n            for channel in channels:\n                del self._history[channel]\n        except KeyError:\n            pass\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n\n------------------------------\n------------------------------\n            if not channel_subscribers:\n                channels_to_subscribe.add(channel)\n\n            channel_subscribers.add(subscriber)\n\n        if channels_to_subscribe:\n            await self._backend.subscribe(channels_to_subscribe)\n\n        if history:\n            await self.put_subscriber_history(subscriber=subscriber, limit=history, channels=channels)\n\n        return subscriber\n\n    async def unsubscribe(self, subscriber: Subscriber, channels: str | Iterable[str] | None = None) -> None:\n        \"\"\"Unsubscribe a :class:`Subscriber` from ``channels``. If the subscriber has a running sending task, it will\n        be stopped.\n\n        Args:\n            channels: Channels to unsubscribe from. If ``None``, unsubscribe from all channels\n            subscriber: :class:`Subscriber` to unsubscribe\n\n------------------------------\n------------------------------\n        \"\"\"Construct a header from its string representation.\"\"\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n@dataclass\nclass CacheControlHeader(Header):\n    \"\"\"A ``cache-control`` header.\"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def unsubscribe(self, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Unsubscribe from ``channels``\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._subscribed_channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```\n", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._channels -= set(channels)\n    try:\n        for channel in channels:\n            del self._history[channel]\n    except KeyError:\n        pass\n```\n", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    self._subscribed_channels -= set(channels)\n    for channel in channels:\n        self._history.pop(channel, None)\n```\n"]}, "litestar-litestar/channels/backends/redis.py-publish": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Delete all stream keys with the ``key_prefix``.\n\n        .. important::\n            This method is incompatible with redis clusters\n        \"\"\"\n        deleted_streams = await self._flush_all_streams_script(keys=[], args=[f\"{self._key_prefix}*\"])\n        return cast(\"int\", deleted_streams)\n\n------------------------------\n------------------------------\n        \"\"\"Add ``data`` to the collection.\n\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\n\n        .. note::\n            This operation is performed atomically, using a lua script\n        \"\"\"\n        await self._publish_script(keys=list(set(channels)), args=[data])\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\n\n        while True:\n            await self._has_subscribed.wait()\n            message = await self._pub_sub.get_message(\n                ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n            )\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    async def flush_all(self) -> int:\n        \"\"\"Delete all stream keys with the ``key_prefix``.\n\n        .. important::\n            This method is incompatible with redis clusters\n        \"\"\"\n\n------------------------------\n------------------------------\n\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Subscribe to ``channels``, and enable publishing to them\"\"\"\n        await self._pub_sub.subscribe(*channels)\n        self._has_subscribed.set()\n\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        await self._pub_sub.unsubscribe(*channels)\n        # if we have no active subscriptions, or only subscriptions which are pending\n        # to be unsubscribed we consider the backend to be unsubscribed from all\n        # channels, so we reset the event\n        if not self._pub_sub.channels.keys() - self._pub_sub.pending_unsubscribe_channels:\n            self._has_subscribed.clear()\n\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\n\n        .. note::\n            This operation is performed atomically, using a lua script\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```\n", "```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```\n", "```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```\n"]}, "litestar-litestar/channels/backends/redis.py-stream_events": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        self._event.set()\n\n    def clear(self) -> None:\n        self._event.clear()\n\n    async def wait(self) -> None:\n        await self._event.wait()\n\n\nclass RedisChannelsBackend(ChannelsBackend, ABC):\n    def __init__(self, *, redis: Redis, key_prefix: str, stream_sleep_no_subscriptions: int) -> None:\n        \"\"\"Base redis channels backend.\n\n        Args:\n            redis: A :class:`redis.asyncio.Redis` instance\n            key_prefix: Key prefix to use for storing data in redis\n            stream_sleep_no_subscriptions: Amount of time in milliseconds to pause the\n                :meth:`stream_events` generator, should no subscribers exist\n        \"\"\"\n        self._redis = redis\n\n------------------------------\n------------------------------\n            self._queue.put_nowait((channel, data))\n        if self._max_history_length:\n            for channel in channels:\n                self._history[channel].append(data)\n\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Subscribe to ``channels``, and enable publishing to them\"\"\"\n        self._channels.update(channels)\n\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Unsubscribe from ``channels``\"\"\"\n        self._channels -= set(channels)\n        try:\n            for channel in channels:\n                del self._history[channel]\n        except KeyError:\n            pass\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n\n------------------------------\n------------------------------\n        ...\n\n    @abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        ...\n\n    @abstractmethod\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        ...\n\n------------------------------\n------------------------------\n        ...\n\n    @abstractmethod\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish the message ``data`` to all ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Start listening for events on ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n\n------------------------------\n------------------------------\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish ``data`` to ``channels``\n\n        .. note::\n            This operation is performed atomically, using a lua script\n        \"\"\"\n        await self._publish_script(keys=list(set(channels)), args=[data])\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\n\n        while True:\n            await self._has_subscribed.wait()\n            message = await self._pub_sub.get_message(\n                ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n            )\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n# Natural Language Annotations: \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n```\n", "```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n```\n", "```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n        if message is not None:\n            yield (message['channel'].decode(), message['data'])\n```\n"]}, "litestar-litestar/channels/backends/redis.py-get_history": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Returns:\n            A :class:`Subscriber`\n        \"\"\"\n        subscriber = await self.subscribe(channels, history=history)\n\n        try:\n            yield subscriber\n        finally:\n            await self.unsubscribe(subscriber, channels)\n\n    async def put_subscriber_history(\n        self, subscriber: Subscriber, channels: str | Iterable[str], limit: int | None = None\n    ) -> None:\n        \"\"\"Fetch the history of ``channels`` from the backend and put them in the\n        subscriber's stream\n        \"\"\"\n        if isinstance(channels, str):\n            channels = [channels]\n\n\n------------------------------\n------------------------------\n        except KeyError:\n            pass\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        if self._queue is None:\n            raise RuntimeError(\"Backend not yet initialized. Did you forget to call on_startup?\")\n\n        while True:\n            channel, message = await self._queue.get()\n            self._queue.task_done()\n\n            # if a message is published to a channel and the channel is then\n            # unsubscribed before retrieving that message from the stream, it can still\n            # end up here, so we double-check if we still are interested in this message\n            if channel in self._channels:\n                yield channel, message\n\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n\n------------------------------\n------------------------------\n        ...\n\n    @abstractmethod\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        \"\"\"Publish the message ``data`` to all ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    async def subscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Start listening for events on ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Stop listening for events on ``channels``\"\"\"\n        ...\n\n    @abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n\n------------------------------\n------------------------------\n        ...\n\n    @abstractmethod\n    def stream_events(self) -> AsyncGenerator[tuple[str, bytes], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available\"\"\"\n        ...\n\n    @abstractmethod\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        ...\n\n------------------------------\n------------------------------\n            if channel in self._channels:\n                yield channel, message\n\n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n        history = list(self._history[channel])\n        if limit:\n            history = history[-limit:]\n        return history\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n# Natural Language Annotations: \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```\n", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```\n", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the event history of ``channel``, at most ``limit`` entries\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```\n"]}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Add ``data`` to the collection.\n\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n        field_definition: FieldDefinition,\n    ) -> Any:\n        \"\"\"Create instance or iterable of instances of ``destination_type``.\n\n        Args:\n            destination_type: the model type received by the DTO on type narrowing.\n            field_definition: the parsed type that represents the handler annotation for which the DTO is being applied.\n\n        Returns:\n            Data parsed into ``destination_type``.\n        \"\"\"\n\n        return TransferFunctionFactory.create_transfer_data(\n            destination_type=destination_type,\n            field_definitions=self.parsed_field_definitions,\n            is_data_field=self.is_data_field,\n            field_definition=field_definition,\n        )\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n\n------------------------------\n------------------------------\n    ) -> None:\n        \"\"\"Create dto backend instance.\n\n        Args:\n            dto_factory: The DTO factory class calling this backend.\n            field_definition: Parsed type.\n            handler_id: The name of the handler that this backend is for.\n            is_data_field: Whether the field is a subclass of DTOData.\n            model_type: Model type.\n            wrapper_attribute_name: If the data that DTO should operate upon is wrapped in a generic datastructure,\n              this is the name of the attribute that the data is stored in.\n        \"\"\"\n        super().__init__(\n            dto_factory=dto_factory,\n            field_definition=field_definition,\n            handler_id=handler_id,\n            is_data_field=is_data_field,\n            model_type=model_type,\n            wrapper_attribute_name=wrapper_attribute_name,\n        )\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_transfer_model_type(\n# Natural Language Annotations: \"\"\"Create a model for data transfer.\n\n        Args:\n            model_name: name for the type that should be unique across all transfer types.\n            field_definitions: field definitions for the container type.\n\n        Returns:\n            A ``BackendT`` class.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_transfer_model_type(model_name: str, field_definitions: list) -> Type[BackendT]:\n    \"\"\"Create a model for data transfer.\n\n    Args:\n        model_name: name for the type that should be unique across all transfer types.\n        field_definitions: field definitions for the container type.\n\n    Returns:\n        A ``BackendT`` class.\n    \"\"\"\n    # Your implementation here\n    pass\n```\n", "```python\nfrom typing import Type\n\ndef create_transfer_model_type(\n    model_name: str,\n    field_definitions: List[FieldDefinition],\n) -> Type[BackendT]:\n    \"\"\"Create a model for data transfer.\n\n    Args:\n        model_name: name for the type that should be unique across all transfer types.\n        field_definitions: field definitions for the container type.\n\n    Returns:\n        A ``BackendT`` class.\n    \"\"\"\n    # Your implementation here\n    pass\n```\n", "```python\ndef create_transfer_model_type(\n        model_name: str,\n        field_definitions: List[FieldDefinition]\n) -> Type[BackendT]:\n    \"\"\"Create a model for data transfer.\n\n    Args:\n        model_name: name for the type that should be unique across all transfer types.\n        field_definitions: field definitions for the container type.\n\n    Returns:\n        A ``BackendT`` class.\n    \"\"\"\n    # Your implementation here...\n```\n"]}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def parse_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse builtin types into transfer model type.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The builtin type parsed into transfer model type.\n        \"\"\"\n        return convert(\n            obj=builtins,\n            type=self.annotation,\n            dec_hook=asgi_connection.route_handler.default_deserializer,\n            strict=False,\n            str_keys=True,\n        )\n\n\n\n\n------------------------------\n------------------------------\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return self._transfer_data_from_builtins(builtins)\n\n    def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n\n------------------------------\n------------------------------\n            field_definition=self.field_definition,\n        )\n        self._transfer_data_from_builtins_with_overrides = self._create_transfer_data_fn(\n            destination_type=self.model_type,\n            field_definition=self.field_definition,\n        )\n        self._encode_data = self._create_transfer_data_fn(\n            destination_type=self.transfer_model_type,\n            field_definition=self.field_definition,\n        )\n\n    def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n\n------------------------------\n------------------------------\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n            )\n        return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n        )\n    return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n```\n", "```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n        )\n    return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n```\n", "```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n        )\n    return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n```\n"]}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n    def parse_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Struct | Collection[Struct]:\n        \"\"\"Parse raw bytes into transfer model type.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            The raw bytes parsed into transfer model type.\n        \"\"\"\n        request_encoding = RequestEncodingType.JSON\n\n        if (content_type := getattr(asgi_connection, \"content_type\", None)) and (media_type := content_type[0]):\n            request_encoding = media_type\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n\n------------------------------\n------------------------------\n            field_definition=self.field_definition,\n        )\n        self._transfer_data_from_builtins_with_overrides = self._create_transfer_data_fn(\n            destination_type=self.model_type,\n            field_definition=self.field_definition,\n        )\n        self._encode_data = self._create_transfer_data_fn(\n            destination_type=self.transfer_model_type,\n            field_definition=self.field_definition,\n        )\n\n    def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n\n------------------------------\n------------------------------\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n            )\n        return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n\n    def transfer_data_from_builtins(self, builtins: Any) -> Any:\n        \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n        Args:\n            builtins: Builtin type.\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        return self._transfer_data_from_builtins(builtins)\n\n    def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n        \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    parsed_data = self.parse_raw(raw, asgi_connection)\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(parsed_data),\n        )\n    return self.transfer_data_from_builtins(parsed_data)\n```\n", "```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    parsed_data = self.parse_raw(raw, asgi_connection)\n    if self.dto_data_type:\n        return self.dto_data_type(backend=self, data_as_builtins=self._transfer_to_dict(parsed_data))\n    return self.transfer_data_from_builtins(parsed_data)\n```\n", "```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    parsed = self.parse_raw(raw, asgi_connection)\n    if self.dto_data_type:\n        return self.dto_data_type(backend=self, data_as_builtins=self._transfer_to_dict(parsed))\n    else:\n        return self.transfer_data_from_builtins(parsed)\n```\n"]}, "litestar-litestar/dto/_backend.py-encode_data": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    async def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n    @abstractmethod\n    async def count(self, *filters: FilterTypes, **kwargs: Any) -> int:\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n        \"\"\"Add ``data`` to the collection.\n\n        Args:\n            data: Instance to be added to the collection.\n\n        Returns:\n            The added instance.\n        \"\"\"\n\n    @abstractmethod\n    def add_many(self, data: list[T]) -> list[T]:\n        \"\"\"Add multiple ``data`` to the collection.\n\n        Args:\n            data: Instances to be added to the collection.\n\n        Returns:\n            The added instances.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\n        if self.wrapper_attribute_name:\n            wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n            setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n            return cast(\"LitestarEncodableType\", data)\n\n        return cast(\"LitestarEncodableType\", self._encode_data(data))\n\n    def _create_transfer_data_fn(\n        self,\n        destination_type: type[Any],\n        field_definition: FieldDefinition,\n    ) -> Any:\n        \"\"\"Create instance or iterable of instances of ``destination_type``.\n\n        Args:\n\n------------------------------\n------------------------------\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\n        if self.dto_data_type:\n            return self.dto_data_type(\n                backend=self,\n                data_as_builtins=self._transfer_to_dict(self.parse_raw(raw, asgi_connection)),\n            )\n        return self._transfer_to_model_type(self.parse_raw(raw, asgi_connection))\n\n    def encode_data(self, data: Any) -> LitestarEncodableType:\n        \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def encode_data(self, data: Any) -> LitestarEncodableType:\n# Natural Language Annotations: \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    \"\"\"Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n\n    return cast(\"LitestarEncodableType\", self._encode_data(data))\n```\n", "```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    \"\"\"Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n\n    return cast(\"LitestarEncodableType\", self._encode_data(data))\n```\n", "```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    \"\"\"Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n\n    return cast(\"LitestarEncodableType\", self._encode_data(data))\n```\n"]}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    field_definitions: tuple[TransferDTOFieldDefinition, ...],\n    is_data_field: bool,\n) -> Any:\n    \"\"\"Create instance of ``destination_type`` with data from ``source_instance``.\n\n    Args:\n        destination_type: the model type received by the DTO on type narrowing.\n        source_instance: primitive data that has been parsed and validated via the backend.\n        field_definitions: model field definitions.\n        is_data_field: whether the given field is a 'data' kwarg field.\n\n    Returns:\n        Data parsed into ``model_type``.\n    \"\"\"\n    unstructured_data = {}\n\n    for field_definition in field_definitions:\n        if not is_data_field:\n            if field_definition.is_excluded:\n                continue\n\n------------------------------\n------------------------------\n        source_data: data that has been parsed and validated via the backend.\n        field_definitions: model field definitions.\n        field_definition: the parsed type that represents the handler annotation for which the DTO is being applied.\n        is_data_field: whether the DTO is being applied to a ``data`` field.\n\n    Returns:\n        Data parsed into ``destination_type``.\n    \"\"\"\n    if field_definition.is_non_string_collection:\n        if not field_definition.is_mapping:\n            return field_definition.instantiable_origin(\n                _transfer_data(\n                    destination_type=destination_type,\n                    source_data=item,\n                    field_definitions=field_definitions,\n                    field_definition=field_definition.inner_types[0],\n                    is_data_field=is_data_field,\n                )\n                for item in source_data\n            )\n\n------------------------------\n------------------------------\n        )\n    return defstruct(model_name, struct_fields, frozen=True, kw_only=True, rename=rename_strategy)\n\n\ndef build_annotation_for_backend(\n    model_type: type[Any], field_definition: FieldDefinition, transfer_model: type[Struct]\n) -> Any:\n    \"\"\"A helper to re-build a generic outer type with new inner type.\n\n    Args:\n        model_type: The original model type.\n        field_definition: The parsed type that represents the handler annotation for which the DTO is being applied.\n        transfer_model: The transfer model generated to represent the model type.\n\n    Returns:\n        Annotation with new inner type if applicable.\n    \"\"\"\n    if not field_definition.inner_types:\n        if field_definition.is_subclass_of(model_type):\n            return transfer_model\n\n------------------------------\n------------------------------\n        )\n\n    @classmethod\n    def resolve_generic_wrapper_type(\n        cls, field_definition: FieldDefinition\n    ) -> tuple[FieldDefinition, FieldDefinition, str] | None:\n        \"\"\"Handle where DTO supported data is wrapped in a generic container type.\n\n        Args:\n            field_definition: A parsed type annotation that represents the annotation used to narrow the DTO type.\n\n        Returns:\n            The data model type.\n        \"\"\"\n        if field_definition.origin and (\n            inner_fields := [\n                inner_field\n                for inner_field in field_definition.inner_types\n                if cls.resolve_model_type(inner_field).is_subclass_of(cls.model_type)\n            ]\n\n------------------------------\n------------------------------\n        Returns:\n            The type and config object extracted from the annotation.\n        \"\"\"\n        return next((item for item in field_definition.metadata if isinstance(item, DTOConfig)), None)\n\n    @classmethod\n    def resolve_model_type(cls, field_definition: FieldDefinition) -> FieldDefinition:\n        \"\"\"Resolve the data model type from a parsed type.\n\n        Args:\n            field_definition: A parsed type annotation that represents the annotation used to narrow the DTO type.\n\n        Returns:\n            A :class:`FieldDefinition <.typing.FieldDefinition>` that represents the data model type.\n        \"\"\"\n        if field_definition.is_optional:\n            return cls.resolve_model_type(\n                next(t for t in field_definition.inner_types if not t.is_subclass_of(NoneType))\n            )\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n# Natural Language Annotations: \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    if transfer_type.is_model_type:\n        return transfer_type.model_type_annotation\n    else:\n        return transfer_type.transfer_model_type_annotation\n```\n", "```python\nfrom typing import Any\n\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    if transfer_type.origin:\n        if transfer_type.is_non_string_collection:\n            if not transfer_type.is_mapping:\n                return transfer_type.instantiable_origin(\n                    _create_transfer_model_type_annotation(\n                        destination_type=transfer_type.inner_types[0],\n                        source_data=item,\n                        field_definitions=field_definitions,\n                        field_definition=field_definition.inner_types[0],\n                        is_data_field=is_data_field,\n                    )\n                    for item in source_data\n                )\n        else:\n            return transfer_type.instantiable_origin(\n                _create_transfer_model_type_annotation(\n                    destination_type=transfer_type.inner_types[0],\n                    source_data=item,\n                    field_definitions=field_definitions,\n                    field_definition=field_definition.inner_types[0],\n                    is_data_field=is_data_field,\n                )\n                for item in source_data\n            )\n    else:\n        return transfer_type\n```\n", "```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    if isinstance(transfer_type, dict):\n        return Union[\n            build_annotation_for_backend(\n                model_type=field_definition.type,\n                field_definition=field_definition,\n                transfer_model=transfer_model,\n            )\n            for field_definition in transfer_type.values()\n        ]\n\n    if transfer_type.origin and (\n        inner_fields := [\n            inner_field\n            for inner_field in transfer_type.inner_types\n            if resolve_model_type(inner_field).is_subclass_of(model_type)\n        ]\n    ):\n        return transfer_type.origin[tuple(inner_fields)]\n\n    if transfer_type.is_optional:\n        return Optional[\n            _create_transfer_model_type_annotation(\n                next(\n                    t\n                    for t in transfer_type.inner_types\n                    if not t.is_subclass_of(NoneType)\n                )\n            )\n        ]\n\n    if transfer_type.is_non_string_collection:\n        if not transfer_type.is_mapping:\n            return List[\n                _create_transfer_model_type_annotation(\n                    destination_type=transfer_type.inner_types[0]\n                )\n            ]\n\n    return transfer_type\n```\n"]}, "litestar-litestar/response/file.py-start_response": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    async def send_body(self, send: Send, receive: Receive) -> None:\n        \"\"\"Emit the response body.\n\n        Args:\n            send: The ASGI send function.\n            receive: The ASGI receive function.\n\n        Notes:\n            - Response subclasses should customize this method if there is a need to customize sending data.\n\n        Returns:\n            None\n        \"\"\"\n        event: HTTPResponseBodyEvent = {\"type\": \"http.response.body\", \"body\": self.body, \"more_body\": False}\n        await send(event)\n\n    async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n        \"\"\"ASGI callable of the ``Response``.\n\n\n------------------------------\n------------------------------\n        self.etag = etag\n        self.file_path = file_path\n\n        if file_info:\n            self.file_info: FileInfo | Coroutine[Any, Any, FileInfo] = file_info\n        elif stat_result:\n            self.file_info = self.adapter.parse_stat_result(result=stat_result, path=file_path)\n        else:\n            self.file_info = self.adapter.info(self.file_path)\n\n    async def send_body(self, send: Send, receive: Receive) -> None:\n        \"\"\"Emit a stream of events correlating with the response body.\n\n        Args:\n            send: The ASGI send function.\n            receive: The ASGI receive function.\n\n        Returns:\n            None\n        \"\"\"\n\n------------------------------\n------------------------------\n        \"\"\"Execute the ASGI middleware.\n\n        Called by the previous middleware in the stack if a response is not awaited prior.\n\n        Upon completion, middleware should call the next ASGI handler and await it - or await a response created in its\n        closure.\n\n        Args:\n            scope: The ASGI connection scope.\n            receive: The ASGI receive function.\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        raise NotImplementedError(\"abstract method must be implemented\")\n\n------------------------------\n------------------------------\n    def encoded_headers(self) -> list[tuple[bytes, bytes]]:\n        return self.encode_headers()\n\n    def encode_headers(self) -> list[tuple[bytes, bytes]]:\n        return [*self.headers.headers, *self._encoded_cookies]\n\n    async def after_response(self) -> None:\n        \"\"\"Execute after the response is sent.\n\n        Returns:\n            None\n        \"\"\"\n        if self.background is not None:\n            await self.background()\n\n    async def start_response(self, send: Send) -> None:\n        \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n------------------------------\n------------------------------\n    async def start_response(self, send: Send) -> None:\n        \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\n        event: HTTPResponseStartEvent = {\n            \"type\": \"http.response.start\",\n            \"status\": self.status_code,\n            \"headers\": self.encode_headers(),\n        }\n        await send(event)\n\n    async def send_body(self, send: Send, receive: Receive) -> None:\n        \"\"\"Emit the response body.\n\n        Args:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def start_response(self, send: Send) -> None:\n# Natural Language Annotations: \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```\n", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```\n", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```\n"]}, "litestar-litestar/connection/request.py-json": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n    async def msgpack(self) -> Any:\n        \"\"\"Retrieve the MessagePack request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        if self._msgpack is Empty:\n            if (msgpack := self._connection_state.msgpack) is not Empty:\n                self._msgpack = msgpack\n            else:\n                body = await self.body()\n                self._msgpack = self._connection_state.msgpack = decode_msgpack(\n                    body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n                )\n        return self._msgpack\n\n    async def stream(self) -> AsyncGenerator[bytes, None]:\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n\n    Args:\n        request: The request that triggered the exception.\n        exc: An exception.\n\n    Returns:\n        Response: Debug response constructed from exception details.\n    \"\"\"\n    return _debug_response.create_debug_response(request, exc)\n\n------------------------------\n------------------------------\n\n    def write(self, body: bytes) -> None:\n        \"\"\"Write compressed bytes.\n\n        Args:\n            body: Message body to process\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n    def close(self) -> None:\n        \"\"\"Close the compression stream.\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n------------------------------\n------------------------------\n        return self._accept\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    async def msgpack(self) -> Any:\n        \"\"\"Retrieve the MessagePack request body from the request.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def json(self) -> Any:\n# Natural Language Annotations: \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if self._json is Empty:\n        if (json := self._connection_state.json) is not Empty:\n            self._json = json\n        else:\n            body = await self.body()\n            self._json = self._connection_state.json = decode_json(\n                body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n            )\n    return self._json\n```\n", "```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if self._json is Empty:\n        if (json := self._connection_state.json) is not Empty:\n            self._json = json\n        else:\n            body = await self.body()\n            self._json = self._connection_state.json = decode_json(\n                body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n            )\n    return self._json\n```\n", "```python\nasync def json(self) -> Any:\n        \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        if self._json is Empty:\n            if (json := self._connection_state.json) is not Empty:\n                self._json = json\n            else:\n                body = await self.body()\n                self._json = self._connection_state.json = decode_json(\n                    body or b\"\\xc0\", type_decoders=self.route_handler.resolve_type_decoders()\n                )\n        return self._json\n```\n"]}, "litestar-litestar/datastructures/multi_dicts.py-close": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def set_session_data(self, data: dict[str, Any]) -> None:\n        \"\"\"Set session data.\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    async def flush_all(self) -> int:\n        \"\"\"Delete all stream keys with the ``key_prefix``.\n\n        .. important::\n            This method is incompatible with redis clusters\n        \"\"\"\n\n------------------------------\n------------------------------\n\n    async def __call__(self) -> None:\n        \"\"\"Call the wrapped background tasks.\n\n        Returns:\n            None\n        \"\"\"\n        if self.run_in_task_group:\n            async with create_task_group() as task_group:\n                for task in self.tasks:\n                    task_group.start_soon(task)\n        else:\n            for task in self.tasks:\n                await task()\n\n------------------------------\n------------------------------\n\n        Args:\n            key: Key to set.\n            value: Value to set.\n\n        Returns:\n            None\n        \"\"\"\n\n        with self._lock:\n            self._state[key] = value\n\n    def __setattr__(self, key: str, value: Any) -> None:\n        \"\"\"Set an item in the state using attribute notation.\n\n        Args:\n            key: Key to set.\n            value: Value to set.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n    def write(self, body: bytes) -> None:\n        \"\"\"Write compressed bytes.\n\n        Args:\n            body: Message body to process\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n    def close(self) -> None:\n        \"\"\"Close the compression stream.\n\n        Returns:\n            None\n        \"\"\"\n        ...\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def close(self) -> None:\n# Natural Language Annotations: \"\"\"Close all files in the multi-dict.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    # Your code here\n    pass\n```\n", "```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    # Implementation goes here\n```\n", "```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for key, value in self._state.items():\n        if isinstance(value, IOBase):\n            value.close()\n```\n"]}, "litestar-litestar/datastructures/url.py-from_scope": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        else:\n            self.headers = []\n\n    @classmethod\n    def from_message(cls, message: \"Message\") -> \"MutableScopeHeaders\":\n        \"\"\"Construct a header from a message object.\n\n        Args:\n            message: :class:`Message <.types.Message>`.\n\n        Returns:\n            MutableScopeHeaders.\n\n        Raises:\n            ValueError: If the message does not have a ``headers`` key.\n        \"\"\"\n        if \"headers\" not in message:\n            raise ValueError(f\"Invalid message type: {message['type']!r}\")\n\n        return cls(cast(\"HeaderScope\", message))\n\n------------------------------\n------------------------------\n        \"\"\"Extract a status code from a ``Message``\n\n        Args:\n            messages: A tuple containing\n                :class:`HTTPResponseStartEvent <litestar.types.asgi_types.HTTPResponseStartEvent>`\n                and :class:`HTTPResponseBodyEvent <litestar.types.asgi_types.HTTPResponseBodyEvent>`.\n\n        Returns:\n            The Response's status-code.\n        \"\"\"\n        return messages[0][\"status\"]\n\n    def extract_headers(self, messages: tuple[HTTPResponseStartEvent, HTTPResponseBodyEvent]) -> dict[str, str]:\n        \"\"\"Extract headers from a ``Message``\n\n        Args:\n            messages: A tuple containing\n                :class:`HTTPResponseStartEvent <litestar.types.asgi_types.HTTPResponseStartEvent>`\n                and :class:`HTTPResponseBodyEvent <litestar.types.asgi_types.HTTPResponseBodyEvent>`.\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    @classmethod\n    def from_signature(cls, signature: Signature, fn_type_hints: dict[str, type]) -> Self:\n        \"\"\"Parse an :class:`inspect.Signature` instance.\n\n        Args:\n            signature: An :class:`inspect.Signature` instance.\n            fn_type_hints: mapping of types\n\n        Returns:\n            ParsedSignature\n        \"\"\"\n\n\n------------------------------\n------------------------------\n    :class:`Scope <.types.Scope>`\n    \"\"\"\n\n    def __init__(self, scope: Optional[\"HeaderScope\"] = None) -> None:\n        \"\"\"Initialize ``MutableScopeHeaders`` from a ``HeaderScope``.\n\n        Args:\n            scope: The ASGI connection scope.\n        \"\"\"\n        self.headers: RawHeadersList\n        if scope is not None:\n            if not isinstance(scope[\"headers\"], list):\n                scope[\"headers\"] = list(scope[\"headers\"])\n\n            self.headers = cast(\"RawHeadersList\", scope[\"headers\"])\n        else:\n            self.headers = []\n\n    @classmethod\n    def from_message(cls, message: \"Message\") -> \"MutableScopeHeaders\":\n\n------------------------------\n------------------------------\n    def from_components(\n        cls,\n        scheme: str = \"\",\n        netloc: str = \"\",\n        path: str = \"\",\n        fragment: str = \"\",\n        query: str = \"\",\n    ) -> Self:\n        \"\"\"Create a new URL from components.\n\n        Args:\n            scheme: URL scheme\n            netloc: Network location\n            path: Hierarchical path\n            query: Query component\n            fragment: Fragment identifier\n\n        Returns:\n            A new URL with the given components\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_scope(cls, scope: Scope) -> Self:\n# Natural Language Annotations: \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n        Args:\n            scope: A scope\n\n        Returns:\n            A URL\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n```\n", "```python\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n```\n", "```python\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    # Insert your implementation here\n    pass\n```\n"]}, "litestar-litestar/datastructures/headers.py-to_header": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Args:\n            data: Session data of the current scope.\n            scope: A scope, if applicable, from which to extract a serializer.\n\n        Notes:\n            - The serializer will be extracted from ``scope`` or fall back to\n                :func:`default_serializer <.serialization.default_serializer>`\n\n        Returns:\n            ``data`` serialized as bytes.\n        \"\"\"\n        serializer = get_serializer_from_scope(scope) if scope else None\n        return encode_json(data, serializer)\n\n    @staticmethod\n    def deserialize_data(data: Any) -> dict[str, Any]:\n        \"\"\"Deserialize data into a dictionary for use in the application scope.\n\n        Args:\n            data: Data to be deserialized\n\n------------------------------\n------------------------------\n        \"\"\"Return the ``Logger`` instance for this connection.\n\n        Returns:\n            A ``Logger`` instance.\n\n        Raises:\n            ImproperlyConfiguredException: if ``log_config`` has not been passed to the Litestar constructor.\n        \"\"\"\n        return self.app.get_logger()\n\n    def set_session(self, value: dict[str, Any] | DataContainerType | EmptyType) -> None:\n        \"\"\"Set the session in the connection's ``Scope``.\n\n        If the :class:`SessionMiddleware <.middleware.session.base.SessionMiddleware>` is enabled, the session will be added\n        to the response as a cookie header.\n\n        Args:\n            value: Dictionary or pydantic model instance for the session data.\n\n        Returns:\n\n------------------------------\n------------------------------\n            item_id: Identifier of the instance to be retrieved.\n            **kwargs: Additional arguments\n\n        Returns:\n            The retrieved instance.\n\n        Raises:\n            NotFoundError: If no instance found identified by ``item_id``.\n        \"\"\"\n\n    @abstractmethod\n    def get_one(self, **kwargs: Any) -> T:\n        \"\"\"Get an instance specified by the ``kwargs`` filters if it exists.\n\n        Args:\n            **kwargs: Instance attribute value filters.\n\n        Returns:\n            The retrieved instance.\n\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_all(self) -> None:\n        \"\"\"Delete all stored values.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def exists(self, key: str) -> bool:\n        \"\"\"Check if a given ``key`` exists.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def expires_in(self, key: str) -> int | None:\n        \"\"\"Get the time in seconds ``key`` expires in. If no such ``key`` exists or no\n        expiry time was set, return ``None``.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_header(self, include_header_name: bool = False) -> str:\n# Natural Language Annotations: \"\"\"Get the header as string.\n\n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    if include_header_name:\n        return f\"{self.header_name}: {self.header_value}\"\n    else:\n        return self.header_value\n```\n", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    if include_header_name:\n        return f\"{self.header_name}: {self.value}\"\n    else:\n        return self.value\n```\n", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    header_value = self.get_header_value()\n    if include_header_name:\n        header_name = self.get_header_name()\n        return f\"{header_name}: {header_value}\"\n    else:\n        return header_value\n```\n"]}, "litestar-litestar/middleware/session/server_side.py-delete": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete_all(self) -> None:\n        \"\"\"Delete all stored values.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def exists(self, key: str) -> bool:\n        \"\"\"Check if a given ``key`` exists.\"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def expires_in(self, key: str) -> int | None:\n        \"\"\"Get the time in seconds ``key`` expires in. If no such ``key`` exists or no\n        expiry time was set, return ``None``.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n        Args:\n            media_type: The media type to check for.\n\n        Returns:\n            True if the request accepts ``media_type``.\n        \"\"\"\n        return self.best_match([media_type]) == media_type\n\n------------------------------\n------------------------------\n            The session data, if existing, otherwise ``None``.\n        \"\"\"\n        max_age = int(self.config.max_age) if self.config.max_age is not None else None\n        return await store.get(session_id, renew_for=max_age if self.config.renew_on_access else None)\n\n    async def set(self, session_id: str, data: bytes, store: Store) -> None:\n        \"\"\"Store ``data`` under the ``session_id`` for later retrieval.\n\n        If there is already data associated with ``session_id``, replace\n        it with ``data`` and reset its expiry time\n\n        Args:\n            session_id: The session-ID\n            data: Serialized session data\n            store: Store to save the session data in\n\n        Returns:\n            None\n        \"\"\"\n        expires_in = int(self.config.max_age) if self.config.max_age is not None else None\n\n------------------------------\n------------------------------\n        \"\"\"Initialize ``ServerSideSessionBackend``\n\n        Args:\n            config: A subclass of ``ServerSideSessionConfig``\n        \"\"\"\n        super().__init__(config=config)\n\n    async def get(self, session_id: str, store: Store) -> bytes | None:\n        \"\"\"Retrieve data associated with ``session_id``.\n\n        Args:\n            session_id: The session-ID\n            store: Store to retrieve the session data from\n\n        Returns:\n            The session data, if existing, otherwise ``None``.\n        \"\"\"\n        max_age = int(self.config.max_age) if self.config.max_age is not None else None\n        return await store.get(session_id, renew_for=max_age if self.config.renew_on_access else None)\n\n\n------------------------------\n------------------------------\n                expiry time for ``renew_for`` seconds. If the value has not been set\n                with an expiry time this is a no-op\n\n        Returns:\n            The value associated with ``key`` if it exists and is not expired, else\n            ``None``\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    async def delete(self, key: str) -> None:\n        \"\"\"Delete a value.\n\n        If no such key exists, this is a no-op.\n\n        Args:\n            key: Key of the value to delete\n        \"\"\"\n        raise NotImplementedError\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def delete(self, session_id: str, store: Store) -> None:\n# Natural Language Annotations: \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n        Args:\n            session_id: The session-ID\n            store: Store to delete the session data from\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    if await store.exists(session_id):\n        await store.delete(session_id)\n```\n", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    if await store.exists(session_id):\n        await store.delete(session_id)\n```\n", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    try:\n        await store.delete(session_id)\n    except Exception:\n        pass\n```\n"]}, "marimo-marimo/_islands/island_generator.py-add_code": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n\n    Attributes:\n        source (str): The source of the data table.\n        name (str): The name of the data table.\n        num_rows (Optional[int]): The number of rows in the data table.\n        num_columns (Optional[int]): The number of columns in the data table.\n        variable_name (Optional[str]): The variable name associated with\n        the data table.\n        columns (List[DataTableColumn]): The list of columns in the data table.\n    \"\"\"\n\n    source: str\n    name: str\n    num_rows: Optional[int]\n    num_columns: Optional[int]\n    variable_name: Optional[str]\n    columns: List[DataTableColumn]\n\n------------------------------\n------------------------------\nclass DataTableColumn:\n    \"\"\"\n    Represents a column in a data table.\n\n    Attributes:\n        name (str): The name of the column.\n        type (DataType): The data type of the column.\n    \"\"\"\n\n    name: str\n    type: DataType\n    external_type: ExternalDataType\n\n\n@dataclass\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n\n    Attributes:\n\n------------------------------\n------------------------------\n\n    @staticmethod\n    def from_file(\n        filename: str,\n        display_code: bool = False,\n    ) -> MarimoIslandGenerator:\n        \"\"\"\n        Create a MarimoIslandGenerator and populate MarimoIslandStubs\n        using code cells from a marimo *.py file.\n\n        *Args:*\n\n        - filename (str): Marimo .py filename to convert to reactive HTML.\n        - display_code (bool): Whether to display the code in HTML snippets.\n        \"\"\"\n        path = MarimoPath(filename)\n        file_router = AppFileRouter.from_filename(path)\n        file_key = file_router.get_unique_file_key()\n        assert file_key is not None\n        file_manager = file_router.get_file_manager(file_key)\n\n------------------------------\n------------------------------\n    def code(self) -> str:\n        return self._code\n\n    def render(\n        self,\n        display_code: Optional[bool] = None,\n        display_output: Optional[bool] = None,\n        is_reactive: Optional[bool] = None,\n    ) -> str:\n        \"\"\"\n        Render the HTML island code for the cell.\n        Note: This will override construction defaults.\n\n        *Args:*\n\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n------------------------------\n------------------------------\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n        - str: The HTML code.\n        \"\"\"\n\n        is_reactive = (\n            is_reactive if is_reactive is not None else self._is_reactive\n        )\n        display_code = (\n            display_code if display_code is not None else self._display_code\n        )\n        display_output = (\n            display_output\n            if display_output is not None\n            else self._display_output\n        )\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_code(\n# Natural Language Annotations: \"\"\"Add a code cell to the app.\n\n        *Args:*\n\n        - code (str): The code to add to the app.\n        - display_code (bool): Whether to display the code in the HTML.\n        - display_output (bool): Whether to display the output in the HTML.\n        - is_raw (bool): Whether to handled the code without formatting.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_code(\n    code: str,\n    display_code: bool = False,\n    display_output: bool = False,\n    is_raw: bool = False,\n    is_reactive: bool = False,\n) -> None:\n    \"\"\"\n    Add a code cell to the app.\n\n    *Args:*\n\n    - code (str): The code to add to the app.\n    - display_code (bool): Whether to display the code in the HTML.\n    - display_output (bool): Whether to display the output in the HTML.\n    - is_raw (bool): Whether to handled the code without formatting.\n    - is_reactive (bool): Whether this code block will run with pyodide.\n    \"\"\"\n    # Your code here\n```\n", "```python\ndef add_code(\n    code: str,\n    display_code: bool = True,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = True,\n):\n    \"\"\"\n    Add a code cell to the app.\n\n    *Args:*\n\n    - code (str): The code to add to the app.\n    - display_code (bool): Whether to display the code in the HTML.\n    - display_output (bool): Whether to display the output in the HTML.\n    - is_raw (bool): Whether to handled the code without formatting.\n    - is_reactive (bool): Whether this code block will run with pyodide.\n    \"\"\"\n    # TODO: Implement the function\n```\n", "```python\ndef add_code(\n    self,\n    code: str,\n    display_code: Optional[bool] = None,\n    display_output: Optional[bool] = None,\n    is_raw: Optional[bool] = None,\n    is_reactive: Optional[bool] = None,\n):\n    \"\"\"Add a code cell to the app.\n\n    *Args:*\n\n    - code (str): The code to add to the app.\n    - display_code (bool): Whether to display the code in the HTML.\n    - display_output (bool): Whether to display the output in the HTML.\n    - is_raw (bool): Whether to handled the code without formatting.\n    - is_reactive (bool): Whether this code block will run with pyodide.\n    \"\"\"\n    if display_code is None:\n        display_code = self._display_code\n    if display_output is None:\n        display_output = self._display_output\n    if is_raw is None:\n        is_raw = self._is_raw\n    if is_reactive is None:\n        is_reactive = self._is_reactive\n\n    # add code logic here\n```\n"]}, "marimo-marimo/_islands/island_generator.py-build": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    mo.accordion(\n        {\n            \"Tip: hide this tutorial's code\": (\n            \"\"\"\n            Click the app window icon in the bottom-left to hide this app's code,\n            or use the \"fold code\" shortcut to fold all code cells.\n            \"\"\"\n            )\n        }\n    )\n    return\n\n\n@app.cell(hide_code=True)\ndef __(example_program, mo):\n    mo.md(example_program)\n    return\n\n\n@app.cell(hide_code=True)\n\n------------------------------\n------------------------------\n        version_override: str = __version__,\n        _development_url: Union[str | bool] = False,\n    ) -> str:\n        \"\"\"\n        Render the header for the app.\n        This should be included in the <head> tag of the page.\n\n        *Args:*\n\n        - version_override (str): Marimo version to use for loaded js/css.\n        - _development_url (str): If True, uses local marimo islands js.\n        \"\"\"\n\n        # This loads:\n        # - The marimo islands js\n        # - The marimo islands css\n        # - Preconnects to Google Fonts (https://stackoverflow.com/questions/73838138)\n        # - Fonts from Google Fonts\n        #   (otherwise they would get bundled in the css)\n        # - Fonts from KaTeX\n\n------------------------------\n------------------------------\n        include_init_island: bool = True,\n        max_width: Optional[str] = None,\n        margin: Optional[str] = None,\n        style: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Render the body for the app.\n        This should be included in the <body> tag of the page.\n\n        *Args:*\n        - include_init_island (bool): If True, adds initialization loader.\n        - max_width (str): CSS style max_width property.\n        - margin (str): CSS style margin property.\n        - style (str): CSS style. Overrides max_width and margin.\n        \"\"\"\n\n        rendered_stubs = []\n        for stub in self._stubs:\n            rendered_stubs.append(stub.render())\n\n\n------------------------------\n------------------------------\n    def code(self) -> str:\n        return self._code\n\n    def render(\n        self,\n        display_code: Optional[bool] = None,\n        display_output: Optional[bool] = None,\n        is_reactive: Optional[bool] = None,\n    ) -> str:\n        \"\"\"\n        Render the HTML island code for the cell.\n        Note: This will override construction defaults.\n\n        *Args:*\n\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n------------------------------\n------------------------------\n        - display_code (bool): Whether to display the code in HTML.\n        - display_output (bool): Whether to include the output in the HTML.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n\n        *Returns:*\n\n        - str: The HTML code.\n        \"\"\"\n\n        is_reactive = (\n            is_reactive if is_reactive is not None else self._is_reactive\n        )\n        display_code = (\n            display_code if display_code is not None else self._display_code\n        )\n        display_output = (\n            display_output\n            if display_output is not None\n            else self._display_output\n        )\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def build(self) -> App:\n# Natural Language Annotations: \"\"\"\n        Build the app. This should be called after adding all the code cells.\n\n        *Returns:*\n\n        - App: The built app.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n```\n", "```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n    pass\n```\n", "```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n    # Your code implementation here\n```\n"]}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    name: str\n    num_rows: Optional[int]\n    num_columns: Optional[int]\n    variable_name: Optional[str]\n    columns: List[DataTableColumn]\n\n\nNumericLiteral = Union[int, float, Decimal]\nTemporalLiteral = Union[date, time, datetime, timedelta]\nNonNestedLiteral = Union[NumericLiteral, TemporalLiteral, str, bool, bytes]\n\n\n@dataclass\nclass ColumnSummary:\n    \"\"\"\n    Represents a summary of a column in a data table.\n\n    \"\"\"\n\n    total: Optional[int] = None\n\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\n\"\"\"Specification of a code completion result\"\"\"\n\nfrom __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import Optional\n\n\n@dataclass\nclass CompletionOption:\n    # completed symbol name\n    name: str\n    # type of symbol\n    type: str\n    # docstring, type hint, or other info\n    completion_info: Optional[str]\n\n------------------------------\n------------------------------\n    is_marimo_file: bool\n    last_modified: Optional[float] = None\n    children: List[\"FileInfo\"] = field(default_factory=list)\n\n\n@dataclass\nclass FileListRequest:\n    # The directory path to list files from\n    # If None, the root directory will be used\n    path: Optional[str] = None\n\n\n@dataclass\nclass FileDetailsRequest:\n    # The path of the file or directory\n    path: str\n\n\n@dataclass\nclass FileOpenRequest:\n\n------------------------------\n------------------------------\nclass DataTableColumn:\n    \"\"\"\n    Represents a column in a data table.\n\n    Attributes:\n        name (str): The name of the column.\n        type (DataType): The data type of the column.\n    \"\"\"\n\n    name: str\n    type: DataType\n    external_type: ExternalDataType\n\n\n@dataclass\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n\n    Attributes:\n\n------------------------------\n------------------------------\n@app.cell\ndef __():\n    from dataclasses import dataclass\n    return dataclass,\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\n    return cls(**values)\n```\n", "```python\nfrom typing import TypeVar, Type, Any, Dict\n\nT = TypeVar('T')\n\ndef build_dataclass(values: Dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\n    field_names = set(f.name for f in dataclasses.fields(cls))\n    filtered_values = {k: v for k, v in values.items() if k in field_names}\n    return cls(**filtered_values)\n```\n", "```python\nfrom typing import Any, TypeVar, Type\n\nT = TypeVar('T')\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\n    field_names = set(f.name for f in dataclasses.fields(cls))\n    data = {k: v for k, v in values.items() if k in field_names}\n    return cls(**data)\n```\n"]}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\ndef csv(data: Union[str, bytes, io.BytesIO]) -> VirtualFile:\n    \"\"\"Create a virtual file for CSV data.\n\n    **Args.**\n\n    - data: CSV data in bytes, or string representing a data URL, external URL\n        or a Pandas DataFrame\n\n    **Returns.**\n\n    A `VirtualFile` object.\n    \"\"\"\n    return any_data(data, ext=\"csv\")  # type: ignore\n\n\ndef json(data: Union[str, bytes, io.BytesIO]) -> VirtualFile:\n    \"\"\"Create a virtual file for JSON data.\n\n    **Args.**\n\n------------------------------\n------------------------------\ndef forward_os_stream(stream_object: Stdout | Stderr, fd: int) -> None:\n    while True:\n        data = os.read(fd, 1024)\n        if not data:\n            break\n        stream_object.write(data.decode())\n\n\ndef dup2newfd(fd: int) -> tuple[int, int, int]:\n    \"\"\"Create a pipe, with `fd` at the write end of it.\n\n    Returns\n    - duplicate (os.dup) of `fd`\n    - read end of pipe\n    - fd (which now points to the file referenced by the write end of the pipe)\n\n    When done with the pipe, the write-end of the pipe should be closed\n    and remapped to point to the saved duplicate. The read end should\n    also be closed, as should the saved duplicate.\n    \"\"\"\n\n------------------------------\n------------------------------\n    # type of layout\n    type: str\n    # data for layout\n    data: dict[str, Any]\n\n\ndef save_layout_config(\n    directory: str, app_name: str, config: LayoutConfig\n) -> str:\n    \"\"\"\n    Save the layout configuration to disk\n    at the given directory.\n\n    The layout is saved as a JSON file under\n        <directory>/layouts/<app_name>.{type}.json\n    This allows:\n        - all layouts to be saved in the same directory\n        - multiple layouts to be saved for the same app\n        - multiple apps can live in the same directory\n\n\n------------------------------\n------------------------------\n\n# TODO still needed?\ndef require_header(header: list[str] | None) -> str:\n    \"\"\"\n    Require exactly one value in header and return it.\n    \"\"\"\n\n    if header is None:\n        raise ValueError(\"Expected exactly one value in header, got None\")\n    if len(header) != 1:\n        raise ValueError(\n            \"Expected exactly one value in header, \"\n            f\"got {len(header)} values: {header}\"\n        )\n    return header[0]\n\n\nasync def parse_request(request: Request, cls: Type[T]) -> T:\n    \"\"\"Parse the request body as a dataclass of type `cls`\"\"\"\n    return parse_raw(await request.body(), cls=cls)\n\n------------------------------\n------------------------------\n#     \"field2\": \"value2\",\n#   }[],\n#   \"range\": {\n#     \"field1\": [min, max],\n#     \"field2\": [min, max],\n#   },\n#  \"indices\": int[],\n# }\nPlotlySelection = Dict[str, JSONType]\n\n\n@mddoc\nclass plotly(UIElement[PlotlySelection, List[Dict[str, Any]]]):\n    \"\"\"Make reactive plots with Plotly.\n\n    Use `mo.ui.plotly` to make plotly plots reactive: select data\n    with your cursor on the frontend, get them as a list of dicts in Python!\n\n    **Example.**\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport json\nfrom typing import Any, Dict, List, Tuple, Set, Type, Union\n\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[T]) -> T:\n    # If the message is a bytes object, decode it to a dictionary\n    if isinstance(message, bytes):\n        message = json.loads(message.decode('utf-8'))\n\n    # Transform all fields in the parsed JSON from camel case to snake case\n    transformed_message = _transform_keys(message)\n\n    # Instantiate the dataclass\n    return cls(**transformed_message)\n\ndef _transform_keys(obj: Union[Dict[str, Any], List[Any]]) -> Dict[str, Any]:\n    if isinstance(obj, dict):\n        return {\n            _camel_to_snake(key): _transform_keys(value)\n            for key, value in obj.items()\n        }\n    elif isinstance(obj, list):\n        return [_transform_keys(value) for value in obj]\n    else:\n        return obj\n\ndef _camel_to_snake(name: str) -> str:\n    import re\n    s1 = re.sub('(.)([A-Z][a-z]+)', r'\\1_\\2', name)\n    return re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', s1).lower()\n```\n------------------------------\n", "```python\nfrom typing import Any, Dict, Type, Union\nimport json\nimport re\n\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[T]) -> T:\n    \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n    if isinstance(message, bytes):\n        message = message.decode('utf-8')\n    data = json.loads(message)\n    data = {re.sub(r'([A-Z]+)', r'_\\1', k).lower(): v for k, v in data.items()}\n    return cls(**data)\n```\n\nPlease note that this function assumes that the dataclass fields match the keys in the JSON message, in camel case. The function also assumes that the dataclass fields are all simple types (integers, strings, etc.), and does not support nested dataclasses or collections of more complex types. For more complex use cases, you may need to modify the function or use a more sophisticated library.\n", "```python\nfrom dataclasses import asdict\nfrom typing import Any, Type, TypeVar, Union\nimport json\nimport re\n\nT = TypeVar(\"T\")\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n    if isinstance(message, bytes):\n        message = json.loads(message.decode())\n\n    snake_case_message = {\n        re.sub(r\"(?<=[a-z])(?=[A-Z])\", \"_\", k).lower(): v\n        for k, v in message.items()\n    }\n\n    return cls(**snake_case_message)\n```\n\nThis function parses a JSON message and instantiates it into the supplied type `cls`. It follows the convention that dataclasses must be used and supports List, Tuple, Set, and Dict collections. It also handles converting fields from camel case to snake case.\n"]}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    ```python3\n    # Build a grid.\n    mo.vstack(\n        [\n            mo.hstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.hstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `align`: Align items horizontally: start, end, center, or stretch.\n    - `justify`: Justify items vertically: start, center, end,\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `heights`: \"equal\" to give items equal height;\n        or a list of relative heights with same length as `items`,\n        eg, [1, 2] means the second item is twice as tall\n        as the first; or `None` for a sensible default\n\n------------------------------\n------------------------------\n    mo.hstack(\n        [\n            mo.md(\"Rotate\"),\n            mo.icon(\"lucide:leaf\", size=20),\n            mo.icon(\"lucide:leaf\", size=20, rotate=\"90deg\"),\n            mo.icon(\"lucide:leaf\", size=20, rotate=\"180deg\"),\n            mo.icon(\"lucide:leaf\", size=20, rotate=\"270deg\"),\n        ],\n        justify=\"start\",\n    )\n    return\n\n\n@app.cell\ndef __(mo):\n    mo.hstack(\n        [\n            mo.md(\"In buttons\"),\n            mo.ui.button(\n                label=f\"{mo.icon('material-symbols:rocket-launch')} Launch\"\n\n------------------------------\n------------------------------\n    ```\n\n    where `expensive_item` is the item to render, or a callable that\n    returns the item to render.\n\n    **Args.**\n\n    - `items`: a dictionary of item names to item content; strings are\n      interpreted as markdown\n    - `multiple`: whether to allow multiple items to be open simultaneously\n    - `lazy`: a boolean, whether to lazily load the accordion content.\n              This is a convenience that wraps each accordion in a `mo.lazy`\n              component.\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n\n    def render_content(tab: object) -> str:\n\n------------------------------\n------------------------------\n    ```python\n    tabs = mo.ui.tabs(\n        {\"Heading 1\": tab1, \"Heading 2\": expensive_component}, lazy=True\n    )\n    ```\n\n    **Attributes.**\n\n    - `value`: A string, the name of the selected tab.\n\n    **Initialization Args.**\n\n    - `tabs`: a dictionary of tab names to tab content; strings are interpreted\n              as markdown\n    - `value`: the name of the tab to open; defaults to the first tab\n    - `lazy`: a boolean, whether to lazily load the tab content.\n              This is a convenience that wraps each tab in a `mo.lazy`\n              component.\n    \"\"\"\n\n\n------------------------------\n------------------------------\n    \"\"\"\n    Displays content in a sidebar. This is a special layout component that\n    will display the content in a sidebar layout, rather than below/above\n    the cell.\n\n    This component still needs to be the last expression in the cell,\n    in order to display correctly.\n\n    You may use more than one `mo.sidebar` - they will be displayed in the\n    order they are called.\n\n    **Examples.**\n\n    ```python\n    mo.sidebar(\n        [\n            mo.md(\"# marimo\"),\n            mo.nav_menu(\n                {\n                    \"#home\": f\"{mo.icon('lucide:home')} Home\",\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def icon(\n# Natural Language Annotations: \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python3\ndef icon(icon_name, size=None, color=None, inline=False, flip=None, rotate=None, style=None):\n    \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n```\n", "```python\ndef icon(icon_name: str, size: int = 24, color: str = \"inherit\", inline: bool = False, flip: str = None, rotate: str = None, style: dict = None):\n    # Your function implementation here\n    pass\n```\n", "Based on your request, here is a function based on the function signature and natural language annotations:\n\n```python\ndef icon(icon_name, size=None, color=None, inline=None, flip=None, rotate=None, style=None):\n    \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    # Function implementation goes here\n```\n\nPlease note that this is just a skeleton and does not include the actual implementation. The actual implementation would depend on the specific library or framework you are using for this project.\n"]}, "marimo-marimo/_plugins/stateless/image.py-image": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        only works if `src` is a URL\n    - `width`: the width of the pdf\n    - `height`: the height of the pdf. for a percentage\n        of the user's viewport, use a string like `\"50vh\"`\n    - `style`: a dictionary of CSS styles to apply to the pdf\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\n    resolved_src = src if isinstance(src, str) else mo_data.pdf(src.read()).url\n    if initial_page is not None and isinstance(src, str):\n        # FitV is \"fit to vertical\"\n        resolved_src += f\"#page={initial_page}&view=FitV\"\n    styles = create_style(\n        {\n            \"border-radius\": \"4px\",\n            \"width\": width,\n            \"height\": height,\n            **(style or {}),\n\n------------------------------\n------------------------------\n\n    ```python\n    download_txt = mo.download(\n        data=\"Hello, world!\".encode(\"utf-8\"),\n        filename=\"hello.txt\",\n        mimetype=\"text/plain\",\n    )\n\n    download_image = mo.download(\n        data=open(\"hello.png\", \"rb\"),\n    )\n    ```\n\n    **Args.**\n\n    - `data`: The data to download. Can be a string (interpreted as\n        a URL), bytes, or a file opened in binary mode.\n    - `filename`: The name of the file to download.\n        If not provided, the name will be guessed from the data.\n    - `mimetype`: The mimetype of the file to download, for example,\n\n------------------------------\n------------------------------\n        src=\"https://v3.cdnpk.net/videvo_files/video/free/2013-08/large_watermarked/hd0992_preview.mp4\",\n        controls=False,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: the URL of the video or a file-like object\n    - `controls`: whether to show the controls\n    - `muted`: whether to mute the video\n    - `autoplay`: whether to autoplay the video.\n        the video will only autoplay if `muted` is `True`\n    - `loop`: whether to loop the video\n    - `width`: the width of the video\n    - `height`: the height of the video\n    - `rounded`: whether to round the corners of the video\n\n    **Returns.**\n\n    `Html` object\n\n------------------------------\n------------------------------\ndef audio(\n    src: Union[str, io.BytesIO],\n) -> Html:\n    \"\"\"Render an audio file as HTML.\n\n    **Example.**\n\n    ```python3\n    mo.audio(\n        src=\"https://upload.wikimedia.org/wikipedia/commons/8/8c/Ivan_Ili%C4%87-Chopin_-_Prelude_no._1_in_C_major.ogg\"\n    )\n\n    mo.audio(src=\"path/to/local/file.wav\")\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an audio file, bytes,\n        or a file-like object opened in binary mode\n\n\n------------------------------\n------------------------------\n    ```python3\n    mo.pdf(\n        src=\"https://arxiv.org/pdf/2104.00282.pdf\",\n        width=\"100%\",\n        height=\"50vh\",\n    )\n\n    with open(\"paper.pdf\", \"rb\") as file:\n        mo.pdf(src=file)\n    ```\n\n    **Args.**\n\n    - `src`: the URL of the pdf or a file-like object\n    - `initial_page`: the page to open the pdf to.\n        only works if `src` is a URL\n    - `width`: the width of the pdf\n    - `height`: the height of the pdf. for a percentage\n        of the user's viewport, use a string like `\"50vh\"`\n    - `style`: a dictionary of CSS styles to apply to the pdf\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def image(\n# Natural Language Annotations: \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef image(\n    src: Union[str, io.BytesIO],\n    alt: Optional[str] = None,\n    width: Optional[Union[int, str]] = None,\n    height: Optional[Union[int, str]] = None,\n    rounded: bool = False,\n    style: Optional[Dict[str, str]] = None,\n) -> Html:\n    \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\n```\n", "```python\ndef image(\n    src: Union[str, io.BytesIO, np.ndarray],\n    alt: str = \"\",\n    width: int = None,\n    height: int = None,\n    rounded: bool = False,\n    style: dict = None,\n) -> Html:\n    \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\n```\n", "```python\ndef image(\n    src: Union[str, io.BytesIO, Iterable],\n    alt: Optional[str] = None,\n    width: Optional[Union[int, str]] = None,\n    height: Optional[Union[int, str]] = None,\n    rounded: Optional[bool] = False,\n    style: Optional[Dict[str, str]] = None,\n) -> Html:\n    \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\n```\n"]}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    items_per_row: Optional[int] = None,\n    column_gap: float = 1,\n    row_gap: float = 1,\n) -> Html:\n    \"\"\"Space items evenly in row-major order.\n\n    A grid built with this function has a fixed number of items per row.\n    For more flexibility, use `hstack` and `vstack`.\n\n    **Args.**\n\n    - `items`: Items to arrange\n    - `justify`: Justify items normally, left, right, or center.\n    - `items_per_row`: Number of items to place in each row\n    - `column_gap`: Minimum gap in rem between columns\n    - `row_gap`: Minimum gap in rem between rows\n\n    **Returns.**\n\n    - An `Html` object.\n\n------------------------------\n------------------------------\n) -> Html:\n    \"\"\"Create a carousel of items.\n\n    **Example.**\n\n    ```python3\n    mo.carousel([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    item_content = \"\".join(\n        [\n            (md(item).text if isinstance(item, str) else as_html(item).text)\n\n------------------------------\n------------------------------\n    ] = \"start\",\n    gap: float = 0.5,\n    heights: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items vertically, in a column.\n\n    Combine with `hstack` to build a grid of items.\n\n    **Example.**\n\n    ```python3\n    # Build a column of items\n    mo.vstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.vstack(\n        [\n            mo.hstack([mo.md(\"...\"), mo.ui.text_area()]),\n\n------------------------------\n------------------------------\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `heights`: \"equal\" to give items equal height;\n        or a list of relative heights with same length as `items`,\n        eg, [1, 2] means the second item is twice as tall\n        as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return _flex(\n        items,\n        direction=\"column\",\n        justify=justify,\n        align=align,\n        wrap=False,\n        gap=gap,\n        child_flexes=[1 for _ in range(len(items))]\n        if heights == \"equal\"\n        else heights,\n\n------------------------------\n------------------------------\n    ```python3\n    # Build a grid.\n    mo.vstack(\n        [\n            mo.hstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.hstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `align`: Align items horizontally: start, end, center, or stretch.\n    - `justify`: Justify items vertically: start, center, end,\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `heights`: \"equal\" to give items equal height;\n        or a list of relative heights with same length as `items`,\n        eg, [1, 2] means the second item is twice as tall\n        as the first; or `None` for a sensible default\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def hstack(\n# Natural Language Annotations: \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python3\ndef hstack(\n    items: Sequence[Union[Html, str]],\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Literal[\"start\", \"end\", \"center\", \"stretch\"] = \"stretch\",\n    wrap: bool = True,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return _flex(\n        items,\n        direction=\"row\",\n        justify=justify,\n        align=align,\n        wrap=wrap,\n        gap=gap,\n        child_flexes=[1 for _ in range(len(items))]\n        if widths == \"equal\"\n        else widths,\n    )\n```\n", "```python3\ndef hstack(\n    items: Sequence[Any],\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Literal[\"start\", \"end\", \"center\", \"stretch\"] = \"center\",\n    wrap: bool = True,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return _flex(\n        items,\n        direction=\"row\",\n        justify=justify,\n        align=align,\n        wrap=wrap,\n        gap=gap,\n        child_flexes=[1 for _ in range(len(items))]\n        if widths == \"equal\"\n        else widths,\n    )\n```\n", "```python\ndef hstack(\n    items: List[Union[Element, str]],\n    justify: Literal[\"start\", \"center\", \"end\", \"space-between\", \"space-around\"] = \"start\",\n    align: Literal[\"start\", \"end\", \"center\", \"stretch\"] = \"stretch\",\n    wrap: bool = True,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return _flex(\n        items,\n        direction=\"row\",\n        justify=justify,\n        align=align,\n        wrap=wrap,\n        gap=gap,\n        child_flexes=[1 for _ in range(len(items))]\n        if widths == \"equal\"\n        else widths,\n    )\n```\n"]}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            title=title,\n            subtitle=subtitle,\n            total=None,\n            show_rate=False,\n            show_eta=False,\n        )\n\n    def update(\n        self, title: str | None = None, subtitle: str | None = None\n    ) -> None:\n        \"\"\"Update the title and subtitle of the spinner\n\n        This method updates a spinner output in-place. Must be used\n        in the cell the spinner was created.\n\n        **Example.**\n\n        ```python\n        with mo.status.spinner(\"Hang tight!\") as _spinner:\n            ...\n\n------------------------------\n------------------------------\n\n    The interactive viewer allows you to pan, zoom, and see plot coordinates\n    on mouse hover.\n\n    **Example**:\n\n    ```python\n    plt.plot([1, 2])\n    # plt.gcf() gets the current figure\n    mo.mpl.interactive(plt.gcf())\n    ```\n\n    **Args**:\n\n    - figure: a matplotlib `Figure` or `Axes` object\n\n    **Returns**:\n\n    - An interactive matplotlib figure as an `Html` object\n    \"\"\"\n\n------------------------------\n------------------------------\n        **Example.**\n\n        ```python\n        with mo.status.spinner(\"Hang tight!\") as _spinner:\n            ...\n            _spinner.update(title=\"Almost done!\")\n        # Optionally, remove the spinner from the output\n        # _spinner.clear()\n        ```\n        \"\"\"\n        super().update_progress(increment=1, title=title, subtitle=subtitle)\n\n\n@mddoc\nclass spinner:\n    \"\"\"Show a loading spinner\n\n    Use `mo.status.spinner()` as a context manager to show a loading spinner.\n    You can optionally pass a title and subtitle.\n\n\n------------------------------\n------------------------------\n    \"\"\"Show a loading spinner\n\n    Use `mo.status.spinner()` as a context manager to show a loading spinner.\n    You can optionally pass a title and subtitle.\n\n    **Example.**\n\n    ```python\n    with mo.status.spinner(subtitle=\"Loading data ...\") as _spinner:\n        data = expensive_function()\n        _spinner.update(subtitle=\"Crunching numbers ...\")\n        ...\n\n    mo.ui.table(data)\n    ```\n\n    You can also show the spinner without a context manager:\n\n    ```python\n    mo.status.spinner(title=\"Loading ...\") if condition else mo.md(\"Done!\")\n\n------------------------------\n------------------------------\n\n    **Example.**\n\n    ```python\n    # a button that when clicked will have its value set to True;\n    # any cells referencing that button will automatically run.\n    button = mo.ui.run_button()\n    button\n    ```\n\n    ```python\n    slider = mo.ui.slider(1, 10)\n    slider\n    ```\n\n    ```python\n    # if the button hasn't been clicked, don't run.\n    mo.stop(not button.value)\n\n    slider.value\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def update_progress(\n# Natural Language Annotations: \"\"\"Update the progress indicator.\n\n        **Example.**\n\n        ```python\n        # Increment by 1\n        progress.update()\n\n        # Increment by 10 and update title and subtitle\n        progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n        ```\n\n        **Args.**\n\n        - increment: amount to increment by. Defaults to 1.\n        - title: new title. Defaults to None.\n        - subtitle: new subtitle. Defaults to None.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef update_progress(self, increment: int = 1, title: str | None = None, subtitle: str | None = None) -> None:\n    \"\"\"Update the progress indicator.\n\n    **Example.**\n\n    ```python\n    # Increment by 1\n    progress.update()\n\n    # Increment by 10 and update title and subtitle\n    progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    **Args.**\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    super().update_progress(increment=increment, title=title, subtitle=subtitle)\n```\n", "```python\ndef update_progress(self, increment: int = 1, title: str | None = None, subtitle: str | None = None) -> None:\n    \"\"\"Update the progress indicator.\n\n    **Example.**\n\n    ```python\n    # Increment by 1\n    progress.update()\n\n    # Increment by 10 and update title and subtitle\n    progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    **Args.**\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    super().update_progress(increment=increment, title=title, subtitle=subtitle)\n```\n", "```python\ndef update_progress(self, increment: int = 1, title: str | None = None, subtitle: str | None = None) -> None:\n    \"\"\"Update the progress indicator.\n\n    Example.\n\n    ```python\n    # Increment by 1\n    progress.update()\n\n    # Increment by 10 and update title and subtitle\n    progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    Args.\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    super().update_progress(increment=increment, title=title, subtitle=subtitle)\n```\n"]}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    name: optional text label\n\n    Returns:\n    --------\n    A string of HTML for a JSON output element.\n    \"\"\"\n    return Html(\n        build_stateless_plugin(\n            component_name=\"marimo-json-output\",\n            args=(\n                {\"json-data\": json_data, \"name\": name}\n                if name is not None\n                else {\"json-data\": json_data}\n            ),\n        )\n    )\n\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nfrom typing import Optional\n\nfrom marimo._output.hypertext import Html\nfrom marimo._plugins.core.web_component import JSONType, build_stateless_plugin\n\n\ndef json_output(json_data: JSONType, name: Optional[str] = None) -> Html:\n    \"\"\"Build a json output element.\n\n    Args:\n    -----\n    json_data: JSON-serializable data to display\n    name: optional text label\n\n    Returns:\n    --------\n    A string of HTML for a JSON output element.\n\n------------------------------\n------------------------------\n    ) -> None:\n        \"\"\"Initialize a UIElement\n\n        Args:\n        ----\n        component_name: tag name of the custom element\n        initial_value: initial value of the element in the frontend\n        label: markdown string, label of element\n        on_change: callback, called with element's new value on change\n        args: arguments that the element takes\n        slotted_html: any html to slot in the custom element\n        functions: any functions to register with the graph\n        \"\"\"\n        # Validate parameters from a user\n        if not isinstance(component_name, str):\n            raise TypeError(\"component_name must be a string\")\n        if label is not None and not isinstance(label, str):\n            raise TypeError(\"label must be a string or None\")\n        if on_change is not None and not callable(on_change):\n            raise TypeError(\"on_change must be a callable or None\")\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\ndef build_stateless_plugin(\n    component_name: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a stateless plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n\n------------------------------\n------------------------------\n    Build HTML for a stateless plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    return (\n        f\"<{component_name} {' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_ui_plugin(\n# Natural Language Annotations: \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: Optional[str] = None,\n    args: Optional[dict[str, JSONType]] = None,\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    attrs = [_build_attr(\"value\", initial_value)]\n    if label is not None:\n        attrs.append(_build_attr(\"label\", label))\n    if args is not None:\n        attrs.extend([_build_attr(name, value) for name, value in args.items()])\n    return (\n        f\"<{component_name} {' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n```\n", "```python\ndef build_ui_plugin(\n    component_name: str, \n    initial_value: JSONType, \n    label: Optional[str] = None, \n    args: Optional[dict[str, JSONType]] = None, \n    slotted_html: str = \"\"\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    # Initialize the arguments dictionary\n    if args is None:\n        args = {}\n\n    # Add initial value to the arguments\n    args[\"initial-value\"] = initial_value\n\n    # Add label to the arguments\n    if label is not None:\n        args[\"label\"] = label\n\n    # Build the HTML\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    return (\n        f\"<{component_name} {' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n```\n", "```python\ndef build_ui_plugin(\n    component_name: str, \n    initial_value: JSONType, \n    label: Optional[str], \n    args: dict[str, JSONType], \n    slotted_html: str = \"\"\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    attrs.append(_build_attr(\"initial-value\", initial_value))\n    if label is not None:\n        attrs.append(_build_attr(\"label\", label))\n    return (\n        f\"<{component_name} {' '.join(attrs)}>\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n\ndef _build_attr(name: str, value: JSONType) -> str:\n    \"\"\"\n    Build an HTML attribute from a value.\n\n    Args:\n    ----\n    name: attribute name\n    value: JSON-serializable value\n\n    Returns:\n    -------\n    HTML text for the attribute\n    \"\"\"\n    return f'{name}=\"{json.dumps(value)}\"'\n```\n"]}, "marimo-marimo/_output/formatting.py-as_html": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    ```python\n    tabs = mo.ui.tabs(\n        {\"Heading 1\": tab1, \"Heading 2\": expensive_component}, lazy=True\n    )\n    ```\n\n    **Attributes.**\n\n    - `value`: A string, the name of the selected tab.\n\n    **Initialization Args.**\n\n    - `tabs`: a dictionary of tab names to tab content; strings are interpreted\n              as markdown\n    - `value`: the name of the tab to open; defaults to the first tab\n    - `lazy`: a boolean, whether to lazily load the tab content.\n              This is a convenience that wraps each tab in a `mo.lazy`\n              component.\n    \"\"\"\n\n\n------------------------------\n------------------------------\n    tabs = mo.tabs({\n        \"Tab 1\": tab1,\n        \"Tab 2\": tab2\n    })\n    ```\n\n    **Args.**\n\n    - `tabs`: a dictionary of tab names to tab content; strings are interpreted\n    as markdown\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return tabs_impl(tabs)\n\n------------------------------\n------------------------------\n        for f in virtual_filenames:\n            ctx.virtual_file_registry.dereference(f)\n\n\n@mddoc\nclass Html(MIME):\n    \"\"\"A wrapper around HTML text that can be used as an output.\n\n    Output an `Html` object as the last expression of a cell to render it in\n    your app.\n\n    Use f-strings to embed Html objects as text into other HTML or markdown\n    strings. For example:\n\n    ```python3\n    hello_world = Html(\"<h2>Hello, World</h2>\")\n    Html(\n        f'''\n        <h1>Hello, Universe!</h1>\n        {hello_world}\n\n------------------------------\n------------------------------\n) -> Html:\n    \"\"\"Create a carousel of items.\n\n    **Example.**\n\n    ```python3\n    mo.carousel([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    item_content = \"\".join(\n        [\n            (md(item).text if isinstance(item, str) else as_html(item).text)\n\n------------------------------\n------------------------------\n\n    The interactive viewer allows you to pan, zoom, and see plot coordinates\n    on mouse hover.\n\n    **Example**:\n\n    ```python\n    plt.plot([1, 2])\n    # plt.gcf() gets the current figure\n    mo.mpl.interactive(plt.gcf())\n    ```\n\n    **Args**:\n\n    - figure: a matplotlib `Figure` or `Axes` object\n\n    **Returns**:\n\n    - An interactive matplotlib figure as an `Html` object\n    \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def as_html(value: object) -> Html:\n# Natural Language Annotations: \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\"\"\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \"\"\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n```\n", "Here is the requested function:\n\n```python\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    html_str = \"\"\n    if isinstance(value, str):\n        html_str = value\n    elif isinstance(value, Html):\n        html_str = value.text\n    else:\n        raise ValueError(f\"Cannot convert {type(value)} to Html\")\n    return Html(html_str)\n```\n", "Based on the given code snippets and the function signature, here is the requested function:\n\n```python\nfrom mo import Html\nimport matplotlib.pyplot as plt\n\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\"\"\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \"\"\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    if isinstance(value, plt.Axes):\n        from io import BytesIO\n        import base64\n        import matplotlib.pyplot as plt\n        buffer = BytesIO()\n        value.figure.savefig(buffer, format='png')\n        buffer.seek(0)\n        image_png = buffer.getvalue()\n        buffer.close()\n        graphic = base64.b64encode(image_png).decode('utf-8')\n        return Html(f'<img src=\"data:image/png;base64,{graphic}\">')\n    else:\n        return Html(str(value))\n```\n\nThis function checks if the input value is a Matplotlib `Axes` object. If it is, it saves the figure to a buffer, converts it to base64, and then embeds it into an HTML image tag. If the input value is not a Matplotlib `Axes` object, it simply converts the value to a string and returns an `Html` object.\n"]}, "marimo-marimo/_output/md.py-md": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                \"Use `r''` strings to remove the need to escape backslashes\"\n                \" when writing LaTeX.\"\n            )\n        }\n    )\n    return\n\n\n@app.cell(hide_code=True)\ndef __(mo):\n    mo.md(\n        \"\"\"\n        ## Interpolating Python values\n\n        You can interpolate Python values into markdown using\n        `f-strings` and marimo's ` as_html` function. This lets you create \n        markdown whose contents depend on data that changes at runtime.\n\n        Here are some examples.\n        \"\"\"\n\n------------------------------\n------------------------------\n    \"\"\"An executable notebook cell\n\n    A `Cell` object can be executed as a function via its `run()` method, which\n    returns the cell's last expression (output) and a mapping from its defined\n    names to its values.\n\n    Cells can be named via the marimo editor in the browser, or by\n    changing the cell's function name in the notebook file. Named\n    cells can then be executed for use in other notebooks, or to test\n    in unit tests.\n\n    For example:\n\n    ```python\n    from my_notebook import my_cell\n\n    output, definitions = my_cell.run()\n    ```\n\n    See the documentation of `run` for info and examples.\n\n------------------------------\n------------------------------\n    return\n\n\n@app.cell(hide_code=True)\ndef __(mo):\n    mo.md(\n        r\"\"\"\n        Once installed, you can either right-click the **Add Cell** buttons on the left, or click the **Add SQL Cell** at the bottom of the page. This creates a '**SQL**' cell for you, while in reality this is actually Python code.\n\n        For example, since we store marimo files as pure Python files, the translated code looks like:\n\n        ```python\n        output_df = mo.sql(f\"SELECT * FROM my_table LIMIT {max_rows.value}\")\n        ```\n\n        Notice that we have an **`output_df`** variable in the cell. This is a resulting Polars DataFrame (if you have `polars` installed) or a Pandas DataFrame (if you don't). One of them must be installed in order to interact with the SQL result.\n\n        The SQL statement itself is an formatted string (f-string), so this means they can contain any valid Python code, such as the values of UI elements. This means your SQL statement and results can be reactive! \ud83d\ude80\n\n        Let's take a look at a SQL cell. First we will create a dataframe\n\n------------------------------\n------------------------------\n@app.cell\ndef __(create_wrapper, mo):\n    create_wrapper(\n        mo.md(\n            r\"\"\"\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        \"\"\"\n        ),\n        \"latex\",\n    )\n    return\n\n\n@app.cell\ndef __(create_wrapper, file):\n    create_wrapper(\n\n------------------------------\n------------------------------\n        for f in virtual_filenames:\n            ctx.virtual_file_registry.dereference(f)\n\n\n@mddoc\nclass Html(MIME):\n    \"\"\"A wrapper around HTML text that can be used as an output.\n\n    Output an `Html` object as the last expression of a cell to render it in\n    your app.\n\n    Use f-strings to embed Html objects as text into other HTML or markdown\n    strings. For example:\n\n    ```python3\n    hello_world = Html(\"<h2>Hello, World</h2>\")\n    Html(\n        f'''\n        <h1>Hello, Universe!</h1>\n        {hello_world}\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def md(text: str) -> Html:\n# Natural Language Annotations: r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef md(text: str) -> Html:\n    \"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n```\n", "```python\ndef md(text: str) -> Html:\n    \"\"\"\n    Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n```\n", "Sure, here is the code based on the function signature and natural language annotations:\n\n```python\ndef md(text: str) -> Html:\n    \"\"\"\n    Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n    return Html(text)\n```\n"]}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    \"\"\"An executable notebook cell\n\n    A `Cell` object can be executed as a function via its `run()` method, which\n    returns the cell's last expression (output) and a mapping from its defined\n    names to its values.\n\n    Cells can be named via the marimo editor in the browser, or by\n    changing the cell's function name in the notebook file. Named\n    cells can then be executed for use in other notebooks, or to test\n    in unit tests.\n\n    For example:\n\n    ```python\n    from my_notebook import my_cell\n\n    output, definitions = my_cell.run()\n    ```\n\n    See the documentation of `run` for info and examples.\n\n------------------------------\n------------------------------\n        slow down all imports.\n\n        Return `None` if the formatter isn't for any specific package.\n        \"\"\"\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def register(self) -> Callable[[], None] | None:\n        \"\"\"Registers formatters.\n\n        Formatters can be registered using the formatters.formatter decorator.\n\n        Optionally returns a handle to undo side-effects, such as module\n        patches.\n        \"\"\"\n        raise NotImplementedError\n\n------------------------------\n------------------------------\n    )\n\n    if is_edit_mode:\n        # completions only provided in edit mode\n        kernel.start_completion_worker(completion_queue)\n\n        # In edit mode, kernel runs in its own process so it's interruptible.\n        from marimo._output.formatters.formatters import register_formatters\n\n        # TODO: Windows workaround -- find a way to make the process\n        # its group leader\n        if sys.platform != \"win32\":\n            # Make this process group leader to prevent it from receiving\n            # signals intended for the parent (server) process,\n            # Ctrl+C in particular.\n            os.setsid()\n\n        # kernels are processes in edit mode, and each process needs to\n        # install the formatter import hooks\n        register_formatters()\n\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\n\"\"\"Formatting protocol\n\nThis module defines a protocol for implementing objects that can be displayed\nusing marimo's media viewer.\n\nTo register a formatter for a type, user have two options:\n    1. Implement a method _mime_ on the class that takes an instance\n       and returns a (mime, data) tuple (i.e., implement the protocol MIME)\n    2. Register a formatter function that takes a value and returns\n       a (mime, data) tuple.\n\nThe function get_formatter(value: T) can be used to obtain a function that\ninstantiates a (mime, data) tuple for a value, with registered formatters\ntaking precedence over the MIME protocol.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport inspect\n\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport abc\nfrom typing import Callable, Optional\n\n\n# Abstract base class for formatters that are installed at runtime.\nclass FormatterFactory(abc.ABC):\n    @staticmethod\n    @abc.abstractmethod\n    def package_name() -> Optional[str]:\n        \"\"\"Name of third-party package that this formatter is for\n\n        **Important**: should not actually import the package, since that will\n        slow down all imports.\n\n        Return `None` if the formatter isn't for any specific package.\n        \"\"\"\n        raise NotImplementedError\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_formatters() -> None:\n# Natural Language Annotations: \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n    pass\n```\n", "Sure, here is the function based on your specifications:\n\n```python\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n    pass\n```\n", "```python\nimport sys\nimport os\nimport marimo\n\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n    kernel = marimo.get_kernel()\n    kernel.start_completion_worker(completion_queue)\n\n    # In edit mode, kernel runs in its own process so it's interruptible.\n    from marimo._output.formatters.formatters import register_formatters\n\n    # TODO: Windows workaround -- find a way to make the process\n    # its group leader\n    if sys.platform != \"win32\":\n        # Make this process group leader to prevent it from receiving\n        # signals intended for the parent (server) process,\n        # Ctrl+C in particular.\n        os.setsid()\n\n    # kernels are processes in edit mode, and each process needs to\n    # install the formatter import hooks\n    register_formatters()\n```\n"]}, "marimo-marimo/_data/series.py-get_category_series_info": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\nclass DataTableColumn:\n    \"\"\"\n    Represents a column in a data table.\n\n    Attributes:\n        name (str): The name of the column.\n        type (DataType): The data type of the column.\n    \"\"\"\n\n    name: str\n    type: DataType\n    external_type: ExternalDataType\n\n\n@dataclass\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n\n    Attributes:\n\n------------------------------\n------------------------------\n    Represents a summary of a categorical series.\n    \"\"\"\n\n    categories: list[str]\n    label: str\n\n\n@dataclass\nclass DateSeriesInfo:\n    \"\"\"\n    Represents a summary of a date series.\n    \"\"\"\n\n    min: str\n    max: str\n    label: str\n\n\ndef _get_name(series: DataFrameSeries) -> str:\n    return str(series.name) if series.name is not None else \"\"\n\n------------------------------\n------------------------------\n\n@dataclass\nclass NumberSeriesInfo:\n    \"\"\"\n    Represents a summary of a numeric series.\n    \"\"\"\n\n    min: float\n    max: float\n    label: str\n\n\n@dataclass\nclass CategorySeriesInfo:\n    \"\"\"\n    Represents a summary of a categorical series.\n    \"\"\"\n\n    categories: list[str]\n    label: str\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_category_series_info(series: Any) -> CategorySeriesInfo:\n# Natural Language Annotations: \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    categories = series.unique().tolist()\n    label = series.name\n    return CategorySeriesInfo(categories, label)\n```\n", "```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    categories = series.unique().tolist()\n    label = series.name\n    return CategorySeriesInfo(categories, label)\n```\n", "```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    categories = list(series.unique())\n    label = series.name\n    return CategorySeriesInfo(categories, label)\n```\n"]}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    )\n    return\n\n\n@app.cell\ndef __(mo):\n    mo.md(\n        \"\"\"\n        We'll start by making a simple neighborhood-preserving embedding. This\n        means that we'll try to identify pairs of images that are similar, using\n        a heuristic, and we'll tell PyMDE to place these pairs near each other in\n        the embedding.\n        \"\"\"\n    )\n    return\n\n\n@app.cell\ndef __(n_neighbors):\n    n_neighbors\n\n------------------------------\n------------------------------\nimport marimo\n\n__generated_with = \"0.1.4\"\napp = marimo.App()\n\n\n@app.cell\ndef __(mo):\n    mo.md(\"# Regularization and Sparsity\")\n    return\n\n\n@app.cell\ndef __(mo):\n    mo.md(\n        r\"\"\"\n        This app shows how the choice of regularization in a least squares regression\n        problem can affect the sparsity of solutions.\n\n        We will use CVXPY to solve the problem\n\n------------------------------\n------------------------------\n        [^longnote]: This is a longer footnote with paragraphs, and code.\n\n            Indent paragraphs to include them in the footnote.\n\n            `{ my code }` add some code, if you like.\n\n            Add as many paragraphs as you need.\n        \"\"\"\n    )\n    return\n\n\n@app.cell\ndef __(mo):\n    mo.md(\"# External links\")\n    return\n\n\n@app.cell\ndef __(mo):\n\n------------------------------\n------------------------------\n    Represents a summary of a column in a data table.\n\n    \"\"\"\n\n    total: Optional[int] = None\n    nulls: Optional[int] = None\n    unique: Optional[int] = None\n    min: Optional[NonNestedLiteral] = None\n    max: Optional[NonNestedLiteral] = None\n    mean: Optional[NonNestedLiteral] = None\n    median: Optional[NonNestedLiteral] = None\n    std: Optional[NonNestedLiteral] = None\n    true: Optional[int] = None\n    false: Optional[int] = None\n    p5: Optional[NonNestedLiteral] = None\n    p25: Optional[NonNestedLiteral] = None\n    # p50 is the median\n    p75: Optional[NonNestedLiteral] = None\n    p95: Optional[NonNestedLiteral] = None\n\n------------------------------\n------------------------------\nclass DataTableColumn:\n    \"\"\"\n    Represents a column in a data table.\n\n    Attributes:\n        name (str): The name of the column.\n        type (DataType): The data type of the column.\n    \"\"\"\n\n    name: str\n    type: DataType\n    external_type: ExternalDataType\n\n\n@dataclass\nclass DataTable:\n    \"\"\"\n    Represents a data table.\n\n    Attributes:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_column_preview(\n# Natural Language Annotations: \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_column_preview(column: DataTableColumn, dataset: DataTable, num_rows: int = 1000) -> None:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n```\n", "Sure, here is the function `get_column_preview` based on your specifications:\n\n```python\nfrom typing import Optional, Union\nfrom dataclasses import dataclass\n\nclass DataType:\n    pass\n\nclass ExternalDataType:\n    pass\n\nclass NonNestedLiteral:\n    pass\n\n@dataclass\nclass DataColumnSummary:\n    total: Optional[int] = None\n    nulls: Optional[int] = None\n    unique: Optional[int] = None\n    min: Optional[NonNestedLiteral] = None\n    max: Optional[NonNestedLiteral] = None\n    mean: Optional[NonNestedLiteral] = None\n    median: Optional[NonNestedLiteral] = None\n    std: Optional[NonNestedLiteral] = None\n    true: Optional[int] = None\n    false: Optional[int] = None\n    p5: Optional[NonNestedLiteral] = None\n    p25: Optional[NonNestedLiteral] = None\n    # p50 is the median\n    p75: Optional[NonNestedLiteral] = None\n    p95: Optional[NonNestedLiteral] = None\n\nclass DataTableColumn:\n    name: str\n    type: DataType\n    external_type: ExternalDataType\n\n@dataclass\nclass DataTable:\n    pass\n\ndef get_column_preview(\n    table: DataTable, \n    column: Union[str, DataTableColumn]\n) -> DataColumnSummary:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    # Your code here\n    pass\n```\n\nPlease note that the function `get_column_preview` has placeholders for the actual code. You need to replace `# Your code here` with the actual implementation of the function.\n", "```python\nimport pandas as pd\nfrom typing import Tuple\nfrom .data_table import DataTableColumn\n\ndef get_column_preview(column: DataTableColumn) -> Tuple[pd.Series, DataTableColumn]:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\n    # The implementation of this function depends on how you have implemented your DataTable and DataTableColumn classes.\n    # This is a general idea of what the function might look like based on the provided information.\n\n    # Assuming you have a pandas DataFrame called df and you're using the column name to access the data.\n    # Also, assuming you have methods to generate a DataTableColumn summary from pandas Series.\n\n    column_data = df[column.name]\n    summary = DataTableColumn.generate_summary(column_data)\n\n    # Here you would typically create a chart from the column data.\n    # This is not included because the specific implementation would depend on the charting library you're using.\n\n    return column_data, summary\n```\n"]}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    if not path.is_file():\n        raise click.UsageError(\"Invalid NAME - %s is not a file\" % name)\n\n    print(codegen.recover(name))\n\n\n@main.command(\n    help=\"\"\"Open a tutorial.\n\nmarimo is a powerful library for making reactive notebooks\nand apps. To get the most out of marimo, get started with a few\ntutorials, starting with the intro:\n\n    \\b\n    marimo tutorial intro\n\nRecommended sequence:\n\n    \\b\n\n------------------------------\n------------------------------\n    Watch notebook for changes and regenerate the script on modification.\n    If watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=str,\n    default=None,\n    help=\"\"\"\n    Output file to save the script to.\n    If not provided, markdown will be printed to stdout.\n    \"\"\",\n)\n@click.argument(\"name\", required=True)\ndef md(\n    name: str,\n    output: str,\n    watch: bool,\n\n------------------------------\n------------------------------\n                session.app_file_manager.path == os.path.abspath(key)\n            ):\n                return True\n        return False\n\n    def get_session_for_key(self, key: MarimoFileKey) -> Optional[Session]:\n        for session in self.sessions.values():\n            if (\n                session.app_file_manager.path == os.path.abspath(key)\n                or session.initialization_id == key\n            ) and session.connection_state() == ConnectionState.OPEN:\n                return session\n        return None\n\n    async def start_lsp_server(self) -> None:\n        \"\"\"Starts the lsp server if it is not already started.\n\n        Doesn't start in run mode.\n        \"\"\"\n        if self.mode == SessionMode.RUN:\n\n------------------------------\n------------------------------\n@click.option(\n    \"--watch/--no-watch\",\n    default=False,\n    show_default=True,\n    type=bool,\n    help=\"\"\"\n    Watch notebook for changes and regenerate HTML on modification.\n    If watchdog is installed, it will be used to watch the file.\n    Otherwise, file watcher will poll the file every 1s.\n    \"\"\",\n)\n@click.option(\n    \"-o\",\n    \"--output\",\n    type=str,\n    default=None,\n    help=\"\"\"\n    Output file to save the HTML to.\n    If not provided, the HTML will be printed to stdout.\n    \"\"\",\n\n------------------------------\n------------------------------\n        \"\"\"Starts the lsp server if it is not already started.\n\n        Doesn't start in run mode.\n        \"\"\"\n        if self.mode == SessionMode.RUN:\n            LOGGER.warning(\"Cannot start LSP server in run mode\")\n            return\n\n        alert = self.lsp_server.start()\n\n        if alert is not None:\n            for _, session in self.sessions.items():\n                session.write_operation(alert)\n            return\n\n    def close_session(self, session_id: SessionId) -> bool:\n        LOGGER.debug(\"Closing session %s\", session_id)\n        session = self.get_session(session_id)\n        if session is not None:\n            session.close()\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start_file_watcher(self) -> Disposable:\n# Natural Language Annotations: \"\"\"Starts the file watcher if it is not already started\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef start_file_watcher(self) -> Disposable:\n    \"\"\"Starts the file watcher if it is not already started\"\"\"\n    if self.mode == SessionMode.RUN:\n        LOGGER.warning(\"Cannot start file watcher in run mode\")\n        return\n\n    alert = self.file_watcher.start()\n\n    if alert is not None:\n        for _, session in self.sessions.items():\n            session.write_operation(alert)\n        return\n```\n", "```python\ndef start_file_watcher(self) -> Disposable:\n    \"\"\"Starts the file watcher if it is not already started\"\"\"\n    pass\n```\n", "```python\ndef start_file_watcher(self) -> Disposable:\n    \"\"\"Starts the file watcher if it is not already started\"\"\"\n\n    # Note: This function assumes that self.file_watcher is a Watcher object\n    # and that it has a start() method that starts the watcher.\n    # The Watcher object should return a Disposable object when the start() method is called.\n    # The Disposable object can be used to stop the watcher.\n\n    if not self.file_watcher.is_running():\n        return self.file_watcher.start()\n```\n"]}, "marimo-marimo/_server/file_manager.py-save_app_config": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    )\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n------------------------------\n------------------------------\n    )\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n------------------------------\n------------------------------\n    # partial app config\n    config: Dict[str, Any]\n\n\n@dataclass\nclass SaveUserConfigurationRequest:\n    # user configuration\n    config: MarimoConfig\n\n\n@dataclass\nclass StdinRequest:\n    text: str\n\n------------------------------\n------------------------------\n@router.post(\"/save_app_config\")\n@requires(\"edit\")\nasync def save_app_config(\n    *,\n    request: Request,\n) -> PlainTextResponse:\n    \"\"\"\n    requestBody:\n        content:\n            application/json:\n                schema:\n                    $ref: \"#/components/schemas/SaveAppConfigurationRequest\"\n    responses:\n        200:\n            description: Save the app configuration\n            content:\n                text/plain:\n                    schema:\n                        type: string\n    \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def save(self, request: SaveNotebookRequest) -> str:\n        \"\"\"Save the current app.\"\"\"\n        cell_ids, codes, configs, names, filename, layout = (\n            request.cell_ids,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def save_app_config(self, config: Dict[str, Any]) -> str:\n# Natural Language Annotations: \"\"\"Save the app configuration.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    # Implement your logic here\n    pass\n```\n", "```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    # TODO: Implement your logic here\n    pass\n```\n", "```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    # Your code here to save the app configuration\n    pass\n```\n"]}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    def stop(self) -> None:\n        # Stop the task and set the stopped flag\n        self.stopped = True\n        assert self.task is not None\n        self.task.cancel()\n\n    def restart(self) -> None:\n        # Cancel the current task, which will cause\n        # the while loop to start a new task\n        assert self.task is not None\n        self.task.cancel()\n\n------------------------------\n------------------------------\n            input `Ctrl/Cmd+Shift+h`) to view a list of all keyboard\n            shortcuts.\n            \"\"\"\n        ),\n        \"Configuration\": (\n            \"\"\"\n           Configure the editor by clicking the gears icon near the top-right\n           of the screen.\n           \"\"\"\n        ),\n    }\n    return (tips,)\n\n\nif __name__ == \"__main__\":\n    app.run()\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_stdin(self, stdin: str) -> None:\n# Natural Language Annotations: \"\"\"Add a stdin request to the session view.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    self.stdin = stdin\n```\n", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    # Add the stdin request to the session view\n    self.stdin = stdin\n```\n", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"\n    Add a stdin request to the session view.\n\n    Parameters:\n        stdin (str): The standard input data to add to the session view.\n\n    Returns:\n        None\n    \"\"\"\n    # Add the stdin data to the session view\n    self.session_view.add_stdin(stdin)\n```\n"]}, "marimo-marimo/_server/session/session_view.py-add_operation": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        # execute the notebook\n        result = await app.embed()\n        ```\n\n        ```python\n        # view the notebook's visual output\n        result.output\n        ```\n\n        ```python\n        # access the notebook's defined variables\n        result.defs\n        ```\n\n        Running `await app.embed()` executes the notebook and results an object\n        encapsulating the notebook visual output and its definitions.\n\n        Embedded notebook outputs are interactive: when you interact with\n        UI elements in an embedded notebook's output, any cell referring\n        to the `app` object is marked for execution, and its internal state\n\n------------------------------\n------------------------------\n        \"\"\"\n\n        self.status = ConnectionState.OPEN\n        session.connect_consumer(self, main=False)\n\n        operations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the kiosk consumer\",\n        )\n\n        self._write_kernel_ready(\n            session=session,\n            resumed=True,\n            ui_values=session.get_current_state().ui_values,\n            last_executed_code=session.get_current_state().last_executed_code,\n            last_execution_time=session.get_current_state().last_execution_time,\n            kiosk=True,\n        )\n\n\n------------------------------\n------------------------------\n            self.write_operation(\n                Alert(\n                    title=\"Reconnected\",\n                    description=\"You have reconnected to an existing session.\",\n                )\n            )\n            return\n\n        operations = session.get_current_state().operations\n        # Replay the current session view\n        LOGGER.debug(\n            f\"Replaying {len(operations)} operations to the consumer\",\n        )\n\n        self._write_kernel_ready(\n            session=session,\n            resumed=True,\n            ui_values=session.get_current_state().ui_values,\n            last_executed_code=session.get_current_state().last_executed_code,\n            last_execution_time=session.get_current_state().last_execution_time,\n\n------------------------------\n------------------------------\n            return ConnectionState.ORPHANED\n        return self.room.main_consumer.connection_state()\n\n    def write_operation(self, operation: MessageOperation) -> None:\n        \"\"\"Write an operation to the session consumer and the session view.\"\"\"\n        self.session_view.add_operation(operation)\n        self.room.broadcast(operation)\n\n    def close(self) -> None:\n        \"\"\"\n        Close the session.\n\n        This will close the session consumer, kernel, and all kiosk consumers.\n        \"\"\"\n        self._closed = True\n        # Close the room\n        self.room.close()\n        # Close the kernel\n        self.message_distributor.stop()\n        if self.heartbeat_task:\n\n------------------------------\n------------------------------\n            session_consumer,\n            unsubscribe_consumer,\n            session_consumer.consumer_id,\n            main=main,\n        )\n\n    def get_current_state(self) -> SessionView:\n        \"\"\"Return the current state of the session.\"\"\"\n        return self.session_view\n\n    def connection_state(self) -> ConnectionState:\n        \"\"\"Return the connection state of the session.\"\"\"\n        if self._closed:\n            return ConnectionState.CLOSED\n        if self.room.main_consumer is None:\n            return ConnectionState.ORPHANED\n        return self.room.main_consumer.connection_state()\n\n    def write_operation(self, operation: MessageOperation) -> None:\n        \"\"\"Write an operation to the session consumer and the session view.\"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_operation(self, operation: MessageOperation) -> None:\n# Natural Language Annotations: \"\"\"Add an operation to the session view.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.session_view.add_operation(operation)\n```\n", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.session_view.add_operation(operation)\n```\n", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    # Add an operation to the session view\n    self.session_view.add_operation(operation)\n```\n"]}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    Variables,\n    VariableValue,\n    VariableValues,\n)\nfrom marimo._runtime.requests import (\n    ControlRequest,\n    CreationRequest,\n    ExecuteMultipleRequest,\n    ExecutionRequest,\n    SetUIElementValueRequest,\n)\nfrom marimo._utils.parse_dataclass import parse_raw\n\n\nclass SessionView:\n    \"\"\"\n    This stores the current view of the session.\n\n    Which are the cell's outputs, status, and console.\n    \"\"\"\n\n------------------------------\n------------------------------\n                    cell_id,\n                    output.data,\n                    output.mimetype,\n                )\n        outputs_buffered_per_cell = {}\n        timer = None\n\n------------------------------\n------------------------------\n        return set(\n            mod\n            for cell in self.graph.cells.values()\n            for mod in cell.imported_namespaces\n        )\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        return cids_to_run\n\n    def pop_cell(self) -> CellId_t:\n        \"\"\"Get the next cell to run.\"\"\"\n        return self.cells_to_run.pop(0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def get_cell_outputs(\n        self, ids: list[CellId_t]\n    ) -> dict[CellId_t, CellOutput]:\n        \"\"\"Get the outputs for the given cell ids.\"\"\"\n        outputs: dict[CellId_t, CellOutput] = {}\n        for cell_id in ids:\n            cell_op = self.cell_operations.get(cell_id)\n            if cell_op is not None and cell_op.output is not None:\n                outputs[cell_id] = cell_op.output\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_cell_console_outputs(\n# Natural Language Annotations: \"\"\"Get the console outputs for the given cell ids.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_cell_console_outputs(\n    self, ids: list[CellId_t]\n) -> dict[CellId_t, CellConsoleOutput]:\n    \"\"\"Get the console outputs for the given cell ids.\"\"\"\n    console_outputs: dict[CellId_t, CellConsoleOutput] = {}\n    for cell_id in ids:\n        cell_op = self.cell_operations.get(cell_id)\n        if cell_op is not None and cell_op.console_output is not None:\n            console_outputs[cell_id] = cell_op.console_output\n    return console_outputs\n```\n", "```python\ndef get_cell_console_outputs(\n    self, ids: list[CellId_t]\n) -> dict[CellId_t, CellConsoleOutput]:\n    \"\"\"Get the console outputs for the given cell ids.\"\"\"\n    console_outputs: dict[CellId_t, CellConsoleOutput] = {}\n    for cell_id in ids:\n        cell_op = self.cell_operations.get(cell_id)\n        if cell_op is not None and cell_op.console_output is not None:\n            console_outputs[cell_id] = cell_op.console_output\n    return console_outputs\n```\n", "```python\ndef get_cell_console_outputs(self, ids: list[CellId_t]) -> dict[CellId_t, CellOutput]:\n    \"\"\"Get the console outputs for the given cell ids.\"\"\"\n    console_outputs: dict[CellId_t, CellOutput] = {}\n    for cell_id in ids:\n        cell_op = self.cell_operations.get(cell_id)\n        if cell_op is not None and cell_op.console_output is not None:\n            console_outputs[cell_id] = cell_op.console_output\n    return console_outputs\n```\n"]}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                        modules={m: sys.modules[m] for m in new_modules},\n                        reload=False,\n                    )\n\n    def _try_registering_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> Optional[Error]:\n        \"\"\"Attempt to register a cell with given id and code.\n\n        Precondition: a cell with the supplied id must not already exist in the\n        graph.\n\n        If cell was unable to be registered, returns an Error object.\n        \"\"\"\n        error: Optional[Error] = None\n        try:\n            cell = compile_cell(code, cell_id=cell_id)\n        except Exception as e:\n\n------------------------------\n------------------------------\n\n    @property\n    def name(self) -> str:\n        return self._name\n\n    @property\n    def refs(self) -> set[str]:\n        \"\"\"The references that this cell takes as input\"\"\"\n        return self._cell.refs\n\n    @property\n    def defs(self) -> set[str]:\n        \"\"\"The definitions made by this cell\"\"\"\n        return self._cell.defs\n\n    def _is_coroutine(self) -> bool:\n        \"\"\"Whether this cell is a coroutine function.\n\n        If True, then this cell's `run` method returns an awaitable.\n        \"\"\"\n\n------------------------------\n------------------------------\n        return self._deactivate_cell(cell_id)\n\n    def mutate_graph(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> set[CellId_t]:\n        \"\"\"Add and remove cells to/from the graph.\n\n        This method adds the cells in `execution_requests` to the kernel's\n        graph (deleting old versions of these cells, if any), and removes the\n        cells in `deletion_requests` from the kernel's graph.\n\n        The mutations that this method makes to the graph renders the\n        kernel inconsistent (stale).\n\n        This method does not register errors for cells that were previously\n        valid and are not descendants of any of the newly registered cells.\n        This is important for multiple definition errors, since a user may\n        absent-mindedly redefine an existing name when creating a new cell:\n\n------------------------------\n------------------------------\n\n        Return True if the disposal is successful and the lifecycle item\n        should be removed from the registry. Return False if the disposal\n        needs to be retried in the next cell lifecycle (note that `create`\n        will not be re-run, only `dispose`).\n        \"\"\"\n        ...\n\n------------------------------\n------------------------------\n                child = self.cells[cid]\n                if child.stale:\n                    # cell was previously disabled, is no longer\n                    # disabled, and is stale: needs to run.\n                    cells_to_run.add(cid)\n                if child.disabled_transitively:\n                    # cell is no longer disabled: status -> idle\n                    child.set_status(\"idle\")\n        return cells_to_run\n\n    def delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Removes a cell from the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Returns the ids of the children of the removed cell.\n        \"\"\"\n        with self.lock:\n            if cell_id not in self.cells:\n                raise ValueError(f\"Cell {cell_id} not found\")\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n# Natural Language Annotations: \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```\n", "```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```\n", "```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} already exists\")\n        self.cells[cell_id] = cell\n```\n"]}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n------------------------------\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n    hello, this is a cell\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check_for_errors(\n# Natural Language Annotations: \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    pass\n```\n", "```python\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    errors = {}\n    for cell in graph:\n        # Check for errors in the cell\n        error = check_cell(cell)\n        if error:\n            errors[cell] = error\n    return errors\n\ndef check_cell(cell):\n    \"\"\"\n    Check a cell for violations of marimo semantics.\n\n    Return an error message if a violation is found, otherwise return None.\n    \"\"\"\n    # Check for violations of marimo semantics in the cell\n    # If a violation is found, return an error message\n    # Otherwise, return None\n    pass\n```\n", "```python\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    error_dict = {}\n\n    # Iterate over each cell in the graph\n    for cell in graph:\n        # Check for violations of marimo semantics\n        if not is_marimo_semantics_valid(cell):\n            # If there is a violation, add it to the error_dict\n            error_dict[cell] = \"Violation of marimo semantics detected.\"\n\n    return error_dict\n```\n"]}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def _deactivate_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Deactivate: remove from graph, invalidate state, but keep metadata\n\n        Keeps the cell's config, in case we see the same cell again.\n\n        In contrast to deleting a cell, which fully scrubs the cell\n        from the kernel and graph.\n        \"\"\"\n        if cell_id not in self.errors:\n            self._invalidate_cell_state(cell_id, deletion=True)\n            return self.graph.delete_cell(cell_id)\n        else:\n            # An errored cell can be thought of as a cell that's in the graph\n            # but that has no state in the kernel (because it was never run).\n            # Its defs may overlap with defs of a non-errored cell, so we MUST\n            # NOT delete/cleanup its defs from the kernel (i.e., an errored\n            # cell shouldn't invalidate state of another cell).\n            self.graph.delete_cell(cell_id)\n            return set()\n\n------------------------------\n------------------------------\n                        modules={m: sys.modules[m] for m in new_modules},\n                        reload=False,\n                    )\n\n    def _try_registering_cell(\n        self,\n        cell_id: CellId_t,\n        code: str,\n    ) -> Optional[Error]:\n        \"\"\"Attempt to register a cell with given id and code.\n\n        Precondition: a cell with the supplied id must not already exist in the\n        graph.\n\n        If cell was unable to be registered, returns an Error object.\n        \"\"\"\n        error: Optional[Error] = None\n        try:\n            cell = compile_cell(code, cell_id=cell_id)\n        except Exception as e:\n\n------------------------------\n------------------------------\n    def enable_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"\n        Enables a cell in the graph.\n\n        Does not mutate the graph (but does mutate cell statuses).\n\n        Returns:\n        - set of cells that were stale and should be re-run\n        \"\"\"\n        if cell_id not in self.cells:\n            raise ValueError(f\"Cell {cell_id} not found\")\n\n        cells_to_run: set[CellId_t] = set()\n        for cid in transitive_closure(self, set([cell_id])):\n            if not self.is_disabled(cid):\n                child = self.cells[cid]\n                if child.stale:\n                    # cell was previously disabled, is no longer\n                    # disabled, and is stale: needs to run.\n                    cells_to_run.add(cid)\n\n------------------------------\n------------------------------\n                child = self.cells[cid]\n                if child.stale:\n                    # cell was previously disabled, is no longer\n                    # disabled, and is stale: needs to run.\n                    cells_to_run.add(cid)\n                if child.disabled_transitively:\n                    # cell is no longer disabled: status -> idle\n                    child.set_status(\"idle\")\n        return cells_to_run\n\n    def delete_cell(self, cell_id: CellId_t) -> set[CellId_t]:\n        \"\"\"Removes a cell from the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Returns the ids of the children of the removed cell.\n        \"\"\"\n        with self.lock:\n            if cell_id not in self.cells:\n                raise ValueError(f\"Cell {cell_id} not found\")\n\n------------------------------\n------------------------------\n        return self._deactivate_cell(cell_id)\n\n    def mutate_graph(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> set[CellId_t]:\n        \"\"\"Add and remove cells to/from the graph.\n\n        This method adds the cells in `execution_requests` to the kernel's\n        graph (deleting old versions of these cells, if any), and removes the\n        cells in `deletion_requests` from the kernel's graph.\n\n        The mutations that this method makes to the graph renders the\n        kernel inconsistent (stale).\n\n        This method does not register errors for cells that were previously\n        valid and are not descendants of any of the newly registered cells.\n        This is important for multiple definition errors, since a user may\n        absent-mindedly redefine an existing name when creating a new cell:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _maybe_register_cell(\n# Natural Language Annotations: \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _maybe_register_cell(\n    self,\n    cell_id: CellId_t,\n    code: str,\n) -> Tuple[Optional[set[CellId_t]], Optional[Error]]:\n    if cell_id in self.cells:\n        if self.cells[cell_id].code == code:\n            return None, None\n        else:\n            # cell was registered with different code: delete it and register\n            # new cell\n            cells_to_run = self._deactivate_cell(cell_id)\n            error = self._try_registering_cell(cell_id, code)\n            return cells_to_run, error\n    else:\n        # cell was not registered: register it\n        error = self._try_registering_cell(cell_id, code)\n        return None, error\n```\n", "```python\ndef _maybe_register_cell(\n    self,\n    cell_id: CellId_t,\n    code: str,\n) -> Tuple[Optional[set[CellId_t]], Optional[Error]]:\n    if cell_id in self.cells:\n        old_code = self.cells[cell_id].code\n        if old_code != code:\n            # Cell with the same id but different code exists\n            # Delete old cell and register new one\n            children = self.delete_cell(cell_id)\n            error = self._try_registering_cell(cell_id, code)\n            return children, error\n        else:\n            # Cell with the same id and code already exists\n            return None, None\n    else:\n        # Cell doesn't exist, register new one\n        error = self._try_registering_cell(cell_id, code)\n        return None, error\n```\n", "Sure, here is the Python function based on the given specifications:\n\n```python\ndef _maybe_register_cell(\n    self,\n    cell_id: CellId_t,\n    code: str,\n) -> tuple[Optional[set[CellId_t]], Optional[Error]]:\n    \"\"\"Register a cell (given by id, code) if not already registered.\n\n    If a cell with id `cell_id` is already registered but with different\n    code, that cell is deleted from the graph and a new cell with the\n    same id but different code is registered.\n\n    Returns:\n    - a set of ids for cells that were previously children of `cell_id`;\n      only non-empty when `cell-id` was already registered but with\n      different code.\n    - an `Error` if the cell couldn't be registered, `None` otherwise\n    \"\"\"\n    # Check if cell already exists\n    if cell_id in self.cells:\n        # Check if cell has the same code\n        if self.cells[cell_id].code == code:\n            # No need to register cell, return None\n            return None, None\n        else:\n            # Cell exists but has different code, get its children\n            children = self.graph.delete_cell(cell_id)\n            # Register cell with new code\n            error = self._try_registering_cell(cell_id, code)\n            # Return children and any error\n            return children, error\n    else:\n        # Cell doesn't exist, register it\n        error = self._try_registering_cell(cell_id, code)\n        # No children to return, return None and any error\n        return None, error\n```\n"]}, "marimo-marimo/_runtime/runtime.py-run": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        | Awaitable[tuple[Any, Mapping[str, Any]]]\n    ):\n        \"\"\"Run this cell and return its visual output and definitions\n\n        Use this method to run **named cells** and retrieve their output and\n        definitions.\n\n        This lets you use reuse cells defined in one notebook in another\n        notebook or Python file. It also makes it possible to write and execute\n        unit tests for notebook cells using a test framework like `pytest`.\n\n        **Example.** marimo cells can be given names either through the\n        editor cell menu or by manually changing the function name in the\n        notebook file. For example, consider a notebook `notebook.py`:\n\n        ```python\n        import marimo\n\n        app = marimo.App()\n\n\n------------------------------\n------------------------------\n        \"\"\"## 5. The `marimo` command-line tool\n\n        **Creating and editing notebooks.** Use\n\n        ```\n        marimo edit\n        ```\n\n        in a terminal to create a new marimo notebook, or\n\n        ```\n        marimo edit notebook.py\n        ```\n\n        to create/edit a notebook called `notebook.py`.\n\n        **Running as apps.** Use\n\n        ```\n        marimo run notebook.py\n\n------------------------------\n------------------------------\n    \"\"\"An executable notebook cell\n\n    A `Cell` object can be executed as a function via its `run()` method, which\n    returns the cell's last expression (output) and a mapping from its defined\n    names to its values.\n\n    Cells can be named via the marimo editor in the browser, or by\n    changing the cell's function name in the notebook file. Named\n    cells can then be executed for use in other notebooks, or to test\n    in unit tests.\n\n    For example:\n\n    ```python\n    from my_notebook import my_cell\n\n    output, definitions = my_cell.run()\n    ```\n\n    See the documentation of `run` for info and examples.\n\n------------------------------\n------------------------------\n        This method is executed at the beginning of a cell's lifecycle.\n        Use it to run side-effects or create state.\n        \"\"\"\n        ...\n\n    @abc.abstractmethod\n    def dispose(self, context: \"RuntimeContext\", deletion: bool) -> bool:\n        \"\"\"Dispose this item\n\n        This method is executed at the end of a cell's lifecycle. Use\n        it to clean-up side-effects or state associated with the lifecycle\n        item.\n\n        The `deletion` flag indicates whether the cell is being removed\n        from the graph, which may influence disposal strategy.\n\n        Return True if the disposal is successful and the lifecycle item\n        should be removed from the registry. Return False if the disposal\n        needs to be retried in the next cell lifecycle (note that `create`\n        will not be re-run, only `dispose`).\n\n------------------------------\n------------------------------\n        return self._deactivate_cell(cell_id)\n\n    def mutate_graph(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> set[CellId_t]:\n        \"\"\"Add and remove cells to/from the graph.\n\n        This method adds the cells in `execution_requests` to the kernel's\n        graph (deleting old versions of these cells, if any), and removes the\n        cells in `deletion_requests` from the kernel's graph.\n\n        The mutations that this method makes to the graph renders the\n        kernel inconsistent (stale).\n\n        This method does not register errors for cells that were previously\n        valid and are not descendants of any of the newly registered cells.\n        This is important for multiple definition errors, since a user may\n        absent-mindedly redefine an existing name when creating a new cell:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run(\n# Natural Language Annotations: \"\"\"Run cells and their descendants.\n\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def run(\n    self,\n    execution_requests: Sequence[ExecutionRequest],\n    deletion_requests: Sequence[DeleteCellRequest],\n) -> set[CellId_t]:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    # Add the execution requests to the graph\n    self.mutate_graph(execution_requests, [])\n\n    # Run the cells\n    for cell in execution_requests:\n        await cell.run()\n\n    # Run the descendants of the cells\n    for cell in execution_requests:\n        for descendant in cell.descendants():\n            await descendant.run()\n\n    return {cell.id for cell in execution_requests}\n```\n", "```python\nasync def run(\n    self,\n    execution_requests: Sequence[ExecutionRequest],\n    deletion_requests: Sequence[DeleteCellRequest],\n) -> Awaitable[tuple[Any, Mapping[str, Any]]]:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    # Add the new cells and remove the old ones\n    for request in execution_requests:\n        self.add_cell(request)\n    for request in deletion_requests:\n        self.remove_cell(request)\n    \n    # Run the cells\n    results = []\n    for request in execution_requests:\n        cell = self.get_cell(request.cell_id)\n        result = await cell.run()\n        results.append(result)\n    \n    return results\n```\n", "```python\nasync def run(\n        self,\n        execution_requests: Sequence[ExecutionRequest],\n        deletion_requests: Sequence[DeleteCellRequest],\n    ) -> None:\n        \"\"\"Run cells and their descendants.\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\n        for request in execution_requests:\n            # Add the cell to the graph\n            # If the cell is already in the graph, replace it with the new one\n            self.mutate_graph([request], [])\n\n        # Run all the cells\n        for request in execution_requests:\n            cell_id = request.cell_id\n            await self._run_cell(cell_id)\n```\n"]}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def has_openai() -> bool:\n        \"\"\"Return True if openai is installed.\"\"\"\n        return importlib.util.find_spec(\"openai\") is not None\n\n    @staticmethod\n    def has_pandas() -> bool:\n        \"\"\"Return True if pandas is installed.\"\"\"\n        return importlib.util.find_spec(\"pandas\") is not None\n\n    @staticmethod\n    def has_pyarrow() -> bool:\n        \"\"\"Return True if pyarrow is installed.\"\"\"\n        return importlib.util.find_spec(\"pyarrow\") is not None\n\n    @staticmethod\n    def has_polars() -> bool:\n        \"\"\"Return True if polars is installed.\"\"\"\n        return importlib.util.find_spec(\"polars\") is not None\n\n    @staticmethod\n\n------------------------------\n------------------------------\n    asyncio.run(control_loop())\n\n    if stdout is not None:\n        stdout._watcher.stop()\n    if stderr is not None:\n        stderr._watcher.stop()\n    get_context().virtual_file_registry.shutdown()\n\n------------------------------\n------------------------------\n\n        Return True if the disposal is successful and the lifecycle item\n        should be removed from the registry. Return False if the disposal\n        needs to be retried in the next cell lifecycle (note that `create`\n        will not be re-run, only `dispose`).\n        \"\"\"\n        ...\n\n------------------------------\n------------------------------\n    def has_ipython() -> bool:\n        \"\"\"Return True if IPython is installed.\"\"\"\n        return importlib.util.find_spec(\"IPython\") is not None\n\n    @staticmethod\n    def has_nbformat() -> bool:\n        \"\"\"Return True if nbformat is installed.\"\"\"\n        return importlib.util.find_spec(\"nbformat\") is not None\n\n------------------------------\n------------------------------\n        return SuccessResponse()\n\n    was_shutdown = session_manager.close_session(session_id)\n    if not was_shutdown:\n        shutdown_server()\n\n    return SuccessResponse()\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_python_isolated() -> bool:\n# Natural Language Annotations: \"\"\"Returns True if not using system Python\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python\"\"\"\n    import sys\n    return not sys.executable.startswith(sys.base_prefix)\n```\n", "```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python.\"\"\"\n    pass\n```\n", "```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python\"\"\"\n    import sys\n    if getattr(sys, 'ps1', False):\n        # Interactive shell\n        return False\n    elif getattr(sys, 'ps2', False):\n        # Second level of interactive shell\n        return False\n    return True\n```\n"]}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\nclass Plain:\n    \"\"\"\n    Wrapper around a value to indicate that it should be displayed\n    without any opinionated formatting.\n    \"\"\"\n\n    def __init__(self, child: Any):\n        self.child = child\n\n------------------------------\n------------------------------\n\n    **Example.**\n\n    ```python\n    # a button that when clicked will have its value set to True;\n    # any cells referencing that button will automatically run.\n    button = mo.ui.run_button()\n    button\n    ```\n\n    ```python\n    slider = mo.ui.slider(1, 10)\n    slider\n    ```\n\n    ```python\n    # if the button hasn't been clicked, don't run.\n    mo.stop(not button.value)\n\n    slider.value\n\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\n\"\"\"Write to a cell's output area.\"\"\"\n\n__all__ = [\n    \"append\",\n    \"clear\",\n    \"replace\",\n    \"replace_at_index\",\n]\n\nfrom marimo._runtime.output._output import (\n    append,\n    clear,\n    replace,\n    replace_at_index,\n)\n\n------------------------------\n------------------------------\n\n        Return True if the disposal is successful and the lifecycle item\n        should be removed from the registry. Return False if the disposal\n        needs to be retried in the next cell lifecycle (note that `create`\n        will not be re-run, only `dispose`).\n        \"\"\"\n        ...\n\n------------------------------\n------------------------------\n# Copyright 2024 Marimo. All rights reserved.\n\"\"\"Message Types\n\nMessages that the kernel sends to the frontend.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport sys\nimport time\nfrom dataclasses import asdict, dataclass, field\nfrom types import ModuleType\nfrom typing import (\n    Any,\n    ClassVar,\n    Dict,\n    List,\n    Literal,\n    Optional,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def missing_modules(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Modules that will fail to import.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    missing = set()\n    for module in self.modules:\n        try:\n            __import__(module)\n        except ImportError:\n            missing.add(module)\n    return missing\n```\n", "```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    missing_modules = set()\n    # Implementation of the function would go here\n```\n", "Here is the function based on the given signature and natural language annotations:\n\n```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    pass\n```\n\nPlease note that this function is not complete yet. It currently doesn't do anything and just passes. You should implement the logic to find out which modules will fail to import.\n"]}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    \"\"\"\n    Memory is used to store all the conversations in the system,\n    which should be initialized when creating a session.\n    \"\"\"\n\n    def __init__(self, session_id: str) -> None:\n        self.session_id = session_id\n        self.conversation = Conversation.init()\n\n    def create_round(self, user_query: str) -> Round:\n        \"\"\"Create a round with the given query.\"\"\"\n        round = Round.create(user_query=user_query)\n        self.conversation.add_round(round)\n        return round\n\n    def get_role_rounds(self, role: RoleName, include_failure_rounds: bool = False) -> List[Round]:\n        \"\"\"Get all the rounds of the given role in the memory.\n        TODO: better do cache here to avoid recreating the round list (new object) every time.\n\n        Args:\n\n------------------------------\n------------------------------\n\n    @property\n    @abstractmethod\n    def env_id(self) -> str:\n        \"\"\"get the environment id of the plugin\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def session_id(self) -> str:\n        \"\"\"get the session id of the plugin\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def execution_id(self) -> str:\n        \"\"\"get the execution id of the plugin\"\"\"\n        ...\n\n    @abstractmethod\n\n------------------------------\n------------------------------\n    \"\"\"A conversation denotes the interaction with the user, which is a collection of rounds.\n    The conversation is also used to construct the Examples.\n\n    Args:\n        id: the unique id of the conversation.\n        rounds: a list of rounds.\n        plugins: a list of plugins that are used in the conversation.\n        enabled: whether the conversation is enabled, used for Example only.\n    \"\"\"\n\n    id: str = \"\"\n    rounds: List[Round] = field(default_factory=list)\n    plugins: List[PluginEntry] = field(default_factory=list)\n    roles: List[str] = field(default_factory=list)\n    enabled: bool = True\n\n    @staticmethod\n    def init():\n        \"\"\"init a conversation with empty rounds and plugins.\"\"\"\n        return Conversation(\n\n------------------------------\n------------------------------\n        else:\n            write_yaml(raw_exp_path, self.conversation.to_dict())\n\n    def from_yaml(self, session_id: str, path: str) -> Memory:\n        \"\"\"Load the memory from a yaml file.\"\"\"\n        conversation = Conversation.from_yaml(path)\n        self.conversation = conversation\n        self.session_id = session_id\n        return self\n\n------------------------------\n------------------------------\n    It should always have a text_message to denote the string message,\n    while other data formats should be put in the attachment.\n    The role can be either a User, a Planner, or others.\n\n    Args:\n        id: the unique id of the post.\n        send_from: the role who sends the post.\n        send_to: the role who receives the post.\n        message: the text message in the post.\n        attachment_list: a list of attachments in the post.\n\n    \"\"\"\n\n    id: str\n    send_from: RoleName\n    send_to: RoleName\n    message: str\n    attachment_list: List[Attachment]\n\n    @staticmethod\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def load_examples(\n# Natural Language Annotations: \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef load_examples(folder: str, role_set: Set[RoleName]) -> List[Conversation]:\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\n    examples = []\n\n    for root, dirs, files in os.walk(folder):\n        for file in files:\n            if file.endswith(\".yaml\"):\n                conversation = Conversation.from_yaml(os.path.join(root, file))\n                if set(conversation.roles).issubset(role_set):\n                    examples.append(conversation)\n\n    return examples\n```\n", "```python\ndef load_examples(folder: str, role_set: Set[RoleName]) -> List[Conversation]:\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\n    # Get all the yaml files in the folder\n    yaml_files = [f for f in os.listdir(folder) if f.endswith('.yaml')]\n\n    # Load each yaml file and parse it into a Conversation object\n    conversations = []\n    for yaml_file in yaml_files:\n        yaml_path = os.path.join(folder, yaml_file)\n        with open(yaml_path, 'r') as file:\n            yaml_data = yaml.safe_load(file)\n            # Check if the roles in the conversation are included in the role_set\n            if any(role in yaml_data['roles'] for role in role_set):\n                conversation = Conversation.from_yaml(yaml_path)\n                conversations.append(conversation)\n\n    return conversations\n```\n", "```python\nfrom typing import List\nfrom pathlib import Path\nfrom .conversation import Conversation\n\ndef load_examples(folder: str, role_set: List[str]) -> List[Conversation]:\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\n    examples = []\n    folder_path = Path(folder)\n\n    for file_path in folder_path.glob('*.yaml'):\n        try:\n            conversation = Conversation.from_yaml(str(file_path))\n\n            # check if the conversation has any of the roles in the role_set\n            if any(role in role_set for role in conversation.roles):\n                examples.append(conversation)\n        except Exception as e:\n            print(f\"Failed to load example from {file_path} with error: {str(e)}\")\n\n    return examples\n```\n"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"wrap text with delimiter\"\"\"\n        return PromptUtil.wrap_text_with_delimiter(\n            text,\n            PromptUtil.DELIMITER_TEMPORAL,\n        )\n\n------------------------------\n------------------------------\n\n    def write_board(self, role_alias: str, bulletin: str) -> None:\n        \"\"\"Add a bulletin to the round.\"\"\"\n        self.board[role_alias] = bulletin\n\n    def read_board(self, role_alias: Optional[str] = None) -> Union[Dict[str, str], str]:\n        \"\"\"Read the bulletin of the round.\"\"\"\n        if role_alias is None:\n            return self.board\n        return self.board.get(role_alias, None)\n\n------------------------------\n------------------------------\n    def execution_id(self) -> str:\n        \"\"\"get the execution id of the plugin\"\"\"\n        ...\n\n    @abstractmethod\n    def add_artifact(\n        self,\n        name: str,\n        file_name: str,\n        type: ArtifactType,\n        val: Any,\n        desc: Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        add an artifact to the execution context\n\n        :param name: the name of the artifact\n        :param file_name: the name of the file\n        :param type: the type of the artifact\n        :param val: the value of the artifact\n\n------------------------------\n------------------------------\n            reverse=True,\n        )[:top_k]\n\n        selected_plugins = [p for p, sim in plugins_rank]\n\n        return selected_plugins\n\n------------------------------\n------------------------------\n\n    @property\n    @abstractmethod\n    def env_id(self) -> str:\n        \"\"\"get the environment id of the plugin\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def session_id(self) -> str:\n        \"\"\"get the session id of the plugin\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def execution_id(self) -> str:\n        \"\"\"get the execution id of the plugin\"\"\"\n        ...\n\n    @abstractmethod\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n# Natural Language Annotations: \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    for plugin in self.selected_plugins:\n        if plugin not in external_plugin_pool:\n            external_plugin_pool.append(plugin)\n```\n", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n        \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\n        # Implementation goes here\n        pass\n```\n", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]) -> None:\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    selected_plugins = self.select_plugins()  # Assuming there's a method select_plugins which returns the selected plugins\n    for plugin in selected_plugins:\n        external_plugin_pool.append(plugin)\n```\n"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            reverse=True,\n        )[:top_k]\n\n        selected_plugins = [p for p, sim in plugins_rank]\n\n        return selected_plugins\n\n------------------------------\n------------------------------\n    \"\"\"A conversation denotes the interaction with the user, which is a collection of rounds.\n    The conversation is also used to construct the Examples.\n\n    Args:\n        id: the unique id of the conversation.\n        rounds: a list of rounds.\n        plugins: a list of plugins that are used in the conversation.\n        enabled: whether the conversation is enabled, used for Example only.\n    \"\"\"\n\n    id: str = \"\"\n    rounds: List[Round] = field(default_factory=list)\n    plugins: List[PluginEntry] = field(default_factory=list)\n    roles: List[str] = field(default_factory=list)\n    enabled: bool = True\n\n    @staticmethod\n    def init():\n        \"\"\"init a conversation with empty rounds and plugins.\"\"\"\n        return Conversation(\n\n------------------------------\n------------------------------\n\n    @property\n    @abstractmethod\n    def env_id(self) -> str:\n        \"\"\"get the environment id of the plugin\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def session_id(self) -> str:\n        \"\"\"get the session id of the plugin\"\"\"\n        ...\n\n    @property\n    @abstractmethod\n    def execution_id(self) -> str:\n        \"\"\"get the execution id of the plugin\"\"\"\n        ...\n\n    @abstractmethod\n\n------------------------------\n------------------------------\n\n        if self.config.enable_auto_plugin_selection:\n            # filter out plugins that are not used in the generated code\n            self.selected_plugin_pool.filter_unused_plugins(code=generated_code)\n\n        if prompt_log_path is not None:\n            self.logger.dump_prompt_file(prompt, prompt_log_path)\n\n        self.tracing.set_span_attribute(\"code\", generated_code)\n\n        return post_proxy.post\n\n    def format_plugins(\n        self,\n        plugin_list: List[PluginEntry],\n    ) -> str:\n        if self.config.load_plugin:\n            return \"\\n\".join(\n                [plugin.format_prompt() for plugin in plugin_list],\n            )\n\n------------------------------\n------------------------------\n        post_proxy.update_send_to(\"Planner\")\n        generated_code = \"\"\n        reply_type: Optional[str] = None\n        for attachment in post_proxy.post.attachment_list:\n            if attachment.type == AttachmentType.reply_type:\n                reply_type = attachment.content\n                break\n        for attachment in post_proxy.post.attachment_list:\n            if attachment.type == AttachmentType.reply_content:\n                if reply_type == \"python\":\n                    generated_code = attachment.content\n                    break\n                elif reply_type == \"text\":\n                    post_proxy.update_message(attachment.content)\n                    break\n\n        if self.config.enable_auto_plugin_selection:\n            # filter out plugins that are not used in the generated code\n            self.selected_plugin_pool.filter_unused_plugins(code=generated_code)\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def filter_unused_plugins(self, code: str):\n# Natural Language Annotations: \"\"\"\n        Filter out plugins that are not used in the code generated by LLM\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n    \"\"\"\n    used_plugins = [plugin for plugin in self.plugins if plugin.env_id in code]\n    self.plugins = used_plugins\n```\n", "```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n    \"\"\"\n    used_plugins = [plugin for plugin in self.plugins if plugin.env_id in code]\n    self.plugins = used_plugins\n```\n", "```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n\n    Args:\n        code (str): The code generated by LLM\n\n    \"\"\"\n    used_plugins = []\n    for plugin in self.plugins:\n        if plugin.env_id in code or plugin.session_id in code or plugin.execution_id in code:\n            used_plugins.append(plugin)\n\n    self.plugins = used_plugins\n```\n"]}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                    text = text[:start_index] + text[end_index + len(delimiter[1]) :]\n                else:\n                    break\n            elif start_index == -1 and end_index == -1:\n                # No more markers found, break the loop\n                break\n            else:\n                # One of the markers is found without the other\n                break\n        return text\n\n    @staticmethod\n    def remove_delimiter(text: str, delimiter: Tuple[str, str]):\n        \"\"\"Remove the specified delimiter from the text.\"\"\"\n        text = text.replace(delimiter[0], \"\")\n        text = text.replace(delimiter[1], \"\")\n        return text\n\n    @staticmethod\n\n\n------------------------------\n------------------------------\nfrom typing import List, Tuple\n\n\nclass PromptUtil:\n    DELIMITER_TEMPORAL: Tuple[str, str] = (\"{{DELIMITER_START_TEMPORAL}}\", \"{{DELIMITER_END_TEMPORAL}}\")\n\n    @staticmethod\n    def wrap_text_with_delimiter(text, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Wrap the provided text with the specified start and end delimiters.\"\"\"\n        return f\"{delimiter[0]}{text}{delimiter[1]}\"\n\n    @staticmethod\n    def get_all_delimiters() -> List[Tuple[str, str]]:\n        \"\"\"Get all the delimiters.\"\"\"\n        return [getattr(PromptUtil, attr) for attr in dir(PromptUtil) if attr.startswith(\"DELIMITER_\")]\n\n    @staticmethod\n    def remove_parts(text: str, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Remove the parts of the text that are wrapped by the specified delimiters.\"\"\"\n        while True:\n\n------------------------------\n------------------------------\n\n    @staticmethod\n    def remove_parts(text: str, delimiter: Tuple[str, str]) -> str:\n        \"\"\"Remove the parts of the text that are wrapped by the specified delimiters.\"\"\"\n        while True:\n            # Find the start of the temporal part\n            start_index = text.find(delimiter[0])\n            # Find the end of the temporal part\n            end_index = text.find(delimiter[1], start_index + len(delimiter[0]))\n\n            # Check if both markers are present\n            if start_index != -1 and end_index != -1:\n                # Ensure that the start marker comes before the end marker\n                if start_index < end_index:\n                    # Remove the temporal part including the markers\n                    text = text[:start_index] + text[end_index + len(delimiter[1]) :]\n                else:\n                    break\n            elif start_index == -1 and end_index == -1:\n                # No more markers found, break the loop\n\n------------------------------\n------------------------------\n                state=round.state,\n                board=copy.deepcopy(round.board),\n            )\n            for post in round.post_list:\n                if post.send_from == role or post.send_to == role:\n                    new_round.add_post(copy.deepcopy(post))\n            rounds_from_role.append(new_round)\n        # Remove the temporal parts from the text of the posts of rounds\n        for round in rounds_from_role[:-1]:\n            for post in round.post_list:\n                post.message = PromptUtil.remove_parts(\n                    post.message,\n                    delimiter=PromptUtil.DELIMITER_TEMPORAL,\n                )\n        # Remove the delimiters from the text of the posts of the last round\n        for post in rounds_from_role[-1].post_list:\n            post.message = PromptUtil.remove_all_delimiters(post.message)\n\n        return rounds_from_role\n\n\n------------------------------\n------------------------------\n        \"\"\"Get all the attachments of the given type.\"\"\"\n        return [attachment.content for attachment in self.attachment_list if attachment.type == type]\n\n    def del_attachment(self, type_list: List[AttachmentType]) -> None:\n        \"\"\"Delete all the attachments of the given type.\"\"\"\n        self.attachment_list = [attachment for attachment in self.attachment_list if attachment.type not in type_list]\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def remove_all_delimiters(text: str) -> str:\n# Natural Language Annotations: \"\"\"Remove all the delimiters from the text.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    delimiters = PromptUtil.get_all_delimiters()\n    for delimiter in delimiters:\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```\n", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    for delimiter in PromptUtil.get_all_delimiters():\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```\n", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    for delimiter in PromptUtil.get_all_delimiters():\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```\n"]}, "reflex-reflex/app.py-_enable_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"The pages of the app.\"\"\"\n\nfrom .chatapp import chatapp_page\nfrom .datatable import datatable_page\nfrom .forms import forms_page\nfrom .graphing import graphing_page\nfrom .home import home_page\n\n------------------------------\n------------------------------\n\"\"\"Temporary shim for Chakra icon class.\"\"\"\n\n------------------------------\n------------------------------\n\"\"\"Init file for the sonner component.\"\"\"\n\nfrom .toast import toast\n\n------------------------------\n------------------------------\n\"\"\"Package for integration tests.\"\"\"\n\n------------------------------\n------------------------------\n\"\"\"Base template for Reflex.\"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _enable_state(self) -> None:\n# Natural Language Annotations: \"\"\"Enable state for the app.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    pass\n```\n", "```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n```\n", "```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n```\n"]}, "reflex-reflex/app.py-_add_optional_endpoints": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"Base template for Reflex.\"\"\"\n\n------------------------------\n------------------------------\n\"\"\"Package for integration tests.\"\"\"\n\n------------------------------\n------------------------------\n\"\"\"Reflex utilities.\"\"\"\n\n------------------------------\n------------------------------\n\"\"\"The Reflex compiler.\"\"\"\n\n------------------------------\n------------------------------\n\"\"\"Core layout components.\"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_optional_endpoints(self):\n# Natural Language Annotations: \"\"\"Add optional api endpoints (_upload).\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    pass\n```\n", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    # Add your implementation here\n    pass\n```\n", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"\n    Add optional API endpoints (_upload).\n\n    This function adds optional API endpoints to provide additional functionalities.\n    \"\"\"\n    pass\n```\n"]}, "reflex-reflex/app.py-add_page": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    arg_spec: ArgsSpec,\n) -> EventSpec:\n    \"\"\"Call an event handler to get the event spec.\n\n    This function will inspect the function signature of the event handler.\n    If it takes in an arg, the arg will be passed to the event handler.\n    Otherwise, the event handler will be called with no args.\n\n    Args:\n        event_handler: The event handler.\n        arg_spec: The lambda that define the argument(s) to pass to the event handler.\n\n    Raises:\n        ValueError: if number of arguments expected by event_handler doesn't match the spec.\n\n    Returns:\n        The event spec from calling the event handler.\n    \"\"\"\n    parsed_args = parse_args_spec(arg_spec)  # type: ignore\n\n\n------------------------------\n------------------------------\n    image: str | None = None,\n    description: str | None = None,\n    meta: list[Any] | None = None,\n    script_tags: list[Any] | None = None,\n    on_load: Any | list[Any] | None = None,\n):\n    \"\"\"Decorate a function as a page.\n\n    rx.App() will automatically call add_page() for any method decorated with page\n    when App.compile is called.\n\n    All defaults are None because they will use the one from add_page().\n\n    Note: the decorated functions still need to be imported.\n\n    Args:\n        route: The route to reach the page.\n        title: The title of the page.\n        image: The favicon of the page.\n        description: The description of the page.\n\n------------------------------\n------------------------------\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an inline or user-defined script.\n\n        If a string is provided as the first child, it will be rendered as an inline script\n        otherwise the `src` prop must be provided.\n\n        The following event triggers are provided:\n\n        on_load: Execute code after the script has finished loading.\n        on_ready: Execute code after the script has finished loading and every\n            time the component is mounted.\n        on_error: Execute code if the script fails to load.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n\n------------------------------\n------------------------------\n    Args:\n        route: The route to reach the page.\n        title: The title of the page.\n        image: The favicon of the page.\n        description: The description of the page.\n        meta: Additional meta to add to the page.\n        on_load: The event handler(s) called when the page load.\n        script_tags: scripts to attach to the page\n\n    Returns:\n        The decorated function.\n    \"\"\"\n\n    def decorator(render_fn):\n        kwargs = {}\n        if route:\n            kwargs[\"route\"] = route\n        if title:\n            kwargs[\"title\"] = title\n        if image:\n\n------------------------------\n------------------------------\n        If there is no page defined on 'index' route, add the 404 page to it.\n        If there is no global catchall defined, add the 404 page with a catchall.\n\n        Args:\n            component: The component to display at the page.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n        \"\"\"\n        if component is None:\n            component = Default404Page.create()\n        self.add_page(\n            component=wait_for_client_redirect(self._generate_component(component)),\n            route=constants.Page404.SLUG,\n            title=title or constants.Page404.TITLE,\n            image=image or constants.Page404.IMAGE,\n            description=description or constants.Page404.DESCRIPTION,\n            on_load=on_load,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_page(\n# Natural Language Annotations: \"\"\"Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_page(\n    self,\n    component: Union[Callable, Component],\n    route: str = None,\n    title: str = None,\n    description: str = None,\n    image: str = None,\n    on_load: Any = None,\n    meta: List[Any] = None,\n):\n    \"\"\"Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    # Function body here\n```\n", "```python\ndef add_page(\n    component, \n    route=None, \n    title=None, \n    description=None, \n    image=None, \n    on_load=None, \n    meta=None\n):\n    if route is None:\n        if callable(component):\n            route = component.__name__\n        else:\n            raise ValueError(\"A route must be provided when the component is not a callable.\")\n\n    # Add your logic to add a page here\n    pass\n```\n", "```python\ndef add_page(\n    component: Callable[[], Component],\n    route: str | None = None,\n    title: str | None = None,\n    description: str | None = None,\n    image: str | None = None,\n    on_load: Any | list[Any] | None = None,\n    meta: list[Any] | None = None,\n):\n    \"\"\"Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    if route is None:\n        route = component.__name__\n\n    if route in self.routes:\n        raise ValueError(\"Route already exists in app.\")\n\n    self.routes[route] = component\n\n    if title is None:\n        title = route\n\n    if description is None:\n        description = ''\n\n    if image is None:\n        image = ''\n\n    if on_load is None:\n        on_load = []\n\n    if meta is None:\n        meta = []\n\n    self.pages.append({\n        'route': route,\n        'title': title,\n        'description': description,\n        'image': image,\n        'on_load': on_load,\n        'meta': meta,\n    })\n```\n"]}, "reflex-reflex/app.py-_setup_overlay_component": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"Avatar components.\"\"\"\n\nfrom __future__ import annotations\n\nfrom reflex.components.chakra import ChakraComponent, LiteralAvatarSize\nfrom reflex.event import EventHandler\nfrom reflex.vars import Var\n\n\nclass Avatar(ChakraComponent):\n    \"\"\"The image that represents the user.\"\"\"\n\n    tag = \"Avatar\"\n\n    # The default avatar used as fallback when name, and src is not specified.\n    icon: Var[str]\n\n    # The label of the icon.\n    icon_label: Var[str]\n\n\n------------------------------\n------------------------------\ndef default_overlay_component() -> Component:\n    \"\"\"Default overlay_component attribute for App.\n\n    Returns:\n        The default overlay_component, which is a connection_modal.\n    \"\"\"\n    return Fragment.create(\n        connection_pulser(),\n        connection_toaster(),\n        *codespaces.codespaces_auto_redirect(),\n    )\n\n\nclass OverlayFragment(Fragment):\n    \"\"\"Alias for Fragment, used to wrap the overlay_component.\"\"\"\n\n    pass\n\n\nclass App(MiddlewareMixin, LifespanMixin, Base):\n\n------------------------------\n------------------------------\n\n\n@serializer\ndef serialize_component(comp: Component):\n    \"\"\"Serialize a component.\n\n    Args:\n        comp: The component to serialize.\n\n    Returns:\n        The serialized component.\n    \"\"\"\n    return str(comp)\n\n\nclass StatefulComponent(BaseComponent):\n    \"\"\"A component that depends on state and is rendered outside of the page component.\n\n    If a StatefulComponent is used in multiple pages, it will be rendered to a common file and\n    imported into each page that uses it.\n\n------------------------------\n------------------------------\n\n    # When true, signifies that it is purely visual, carries no semantic meaning, and ensures it is not present in the accessibility tree.\n    decorative: Var[bool]\n\n\n# Alias to divider.\ndivider = separator = Separator.create\n\n------------------------------\n------------------------------\n        The serialized value, or None if a serializer is not found.\n    \"\"\"\n    # Get the serializer for the type.\n    serializer = get_serializer(type(value))\n\n    # If there is no serializer, return None.\n    if serializer is None:\n        if get_type:\n            return None, None\n        return None\n\n    # Serialize the value.\n    serialized = serializer(value)\n\n    # Return the serialized value and the type.\n    if get_type:\n        return serialized, get_serializer_type(type(value))\n    else:\n        return serialized\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _setup_overlay_component(self):\n# Natural Language Annotations: \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _setup_overlay_component(self):\n    \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\n    if not self.state and not self.overlay_component:\n        self.overlay_component = Fragment.create(\n            connection_pulser(),\n            connection_toaster(),\n            *codespaces.codespaces_auto_redirect(),\n        )\n```\n", "```python\ndef _setup_overlay_component(self):\n    if not isinstance(self.state, State):\n        self.overlay_component = Fragment.create(\n            connection_pulser(),\n            connection_toaster(),\n            *codespaces.codespaces_auto_redirect(),\n        )\n```\n", "```python\ndef _setup_overlay_component(self):\n    \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\n    if not self.state and not self.overlay_component:\n        self.overlay_component = Fragment.create()\n    elif not self.state and self.overlay_component:\n        if default_overlay_component() != self.overlay_component:\n            self.overlay_component = Fragment.create(\n                self.overlay_component, default_overlay_component()\n            )\n```\n"]}, "reflex-reflex/app.py-_compile": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n\n        Raises:\n            ValueError: If the style is not set.\n        \"\"\"\n        if cls.STYLE is None:\n            raise ValueError(\"STYLE should be set\")\n        return compile_theme(cls.STYLE)\n\n------------------------------\n------------------------------\n\n\n@serializer\ndef serialize_component(comp: Component):\n    \"\"\"Serialize a component.\n\n    Args:\n        comp: The component to serialize.\n\n    Returns:\n        The serialized component.\n    \"\"\"\n    return str(comp)\n\n\nclass StatefulComponent(BaseComponent):\n    \"\"\"A component that depends on state and is rendered outside of the page component.\n\n    If a StatefulComponent is used in multiple pages, it will be rendered to a common file and\n    imported into each page that uses it.\n\n------------------------------\n------------------------------\n\n    Args:\n        pages: The pages to extract stateful components from.\n\n    Returns:\n        The path and code of the compiled stateful components.\n    \"\"\"\n    output_path = utils.get_stateful_components_path()\n\n    # Compile the stateful components.\n    page_components = [StatefulComponent.compile_from(page) or page for page in pages]\n    code = _compile_stateful_components(page_components)\n    return output_path, code, page_components\n\n\ndef compile_tailwind(\n    config: dict,\n):\n    \"\"\"Compile the Tailwind config.\n\n\n------------------------------\n------------------------------\n        state: The app state.\n        theme: The top-level app theme.\n\n    Returns:\n        The path and code of the compiled context.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_context_path()\n\n    return output_path, _compile_contexts(state, theme)\n\n\ndef compile_page(\n    path: str, component: Component, state: Type[BaseState]\n) -> tuple[str, str]:\n    \"\"\"Compile a single page.\n\n    Args:\n        path: The path to compile the page to.\n        component: The component to compile.\n\n------------------------------\n------------------------------\n    \"\"\"Compile a single page.\n\n    Args:\n        path: The path to compile the page to.\n        component: The component to compile.\n        state: The app state.\n\n    Returns:\n        The path and code of the compiled page.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_page_path(path)\n\n    # Add the style to the component.\n    code = _compile_page(component, state)\n    return output_path, code\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _compile(self, export: bool = False):\n# Natural Language Annotations: \"\"\"Compile the app and output it to the pages folder.\n\n        Args:\n            export: Whether to compile the app for export.\n\n        Raises:\n            ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n```\n", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    pass\n```\n", "Sure, here is the function based on your request:\n\n```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    # Check state\n    if any(page.uses_state() for page in self.pages) and rx.State is None:\n        raise ReflexRuntimeError(\"App uses state, but no rx.State subclass is defined\")\n\n    # Compile theme\n    theme_path, theme_code = self.compile_theme()\n    utils.write_output(theme_path, theme_code)\n\n    # Compile stateful components\n    stateful_path, stateful_code, stateful_components = self.compile_stateful_components(self.pages)\n    utils.write_output(stateful_path, stateful_code)\n\n    # Compile context\n    context_path, context_code = self.compile_context(self.state, self.theme)\n    utils.write_output(context_path, context_code)\n\n    # Compile pages\n    for path, component in self.pages.items():\n        page_path, page_code = self.compile_page(path, component, self.state)\n        utils.write_output(page_path, page_code)\n\n    # Compile tailwind\n    tailwind_path, tailwind_code = self.compile_tailwind(self.config)\n    utils.write_output(tailwind_path, tailwind_code)\n```\n"]}, "reflex-reflex/app.py-modify_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def state_manager(self) -> StateManager:\n        \"\"\"Get the state manager.\n\n        Returns:\n            The initialized state manager.\n\n        Raises:\n            ValueError: if the state has not been initialized.\n        \"\"\"\n        if self._state_manager is None:\n            raise ValueError(\"The state manager has not been initialized.\")\n        return self._state_manager\n\n    @staticmethod\n    def _generate_component(component: Component | ComponentCallable) -> Component:\n        \"\"\"Generate a component from a callable.\n\n        Args:\n            component: The component function to call or Component to return as-is.\n\n\n------------------------------\n------------------------------\n        self,\n        token: str,\n        top_level: bool = True,\n        get_substates: bool = True,\n        parent_state: BaseState | None = None,\n    ) -> BaseState:\n        \"\"\"Get the state for a token.\n\n        Args:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n\n        Raises:\n            RuntimeError: when the state_cls is not specified in the token\n        \"\"\"\n\n------------------------------\n------------------------------\n    ) -> None:\n        \"\"\"Validate the dependencies of the vars in the app.\n\n        Args:\n            state: The state to validate the dependencies for.\n\n        Raises:\n            VarDependencyError: When a computed var has an invalid dependency.\n        \"\"\"\n        if not self.state:\n            return\n\n        if not state:\n            state = self.state\n\n        for var in state.computed_vars.values():\n            if not var._cache:\n                continue\n            deps = var._deps(objclass=state)\n            for dep in deps:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n    def _check_valid(self, handler: EventHandler, events: Any) -> Any:\n        \"\"\"Check if the events yielded are valid. They must be EventHandlers or EventSpecs.\n\n        Args:\n            handler: EventHandler.\n            events: The events to be checked.\n\n        Raises:\n            TypeError: If any of the events are not valid.\n\n\n------------------------------\n------------------------------\n\n        Returns:\n            The state for the token.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    async def set_state(self, token: str, state: BaseState):\n        \"\"\"Set the state for a token.\n\n        Args:\n            token: The token to set the state for.\n            state: The state to set.\n        \"\"\"\n        pass\n\n    @abstractmethod\n    @contextlib.asynccontextmanager\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state for a token while holding exclusive lock.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n# Natural Language Annotations: \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if self._state_manager is None:\n        raise RuntimeError(\"The app has not been initialized yet.\")\n\n    state = await self._state_manager.get_state(token)\n    yield state\n```\n", "```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if self._state_manager is None:\n        raise RuntimeError(\"The app has not been initialized yet.\")\n\n    async with self._state_manager.modify_state(token) as state:\n        yield state\n```\n", "```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not self.state:\n        raise RuntimeError(\"The app has not been initialized yet.\")\n\n    state = self.state_manager().get_state(token)\n\n    async with self.state_manager().lock(token):\n        yield state\n```\n"]}, "reflex-reflex/vars.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    # Whether this is a local javascript variable.\n    _var_is_local: bool = dataclasses.field(default=False)\n\n    # Whether the var is a string literal.\n    _var_is_string: bool = dataclasses.field(default=False)\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool = dataclasses.field(default=False)\n\n    # Extra metadata associated with the Var\n    _var_data: Optional[VarData] = dataclasses.field(default=None)\n\n    def __hash__(self) -> int:\n        \"\"\"Define a hash function for a var.\n\n        Returns:\n            The hash of the var.\n        \"\"\"\n        return hash((self._var_name, str(self._var_type)))\n\n\n------------------------------\n------------------------------\n    @property\n    def _var_is_local(self) -> bool:\n        \"\"\"Whether this is a local javascript variable.\n\n        Returns:\n            False\n        \"\"\"\n        return False\n\n    @property\n    def _var_is_string(self) -> bool:\n        \"\"\"Whether the var is a string literal.\n\n        Returns:\n            False\n        \"\"\"\n        return False\n\n    @property\n    def _var_full_name_needs_state_prefix(self) -> bool:\n\n------------------------------\n------------------------------\n\nclass Var:\n    \"\"\"An abstract var.\"\"\"\n\n    # The name of the var.\n    _var_name: str\n\n    # The type of the var.\n    _var_type: Type\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool\n\n    # Whether the var is a string literal.\n    _var_is_string: bool\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool\n\n    # Extra metadata associated with the Var\n\n------------------------------\n------------------------------\n            ),\n        )\n        return ImmutableVar(**field_values)\n\n    @classmethod\n    def create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n\n------------------------------\n------------------------------\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n            TypeError: If _var_is_local or _var_is_string is not None.\n        \"\"\"\n        if _var_is_local is not None:\n            raise TypeError(\n                \"The _var_is_local argument is not supported for ImmutableVar.\"\n            )\n\n        if _var_is_string is not None:\n            raise TypeError(\n                \"The _var_is_string argument is not supported for ImmutableVar.\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    \"\"\"Create a var from a value.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n\n    Raises:\n        VarTypeError: If the value is JSON-unserializable.\n    \"\"\"\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n\n    if _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_string argument is not supported for ImmutableVar.\"\n        )\n```\n", "```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    \"\"\"Create a var from a value.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n\n    Raises:\n        VarTypeError: If the value is JSON-unserializable.\n        TypeError: If _var_is_local or _var_is_string is not None.\n    \"\"\"\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n\n    if _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_string argument is not supported for ImmutableVar.\"\n        )\n```\n", "```python\ndef create(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var | None:\n    \"\"\"Create a var from a value.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n\n    Raises:\n        VarTypeError: If the value is JSON-unserializable.\n    \"\"\"\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n\n    if _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_string argument is not supported for ImmutableVar.\"\n        )\n\n    try:\n        # Create and return the var from the value.\n        # Replace with actual implementation.\n        pass\n    except json.JSONDecodeError:\n        raise VarTypeError(\"The value is JSON-unserializable.\")\n```\n"]}, "reflex-reflex/vars.py-create_safe": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    # Whether this is a local javascript variable.\n    _var_is_local: bool = dataclasses.field(default=False)\n\n    # Whether the var is a string literal.\n    _var_is_string: bool = dataclasses.field(default=False)\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool = dataclasses.field(default=False)\n\n    # Extra metadata associated with the Var\n    _var_data: Optional[VarData] = dataclasses.field(default=None)\n\n    def __hash__(self) -> int:\n        \"\"\"Define a hash function for a var.\n\n        Returns:\n            The hash of the var.\n        \"\"\"\n        return hash((self._var_name, str(self._var_type)))\n\n\n------------------------------\n------------------------------\n\nclass Var:\n    \"\"\"An abstract var.\"\"\"\n\n    # The name of the var.\n    _var_name: str\n\n    # The type of the var.\n    _var_type: Type\n\n    # Whether this is a local javascript variable.\n    _var_is_local: bool\n\n    # Whether the var is a string literal.\n    _var_is_string: bool\n\n    # _var_full_name should be prefixed with _var_state\n    _var_full_name_needs_state_prefix: bool\n\n    # Extra metadata associated with the Var\n\n------------------------------\n------------------------------\n            self._var_name == other._var_name\n            and self._var_type == other._var_type\n            and self._var_is_local == other._var_is_local\n            and self._var_full_name_needs_state_prefix\n            == other._var_full_name_needs_state_prefix\n            and self._var_data == other._var_data\n        )\n\n    def _merge(self, other) -> Var:\n        \"\"\"Merge two or more dicts.\n\n        Args:\n            other: The other var to merge.\n\n        Returns:\n            The merged var.\n        \"\"\"\n        if other is None:\n            return self._replace()\n        if not isinstance(other, Var):\n\n------------------------------\n------------------------------\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n            TypeError: If _var_is_local or _var_is_string is not None.\n        \"\"\"\n        if _var_is_local is not None:\n            raise TypeError(\n                \"The _var_is_local argument is not supported for ImmutableVar.\"\n            )\n\n        if _var_is_string is not None:\n            raise TypeError(\n                \"The _var_is_string argument is not supported for ImmutableVar.\"\n\n------------------------------\n------------------------------\n            ),\n        )\n        return ImmutableVar(**field_values)\n\n    @classmethod\n    def create(\n        cls,\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n    ) -> Var | None:\n        \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local. Deprecated.\n            _var_is_string: Whether the var is a string literal. Deprecated.\n            _var_data: Additional hooks and imports associated with the Var.\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_safe(\n# Natural Language Annotations: \"\"\"Create a var from a value, asserting that it is not None.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_safe(\n    value: Any,\n    _var_is_local: bool | None = None,\n    _var_is_string: bool | None = None,\n    _var_data: VarData | None = None,\n) -> Var:\n    \"\"\"Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    if value is None:\n        raise ValueError(\"The value cannot be None.\")\n\n    return ImmutableVar.create(value, _var_is_local, _var_is_string, _var_data)\n```\n", "```python\ndef create_safe(\n    value: Any,\n    _var_is_local: bool = False,\n    _var_is_string: bool = False,\n    _var_data: VarData | None = None,\n) -> Var:\n    assert value is not None, \"Value cannot be None\"\n    if _var_is_local:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n\n    if _var_is_string:\n        raise TypeError(\n            \"The _var_is_string argument is not supported for ImmutableVar.\"\n        )\n\n    field_values = dict(\n        value=value,\n        _var_is_local=_var_is_local,\n        _var_is_string=_var_is_string,\n        _var_data=_var_data,\n    )\n\n    return ImmutableVar(**field_values)\n```\n", "```python\ndef create_safe(\n        value: Any,\n        _var_is_local: bool | None = None,\n        _var_is_string: bool | None = None,\n        _var_data: VarData | None = None,\n) -> Var | None:\n    \"\"\"Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    if value is None:\n        raise ValueError(\"The value cannot be None.\")\n\n    if _var_is_local is not None:\n        raise TypeError(\n            \"The _var_is_local argument is not supported for ImmutableVar.\"\n        )\n\n    if _var_is_string is not None:\n        raise TypeError(\n            \"The _var_is_string argument is not supported for ImmutableVar.\"\n        )\n\n    field_values = dict(\n        value=value,\n        _var_is_local=_var_is_local,\n        _var_is_string=_var_is_string,\n        _var_data=_var_data,\n    )\n\n    return ImmutableVar(**field_values)\n```\n"]}, "reflex-reflex/vars.py-foreach": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return self.operation(fn=\"-\")\n\n    def __abs__(self) -> Var:\n        \"\"\"Get the absolute value of a var.\n\n        Returns:\n            A var with the absolute value.\n        \"\"\"\n        return self.operation(fn=\"Math.abs\")\n\n    def length(self) -> Var:\n        \"\"\"Get the length of a list var.\n\n        Returns:\n            A var with the absolute value.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\n        if not types._issubclass(self._var_type, List):\n\n------------------------------\n------------------------------\n\n        Args:\n            other: The power to raise to.\n\n        Returns:\n            A var representing the power.\n        \"\"\"\n        return self.operation(\",\", other, fn=\"Math.pow\")\n\n    def __rpow__(self, other: Var) -> Var:\n        \"\"\"Raise a var to a power.\n\n        Args:\n            other: The power to raise to.\n\n        Returns:\n            A var representing the power.\n        \"\"\"\n        return self.operation(\",\", other, flip=True, fn=\"Math.pow\")\n\n\n------------------------------\n------------------------------\n        \"\"\"Generate a component from a callable.\n\n        Args:\n            component: The component function to call or Component to return as-is.\n\n        Returns:\n            The generated component.\n\n        Raises:\n            VarOperationTypeError: When an invalid component var related function is passed.\n            TypeError: When an invalid component function is passed.\n            exceptions.MatchTypeError: If the return types of match cases in rx.match are different.\n        \"\"\"\n        from reflex.utils.exceptions import VarOperationTypeError\n\n        try:\n            return component if isinstance(component, Component) else component()\n        except exceptions.MatchTypeError:\n            raise\n        except TypeError as e:\n\n------------------------------\n------------------------------\n        )\n\n    def operation(\n        self,\n        op: str = \"\",\n        other: Var | None = None,\n        type_: Type | None = None,\n        flip: bool = False,\n        fn: str | None = None,\n        invoke_fn: bool = False,\n    ) -> Var:\n        \"\"\"Perform an operation on a var.\n\n        Args:\n            op: The operation to perform.\n            other: The other var to perform the operation on.\n            type_: The type of the operation result.\n            flip: Whether to flip the order of the operation.\n            fn: A function to apply to the operation.\n            invoke_fn: Whether to invoke the function.\n\n------------------------------\n------------------------------\n        v1: Var | int = 0,\n        v2: Var | int | None = None,\n        step: Var | int | None = None,\n    ) -> Var:\n        \"\"\"Return an iterator over indices from v1 to v2 (or 0 to v1).\n\n        Args:\n            v1: The start of the range or end of range if v2 is not given.\n            v2: The end of the range.\n            step: The number of numbers between each item.\n\n        Returns:\n            A var representing range operation.\n\n        Raises:\n            VarTypeError: If the var is not an int.\n        \"\"\"\n        if not isinstance(v1, Var):\n            v1 = Var.create_safe(v1)\n        if v1._var_type != int:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def foreach(self, fn: Callable) -> Var:\n# Natural Language Annotations: \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not types._issubclass(self._var_type, List):\n        raise VarTypeError(\"The var is not a list.\")\n    return self.operation(fn=fn)\n```\n", "```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not types._issubclass(self._var_type, List):\n        raise VarTypeError(\"The var is not a list.\")\n    return [fn(i) for i in self._var]\n```\n", "```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not types._issubclass(self._var_type, List):\n        raise VarTypeError(f\"Expected a list but got {self._var_type}\")\n\n    result = [fn(item) for item in self._var]\n    return Var(result, List[type(result[0])])\n```\n"]}, "reflex-reflex/vars.py-get_default_value": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        ]\n\n    def get_component(self, tag: str, **props) -> Component:\n        \"\"\"Get the component for a tag and props.\n\n        Args:\n            tag: The tag of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n\n        Raises:\n            ValueError: If the tag is invalid.\n        \"\"\"\n        # Check the tag is valid.\n        if tag not in self.component_map:\n            raise ValueError(f\"No markdown component found for tag: {tag}.\")\n\n        special_props = {_PROPS}\n\n------------------------------\n------------------------------\n    def compile_custom_components(cls):\n        \"\"\"Compile the custom components.\n\n        Returns:\n            The path and code of the compiled custom components.\n\n        Raises:\n            ValueError: If the custom components are not set.\n        \"\"\"\n        if cls.CUSTOM_COMPONENTS is None:\n            raise ValueError(\"CUSTOM_COMPONENTS should be set\")\n        return compile_components(cls.CUSTOM_COMPONENTS)\n\n    @classmethod\n    def compile_theme(cls):\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n\n\n------------------------------\n------------------------------\n    @classmethod\n    def compile_app(cls):\n        \"\"\"Compile the app.\n\n        Returns:\n            The path and code of the compiled app.\n\n        Raises:\n            ValueError: If the app root is not set.\n        \"\"\"\n        if cls.COMPILE_APP_APP_ROOT is None:\n            raise ValueError(\"COMPILE_APP_APP_ROOT should be set\")\n        return compile_app(cls.COMPILE_APP_APP_ROOT)\n\n    @classmethod\n    def compile_custom_components(cls):\n        \"\"\"Compile the custom components.\n\n        Returns:\n            The path and code of the compiled custom components.\n\n------------------------------\n------------------------------\n        return self.operation(fn=\"-\")\n\n    def __abs__(self) -> Var:\n        \"\"\"Get the absolute value of a var.\n\n        Returns:\n            A var with the absolute value.\n        \"\"\"\n        return self.operation(fn=\"Math.abs\")\n\n    def length(self) -> Var:\n        \"\"\"Get the length of a list var.\n\n        Returns:\n            A var with the absolute value.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\n        if not types._issubclass(self._var_type, List):\n\n------------------------------\n------------------------------\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n\n        Raises:\n            ValueError: If the style is not set.\n        \"\"\"\n        if cls.STYLE is None:\n            raise ValueError(\"STYLE should be set\")\n        return compile_theme(cls.STYLE)\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_default_value(self) -> Any:\n# Natural Language Annotations: \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\n\n    Returns:\n        The default value of the var.\n\n    Raises:\n        ImportError: If the var is a dataframe and pandas is not installed.\n    \"\"\"\n    if self.var_type == DataFrame and not pandas_installed:\n        raise ImportError(\"Pandas is not installed.\")\n    return self.default_value\n```\n", "```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\n\n    Returns:\n        The default value of the var.\n\n    Raises:\n        ImportError: If the var is a dataframe and pandas is not installed.\n    \"\"\"\n    try:\n        if self._var_type == DataFrame:\n            try:\n                import pandas as pd\n            except ImportError:\n                raise ImportError(\"Pandas is not installed.\")\n            return pd.DataFrame()\n        else:\n            return None\n    except Exception as e:\n        raise e\n```\n", "```python\ndef get_default_value(self) -> Any:\n    \"\"\"Get the default value of the var.\n\n    Returns:\n        The default value of the var.\n\n    Raises:\n        ImportError: If the var is a dataframe and pandas is not installed.\n    \"\"\"\n    if self._var_type == DataFrame and not HAS_PANDAS:\n        raise ImportError(\"Pandas is not installed. Cannot get default value for dataframe.\")\n    return self._default_value\n```\n"]}, "reflex-reflex/state.py-get_skip_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return code\n\n    def _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        Args:\n            other: The other var to divide.\n\n        Returns:\n            A var representing the quotient.\n        \"\"\"\n        return self.operation(\"/\", other, fn=\"Math.floor\")\n\n    def __mod__(self, other: Var) -> Var:\n        \"\"\"Get the remainder of two vars.\n\n        Args:\n            other: The other var to divide.\n\n        Returns:\n            A var representing the remainder.\n        \"\"\"\n        return self.operation(\"%\", other)\n\n    def __rmod__(self, other: Var) -> Var:\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_skip_vars(cls) -> set[str]:\n# Natural Language Annotations: \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    return set()\n```\n", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    return set()\n```\n", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    return cls._skip_vars\n```\n"]}, "reflex-reflex/state.py-add_var": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Ensure that the value is an int type or str percentage.\n\n        Unfortunately str Vars cannot be checked and are implicitly not allowed.\n\n        Args:\n            name: The name of the prop.\n            value: The value to check.\n\n        Raises:\n            ValueError: If the value is not an int type or str percentage.\n        \"\"\"\n        if value is None:\n            return\n        if isinstance(value, int):\n            return\n        if isinstance(value, str) and value.endswith(\"%\"):\n            return\n        if isinstance(value, Var) and issubclass(value._var_type, int):\n            return\n        raise ValueError(\n\n------------------------------\n------------------------------\n            setattr(self, key, value)\n        return self\n\n    @classmethod\n    def get_fields(cls) -> dict[str, Any]:\n        \"\"\"Get the fields of the object.\n\n        Returns:\n            The fields of the object.\n        \"\"\"\n        return cls.__fields__\n\n    @classmethod\n    def add_field(cls, var: Any, default_value: Any):\n        \"\"\"Add a pydantic field after class definition.\n\n        Used by State.add_var() to correctly handle the new variable.\n\n        Args:\n            var: The variable to add a pydantic field for.\n\n------------------------------\n------------------------------\n            type_: The type of resource to increment.\n        \"\"\"\n        for resource in self.resources:\n            if resource[\"type_\"] == type_:\n                resource[\"count\"] += 1\n                break\n\n    def decrement(self, type_: str):\n        \"\"\"Decrement the count of a resource type.\n\n        Args:\n            type_: The type of resource to decrement.\n        \"\"\"\n        for resource in self.resources:\n            if resource[\"type_\"] == type_ and resource[\"count\"] > 0:\n                resource[\"count\"] -= 1\n                break\n\n------------------------------\n------------------------------\n\ndef is_backend_base_variable(name: str, cls: Type) -> bool:\n    \"\"\"Check if this variable name correspond to a backend variable.\n\n    Args:\n        name: The name of the variable to check\n        cls: The class of the variable to check\n\n    Returns:\n        bool: The result of the check\n    \"\"\"\n    if name in RESERVED_BACKEND_VAR_NAMES:\n        return False\n\n    if not name.startswith(\"_\"):\n        return False\n\n    if name.startswith(\"__\"):\n        return False\n\n\n------------------------------\n------------------------------\n    Args:\n        route: The route to get the arguments for.\n\n    Returns:\n        The route arguments.\n    \"\"\"\n    args = {}\n\n    def add_route_arg(match: re.Match[str], type_: str):\n        \"\"\"Add arg from regex search result.\n\n        Args:\n            match: Result of a regex search\n            type_: The assigned type for this arg\n\n        Raises:\n            ValueError: If the route is invalid.\n        \"\"\"\n        arg_name = match.groups()[0]\n        if arg_name in args:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_var(cls, name: str, type_: Any, default_value: Any = None):\n# Natural Language Annotations: \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if not isinstance(name, str):\n        raise TypeError(\"name should be a string\")\n\n    if not isinstance(type_, type):\n        raise TypeError(\"type_ should be a type\")\n\n    if name in cls.__fields__:\n        raise NameError(f\"A variable with name {name} already exists\")\n\n    cls.__fields__[name] = FieldInfo(default=default_value, annotation=type_)\n\n    setattr(cls, name, default_value)\n```\n", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    # Check if the variable already exists\n    fields = cls.get_fields()\n    if name in fields:\n        raise NameError(f\"A variable with the name '{name}' already exists.\")\n\n    # Create a new field for the variable\n    field_info = FieldInfo(\n        annotation=type_,\n        default=default_value,\n        required=default_value is None,\n    )\n\n    # Add the new field to the class fields\n    cls.__fields__[name] = field_info\n```\n", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"A variable of name {name} already exists\")\n    setattr(cls, name, default_value)\n    # If you want to add a variable to all instances of the class, you could iterate over them and add the attribute\n    for instance in cls.__dict__.values():\n        if isinstance(instance, cls):\n            setattr(instance, name, default_value)\n```\n"]}, "reflex-reflex/state.py-reset": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\"\"\"Custom Exceptions.\"\"\"\n\n\nclass ReflexError(Exception):\n    \"\"\"Base exception for all Reflex exceptions.\"\"\"\n\n\nclass ReflexRuntimeError(ReflexError, RuntimeError):\n    \"\"\"Custom RuntimeError for Reflex.\"\"\"\n\n\nclass UploadTypeError(ReflexError, TypeError):\n    \"\"\"Custom TypeError for upload related errors.\"\"\"\n\n\nclass EnvVarValueError(ReflexError, ValueError):\n    \"\"\"Custom ValueError raised when unable to convert env var to expected type.\"\"\"\n\n\nclass ComponentTypeError(ReflexError, TypeError):\n\n------------------------------\n------------------------------\n\"\"\"Constants used to compile element classes.\"\"\"\n\nfrom .html import *\nfrom .react import *\nfrom .reflex import *\n\n------------------------------\n------------------------------\n\"\"\"Init file for the sonner component.\"\"\"\n\nfrom .toast import toast\n\n------------------------------\n------------------------------\n\"\"\"Default mixin for all app mixins.\"\"\"\n\nfrom reflex.base import Base\n\n\nclass AppMixin(Base):\n    \"\"\"Define the base class for all app mixins.\"\"\"\n\n    def _init_mixin(self):\n        \"\"\"Initialize the mixin.\n\n        Any App mixin can override this method to perform any initialization.\n        \"\"\"\n        ...\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def _reset_client_storage(self):\n        \"\"\"Reset client storage base vars to their default values.\"\"\"\n        # Client-side storage is reset during hydrate so that clearing cookies\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def reset(self):\n# Natural Language Annotations: \"\"\"Reset all the base vars to their default values.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef reset(self):\n    \"\"\"\n    Reset all the base vars to their default values.\n    \"\"\"\n    # Implement your reset logic here\n    pass\n```\n", "```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    # Client-side storage is reset during hydrate so that clearing cookies\n    # or local storage will not affect the state of the application.\n    self._reset_client_storage()\n```\n", "Here is the code for the function based on the description you provided:\n\n```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    # Client-side storage is reset during hydrate so that clearing cookies\n    self._reset_client_storage()\n```\n"]}, "reflex-reflex/state.py-get_state": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def _mark_dirty(\n        self,\n        wrapped=None,\n        instance=None,\n        args=tuple(),\n        kwargs=None,\n    ) -> Any:\n        \"\"\"Raise an exception when an attempt is made to modify the object.\n\n        Intended for use with `FunctionWrapper` from the `wrapt` library.\n\n        Args:\n            wrapped: The wrapped function.\n            instance: The instance of the wrapped function.\n            args: The args for the wrapped function.\n            kwargs: The kwargs for the wrapped function.\n\n        Returns:\n            The result of the wrapped function.\n\n\n------------------------------\n------------------------------\n        \"\"\"Convert the events to a StateUpdate.\n\n        Fixes the events and checks for validity before converting.\n\n        Args:\n            handler: The handler where the events originated from.\n            events: The events to queue with the update.\n            final: Whether the handler is done processing.\n\n        Returns:\n            The valid StateUpdate containing the events and final flag.\n        \"\"\"\n        # get the delta from the root of the state tree\n        state = self\n        while state.parent_state is not None:\n            state = state.parent_state\n\n        token = self.router.session.client_token\n\n        # Convert valid EventHandler and EventSpec into Event\n\n------------------------------\n------------------------------\n\n    @classmethod\n    def _set_var(cls, prop: BaseVar):\n        \"\"\"Set the var as a class member.\n\n        Args:\n            prop: The var instance to set.\n        \"\"\"\n        setattr(cls, prop._var_name, prop)\n\n    @classmethod\n    def _create_event_handler(cls, fn):\n        \"\"\"Create an event handler for the given function.\n\n        Args:\n            fn: The function to create an event handler for.\n\n        Returns:\n            The event handler.\n        \"\"\"\n\n------------------------------\n------------------------------\n        self,\n        token: str,\n        top_level: bool = True,\n        get_substates: bool = True,\n        parent_state: BaseState | None = None,\n    ) -> BaseState:\n        \"\"\"Get the state for a token.\n\n        Args:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n\n        Raises:\n            RuntimeError: when the state_cls is not specified in the token\n        \"\"\"\n\n------------------------------\n------------------------------\n    def _get_state_from_cache(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get a state instance from the cache.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\n        if self.parent_state is None:\n            root_state = self\n        else:\n            root_state = self._get_parent_states()[-1][1]\n        return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n\n    async def _get_state_from_redis(self, state_cls: Type[BaseState]) -> BaseState:\n        \"\"\"Get a state instance from redis.\n\n        Args:\n            state_cls: The class of the state.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n# Natural Language Annotations: \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    if self.parent_state is None:\n        root_state = self\n    else:\n        root_state = self._get_parent_states()[-1][1]\n    return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n```\n", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    if self.parent_state is None:\n        root_state = self\n    else:\n        root_state = self._get_parent_states()[-1][1]\n    return root_state.get_substate(state_cls.get_full_name().split(\".\"))\n```\n", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    if self.redis_client.connected:\n        return await self._get_state_from_redis(state_cls)\n    else:\n        return self._get_state_from_cache(state_cls)\n```\n"]}, "reflex-reflex/state.py-_process": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            }\n        super().__init__(*args, **kwargs)\n\n\n\n\n\n\n\n\n\n    def add_props(self, **kwargs: Optional[Any]) -> Tag:\n        \"\"\"Add props to the tag.\n\n        Args:\n            **kwargs: The props to add.\n\n        Returns:\n            The tag with the props added.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n        )\n\n    async def _process_event(\n        self, handler: EventHandler, state: BaseState | StateProxy, payload: Dict\n    ) -> AsyncIterator[StateUpdate]:\n        \"\"\"Process event.\n\n        Args:\n            handler: EventHandler to process.\n            state: State to process the handler.\n            payload: The event payload.\n\n        Yields:\n            StateUpdate object\n        \"\"\"\n        from reflex.utils import telemetry\n\n        # Get the function to process the event.\n        fn = functools.partial(handler.fn, state)\n\n\n------------------------------\n------------------------------\nclass Middleware(Base, ABC):\n    \"\"\"Middleware to preprocess and postprocess requests.\"\"\"\n\n    async def preprocess(\n        self, app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate]:\n        \"\"\"Preprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional state update to return.\n        \"\"\"\n        return None\n\n    async def postprocess(\n        self, app: App, state: BaseState, event: Event, update: StateUpdate\n\n------------------------------\n------------------------------\n        \"\"\"\n        return None\n\n    async def postprocess(\n        self, app: App, state: BaseState, event: Event, update: StateUpdate\n    ) -> StateUpdate:\n        \"\"\"Postprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to postprocess.\n            update: The current state update.\n\n        Returns:\n            An optional state to return.\n        \"\"\"\n        return update\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n# Natural Language Annotations: \"\"\"Obtain event info and process event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n```\n", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n```\n", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Code to get event info and process event\n    # ...\n```\n"]}, "reflex-reflex/state.py-_dirty_computed_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    # The computed vars of the class.\n    computed_vars: ClassVar[Dict[str, ComputedVar]] = {}\n\n    # Vars inherited by the parent state.\n    inherited_vars: ClassVar[Dict[str, Var]] = {}\n\n    # Backend base vars that are never sent to the client.\n    backend_vars: ClassVar[Dict[str, Any]] = {}\n\n    # Backend base vars inherited\n    inherited_backend_vars: ClassVar[Dict[str, Any]] = {}\n\n    # The event handlers.\n    event_handlers: ClassVar[Dict[str, EventHandler]] = {}\n\n    # A set of subclassses of this class.\n    class_subclasses: ClassVar[Set[Type[BaseState]]] = set()\n\n    # Mapping of var name to set of computed variables that depend on it\n    _computed_var_dependencies: ClassVar[Dict[str, Set[str]]] = {}\n\n------------------------------\n------------------------------\n    Args:\n        substate_key: The substate key.\n\n    Returns:\n        Tuple of token and state name.\n    \"\"\"\n    token, _, state_name = substate_key.partition(\"_\")\n    return token, state_name\n\n\nclass EventHandlerSetVar(EventHandler):\n    \"\"\"A special event handler to wrap setvar functionality.\"\"\"\n\n    state_cls: Type[BaseState]\n\n    def __init__(self, state_cls: Type[BaseState]):\n        \"\"\"Initialize the EventHandlerSetVar.\n\n        Args:\n            state_cls: The state class that vars will be set on.\n\n------------------------------\n------------------------------\n        Returns:\n            True if the computed var needs to be updated, False otherwise.\n        \"\"\"\n        if self._update_interval is None:\n            return False\n        last_updated = getattr(instance, self._last_updated_attr, None)\n        if last_updated is None:\n            return True\n        return datetime.datetime.now() - last_updated > self._update_interval\n\n    def __get__(self, instance: BaseState | None, owner):\n        \"\"\"Get the ComputedVar value.\n\n        If the value is already cached on the instance, return the cached value.\n\n        Args:\n            instance: the instance of the class accessing this computed var.\n            owner: the class that this descriptor is attached to.\n\n        Returns:\n\n------------------------------\n------------------------------\n            )\n\n    def _mark_dirty_computed_vars(self) -> None:\n        \"\"\"Mark ComputedVars that need to be recalculated based on dirty_vars.\"\"\"\n        dirty_vars = self.dirty_vars\n        while dirty_vars:\n            calc_vars, dirty_vars = dirty_vars, set()\n            for cvar in self._dirty_computed_vars(from_vars=calc_vars):\n                self.dirty_vars.add(cvar)\n                dirty_vars.add(cvar)\n                actual_var = self.computed_vars.get(cvar)\n                if actual_var is not None:\n                    actual_var.mark_dirty(instance=self)\n\n    def _expired_computed_vars(self) -> set[str]:\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n\n------------------------------\n------------------------------\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n        return set(\n            cvar\n            for cvar in self.computed_vars\n            if self.computed_vars[cvar].needs_update(instance=self)\n        )\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _dirty_computed_vars(\n# Natural Language Annotations: \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _dirty_computed_vars(\n    self, \n    from_vars: Optional[Set[str]] = None, \n    include_backend: bool = False\n) -> Set[str]:\n    if from_vars is None:\n        from_vars = self.dirty_vars\n    dirty_computed_vars = set()\n    for var in from_vars:\n        dirty_computed_vars.update(self._computed_var_dependencies.get(var, set()))\n    if include_backend:\n        dirty_computed_vars.update(self.backend_vars.keys())\n    return dirty_computed_vars\n```\n", "```python\ndef _dirty_computed_vars(self, from_vars: Set[str] = None, include_backend: bool = False) -> Set[str]:\n    \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = self.dirty_vars\n    dirty_computed_vars = set()\n    for var in from_vars:\n        dirty_computed_vars.update(self._computed_var_dependencies.get(var, set()))\n    if include_backend:\n        dirty_computed_vars.update(self.backend_vars.keys())\n        dirty_computed_vars.update(self.inherited_backend_vars.keys())\n    return dirty_computed_vars\n```\n", "```python\ndef _dirty_computed_vars(self, from_vars: Optional[Set[str]] = None, include_backend: bool = False) -> Set[str]:\n    if from_vars is None:\n        from_vars = self.dirty_vars\n\n    computed_vars = set()\n    for var in from_vars:\n        computed_vars.update(self._computed_var_dependencies.get(var, set()))\n\n    if include_backend:\n        for var, actual_var in self.backend_vars.items():\n            if actual_var in from_vars:\n                computed_vars.update(self._computed_var_dependencies.get(var, set()))\n\n    return computed_vars\n```\n"]}, "reflex-reflex/state.py-_potentially_dirty_substates": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            token: The token to get the state for.\n            state: The state instance to populate substates for.\n            all_substates: Whether to fetch all substates or just required substates.\n        \"\"\"\n        client_token, _ = _split_substate_key(token)\n\n        if all_substates:\n            # All substates are requested.\n            fetch_substates = state.get_substates()\n        else:\n            # Only _potentially_dirty_substates need to be fetched to recalc computed vars.\n            fetch_substates = state._potentially_dirty_substates()\n\n        tasks = {}\n        # Retrieve the necessary substates from redis.\n        for substate_cls in fetch_substates:\n            substate_name = substate_cls.get_name()\n            tasks[substate_name] = asyncio.create_task(\n                self.get_state(\n                    token=_substate_key(client_token, substate_cls),\n\n------------------------------\n------------------------------\n                        parent_state._substate_var_dependencies[var].add(state_name)\n                        state_name, parent_state = (\n                            parent_state.get_name(),\n                            parent_state.get_parent_state(),\n                        )\n\n        # ComputedVar with cache=False always need to be recomputed\n        cls._always_dirty_computed_vars = set(\n            cvar_name\n            for cvar_name, cvar in cls.computed_vars.items()\n            if not cvar._cache\n        )\n\n        # Any substate containing a ComputedVar with cache=False always needs to be recomputed\n        if cls._always_dirty_computed_vars:\n            # Tell parent classes that this substate has always dirty computed vars\n            state_name = cls.get_name()\n            parent_state = cls.get_parent_state()\n            while parent_state is not None:\n                parent_state._always_dirty_substates.add(state_name)\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n            )\n\n    def _mark_dirty_computed_vars(self) -> None:\n        \"\"\"Mark ComputedVars that need to be recalculated based on dirty_vars.\"\"\"\n        dirty_vars = self.dirty_vars\n        while dirty_vars:\n            calc_vars, dirty_vars = dirty_vars, set()\n            for cvar in self._dirty_computed_vars(from_vars=calc_vars):\n                self.dirty_vars.add(cvar)\n                dirty_vars.add(cvar)\n                actual_var = self.computed_vars.get(cvar)\n                if actual_var is not None:\n                    actual_var.mark_dirty(instance=self)\n\n    def _expired_computed_vars(self) -> set[str]:\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n\n------------------------------\n------------------------------\n        \"\"\"Determine ComputedVars that need to be recalculated based on the expiration time.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n        return set(\n            cvar\n            for cvar in self.computed_vars\n            if self.computed_vars[cvar].needs_update(instance=self)\n        )\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n# Natural Language Annotations: \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n        Returns:\n            Set of State classes that may need to be fetched to recalc computed vars.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    potentially_dirty_substates = set()\n    for var in cls.dirty_vars:\n        for dependent_state, dependent_vars in cls.substate_var_dependencies.items():\n            if var in dependent_vars:\n                potentially_dirty_substates.add(dependent_state)\n    return potentially_dirty_substates\n```\n", "```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    dirty_var_substates = set()\n    for dirty_var in cls.dirty_vars:\n        dirty_var_substates.update(\n            substate\n            for substate in cls.get_substates()\n            if dirty_var in cls.computed_vars or dirty_var in substate.computed_vars\n        )\n    return dirty_var_substates\n```\n", "```python\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    dirty_vars = cls.dirty_vars\n    dirty_substates = set()\n\n    def recurse_substates(substate_cls):\n        for var_name in dirty_vars:\n            if var_name in substate_cls.dirty_vars:\n                dirty_substates.add(substate_cls)\n                return\n\n        for var_name in dirty_vars:\n            if var_name in cls.computed_vars:\n                for dep_var in cls.computed_vars[var_name].get_dependency_var_names():\n                    if dep_var in dirty_vars and substate_cls.get_name() in cls._substate_var_dependencies[dep_var]:\n                        dirty_substates.add(substate_cls)\n                        return\n\n        for child_substate_cls in substate_cls.get_substates():\n            recurse_substates(child_substate_cls)\n\n    for substate_cls in cls.get_substates():\n        recurse_substates(substate_cls)\n\n    return dirty_substates\n```\n"]}, "reflex-reflex/state.py-get_delta": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return code\n\n    def _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_delta(self) -> Delta:\n# Natural Language Annotations: \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    # Your implementation here\n    pass\n```\n", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    return self._get_delta()\n```\n", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    # This is a placeholder for your implementation.\n    # Replace the below line with your actual implementation.\n    pass\n```\n"]}, "reflex-reflex/model.py-get_db_engine": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n        Returns:\n            The hash of the var.\n        \"\"\"\n        return hash((self._var_name, str(self._var_type)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_db_engine():\n# Natural Language Annotations: \"\"\"Get the database engine.\n\n        Returns:\n            The database engine.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    # TODO: Implement this function\n    pass\n```\n", "```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    engine = create_engine('sqlite:///:memory:')\n    return engine\n```\n", "```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    # Placeholder for your code here. It could look something like this:\n    # return create_engine('database_url')\n```\n"]}, "reflex-reflex/model.py-alembic_autogenerate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n\n\n\n    def get_load_events(self, route: str) -> list[EventHandler | EventSpec]:\n        \"\"\"Get the load events for a route.\n\n        Args:\n            route: The route to get the load events for.\n\n        Returns:\n            The load events for the route.\n        \"\"\"\n        route = route.lstrip(\"/\")\n        if route == \"\":\n\n------------------------------\n------------------------------\n        self,\n        token: str,\n        top_level: bool = True,\n        get_substates: bool = True,\n        parent_state: BaseState | None = None,\n    ) -> BaseState:\n        \"\"\"Get the state for a token.\n\n        Args:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n\n        Raises:\n            RuntimeError: when the state_cls is not specified in the token\n        \"\"\"\n\n------------------------------\n------------------------------\n\n        Args:\n            format_spec: The format specifier to use.\n\n        Returns:\n            The formatted color.\n        \"\"\"\n        return format_color(self.color, self.shade, self.alpha)\n\n------------------------------\n------------------------------\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n            to_rev: Revision to migrate towards.\n        \"\"\"\n        config, script_directory = cls._alembic_config()\n\n        def run_upgrade(rev, context):\n            return script_directory._upgrade_revs(to_rev, rev)\n\n        with alembic.runtime.environment.EnvironmentContext(\n            config=config,\n            script=script_directory,\n            fn=run_upgrade,\n        ) as env:\n            env.configure(connection=connection)\n            env.run_migrations()\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def _alembic_upgrade(\n        cls,\n        connection: sqlalchemy.engine.Connection,\n        to_rev: str = \"head\",\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def alembic_autogenerate(\n# Natural Language Annotations: \"\"\"Generate migration scripts for alembic-detectable changes.\n\n        Args:\n            connection: SQLAlchemy connection to use when detecting changes.\n            message: Human readable identifier describing the generated revision.\n            write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n        Returns:\n            True when changes have been detected.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str,\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n    command.revision(config, message, autogenerate=True)\n\n    if write_migration_scripts:\n        command.upgrade(config, \"head\")\n\n    return True\n```\n", "```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str = \"auto generated revision\",\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n    command.revision(config=config, message=message, autogenerate=True)\n\n    if write_migration_scripts:\n        command.upgrade(config=config, revision=\"head\")\n\n    return True\n```\n", "```python\ndef alembic_autogenerate(\n    connection: sqlalchemy.engine.Connection,\n    message: str,\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config, script_directory = cls._alembic_config()\n\n    def run_autogenerate(rev, context):\n        command.autogenerate(config, rev, write_migration_scripts)\n\n    with alembic.runtime.environment.EnvironmentContext(\n        config=config,\n        script=script_directory,\n        fn=run_autogenerate,\n    ) as env:\n        env.configure(connection=connection)\n        env.run_migrations(message)\n\n    return True\n```\n"]}, "reflex-reflex/model.py-migrate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            events: The events to be checked.\n\n        Raises:\n            TypeError: If any of the events are not valid.\n\n        Returns:\n            The events as they are if valid.\n        \"\"\"\n\n        def _is_valid_type(events: Any) -> bool:\n            return isinstance(events, (Event, EventHandler, EventSpec))\n\n        if events is None or _is_valid_type(events):\n            return events\n        try:\n            if all(_is_valid_type(e) for e in events):\n                return events\n        except TypeError:\n            pass\n\n\n------------------------------\n------------------------------\n        \"\"\"Ensure that the value is an int type or str percentage.\n\n        Unfortunately str Vars cannot be checked and are implicitly not allowed.\n\n        Args:\n            name: The name of the prop.\n            value: The value to check.\n\n        Raises:\n            ValueError: If the value is not an int type or str percentage.\n        \"\"\"\n        if value is None:\n            return\n        if isinstance(value, int):\n            return\n        if isinstance(value, str) and value.endswith(\"%\"):\n            return\n        if isinstance(value, Var) and issubclass(value._var_type, int):\n            return\n        raise ValueError(\n\n------------------------------\n------------------------------\n        self,\n        token: str,\n        top_level: bool = True,\n        get_substates: bool = True,\n        parent_state: BaseState | None = None,\n    ) -> BaseState:\n        \"\"\"Get the state for a token.\n\n        Args:\n            token: The token to get the state for.\n            top_level: If true, return an instance of the top-level state (self.state).\n            get_substates: If true, also retrieve substates.\n            parent_state: If provided, use this parent_state instead of getting it from redis.\n\n        Returns:\n            The state for the token.\n\n        Raises:\n            RuntimeError: when the state_cls is not specified in the token\n        \"\"\"\n\n------------------------------\n------------------------------\n        \"\"\"Chase parent_state pointers to find an instance of the top-level state.\n\n        Args:\n            state: The state to start from.\n\n        Returns:\n            An instance of the top-level state (self.state).\n        \"\"\"\n        while type(state) != self.state and state.parent_state is not None:\n            state = state.parent_state\n        return state\n\n    async def _get_parent_state(self, token: str) -> BaseState | None:\n        \"\"\"Get the parent state for the state requested in the token.\n\n        Args:\n            token: The token to get the state for (_substate_key).\n\n        Returns:\n            The parent state for the state requested by the token or None if there is no such parent.\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n    @classmethod\n    def _alembic_upgrade(\n        cls,\n        connection: sqlalchemy.engine.Connection,\n        to_rev: str = \"head\",\n    ) -> None:\n        \"\"\"Apply alembic migrations up to the given revision.\n\n        Args:\n            connection: SQLAlchemy connection to use when performing upgrade.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def migrate(cls, autogenerate: bool = False) -> bool | None:\n# Natural Language Annotations: \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n        If alembic is not installed or has not been initialized for the project,\n        then no action is performed.\n\n        If there are no revisions currently tracked by alembic, then\n        an initial revision will be created based on sqlmodel metadata.\n\n        If models in the app have changed in incompatible ways that alembic\n        cannot automatically generate revisions for, the app may not be able to\n        start up until migration scripts have been corrected by hand.\n\n        Args:\n            autogenerate: If True, generate migration script and use it to upgrade schema\n                (otherwise, just bring the schema to current \"head\" revision).\n\n        Returns:\n            True - indicating the process was successful.\n            None - indicating the process was skipped.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    try:\n        import alembic\n        from alembic.config import Config\n        from alembic.script import ScriptDirectory\n        from sqlalchemy.engine import Connection\n        from sqlmodel import SQLModel\n    except ImportError:\n        return\n\n    config = Config()\n    config.set_main_option('script_location', 'migrations')\n    script = ScriptDirectory.from_config(config)\n\n    if script.get_current_head() is None:\n        command.revision(config, autogenerate=True, message='initial')\n\n    if autogenerate:\n        command.revision(config, autogenerate=True, message='auto generated')\n    else:\n        command.upgrade(config, 'head')\n\n    return True\n```\n", "```python\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    try:\n        import alembic  # noqa\n    except ImportError:\n        return\n\n    from alembic.config import Config\n    from alembic.command import upgrade\n    from alembic.autogenerate import render_python_code\n    from alembic.runtime.migration import RevisionStep\n    from sqlalchemy import MetaData\n    from sqlmodel import SQLModel\n\n    config = Config()\n\n    with cls.engine.begin() as connection:\n        config.set_main_option('script_location', alembic.script_location)\n        metadata = MetaData()\n        SQLModel.metadata.create_all(bind=connection)\n        metadata.reflect(bind=connection)\n        config.attributes['connection'] = connection\n        config.attributes['metadata'] = metadata\n\n        context = config.get_context()\n        if context.get_current_revision() is None:\n            command.stamp(config, 'head')\n        if autogenerate:\n            script = render_python_code(\n                config, context.get_current_revision(),\n                as_string=True,\n                rev_id=None,\n                process_revision_directives=RevisionStep.all,\n            )\n            print(script)\n        upgrade(config, 'head')\n\n    return True\n```\n", "Here is the implementation of the `migrate` function:\n\n```python\nimport alembic\nimport sqlalchemy\nimport sqlmodel\nfrom alembic.config import Config\nfrom alembic.runtime.environment import EnvironmentContext\nfrom alembic.script import ScriptDirectory\n\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    try:\n        # Check if alembic is installed\n        alembic.__version__\n    except ImportError:\n        # Alembic is not installed, so return None\n        return None\n\n    # Get the Alembic configuration from the current context\n    config = cls._get_alembic_config()\n\n    # Get the script directory\n    script_dir = ScriptDirectory.from_config(config)\n\n    # Check if there are any revisions currently tracked by alembic\n    if not script_dir.revision_map.revision_exists():\n        # If not, create an initial revision\n        cls._create_initial_revision()\n\n    # Check if models in the app have changed in incompatible ways\n    if autogenerate:\n        # Generate a migration script and use it to upgrade the schema\n        cls._autogenerate_revision(config)\n    else:\n        # Bring the schema to the current \"head\" revision\n        cls._upgrade_head(config)\n\n    return True\n```\nThis function is a class method and assumes that the class it belongs to has appropriate methods for getting the Alembic configuration, creating an initial revision, autogenerating revisions, and upgrading the schema to the current \"head\" revision. These methods would need to be implemented based on the specific requirements of your application.\n"]}, "reflex-reflex/model.py-select": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            }\n        super().__init__(*args, **kwargs)\n\n\n\n\n\n\n\n\n\n    def add_props(self, **kwargs: Optional[Any]) -> Tag:\n        \"\"\"Add props to the tag.\n\n        Args:\n            **kwargs: The props to add.\n\n        Returns:\n            The tag with the props added.\n        \"\"\"\n\n------------------------------\n------------------------------\n        Returns:\n            The hash of the var.\n        \"\"\"\n        return hash((self._var_name, str(self._var_type)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def select(cls):\n# Natural Language Annotations: \"\"\"Select rows from the table.\n\n        Returns:\n            The select statement.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    # Your implementation here\n```\n", "```python\ndef select(cls):\n    \"\"\"Select rows from the table.\"\"\"\n    return cls.select()\n```\n", "```python\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    # Here you need to implement the logic to select rows from the table\n    # This is a placeholder code, replace it with your actual implementation\n    return \"SELECT * FROM table_name\"\n```\n"]}, "reflex-reflex/compiler/compiler.py-compile_components": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def compile_custom_components(cls):\n        \"\"\"Compile the custom components.\n\n        Returns:\n            The path and code of the compiled custom components.\n\n        Raises:\n            ValueError: If the custom components are not set.\n        \"\"\"\n        if cls.CUSTOM_COMPONENTS is None:\n            raise ValueError(\"CUSTOM_COMPONENTS should be set\")\n        return compile_components(cls.CUSTOM_COMPONENTS)\n\n    @classmethod\n    def compile_theme(cls):\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n\n\n------------------------------\n------------------------------\n    @classmethod\n    def compile_app(cls):\n        \"\"\"Compile the app.\n\n        Returns:\n            The path and code of the compiled app.\n\n        Raises:\n            ValueError: If the app root is not set.\n        \"\"\"\n        if cls.COMPILE_APP_APP_ROOT is None:\n            raise ValueError(\"COMPILE_APP_APP_ROOT should be set\")\n        return compile_app(cls.COMPILE_APP_APP_ROOT)\n\n    @classmethod\n    def compile_custom_components(cls):\n        \"\"\"Compile the custom components.\n\n        Returns:\n            The path and code of the compiled custom components.\n\n------------------------------\n------------------------------\n        \"\"\"Compile the theme.\n\n        Returns:\n            The path and code of the compiled theme.\n\n        Raises:\n            ValueError: If the style is not set.\n        \"\"\"\n        if cls.STYLE is None:\n            raise ValueError(\"STYLE should be set\")\n        return compile_theme(cls.STYLE)\n\n------------------------------\n------------------------------\n\n    Args:\n        stylesheets: The stylesheets to include in the root stylesheet.\n\n    Returns:\n        The path and code of the compiled root stylesheet.\n    \"\"\"\n    output_path = utils.get_root_stylesheet_path()\n\n    code = _compile_root_stylesheet(stylesheets)\n\n    return output_path, code\n\n\ndef _compile_root_stylesheet(stylesheets: list[str]) -> str:\n    \"\"\"Compile the root stylesheet.\n\n    Args:\n        stylesheets: The stylesheets to include in the root stylesheet.\n\n\n------------------------------\n------------------------------\n    \"\"\"Compile a single page.\n\n    Args:\n        path: The path to compile the page to.\n        component: The component to compile.\n        state: The app state.\n\n    Returns:\n        The path and code of the compiled page.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_page_path(path)\n\n    # Add the style to the component.\n    code = _compile_page(component, state)\n    return output_path, code\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def compile_components(\n# Natural Language Annotations: \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef compile_components(components: list[str]) -> tuple[str, str]:\n    \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_components_path()\n\n    # Compile the components.\n    code = _compile_components(components)\n\n    return output_path, code\n```\n", "```python\ndef compile_components(components: list) -> tuple:\n    \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    output_path = utils.get_components_path()\n\n    code = _compile_components(components)\n\n    return output_path, code\n```\n", "```python\ndef compile_components(components: list[str]) -> Tuple[str, str]:\n    output_path = utils.get_components_path()\n    code = _compile_components(components)\n    return output_path, code\n```\n"]}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n    @classmethod\n    @lru_cache(maxsize=None)\n    def get_initial_props(cls) -> Set[str]:\n        \"\"\"Get the initial props to set for the component.\n\n        Returns:\n            The initial props to set.\n        \"\"\"\n        return set()\n\n    @classmethod\n    @lru_cache(maxsize=None)\n    def get_component_props(cls) -> set[str]:\n        \"\"\"Get the props that expected a component as value.\n\n        Returns:\n            The components props.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\ndef check_node_version() -> bool:\n    \"\"\"Check the version of Node.js.\n\n    Returns:\n        Whether the version of Node.js is valid.\n    \"\"\"\n    current_version = get_node_version()\n    if current_version:\n\n------------------------------\n------------------------------\n    Returns:\n        The operating system.\n    \"\"\"\n    return platform.system()\n\n\ndef get_detailed_platform_str() -> str:\n    \"\"\"Get the detailed os/platform string.\n\n    Returns:\n        The platform string\n    \"\"\"\n    return platform.platform()\n\n\ndef get_python_version() -> str:\n    \"\"\"Get the Python version.\n\n    Returns:\n        The Python version.\n\n------------------------------\n------------------------------\n\"\"\"Checks the size of a specific directory and uploads result.\"\"\"\n\nimport argparse\nimport os\nimport subprocess\nfrom datetime import datetime\n\nimport psycopg2\n\n\ndef get_directory_size(directory):\n    \"\"\"Get the size of a directory in bytes.\n\n    Args:\n        directory: The directory to check.\n\n    Returns:\n        The size of the dir in bytes.\n    \"\"\"\n    total_size = 0\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_or_set_last_reflex_version_check_datetime():\n# Natural Language Annotations: \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["Here is the function based on the given function signature and natural language annotations:\n\n```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    # This is a placeholder for your actual implementation.\n    # Here, we just return the current datetime.\n    return datetime.now()\n```\n", "```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    # Assuming you have a config file or some other form of persistent storage\n    # where you can store and retrieve this value. This is just an example.\n    # If you don't have such a storage, you would need to modify this function\n    # to store and retrieve the value from somewhere else.\n    try:\n        with open('version_check.txt', 'r') as f:\n            last_check_time = f.read()\n    except FileNotFoundError:\n        last_check_time = None\n\n    if not last_check_time:\n        # If there was no last time recorded, set it to the current time\n        last_check_time = datetime.now().isoformat()\n        with open('version_check.txt', 'w') as f:\n            f.write(last_check_time)\n\n    return datetime.fromisoformat(last_check_time)\n```\n", "Here is the requested function based on the given function signature and natural language annotations:\n\n```python\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    # Assuming you have a way to store and retrieve this value (e.g., a file, a database, etc.)\n    # Replace the following code with the actual implementation\n    \n    # Sample implementation using a file\n    file_path = \"last_reflex_version_check_datetime.txt\"\n\n    try:\n        with open(file_path, 'r') as file:\n            last_check_time = datetime.strptime(file.read(), \"%Y-%m-%d %H:%M:%S\")\n    except FileNotFoundError:\n        last_check_time = None\n\n    return last_check_time\n```\n\nNote: This function is a placeholder and does not perform the actual version check. It retrieves the last version check datetime from a file. In a real implementation, you would replace this with a proper way to store and retrieve this value. You could use a database, a configuration file, etc.\n"]}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    \"\"\"Compile a single page.\n\n    Args:\n        path: The path to compile the page to.\n        component: The component to compile.\n        state: The app state.\n\n    Returns:\n        The path and code of the compiled page.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_page_path(path)\n\n    # Add the style to the component.\n    code = _compile_page(component, state)\n    return output_path, code\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n        if index is None:\n            self.middleware.append(middleware)\n        else:\n            self.middleware.insert(index, middleware)\n\n    async def _preprocess(self, state: BaseState, event: Event) -> StateUpdate | None:\n        \"\"\"Preprocess the event.\n\n        This is where middleware can modify the event before it is processed.\n        Each middleware is called in the order it was added to the app.\n\n        If a middleware returns an update, the event is not processed and the\n        update is returned.\n\n        Args:\n            state: The state to preprocess.\n            event: The event to preprocess.\n\n        Returns:\n            An optional state to return.\n\n------------------------------\n------------------------------\nclass Middleware(Base, ABC):\n    \"\"\"Middleware to preprocess and postprocess requests.\"\"\"\n\n    async def preprocess(\n        self, app: App, state: BaseState, event: Event\n    ) -> Optional[StateUpdate]:\n        \"\"\"Preprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional state update to return.\n        \"\"\"\n        return None\n\n    async def postprocess(\n        self, app: App, state: BaseState, event: Event, update: StateUpdate\n\n------------------------------\n------------------------------\n        \"\"\"\n        return None\n\n    async def postprocess(\n        self, app: App, state: BaseState, event: Event, update: StateUpdate\n    ) -> StateUpdate:\n        \"\"\"Postprocess the event.\n\n        Args:\n            app: The app.\n            state: The client state.\n            event: The event to postprocess.\n            update: The current state update.\n\n        Returns:\n            An optional state to return.\n        \"\"\"\n        return update\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def preprocess(\n# Natural Language Annotations: \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def preprocess(app: App, state: BaseState, event: Event) -> Optional[StateUpdate]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n```\n", "```python\nasync def preprocess(\n    app: App, \n    state: BaseState, \n    event: Event\n) -> Optional[StateUpdate | List[StateUpdate]]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # Your implementation goes here...\n    pass\n```\n", "```python\nasync def preprocess(app: App, state: BaseState, event: Event) -> Optional[StateUpdate | List[StateUpdate]]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # TODO: Implement the preprocessing logic here.\n    # Currently, this function returns None.\n    return None\n```\n"]}, "reflex-reflex/components/component.py-get_event_triggers": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return code\n\n    def _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_event_triggers(self) -> Dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    return {}\n```\n", "```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    # Placeholder code\n    return {}\n```\n", "```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    # Please replace the placeholders with the actual implementation\n    return {}\n```\n"]}, "reflex-reflex/components/component.py-get_props": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return code\n\n    def _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_props(cls) -> Set[str]:\n# Natural Language Annotations: \"\"\"Get the unique fields for the component.\n\n        Returns:\n            The unique fields.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set(cls.__dict__.keys())\n```\n", "```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    pass\n```\n", "Sure, here is the function based on the provided function signature and natural language annotations:\n\n```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return cls._get_all_refs()\n```\n\nThis function uses the `_get_all_refs()` method of the `cls` object to return the unique fields for the component. The `cls` object is expected to have this method implemented as it is decorated with `@abstractmethod`.\n"]}, "reflex-reflex/components/component.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    \"\"\"\n    return Box.create(*children, **props, display=[\"block\", \"none\", \"none\", \"none\"])\n\n\ndef tablet_only(*children, **props):\n    \"\"\"Create a component that is only visible on tablet.\n\n    Args:\n        *children: The children to pass to the component.\n        **props: The props to pass to the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return Box.create(*children, **props, display=[\"none\", \"block\", \"block\", \"none\"])\n\n\ndef desktop_only(*children, **props):\n    \"\"\"Create a component that is only visible on desktop.\n\n\n------------------------------\n------------------------------\n\nclass Layout(Box):\n    \"\"\"A component that renders the layout.\"\"\"\n\n    @classmethod\n    def create(\n        cls,\n        *content: Component,\n        sidebar: Component | None = None,\n        **props,\n    ):\n        \"\"\"Create the layout component.\n\n        Args:\n            content: The content component.\n            sidebar: The sidebar component.\n            props: The properties of the layout.\n\n        Returns:\n            The layout component.\n\n------------------------------\n------------------------------\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The Progress Component.\n        \"\"\"\n        props.setdefault(\"width\", \"100%\")\n        return super().create(*children, **props)\n\n\nprogress = Progress.create\n\n------------------------------\n------------------------------\n        help_text=None,\n        error_message=None,\n        **props,\n    ) -> Component:\n        \"\"\"Create a form control component.\n\n        Args:\n            *children: The children of the form control.\n            label: The label of the form control.\n            input: The input of the form control.\n            help_text: The help text of the form control.\n            error_message: The error message of the form control.\n            **props: The properties of the form control.\n\n        Raises:\n            AttributeError: raise an error if missing required kwargs.\n\n        Returns:\n            The form control component.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n    Args:\n        *children: The children to pass to the component.\n        **props: The props to pass to the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return Box.create(*children, **props, display=[\"block\", \"block\", \"block\", \"none\"])\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return super().create(*children, **props)\n```\n", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return super().create(*children, **props)\n```\n", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return cls(*children, **props)\n```\n"]}, "reflex-reflex/components/component.py-_add_style_recursive": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        v1: Var | int = 0,\n        v2: Var | int | None = None,\n        step: Var | int | None = None,\n    ) -> Var:\n        \"\"\"Return an iterator over indices from v1 to v2 (or 0 to v1).\n\n        Args:\n            v1: The start of the range or end of range if v2 is not given.\n            v2: The end of the range.\n            step: The number of numbers between each item.\n\n        Returns:\n            A var representing range operation.\n\n        Raises:\n            VarTypeError: If the var is not an int.\n        \"\"\"\n        if not isinstance(v1, Var):\n            v1 = Var.create_safe(v1)\n        if v1._var_type != int:\n\n------------------------------\n------------------------------\n    Returns:\n        The rendered stateful components code.\n    \"\"\"\n    all_import_dicts = []\n    rendered_components = {}\n\n    def get_shared_components_recursive(component: BaseComponent):\n        \"\"\"Get the shared components for a component and its children.\n\n        A shared component is a StatefulComponent that appears in 2 or more\n        pages and is a candidate for writing to a common file and importing\n        into each page where it is used.\n\n        Args:\n            component: The component to collect shared StatefulComponents for.\n        \"\"\"\n        for child in component.children:\n            # Depth-first traversal.\n            get_shared_components_recursive(child)\n\n\n------------------------------\n------------------------------\n\n        Args:\n            theme: The theme to apply.\n        \"\"\"\n        self._apply_theme(theme)\n        for child in self.children:\n            if isinstance(child, Component):\n                child.apply_theme(theme)\n\n    def _exclude_props(self) -> list[str]:\n        \"\"\"Props to exclude when adding the component props to the Tag.\n\n        Returns:\n            A list of component props to exclude.\n        \"\"\"\n        return []\n\n    def _render(self, props: dict[str, Any] | None = None) -> Tag:\n        \"\"\"Define how to render the component in React.\n\n\n------------------------------\n------------------------------\n        for s in reversed(styles):\n            _style.update(s)\n        return _style\n\n    def _get_component_style(self, styles: ComponentStyle) -> Style | None:\n        \"\"\"Get the style to the component from `App.style`.\n\n        Args:\n            styles: The style to apply.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        component_style = None\n        if type(self) in styles:\n            component_style = Style(styles[type(self)])\n        if self.create in styles:\n            component_style = Style(styles[self.create])\n        return component_style\n\n\n------------------------------\n------------------------------\n\n        return _compile_component(self)\n\n    def _apply_theme(self, theme: Optional[Component]):\n        \"\"\"Apply the theme to this component.\n\n        Deprecated. Use add_style instead.\n\n        Args:\n            theme: The theme to apply.\n        \"\"\"\n        pass\n\n    def apply_theme(self, theme: Optional[Component]):\n        \"\"\"Apply a theme to the component and its children.\n\n        Args:\n            theme: The theme to apply.\n        \"\"\"\n        self._apply_theme(theme)\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_style_recursive(\n# Natural Language Annotations: \"\"\"Add additional style to the component and its children.\n\n        Apply order is as follows (with the latest overriding the earliest):\n        1. Default style from `_add_style`/`add_style`.\n        2. User-defined style from `App.style`.\n        3. User-defined style from `Component.style`.\n        4. style dict and css props passed to the component instance.\n\n        Args:\n            style: A dict from component to styling.\n            theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n        Raises:\n            UserWarning: If `_add_style` has been overridden.\n\n        Returns:\n            The component with the additional style.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _add_style_recursive(\n    style: dict,\n    theme: Optional[Component]\n) -> Component:\n    \"\"\"Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n\n    Returns:\n        The component with the additional style.\n    \"\"\"\n    pass\n```\n", "```python\ndef _add_style_recursive(\n    self,\n    style: dict[Component, ComponentStyle] | None = None,\n    theme: Optional[Component] = None,\n) -> Component:\n    \"\"\"Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n\n    Returns:\n        The component with the additional style.\n    \"\"\"\n    if style is not None:\n        for component, component_style in style.items():\n            component._add_style(component_style)\n\n    if theme is not None:\n        self._apply_theme(theme)\n\n    return self\n```\n", "```python\ndef _add_style_recursive(self, style: dict, theme: Optional[Component] = None) -> Component:\n    \"\"\"Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n\n    Returns:\n        The component with the additional style.\n    \"\"\"\n\n    if self._add_style != self._default_add_style:\n        warnings.warn(\n            \"`_add_style` has been overridden. This may cause unexpected behavior.\",\n            UserWarning,\n        )\n\n    self._add_style(style)\n\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(style)\n\n    return self\n```\n"]}, "reflex-reflex/components/component.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        return IterTag(\n            iterable=self.iterable,\n            render_fn=self.render_fn,\n            children=self.children,\n            **props,\n        )\n\n    def render(self):\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        tag = self._render()\n\n        return dict(\n            tag,\n            iterable_state=tag.iterable._var_full_name,\n            arg_name=tag.arg_var_name,\n\n------------------------------\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self) -> Dict:\n# Natural Language Annotations: \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef render(self) -> Dict:\n    \"\"\"Render the component.\n\n    Returns:\n        The dictionary for template of component.\n    \"\"\"\n    tag = self._render()\n\n    return dict(\n        tag,\n        iterable_state=tag.iterable._var_full_name,\n        arg_name=tag.arg_var_name,\n    )\n```\n", "```python\ndef render(self) -> Dict:\n    \"\"\"Render the component.\n\n    Returns:\n        The dictionary for template of component.\n    \"\"\"\n    tag = self._render()\n\n    return dict(\n        tag,\n        iterable_state=tag.iterable._var_full_name,\n        arg_name=tag.arg_var_name,\n    )\n```\n", "```python\ndef render(self) -> Dict:\n    \"\"\"Render the component.\n\n    Returns:\n        The dictionary for template of component.\n    \"\"\"\n    tag = self._render()\n\n    return dict(\n        tag,\n        iterable_state=tag.iterable._var_full_name,\n        arg_name=tag.arg_var_name\n    )\n```\n"]}, "reflex-reflex/components/component.py-_get_vars": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    track_color: Var[str]\n\n    # Current progress (must be between min/max).\n    value: Var[int]\n\n    # The desired valueText to use in place of the value.\n    value_text: Var[str]\n\n    # The color name of the progress bar\n    color: Var[str]\n\n    # The size of the circular progress\n    size: Var[str]\n\n    @classmethod\n    def create(cls, *children, label=None, **props) -> Component:\n        \"\"\"Create a circular progress component.\n\n        Args:\n            *children: the children of the component.\n\n------------------------------\n------------------------------\n\n    Args:\n        *children: The children to pass to the component.\n        **props: The props to pass to the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return Box.create(*children, **props, display=[\"block\", \"block\", \"block\", \"none\"])\n\n------------------------------\n------------------------------\n            contents = str(contents) if contents is not None else \"\"\n        return cls(contents=contents)  # type: ignore\n\n    def _render(self) -> Tag:\n        return Tagless(contents=str(self.contents))\n\n    def _get_vars(self, include_children: bool = False) -> Iterator[Var]:\n        \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Yields:\n            The contents if it is a Var, otherwise nothing.\n        \"\"\"\n        yield self.contents\n\n------------------------------\n------------------------------\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\n        return super()._get_vars(include_children=include_children) + [\n            prop for prop in self.props.values() if isinstance(prop, Var)\n        ]\n\n    @lru_cache(maxsize=None)  # noqa\n    def get_component(self) -> Component:\n        \"\"\"Render the component.\n\n        Returns:\n            The code to render the component.\n        \"\"\"\n        return self.component_fn(*self.get_prop_vars())\n\n\ndef custom_component(\n\n------------------------------\n------------------------------\n        \"\"\"\n        return [\n            BaseVar(\n                _var_name=name,\n                _var_type=(\n                    prop._var_type if types._isinstance(prop, Var) else type(prop)\n                ),\n            )\n            for name, prop in self.props.items()\n        ]\n\n    def _get_vars(self, include_children: bool = False) -> list[Var]:\n        \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_vars(self, include_children: bool = False) -> list[Var]:\n# Natural Language Annotations: \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_list = []\n    for prop in self.props.values():\n        if isinstance(prop, Var):\n            vars_list.append(prop)\n    if include_children:\n        for child in self.children:\n            vars_list.extend(child._get_vars(include_children=True))\n    return vars_list\n```\n", "```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_ = super()._get_vars(include_children=include_children)\n    vars_.extend(prop for prop in self.props.values() if isinstance(prop, Var))\n    return vars_\n```\n", "```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_list = super()._get_vars(include_children=include_children)\n    vars_list.extend(\n        prop for prop in self.props.values() if isinstance(prop, Var)\n    )\n    return vars_list\n```\n"]}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\ndef check_node_version() -> bool:\n    \"\"\"Check the version of Node.js.\n\n    Returns:\n        Whether the version of Node.js is valid.\n    \"\"\"\n    current_version = get_node_version()\n    if current_version:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def _event_trigger_values_use_state(self) -> bool:\n        \"\"\"Check if the values of a component's event trigger use state.\n\n        Returns:\n            True if any of the component's event trigger values uses State.\n        \"\"\"\n        for trigger in self.event_triggers.values():\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _has_stateful_event_triggers(self):\n# Natural Language Annotations: \"\"\"Check if component or children have any event triggers that use state.\n\n        Returns:\n            True if the component or children have any event triggers that uses state.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _has_stateful_event_triggers(self) -> bool:\n    \"\"\"Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    for trigger in self.event_triggers.values():\n        if trigger.uses_state():\n            return True\n    return False\n```\n", "```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    for trigger in self.event_triggers.values():\n        if trigger.uses_state:\n            return True\n    return False\n```\n", "```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"\n    Check if the component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    for trigger in self.event_triggers.values():\n        if trigger.uses_state():\n            return True\n    return False\n```\n"]}, "reflex-reflex/components/component.py-_get_all_custom_code": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Returns:\n            The dictionary for template of the component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n    def _get_dynamic_imports(self) -> str | None:\n        \"\"\"Get dynamic import for the component.\n\n        Returns:\n            The dynamic import.\n        \"\"\"\n        return None\n\n    def _get_all_dynamic_imports(self) -> Set[str]:\n        \"\"\"Get dynamic imports for the component and its children.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n        # Store the import in a set to avoid duplicates.\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_code(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Get custom code for the component and its children.\n\n        Returns:\n            The custom code.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = set()\n    custom_code.add(self._get_custom_code())\n    for child in self.children:\n        custom_code.update(child._get_all_custom_code())\n    return custom_code\n```\n", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    # Initialize an empty set to store custom code\n    custom_code = set()\n\n    # Add custom code for this component\n    custom_code.add(self._get_custom_code())\n\n    # Recursively add custom code for all children\n    for child in self.children:\n        custom_code.update(child._get_all_custom_code())\n\n    return custom_code\n```\n", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code_set = set()\n    custom_code = self._get_custom_code()\n    if custom_code:\n        custom_code_set.add(custom_code)\n    \n    return custom_code_set\n```\n"]}, "reflex-reflex/components/component.py-_get_all_imports": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Returns:\n            The dictionary for template of the component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n------------------------------\n------------------------------\n    def create(\n        cls,\n        *children,\n        trigger=None,\n        header=None,\n        body=None,\n        footer=None,\n        use_close_button=False,\n        **props,\n    ) -> Component:\n        \"\"\"Create a popover component.\n\n        Args:\n            *children: The children of the component.\n            trigger: The trigger that opens the popover.\n            header: The header of the popover.\n            body: The body of the popover.\n            footer: The footer of the popover.\n            use_close_button: Whether to add a close button on the popover.\n            **props: The properties of the component.\n\n------------------------------\n------------------------------\n\n\n\n\n\n    def _get_dynamic_imports(self) -> str | None:\n        \"\"\"Get dynamic import for the component.\n\n        Returns:\n            The dynamic import.\n        \"\"\"\n        return None\n\n    def _get_all_dynamic_imports(self) -> Set[str]:\n        \"\"\"Get dynamic imports for the component and its children.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n        # Store the import in a set to avoid duplicates.\n\n------------------------------\n------------------------------\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n        if self.rendered_as_shared:\n\n------------------------------\n------------------------------\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n# Natural Language Annotations: \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n        Args:\n            collapse: Whether to collapse the imports by removing duplicates.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n```\n", "```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n```\n", "```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    import_dict = self._get_imports()\n    for child in self.children:\n        import_dict.update(child._get_all_imports(collapse=collapse))\n\n    if collapse:\n        return self._collapse_imports(import_dict)\n    else:\n        return import_dict\n```\n"]}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        return code\n\n    def _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n\n------------------------------\n------------------------------\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n        if self.rendered_as_shared:\n\n------------------------------\n------------------------------\n\n        Returns:\n            The dictionary for template of the component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks_internal(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    # Placeholder code to be replaced with actual implementation\n    pass\n```\n", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    # You should implement this function based on your requirements\n    pass\n```\n", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    # This is a placeholder function. You need to implement this function based on your requirements.\n    # For now, it returns an empty dictionary.\n    return {}\n```\n"]}, "reflex-reflex/components/component.py-_get_all_hooks": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n        return {}\n\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n        return {}\n\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n        if self.rendered_as_shared:\n\n------------------------------\n------------------------------\n        return code\n\n    def _get_hooks(self) -> str | None:\n        \"\"\"Get the React hooks for this component.\n\n        Downstream components should override this method to add their own hooks.\n\n        Returns:\n            The hooks for just this component.\n        \"\"\"\n        return\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_imports(self) -> ParsedImportDict:\n        \"\"\"Get all the libraries and fields that are used by the component.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n\n------------------------------\n------------------------------\n\n        Returns:\n            The dictionary for template of the component.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks_internal(self) -> dict[str, None]:\n        \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_hooks(self) -> dict[str, None]:\n        \"\"\"Get the React hooks for this component.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the React hooks for this component and its children.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    # Implementation here\n```\n", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    all_hooks = {}\n\n    # Get hooks for this component\n    this_component_hooks = self._get_hooks()\n    if this_component_hooks is not None:\n        all_hooks.update(this_component_hooks)\n\n    # Get hooks for child components\n    for child in self.children:\n        child_hooks = child._get_all_hooks()\n        all_hooks.update(child_hooks)\n\n    return all_hooks\n```\n", "Sure, here is the function based on the provided function signature and natural language annotations:\n\n```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n```\n"]}, "reflex-reflex/components/component.py-_get_all_custom_components": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def get_component(cls, *children, **props):\n        \"\"\"Get the stateful sidebar component.\n\n        Args:\n            children: The children components.\n            props: The properties of the sidebar.\n\n        Returns:\n            The stateful sidebar component.\n        \"\"\"\n        return Sidebar.create(*children, **props)\n\n\nclass DrawerSidebar(DrawerRoot):\n    \"\"\"A component that renders a drawer sidebar.\"\"\"\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Create the sidebar component.\n\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n    def _get_all_dynamic_imports(self) -> set[str]:\n        \"\"\"Get dynamic imports for the component.\n\n        Returns:\n            The dynamic imports.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_custom_code(self) -> set[str]:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n\n    @abstractmethod\n    def _get_all_refs(self) -> set[str]:\n        \"\"\"Get the refs for the children of the component.\n\n        Returns:\n\n------------------------------\n------------------------------\n            component_map=component_map,\n            component_map_hash=cls._component_map_hash(component_map),\n            **props,\n        )\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\n        custom_components = super()._get_all_custom_components(seen=seen)\n\n        # Get the custom components for each tag.\n        for component in self.component_map.values():\n\n------------------------------\n------------------------------\n    @classmethod\n    def get_props(cls) -> Set[str]:\n        \"\"\"Get the props for the component.\n\n        Returns:\n            The set of component props.\n        \"\"\"\n        return set()\n\n    def _get_all_custom_components(\n        self, seen: set[str] | None = None\n    ) -> Set[CustomComponent]:\n        \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_components(\n# Natural Language Annotations: \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> Set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    custom_components = super()._get_all_custom_components(seen=seen)\n\n    # Get the custom components for each tag.\n    for component in self.component_map.values():\n        # Add logic here to get custom components\n        pass\n\n    return custom_components\n```\n", "```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    custom_components = super()._get_all_custom_components(seen=seen)\n\n    for component in self.component_map.values():\n        custom_components.add(component)\n\n    return custom_components\n```\n", "```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> Set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    custom_components = super()._get_all_custom_components(seen=seen)\n\n    # Get the custom components for each tag.\n    for component in self.component_map.values():\n        # Add your custom logic here.\n        pass\n\n    return custom_components\n```\n"]}, "reflex-reflex/components/core/upload.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    Args:\n        *children: The children to pass to the component.\n        **props: The props to pass to the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return Box.create(*children, **props, display=[\"block\", \"block\", \"block\", \"none\"])\n\n------------------------------\n------------------------------\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The Progress Component.\n        \"\"\"\n        props.setdefault(\"width\", \"100%\")\n        return super().create(*children, **props)\n\n\nprogress = Progress.create\n\n------------------------------\n------------------------------\n    def create(\n        cls,\n        *children,\n        trigger=None,\n        header=None,\n        body=None,\n        footer=None,\n        use_close_button=False,\n        **props,\n    ) -> Component:\n        \"\"\"Create a popover component.\n\n        Args:\n            *children: The children of the component.\n            trigger: The trigger that opens the popover.\n            header: The header of the popover.\n            body: The body of the popover.\n            footer: The footer of the popover.\n            use_close_button: Whether to add a close button on the popover.\n            **props: The properties of the component.\n\n------------------------------\n------------------------------\n            *children, items=items, list_style_type=list_style_type, **props\n        )\n\n\nclass ListItem(Li):\n    \"\"\"Display an item of an ordered or unordered list.\"\"\"\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Create a list item component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The list item component.\n\n        \"\"\"\n        for child in children:\n\n------------------------------\n------------------------------\n        help_text=None,\n        error_message=None,\n        **props,\n    ) -> Component:\n        \"\"\"Create a form control component.\n\n        Args:\n            *children: The children of the form control.\n            label: The label of the form control.\n            input: The input of the form control.\n            help_text: The help text of the form control.\n            error_message: The error message of the form control.\n            **props: The properties of the form control.\n\n        Raises:\n            AttributeError: raise an error if missing required kwargs.\n\n        Returns:\n            The form control component.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create an upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The upload component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n```\n", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n```\n", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n```\n"]}, "reflex-reflex/components/next/image.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            *children, items=items, list_style_type=list_style_type, **props\n        )\n\n\nclass ListItem(Li):\n    \"\"\"Display an item of an ordered or unordered list.\"\"\"\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Create a list item component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The list item component.\n\n        \"\"\"\n        for child in children:\n\n------------------------------\n------------------------------\n    is_default = True\n    # the URL\n    src: Var[str]\n\n    as_: Optional[Component]\n\n    @classmethod\n    def create(cls, *children, **props) -> NextComponent:\n        \"\"\"Create a Video component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The Video component.\n        \"\"\"\n        return super().create(*children, **props)\n\n------------------------------\n------------------------------\n\n    Args:\n        *children: The children to pass to the component.\n        **props: The props to pass to the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return Box.create(*children, **props, display=[\"block\", \"block\", \"block\", \"none\"])\n\n------------------------------\n------------------------------\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Create an Image component.\n\n        Args:\n            *children: The children of the image.\n            **props: The props of the image.\n\n        Returns:\n            The Image component.\n        \"\"\"\n        src = props.get(\"src\", None)\n        if src is not None and not isinstance(src, (Var)):\n            props[\"src\"] = Var.create(value=src, _var_is_string=True)\n        return super().create(*children, **props)\n\n------------------------------\n------------------------------\n        help_text=None,\n        error_message=None,\n        **props,\n    ) -> Component:\n        \"\"\"Create a form control component.\n\n        Args:\n            *children: The children of the form control.\n            label: The label of the form control.\n            input: The input of the form control.\n            help_text: The help text of the form control.\n            error_message: The error message of the form control.\n            **props: The properties of the form control.\n\n        Raises:\n            AttributeError: raise an error if missing required kwargs.\n\n        Returns:\n            The form control component.\n        \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create an Image component from next/image.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the image.\n            height: The height of the image.\n            **props:The props of the component.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create(cls, *children, width: Optional[int] = None, height: Optional[int] = None, **props) -> Component:\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props:The props of the component.\n\n    Returns:\n        The Image component.\n    \"\"\"\n```\n", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an Image component.\n\n    Args:\n        *children: The children of the image.\n        width: The width of the image.\n        height: The height of the image.\n        **props: The props of the image.\n\n    Returns:\n        The Image component.\n    \"\"\"\n    src = props.get(\"src\", None)\n    if src is not None and not isinstance(src, (Var)):\n        props[\"src\"] = Var.create(value=src, _var_is_string=True)\n    return super().create(*children, **props)\n```\n", "```python\ndef create_image(\n    *children,\n    width: Optional[Union[str, int]] = None,\n    height: Optional[Union[str, int]] = None,\n    **props,\n) -> Component:\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props:The props of the component.\n\n    Returns:\n        The Image component.\n    \"\"\"\n    props[\"width\"] = width\n    props[\"height\"] = height\n    return Image.create(*children, **props)\n```\n"]}, "reflex-reflex/components/lucide/icon.py-create": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    # Enable pagination.\n    pagination: Var[Union[bool, Dict]]\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Create a datatable component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props to pass to the component.\n\n        Returns:\n            The datatable component.\n\n        Raises:\n            ValueError: If a pandas dataframe is passed in and columns are also provided.\n        \"\"\"\n        data = props.get(\"data\")\n        columns = props.get(\"columns\")\n\n\n------------------------------\n------------------------------\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\n        if children:\n            raise AttributeError(\n                f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n            )\n        if \"tag\" not in props:\n            raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n        if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n            raise ValueError(\n                f\"Invalid icon tag: {props['tag']}. Please use one of the following: {sorted(ICON_LIST)}\"\n            )\n        props[\"tag\"] = format.to_title_case(props[\"tag\"]) + \"Icon\"\n        return super().create(*children, **props)\n\n\n\n------------------------------\n------------------------------\n    on_escape_key_down: EventHandler[lambda e0: [e0.target.value]]\n\n    # Fired when the pointer is down outside the tooltip.\n    on_pointer_down_outside: EventHandler[lambda e0: [e0.target.value]]\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        \"\"\"Initialize the Tooltip component.\n\n        Run some additional handling on the props.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Returns:\n            The created component.\n        \"\"\"\n        ARIA_LABEL_KEY = \"aria_label\"\n        if props.get(ARIA_LABEL_KEY) is not None:\n\n------------------------------\n------------------------------\n        \"\"\"Create the DataEditor component.\n\n        Args:\n            *children: The children of the data editor.\n            **props: The props of the data editor.\n\n        Raises:\n            ValueError: invalid input.\n\n        Returns:\n            The DataEditor component.&\n        \"\"\"\n        from reflex.components.el import Div\n\n        columns = props.get(\"columns\", [])\n        data = props.get(\"data\", [])\n        rows = props.get(\"rows\", None)\n\n        # If rows is not provided, determine from data.\n        if rows is None:\n\n------------------------------\n------------------------------\n    \"\"\"An image icon.\"\"\"\n\n    tag = \"None\"\n\n    @classmethod\n    def create(cls, *children, **props):\n        \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n            f\"Invalid icon tag: {props['tag']}. Please use one of the following: {sorted(ICON_LIST)}\"\n        )\n    props[\"tag\"] = format.to_title_case(props[\"tag\"]) + \"Icon\"\n    return super().create(*children, **props)\n```\n", "```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n            f\"Invalid icon tag: {props['tag']}. Please use one of the following: {sorted(ICON_LIST)}\"\n        )\n    props[\"tag\"] = format.to_title_case(props[\"tag\"]) + \"Icon\"\n    return super().create(*children, **props)\n```\n", "```python\n@classmethod\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    if children:\n        raise AttributeError(\n            f\"Passing children to Icon component is not allowed: remove positional arguments {children} to fix\"\n        )\n    if \"tag\" not in props:\n        raise AttributeError(\"Missing 'tag' keyword-argument for Icon\")\n    if not isinstance(props[\"tag\"], str) or props[\"tag\"].lower() not in ICON_LIST:\n        raise ValueError(\n            f\"Invalid icon tag: {props['tag']}. Please use one of the following: {sorted(ICON_LIST)}\"\n        )\n    props[\"tag\"] = format.to_title_case(props[\"tag\"]) + \"Icon\"\n    return super().create(*children, **props)\n```\n"]}, "reflex-reflex/components/tags/tag.py-format_props": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Args:\n            format_spec: The format specifier to use.\n\n        Returns:\n            The formatted color.\n        \"\"\"\n        return format_color(self.color, self.shade, self.alpha)\n\n------------------------------\n------------------------------\n\n    def _get_custom_code(self) -> str | None:\n        \"\"\"Get custom code for the component.\n\n        Returns:\n            The custom code.\n        \"\"\"\n        return None\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n        \"\"\"Add style to the component.\n\n        Returns:\n            The style of the component.\n        \"\"\"\n        return Style({\"padding\": \"6px\"})\n\n\nicon_button = IconButton.create\n\n------------------------------\n------------------------------\n            }\n        super().__init__(*args, **kwargs)\n\n\n\n\n\n\n\n\n\n    def add_props(self, **kwargs: Optional[Any]) -> Tag:\n        \"\"\"Add props to the tag.\n\n        Args:\n            **kwargs: The props to add.\n\n        Returns:\n            The tag with the props added.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def __repr__(self) -> str:\n        \"\"\"Represent the component in React.\n\n        Returns:\n            The code to render the component.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def format_props(self) -> List:\n# Natural Language Annotations: \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Your code here\n```\n", "```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    # Your code here\n    pass\n```\n", "```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    formatted_props = []\n    for prop_name, prop_value in self.props.items():\n        if isinstance(prop_value, (list, tuple)):\n            formatted_prop_value = \" \".join([str(value) for value in prop_value])\n        else:\n            formatted_prop_value = str(prop_value)\n        formatted_props.append(f'{prop_name}={formatted_prop_value}')\n    return formatted_props\n```\n"]}, "textual-src/textual/screen.py-focus_next": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        ) -> ExpectType: ...\n\n    def get_widget_by_id(\n        self, id: str, expect_type: type[ExpectType] | None = None\n    ) -> ExpectType | Widget:\n        \"\"\"Get the first descendant widget with the given ID.\n\n        Performs a breadth-first search rooted at the current screen.\n        It will not return the Screen if that matches the ID.\n        To get the screen, use `self.screen`.\n\n        Args:\n            id: The ID to search for in the subtree\n            expect_type: Require the object be of the supplied type, or None for any type.\n                Defaults to None.\n\n        Returns:\n            The first descendant encountered with this ID.\n\n        Raises:\n\n------------------------------\n------------------------------\n\n        Args:\n            widget: The widget to find in the node list.\n\n        Returns:\n            The index of the widget in the node list.\n\n        Raises:\n            ValueError: If the widget is not in the node list.\n        \"\"\"\n        return self._nodes.index(widget, start, stop)\n\n    def _get_by_id(self, widget_id: str) -> Widget | None:\n        \"\"\"Get the widget for the given widget_id, or None if there's no matches in this list\"\"\"\n        return self._nodes_by_id.get(widget_id)\n\n    def _append(self, widget: Widget) -> None:\n        \"\"\"Append a Widget.\n\n        Args:\n\n------------------------------\n------------------------------\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n\n        Returns:\n            Sequence of (WIDGET, REGION) tuples.\n        \"\"\"\n        return self._compositor.get_widgets_at(x, y)\n\n    def get_focusable_widget_at(self, x: int, y: int) -> Widget | None:\n        \"\"\"Get the focusable widget under a given coordinate.\n\n        If the widget directly under the given coordinate is not focusable, then this method will check\n        if any of the ancestors are focusable. If no ancestors are focusable, then `None` will be returned.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n\n\n------------------------------\n------------------------------\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        # TODO: This shouldn't be required\n        self._compositor._full_map_invalidated = True\n        if not isinstance(selector, str):\n            selector = selector.__name__\n        selector_set = parse_selectors(selector)\n        focus_chain = self.focus_chain\n        filtered_focus_chain = (\n            node for node in focus_chain if match(selector_set, node)\n        )\n\n        if not focus_chain:\n            # Nothing focusable, so nothing to do\n            return self.focused\n        if self.focused is None:\n\n------------------------------\n------------------------------\n        return widgets\n\n    def _move_focus(\n        self, direction: int = 0, selector: str | type[QueryType] = \"*\"\n    ) -> Widget | None:\n        \"\"\"Move the focus in the given direction.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            direction: 1 to move forward, -1 to move backward, or\n                0 to keep the current focus.\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: Implement this function\n    pass\n```\n", "```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: Implement focus_next function\n    pass\n```\n", "```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: Implement the function\n```\n"]}, "textual-src/textual/screen.py-focus_previous": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        ) -> ExpectType: ...\n\n    def get_widget_by_id(\n        self, id: str, expect_type: type[ExpectType] | None = None\n    ) -> ExpectType | Widget:\n        \"\"\"Get the first descendant widget with the given ID.\n\n        Performs a breadth-first search rooted at the current screen.\n        It will not return the Screen if that matches the ID.\n        To get the screen, use `self.screen`.\n\n        Args:\n            id: The ID to search for in the subtree\n            expect_type: Require the object be of the supplied type, or None for any type.\n                Defaults to None.\n\n        Returns:\n            The first descendant encountered with this ID.\n\n        Raises:\n\n------------------------------\n------------------------------\n\n        Args:\n            widget: The widget to find in the node list.\n\n        Returns:\n            The index of the widget in the node list.\n\n        Raises:\n            ValueError: If the widget is not in the node list.\n        \"\"\"\n        return self._nodes.index(widget, start, stop)\n\n    def _get_by_id(self, widget_id: str) -> Widget | None:\n        \"\"\"Get the widget for the given widget_id, or None if there's no matches in this list\"\"\"\n        return self._nodes_by_id.get(widget_id)\n\n    def _append(self, widget: Widget) -> None:\n        \"\"\"Append a Widget.\n\n        Args:\n\n------------------------------\n------------------------------\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n\n        Returns:\n            Sequence of (WIDGET, REGION) tuples.\n        \"\"\"\n        return self._compositor.get_widgets_at(x, y)\n\n    def get_focusable_widget_at(self, x: int, y: int) -> Widget | None:\n        \"\"\"Get the focusable widget under a given coordinate.\n\n        If the widget directly under the given coordinate is not focusable, then this method will check\n        if any of the ancestors are focusable. If no ancestors are focusable, then `None` will be returned.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n\n\n------------------------------\n------------------------------\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        # TODO: This shouldn't be required\n        self._compositor._full_map_invalidated = True\n        if not isinstance(selector, str):\n            selector = selector.__name__\n        selector_set = parse_selectors(selector)\n        focus_chain = self.focus_chain\n        filtered_focus_chain = (\n            node for node in focus_chain if match(selector_set, node)\n        )\n\n        if not focus_chain:\n            # Nothing focusable, so nothing to do\n            return self.focused\n        if self.focused is None:\n\n------------------------------\n------------------------------\n        return widgets\n\n    def _move_focus(\n        self, direction: int = 0, selector: str | type[QueryType] = \"*\"\n    ) -> Widget | None:\n        \"\"\"Move the focus in the given direction.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            direction: 1 to move forward, -1 to move backward, or\n                0 to keep the current focus.\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: Implement this method\n    pass\n```\n", "```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: Implement the focus_previous method\n    pass\n```\n", "```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # TODO: This shouldn't be required\n    self._compositor._full_map_invalidated = True\n    if not isinstance(selector, str):\n        selector = selector.__name__\n    selector_set = parse_selectors(selector)\n    focus_chain = self.focus_chain\n    filtered_focus_chain = (\n        node for node in focus_chain if match(selector_set, node)\n    )\n\n    if not focus_chain:\n        # Nothing focusable, so nothing to do\n        return self.focused\n    if self.focused is None:\n        # Nothing focused, so focus the first focusable widget\n        self.focused = next(filtered_focus_chain, None)\n        return self.focused\n\n    # Find the index of the currently focused widget in the focus chain\n    focused_index = next((index for index, node in enumerate(focus_chain) if node is self.focused), None)\n    if focused_index is not None and focused_index > 0:\n        # Focus the previous focusable widget\n        self.focused = focus_chain[focused_index - 1]\n    else:\n        # No previous focusable widget, so clear the focus\n        self.focused = None\n\n    return self.focused\n```\n"]}, "textual-src/textual/screen.py-set_focus": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return partial_style if partial else style\n\n    def render_str(self, text_content: str | Text) -> Text:\n        \"\"\"Convert str in to a Text object.\n\n        If you pass in an existing Text object it will be returned unaltered.\n\n        Args:\n            text_content: Text or str.\n\n        Returns:\n            A text object.\n        \"\"\"\n        text = (\n            Text.from_markup(text_content)\n            if isinstance(text_content, str)\n            else text_content\n        )\n        return text\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n    def _reset_focus(\n        self, widget: Widget, avoiding: list[Widget] | None = None\n    ) -> None:\n        \"\"\"Reset the focus when a widget is removed\n\n        Args:\n            widget: A widget that is removed.\n            avoiding: Optional list of nodes to avoid.\n        \"\"\"\n\n\n------------------------------\n------------------------------\n    def _start_widget(self, parent: Widget, widget: Widget) -> None:\n        \"\"\"Start a widget (run it's task) so that it can receive messages.\n\n        Args:\n            parent: The parent of the Widget.\n            widget: The Widget to start.\n        \"\"\"\n\n        widget._attach(parent)\n        widget._start_messages()\n        self.app._registry.add(widget)\n\n    def is_mounted(self, widget: Widget) -> bool:\n        \"\"\"Check if a widget is mounted.\n\n        Args:\n            widget: A widget.\n\n        Returns:\n            True of the widget is mounted.\n\n------------------------------\n------------------------------\n    def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n        \"\"\"Focus (or unfocus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\n        self.screen.set_focus(widget, scroll_visible)\n\n    def _set_mouse_over(self, widget: Widget | None) -> None:\n        \"\"\"Called when the mouse is over another widget.\n\n        Args:\n            widget: Widget under mouse, or None for no widgets.\n        \"\"\"\n        if widget is None:\n            if self.mouse_over is not None:\n                try:\n                    self.mouse_over.post_message(events.Leave())\n                finally:\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n        \"\"\"Focus (or unfocus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n# Natural Language Annotations: \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    self.screen.set_focus(widget, scroll_visible)\n```\n", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    self.screen.set_focus(widget, scroll_visible)\n```\n", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is None:\n        # Un-focus the currently focused widget\n        self.screen.set_focus(None, scroll_visible)\n    else:\n        # Focus a new widget\n        self.screen.set_focus(widget, scroll_visible)\n```\n"]}, "textual-src/textual/strip.py-index_to_cell_position": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def remove_option(self, option_id: str) -> Self:\n        \"\"\"Remove the option with the given ID.\n\n        Args:\n            option_id: The ID of the option to remove.\n\n        Returns:\n            The `OptionList` instance.\n\n        Raises:\n            OptionDoesNotExist: If no option has the given ID.\n        \"\"\"\n        self._remove_option(self.get_option_index(option_id))\n        return self\n\n    def remove_option_at_index(self, index: int) -> Self:\n        \"\"\"Remove the option at the given index.\n\n        Args:\n\n------------------------------\n------------------------------\n            return self\n        region = self._get_cell_region(coordinate)\n        self._refresh_region(region)\n        return self\n\n    def refresh_row(self, row_index: int) -> Self:\n        \"\"\"Refresh the row at the given index.\n\n        Args:\n            row_index: The index of the row to refresh.\n\n        Returns:\n            The `DataTable` instance.\n        \"\"\"\n        if not self.is_valid_row_index(row_index):\n            return self\n\n        region = self._get_row_region(row_index)\n        self._refresh_region(region)\n        return self\n\n------------------------------\n------------------------------\n        for the cursor to rest.\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the document is at the end of a line in the document.\n        \"\"\"\n        row, column = location\n        row_length = len(self._document[row])\n        return column == row_length\n\n    def is_end_of_wrapped_line(self, location: Location) -> bool:\n        \"\"\"True if the location is at the end of a wrapped line.\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the cursor is on the last wrapped section of *any* line.\n\n------------------------------\n------------------------------\n\n    def get_option_at_index(self, index: int) -> Option:\n        \"\"\"Get the option at the given index.\n\n        Args:\n            index: The index of the option to get.\n\n        Returns:\n            The option at that index.\n\n        Raises:\n            OptionDoesNotExist: If there is no option with the given index.\n        \"\"\"\n        try:\n            return self._options[index]\n        except IndexError:\n            raise OptionDoesNotExist(\n                f\"There is no option with an index of {index}\"\n            ) from None\n\n\n------------------------------\n------------------------------\n\n\nclass NoCellPositionForIndex(Exception):\n    pass\n\n\ndef index_to_cell_position(segments: Iterable[Segment], index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character within\n    an Iterable of Segments. This is the sum of the cell lengths of all the characters\n    *before* the character at `index`.\n\n    Args:\n        segments: The segments to find the cell position within.\n        index: The index to convert into a cell position.\n\n    Returns:\n        The cell position of the character at `index`.\n\n    Raises:\n        NoCellPositionForIndex: If the supplied index doesn't fall within the given segments.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def index_to_cell_position(self, index: int) -> int:\n# Natural Language Annotations: \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    if index < 0 or index >= len(self.document):\n        raise NoCellPositionForIndex(\"The supplied index doesn't fall within the given segments.\")\n\n    cell_position = 0\n    for i in range(index):\n        cell_position += len(self.document[i])\n\n    return cell_position\n```\n", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n\n    Raises:\n        NoCellPositionForIndex: If the supplied index doesn't fall within the given segments.\n    \"\"\"\n    try:\n        return sum(segment.cell_length for segment in self._segments[:index])\n    except IndexError:\n        raise NoCellPositionForIndex(f\"There is no cell position for index {index}\") from None\n```\n", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n\n    Raises:\n        NoCellPositionForIndex: If the supplied index doesn't fall within the given segments.\n    \"\"\"\n    cell_position = 0\n    for segment in self._segments:\n        if index < segment.length():\n            return cell_position + index\n        else:\n            cell_position += segment.length()\n            index -= segment.length()\n    raise NoCellPositionForIndex(f\"The supplied index doesn't fall within the given segments.\")\n```\n"]}, "textual-src/textual/strip.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Args:\n            widget: A widget.\n            region: A region of the widget to render.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\n\n        border_title = widget._border_title\n        border_subtitle = widget._border_subtitle\n\n        base_background, background = widget._opacity_background_colors\n        styles = widget.styles\n        strips = self.render(\n            styles,\n            widget.region.size,\n            base_background,\n            background,\n            widget.render_line,\n            widget.app.console,\n\n------------------------------\n------------------------------\n\n    def render(self) -> PrettyRenderable:\n        \"\"\"Render the pretty-printed object.\n\n        Returns:\n            The rendered pretty-print.\n        \"\"\"\n        return self._renderable\n\n    def update(self, object: Any) -> None:\n        \"\"\"Update the content of the pretty widget.\n\n        Args:\n            object: The object to pretty-print.\n        \"\"\"\n        self._renderable = PrettyRenderable(object)\n        self.clear_cached_dimensions()\n        self.refresh(layout=True)\n\n------------------------------\n------------------------------\n        \"\"\"Toggle an attribute on the node.\n\n        Assumes the attribute is a bool.\n\n        Args:\n            attribute_name: Name of the attribute.\n        \"\"\"\n        value = getattr(self, attribute_name)\n        setattr(self, attribute_name, not value)\n\n------------------------------\n------------------------------\n\n            if y != last_y:\n                yield new_line\n\n    def render_segments(self, console: Console) -> str:\n        \"\"\"Render the update to raw data, suitable for writing to terminal.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Raw data with escape sequences.\n        \"\"\"\n\n        sequences: list[str] = []\n        append = sequences.append\n\n        move_to = Control.move_to\n        chops = self.chops\n        chop_ends = self.chop_ends\n\n------------------------------\n------------------------------\n        \"\"\"Get a new Size with just the width changed.\n\n        Args:\n            width: New width.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(width, self.height)\n\n    def with_height(self, height: int) -> Size:\n        \"\"\"Get a new Size with just the height changed.\n\n        Args:\n            width: New height.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(self.width, height)\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self, console: Console) -> str:\n# Natural Language Annotations: \"\"\"Render the strip into terminal sequences.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Rendered sequences.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    sequences: list[str] = []\n    append = sequences.append\n\n    move_to = Control.move_to\n    chops = self.chops\n    chop_ends = self.chop_ends\n\n    # ... rest of the code ...\n```\n", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    sequences: list[str] = []\n    append = sequences.append\n\n    move_to = Control.move_to\n    chops = self.chops\n    chop_ends = self.chop_ends\n\n    # Implement your rendering logic here.\n\n    return \"\".join(sequences)\n```\n", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    sequences: list[str] = []\n    append = sequences.append\n\n    move_to = Control.move_to\n    chops = self.chops\n    chop_ends = self.chop_ends\n\n    # Render the strip\n    for chop in chops:\n        append(move_to(chop.x, chop.y))\n        append(chop.render(console))\n    append(chop_ends)\n\n    return \"\".join(sequences)\n```\n"]}, "textual-src/textual/app.py-batch_update": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Args:\n            start: The start location of the selection.\n            end: The end location of the selection.\n\n        Returns:\n            The text between start (inclusive) and end (exclusive).\n        \"\"\"\n\n    @abstractmethod\n    def get_size(self, indent_width: int) -> Size:\n        \"\"\"Get the size of the document.\n\n        The height is generally the number of lines, and the width\n        is generally the maximum cell length of all the lines.\n\n        Args:\n            indent_width: The width to use for tab characters.\n\n        Returns:\n\n------------------------------\n------------------------------\n    \"\"\"Uniquely identifies a row in the DataTable.\n\n    Even if the visual location\n    of the row changes due to sorting or other modifications, a key will always\n    refer to the same row.\"\"\"\n\n\nclass ColumnKey(StringKey):\n    \"\"\"Uniquely identifies a column in the DataTable.\n\n    Even if the visual location\n    of the column changes due to sorting or other modifications, a key will always\n    refer to the same column.\"\"\"\n\n\nclass CellKey(NamedTuple):\n    \"\"\"A unique identifier for a cell in the DataTable.\n\n    A cell key is a `(row_key, column_key)` tuple.\n\n\n------------------------------\n------------------------------\n        code_point_offset += 1\n\n    # Mapping for the end of the string\n    byte_to_codepoint[current_byte_offset] = code_point_offset\n    return byte_to_codepoint\n\n------------------------------\n------------------------------\n\n    def append(self, item: ListItem) -> AwaitMount:\n        \"\"\"Append a new ListItem to the end of the ListView.\n\n        Args:\n            item: The ListItem to append.\n\n        Returns:\n            An awaitable that yields control to the event loop\n                until the DOM has been updated with the new child item.\n        \"\"\"\n        return self.extend([item])\n\n    def clear(self) -> AwaitRemove:\n        \"\"\"Clear all items from the ListView.\n\n        Returns:\n            An awaitable that yields control to the event loop until\n                the DOM has been updated to reflect all children being removed.\n        \"\"\"\n\n------------------------------\n------------------------------\n\"\"\"The severity level for a notification.\"\"\"\n\n\n@dataclass\nclass Notify(Message, bubble=False):\n    \"\"\"Message to show a notification.\"\"\"\n\n    notification: Notification\n\n\n@dataclass\nclass Notification:\n    \"\"\"Holds the details of a notification.\"\"\"\n\n    message: str\n    \"\"\"The message for the notification.\"\"\"\n\n    title: str = \"\"\n    \"\"\"The title for the notification.\"\"\"\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def batch_update(self) -> Generator[None, None, None]:\n# Natural Language Annotations: \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Generator\n\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    try:\n        # Suspend repaints\n        self._suspend_repaints = True\n\n        yield None\n    finally:\n        # Resume repaints\n        self._suspend_repaints = False\n```\n", "```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    try:\n        # Suspend repaints\n        self.suspend_repaints()\n        yield\n    finally:\n        # Resume repaints and update the UI\n        self.resume_repaints()\n        self.update_ui()\n```\n", "```python\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    # Store the current state of the batch update\n    old_state = self.is_batch_update\n\n    # Start the batch update\n    self.is_batch_update = True\n\n    try:\n        # Yield control to the caller\n        yield\n    finally:\n        # Restore the old state\n        self.is_batch_update = old_state\n```\n"]}, "textual-src/textual/app.py-call_from_thread": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def _get_prevented_messages(self) -> set[type[Message]]:\n        \"\"\"A set of all the prevented message types.\"\"\"\n        return self._prevent_message_types_stack[-1]\n\n    def _is_prevented(self, message_type: type[Message]) -> bool:\n        \"\"\"Check if a message type has been prevented via the\n        [prevent][textual.message_pump.MessagePump.prevent] context manager.\n\n        Args:\n            message_type: A message type.\n\n        Returns:\n            `True` if the message has been prevented from sending, or `False` if it will be sent as normal.\n        \"\"\"\n        return message_type in self._prevent_message_types_stack[-1]\n\n    @contextmanager\n    def prevent(self, *message_types: type[Message]) -> Generator[None, None, None]:\n        \"\"\"A context manager to *temporarily* prevent the given message types from being posted.\n\n\n------------------------------\n------------------------------\n    ) -> bool:\n        \"\"\"Simulate a [`MouseUp`][textual.events.MouseUp] event at a specified position.\n\n        The final position for the event is computed based on the selector provided and\n        the offset specified and it must be within the visible area of the screen.\n\n        Args:\n            selector: A selector to specify a widget that should be used as the reference\n                for the event offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the event may not land on the widget you specified.\n            offset: The offset for the event. The offset is relative to the selector\n                provided or to the screen, if no selector is provided.\n            shift: Simulate the event with the shift key held down.\n            meta: Simulate the event with the meta key held down.\n            control: Simulate the event with the control key held down.\n\n        Raises:\n            OutOfBounds: If the position for the event is outside of the (visible) screen.\n\n------------------------------\n------------------------------\n    ) -> bool:\n        \"\"\"Simulate a [`MouseDown`][textual.events.MouseDown] event at a specified position.\n\n        The final position for the event is computed based on the selector provided and\n        the offset specified and it must be within the visible area of the screen.\n\n        Args:\n            selector: A selector to specify a widget that should be used as the reference\n                for the event offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to target a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the event may not land on the widget you specified.\n            offset: The offset for the event. The offset is relative to the selector\n                provided or to the screen, if no selector is provided.\n            shift: Simulate the event with the shift key held down.\n            meta: Simulate the event with the meta key held down.\n            control: Simulate the event with the control key held down.\n\n        Raises:\n            OutOfBounds: If the position for the event is outside of the (visible) screen.\n\n------------------------------\n------------------------------\n\n        !!! warning\n\n            This method is only called if no other description has been supplied. If you supply a description\n            inside a call to `self.failure(description=\"...\")`, or pass a description into the constructor of\n            the validator, those will take priority, and this method won't be called.\n\n        Args:\n            failure: Information about why the validation failed.\n\n        Returns:\n            A string description of the failure.\n        \"\"\"\n        return self.failure_description\n\n    def success(self) -> ValidationResult:\n        \"\"\"Shorthand for `ValidationResult(True)`.\n\n        You can return success() from a `Validator.validate` method implementation to signal\n        that validation has succeeded.\n\n------------------------------\n------------------------------\n        self, result: ScreenResultType | Type[_NoResult] = _NoResult\n    ) -> AwaitComplete:\n        \"\"\"Dismiss the screen, optionally with a result.\n\n        !!! note\n\n            Only the active screen may be dismissed. If you try to dismiss a screen that isn't active,\n            this method will raise a `ScreenError`.\n\n        If `result` is provided and a callback was set when the screen was [pushed][textual.app.App.push_screen], then\n        the callback will be invoked with `result`.\n\n        Args:\n            result: The optional result to be passed to the result callback.\n\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_from_thread(\n# Natural Language Annotations: \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef call_from_thread(self, callback, *args, **kwargs):\n    \"\"\"Run a callable from another thread, and return the result.\n\n    Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n    or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n    This method will ensure that your code runs within the correct context.\n\n    !!! tip\n\n        Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n    Args:\n        callback: A callable to run.\n        *args: Arguments to the callback.\n        **kwargs: Keyword arguments for the callback.\n\n    Raises:\n        RuntimeError: If the app isn't running or if this method is called from the same\n            thread where the app is running.\n\n    Returns:\n        The result of the callback.\n    \"\"\"\n    if threading.current_thread() == threading.main_thread():\n        raise RuntimeError(\"Cannot call this method from the main thread.\")\n    elif not self.app.running:\n        raise RuntimeError(\"App is not running.\")\n\n    result = None\n    event = threading.Event()\n\n    def run_callback():\n        nonlocal result\n        result = callback(*args, **kwargs)\n        event.set()\n\n    self.app.call_from_thread(run_callback)\n    event.wait()\n\n    return result\n```\n", "```python\ndef call_from_thread(self, callback: Callable, *args, **kwargs):\n    \"\"\"Run a callable from another thread, and return the result.\"\"\"\n\n    if not self.app._running:\n        raise RuntimeError(\"App is not running.\")\n\n    if threading.get_ident() == self.app._main_thread_id:\n        raise RuntimeError(\n            \"Cannot call methods from the main thread when the app is running.\"\n        )\n\n    future = asyncio.run_coroutine_threadsafe(callback(*args, **kwargs), self.app._loop)\n    return future.result()\n```\n", "```python\nfrom typing import Callable, TypeVar, Generic, Any\nimport functools\nfrom textual.app import App\n\nT = TypeVar('T')\n\ndef call_from_thread(\n    self, \n    callback: Callable[..., T], \n    *args: Any, \n    **kwargs: Any\n) -> T:\n    if not isinstance(self, App):\n        raise TypeError('The first argument must be an instance of textual.App')\n\n    if threading.current_thread() == threading.main_thread():\n        raise RuntimeError('Cannot call this method from the main thread')\n\n    loop = asyncio.get_event_loop()\n    if not loop.is_running():\n        raise RuntimeError('The app is not running')\n\n    future = loop.run_in_executor(None, functools.partial(callback, *args, **kwargs))\n    return future.result()\n```\nIn this code, `call_from_thread` is a method that takes a callable (`callback`), and any number of positional and keyword arguments, and runs the callable in a separate thread. The method returns the result of the callable.\n\nThe callable is run in a separate thread via `loop.run_in_executor`, which is an asynchronous method that runs the provided callable in a separate thread. It returns a `concurrent.futures.Future` object, which is a handle on the callable that has been scheduled to run.\n\nThe `result()` method of the Future object is then called to get the result of the callable. Note that if the callable raises an exception, the Future object's `result()` method will raise a `concurrent.futures.InvalidStateError`.\n"]}, "textual-src/textual/app.py-run_test": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                `False` if the action is disabled+hidden,\n                `None` if the action is disabled+visible (grayed out in footer)\n        \"\"\"\n        return True\n\n    def refresh_bindings(self) -> None:\n        \"\"\"Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update\n        the display of key bindings.\n\n        See [actions](/guide/actions#dynamic-actions) for how to use this method.\n\n        \"\"\"\n        self.screen.refresh_bindings()\n\n    async def action_toggle(self, attribute_name: str) -> None:\n        \"\"\"Toggle an attribute on the node.\n\n        Assumes the attribute is a bool.\n\n        Args:\n\n------------------------------\n------------------------------\n        self, result: ScreenResultType | Type[_NoResult] = _NoResult\n    ) -> AwaitComplete:\n        \"\"\"Dismiss the screen, optionally with a result.\n\n        !!! note\n\n            Only the active screen may be dismissed. If you try to dismiss a screen that isn't active,\n            this method will raise a `ScreenError`.\n\n        If `result` is provided and a callback was set when the screen was [pushed][textual.app.App.push_screen], then\n        the callback will be invoked with `result`.\n\n        Args:\n            result: The optional result to be passed to the result callback.\n\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n\n\n------------------------------\n------------------------------\n\n        Args:\n            user_input: The text that the user has input.\n            case_sensitive: Should matching be case sensitive?\n\n        Returns:\n            A [fuzzy matcher][textual.fuzzy.Matcher] object for matching against candidate hits.\n        \"\"\"\n        return Matcher(\n            user_input, match_style=self.match_style, case_sensitive=case_sensitive\n        )\n\n    def _post_init(self) -> None:\n        \"\"\"Internal method to run post init task.\"\"\"\n\n        async def post_init_task() -> None:\n            \"\"\"Wrapper to post init that runs in a task.\"\"\"\n            try:\n                await self.startup()\n            except Exception:\n\n------------------------------\n------------------------------\n    ) -> bool:\n        \"\"\"Simulate clicking with the mouse at a specified position.\n\n        The final position to be clicked is computed based on the selector provided and\n        the offset specified and it must be within the visible area of the screen.\n\n        Example:\n            The code below runs an app and clicks its only button right in the middle:\n            ```py\n            async with SingleButtonApp().run_test() as pilot:\n                await pilot.click(Button, offset=(8, 1))\n            ```\n\n        Args:\n            selector: A selector to specify a widget that should be used as the reference\n                for the click offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to click on a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the click may not land on the widget you specified.\n            offset: The offset to click. The offset is relative to the selector provided\n\n------------------------------\n------------------------------\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> ReturnType | None:\n        \"\"\"Run the app asynchronously.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n\n        app = self\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_test(\n# Natural Language Annotations: \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def run_test(\n        self,\n        headless: bool = True,\n        size: tuple[int, int] | None = None,\n        tooltips: bool = True,\n        notifications: bool = True,\n        message_hook: Callable[[Message], None] | None = None,\n    ) -> AsyncContextManager[Pilot]:\n        \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\n```\n", "```python\nasync def run_test(\n        self,\n        headless: bool = True,\n        size: tuple[int, int] | None = None,\n        tooltips: bool = False,\n        notifications: bool = False,\n        message_hook: Callable[[Message], None] | None = None,\n) -> AsyncContextManager[Pilot]:\n    \"\"\"An asynchronous context manager for testing apps.\n\n    !!! tip\n\n        See the guide for [testing](/guide/testing) Textual apps.\n\n    Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n    Example:\n\n        ```python\n        async with app.run_test() as pilot:\n            await pilot.click(\"#Button.ok\")\n            assert ...\n        ```\n\n    Args:\n        headless: Run in headless mode (no output or input).\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        tooltips: Enable tooltips when testing.\n        notifications: Enable notifications when testing.\n        message_hook: An optional callback that will be called each time any message arrives at any\n            message pump in the app.\n    \"\"\"\n```\n", "```python\nasync def run_test(\n        self,\n        headless: bool = True,\n        size: tuple[int, int] | None = None,\n        tooltips: bool = True,\n        notifications: bool = True,\n        message_hook: Callable[[str, Message], None] | None = None,\n) -> AsyncContextManager[Pilot]:\n    \"\"\"An asynchronous context manager for testing apps.\n\n    Please see the guide for [testing](/guide/testing) Textual apps.\n\n    Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n    Example:\n\n        ```python\n        async with app.run_test() as pilot:\n            await pilot.click(\"#Button.ok\")\n            assert ...\n        ```\n\n    Args:\n        headless: Run in headless mode (no output or input).\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        tooltips: Enable tooltips when testing.\n        notifications: Enable notifications when testing.\n        message_hook: An optional callback that will be called each time any message arrives at any\n            message pump in the app.\n    \"\"\"\n```\n"]}, "textual-src/textual/app.py-run": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @property\n    def size(self) -> Size:\n        \"\"\"The size of the terminal.\n\n        Returns:\n            Size of the terminal.\n        \"\"\"\n        if self._driver is not None and self._driver._size is not None:\n            width, height = self._driver._size\n        else:\n            width, height = self.console.size\n        return Size(width, height)\n\n    def _get_inline_height(self) -> int:\n        \"\"\"Get the inline height (height when in inline mode).\n\n        Returns:\n            Height in lines.\n        \"\"\"\n        size = self.size\n\n------------------------------\n------------------------------\n    \"\"\"A base class for drivers.\"\"\"\n\n    def __init__(\n        self,\n        app: App,\n        *,\n        debug: bool = False,\n        mouse: bool = True,\n        size: tuple[int, int] | None = None,\n    ) -> None:\n        \"\"\"Initialize a driver.\n\n        Args:\n            app: The App instance.\n            debug: Enable debug mode.\n            mouse: Enable mouse support,\n            size: Initial size of the terminal or `None` to detect.\n        \"\"\"\n        self._app = app\n        self._debug = debug\n\n------------------------------\n------------------------------\n    def is_headless(self) -> bool:\n        \"\"\"Is the driver 'headless' (no output)?\"\"\"\n        return False\n\n    @property\n    def is_inline(self) -> bool:\n        \"\"\"Is the driver 'inline' (not full-screen)?\"\"\"\n        return False\n\n    @property\n    def can_suspend(self) -> bool:\n        \"\"\"Can this driver be suspended?\"\"\"\n        return False\n\n    def send_event(self, event: events.Event) -> None:\n        \"\"\"Send an event to the target app.\n\n        Args:\n            event: An event.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n    async def run_async(\n        self,\n        *,\n        headless: bool = False,\n        inline: bool = False,\n        inline_no_clear: bool = False,\n        mouse: bool = True,\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> ReturnType | None:\n        \"\"\"Run the app asynchronously.\n\n\n------------------------------\n------------------------------\n        size: tuple[int, int] | None = None,\n        auto_pilot: AutopilotCallbackType | None = None,\n    ) -> ReturnType | None:\n        \"\"\"Run the app asynchronously.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\n        from .pilot import Pilot\n\n        app = self\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def run(\n# Natural Language Annotations: \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef run(\n    self,\n    *,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    from .pilot import Pilot\n\n    app = self\n```\n", "```python\ndef run(\n    self,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    from .pilot import Pilot\n\n    app = self\n```\n", "```python\ndef run(\n    self,\n    *,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    # Your code here\n```\n"]}, "textual-src/textual/app.py-switch_mode": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def add_tab(\n        self,\n        tab: Tab | str | Text,\n        *,\n        before: Tab | str | None = None,\n        after: Tab | str | None = None,\n    ) -> AwaitComplete:\n        \"\"\"Add a new tab to the end of the tab list.\n\n        Args:\n            tab: A new tab object, or a label (str or Text).\n            before: Optional tab or tab ID to add the tab before.\n            after: Optional tab or tab ID to add the tab after.\n\n        Returns:\n            An optionally awaitable object that waits for the tab to be mounted and\n                internal state to be fully updated to reflect the new tab.\n\n        Raises:\n            Tabs.TabError: If there is a problem with the addition request.\n\n------------------------------\n------------------------------\n\n        Args:\n            pane: The pane to add.\n            before: Optional pane or pane ID to add the pane before.\n            after: Optional pane or pane ID to add the pane after.\n\n        Returns:\n            An optionally awaitable object that waits for the pane to be added.\n\n        Raises:\n            Tabs.TabError: If there is a problem with the addition request.\n\n        Note:\n            Only one of `before` or `after` can be provided. If both are\n            provided an exception is raised.\n        \"\"\"\n        if isinstance(before, TabPane):\n            before = before.id\n        if isinstance(after, TabPane):\n            after = after.id\n\n------------------------------\n------------------------------\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n\n------------------------------\n------------------------------\n        \"\"\"Mount the given widgets relative to the app's screen.\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n\n------------------------------\n------------------------------\n        after: int | str | Widget | None = None,\n    ) -> AwaitMount:\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_mode(self, mode: str) -> AwaitMount:\n# Natural Language Annotations: \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    \"\"\"Switch to a given mode.\n\n    Args:\n        mode: The mode to switch to.\n\n    Returns:\n        An optionally awaitable object which waits for the screen associated\n            with the mode to be mounted.\n\n    Raises:\n        UnknownModeError: If trying to switch to an unknown mode.\n    \"\"\"\n```\n", "```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    \"\"\"Switch to a given mode.\n\n    Args:\n        mode: The mode to switch to.\n\n    Returns:\n        An optionally awaitable object which waits for the screen associated\n            with the mode to be mounted.\n\n    Raises:\n        UnknownModeError: If trying to switch to an unknown mode.\n    \"\"\"\n```\n", "```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    \"\"\"Switch to a given mode.\n\n    Args:\n        mode: The mode to switch to.\n\n    Returns:\n        An optionally awaitable object which waits for the screen associated\n            with the mode to be mounted.\n\n    Raises:\n        UnknownModeError: If trying to switch to an unknown mode.\n    \"\"\"\n```\n"]}, "textual-src/textual/app.py-push_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n    def install_screen(self, screen: Screen, name: str) -> None:\n        \"\"\"Install a screen.\n\n        Installing a screen prevents Textual from destroying it when it is no longer on the screen stack.\n        Note that you don't need to install a screen to use it. See [push_screen][textual.app.App.push_screen]\n        or [switch_screen][textual.app.App.switch_screen] to make a new screen current.\n\n        Args:\n            screen: Screen to install.\n            name: Unique name to identify the screen.\n\n        Raises:\n            ScreenError: If the screen can't be installed.\n\n\n------------------------------\n------------------------------\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n\n        \"\"\"\n        if not self.is_active:\n            from .app import ScreenError\n\n            raise ScreenError(\"Screen is not active\")\n        if result is not self._NoResult and self._result_callbacks:\n            self._result_callbacks[-1](cast(ScreenResultType, result))\n        await_pop = self.app.pop_screen()\n        return await_pop\n\n    async def action_dismiss(\n        self, result: ScreenResultType | Type[_NoResult] = _NoResult\n    ) -> None:\n        \"\"\"A wrapper around [`dismiss`][textual.screen.Screen.dismiss] that can be called as an action.\n\n\n------------------------------\n------------------------------\n        self, result: ScreenResultType | Type[_NoResult] = _NoResult\n    ) -> AwaitComplete:\n        \"\"\"Dismiss the screen, optionally with a result.\n\n        !!! note\n\n            Only the active screen may be dismissed. If you try to dismiss a screen that isn't active,\n            this method will raise a `ScreenError`.\n\n        If `result` is provided and a callback was set when the screen was [pushed][textual.app.App.push_screen], then\n        the callback will be invoked with `result`.\n\n        Args:\n            result: The optional result to be passed to the result callback.\n\n        Raises:\n            ScreenError: If the screen being dismissed is not active.\n            ScreenStackError: If trying to dismiss a screen that is not at the top of\n                the stack.\n\n\n------------------------------\n------------------------------\n        else:\n            next_screen = screen\n        return next_screen\n\n    def _get_screen(self, screen: Screen | str) -> tuple[Screen, AwaitMount]:\n        \"\"\"Get an installed screen and an AwaitMount object.\n\n        If the screen isn't running, it will be registered before it is run.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Raises:\n            KeyError: If the named screen doesn't exist.\n\n        Returns:\n            A screen instance and an awaitable that awaits the children mounting.\n        \"\"\"\n        _screen = self.get_screen(screen)\n        if not _screen.is_running:\n\n------------------------------\n------------------------------\n        async def push_screen_wait(self, screen: str) -> Any: ...\n\n    async def push_screen_wait(\n        self, screen: Screen[ScreenResultType] | str\n    ) -> ScreenResultType | Any:\n        \"\"\"Push a screen and wait for the result (received from [`Screen.dismiss`][textual.screen.Screen.dismiss]).\n\n        Note that this method may only be called when running in a worker.\n\n        Args:\n            screen: A screen or the name of an installed screen.\n\n        Returns:\n            The screen's result.\n        \"\"\"\n        await self._flush_next_callbacks()\n        return await self.push_screen(screen, wait_for_dismiss=True)\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def push_screen(\n# Natural Language Annotations: \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n        Args:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n                this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n        Raises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def push_screen(\n    self, \n    screen: Screen | str, \n    callback: Callable[[ScreenResultType], None] | None = None, \n    wait_for_dismiss: bool = False\n) -> AwaitMount | AwaitComplete:\n    \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    # Your code here\n```\n", "```python\nasync def push_screen(\n    self, \n    screen: Screen | str, \n    callback: Callable[[ScreenResultType], None] | None = None, \n    wait_for_dismiss: bool = False\n) -> AwaitComplete | AwaitMount | asyncio.Future:\n    \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    if wait_for_dismiss and not self.app.is_worker:\n        raise NoActiveWorker(\"Cannot wait for dismiss outside of a worker\")\n\n    if callback:\n        self._result_callbacks.append(callback)\n\n    next_screen, await_mount = self._get_screen(screen)\n    self._screen_stack.append(next_screen)\n    await_pop = self.app.push_screen(screen_name=next_screen.name, callback=callback)\n    if wait_for_dismiss:\n        result = await await_pop\n        return result\n    else:\n        return await_mount\n```\n", "```python\ndef push_screen(\n        self, \n        screen: Screen | str, \n        callback: Callable[[ScreenResultType], None] | None = None, \n        wait_for_dismiss: bool = False\n    ) -> AwaitMount | AwaitComplete:\n    if wait_for_dismiss and not self.app.is_running_in_worker:\n        raise NoActiveWorker(\"Attempting to wait for dismiss in non-worker thread\")\n\n    _screen, await_mount = self._get_screen(screen)\n    if callback is not None:\n        _screen._result_callbacks.append(callback)\n\n    self._stack.append(_screen)\n    self._active_screen = _screen\n    self._on_screen_pushed(_screen)\n\n    if wait_for_dismiss:\n        return asyncio.ensure_future(self._wait_for_dismiss())\n    else:\n        return await_mount\n```\n"]}, "textual-src/textual/app.py-switch_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n\n\n\n\n    def install_screen(self, screen: Screen, name: str) -> None:\n        \"\"\"Install a screen.\n\n        Installing a screen prevents Textual from destroying it when it is no longer on the screen stack.\n        Note that you don't need to install a screen to use it. See [push_screen][textual.app.App.push_screen]\n        or [switch_screen][textual.app.App.switch_screen] to make a new screen current.\n\n        Args:\n            screen: Screen to install.\n            name: Unique name to identify the screen.\n\n        Raises:\n            ScreenError: If the screen can't be installed.\n\n\n------------------------------\n------------------------------\n    async def action_push_screen(self, screen: str) -> None:\n        \"\"\"An [action](/guide/actions) to push a new screen on to the stack and make it active.\n\n        Args:\n            screen: Name of the screen.\n        \"\"\"\n        self.push_screen(screen)\n\n    async def action_pop_screen(self) -> None:\n        \"\"\"An [action](/guide/actions) to remove the topmost screen and makes the new topmost screen active.\"\"\"\n        self.pop_screen()\n\n    async def action_switch_mode(self, mode: str) -> None:\n        \"\"\"An [action](/guide/actions) that switches to the given mode..\"\"\"\n        self.switch_mode(mode)\n\n    async def action_back(self) -> None:\n        \"\"\"An [action](/guide/actions) to go back to the previous screen (pop the current screen).\n\n        Note:\n\n------------------------------\n------------------------------\n        else:\n            next_screen = screen\n        return next_screen\n\n    def _get_screen(self, screen: Screen | str) -> tuple[Screen, AwaitMount]:\n        \"\"\"Get an installed screen and an AwaitMount object.\n\n        If the screen isn't running, it will be registered before it is run.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Raises:\n            KeyError: If the named screen doesn't exist.\n\n        Returns:\n            A screen instance and an awaitable that awaits the children mounting.\n        \"\"\"\n        _screen = self.get_screen(screen)\n        if not _screen.is_running:\n\n------------------------------\n------------------------------\n\n        stack = self._screen_stacks[mode]\n        del self._screen_stacks[mode]\n\n        async def remove_screens() -> None:\n            \"\"\"Remove screens.\"\"\"\n            for screen in reversed(stack):\n                await self._replace_screen(screen)\n\n        return AwaitComplete(remove_screens()).call_next(self)\n\n    def is_screen_installed(self, screen: Screen | str) -> bool:\n        \"\"\"Check if a given screen has been installed.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Returns:\n            True if the screen is currently installed,\n        \"\"\"\n\n------------------------------\n------------------------------\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Returns:\n            True if the screen is currently installed,\n        \"\"\"\n        if isinstance(screen, str):\n            return screen in self._installed_screens\n        else:\n            return screen in self._installed_screens.values()\n\n    def get_screen(self, screen: Screen | str) -> Screen:\n        \"\"\"Get an installed screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n\n        Raises:\n            KeyError: If the named screen doesn't exist.\n\n        Returns:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    screen, await_mount = self._get_screen(screen)\n    return await_mount.call_next(lambda: self._switch_screen(screen))\n```\n", "```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    async def _switch_screen() -> None:\n        if not self.is_screen_installed(screen):\n            raise ScreenError(f\"The screen {screen} is not installed.\")\n\n        _screen, await_mount = self._get_screen(screen)\n        await self.action_pop_screen()\n        self.push_screen(_screen)\n\n    return AwaitComplete(_switch_screen()).call_next(self)\n```\n", "```python\nasync def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    if isinstance(screen, str):\n        _screen = self.get_screen(screen)\n    else:\n        _screen = screen\n\n    if not _screen.is_running:\n        self.install_screen(_screen, _screen.name)\n\n    async def switch_screen_task() -> None:\n        \"\"\"Switch screen task.\"\"\"\n        await self.pop_screen()\n        await self.push_screen(_screen)\n\n    return AwaitComplete(switch_screen_task()).call_next(self)\n``` \n\nThis function will switch to another screen by replacing the top of the screen stack with a new screen. It first checks if the new screen is a string (in which case it retrieves the screen from the installed screens), and if it's not running, it installs it. Then, it defines an asynchronous function to pop the current screen and push the new screen, and returns an AwaitComplete object that will call this function when the current screen is done running.\n"]}, "textual-src/textual/app.py-pop_screen": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            node = self.query(f\"#{widget_id}\").first()\n        except NoMatches:\n            pass\n        else:\n            if isinstance(node, Widget):\n                self.set_focus(node)\n\n    async def action_switch_screen(self, screen: str) -> None:\n        \"\"\"An [action](/guide/actions) to switch screens.\n\n        Args:\n            screen: Name of the screen.\n        \"\"\"\n        self.switch_screen(screen)\n\n    async def action_push_screen(self, screen: str) -> None:\n        \"\"\"An [action](/guide/actions) to push a new screen on to the stack and make it active.\n\n        Args:\n            screen: Name of the screen.\n\n------------------------------\n------------------------------\n    def down(self) -> Coordinate:\n        \"\"\"Get the coordinate below.\n\n        Returns:\n            The coordinate below.\n        \"\"\"\n        row, column = self\n        return Coordinate(row + 1, column)\n\n------------------------------\n------------------------------\n        Returns:\n            The coordinate to the right.\n        \"\"\"\n        row, column = self\n        return Coordinate(row, column + 1)\n\n    def up(self) -> Coordinate:\n        \"\"\"Get the coordinate above.\n\n        Returns:\n            The coordinate above.\n        \"\"\"\n        row, column = self\n        return Coordinate(row - 1, column)\n\n    def down(self) -> Coordinate:\n        \"\"\"Get the coordinate below.\n\n        Returns:\n            The coordinate below.\n\n------------------------------\n------------------------------\n        \"\"\"An [action](/guide/actions) to add a CSS class to the selected widget.\n\n        Args:\n            selector: Selects the widget to add the class to.\n            class_name: The class to add to the selected widget.\n        \"\"\"\n        self.screen.query(selector).add_class(class_name)\n\n    async def action_remove_class(self, selector: str, class_name: str) -> None:\n        \"\"\"An [action](/guide/actions) to remove a CSS class from the selected widget.\n\n        Args:\n            selector: Selects the widget to remove the class from.\n            class_name: The class to remove from  the selected widget.\"\"\"\n        self.screen.query(selector).remove_class(class_name)\n\n    async def action_toggle_class(self, selector: str, class_name: str) -> None:\n        \"\"\"An [action](/guide/actions) to toggle a CSS class on the selected widget.\n\n        Args:\n\n------------------------------\n------------------------------\n    async def action_push_screen(self, screen: str) -> None:\n        \"\"\"An [action](/guide/actions) to push a new screen on to the stack and make it active.\n\n        Args:\n            screen: Name of the screen.\n        \"\"\"\n        self.push_screen(screen)\n\n    async def action_pop_screen(self) -> None:\n        \"\"\"An [action](/guide/actions) to remove the topmost screen and makes the new topmost screen active.\"\"\"\n        self.pop_screen()\n\n    async def action_switch_mode(self, mode: str) -> None:\n        \"\"\"An [action](/guide/actions) that switches to the given mode..\"\"\"\n        self.switch_mode(mode)\n\n    async def action_back(self) -> None:\n        \"\"\"An [action](/guide/actions) to go back to the previous screen (pop the current screen).\n\n        Note:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def pop_screen(self) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    replaced_screen = self.pop_screen()\n    self.switch_screen(replaced_screen)\n    return replaced_screen\n```\n", "```python\nasync def pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    return self.pop_screen()\n```\n", "```python\nasync def pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current screen from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    previous_screen = self.screen_stack.pop()\n    self.switch_screen(previous_screen)\n    return previous_screen\n```\n"]}, "textual-src/textual/app.py-run_action": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n                message.stop()\n            if self.is_parent_active and self.is_attached:\n                message._bubble_to(self._parent)\n\n    def check_idle(self) -> None:\n        \"\"\"Prompt the message pump to call idle if the queue is empty.\"\"\"\n        if self._running and self._message_queue.empty():\n            self.post_message(messages.Prompt())\n\n    async def _post_message(self, message: Message) -> bool:\n        \"\"\"Post a message or an event to this message pump.\n\n        This is an internal method for use where a coroutine is required.\n\n        Args:\n            message: A message object.\n\n        Returns:\n            True if the messages was posted successfully, False if the message was not posted\n                (because the message pump was in the process of closing).\n\n------------------------------\n------------------------------\n\n    async def action_back(self) -> None:\n        \"\"\"An [action](/guide/actions) to go back to the previous screen (pop the current screen).\n\n        Note:\n            If there is no screen to go back to, this is a non-operation (in\n            other words it's safe to call even if there are no other screens\n            on the stack.)\n        \"\"\"\n        try:\n            self.pop_screen()\n        except ScreenStackError:\n            pass\n\n    async def action_add_class(self, selector: str, class_name: str) -> None:\n        \"\"\"An [action](/guide/actions) to add a CSS class to the selected widget.\n\n        Args:\n            selector: Selects the widget to add the class to.\n            class_name: The class to add to the selected widget.\n\n------------------------------\n------------------------------\n        return self.css_identifier_styled\n\n    def _render(self) -> ConsoleRenderable | RichCast:\n        \"\"\"Get renderable, promoting str to text as required.\n\n        Returns:\n            A renderable.\n        \"\"\"\n        renderable = self.render()\n        if isinstance(renderable, str):\n            return Text.from_markup(renderable)\n        return renderable\n\n    async def run_action(self, action: str) -> None:\n        \"\"\"Perform a given action, with this widget as the default namespace.\n\n        Args:\n            action: Action encoded as a string.\n        \"\"\"\n        await self.app.run_action(action, self)\n\n------------------------------\n------------------------------\n        self, *, repaint: bool = True, layout: bool = False, recompose: bool = False\n    ) -> Self:\n        return self\n\n    def check_action(self, action: str, parameters: tuple[object, ...]) -> bool | None:\n        \"\"\"Check whether an action is enabled.\n\n        Implement this method to add logic for [dynamic actions](/guide/actions#dynamic-actions) / bindings.\n\n        Args:\n            action: The name of an action.\n            action_parameters: A tuple of any action parameters.\n\n        Returns:\n            `True` if the action is enabled+visible,\n                `False` if the action is disabled+hidden,\n                `None` if the action is disabled+visible (grayed out in footer)\n        \"\"\"\n        return True\n\n\n------------------------------\n------------------------------\n                `False` if the action is disabled+hidden,\n                `None` if the action is disabled+visible (grayed out in footer)\n        \"\"\"\n        return True\n\n    def refresh_bindings(self) -> None:\n        \"\"\"Call to prompt widgets such as the [Footer][textual.widgets.Footer] to update\n        the display of key bindings.\n\n        See [actions](/guide/actions#dynamic-actions) for how to use this method.\n\n        \"\"\"\n        self.screen.refresh_bindings()\n\n    async def action_toggle(self, attribute_name: str) -> None:\n        \"\"\"Toggle an attribute on the node.\n\n        Assumes the attribute is a bool.\n\n        Args:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_action(\n# Natural Language Annotations: \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def run_action(self, action: str, default_namespace: str | None = None) -> bool:\n    \"\"\"Perform an [action](/guide/actions).\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    pass\n```\n", "```python\nasync def run_action(self, action: str, default_namespace: object = None) -> bool:\n    \"\"\"Perform an [action](/guide/actions).\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n```\n", "```python\nasync def run_action(self, action: str, default_namespace: str | None = None) -> bool:\n    \"\"\"Perform an [action](/guide/actions).\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    namespace = default_namespace if default_namespace is not None else self.app\n    # Add your code here to handle the action\n    return True\n```\n"]}, "textual-src/textual/file_monitor.py-check": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Returns:\n            True if and only if the cursor is on the first wrapped section of the first line.\n        \"\"\"\n        if not self.is_first_document_line(location):\n            return False\n\n        row, column = location\n        wrap_offsets = self._wrapped_document.get_offsets(row)\n\n        if not wrap_offsets:\n            return True\n\n        if column < wrap_offsets[0]:\n            return True\n        return False\n\n    def is_last_document_line(self, location: Location) -> bool:\n        \"\"\"Check if the given location is on the last line of the document.\n\n        Args:\n\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Iterable\n\nfrom .model import CombinatorType, Selector, SelectorSet\n\nif TYPE_CHECKING:\n    from ..dom import DOMNode\n\n\ndef match(selector_sets: Iterable[SelectorSet], node: DOMNode) -> bool:\n    \"\"\"Check if a given node matches any of the given selector sets.\n\n    Args:\n        selector_sets: Iterable of selector sets.\n        node: DOM node.\n\n    Returns:\n        True if the node matches the selector, otherwise False.\n    \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n    def add_paths(self, paths: Iterable[Path]) -> None:\n        \"\"\"Adds paths to start being monitored.\n\n        Args:\n            paths: The paths to be monitored.\n        \"\"\"\n        self._paths.update(paths)\n\n    async def __call__(self) -> None:\n        if self.check():\n            await self.on_change()\n\n    async def on_change(self) -> None:\n        \"\"\"Called when any of the monitored files change.\"\"\"\n        await invoke(self.callback)\n\n------------------------------\n------------------------------\n        \"\"\"\n        return cls(location, location)\n\n    @property\n    def is_empty(self) -> bool:\n        \"\"\"Return True if the selection has 0 width, i.e. it's just a cursor.\"\"\"\n        start, end = self\n        return start == end\n\n------------------------------\n------------------------------\nget_time = time\n\"\"\"Get the current wall clock (monotonic) time.\n\nReturns:\n    The value (in fractional seconds) of a monotonic clock,\n    i.e. a clock that cannot go backwards.\n\"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check(self) -> bool:\n# Natural Language Annotations: \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    for path in self._paths:\n        if get_time() - path.stat().st_mtime < self.delay:\n            return True\n    return False\n```\n", "```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    for path in self._paths:\n        current_time = get_time()\n        if current_time > self._modification_times[path]:\n            # File has changed\n            self._modification_times[path] = current_time\n            return True\n    return False\n```\n", "```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n\n    # Check if there are any monitored files\n    if not self._paths:\n        return False\n\n    # Get the current time\n    now = get_time()\n\n    # Check each monitored file\n    for path in self._paths:\n        # Get the last modification time of the file\n        mtime = os.path.getmtime(path)\n\n        # If the file was modified after the last check, return True\n        if mtime > self._last_check_time:\n            self._last_check_time = now\n            return True\n\n    return False\n```\n"]}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nfrom __future__ import annotations\n\nimport re\n\nfrom rich.cells import cell_len\nfrom rich.text import Text\n\n_TABS_SPLITTER_RE = re.compile(r\"(.*?\\t|.+?$)\")\n\n\ndef get_tab_widths(line: str, tab_size: int = 4) -> list[tuple[str, int]]:\n    \"\"\"Splits a string line into tuples (str, int).\n\n    Each tuple represents a section of the line which precedes a tab character.\n    The string is the string text that appears before the tab character (excluding the tab).\n    The integer is the width that the tab character is expanded to.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n\n------------------------------\n------------------------------\n\n        Args:\n            start: The start location of the selection.\n            end: The end location of the selection.\n\n        Returns:\n            The text between start (inclusive) and end (exclusive).\n        \"\"\"\n\n    @abstractmethod\n    def get_size(self, indent_width: int) -> Size:\n        \"\"\"Get the size of the document.\n\n        The height is generally the number of lines, and the width\n        is generally the maximum cell length of all the lines.\n\n        Args:\n            indent_width: The width to use for tab characters.\n\n        Returns:\n\n------------------------------\n------------------------------\n    \"\"\"Retrieve the column index corresponding to the given cell width.\n\n    Args:\n        line: The line of text to search within.\n        cell_width: The cell width to convert to column index.\n        tab_width: The tab stop width to expand tabs contained within the line.\n\n    Returns:\n        The column corresponding to the cell width.\n    \"\"\"\n    column_index = 0\n    total_cell_offset = 0\n    for part, expanded_tab_width in get_tab_widths(line, tab_width):\n        # Check if the click landed on a character within this part.\n        for character in part:\n            total_cell_offset += cell_len(character)\n            if total_cell_offset > cell_width:\n                return column_index\n            column_index += 1\n\n\n------------------------------\n------------------------------\n    The integer is the width that the tab character is expanded to.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n\n    Returns:\n        A list of tuples representing the line split on tab characters,\n            and the widths of the tabs after tab expansion is applied.\n    \"\"\"\n\n    parts: list[tuple[str, int]] = []\n    add_part = parts.append\n    cell_position = 0\n    matches = _TABS_SPLITTER_RE.findall(line)\n\n    for match in matches:\n        expansion_width = 0\n        if match.endswith(\"\\t\"):\n            # Remove the tab, and check the width of the rest of the line.\n\n------------------------------\n------------------------------\n\n\n\ndef expand_text_tabs_from_widths(line: Text, tab_widths: list[int]) -> Text:\n    \"\"\"Expand tabs to the widths defined in the `tab_widths` list.\n\n    This will return a new Text instance with tab characters expanded into a\n    number of spaces. Each time a tab is encountered, it's expanded into the\n    next integer encountered in the `tab_widths` list. Consequently, the length\n    of `tab_widths` should match the number of tab characters in `line`.\n\n    Args:\n        line: The `Text` instance to expand tabs in.\n        tab_widths: The widths to expand tabs to.\n\n    Returns:\n        A new text instance with tab characters converted to spaces.\n    \"\"\"\n    if \"\\t\" not in line.plain:\n        return line\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n# Natural Language Annotations: \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    new_line = \"\"\n    for char in line:\n        if char == \"\\t\":\n            new_line += \" \" * tab_size\n        else:\n            new_line += char\n    return new_line\n```\n", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    new_line = \"\"\n    for character in line:\n        if character == \"\\t\":\n            new_line += \" \" * tab_size\n        else:\n            new_line += character\n    return new_line\n```\n", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    new_line = \"\"\n    for character in line:\n        if character == \"\\t\":\n            new_line += \" \" * tab_size\n        else:\n            new_line += character\n    return new_line\n```\n"]}, "textual-src/textual/_resolve.py-resolve": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def get_content_height(\n        self, widget: Widget, container: Size, viewport: Size, width: int\n    ) -> int:\n        \"\"\"Get the content height.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n\n        Returns:\n            Content height (in lines).\n        \"\"\"\n        if not widget._nodes:\n            height = 0\n        else:\n            # Use a height of zero to ignore relative heights\n            styles_height = widget.styles.height\n\n------------------------------\n------------------------------\n    def resolve_scalar(\n        scalar: Scalar | None, fraction_unit: Fraction = Fraction(1)\n    ) -> Fraction | None:\n        \"\"\"Resolve a scalar if it is not None.\n\n        Args:\n            scalar: Optional scalar to resolve.\n            fraction_unit: Size of 1fr.\n\n        Returns:\n            Fraction if resolved, otherwise None.\n        \"\"\"\n        return (\n            None\n            if scalar is None\n            else scalar.resolve(size, viewport_size, fraction_unit)\n        )\n\n    resolve: list[tuple[Scalar, Fraction | None, Fraction | None]] = []\n\n\n------------------------------\n------------------------------\n\ndef align_lines(\n    lines: list[list[Segment]],\n    style: Style,\n    size: Size,\n    horizontal: AlignHorizontal,\n    vertical: AlignVertical,\n) -> Iterable[list[Segment]]:\n    \"\"\"Align lines.\n\n    Args:\n        lines: A list of lines.\n        style: Background style.\n        size: Size of container.\n        horizontal: Horizontal alignment.\n        vertical: Vertical alignment.\n\n    Returns:\n        Aligned lines.\n    \"\"\"\n\n------------------------------\n------------------------------\n        yield None, str(self.x)\n        yield None, str(self.y)\n\n    def resolve(self, size: Size, viewport: Size) -> Offset:\n        \"\"\"Resolve the offset in to cells.\n\n        Args:\n            size: Size of container.\n            viewport: Size of viewport.\n\n        Returns:\n            Offset in cells.\n        \"\"\"\n        x, y = self\n        return Offset(\n            round(x.resolve(size, viewport)),\n            round(y.resolve(size, viewport)),\n        )\n\n\n\n------------------------------\n------------------------------\n    size: Size,\n    viewport_size: Size,\n    margin: Size,\n    resolve_dimension: Literal[\"width\", \"height\"] = \"width\",\n) -> list[BoxModel]:\n    \"\"\"Resolve box models for a list of dimensions\n\n    Args:\n        dimensions: A list of Scalars or Nones for each dimension.\n        widgets: Widgets in resolve.\n        size: Size of container.\n        viewport_size: Viewport size.\n        margin: Total space occupied by margin\n        resolve_dimension: Which dimension to resolve.\n\n    Returns:\n        List of resolved box models.\n    \"\"\"\n    margin_width, margin_height = margin\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def resolve(\n# Natural Language Annotations: \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef resolve(\n    dimensions: list[Scalar],\n    total: int,\n    gutter: int,\n    size: Size,\n    viewport: Size,\n) -> list[tuple[int, int]]:\n    \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    resolved = []\n    offset = 0\n    for dim in dimensions:\n        length = round(dim.resolve(size, viewport))\n        resolved.append((offset, length))\n        offset += length + gutter\n    return resolved\n```\n", "```python\ndef resolve(\n    dimensions: list[Scalar | None],\n    total: int,\n    gutter: int,\n    size: Size,\n    viewport: Size,\n) -> list[tuple[int, int]]:\n    \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    resolved = []\n    offset = 0\n    for dimension in dimensions:\n        length = resolve_scalar(dimension)\n        if length is None:\n            length = (total - gutter * (len(dimensions) - 1)) // len(dimensions)\n        resolved.append((offset, length))\n        offset += length + gutter\n    return resolved\n```\n", "```python\ndef resolve(\n    dimensions: list[Scalar],\n    total: int,\n    gutter: int,\n    size: Size,\n    viewport: Size,\n) -> list[tuple[int, int]]:\n    \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    resolved_dimensions = []\n    offset = 0\n\n    for dimension in dimensions:\n        length = dimension.resolve(size, viewport)\n\n        # Clip length to remaining space\n        length = min(length, total)\n\n        resolved_dimensions.append((offset, length))\n        offset += length + gutter\n        total -= length\n\n    return resolved_dimensions\n```\n"]}, "textual-src/textual/widget.py-mount": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        return self.screen.mount(*widgets, before=before, after=after)\n\n    def mount_all(\n        self,\n        widgets: Iterable[Widget],\n        *,\n        before: int | str | Widget | None = None,\n        after: int | str | Widget | None = None,\n    ) -> AwaitMount:\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n\n------------------------------\n------------------------------\n\n        Args:\n            pane: The pane to add.\n            before: Optional pane or pane ID to add the pane before.\n            after: Optional pane or pane ID to add the pane after.\n\n        Returns:\n            An optionally awaitable object that waits for the pane to be added.\n\n        Raises:\n            Tabs.TabError: If there is a problem with the addition request.\n\n        Note:\n            Only one of `before` or `after` can be provided. If both are\n            provided an exception is raised.\n        \"\"\"\n        if isinstance(before, TabPane):\n            before = before.id\n        if isinstance(after, TabPane):\n            after = after.id\n\n------------------------------\n------------------------------\n        after: int | str | Widget | None = None,\n    ) -> AwaitMount:\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n\n------------------------------\n------------------------------\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n\n------------------------------\n------------------------------\n        \"\"\"Mount the given widgets relative to the app's screen.\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def mount(\n# Natural Language Annotations: \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef mount(\n        self,\n        *widgets: Iterable[Widget],\n        before: int | str | Widget | None = None,\n        after: int | str | Widget | None = None,\n    ) -> AwaitMount:\n        \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        if before is not None and after is not None:\n            raise MountError(\"Only one of ``before`` or ``after`` can be provided.\")\n        return self.screen.mount(*widgets, before=before, after=after)\n```\n", "```python\ndef mount(\n    self,\n    *widgets: Widget,\n    before: int | str | Widget | None = None,\n    after: int | str | Widget | None = None,\n) -> AwaitMount:\n    \"\"\"Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before and after:\n        raise MountError(\"Only one of 'before' or 'after' can be provided.\")\n\n    # Mount the widgets\n    # ...\n```\n", "```python\ndef mount(\n        self,\n        *widgets: Iterable[Widget],\n        before: int | str | Widget | None = None,\n        after: int | str | Widget | None = None,\n) -> AwaitMount:\n    \"\"\"Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before is not None and after is not None:\n        raise MountError(\"Only one of 'before' or 'after' can be provided.\")\n\n    for widget in widgets:\n        self.screen.mount(widget, before=before, after=after)\n\n    return AwaitMount(self)\n```\n"]}, "textual-src/textual/widget.py-move_child": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        if self.app._exit:\n            return AwaitMount(self, [])\n        await_mount = self.mount(*widgets, before=before, after=after)\n        return await_mount\n\n    if TYPE_CHECKING:\n\n        @overload\n        def move_child(\n            self,\n            child: int | Widget,\n            *,\n\n------------------------------\n------------------------------\n\n        Args:\n            pane: The pane to add.\n            before: Optional pane or pane ID to add the pane before.\n            after: Optional pane or pane ID to add the pane after.\n\n        Returns:\n            An optionally awaitable object that waits for the pane to be added.\n\n        Raises:\n            Tabs.TabError: If there is a problem with the addition request.\n\n        Note:\n            Only one of `before` or `after` can be provided. If both are\n            provided an exception is raised.\n        \"\"\"\n        if isinstance(before, TabPane):\n            before = before.id\n        if isinstance(after, TabPane):\n            after = after.id\n\n------------------------------\n------------------------------\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\n        return self.screen.mount(*widgets, before=before, after=after)\n\n    def mount_all(\n        self,\n        widgets: Iterable[Widget],\n        *,\n        before: int | str | Widget | None = None,\n        after: int | str | Widget | None = None,\n    ) -> AwaitMount:\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n\n------------------------------\n------------------------------\n        \"\"\"Mount the given widgets relative to the app's screen.\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n\n------------------------------\n------------------------------\n        \"\"\"Mount widgets from an iterable.\n\n        Args:\n            widgets: An iterable of widgets.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def move_child(\n# Natural Language Annotations: \"\"\"Move a child widget within its parent's list of children.\n\n        Args:\n            child: The child widget to move.\n            before: Child widget or location index to move before.\n            after: Child widget or location index to move after.\n\n        Raises:\n            WidgetError: If there is a problem with the child or target.\n\n        Note:\n            Only one of `before` or `after` can be provided. If neither\n            or both are provided a `WidgetError` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef move_child(\n    child: Union[int, Widget],\n    before: Optional[Union[int, Widget]] = None,\n    after: Optional[Union[int, Widget]] = None,\n):\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n\n    # Move the child widget logic here\n```\n", "```python\ndef move_child(\n    self,\n    child: int | Widget,\n    *,\n    before: int | str | Widget | None = None,\n    after: int | str | Widget | None = None\n):\n    if before and after:\n        raise WidgetError(\"Only one of `before` or `after` can be provided.\")\n    if isinstance(child, int):\n        child = self.children[child]\n    if isinstance(before, int):\n        before = self.children[before]\n    if isinstance(after, int):\n        after = self.children[after]\n    if before and after:\n        raise WidgetError(\"Only one of `before` or `after` can be provided.\")\n    if before:\n        self.children.insert(self.children.index(before), self.children.pop(self.children.index(child)))\n    elif after:\n        self.children.insert(self.children.index(after) + 1, self.children.pop(self.children.index(child)))\n    else:\n        raise WidgetError(\"Either `before` or `after` must be provided.\")\n```\n", "```python\ndef move_child(\n    self, \n    child: int | Widget, \n    *,\n    before: int | str | Widget | None = None,\n    after: int | str | Widget | None = None\n):\n    if before and after:\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n    \n    if isinstance(child, int):\n        child = self.children[child]\n    \n    if before is not None:\n        if isinstance(before, int):\n            before = self.children[before]\n        elif isinstance(before, str):\n            before = self.query_one(before)\n        \n        self.children.insert(before, child)\n    elif after is not None:\n        if isinstance(after, int):\n            after = self.children[after]\n        elif isinstance(after, str):\n            after = self.query_one(after)\n        \n        self.children.insert(after + 1, child)\n    else:\n        raise WidgetError(\"Either 'before' or 'after' must be provided.\")\n```\n"]}, "textual-src/textual/widget.py-_get_box_model": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n) -> Fraction:\n    \"\"\"Resolves width unit i.e. width: 50w.\n\n    Args:\n        value: Scalar value.\n        size: Size of widget.\n        viewport: Size of viewport.\n        fraction_unit: Size of fraction, i.e. size of 1fr as a Fraction.\n\n    Returns:\n        Resolved unit.\n    \"\"\"\n    return Fraction(value) * Fraction(size.width, 100)\n\n\ndef _resolve_height(\n    value: float, size: Size, viewport: Size, fraction_unit: Fraction\n) -> Fraction:\n    \"\"\"Resolves height unit, i.e. height: 12h.\n\n\n------------------------------\n------------------------------\n\n    Args:\n        value: Scalar value.\n        size: Size of widget.\n        viewport: Size of viewport.\n        fraction_unit: Size of fraction, i.e. size of 1fr as a Fraction.\n\n    Returns:\n        Resolved unit.\n    \"\"\"\n    return fraction_unit * Fraction(value)\n\n\ndef _resolve_width(\n    value: float, size: Size, viewport: Size, fraction_unit: Fraction\n) -> Fraction:\n    \"\"\"Resolves width unit i.e. width: 50w.\n\n    Args:\n        value: Scalar value.\n\n------------------------------\n------------------------------\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n\n------------------------------\n------------------------------\n\n    def get_content_height(\n        self, widget: Widget, container: Size, viewport: Size, width: int\n    ) -> int:\n        \"\"\"Get the content height.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n\n        Returns:\n            Content height (in lines).\n        \"\"\"\n        if not widget._nodes:\n            height = 0\n        else:\n            # Use a height of zero to ignore relative heights\n            styles_height = widget.styles.height\n\n------------------------------\n------------------------------\n        value: Scalar value.\n        size: Size of widget.\n        viewport: Size of viewport.\n        fraction_unit: Size of fraction, i.e. size of 1fr as a Fraction.\n\n    Returns:\n        Resolved unit.\n    \"\"\"\n    return Fraction(value)\n\n\ndef _resolve_fraction(\n    value: float, size: Size, viewport: Size, fraction_unit: Fraction\n) -> Fraction:\n    \"\"\"Resolves a fraction unit i.e. width: 2fr\n\n    Args:\n        value: Scalar value.\n        size: Size of widget.\n        viewport: Size of viewport.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_box_model(\n# Natural Language Annotations: \"\"\"Process the box model for this widget.\n\n        Args:\n            container: The size of the container widget (with a layout)\n            viewport: The viewport size.\n            width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n            height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n        Returns:\n            The size and margin for this widget.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_box_model(\n    container: Size, \n    viewport: Size, \n    width_fraction: Fraction, \n    height_fraction: Fraction\n) -> Tuple[Size, Margin]:\n    \"\"\"Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n    # Implementation goes here\n    pass\n```\n", "```python\ndef _get_box_model(\n    container: Size, \n    viewport: Size, \n    width_fraction: Fraction, \n    height_fraction: Fraction\n) -> Tuple[Size, Margin]:\n    \"\"\"Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n    # Your implementation goes here\n    pass\n```\n", "```python\ndef _get_box_model(\n    container: Size, \n    viewport: Size, \n    width_fraction: float, \n    height_fraction: float\n) -> Tuple[Size, Margin]:\n    \"\"\"Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n    width = _resolve_width(container.width, viewport, width_fraction)\n    height = _resolve_height(container.height, viewport, height_fraction)\n    margin = _calculate_margin(width, height)\n    \n    return (Size(width, height), margin)\n```\nPlease note that I made assumptions about the types of the arguments and return values because they were not provided in the question. You will need to replace the types with actual types that are suitable for your use case.\n"]}, "textual-src/textual/widget.py-get_content_width": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def arrange(\n        self, parent: Widget, children: list[Widget], size: Size\n    ) -> ArrangeResult:\n        \"\"\"Generate a layout map that defines where on the screen the widgets will be drawn.\n\n        Args:\n            parent: Parent widget.\n            size: Size of container.\n\n        Returns:\n            An iterable of widget location\n        \"\"\"\n\n    def get_content_width(self, widget: Widget, container: Size, viewport: Size) -> int:\n        \"\"\"Get the optimal content width by arranging children.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport size.\n\n------------------------------\n------------------------------\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n\n    def _size_updated(\n        self, size: Size, virtual_size: Size, container_size: Size, layout: bool = True\n    ) -> bool:\n        \"\"\"Called when size is updated.\n\n        Args:\n            size: New size.\n            virtual_size: New virtual size.\n            container_size: New container size.\n            layout: Perform layout if required.\n\n------------------------------\n------------------------------\n        text_align = self.styles.text_align\n        align = \"left\" if text_align not in {\"left\", \"center\", \"right\"} else text_align\n        return Align(digits, cast(AlignMethod, align), rich_style)\n\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Called by textual to get the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return DigitsRenderable.get_width(self._value)\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n\n------------------------------\n------------------------------\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Gets the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return self.virtual_size.width\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Gets the height (number of lines) in the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n\n------------------------------\n------------------------------\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_width(self, container: Size, viewport: Size) -> int:\n# Natural Language Annotations: \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    # Your implementation here\n    pass\n```\n", "```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    # You will need to add your own implementation here\n    pass\n```\n", "```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    # Placeholder code, to be replaced by the actual implementation\n    raise NotImplementedError(\"This method should be overridden in a subclass\")\n```\n"]}, "textual-src/textual/widget.py-get_content_height": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def get_content_height(\n        self, widget: Widget, container: Size, viewport: Size, width: int\n    ) -> int:\n        \"\"\"Get the content height.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n\n        Returns:\n            Content height (in lines).\n        \"\"\"\n        if not widget._nodes:\n            height = 0\n        else:\n            # Use a height of zero to ignore relative heights\n            styles_height = widget.styles.height\n\n------------------------------\n------------------------------\n        text_align = self.styles.text_align\n        align = \"left\" if text_align not in {\"left\", \"center\", \"right\"} else text_align\n        return Align(digits, cast(AlignMethod, align), rich_style)\n\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Called by textual to get the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return DigitsRenderable.get_width(self._value)\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n\n------------------------------\n------------------------------\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return self.virtual_size.height\n\n    def _size_updated(\n        self, size: Size, virtual_size: Size, container_size: Size, layout: bool = True\n    ) -> bool:\n        \"\"\"Called when size is updated.\n\n        Args:\n            size: New size.\n            virtual_size: New virtual size.\n            container_size: New container size.\n            layout: Perform layout if required.\n\n------------------------------\n------------------------------\n    def get_content_width(self, container: Size, viewport: Size) -> int:\n        \"\"\"Gets the width of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\n        return self.virtual_size.width\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Gets the height (number of lines) in the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n\n------------------------------\n------------------------------\n\n    def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n        \"\"\"Called by Textual to get the height of the content area.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\n        return 3  # Always 3 lines\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n# Natural Language Annotations: \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    pass\n```\n", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    # Your code here\n    pass\n```\n", "Sure, here is the function based on your requirements:\n\n```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    # Your function implementation goes here\n    pass\n```\n"]}, "textual-src/textual/suggester.py-_get_suggestion": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        target_cell: Coordinate,\n        type_of_cursor: CursorType,\n    ) -> bool:\n        \"\"\"Determine if the given cell should be highlighted because of the cursor.\n\n        This auxiliary method takes the cursor position and type into account when\n        determining whether the cell should be highlighted.\n\n        Args:\n            cursor: The current position of the cursor.\n            target_cell: The cell we're checking for the need to highlight.\n            type_of_cursor: The type of cursor that is currently active.\n\n        Returns:\n            Whether or not the given cell should be highlighted.\n        \"\"\"\n        if type_of_cursor == \"cell\":\n            return cursor == target_cell\n        elif type_of_cursor == \"row\":\n            cursor_row, _ = cursor\n\n------------------------------\n------------------------------\n        \"\"\"Toggle an attribute on the node.\n\n        Assumes the attribute is a bool.\n\n        Args:\n            attribute_name: Name of the attribute.\n        \"\"\"\n        value = getattr(self, attribute_name)\n        setattr(self, attribute_name, not value)\n\n------------------------------\n------------------------------\n        \"\"\"Mark this event as being forwarded.\"\"\"\n        self._forwarded = True\n\n    def set_sender(self, sender: MessagePump) -> Self:\n        \"\"\"Set the sender of the message.\n\n        Args:\n            sender: The sender.\n\n        Note:\n            When creating a message the sender is automatically set.\n            Normally there will be no need for this method to be called.\n            This method will be used when strict control is required over\n            the sender of a message.\n\n        Returns:\n            Self.\n        \"\"\"\n        self._sender = sender\n        return self\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @abstractmethod\n    async def get_suggestion(self, value: str) -> str | None:\n        \"\"\"Try to get a completion suggestion for the given input value.\n\n        Custom suggesters should implement this method.\n\n\n------------------------------\n------------------------------\n    async def get_suggestion(self, value: str) -> str | None:\n        \"\"\"Try to get a completion suggestion for the given input value.\n\n        Custom suggesters should implement this method.\n\n        Note:\n            The value argument will be casefolded if `self.case_sensitive` is `False`.\n\n        Note:\n            If your implementation is not deterministic, you may need to disable caching.\n\n        Args:\n            value: The current value of the requester widget.\n\n        Returns:\n            A valid suggestion or `None`.\n        \"\"\"\n        pass\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n# Natural Language Annotations: \"\"\"Used by widgets to get completion suggestions.\n\n        Note:\n            When implementing custom suggesters, this method does not need to be\n            overridden.\n\n        Args:\n            requester: The message target that requested a suggestion.\n            value: The current value to complete.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n```\n", "```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    pass\n```\n", "```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    pass\n```\n"]}, "textual-src/textual/dom.py-add_class": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"\n        return self._classes.issuperset(class_names)\n\n    def set_class(self, add: bool, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Add or remove class(es) based on a condition.\n\n        Args:\n            add: Add the classes if True, otherwise remove them.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\n        if add:\n            self.add_class(*class_names, update=update)\n        else:\n            self.remove_class(*class_names, update=update)\n        return self\n\n    def set_classes(self, classes: str | Iterable[str]) -> Self:\n\n------------------------------\n------------------------------\n            self.refresh(layout=True)\n\n        styles = self.styles\n        for key, value in update_styles.items():\n            setattr(styles, key, value)\n        return self\n\n    def has_class(self, *class_names: str) -> bool:\n        \"\"\"Check if the Node has all the given class names.\n\n        Args:\n            *class_names: CSS class names to check.\n\n        Returns:\n            ``True`` if the node has all the given class names, otherwise ``False``.\n        \"\"\"\n        return self._classes.issuperset(class_names)\n\n    def set_class(self, add: bool, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Add or remove class(es) based on a condition.\n\n------------------------------\n------------------------------\n            return self\n        if update:\n            self._update_styles()\n        return self\n\n    def toggle_class(self, *class_names: str) -> Self:\n        \"\"\"Toggle class names on this Node.\n\n        Args:\n            *class_names: CSS class names to toggle.\n\n        Returns:\n            Self.\n        \"\"\"\n        check_identifiers(\"class name\", *class_names)\n        old_classes = self._classes.copy()\n        self._classes.symmetric_difference_update(class_names)\n        if old_classes == self._classes:\n            return self\n        self._update_styles()\n\n------------------------------\n------------------------------\n\n    def remove_class(self, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Remove class names from this Node.\n\n        Args:\n            *class_names: CSS class names to remove.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\n        check_identifiers(\"class name\", *class_names)\n        old_classes = self._classes.copy()\n        self._classes.difference_update(class_names)\n        if old_classes == self._classes:\n            return self\n        if update:\n            self._update_styles()\n        return self\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def remove_class(self, *class_names: str, update: bool = True) -> Self:\n        \"\"\"Remove class names from this Node.\n\n        Args:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_class(self, *class_names: str, update: bool = True) -> Self:\n# Natural Language Annotations: \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```\n", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```\n", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    check_identifiers(\"class name\", *class_names)\n    old_classes = self._classes.copy()\n    self._classes.update(class_names)\n    if old_classes == self._classes:\n        return self\n    if update:\n        self._update_styles()\n    return self\n```\n"]}, "textual-src/textual/reactive.py-_initialize_object": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def label(self) -> TextType:\n        \"\"\"The label for the node.\"\"\"\n        return self._label\n\n    @label.setter\n    def label(self, new_label: TextType) -> None:\n        self.set_label(new_label)\n\n    def set_label(self, label: TextType) -> None:\n        \"\"\"Set a new label for the node.\n\n        Args:\n            label: A ``str`` or ``Text`` object with the new label.\n        \"\"\"\n        self._updates += 1\n        text_label = self._tree.process_label(label)\n        self._label = text_label\n        self._tree.call_later(self._tree._refresh_node, self)\n\n    def add(\n\n------------------------------\n------------------------------\n        \"\"\"A null-op because it doesn't make sense to reset a mocked clock.\"\"\"\n\n    def set_time(self, time: float) -> None:\n        \"\"\"Set the time for the clock.\n\n        Args:\n            time: Time to set.\n        \"\"\"\n        self._time = time\n\n    @property\n    def time(self) -> float:\n        \"\"\"Time since creation or reset.\"\"\"\n        return self._get_time()\n\n------------------------------\n------------------------------\n    def log(self) -> Logger:\n        \"\"\"Get a logger for this object.\n\n        Returns:\n            A logger.\n        \"\"\"\n        return self.app._logger\n\n    def _attach(self, parent: MessagePump) -> None:\n        \"\"\"Set the parent, and therefore attach this node to the tree.\n\n        Args:\n            parent: Parent node.\n        \"\"\"\n        self._parent = parent\n\n    def _detach(self) -> None:\n        \"\"\"Set the parent to None to remove the node from the tree.\"\"\"\n        self._parent = None\n\n\n------------------------------\n------------------------------\n        @overload\n        def get_child_by_id(self, id: str) -> Widget: ...\n\n        @overload\n        def get_child_by_id(\n            self, id: str, expect_type: type[ExpectType]\n        ) -> ExpectType: ...\n\n    def get_child_by_id(\n        self, id: str, expect_type: type[ExpectType] | None = None\n    ) -> ExpectType | Widget:\n        \"\"\"Return the first child (immediate descendent) of this node with the given ID.\n\n        Args:\n            id: The ID of the child.\n            expect_type: Require the object be of the supplied type, or None for any type.\n\n        Returns:\n            The first child of this node with the ID.\n\n\n------------------------------\n------------------------------\n        \"\"\"Get the border.\n\n        Args:\n            obj: The ``Styles`` object.\n            objtype: The ``Styles`` class.\n\n        Returns:\n            An ``Edges`` object describing the type and style of each edge.\n        \"\"\"\n\n        return Edges(*self._get_properties(obj))\n\n    def __set__(\n        self,\n        obj: StylesBase,\n        border: BorderDefinition | None,\n    ) -> None:\n        \"\"\"Set the border.\n\n        Args:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _initialize_object(cls, obj: Reactable) -> None:\n# Natural Language Annotations: \"\"\"Set defaults and call any watchers / computes for the first time.\n\n        Args:\n            obj: An object with Reactive descriptors\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for descriptor_name in dir(cls):\n        descriptor = getattr(cls, descriptor_name)\n\n        if isinstance(descriptor, Reactive):\n            if descriptor.default is not None:\n                setattr(obj, descriptor_name, descriptor.default)\n\n            if descriptor.watcher is not None:\n                descriptor.watcher(obj)\n\n            if descriptor.compute is not None:\n                setattr(obj, descriptor_name, descriptor.compute(obj))\n```\n", "```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr_name, attr_value in vars(cls).items():\n        if isinstance(attr_value, (Reactive, Computed)):\n            if hasattr(attr_value, '_default'):\n                setattr(obj, attr_name, attr_value._default)\n            if hasattr(attr_value, '_watcher'):\n                attr_value._watcher(obj)\n            if hasattr(attr_value, '_compute'):\n                attr_value._compute(obj)\n```\n", "```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"\n    Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr_name in dir(obj):\n        attr = getattr(type(obj), attr_name)\n        if isinstance(attr, ReactiveAttribute):\n            setattr(obj, attr_name, attr._default)\n            if hasattr(attr, '_watchers'):\n                for watcher in attr._watchers:\n                    watcher(obj, attr, attr._default)\n            if hasattr(attr, '_computes'):\n                for compute in attr._computes:\n                    compute(obj, attr)\n```\n"]}, "textual-src/textual/message_pump.py-call_after_refresh": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            self._message_changed()\n\n        self.refresh()\n        return self\n\n    def _select(self, value: SelectionType) -> bool:\n        \"\"\"Mark the given value as selected.\n\n        Args:\n            value: The value to mark as selected.\n\n        Returns:\n            `True` if the value was selected, `False` if not.\n        \"\"\"\n        if value not in self._selected:\n            self._selected[value] = None\n            self._message_changed()\n            return True\n        return False\n\n\n------------------------------\n------------------------------\n        \"\"\"Subscribe a node to this signal.\n\n        When the signal is published, the callback will be invoked.\n\n        Args:\n            node: Node to subscribe.\n            callback: A callback function which takes a single argument and returns anything (return type ignored).\n            immediate: Invoke the callback immediately on publish if `True`, otherwise post it to the DOM node to be\n                called once existing messages have been processed.\n\n        Raises:\n            SignalError: Raised when subscribing a non-mounted widget.\n        \"\"\"\n\n        if not node.is_running:\n            raise SignalError(\n                f\"Node must be running to subscribe to a signal (has {node} been mounted)?\"\n            )\n\n        if immediate:\n\n------------------------------\n------------------------------\n    async def _invoke_and_clear_callbacks(self) -> None:\n        \"\"\"If there are scheduled callbacks to run, call them and clear\n        the callback queue.\"\"\"\n        if self._callbacks:\n            callbacks = self._callbacks[:]\n            self._callbacks.clear()\n            for callback, message_pump in callbacks:\n                reset_token = active_message_pump.set(message_pump)\n                try:\n                    await invoke(callback)\n                finally:\n                    active_message_pump.reset(reset_token)\n\n    def _invoke_later(self, callback: CallbackType, sender: MessagePump) -> None:\n        \"\"\"Enqueue a callback to be invoked after the screen is repainted.\n\n        Args:\n            callback: A callback.\n            sender: The sender (active message pump) of the callback.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n    def _detach(self) -> None:\n        \"\"\"Set the parent to None to remove the node from the tree.\"\"\"\n        self._parent = None\n\n    def check_message_enabled(self, message: Message) -> bool:\n        \"\"\"Check if a given message is enabled (allowed to be sent).\n\n        Args:\n            message: A message object.\n\n        Returns:\n            `True` if the message will be sent, or `False` if it is disabled.\n        \"\"\"\n        return type(message) not in self._disabled_messages\n\n    def disable_messages(self, *messages: type[Message]) -> None:\n        \"\"\"Disable message types from being processed.\"\"\"\n        self._disabled_messages.update(messages)\n\n\n------------------------------\n------------------------------\n            message: A message object.\n\n        Returns:\n            True if the messages was posted successfully, False if the message was not posted\n                (because the message pump was in the process of closing).\n        \"\"\"\n        return self.post_message(message)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self._closed:\n        return False\n\n    self._callbacks.append((partial(callback, *args, **kwargs), self))\n    return True\n```\n", "```python\ndef call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self._callbacks is None:\n        return False\n\n    self._callbacks.append((lambda *a, **k: callback(*a, **k), active_message_pump.get()))\n    return True\n```\n", "```python\ndef call_after_refresh(self, callback: CallbackType, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self._closing:\n        return False\n\n    self._callbacks.append((partial(callback, *args, **kwargs), self))\n    self._refresh_required = True\n    return True\n```\n"]}, "textual-src/textual/message_pump.py-call_later": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"The object in the DOM that requested the callback.\"\"\"\n        self.callback: ScreenResultCallbackType | None = callback\n        \"\"\"The callback function.\"\"\"\n        self.future = future\n        \"\"\"A future for the result\"\"\"\n\n    def __call__(self, result: ScreenResultType) -> None:\n        \"\"\"Call the callback, passing the given result.\n\n        Args:\n            result: The result to pass to the callback.\n\n        Note:\n            If the requested or the callback are `None` this will be a no-op.\n        \"\"\"\n        if self.future is not None:\n            self.future.set_result(result)\n        if self.requester is not None and self.callback is not None:\n            self.requester.call_next(self.callback, result)\n\n\n------------------------------\n------------------------------\n            message: A message object.\n\n        Returns:\n            True if the messages was posted successfully, False if the message was not posted\n                (because the message pump was in the process of closing).\n        \"\"\"\n        return self.post_message(message)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------------------------------\n------------------------------\n\n    def _detach(self) -> None:\n        \"\"\"Set the parent to None to remove the node from the tree.\"\"\"\n        self._parent = None\n\n    def check_message_enabled(self, message: Message) -> bool:\n        \"\"\"Check if a given message is enabled (allowed to be sent).\n\n        Args:\n            message: A message object.\n\n        Returns:\n            `True` if the message will be sent, or `False` if it is disabled.\n        \"\"\"\n        return type(message) not in self._disabled_messages\n\n    def disable_messages(self, *messages: type[Message]) -> None:\n        \"\"\"Disable message types from being processed.\"\"\"\n        self._disabled_messages.update(messages)\n\n\n------------------------------\n------------------------------\n\n    def call_next(self, callback: Callback, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Schedule a callback to run immediately after processing the current message.\n\n        Args:\n            callback: Callable to run after current event.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n        \"\"\"\n        callback_message = events.Callback(callback=partial(callback, *args, **kwargs))\n        callback_message._prevent.update(self._get_prevented_messages())\n        self._next_callbacks.append(callback_message)\n        self.check_idle()\n\n    def _on_invoke_later(self, message: messages.InvokeLater) -> None:\n        # Forward InvokeLater message to the Screen\n        self.app.screen._invoke_later(\n            message.callback, message._sender or active_message_pump.get()\n        )\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    def call_next(self, callback: Callback, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Schedule a callback to run immediately after processing the current message.\n\n        Args:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self.is_closed():\n        return False\n\n    self._later_callbacks.append(partial(callback, *args, **kwargs))\n    return True\n```\n", "```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self.app.screen._is_running:\n        partial_callback = partial(callback, *args, **kwargs)\n        self._later_callbacks.append(partial_callback)\n        return True\n    else:\n        return False\n```\n", "```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    \n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    if self.is_closed:\n        return False\n\n    def wrapped_callback(*args, **kwargs):\n        if not self.is_closed:\n            callback(*args, **kwargs)\n\n    self._later_callbacks.append(wrapped_callback)\n    self.check_idle()\n    return True\n```\n"]}, "textual-src/textual/message_pump.py-post_message": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\ndef _check_type(name: str, node: DOMNode) -> bool:\n    \"\"\"Check node matches a type selector.\n\n    Args:\n        name: Selector name.\n        node: A DOM node.\n\n    Returns:\n        `True` if the selector matches.\n    \"\"\"\n    return name in node._css_type_names\n\n\ndef _check_class(name: str, node: DOMNode) -> bool:\n    \"\"\"Check node matches a class selector.\n\n    Args:\n        name: Selector name.\n        node: A DOM node.\n\n------------------------------\n------------------------------\n            self._message_changed()\n\n        self.refresh()\n        return self\n\n    def _select(self, value: SelectionType) -> bool:\n        \"\"\"Mark the given value as selected.\n\n        Args:\n            value: The value to mark as selected.\n\n        Returns:\n            `True` if the value was selected, `False` if not.\n        \"\"\"\n        if value not in self._selected:\n            self._selected[value] = None\n            self._message_changed()\n            return True\n        return False\n\n\n------------------------------\n------------------------------\n    \"\"\"Check node matches a class selector.\n\n    Args:\n        name: Selector name.\n        node: A DOM node.\n\n    Returns:\n        `True` if the selector matches.\n    \"\"\"\n    return name in node._classes\n\n\ndef _check_id(name: str, node: DOMNode) -> bool:\n    \"\"\"Check node matches an ID selector.\n\n    Args:\n        name: Selector name.\n        node: A DOM node.\n\n    Returns:\n\n------------------------------\n------------------------------\n\n    def _detach(self) -> None:\n        \"\"\"Set the parent to None to remove the node from the tree.\"\"\"\n        self._parent = None\n\n    def check_message_enabled(self, message: Message) -> bool:\n        \"\"\"Check if a given message is enabled (allowed to be sent).\n\n        Args:\n            message: A message object.\n\n        Returns:\n            `True` if the message will be sent, or `False` if it is disabled.\n        \"\"\"\n        return type(message) not in self._disabled_messages\n\n    def disable_messages(self, *messages: type[Message]) -> None:\n        \"\"\"Disable message types from being processed.\"\"\"\n        self._disabled_messages.update(messages)\n\n\n------------------------------\n------------------------------\n    def _start_widget(self, parent: Widget, widget: Widget) -> None:\n        \"\"\"Start a widget (run it's task) so that it can receive messages.\n\n        Args:\n            parent: The parent of the Widget.\n            widget: The Widget to start.\n        \"\"\"\n\n        widget._attach(parent)\n        widget._start_messages()\n        self.app._registry.add(widget)\n\n    def is_mounted(self, widget: Widget) -> bool:\n        \"\"\"Check if a widget is mounted.\n\n        Args:\n            widget: A widget.\n\n        Returns:\n            True of the widget is mounted.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def post_message(self, message: Message) -> bool:\n# Natural Language Annotations: \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    if self.check_message_enabled(message):\n        self._message_queue.put(message)\n        return True\n    return False\n```\n", "```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    if self.check_message_enabled(message):\n        self._message_queue.append(message)\n        return True\n    else:\n        return False\n```\n", "```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    if self._msg_queue is not None:\n        self._msg_queue.post(message)\n        return True\n    return False\n```\n"]}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n\n    def describe_failure(self, failure: Failure) -> str | None:\n        \"\"\"Describes why the validator failed.\n\n        Args:\n            failure: Information about why the validation failed.\n\n        Returns:\n            A string description of the failure.\n        \"\"\"\n        return \"Must be a valid URL.\"\n\n------------------------------\n------------------------------\n\n        Args:\n            x: X Coordinate.\n            y: Y Coordinate.\n\n        Returns:\n            Widget and screen region.\n\n        Raises:\n            NoWidget: If there is no widget under the screen coordinate.\n        \"\"\"\n        return self._compositor.get_widget_at(x, y)\n\n    def get_widgets_at(self, x: int, y: int) -> Iterable[tuple[Widget, Region]]:\n        \"\"\"Get all widgets under a given coordinate.\n\n        Args:\n            x: X coordinate.\n            y: Y coordinate.\n\n\n------------------------------\n------------------------------\n        \"\"\"Filter this set by the given CSS selector.\n\n        Args:\n            selector: A CSS selector.\n\n        Returns:\n            New DOM Query.\n        \"\"\"\n\n        return DOMQuery(\n            self.node,\n            filter=selector,\n            deep=self._deep,\n            parent=self,\n        )\n\n    def exclude(self, selector: str) -> DOMQuery[QueryType]:\n        \"\"\"Exclude nodes that match a given selector.\n\n        Args:\n\n------------------------------\n------------------------------\n                return node\n        return None\n\n    def get_style_at(self, x: int, y: int) -> Style:\n        \"\"\"Get the style under a given coordinate.\n\n        Args:\n            x: X Coordinate.\n            y: Y Coordinate.\n\n        Returns:\n            Rich Style object.\n        \"\"\"\n        return self._compositor.get_style_at(x, y)\n\n    def find_widget(self, widget: Widget) -> MapGeometry:\n        \"\"\"Get the screen region of a Widget.\n\n        Args:\n            widget: A Widget within the composition.\n\n------------------------------\n------------------------------\n        \"\"\"Get a new Size with just the width changed.\n\n        Args:\n            width: New width.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(width, self.height)\n\n    def with_height(self, height: int) -> Size:\n        \"\"\"Get a new Size with just the height changed.\n\n        Args:\n            width: New height.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(self.width, height)\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_values_in_region(self, region: Region) -> list[ValueType]:\n# Natural Language Annotations: \"\"\"Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    values = []\n    for value in self.values:\n        if value.region.intersects(region):\n            values.append(value)\n    return values\n```\n", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    return [value for value in self.values if region.intersects(value.region)]\n```\n", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    intersection_values = []\n    for value in self.values:\n        if region.intersects(value.region):\n            intersection_values.append(value)\n\n    return intersection_values\n```\n"]}, "textual-src/textual/validation.py-validate": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        The return value may be awaited to ensure the DirectoryTree has reached\n        a stable state and is no longer performing any node reloading (of this node\n        or any other nodes).\n\n        Args:\n            node: The root of the subtree to reload.\n\n        Returns:\n            An optionally awaitable that ensures the subtree has finished reloading.\n        \"\"\"\n        return AwaitComplete(self._reload(node))\n\n    def validate_path(self, path: str | Path) -> Path:\n        \"\"\"Ensure that the path is of the `Path` type.\n\n        Args:\n            path: The path to validate.\n\n        Returns:\n\n------------------------------\n------------------------------\n    def get_key(self, value: Value) -> Key | None:\n        \"\"\"Given a value, efficiently lookup and return the associated key.\n\n        Args:\n            value: The value\n\n        Returns:\n            The key\n        \"\"\"\n        return self._reverse.get(value)\n\n    def contains_value(self, value: Value) -> bool:\n        \"\"\"Check if `value` is a value within this TwoWayDict.\n\n        Args:\n            value: The value to check.\n\n        Returns:\n            True if the value is within the values of this dict.\n        \"\"\"\n\n------------------------------\n------------------------------\n    \"\"\"Validator which ensures the value is an integer which falls within a range.\"\"\"\n\n    class NotAnInteger(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid integer.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Ensure that `value` is an integer, optionally within a range.\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n        # First, check that we're dealing with a number in the range.\n        number_validation_result = super().validate(value)\n        if not number_validation_result.is_valid:\n            return number_validation_result\n\n        # We know it's a number, but is that number an integer?\n\n------------------------------\n------------------------------\n        \"\"\"Toggle an attribute on the node.\n\n        Assumes the attribute is a bool.\n\n        Args:\n            attribute_name: Name of the attribute.\n        \"\"\"\n        value = getattr(self, attribute_name)\n        setattr(self, attribute_name, not value)\n\n------------------------------\n------------------------------\n    class NotANumber(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid number (decimal/integer, inc. scientific notation)\"\"\"\n\n    class NotInRange(Failure):\n        \"\"\"Indicates a failure due to the number not being within the range [minimum, maximum].\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Ensure that `value` is a valid number, optionally within a range.\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n        try:\n            float_value = float(value)\n        except ValueError:\n            return ValidationResult.failure([Number.NotANumber(self, value)])\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def validate(self, value: str) -> ValidationResult:\n# Natural Language Annotations: \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    from urllib.parse import urlparse\n\n    try:\n        result = urlparse(value)\n        if all([result.scheme, result.netloc]):\n            return ValidationResult.success()\n        else:\n            return ValidationResult.failure([self.NotAValidURL(value)])\n    except ValueError:\n        return ValidationResult.failure([self.NotAValidURL(value)])\n```\n", "```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    from urllib.parse import urlparse\n\n    class InvalidURL(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid URL.\"\"\"\n\n    try:\n        result = urlparse(value)\n        if all([result.scheme, result.netloc]):\n            return ValidationResult.valid(value)\n        else:\n            return ValidationResult.failure([InvalidURL(self, value)])\n    except ValueError:\n        return ValidationResult.failure([InvalidURL(self, value)])\n```\n", "```python\nclass UrlValidator(Validator):\n    class NotAUrl(Failure):\n        \"\"\"Indicates a failure due to the value not being a valid URL.\"\"\"\n\n    def validate(self, value: str) -> ValidationResult:\n        \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\n        # First, check that we're dealing with a URL.\n        # A URL should contain a scheme (e.g., http, https, ftp)\n        if not isinstance(value, str) or \"://\" not in value:\n            return ValidationResult.failure([UrlValidator.NotAUrl(self, value)])\n\n        # URL is valid\n        return ValidationResult.success()\n```\n"]}, "textual-src/textual/geometry.py-clamp": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    @property\n    def width(self) -> int:\n        \"\"\"The canvas width.\"\"\"\n        return self._width\n\n    @property\n    def height(self) -> int:\n        \"\"\"The canvas height.\"\"\"\n        return self._height\n\n    def x_range(self, start: int, end: int) -> range:\n        \"\"\"Range of x values, clipped to the canvas dimensions.\n\n        Args:\n            start: Start index.\n            end: End index.\n\n        Returns:\n            A range object.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n    def __contains__(self, other: Any) -> bool:\n        try:\n            x: int\n            y: int\n            x, y = other\n        except Exception:\n            raise TypeError(\n                \"Dimensions.__contains__ requires an iterable of two integers\"\n            )\n        width, height = self\n        return width > x >= 0 and height > y >= 0\n\n    def clamp_offset(self, offset: Offset) -> Offset:\n        \"\"\"Clamp an offset to fit within the width x height.\n\n        Args:\n            offset: An offset.\n\n        Returns:\n\n------------------------------\n------------------------------\n        \"\"\"Get a new Size with just the width changed.\n\n        Args:\n            width: New width.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(width, self.height)\n\n    def with_height(self, height: int) -> Size:\n        \"\"\"Get a new Size with just the height changed.\n\n        Args:\n            width: New height.\n\n        Returns:\n            New Size instance.\n        \"\"\"\n        return Size(self.width, height)\n\n------------------------------\n------------------------------\n    def expand(self, size: tuple[int, int]) -> Region:\n        \"\"\"Increase the size of the region by adding a border.\n\n        Args:\n            size: Additional width and height.\n\n        Returns:\n            A new region.\n        \"\"\"\n        expand_width, expand_height = size\n        x, y, width, height = self\n        return Region(\n            x - expand_width,\n            y - expand_height,\n            width + expand_width * 2,\n            height + expand_height * 2,\n        )\n\n    def clip_size(self, size: tuple[int, int]) -> Region:\n        \"\"\"Clip the size to fit within minimum values.\n\n------------------------------\n------------------------------\n                return False\n\n    def clip(self, width: int, height: int) -> Region:\n        \"\"\"Clip this region to fit within width, height.\n\n        Args:\n            width: Width of bounds.\n            height: Height of bounds.\n\n        Returns:\n            Clipped region.\n        \"\"\"\n        x1, y1, x2, y2 = self.corners\n\n        _clamp = clamp\n        new_region = Region.from_corners(\n            _clamp(x1, 0, width),\n            _clamp(y1, 0, height),\n            _clamp(x2, 0, width),\n            _clamp(y2, 0, height),\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def clamp(self, width: int, height: int) -> Offset:\n# Natural Language Annotations: \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    x, y = self\n    return Offset(\n        clamp(x, 0, width - 1),\n        clamp(y, 0, height - 1),\n    )\n```\n", "```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    x, y = self\n    x = max(min(x, width - 1), 0)\n    y = max(min(y, height - 1), 0)\n    return Offset(x, y)\n```\n", "```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    x, y = self\n    x = max(0, min(width, x))\n    y = max(0, min(height, y))\n    return Offset(x, y)\n```\n"]}, "textual-src/textual/constants.py-_get_textual_animations": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to show.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n        Raises:\n            TabError: If there are any issues with the request.\n        \"\"\"\n        return super().show(ContentTab.add_prefix(tab_id))\n\n\nclass TabPane(Widget):\n    \"\"\"A container for switchable content, with additional title.\n\n    This widget is intended to be used with [TabbedContent][textual.widgets.TabbedContent].\n    \"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    TabPane {\n\n------------------------------\n------------------------------\n    \"\"\"Retrieves an integer environment variable.\n\n    Args:\n        name: Name of environment variable.\n        default: The value to use if the value is not set, or set to something other\n            than a valid integer.\n\n    Returns:\n        The integer associated with the environment variable if it's set to a valid int\n            or the default value otherwise.\n    \"\"\"\n    try:\n        return int(os.environ[name])\n    except KeyError:\n        return default\n    except ValueError:\n        return default\n\n\ndef _is_valid_animation_level(value: str) -> TypeGuard[AnimationLevel]:\n\n------------------------------\n------------------------------\n    def disable(self, tab_id: str) -> Tab:\n        \"\"\"Disable the indicated tab.\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to disable.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n        Raises:\n            TabError: If there are any issues with the request.\n        \"\"\"\n        return super().disable(ContentTab.add_prefix(tab_id))\n\n    def enable(self, tab_id: str) -> Tab:\n        \"\"\"Enable the indicated tab.\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to enable.\n\n\n------------------------------\n------------------------------\n        \"\"\"Enable the indicated tab.\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to enable.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n        Raises:\n            TabError: If there are any issues with the request.\n        \"\"\"\n        return super().enable(ContentTab.add_prefix(tab_id))\n\n    def hide(self, tab_id: str) -> Tab:\n        \"\"\"Hide the indicated tab.\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to hide.\n\n        Returns:\n\n------------------------------\n------------------------------\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to hide.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n        Raises:\n            TabError: If there are any issues with the request.\n        \"\"\"\n        return super().hide(ContentTab.add_prefix(tab_id))\n\n    def show(self, tab_id: str) -> Tab:\n        \"\"\"Show the indicated tab.\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to show.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_textual_animations() -> AnimationLevel:\n# Natural Language Annotations: \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    return _is_valid_animation_level(os.getenv(\"TEXTUAL_ANIMATIONS\", \"all\"))\n```\n", "```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    return _get_int_env_var('TEXTUAL_ANIMATION', AnimationLevel.ALL)\n```\n", "```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    try:\n        return AnimationLevel(get_validated_integer_env('TEXTUAL_ANIMATION_LEVEL', 4))\n    except ValueError:\n        return AnimationLevel.ALL\n```\n"]}, "textual-src/textual/color.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"Set the box property.\n\n        Args:\n            obj: The ``Styles`` object.\n            value: A 2-tuple containing the type of box to use,\n                e.g. \"dashed\", and the ``Style`` to be used. You can supply the ``Style`` directly, or pass a\n                ``str`` (e.g. ``\"blue on #f0f0f0\"`` ) or ``Color`` instead.\n\n        Raises:\n            StyleSyntaxError: If the string supplied for the color has invalid syntax.\n        \"\"\"\n        _rich_traceback_omit = True\n\n        if border is None:\n            if obj.clear_rule(self.name):\n                obj.refresh(layout=True)\n        else:\n            _type, color = border\n            if _type in (\"none\", \"hidden\"):\n                _type = \"\"\n\n------------------------------\n------------------------------\n        Args:\n            spot: The spot to find.\n\n        Returns:\n            The parent and the location in its child list.\n\n        Raises:\n            MountError: If there was an error finding where to mount a widget.\n\n        The rules of this method are:\n\n        - Given an ``int``, parent is ``self`` and location is the integer value.\n        - Given a ``Widget``, parent is the widget's parent and location is\n          where the widget is found in the parent's ``children``. If it\n          can't be found a ``MountError`` will be raised.\n        - Given a string, it is used to perform a ``query_one`` and then the\n          result is used as if a ``Widget`` had been given.\n        \"\"\"\n\n        # A numeric location means at that point in our child list.\n\n------------------------------\n------------------------------\n\n        A gradient is defined by a sequence of \"stops\" consisting of a float and a color.\n        The stop indicate the color at that point on a spectrum between 0 and 1.\n\n        Args:\n            stops: A colors stop.\n\n        Raises:\n            ValueError: If any stops are missing (must be at least a stop for 0 and 1).\n        \"\"\"\n        self._stops = sorted(stops)\n        if len(stops) < 2:\n            raise ValueError(\"At least 2 stops required.\")\n        if self._stops[0][0] != 0.0:\n            raise ValueError(\"First stop must be 0.\")\n        if self._stops[-1][0] != 1.0:\n            raise ValueError(\"Last stop must be 1.\")\n\n    def get_color(self, position: float) -> Color:\n        \"\"\"Get a color from the gradient at a position between 0 and 1.\n\n------------------------------\n------------------------------\n    async def hover(\n        self,\n        selector: type[Widget] | str | None | None = None,\n        offset: tuple[int, int] = (0, 0),\n    ) -> bool:\n        \"\"\"Simulate hovering with the mouse cursor at a specified position.\n\n        The final position to be hovered is computed based on the selector provided and\n        the offset specified and it must be within the visible area of the screen.\n\n        Args:\n            selector: A selector to specify a widget that should be used as the reference\n                for the hover offset. If this is not specified, the offset is interpreted\n                relative to the screen. You can use this parameter to try to hover a\n                specific widget. However, if the widget is currently hidden or obscured by\n                another widget, the hover may not land on the widget you specified.\n            offset: The offset to hover. The offset is relative to the selector provided\n                or to the screen, if no selector is provided.\n\n        Raises:\n\n------------------------------\n------------------------------\n        if self._stops[-1][0] != 1.0:\n            raise ValueError(\"Last stop must be 1.\")\n\n    def get_color(self, position: float) -> Color:\n        \"\"\"Get a color from the gradient at a position between 0 and 1.\n\n        Positions that are between stops will return a blended color.\n\n        Args:\n            position: A number between 0 and 1, where 0 is the first stop, and 1 is the last.\n\n        Returns:\n            A color.\n        \"\"\"\n        # TODO: consider caching\n        position = clamp(position, 0.0, 1.0)\n        for (stop1, color1), (stop2, color2) in zip(self._stops, self._stops[1:]):\n            if stop2 >= position >= stop1:\n                return color1.blend(\n                    color2,\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(cls, color_text: str | Color) -> Color:\n# Natural Language Annotations: \"\"\"Parse a string containing a named color or CSS-style color.\n\n        Colors may be parsed from the following formats:\n\n        - Text beginning with a `#` is parsed as a hexadecimal color code,\n         where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n            - `#RGB`\n            - `#RGBA`\n            - `#RRGGBB`\n            - `#RRGGBBAA`\n\n        - Alternatively, RGB colors can also be specified in the format\n         that follows, where R, G, and B must be numbers between 0 and 255\n         and A must be a value between 0 and 1:\n\n            - `rgb(R,G,B)`\n            - `rgb(R,G,B,A)`\n\n        - The HSL model can also be used, with a syntax similar to the above,\n         if H is a value between 0 and 360, S and L are percentages, and A\n         is a value between 0 and 1:\n\n            - `hsl(H,S,L)`\n            - `hsla(H,S,L,A)`\n\n        Any other formats will raise a `ColorParseError`.\n\n        Args:\n            color_text: Text with a valid color format. Color objects will\n                be returned unmodified.\n\n        Raises:\n            ColorParseError: If the color is not encoded correctly.\n\n        Returns:\n            Instance encoding the color specified by the argument.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef parse(cls, color_text: str | Color) -> Color:\n    \"\"\"Parse a string containing a named color or CSS-style color.\n\n    Colors may be parsed from the following formats:\n\n    - Text beginning with a `#` is parsed as a hexadecimal color code,\n     where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n        - `#RGB`\n        - `#RGBA`\n        - `#RRGGBB`\n        - `#RRGGBBAA`\n\n    - Alternatively, RGB colors can also be specified in the format\n     that follows, where R, G, and B must be numbers between 0 and 255\n     and A must be a value between 0 and 1:\n\n        - `rgb(R,G,B)`\n        - `rgb(R,G,B,A)`\n\n    - The HSL model can also be used, with a syntax similar to the above,\n     if H is a value between 0 and 360, S and L are percentages, and A\n     is a value between 0 and 1:\n\n        - `hsl(H,S,L)`\n        - `hsla(H,S,L,A)`\n\n    Any other formats will raise a `ColorParseError`.\n\n    Args:\n        color_text: Text with a valid color format. Color objects will\n            be returned unmodified.\n\n    Raises:\n        ColorParseError: If the color is not encoded correctly.\n\n    Returns:\n        Instance encoding the color specified by the argument.\n    \"\"\"\n```\n", "```python\ndef parse(cls, color_text: str | Color) -> Color:\n    \"\"\"Parse a string containing a named color or CSS-style color.\n\n    Colors may be parsed from the following formats:\n\n    - Text beginning with a `#` is parsed as a hexadecimal color code,\n     where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n        - `#RGB`\n        - `#RGBA`\n        - `#RRGGBB`\n        - `#RRGGBBAA`\n\n    - Alternatively, RGB colors can also be specified in the format\n     that follows, where R, G, and B must be numbers between 0 and 255\n     and A must be a value between 0 and 1:\n\n        - `rgb(R,G,B)`\n        - `rgb(R,G,B,A)`\n\n    - The HSL model can also be used, with a syntax similar to the above,\n     if H is a value between 0 and 360, S and L are percentages, and A\n     is a value between 0 and 1:\n\n        - `hsl(H,S,L)`\n        - `hsla(H,S,L,A)`\n\n    Any other formats will raise a `ColorParseError`.\n\n    Args:\n        color_text: Text with a valid color format. Color objects will\n            be returned unmodified.\n\n    Raises:\n        ColorParseError: If the color is not encoded correctly.\n\n    Returns:\n        Instance encoding the color specified by the argument.\n    \"\"\"\n    if isinstance(color_text, Color):\n        return color_text\n\n    if isinstance(color_text, str):\n        if color_text.startswith(\"#\"):\n            # handle hexadecimal color\n            pass\n        elif color_text.startswith(\"rgb\"):\n            # handle rgb color\n            pass\n        elif color_text.startswith(\"hsl\"):\n            # handle hsl color\n            pass\n        else:\n            # handle named color\n            pass\n    else:\n        raise ColorParseError(\"Invalid color format\")\n```\n", "```python\ndef parse(cls, color_text: str | Color) -> Color:\n    \"\"\"Parse a string containing a named color or CSS-style color.\n\n    Colors may be parsed from the following formats:\n\n    - Text beginning with a `#` is parsed as a hexadecimal color code,\n        where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n        - `#RGB`\n        - `#RGBA`\n        - `#RRGGBB`\n        - `#RRGGBBAA`\n\n    - Alternatively, RGB colors can also be specified in the format\n        that follows, where R, G, and B must be numbers between 0 and 255\n        and A must be a value between 0 and 1:\n\n        - `rgb(R,G,B)`\n        - `rgb(R,G,B,A)`\n\n    - The HSL model can also be used, with a syntax similar to the above,\n        if H is a value between 0 and 360, S and L are percentages, and A\n        is a value between 0 and 1:\n\n        - `hsl(H,S,L)`\n        - `hsla(H,S,L,A)`\n\n    Any other formats will raise a `ColorParseError`.\n\n    Args:\n        color_text: Text with a valid color format. Color objects will\n            be returned unmodified.\n\n    Raises:\n        ColorParseError: If the color is not encoded correctly.\n\n    Returns:\n        Instance encoding the color specified by the argument.\n    \"\"\"\n    # ...\n    # Your code implementation here\n    # ...\n```\n"]}, "textual-src/textual/_slug.py-slug": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        \"\"\"\n        if isinstance(label, str):\n            text_label = Text(label)\n        else:\n            text_label = label\n        first_line = text_label.split()[0]\n        return first_line\n\n    def render_label(\n        self, node: TreeNode[DirEntry], base_style: Style, style: Style\n    ) -> Text:\n        \"\"\"Render a label for the given node.\n\n        Args:\n            node: A tree node.\n            base_style: The base style of the widget.\n            style: The additional style for the label.\n\n        Returns:\n            A Rich Text object containing the label.\n\n------------------------------\n------------------------------\nSTRIP_RE: Final[Pattern] = compile(f\"[{REMOVABLE}{NONLINGUAL}]+\")\n\"\"\"A regular expression for finding all the characters that should be removed.\"\"\"\n\nWHITESPACE_RE: Final[Pattern] = compile(r\"\\s\")\n\"\"\"A regular expression for finding all the whitespace and turning it into `REPLACEMENT`.\"\"\"\n\n\ndef slug(text: str) -> str:\n    \"\"\"Create a Markdown-friendly slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n\n    The rules used in generating the slug are based on observations of how\n    GitHub-flavoured Markdown works.\n    \"\"\"\n    result = text.strip().lower()\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    def location_to_offset(self, location: Location) -> Offset:\n        \"\"\"\n        Convert a location in the document to an offset within the wrapped/visual display of the document.\n\n        Args:\n            location: The location in the document.\n\n        Returns:\n            The Offset in the document's visual display corresponding to the given location.\n        \"\"\"\n        line_index, column_index = location\n\n------------------------------\n------------------------------\n            alpha: New value for alpha.\n\n        Returns:\n            A new color.\n        \"\"\"\n        r, g, b, _ = self\n        return Color(r, g, b, alpha)\n\n    def multiply_alpha(self, alpha: float) -> Color:\n        \"\"\"Create a new color, multiplying the alpha by a constant.\n\n        Args:\n            alpha: A value to multiple the alpha by (expected to be in the range 0 to 1).\n\n        Returns:\n            A new color.\n        \"\"\"\n        r, g, b, a = self\n        return Color(r, g, b, a * alpha)\n\n\n------------------------------\n------------------------------\n    def log(self) -> Logger:\n        \"\"\"Get a logger for this object.\n\n        Returns:\n            A logger.\n        \"\"\"\n        return self.app._logger\n\n    def _attach(self, parent: MessagePump) -> None:\n        \"\"\"Set the parent, and therefore attach this node to the tree.\n\n        Args:\n            parent: Parent node.\n        \"\"\"\n        self._parent = parent\n\n    def _detach(self) -> None:\n        \"\"\"Set the parent to None to remove the node from the tree.\"\"\"\n        self._parent = None\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def slug(self, text: str) -> str:\n# Natural Language Annotations: \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n        Args:\n            text: The text to generate a slug from.\n\n        Returns:\n            A slug for the given text.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n\n    result = re.sub(STRIP_RE, \"\", result)\n    result = re.sub(WHITESPACE_RE, REPLACEMENT, result)\n\n    return result\n```\n", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    result = text.strip().lower()\n    result = self.STRIP_RE.sub(self.REPLACEMENT, result)\n    result = self.WHITESPACE_RE.sub(self.REPLACEMENT, result)\n    result = self.DASH_RE.sub(self.DASH_REPLACEMENT, result)\n    return result\n```\n", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n\n    result = STRIP_RE.sub(REPLACEMENT, text.strip().lower())\n    result = WHITESPACE_RE.sub(REPLACEMENT, result)\n\n    # Ensure the slug is unique by appending a number if necessary\n    count = collections.defaultdict(int)\n    for word in result.split('-'):\n        count[word] += 1\n    result = '-'.join(word if count[word] == 1 else f'{word}-{count[word]}' for word in result.split('-'))\n\n    return result\n```\n"]}, "textual-src/textual/_styles_cache.py-render": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    def get_content_height(\n        self, widget: Widget, container: Size, viewport: Size, width: int\n    ) -> int:\n        \"\"\"Get the content height.\n\n        Args:\n            widget: The container widget.\n            container: The container size.\n            viewport: The viewport.\n            width: The content width.\n\n        Returns:\n            Content height (in lines).\n        \"\"\"\n        if not widget._nodes:\n            height = 0\n        else:\n            # Use a height of zero to ignore relative heights\n            styles_height = widget.styles.height\n\n------------------------------\n------------------------------\n            y: Y coordinate of line.\n\n        Returns:\n            True if line requires a render, False if can be cached.\n        \"\"\"\n        return y in self._dirty_lines\n\n    def clear(self) -> None:\n        \"\"\"Clear the styles cache (will cause the content to re-render).\"\"\"\n        self._cache.clear()\n        self._dirty_lines.clear()\n\n    def render_widget(self, widget: Widget, crop: Region) -> list[Strip]:\n        \"\"\"Render the content for a widget.\n\n        Args:\n            widget: A widget.\n            region: A region of the widget to render.\n\n        Returns:\n\n------------------------------\n------------------------------\n        Args:\n            widget: A widget.\n            region: A region of the widget to render.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\n\n        border_title = widget._border_title\n        border_subtitle = widget._border_subtitle\n\n        base_background, background = widget._opacity_background_colors\n        styles = widget.styles\n        strips = self.render(\n            styles,\n            widget.region.size,\n            base_background,\n            background,\n            widget.render_line,\n            widget.app.console,\n\n------------------------------\n------------------------------\n        styles: StylesBase,\n        y: int,\n        size: Size,\n        content_size: Size,\n        padding: Spacing,\n        base_background: Color,\n        background: Color,\n        render_content_line: Callable[[int], Strip],\n        console: Console,\n        border_title: tuple[Text, Color, Color, Style] | None,\n        border_subtitle: tuple[Text, Color, Color, Style] | None,\n        opacity: float,\n    ) -> Strip:\n        \"\"\"Render a styled line.\n\n        Args:\n            styles: Styles object.\n            y: The y coordinate of the line (relative to widget screen offset).\n            size: Size of the widget.\n            content_size: Size of the content area.\n\n------------------------------\n------------------------------\n        Args:\n            styles: Styles object.\n            y: The y coordinate of the line (relative to widget screen offset).\n            size: Size of the widget.\n            content_size: Size of the content area.\n            padding: Padding.\n            base_background: Background color of widget beneath this line.\n            background: Background color of widget.\n            render_content_line: Callback to render a line of content.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            opacity: Opacity of line.\n\n        Returns:\n            A line of segments.\n        \"\"\"\n\n        gutter = styles.gutter\n        width, height = size\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(\n# Natural Language Annotations: \"\"\"Render a widget content plus CSS styles.\n\n        Args:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            content_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef render(\n    styles: CSSStyles,\n    size: Size,\n    base_background: Color,\n    background: Color,\n    render_content_line: Callable[[int], Strip],\n    console: Console,\n    border_title: Optional[Tuple[Text, Color, Color, Style]] = None,\n    border_subtitle: Optional[Tuple[Text, Color, Color, Style]] = None,\n    content_size: Optional[Size] = None,\n    padding: Optional[Spacing] = None,\n    crop: Optional[Region] = None,\n    filters: Optional[List[Callable[[Strip], Strip]]] = None,\n    opacity: float = 1.0\n) -> List[Strip]:\n    \"\"\"Render a widget content plus CSS styles.\n\n    Args:\n        styles: CSS Styles object.\n        size: Size of widget.\n        base_background: Background color beneath widget.\n        background: Background color of widget.\n        render_content_line: Callback to render content line.\n        console: The console in use by the app.\n        border_title: Optional tuple of (title, color, background, style).\n        border_subtitle: Optional tuple of (subtitle, color, background, style).\n        content_size: Size of content or None to assume full size.\n        padding: Override padding from Styles, or None to use styles.padding.\n        crop: Region to crop to.\n        filters: Additional post-processing for the segments.\n        opacity: Widget opacity.\n\n    Returns:\n        Rendered lines.\n    \"\"\"\n    # Your implementation here\n```\n", "```python\ndef render(\n    styles: CSSStyles,\n    size: Size,\n    base_background: Color,\n    background: Color,\n    render_content_line: Callable[[int], Strip],\n    console: Console,\n    border_title: Optional[Tuple[Text, Color, Color, Style]] = None,\n    border_subtitle: Optional[Tuple[Text, Color, Color, Style]] = None,\n    content_size: Optional[Size] = None,\n    padding: Optional[Spacing] = None,\n    crop: Optional[Region] = None,\n    filters: Optional[List[Callable[[Strip], Strip]]] = None,\n    opacity: float = 1.0\n) -> List[Strip]:\n\n    # Add your implementation here\n    pass\n```\n", "```python\ndef render(\n    styles: CSSStyles,\n    size: Size,\n    base_background: Color,\n    background: Color,\n    render_content_line: Callable[[int], Strip],\n    console: Console,\n    border_title: tuple[Text, Color, Color, Style] | None,\n    border_subtitle: tuple[Text, Color, Color, Style] | None,\n    content_size: Size = None,\n    padding: Spacing = None,\n    crop: Region = None,\n    filters: List[FilterBase] = None,\n    opacity: float = 1.0\n) -> List[Strip]:\n    # your implementation here\n    pass\n```\n"]}, "textual-src/textual/document/_document.py-replace_range": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        The default implementation always returns an empty list.\n\n        To support querying in a subclass, this must be implemented.\n\n        Args:\n            query: The tree-sitter Query to perform.\n            start_point: The (row, column byte) to start the query at.\n            end_point: The (row, column byte) to end the query at.\n\n        Returns:\n            A tuple containing the nodes and text captured by the query.\n        \"\"\"\n        return []\n\n    def prepare_query(self, query: str) -> Query | None:\n        return None\n\n    @property\n    @abstractmethod\n\n------------------------------\n------------------------------\n        *,\n        maintain_selection_offset: bool = True,\n    ) -> EditResult:\n        \"\"\"Replace text in the document with new text.\n\n        Args:\n            insert: The text to insert.\n            start: The start location\n            end: The end location.\n            maintain_selection_offset: If True, the active Selection will be updated\n                such that the same text is selected before and after the selection,\n                if possible. Otherwise, the cursor will jump to the end point of the\n                edit.\n\n        Returns:\n            An `EditResult` containing information about the edit.\n        \"\"\"\n        return self.edit(Edit(insert, start, end, maintain_selection_offset))\n\n    def clear(self) -> EditResult:\n\n------------------------------\n------------------------------\n            captures_kwargs[\"start_point\"] = start_point\n        if end_point is not None:\n            captures_kwargs[\"end_point\"] = end_point\n\n        captures = query.captures(self._syntax_tree.root_node, **captures_kwargs)\n        return captures\n\n    def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n        \"\"\"Replace text at the given range.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n        top, bottom = sorted((start, end))\n\n\n------------------------------\n------------------------------\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def text(self) -> str:\n        \"\"\"The text from the document as a string.\"\"\"\n\n    @property\n    @abstractmethod\n    def newline(self) -> Newline:\n        \"\"\"Return the line separator used in the document.\"\"\"\n\n    @property\n    @abstractmethod\n\n------------------------------\n------------------------------\n    elif \"\\r\" in text:  # Old MacOS newline\n        return \"\\r\"\n    else:\n        return \"\\n\"  # Default to Unix style newline\n\n\nclass DocumentBase(ABC):\n    \"\"\"Describes the minimum functionality a Document implementation must\n    provide in order to be used by the TextArea widget.\"\"\"\n\n    @abstractmethod\n    def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n        \"\"\"Replace the text at the given range.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n# Natural Language Annotations: \"\"\"Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"\n    Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    # Your code here\n    pass\n```\n", "```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n        replace operation.\n    \"\"\"\n    # Your implementation here\n    pass\n```\n", "```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"\n    Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    # TODO: Implement the replacement logic.\n    # This is a placeholder function.\n    return EditResult()\n```\n"]}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n            location = self.cursor_location\n        return self.edit(Edit(text, location, location, maintain_selection_offset))\n\n    def delete(\n        self,\n        start: Location,\n        end: Location,\n        *,\n        maintain_selection_offset: bool = True,\n    ) -> EditResult:\n        \"\"\"Delete the text between two locations in the document.\n\n        Args:\n            start: The start location.\n            end: The end location.\n            maintain_selection_offset: If True, the active Selection will be updated\n                such that the same text is selected before and after the selection,\n                if possible. Otherwise, the cursor will jump to the end point of the\n                edit.\n\n\n------------------------------\n------------------------------\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The new end location after the edit is complete.\n        \"\"\"\n\n    @property\n    @abstractmethod\n    def text(self) -> str:\n        \"\"\"The text from the document as a string.\"\"\"\n\n    @property\n    @abstractmethod\n    def newline(self) -> Newline:\n        \"\"\"Return the line separator used in the document.\"\"\"\n\n    @property\n    @abstractmethod\n\n------------------------------\n------------------------------\n    def _replace_via_keyboard(\n        self,\n        insert: str,\n        start: Location,\n        end: Location,\n    ) -> EditResult | None:\n        \"\"\"Handle a replacement performed using a keyboard (as opposed to the API).\n\n        Args:\n            insert: The text to insert into the document.\n            start: The start location of the text to replace.\n            end: The end location of the text to replace.\n\n        Returns:\n            An EditResult or None if no edit was performed (e.g. on read-only mode).\n        \"\"\"\n        if self.read_only:\n            return None\n        return self.replace(insert, start, end, maintain_selection_offset=False)\n\n\n------------------------------\n------------------------------\n        for the cursor to rest.\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the document is at the end of a line in the document.\n        \"\"\"\n        row, column = location\n        row_length = len(self._document[row])\n        return column == row_length\n\n    def is_end_of_wrapped_line(self, location: Location) -> bool:\n        \"\"\"True if the location is at the end of a wrapped line.\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the cursor is on the last wrapped section of *any* line.\n\n------------------------------\n------------------------------\n        \"\"\"Returns the line with the given index from the document.\n\n        This is used in rendering lines, and will be called by the\n        TextArea for each line that is rendered.\n\n        Args:\n            index: The index of the line in the document.\n\n        Returns:\n            The str instance representing the line.\n        \"\"\"\n\n    @abstractmethod\n    def get_text_range(self, start: Location, end: Location) -> str:\n        \"\"\"Get the text that falls between the start and end locations.\n\n        Args:\n            start: The start location of the selection.\n            end: The end location of the selection.\n\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def wrap_range(\n# Natural Language Annotations: \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n        This must be called *after* the source document has been edited.\n\n        Args:\n            start: The start location of the edit that was performed in document-space.\n            old_end: The old end location of the edit in document-space.\n            new_end: The new end location of the edit in document-space.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef wrap_range(\n    self,\n    start: Location,\n    old_end: Location,\n    new_end: Location,\n) -> None:\n    \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n```\n", "```python\ndef wrap_range(\n    self,\n    start: Location,\n    old_end: Location,\n    new_end: Location,\n) -> None:\n    \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n    # Your implementation here\n```\n", "```python\ndef wrap_range(\n    self,\n    start: Location,\n    old_end: Location,\n    new_end: Location,\n) -> None:\n    \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n    # Code here to incrementally recompute wrapping based on the performed edit.\n    # This will depend on the specifics of how wrapping is implemented in your code.\n    pass\n```\n"]}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    ) -> int:\n        \"\"\"Given a line index and the offsets within the wrapped version of that\n        line, return the corresponding column index in the raw document.\n\n        Args:\n             line_index: The index of the line in the document.\n             x_offset: The x-offset within the wrapped line.\n             y_offset: The y-offset within the wrapped line (supports negative indexing).\n\n        Returns:\n            The column index corresponding to the line index and y offset.\n        \"\"\"\n\n        # We've found the relevant line, now find the character by\n        # looking at the character corresponding to the offset width.\n        sections = self.get_sections(line_index)\n\n        # wrapped_section is the text that appears on a single y_offset within\n        # the TextArea. It's a potentially wrapped portion of a larger line from\n        # the original document.\n\n------------------------------\n------------------------------\n        Args:\n            location: The location in the document.\n\n        Returns:\n            The index in the document's text.\n        \"\"\"\n        row, column = location\n        index = row * len(self.newline) + column\n        for line_index in range(row):\n            index += len(self.get_line(line_index))\n        return index\n\n    def get_location_from_index(self, index: int) -> Location:\n        \"\"\"Given an index in the document's text, returns the corresponding location.\n\n        Args:\n            index: The index in the document's text.\n\n        Returns:\n            The corresponding location.\n\n------------------------------\n------------------------------\n    def get_location_below(self, location: Location) -> Location:\n        \"\"\"Given a location in the raw document, return the raw document\n        location corresponding to moving down in the wrapped representation\n        of the document.\n\n        Args:\n            location: The location in the raw document.\n\n        Returns:\n            The location which is *visually* below the given location.\n        \"\"\"\n        line_index, column_index = location\n        document = self._document\n\n        wrap_offsets = self._wrapped_document.get_offsets(line_index)\n        section_start_columns = [0, *wrap_offsets]\n        section_index = bisect(wrap_offsets, column_index)\n        offset_within_section = column_index - section_start_columns[section_index]\n        wrapped_line = self._wrapped_document.get_sections(line_index)\n        section = wrapped_line[section_index]\n\n------------------------------\n------------------------------\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the cursor is on the first line of the document.\n        \"\"\"\n        return location[0] == 0\n\n    def is_first_wrapped_line(self, location: Location) -> bool:\n        \"\"\"Check if the given location is on the first wrapped section of the first line in the document.\n\n        Args:\n            location: The location to examine.\n\n        Returns:\n            True if and only if the cursor is on the first wrapped section of the first line.\n        \"\"\"\n        if not self.is_first_document_line(location):\n            return False\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    def location_to_offset(self, location: Location) -> Offset:\n        \"\"\"\n        Convert a location in the document to an offset within the wrapped/visual display of the document.\n\n        Args:\n            location: The location in the document.\n\n        Returns:\n            The Offset in the document's visual display corresponding to the given location.\n        \"\"\"\n        line_index, column_index = location\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def offset_to_location(self, offset: Offset) -> Location:\n# Natural Language Annotations: \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    line_index = 0\n    while offset > 0 and line_index < len(self._wrapped_document.get_sections()):\n        offset -= len(self._wrapped_document.get_sections(line_index))\n        line_index += 1\n\n    if offset != 0:\n        raise ValueError(\"The given offset does not correspond to a line in the document.\")\n\n    return Location(line_index, offset)\n```\n", "```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    line_index, wrap_offset = offset\n\n    if line_index >= len(self._wrapped_document.lines):\n        raise ValueError(\"The given offset does not correspond to a line in the document.\")\n\n    sections = self._wrapped_document.get_sections(line_index)\n    section_starts = [0, *self._wrapped_document.get_offsets(line_index)]\n    section_index = bisect(section_starts, wrap_offset)\n\n    if section_index == 0:\n        column_index = wrap_offset\n    else:\n        section_offset = wrap_offset - section_starts[section_index - 1]\n        column_index = self._wrapped_document.get_column_index(sections[section_index - 1], section_offset)\n\n    return Location(line_index, column_index)\n```\n", "```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    wrap_offsets = self._wrapped_document.get_offsets(offset)\n    section_start_columns = [0, *wrap_offsets]\n    section_index = bisect(wrap_offsets, offset)\n    offset_within_section = offset - section_start_columns[section_index]\n    wrapped_line = self._wrapped_document.get_sections(offset)\n    section = wrapped_line[section_index]\n\n    # If the section is a newline, we need to re-wrap the line.\n    if section == self.newline:\n        return Location(offset, 0)\n\n    # Otherwise, we need to find the corresponding character in the original line.\n    line_index = self._wrapped_document.get_line_index(offset)\n    line = self._document.get_line(line_index)\n    column_index = self._wrapped_document.x_to_column(line, offset_within_section)\n\n    return Location(line_index, column_index)\n```\n"]}, "textual-src/textual/css/parse.py-substitute_references": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    _split=_re_spaces.split,\n) -> Iterable[Segment]:\n    \"\"\"Replace run of spaces with another character + style.\n\n    Args:\n        segments: Segments to process.\n        character: Character to replace spaces.\n        hatch_style: Style of replacement characters.\n\n    Yields:\n        Segments.\n    \"\"\"\n    _Segment = Segment\n    for segment in segments:\n        if \" \" not in segment.text:\n            yield segment\n        else:\n            text, style, _ = segment\n            for token in _split(text):\n                if token:\n\n------------------------------\n------------------------------\n        self.screen.refresh_bindings()\n\n    def _detach_from_dom(self, widgets: list[Widget]) -> list[Widget]:\n        \"\"\"Detach a list of widgets from the DOM.\n\n        Args:\n            widgets: The list of widgets to detach from the DOM.\n\n        Returns:\n            The list of widgets that should be pruned.\n\n        Note:\n            A side-effect of calling this function is that each parent of\n            each affected widget will be made to forget about the affected\n            child.\n        \"\"\"\n\n        # We've been given a list of widgets to remove, but removing those\n        # will also result in other (descendent) widgets being removed. So\n        # to start with let's get a list of everything that's not going to\n\n------------------------------\n------------------------------\n        *,\n        maintain_selection_offset: bool = True,\n    ) -> EditResult:\n        \"\"\"Replace text in the document with new text.\n\n        Args:\n            insert: The text to insert.\n            start: The start location\n            end: The end location.\n            maintain_selection_offset: If True, the active Selection will be updated\n                such that the same text is selected before and after the selection,\n                if possible. Otherwise, the cursor will jump to the end point of the\n                edit.\n\n        Returns:\n            An `EditResult` containing information about the edit.\n        \"\"\"\n        return self.edit(Edit(insert, start, end, maintain_selection_offset))\n\n    def clear(self) -> EditResult:\n\n------------------------------\n------------------------------\nfrom __future__ import annotations\n\nfrom typing import Callable, Iterable, TypeVar\n\nT = TypeVar(\"T\")\n\n\ndef partition(\n    predicate: Callable[[T], object], iterable: Iterable[T]\n) -> tuple[list[T], list[T]]:\n    \"\"\"Partition a sequence in to two list from a given predicate. The first list will contain\n    the values where the predicate is False, the second list will contain the remaining values.\n\n    Args:\n        predicate: A callable that returns True or False for a given value.\n        iterable: In Iterable of values.\n\n    Returns:\n        A list of values where the predicate is False, and a list\n            where the predicate is True.\n\n------------------------------\n------------------------------\n        return (line + 1, offset + len(self.value) + 1)\n\n    def with_reference(self, by: ReferencedBy | None) -> \"Token\":\n        \"\"\"Return a copy of the Token, with reference information attached.\n        This is used for variable substitution, where a variable reference\n        can refer to tokens which were defined elsewhere. With the additional\n        ReferencedBy data attached, we can track where the token we are referring\n        to is used.\n        \"\"\"\n        return Token(\n            name=self.name,\n            value=self.value,\n            read_from=self.read_from,\n            code=self.code,\n            location=self.location,\n            referenced_by=by,\n        )\n\n    def __str__(self) -> str:\n        return self.value\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def substitute_references(\n# Natural Language Annotations: \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Iterable\n\ndef substitute_references(tokens: Iterable[Token]) -> Iterable[Token]:\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            yield token.subsitute()\n        else:\n            yield token\n```\n", "```python\ndef substitute_references(tokens: Iterable[Token]) -> Iterable[Token]:\n    \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            # Perform the substitution logic here\n            # For example, you could get the value of the variable referenced by this token\n            # using a dictionary or some other data structure, and then yield a new token\n            # with the value and the appropriate attributes.\n            value_token = get_value_token(token)\n            yield value_token.with_reference(ReferencedBy(token.location, token.location))\n        else:\n            yield token\n```\n", "Sure, here is the function based on the function signature and natural language annotations:\n\n```python\nfrom typing import Iterable\n\ndef substitute_references(tokens: Iterable[Token]) -> Iterable[Token]:\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            # Assuming you have a dictionary where keys are variable names and values are the corresponding tokens\n            value_token = variable_dict[token.value]  # replace with your own logic\n            yield value_token.with_reference(ReferencedBy(token.location, token.name))\n        else:\n            yield token\n```\n\nPlease replace `variable_dict` and `ReferencedBy` with your own logic. This code assumes that `variable_dict` is a dictionary where keys are variable names and values are the corresponding tokens. The `ReferencedBy` class is used to keep track of where the token is being substituted.\n"]}, "textual-src/textual/css/parse.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        return (line + 1, offset + len(self.value) + 1)\n\n    def with_reference(self, by: ReferencedBy | None) -> \"Token\":\n        \"\"\"Return a copy of the Token, with reference information attached.\n        This is used for variable substitution, where a variable reference\n        can refer to tokens which were defined elsewhere. With the additional\n        ReferencedBy data attached, we can track where the token we are referring\n        to is used.\n        \"\"\"\n        return Token(\n            name=self.name,\n            value=self.value,\n            read_from=self.read_from,\n            code=self.code,\n            location=self.location,\n            referenced_by=by,\n        )\n\n    def __str__(self) -> str:\n        return self.value\n\n------------------------------\n------------------------------\n        \"\"\"\n        self._updates += 1\n        self._rules.update(other.get_rules())\n\n    def merge_rules(self, rules: RulesMap) -> None:\n        self._updates += 1\n        self._rules.update(rules)\n\n    def extract_rules(\n        self,\n        specificity: Specificity3,\n        is_default_rules: bool = False,\n        tie_breaker: int = 0,\n    ) -> list[tuple[str, Specificity6, Any]]:\n        \"\"\"Extract rules from Styles object, and apply !important css specificity as\n        well as higher specificity of user CSS vs widget CSS.\n\n        Args:\n            specificity: A node specificity.\n            is_default_rules: True if the rules we're extracting are\n\n------------------------------\n------------------------------\n\n        Args:\n            path: The file path of the source in question.\n            class_var: The widget class variable we might be reading the CSS from.\n\n        Returns:\n            Whether the stylesheet is aware of this CSS source or not.\n        \"\"\"\n        return (path, class_var) in self.source\n\n    def add_source(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_css: bool = False,\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n\n\n------------------------------\n------------------------------\n        well as higher specificity of user CSS vs widget CSS.\n\n        Args:\n            specificity: A node specificity.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n\n        Returns:\n            A list containing a tuple of <RULE NAME>, <SPECIFICITY> <RULE VALUE>.\n        \"\"\"\n        is_important = self.important.__contains__\n        default_rules = 0 if is_default_rules else 1\n        rules: list[tuple[str, Specificity6, Any]] = [\n            (\n                rule_name,\n                (\n                    default_rules,\n                    1 if is_important(rule_name) else 0,\n                    *specificity,\n                    tie_breaker,\n\n------------------------------\n------------------------------\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n\n        Args:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n        if read_from is None:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(\n# Natural Language Annotations: \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation | None = None,\n    variables: dict[str, Token] | None = None,\n    is_default_rules: bool = False,\n) -> None:\n    \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n    # Implementation here...\n```\n", "```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation | None = None,\n    variables: dict[str, str] = {},\n    is_default_rules: bool = False,\n) -> None:\n    \"\"\"Parse CSS by tokenizing it, performing variable substitution, and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n    # Tokenize the CSS\n    tokens = tokenize(css)\n\n    # Perform variable substitution\n    for token in tokens:\n        if token.name in variables:\n            token.value = variables[token.name]\n\n    # Generate rule sets from the tokens\n    rules = generate_rules(tokens, scope)\n\n    # Update the stylesheets with the new rules\n    self.merge_rules(rules)\n```\n", "```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation,\n    variables: dict[str, str],\n    is_default_rules: bool = False\n) -> None:\n    \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n\n    # Tokenize the CSS\n    tokens = tokenize_css(css)\n\n    # Perform variable substitution\n    tokens = perform_variable_substitution(tokens, variables)\n\n    # Generate rule sets\n    rules = generate_rule_sets(tokens, is_default_rules)\n\n    # Update the Styles object with the new rules\n    self.merge_rules(rules)\n\n# Helper functions\n\ndef tokenize_css(css: str) -> list[Token]:\n    # Implementation of tokenizing CSS\n    pass\n\ndef perform_variable_substitution(tokens: list[Token], variables: dict[str, str]) -> list[Token]:\n    # Implementation of performing variable substitution\n    pass\n\ndef generate_rule_sets(tokens: list[Token], is_default_rules: bool) -> RulesMap:\n    # Implementation of generating rule sets\n    pass\n```\n"]}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\nclass CssSource(NamedTuple):\n    \"\"\"Contains the CSS content and whether or not the CSS comes from user defined stylesheets\n    vs widget-level stylesheets.\n\n    Args:\n        content: The CSS as a string.\n        is_defaults: True if the CSS is default (i.e. that defined at the widget level).\n            False if it's user CSS (which will override the defaults).\n        tie_breaker: Specificity tie breaker.\n        scope: Scope of CSS.\n    \"\"\"\n\n    content: str\n    is_defaults: bool\n    tie_breaker: int = 0\n    scope: str = \"\"\n\n\n@rich.repr.auto(angular=True)\nclass Stylesheet:\n\n------------------------------\n------------------------------\n\n        Args:\n            path: The file path of the source in question.\n            class_var: The widget class variable we might be reading the CSS from.\n\n        Returns:\n            Whether the stylesheet is aware of this CSS source or not.\n        \"\"\"\n        return (path, class_var) in self.source\n\n    def add_source(\n        self,\n        css: str,\n        read_from: CSSLocation | None = None,\n        is_default_css: bool = False,\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n    def read(self, filename: str | PurePath) -> None:\n        \"\"\"Read Textual CSS file.\n\n        Args:\n            filename: Filename of CSS.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n------------------------------\n------------------------------\n        well as higher specificity of user CSS vs widget CSS.\n\n        Args:\n            specificity: A node specificity.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n\n        Returns:\n            A list containing a tuple of <RULE NAME>, <SPECIFICITY> <RULE VALUE>.\n        \"\"\"\n        is_important = self.important.__contains__\n        default_rules = 0 if is_default_rules else 1\n        rules: list[tuple[str, Specificity6, Any]] = [\n            (\n                rule_name,\n                (\n                    default_rules,\n                    1 if is_important(rule_name) else 0,\n                    *specificity,\n                    tie_breaker,\n\n------------------------------\n------------------------------\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n\n        Args:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n        if read_from is None:\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _parse_rules(\n# Natural Language Annotations: \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _parse_rules(\n    css: str,\n    read_from: CSSLocation | None = None,\n    is_default_rules: bool = False,\n    scope: str = \"\",\n) -> list[RuleSet]:\n    \"\"\"Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n```\n", "```python\ndef _parse_rules(\n    css: str,\n    read_from: CSSLocation | None,\n    is_default_rules: bool,\n    scope: str\n) -> list[RuleSet]:\n    \"\"\"Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    try:\n        rules = parse_css(css)\n    except CSSParseError as e:\n        raise StylesheetError(f\"Invalid CSS: {e}\") from e\n\n    rule_sets = []\n    for rule in rules:\n        rule_set = RuleSet(rule.selector, rule.declarations)\n        rule_sets.append(rule_set)\n\n    return rule_sets\n```\n", "```python\ndef _parse_rules(\n    css: str,\n    read_from: CSSLocation | None,\n    is_default_rules: bool,\n    scope: str = \"\",\n) -> list[dict[str, Any]]:\n    \"\"\"Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    rules = []\n\n    # Your code here\n\n    return rules\n```\n"]}, "textual-src/textual/css/stylesheet.py-parse": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to hide.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n        Raises:\n            TabError: If there are any issues with the request.\n        \"\"\"\n        return super().hide(ContentTab.add_prefix(tab_id))\n\n    def show(self, tab_id: str) -> Tab:\n        \"\"\"Show the indicated tab.\n\n        Args:\n            tab_id: The ID of the [`Tab`][textual.widgets.Tab] to show.\n\n        Returns:\n            The [`Tab`][textual.widgets.Tab] that was targeted.\n\n------------------------------\n------------------------------\n        tie_breaker: int = 0,\n        scope: str = \"\",\n    ) -> None:\n        \"\"\"Parse CSS from a string.\n\n        Args:\n            css: String with CSS source.\n            read_from: The original source location of the CSS.\n            path: The path of the source if a file, or some other identifier.\n            is_default_css: True if the CSS is defined in the Widget, False if the CSS is defined\n                in a user stylesheet.\n            tie_breaker: Integer representing the priority of this source.\n            scope: CSS type name to limit scope or empty string for no scope.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n        if read_from is None:\n\n------------------------------\n------------------------------\n    def read_all(self, paths: Sequence[PurePath]) -> None:\n        \"\"\"Read multiple CSS files, in order.\n\n        Args:\n            paths: The paths of the CSS files to read, in order.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n        for path in paths:\n            self.read(path)\n\n    def has_source(self, path: str, class_var: str = \"\") -> bool:\n        \"\"\"Check if the stylesheet has this CSS source already.\n\n        Args:\n            path: The file path of the source in question.\n            class_var: The widget class variable we might be reading the CSS from.\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n    def read(self, filename: str | PurePath) -> None:\n        \"\"\"Read Textual CSS file.\n\n        Args:\n            filename: Filename of CSS.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n    def reparse(self) -> None:\n        \"\"\"Re-parse source, applying new variables.\n\n        Raises:\n            StylesheetError: If the CSS could not be read.\n            StylesheetParseError: If the CSS is invalid.\n        \"\"\"\n        # Do this in a fresh Stylesheet so if there are errors we don't break self.\n        stylesheet = Stylesheet(variables=self._variables)\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(self) -> None:\n# Natural Language Annotations: \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n```\n", "```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    try:\n        # Your parsing logic here\n        pass\n    except Exception as e:\n        raise StylesheetParseError(\"An error occurred while parsing the CSS\") from e\n```\n", "```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    try:\n        # Your parsing logic here\n        pass\n    except Exception as e:\n        raise StylesheetParseError(f\"An error occurred while parsing the CSS: {e}\") from e\n```\n"]}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    return diffs\n\n\ndef parse_hunk_header(header_line) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Parses the header of a hunk from a diff.\n\n    Args:\n    - header_line (str): The header line of a hunk.\n\n    Returns:\n    - tuple: A tuple containing start and length information for pre- and post-edit.\n    \"\"\"\n    pattern = re.compile(r\"^@@ -\\d{1,},\\d{1,} \\+\\d{1,},\\d{1,} @@$\")\n\n    if not pattern.match(header_line):\n        # Return a default value if the header does not match the expected format\n        return 0, 0, 0, 0\n\n    pre, post = header_line.split(\" \")[1:3]\n\n------------------------------\n------------------------------\n        if not start_true:\n            if not self.find_start_line(lines_dict, problems):\n                return False\n\n        # Now we should be able to validate the hunk line by line and add missing line\n        if not self.validate_lines(lines_dict, problems):\n            return False\n        # Pass the validation\n        return True\n\n\nclass Diff:\n    \"\"\"\n    Represents a file diff, containing multiple hunks of changes.\n\n    Attributes:\n        filename_pre (str): The name of the original file.\n        filename_post (str): The name of the edited file.\n        hunks (list): A list of Hunk objects representing the changes in the diff.\n    \"\"\"\n\n------------------------------\n------------------------------\n        content = match.group(2)\n\n        # Add the cleaned path and content to the FilesDict\n        files_dict[path.strip()] = content.strip()\n\n    return files_dict\n\n\ndef apply_diffs(diffs: Dict[str, Diff], files: FilesDict) -> FilesDict:\n    \"\"\"\n    Applies diffs to the provided files.\n\n    Args:\n    - diffs (Dict[str, Diff]): A dictionary of diffs to apply, keyed by filename.\n    - files (FilesDict): The original files to which diffs will be applied.\n\n    Returns:\n    - FilesDict: The updated files after applying diffs.\n    \"\"\"\n    files = FilesDict(files.copy())\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\ndef count_ratio(str1, str2) -> float:\n    \"\"\"\n    Computes the ratio of common characters to the length of the longer string, ignoring spaces and case.\n\n    Parameters:\n    - str1, str2 (str): The strings to compare.\n\n    Returns:\n    - float: The ratio of common characters to the length of the longer string.\n    \"\"\"\n\n------------------------------\n------------------------------\n\n\n\n\n\n\ndef parse_diff_block(diff_block: str) -> dict:\n    \"\"\"\n    Parses a block of diff text into a Diff object.\n\n    Args:\n    - diff_block (str): A single block of diff text.\n\n    Returns:\n    - dict: A dictionary containing a single Diff object keyed by the post-edit filename.\n    \"\"\"\n    lines = diff_block.strip().split(\"\\n\")[1:-1]  # Exclude the opening and closing ```\n    diffs = {}\n    current_diff = None\n    hunk_lines = []\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_diffs(diff_string: str) -> dict:\n# Natural Language Annotations: \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    lines = diff_string.strip().split(\"\\n\")[1:-1]  # Exclude the opening and closing ```\n    diffs = {}\n    current_diff = None\n    hunk_lines = []\n\n    for line in lines:\n        if line.startswith(\"diff --git\"):\n            if current_diff:\n                current_diff.hunks.append(Hunk(hunk_lines))\n                diffs[current_diff.filename_post] = current_diff\n            path_pre, path_post = line.split()[2:4]\n            current_diff = Diff(path_pre[2:], path_post[2:])\n            hunk_lines = []\n        elif line.startswith(\"@@\"):\n            hunk_lines.append(line)\n        else:\n            hunk_lines[-1] += f\"\\n{line}\"\n\n    if current_diff:\n        current_diff.hunks.append(Hunk(hunk_lines))\n        diffs[current_diff.filename_post] = current_diff\n\n    return diffs\n```\n", "```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    lines = diff_string.strip().split(\"\\n\")[1:-1]  # Exclude the opening and closing ```\n    diffs = {}\n    current_diff = None\n    hunk_lines = []\n    for line in lines:\n        if line.startswith(\"diff --git\"):\n            if current_diff:\n                diffs[current_diff.filename_post] = current_diff\n            current_diff = Diff()\n            current_diff.filename_pre, current_diff.filename_post = parse_diff_header(line)\n        elif line.startswith(\"@@\"):\n            if current_diff:\n                hunk_lines = []\n                hunk = Hunk()\n                hunk.pre_start, hunk.pre_length, hunk.post_start, hunk.post_length = parse_hunk_header(line)\n                current_diff.hunks.append(hunk)\n        else:\n            if line.startswith(\"-\"):\n                hunk.pre_lines.append(line[1:])\n            elif line.startswith(\"+\"):\n                hunk.post_lines.append(line[1:])\n    if current_diff:\n        diffs[current_diff.filename_post] = current_diff\n    return diffs\n```\n", "```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diff_blocks = diff_string.split(\"diff --git\")\n    diffs = {}\n\n    for diff_block in diff_blocks:\n        if not diff_block:\n            continue\n\n        lines = diff_block.strip().split(\"\\n\")[1:-1]  # Exclude the opening and closing ```\n        current_diff = None\n        hunk_lines = []\n\n        for line in lines:\n            if line.startswith(\"---\") or line.startswith(\"+++\"):\n                # If we have a current diff, add it to the dict\n                if current_diff:\n                    if current_diff.filename_post not in diffs:\n                        diffs[current_diff.filename_post] = current_diff\n                    else:\n                        diffs[current_diff.filename_post].hunks.extend(current_diff.hunks)\n\n                # Create a new Diff object\n                current_diff = Diff(line[4:].strip(), line[4:].strip())\n            elif line.startswith(\"@@\"):\n                # If we have a current hunk, add it to the Diff object\n                if hunk_lines:\n                    current_diff.add_hunk(parse_hunk_header(hunk_lines[0]), hunk_lines[1:])\n\n                # Start a new hunk\n                hunk_lines = [line]\n            else:\n                # Add line to current hunk\n                hunk_lines.append(line)\n\n        # Add the last hunk\n        if hunk_lines:\n            current_diff.add_hunk(parse_hunk_header(hunk_lines[0]), hunk_lines[1:])\n\n        # Add the last Diff object\n        if current_diff:\n            if current_diff.filename_post not in diffs:\n                diffs[current_diff.filename_post] = current_diff\n            else:\n                diffs[current_diff.filename_post].hunks.extend(current_diff.hunks)\n\n    return diffs\n```\n"]}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    def log(self) -> List[TokenUsage]:\n        \"\"\"\n        Get the token usage log.\n\n        Returns\n        -------\n        List[TokenUsage]\n            A log of token usage details per step in the conversation.\n        \"\"\"\n        return self._log\n\n    def format_log(self) -> str:\n        \"\"\"\n        Format the token usage log as a CSV string.\n\n        Returns\n        -------\n        str\n            The token usage log formatted as a CSV string.\n        \"\"\"\n\n------------------------------\n------------------------------\n        \"\"\"\n        return self.llm.invoke(messages)  # type: ignore\n\n    @staticmethod\n    def serialize_messages(messages: List[Message]) -> str:\n        \"\"\"\n        Serialize a list of messages to a JSON string.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages to serialize.\n\n        Returns\n        -------\n        str\n            The serialized messages as a JSON string.\n        \"\"\"\n        return json.dumps(messages_to_dict(messages))\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n    def _extract_content(self, content):\n        \"\"\"\n        Extracts text content from a message, supporting both string and list types.\n        Parameters\n        ----------\n        content : Union[str, List[dict]]\n            The content of a message, which could be a string or a list.\n        Returns\n        -------\n        str\n            The extracted text content.\n\n------------------------------\n------------------------------\n        str\n            The serialized messages as a JSON string.\n        \"\"\"\n        return json.dumps(messages_to_dict(messages))\n\n    @staticmethod\n    def deserialize_messages(jsondictstr: str) -> List[Message]:\n        \"\"\"\n        Deserialize a JSON string to a list of messages.\n\n        Parameters\n        ----------\n        jsondictstr : str\n            The JSON string to deserialize.\n\n        Returns\n        -------\n        List[Message]\n            The deserialized list of messages.\n        \"\"\"\n\n------------------------------\n------------------------------\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        answer : str\n            The answer from the AI.\n        step_name : str\n            The name of the step.\n        \"\"\"\n        prompt_tokens = self._tokenizer.num_tokens_from_messages(messages)\n        completion_tokens = self._tokenizer.num_tokens(answer)\n        total_tokens = prompt_tokens + completion_tokens\n\n        self._cumulative_prompt_tokens += prompt_tokens\n        self._cumulative_completion_tokens += completion_tokens\n        self._cumulative_total_tokens += total_tokens\n\n        self._log.append(\n            TokenUsage(\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n# Natural Language Annotations: \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    system_message = Message(role=\"system\", content=system)\n    user_message = Message(role=\"user\", content=user)\n    messages = [system_message, user_message]\n    return messages\n```\n", "```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n\n    # Create the system and user messages\n    system_message = Message(role=\"system\", content=system)\n    user_message = Message(role=\"user\", content=user)\n\n    # Return the messages as a list\n    return [system_message, user_message]\n```\n", "```python\ndef start(self, system: str, user: str, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    self._step_name = step_name\n    self._log = []\n    self._cumulative_prompt_tokens = 0\n    self._cumulative_completion_tokens = 0\n    self._cumulative_total_tokens = 0\n\n    messages = [\n        Message(role=\"system\", content=system),\n        Message(role=\"user\", content=user),\n    ]\n    \n    prompt_tokens = self._tokenizer.num_tokens_from_messages(messages)\n    self._cumulative_prompt_tokens += prompt_tokens\n    self._cumulative_total_tokens += prompt_tokens\n\n    self._log.append(\n        TokenUsage(\n            step_name=step_name,\n            prompt_tokens=prompt_tokens,\n            completion_tokens=0,\n            total_tokens=prompt_tokens,\n        )\n    )\n\n    return messages\n```\n"]}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n    \"\"\"\n    Represents a log of token usage statistics for a conversation.\n    \"\"\"\n\n    def __init__(self, model_name):\n        self.model_name = model_name\n        self._cumulative_prompt_tokens = 0\n        self._cumulative_completion_tokens = 0\n        self._cumulative_total_tokens = 0\n        self._log = []\n        self._tokenizer = Tokenizer(model_name)\n\n    def update_log(self, messages: List[Message], answer: str, step_name: str) -> None:\n        \"\"\"\n        Update the token usage log with the number of tokens used in the current step.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n\n------------------------------\n------------------------------\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n    serialize_messages(messages: List[Message]) -> str\n        Serialize a list of messages to a JSON string.\n    deserialize_messages(jsondictstr: str) -> List[Message]\n        Deserialize a JSON string to a list of messages.\n    _create_chat_model() -> BaseChatModel\n        Create a chat model with the specified model name and temperature.\n    \"\"\"\n\n    def __init__(\n        self,\n        model_name=\"gpt-4-turbo\",\n        temperature=0.1,\n        azure_endpoint=None,\n        streaming=True,\n        vision=False,\n    ):\n\n------------------------------\n------------------------------\n\n    Parameters\n    ----------\n    prompt : str\n        The initial prompt or question that was provided to the model.\n    model : str\n        The name of the model used for generating the response.\n    temperature : float\n        The temperature setting used in the model's response generation.\n    config : Tuple[str, ...]\n        Configuration parameters used for the learning session.\n    memory : DiskMemory\n        An instance of DiskMemory for storing and retrieving data.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n\n------------------------------\n------------------------------\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        answer : str\n            The answer from the AI.\n        step_name : str\n            The name of the step.\n        \"\"\"\n        prompt_tokens = self._tokenizer.num_tokens_from_messages(messages)\n        completion_tokens = self._tokenizer.num_tokens(answer)\n        total_tokens = prompt_tokens + completion_tokens\n\n        self._cumulative_prompt_tokens += prompt_tokens\n        self._cumulative_completion_tokens += completion_tokens\n        self._cumulative_total_tokens += total_tokens\n\n        self._log.append(\n            TokenUsage(\n\n------------------------------\n------------------------------\n    azure_endpoint : str\n        The endpoint URL for the Azure-hosted language model.\n    model_name : str\n        The name of the language model to use.\n    streaming : bool\n        A flag indicating whether to use streaming for the language model.\n    llm : BaseChatModel\n        The language model instance for conversation management.\n    token_usage_log : TokenUsageLog\n        A log for tracking token usage during conversations.\n\n    Methods\n    -------\n    start(system: str, user: str, step_name: str) -> List[Message]\n        Start the conversation with a system message and a user message.\n    next(messages: List[Message], prompt: Optional[str], step_name: str) -> List[Message]\n        Advances the conversation by sending message history to LLM and updating with the response.\n    backoff_inference(messages: List[Message]) -> Any\n        Perform inference using the language model with an exponential backoff strategy.\n    serialize_messages(messages: List[Message]) -> str\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def next(\n# Natural Language Annotations: \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef next(\n    messages: List[Message], \n    prompt: Optional[str] = None, \n    step_name: str\n) -> List[Message]:\n    \"\"\"\n    Advances the conversation by sending message history\n    to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    # Your code goes here\n```\n", "```python\ndef next(self, messages: List[Message], prompt: Optional[str]=None, step_name: str) -> List[Message]:\n    # Advances the conversation by sending message history\n    # to LLM and updating with the response.\n\n    # Serialize the messages to a JSON string\n    serialized_messages = self.serialize_messages(messages)\n\n    # Perform inference using the language model with an exponential backoff strategy\n    response = self.backoff_inference(serialized_messages)\n\n    # Deserialize the response to a list of messages\n    response_messages = self.deserialize_messages(response)\n\n    # Update the token usage log with the number of tokens used in the current step\n    self.update_log(messages, response, step_name)\n\n    # Return the updated list of messages in the conversation\n    return response_messages\n```\n", "```python\ndef next(self, messages: List[Message], prompt: Optional[str] = None, step_name: str) -> List[Message]:\n    \"\"\"\n    Advances the conversation by sending message history to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    # Convert the messages to a JSON string\n    json_str = self.serialize_messages(messages)\n\n    # Send the JSON string to the LLM and get the response\n    response = self._create_chat_model().ask(json_str, prompt=prompt)\n\n    # Update the messages with the response\n    messages.append(Message(role=\"assistant\", content=response))\n\n    # Update the token usage log\n    self.token_usage_log.update_log(messages, response, step_name)\n\n    return messages\n```\n"]}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n        file.writelines(lines)\n\n\ndef ask_yes_no(question: str) -> bool:\n    \"\"\"\n    Asks a yes/no question and returns the response as a boolean value.\n\n    Parameters\n    ----------\n    question : str\n        The yes/no question to ask.\n\n    Returns\n    -------\n    bool\n        True if the answer is 'yes', False if 'no'.\n\n    \"\"\"\n\n    while True:\n\n------------------------------\n------------------------------\n\"\"\"\nFunctions for reading and writing the `gpt-engineer.toml` configuration file.\n\nThe `gpt-engineer.toml` file is a TOML file that contains project-specific configuration used by the GPT Engineer CLI and gptengineer.app.\n\"\"\"\nfrom dataclasses import asdict, dataclass, field\nfrom pathlib import Path\n\nimport tomlkit\n\ndefault_config_filename = \"gpt-engineer.toml\"\n\nexample_config = \"\"\"\n[run]\nbuild = \"npm run build\"\ntest = \"npm run test\"\nlint = \"quick-lint-js\"\n\n[paths]\nbase = \"./frontend\"  # base directory to operate in (for monorepos)\n\n------------------------------\n------------------------------\n        self, input_path: Union[str, Path], toml_file: Union[str, Path]\n    ) -> List[str]:\n        \"\"\"\n        Retrieves a list of selected files from a .toml configuration file.\n\n        Parameters\n        ----------\n        input_path : Union[str, Path]\n            The path where file selection was performed.\n        toml_file : Union[str, Path]\n            The path to the .toml file containing the file selection.\n\n        Returns\n        -------\n        List[str]\n            A list of strings representing the paths of selected files.\n\n        Raises\n        ------\n        Exception\n\n------------------------------\n------------------------------\n\n\n\ndef read_config(config_file: Path) -> tomlkit.TOMLDocument:\n    \"\"\"Read the configuration file\"\"\"\n    assert config_file.exists(), f\"Config file {config_file} does not exist\"\n    with open(config_file, \"r\") as f:\n        return tomlkit.load(f)\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef read_config(config_file: Path) -> tomlkit.TOMLDocument:\n    \"\"\"Read the configuration file\"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_toml(self, config_file: Path | str, save=True) -> str:\n# Natural Language Annotations: \"\"\"Write the configuration to a TOML file.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef to_toml(self, config_file: Union[Path, str], save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    config = asdict(self)\n    toml_str = tomlkit.dumps(config)\n\n    if save:\n        if isinstance(config_file, str):\n            config_file = Path(config_file)\n\n        with open(config_file, \"w\") as f:\n            f.write(toml_str)\n\n    return toml_str\n```\n", "```python\nimport tomlkit\nfrom pathlib import Path\n\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    \n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n\n    if save:\n        with open(config_file, \"w\") as f:\n            tomlkit.dump(self._config, f)\n    else:\n        return tomlkit.dumps(self._config)\n```\n", "```python\ndef to_toml(self, config_file: Union[Path, str], save=True) -> str:\n    \"\"\"\n    Write the configuration to a TOML file.\n\n    Parameters\n    ----------\n    config_file : Union[Path, str]\n        The path to the TOML file where the configuration will be written.\n    save : bool, optional\n        Whether to save the configuration, by default True.\n\n    Returns\n    -------\n    str\n        A string representation of the TOML file.\n\n    \"\"\"\n    \n    # Convert config_file to Path if it's a string\n    if isinstance(config_file, str):\n        config_file = Path(config_file)\n\n    # Convert the configuration to a TOMLDocument\n    toml_document = tomlkit.document()\n    for key, value in asdict(self).items():\n        toml_document.add(tomlkit.item(key, value))\n\n    # Convert the TOMLDocument to a string\n    toml_str = tomlkit.dumps(toml_document)\n\n    # Save the TOML string to a file if save is True\n    if save:\n        with open(config_file, \"w\") as f:\n            f.write(toml_str)\n\n    return toml_str\n```\n"]}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"final_query": "# Below are some relevant code snippets for the given query:\n------------------------------\n\n    Parameters\n    ----------\n    prompt : str\n        The initial prompt or question that was provided to the model.\n    model : str\n        The name of the model used for generating the response.\n    temperature : float\n        The temperature setting used in the model's response generation.\n    config : Tuple[str, ...]\n        Configuration parameters used for the learning session.\n    memory : DiskMemory\n        An instance of DiskMemory for storing and retrieving data.\n\n    Returns\n    -------\n    None\n\n    Notes\n    -----\n\n------------------------------\n------------------------------\n        file.writelines(lines)\n\n\ndef ask_yes_no(question: str) -> bool:\n    \"\"\"\n    Asks a yes/no question and returns the response as a boolean value.\n\n    Parameters\n    ----------\n    question : str\n        The yes/no question to ask.\n\n    Returns\n    -------\n    bool\n        True if the answer is 'yes', False if 'no'.\n\n    \"\"\"\n\n    while True:\n\n------------------------------\n------------------------------\n    Parameters\n    ----------\n    path : str\n        The base path to append the metadata directory to.\n\n    Returns\n    -------\n    str\n        The full path to the metadata directory.\n    \"\"\"\n    return os.path.join(path, META_DATA_REL_PATH)\n\n------------------------------\n------------------------------\n\n        self.path.mkdir(parents=True, exist_ok=True)\n\n    def __contains__(self, key: str) -> bool:\n        \"\"\"\n        Determine whether the database contains a file with the specified key.\n\n        Parameters\n        ----------\n        key : str\n            The key (filename) to check for existence in the database.\n\n        Returns\n        -------\n        bool\n            Returns True if the file exists, False otherwise.\n\n        \"\"\"\n        return (self.path / key).is_file()\n\n\n------------------------------\n------------------------------\n\n\n\n\n\n\n\n\n\n\ndef count_ratio(str1, str2) -> float:\n    \"\"\"\n    Computes the ratio of common characters to the length of the longer string, ignoring spaces and case.\n\n    Parameters:\n    - str1, str2 (str): The strings to compare.\n\n    Returns:\n    - float: The ratio of common characters to the length of the longer string.\n    \"\"\"\n\n------------------------------\n# You are a prefessional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n# Natural Language Annotations: \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef is_similar(str1: str, str2: str, similarity_threshold: float = 0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1 = str1.replace(' ', '').lower()\n    str2 = str2.replace(' ', '').lower()\n\n    intersection = set(str1) & set(str2)\n    union = set(str1) | set(str2)\n\n    ratio = len(intersection) / len(union) if union else 0\n\n    return ratio >= similarity_threshold\n```\n", "```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n\n    # Remove spaces and convert to lower case\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n\n    # Compute the similarity ratio\n    similarity_ratio = count_ratio(str1, str2)\n\n    # Check if the similarity ratio is above the threshold\n    return similarity_ratio > similarity_threshold\n```\n", "```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    # Normalize the strings\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n\n    # Compute the similarity ratio\n    similarity_ratio = count_ratio(str1, str2)\n\n    # Check the similarity ratio against the threshold\n    return similarity_ratio >= similarity_threshold\n```\n"]}}