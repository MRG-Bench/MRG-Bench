{"langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"The specified path is not a directory\");\n    }\n    List<Document> documents = new ArrayList<>();\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path filePath : stream) {\n            try {\n                Document document = documentParser.parse(filePath);\n                documents.add(document);\n            } catch (IOException | ParseException e) {\n                // skip any files that fail to load\n            }\n        }\n    } catch (IOException e) {\n        throw new IllegalArgumentException(\"Failed to read directory\", e);\n    }\n    return documents;\n}\n```", "  ```\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path file : stream) {\n            try {\n                Document document = documentParser.parse(Files.newInputStream(file));\n                documents.add(document);\n            } catch (IOException | ParseException e) {\n                // skip any documents that fail to load\n            }\n        }\n    } catch (IOException e) {\n        // handle any errors that occur while reading the directory\n    }\n\n    return documents;\n}\n```", "  ```\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory\");\n    }\n    List<Document> documents = new ArrayList<>();\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path filePath : stream) {\n            try {\n                Document document = documentParser.parse(Files.readString(filePath));\n                documents.add(document);\n            } catch (IOException e) {\n                // Skip the file if it fails to load\n            }\n        }\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n    return documents;\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n    try (DirectoryStream<Path> stream = Files.newDirectoryStream(directoryPath)) {\n        for (Path path : stream) {\n            if (Files.isDirectory(path)) {\n                documents.addAll(loadDocumentsRecursively(path, documentParser));\n            } else {\n                try {\n                    documents.add(documentParser.parse(path));\n                } catch (IOException e) {\n                    System.err.println(\"Failed to load document from \" + path);\n                }\n            }\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n\n    return documents;\n}\n```", "  ```\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory\");\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (Stream<Path> paths = Files.walk(directoryPath)) {\n        paths.forEach(path -> {\n            if (Files.isRegularFile(path)) {\n                try {\n                    Document document = documentParser.parse(path);\n                    documents.add(document);\n                } catch (IOException e) {\n                    // skip any files that fail to load\n                }\n            }\n        });\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n\n    return documents;\n}\n```", "  ```\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!Files.isDirectory(directoryPath)) {\n        throw new IllegalArgumentException(\"Specified path is not a directory\");\n    }\n    List<Document> documents = new ArrayList<>();\n    try {\n        Files.walkFileTree(directoryPath, new SimpleFileVisitor<Path>() {\n            @Override\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) {\n                try {\n                    Document document = documentParser.parse(file);\n                    documents.add(document);\n                } catch (Exception e) {\n                    // Ignore any documents that fail to load\n                }\n                return FileVisitResult.CONTINUE;\n            }\n        });\n    } catch (IOException e) {\n        throw new UncheckedIOException(e);\n    }\n    return documents;\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public boolean hasSpaceFor(String text) {\n# Natural Language Annotations: /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic boolean hasSpaceFor(String text) {\n    return true;\n}\n```", "  ```\npublic boolean hasSpaceFor(String text) {\n    return true;\n}\n```", "  ```\npublic boolean hasSpaceFor(String text) {\n    return true;\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void append(String text) {\n# Natural Language Annotations: /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void append(String text) {\n    // Append the provided text to the current segment\n    currentSegment.append(text);\n}\n```", "  ```\npublic void append(String text) {\n    currentSegment += text;\n}\n```", "  ```\npublic void append(String text) {\n    segment.append(text);\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void prepend(String text) {\n# Natural Language Annotations: /**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void prepend(String text) {\n    text = text + this.text;\n    this.text = text;\n}\n```", "  ```\npublic void prepend(String text) {\n    text = text + currentSegment;\n    currentSegment = text;\n}\n```", "  ```\npublic void prepend(String text) {\n    segment.insert(0, text);\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public AiServices<T> retriever(Retriever<TextSegment> retriever) {\n# Natural Language Annotations: /**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    return new AiServices<T>(retriever);\n}\n```", "  ```\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    this.retriever = retriever;\n    return this;\n}\n```", "  ```\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    return contentRetriever(new EmbeddingStoreContentRetriever(retriever));\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n# Natural Language Annotations: /**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n     * a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    return new AiServices<T>(new DefaultRetrievalAugmentor(contentRetriever));\n}\n```", "  ```\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    return new AiServices<T>()\n        .retrievalAugmentor(new DefaultRetrievalAugmentor(contentRetriever));\n}\n```", "  ```\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    return new AiServices<T>(new DefaultRetrievalAugmentor(contentRetriever));\n}\n```"]}, "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public String add(Embedding embedding) {\n# Natural Language Annotations: /**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic String add(Embedding embedding) {\n    // Add the embedding to the store\n    // ...\n    // Generate an auto-generated ID for the added embedding\n    String id = generateId();\n    // Return the ID\n    return id;\n}\n```", "  ```\npublic String add(Embedding embedding) {\n    // Add the embedding to the store\n    return \"auto-generated ID\";\n}\n```", "  ```\npublic String add(Embedding embedding) {\n    return store.add(embedding);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n# Natural Language Annotations: /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            ToolSpecification spec = new ToolSpecification();\n            spec.setMethod(method);\n            spec.setTool(method.getAnnotation(Tool.class));\n            toolSpecifications.add(spec);\n        }\n    }\n    return toolSpecifications;\n}\n```", "  ```\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            toolSpecifications.add(new ToolSpecification(method));\n        }\n    }\n    return toolSpecifications;\n}\n```", "  ```\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            Tool toolAnnotation = method.getAnnotation(Tool.class);\n            ToolSpecification toolSpecification = new ToolSpecification();\n            toolSpecification.setName(toolAnnotation.name());\n            toolSpecification.setDescription(toolAnnotation.description());\n            toolSpecification.setInputs(toolAnnotation.inputs());\n            toolSpecification.setOutputs(toolAnnotation.outputs());\n            toolSpecifications.add(toolSpecification);\n        }\n    }\n    return toolSpecifications;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ToolSpecification toolSpecificationFrom(Method method) {\n# Natural Language Annotations: /**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    if (toolAnnotation == null) {\n        return null;\n    }\n    return new ToolSpecification(toolAnnotation.name(), toolAnnotation.description());\n}\n```", "  ```\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    Tool tool = method.getAnnotation(Tool.class);\n    return new ToolSpecification(tool.name(), tool.version());\n}\n```", "  ```\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    if (toolAnnotation == null) {\n        return null;\n    }\n    ToolSpecification toolSpecification = new ToolSpecification();\n    toolSpecification.setName(toolAnnotation.name());\n    toolSpecification.setDescription(toolAnnotation.description());\n    toolSpecification.setVersion(toolAnnotation.version());\n    return toolSpecification;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n# Natural Language Annotations: /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    List<JsonSchemaProperty> properties = new ArrayList<>();\n    properties.add(new JsonSchemaProperty(parameter.getName(), parameter.getType()));\n    return properties;\n}\n```", "  ```\nreturn Arrays.asList(new JsonSchemaProperty(parameter.getName(), parameter.getType()));\n```", "  ```\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    return parameter.getType().getProperties().stream()\n            .map(property -> new JsonSchemaProperty(property.getName(), property.getType()))\n            .collect(Collectors.toList());\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double between(Embedding embeddingA, Embedding embeddingB) {\n# Natural Language Annotations: /**\n     * Calculates cosine similarity between two vectors.\n     * <p>\n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0.0;\n    double magnitudeA = 0.0;\n    double magnitudeB = 0.0;\n    for (int i = 0; i < embeddingA.length; i++) {\n        dotProduct += embeddingA[i] * embeddingB[i];\n        magnitudeA += embeddingA[i] * embeddingA[i];\n        magnitudeB += embeddingB[i] * embeddingB[i];\n    }\n    return dotProduct / (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));\n}\n```", "  ```\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0;\n    double normA = 0;\n    double normB = 0;\n\n    for (int i = 0; i < embeddingA.length; i++) {\n        dotProduct += embeddingA[i] * embeddingB[i];\n        normA += embeddingA[i] * embeddingA[i];\n        normB += embeddingB[i] * embeddingB[i];\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n}\n```", "  ```\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = 0;\n    double magnitudeA = 0;\n    double magnitudeB = 0;\n\n    for (int i = 0; i < embeddingA.length; i++) {\n        dotProduct += embeddingA[i] * embeddingB[i];\n        magnitudeA += embeddingA[i] * embeddingA[i];\n        magnitudeB += embeddingB[i] * embeddingB[i];\n    }\n\n    return dotProduct / (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public Map<String, String> asMap() {\n# Natural Language Annotations: /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic Map<String, String> asMap() {\n    return toMap();\n}\n```", "  ```\n@Deprecated\npublic Map<String, String> asMap() {\n    return toMap();\n}\n```", "  ```\n@Deprecated\npublic Map<String, String> asMap() {\n    return new HashMap<>(this.toMap());\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Document load(DocumentSource source, DocumentParser parser) {\n# Natural Language Annotations: /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source);\n    document.setMetadata(source.getMetadata());\n    return document;\n}\n```", "  ```\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source);\n    document.setMetadata(source.getMetadata());\n    return document;\n}\n```", "  ```\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source.getInputStream());\n    document.setMetadata(source.getMetadata());\n    return document;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String singleText() {\n# Natural Language Annotations: /**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic String singleText() {\n    if (hasSingleText()) {\n        return contents.get(0).getText();\n    } else {\n        throw new RuntimeException(\"Message does not contain a single text\");\n    }\n}\n```", "  ```\npublic String singleText() {\n    if (contents.size() != 1) {\n        throw new RuntimeException(\"Message contains multiple contents or only one content is not a TextContent\");\n    }\n    return contents.get(0).getText();\n}\n```", "  ```\npublic String singleText() {\n    if (contents.size() != 1) {\n        throw new RuntimeException(\"Message contains multiple contents\");\n    }\n    if (!(contents.get(0) instanceof TextContent)) {\n        throw new RuntimeException(\"Content is not a TextContent\");\n    }\n    return ((TextContent)contents.get(0)).getContent();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default AugmentationResult augment(AugmentationRequest augmentationRequest) {\n# Natural Language Annotations: /**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n     * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nAugmentationResult augment(AugmentationRequest augmentationRequest) {\n    ChatMessage chatMessage = augmentationRequest.getChatMessage();\n    Content[] retrievedContents = retrieveContents(chatMessage);\n    AugmentationResult augmentationResult = new AugmentationResult(chatMessage);\n    for (Content content : retrievedContents) {\n        augmentationResult.addContent(content);\n    }\n    return augmentationResult;\n}\n```", "  ```\npublic class AugmentationResult {\n    private ChatMessage augmentedMessage;\n\n    public AugmentationResult(ChatMessage augmentedMessage) {\n        this.augmentedMessage = augmentedMessage;\n    }\n\n    public ChatMessage getAugmentedMessage() {\n        return augmentedMessage;\n    }\n}\n\npublic class AugmentationRequest {\n    private ChatMessage message;\n\n    public AugmentationRequest(ChatMessage message) {\n        this.message = message;\n    }\n\n    public ChatMessage getMessage() {\n        return message;\n    }\n}\n\npublic class Content {\n    private String text;\n\n    public Content(String text) {\n        this.text = text;\n    }\n\n    public String getText() {\n        return text;\n    }\n}\n\npublic class ChatMessage {\n    private String text;\n    private List<Content> contents;\n\n    public ChatMessage(String text) {\n        this.text = text;\n        this.contents = new ArrayList<>();\n    }\n\n    public void addContent(Content content) {\n        contents.add(content);\n    }\n\n    public String getText() {\n        return text;\n    }\n\n    public List<Content> getContents() {\n        return contents;\n    }\n}\n\npublic class RetrievalAugmentor {\n    public AugmentationResult augment(AugmentationRequest augmentationRequest) {\n        ChatMessage message = augmentationRequest.getMessage();\n        List<Content> contents = new ArrayList<>();\n        contents.add(new Content(\"This is a new content\"));\n        message.addContent(contents.get(0));\n        return new AugmentationResult(message);\n    }\n}\n```", "  ```\nAugmentationResult augment(AugmentationRequest augmentationRequest) {\n    ChatMessage chatMessage = augmentationRequest.getChatMessage();\n    Content content = retrieveContent(chatMessage);\n    if (content != null) {\n        chatMessage.setContent(content);\n    }\n    return new AugmentationResult(chatMessage);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    @Deprecated    public UserMessage augment(UserMessage userMessage, Metadata metadata) {\n# Natural Language Annotations: /**\n     * @deprecated use {@link #augment(AugmentationRequest)} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    return augment(new AugmentationRequest(userMessage, metadata));\n}\n```", "  ```\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    return augment(new AugmentationRequest(userMessage, metadata));\n}\n```", "  ```\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    return this.augment(userMessage, metadata);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n# Natural Language Annotations: /**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n     *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    if (contents == null || contents.isEmpty()) {\n        return chatMessage;\n    }\n    if (chatMessage instanceof UserMessage) {\n        UserMessage userMessage = (UserMessage) chatMessage;\n        userMessage.getContents().addAll(contents);\n    } else if (chatMessage instanceof SystemMessage) {\n        SystemMessage systemMessage = (SystemMessage) chatMessage;\n        systemMessage.getContents().addAll(contents);\n    }\n    return chatMessage;\n}\n```", "  ```\npublic ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    // Default implementation\n    if (chatMessage instanceof UserMessage) {\n        UserMessage userMessage = (UserMessage) chatMessage;\n        userMessage.getContents().addAll(contents);\n        return userMessage;\n    } else if (chatMessage instanceof SystemMessage) {\n        SystemMessage systemMessage = (SystemMessage) chatMessage;\n        systemMessage.getContents().addAll(contents);\n        return systemMessage;\n    }\n    return null;\n}\n```", "  ```\npublic static ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    if (contents == null || contents.isEmpty()) {\n        return chatMessage;\n    }\n    if (chatMessage instanceof UserMessage) {\n        return inject((UserMessage) chatMessage, contents);\n    } else if (chatMessage instanceof SystemMessage) {\n        return inject((SystemMessage) chatMessage, contents);\n    } else {\n        throw new UnsupportedOperationException(\"Unsupported ChatMessage type: \" + chatMessage.getClass().getName());\n    }\n}\n\nprivate static UserMessage inject(UserMessage userMessage, List<Content> contents) {\n    // Inject contents into the UserMessage\n    return userMessage;\n}\n\nprivate static SystemMessage inject(SystemMessage systemMessage, List<Content> contents) {\n    // Inject contents into the SystemMessage\n    return systemMessage;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static boolean areNotNullOrBlank(String... strings) {\n# Natural Language Annotations: /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String str : strings) {\n        if (str == null || str.trim().isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "  ```\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (string == null || string.isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "  ```\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String str : strings) {\n        if (str == null || str.trim().isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String generateUUIDFrom(String input) {\n# Natural Language Annotations: /**\n   * Generates a UUID from a hash of the given input string.\n   * @param input The input string.\n   * @return A UUID.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static String generateUUIDFrom(String input) {\n    return UUID.nameUUIDFromBytes(input.getBytes()).toString();\n}\n```", "  ```\npublic static String generateUUIDFrom(String input) {\n    return UUID.nameUUIDFromBytes(input.getBytes()).toString();\n}\n```", "  ```\npublic static String generateUUIDFrom(String input) {\n    return UUID.nameUUIDFromBytes(input.getBytes()).toString();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static byte[] readBytes(String url) {\n# Natural Language Annotations: /**\n   * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n   * and from files stored on the local filesystem.\n   *\n   * @param url The URL to read from.\n   * @return The content as bytes.\n   * @throws RuntimeException if the request fails.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        HttpURLConnection conn = (HttpURLConnection) urlObj.openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.connect();\n        InputStream in = conn.getInputStream();\n        byte[] bytes = new byte[1024];\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        int n;\n        while ((n = in.read(bytes)) != -1) {\n            out.write(bytes, 0, n);\n        }\n        return out.toByteArray();\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```", "  ```\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setConnectTimeout(5000);\n        connection.setReadTimeout(5000);\n        connection.connect();\n        InputStream inputStream = connection.getInputStream();\n        return inputStreamToByteArray(inputStream);\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to read bytes from URL\", e);\n    }\n}\n\nprivate static byte[] inputStreamToByteArray(InputStream inputStream) throws IOException {\n    ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n    byte[] buffer = new byte[1024];\n    int bytesRead;\n    while ((bytesRead = inputStream.read(buffer)) != -1) {\n        outputStream.write(buffer, 0, bytesRead);\n    }\n    return outputStream.toByteArray();\n}\n```", "  ```\npublic static byte[] readBytes(String url) {\n    try {\n        URLConnection conn = new URL(url).openConnection();\n        conn.setRequestMethod(\"GET\");\n        conn.connect();\n        InputStream is = conn.getInputStream();\n        byte[] bytes = IOUtils.toByteArray(is);\n        is.close();\n        return bytes;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int jitterDelayMillis(int attempt) {\n# Natural Language Annotations: /**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic int jitterDelayMillis(int attempt) {\n    return (int) (Math.random() * 1000) + 1000;\n}\n```", "  ```\npublic int jitterDelayMillis(int attempt) {\n    return (int) (Math.random() * 1000);\n}\n```", "  ```\npublic int jitterDelayMillis(int attempt) {\n    return (int) (Math.random() * Math.pow(2, attempt - 1) * 1000);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static IKeyGenerator getKeyGenerator(String name) {\n# Natural Language Annotations: /**\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static IKeyGenerator getKeyGenerator(String name) {\n    // \u83b7\u53d6\u4e3b\u952e\u751f\u6210\u5668\n    IKeyGenerator keyGenerator = new KeyGenerator();\n    keyGenerator.setName(name);\n    return keyGenerator;\n}\n```", "  ```\npublic static IKeyGenerator getKeyGenerator(String name) {\n    if (name.equals(\"primary\")) {\n        return new PrimaryKeyGenerator();\n    } else if (name.equals(\"foreign\")) {\n        return new ForeignKeyGenerator();\n    } else {\n        throw new IllegalArgumentException(\"Invalid key generator name: \" + name);\n    }\n}\n```", "  ```\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return new DefaultKeyGenerator(name);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public QueryCondition when(boolean effective) {\n# Natural Language Annotations: /**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic QueryCondition when(boolean effective) {\n    return new QueryCondition(effective);\n}\n```", "  ```\npublic QueryCondition when(boolean effective) {\n    return new QueryCondition(effective);\n}\n```", "  ```\npublic QueryCondition when(boolean effective) {\n    return new QueryCondition(effective);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String methodToProperty(String name) {\n# Natural Language Annotations: /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\") && name.length() > 2) {\n        return name.substring(2, 3).toLowerCase() + name.substring(3);\n    } else if (name.startsWith(\"get\") && name.length() > 3) {\n        return name.substring(3, 4).toLowerCase() + name.substring(4);\n    } else if (name.startsWith(\"set\") && name.length() > 3) {\n        return name.substring(3, 4).toLowerCase() + name.substring(4);\n    } else {\n        return name;\n    }\n}\n```", "  ```\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"get\") || name.startsWith(\"is\")) {\n        return name.substring(3, 4).toLowerCase() + name.substring(4);\n    } else if (name.startsWith(\"set\")) {\n        return name.substring(3, 4).toLowerCase() + name.substring(4);\n    } else {\n        return name;\n    }\n}\n```", "  ```\npublic static String methodToProperty(String name) {\n    return name.substring(3, name.length() - 2);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String camelToUnderline(String string) {\n# Natural Language Annotations: /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static String camelToUnderline(String string) {\n    return string.replaceAll(\"([A-Z])\", \"_$1\").toLowerCase();\n}\n```", "  ```\npublic static String camelToUnderline(String string) {\n    return string.replaceAll(\"([A-Z])\", \"_$1\").toLowerCase();\n}\n```", "  ```\npublic static String camelToUnderline(String string) {\n    return string.replaceAll(\"([A-Z])\", \"_$1\").toUpperCase();\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String underlineToCamel(String string) {\n# Natural Language Annotations: /**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static String underlineToCamel(String string) {\n    return string.replaceAll(\"_([a-z])\", (m) -> m.group(1).toUpperCase());\n}\n```", "  ```\npublic static String underlineToCamel(String string) {\n    return string.replaceAll(\"_\", \"\").toLowerCase();\n}\n```", "  ```\npublic static String underlineToCamel(String string) {\n    return string.replaceAll(\"_\", \"\").toLowerCase();\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n# Natural Language Annotations: /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        concurrentHashMap.putIfAbsent(key, value);\n    }\n    return value;\n}\n```", "  ```\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        concurrentHashMap.putIfAbsent(key, value);\n    }\n    return value;\n}\n```", "  ```\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    // \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n    if (concurrentHashMap instanceof ConcurrentHashMap) {\n        return ((ConcurrentHashMap<K, V>) concurrentHashMap).computeIfAbsent(key, mappingFunction);\n    } else {\n        return computeIfAbsentFallback(concurrentHashMap, key, mappingFunction);\n    }\n}\n\nprivate static <K, V> V computeIfAbsentFallback(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        concurrentHashMap.putIfAbsent(key, value);\n    }\n    return value;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n# Natural Language Annotations: /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        map.put(key, value);\n    }\n    return value;\n}\n```", "  ```\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        map.put(key, value);\n    }\n    return value;\n}\n```", "  ```\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        map.put(key, value);\n    }\n    return value;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    return new BaseMapper<E>(entityClass);\n}\n```", "  ```\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    return new BaseMapper<>(entityClass);\n}\n```", "  ```\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    return new BaseMapper<E>(entityClass);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <M> M ofMapperClass(Class<M> mapperClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return new MapperProxy<>(mapperClass).getMapper();\n}\n```", "  ```\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return (M) Proxy.newProxyInstance(mapperClass.getClassLoader(), new Class[] { mapperClass }, new InvocationHandler() {\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            // Implement the logic to invoke the method on the mapper class\n            // and return the result\n        }\n    });\n}\n```", "  ```\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return (M) Proxy.newProxyInstance(mapperClass.getClassLoader(), new Class<?>[] { mapperClass }, new InvocationHandler() {\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            // \u83b7\u53d6\u65b9\u6cd5\u7684\u540d\u79f0\n            String methodName = method.getName();\n            // \u83b7\u53d6\u65b9\u6cd5\u7684\u53c2\u6570\n            Object[] params = args;\n            // \u6267\u884c\u65b9\u6cd5\n            Object result = method.invoke(proxy, args);\n            return result;\n        }\n    });\n}\n```"]}, "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n# Natural Language Annotations: /**\n\t * Streams the audio response for the given speech prompt.\n\t * @param speechPrompt The speech prompt containing the text and options for speech\n\t * synthesis.\n\t * @return A Flux of SpeechResponse objects containing the streamed audio and\n\t * metadata.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nreturn new Flux<SpeechResponse>() {\n    @Override\n    public void subscribe(CoreSubscriber<? super SpeechResponse> subscriber) {\n        // TODO: Implement the stream logic\n    }\n};\n```", "  ```\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    return Flux.just(speechPrompt)\n              .map(this::convertTextToSpeech)\n              .map(this::addMetadata)\n              .flatMap(this::streamAudio)\n              .map(this::addAudioMetadata);\n}\n```", "  ```\nreturn Flux.just(speechPrompt)\n\t.flatMap(this::synthesizeSpeech)\n\t.flatMap(this::streamAudio);\n```"]}, "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n# Natural Language Annotations: /**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n  PostgresMlEmbeddingOptions mergedOptions = new PostgresMlEmbeddingOptions();\n  mergedOptions.setModelName(requestOptions.getModelName());\n  mergedOptions.setBatchSize(requestOptions.getBatchSize());\n  mergedOptions.setNumThreads(requestOptions.getNumThreads());\n  mergedOptions.setOptimizer(requestOptions.getOptimizer());\n  mergedOptions.setLearningRate(requestOptions.getLearningRate());\n  mergedOptions.setLossFunction(requestOptions.getLossFunction());\n  mergedOptions.setMetrics(requestOptions.getMetrics());\n  mergedOptions.setEpochs(requestOptions.getEpochs());\n  return mergedOptions;\n}\n```", "  ```\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions mergedOptions = new PostgresMlEmbeddingOptions();\n    mergedOptions.setInputCol(requestOptions.getInputCol());\n    mergedOptions.setOutputCol(requestOptions.getOutputCol());\n    mergedOptions.setDimensions(requestOptions.getDimensions());\n    mergedOptions.setMaxIterations(requestOptions.getMaxIterations());\n    mergedOptions.setRegParam(requestOptions.getRegParam());\n    return mergedOptions;\n}\n```", "  ```\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions mergedOptions = new PostgresMlEmbeddingOptions();\n    mergedOptions.setEmbeddingDimension(requestOptions.getEmbeddingDimension());\n    mergedOptions.setNumNeighbors(requestOptions.getNumNeighbors());\n    mergedOptions.setNumWalks(requestOptions.getNumWalks());\n    mergedOptions.setWalkLength(requestOptions.getWalkLength());\n    mergedOptions.setRandomWalk(requestOptions.getRandomWalk());\n    mergedOptions.setNumThreads(requestOptions.getNumThreads());\n    mergedOptions.setNumIterations(requestOptions.getNumIterations());\n    mergedOptions.setLearningRate(requestOptions.getLearningRate());\n    mergedOptions.setEarlyStopping(requestOptions.getEarlyStopping());\n    mergedOptions.setMinImprovement(requestOptions.getMinImprovement());\n    mergedOptions.setMaxEpochs(requestOptions.getMaxEpochs());\n    mergedOptions.setBatchSize(requestOptions.getBatchSize());\n    mergedOptions.setShuffle(requestOptions.getShuffle());\n    return mergedOptions;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n# Natural Language Annotations: /**\n\t * Return the dimension of the requested embedding generative name. If the generative\n\t * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n\t * count the response dimensions.\n\t * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n\t * @param modelName Embedding generative name to retrieve the dimensions for.\n\t * @param dummyContent Dummy content to use for the empirical dimension calculation.\n\t * @return Returns the embedding dimensions for the modelName.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n\tif (modelName.equals(\"word2vec\")) {\n\t\treturn 100;\n\t} else if (modelName.equals(\"glove\")) {\n\t\treturn 50;\n\t} else {\n\t\treturn embeddingModel.embed(dummyContent).length;\n\t}\n}\n```", "  ```\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (modelName.equals(\"word2vec\")) {\n        return 300;\n    } else if (modelName.equals(\"glove\")) {\n        return 100;\n    } else {\n        return embeddingModel.embed(dummyContent).size();\n    }\n}\n```", "  ```\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (modelName.equals(\"dummy\")) {\n        return embeddingModel.embed(dummyContent).size();\n    }\n    return -1;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n# Natural Language Annotations: /**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index must be greater than or equal to 0\");\n    }\n    return Optional.ofNullable(promptFilters.get(promptIndex));\n}\n```", "  ```\npublic Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index must be non-negative\");\n    }\n    return promptIndex < promptFilterMetadatas.size() ? Optional.of(promptFilterMetadatas.get(promptIndex)) : Optional.empty();\n}\n```", "  ```\nOptional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index cannot be less than 0\");\n    }\n    return Optional.ofNullable(promptFilters.get(promptIndex));\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Long getTotalTokens() {\n# Natural Language Annotations: /**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```", "  ```\npublic Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```", "  ```\npublic long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Filter.Operand negate(Filter.Operand operand) {\n# Natural Language Annotations: /**\n\t * Transforms the input expression into a semantically equivalent one with negation\n\t * operators propagated thought the expression tree by following the negation rules:\n\t *\n\t * <pre>\n\t * \tNOT(NOT(a)) = a\n\t *\n\t * \tNOT(a AND b) = NOT(a) OR NOT(b)\n\t * \tNOT(a OR b) = NOT(a) AND NOT(b)\n\t *\n\t * \tNOT(a EQ b) = a NE b\n\t * \tNOT(a NE b) = a EQ b\n\t *\n\t * \tNOT(a GT b) = a LTE b\n\t * \tNOT(a GTE b) = a LT b\n\t *\n\t * \tNOT(a LT b) = a GTE b\n\t * \tNOT(a LTE b) = a GT b\n\t *\n\t * \tNOT(a IN [...]) = a NIN [...]\n\t * \tNOT(a NIN [...]) = a IN [...]\n\t * </pre>\n\t * @param operand Filter expression to negate.\n\t * @return Returns an negation of the input expression.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static Filter.Operand negate(Filter.Operand operand) {\n    switch (operand.operator) {\n        case NOT:\n            return operand.operands[0];\n        case AND:\n            return new Filter.Operand(NOT, negate(operand.operands[0]), negate(operand.operands[1]));\n        case OR:\n            return new Filter.Operand(NOT, negate(operand.operands[0]), negate(operand.operands[1]));\n        case EQ:\n            return new Filter.Operand(NE, operand.operands[0], operand.operands[1]);\n        case NE:\n            return new Filter.Operand(EQ, operand.operands[0], operand.operands[1]);\n        case GT:\n            return new Filter.Operand(LTE, operand.operands[0], operand.operands[1]);\n        case GTE:\n            return new Filter.Operand(LT, operand.operands[0], operand.operands[1]);\n        case LT:\n            return new Filter.Operand(GTE, operand.operands[0], operand.operands[1]);\n        case LTE:\n            return new Filter.Operand(GT, operand.operands[0], operand.operands[1]);\n        case IN:\n            return new Filter.Operand(NIN, operand.operands[0], operand.operands[1]);\n        case NIN:\n            return new Filter.Operand(IN, operand.operands[0], operand.operands[1]);\n        default:\n            throw new IllegalArgumentException(\"Unsupported operator: \" + operand.operator);\n    }\n}\n```", "  ```\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Not) {\n        return ((Not) operand).getOperand();\n    }\n    if (operand instanceof And) {\n        return new Or(negate(((And) operand).getLeft()), negate(((And) operand).getRight()));\n    }\n    if (operand instanceof Or) {\n        return new And(negate(((Or) operand).getLeft()), negate(((Or) operand).getRight()));\n    }\n    if (operand instanceof Equals) {\n        return new NotEquals(((Equals) operand).getLeft(), ((Equals) operand).getRight());\n    }\n    if (operand instanceof NotEquals) {\n        return new Equals(((NotEquals) operand).getLeft(), ((NotEquals) operand).getRight());\n    }\n    if (operand instanceof GreaterThan) {\n        return new LessThanOrEqual(((GreaterThan) operand).getLeft(), ((GreaterThan) operand).getRight());\n    }\n    if (operand instanceof GreaterThanOrEqual) {\n        return new LessThan(((GreaterThanOrEqual) operand).getLeft(), ((GreaterThanOrEqual) operand).getRight());\n    }\n    if (operand instanceof LessThan) {\n        return new GreaterThanOrEqual(((LessThan) operand).getLeft(), ((LessThan) operand).getRight());\n    }\n    if (operand instanceof LessThanOrEqual) {\n        return new GreaterThan(((LessThanOrEqual) operand).getLeft(), ((LessThanOrEqual) operand).getRight());\n    }\n    if (operand instanceof In) {\n        return new NotIn(((In) operand).getLeft(), ((In) operand).getRight());\n    }\n    if (operand instanceof NotIn) {\n        return new In(((NotIn) operand).getLeft(), ((NotIn) operand).getRight());\n    }\n    throw new IllegalArgumentException(\"Invalid operand type: \" + operand.getClass());\n}\n```", "  ```\npublic static Filter.Operand negate(Filter.Operand operand) {\n    Filter.Operand result = operand;\n    if (operand instanceof Filter.And) {\n        Filter.And and = (Filter.And) operand;\n        result = new Filter.Or(negate(and.getLeft()), negate(and.getRight()));\n    } else if (operand instanceof Filter.Or) {\n        Filter.Or or = (Filter.Or) operand;\n        result = new Filter.And(negate(or.getLeft()), negate(or.getRight()));\n    } else if (operand instanceof Filter.Eq) {\n        Filter.Eq eq = (Filter.Eq) operand;\n        result = new Filter.Ne(eq.getLeft(), eq.getRight());\n    } else if (operand instanceof Filter.Ne) {\n        Filter.Ne ne = (Filter.Ne) operand;\n        result = new Filter.Eq(ne.getLeft(), ne.getRight());\n    } else if (operand instanceof Filter.Gt) {\n        Filter.Gt gt = (Filter.Gt) operand;\n        result = new Filter.Lte(gt.getLeft(), gt.getRight());\n    } else if (operand instanceof Filter.Gte) {\n        Filter.Gte gte = (Filter.Gte) operand;\n        result = new Filter.Lt(gte.getLeft(), gte.getRight());\n    } else if (operand instanceof Filter.Lt) {\n        Filter.Lt lt = (Filter.Lt) operand;\n        result = new Filter.Gte(lt.getLeft(), lt.getRight());\n    } else if (operand instanceof Filter.Lte) {\n        Filter.Lte lte = (Filter.Lte) operand;\n        result = new Filter.Gt(lte.getLeft(), lte.getRight());\n    } else if (operand instanceof Filter.In) {\n        Filter.In in = (Filter.In) operand;\n        result = new Filter.Nin(in.getLeft(), in.getRight());\n    } else if (operand instanceof Filter.Nin) {\n        Filter.Nin nin = (Filter.Nin) operand;\n        result = new Filter.In(nin.getLeft(), nin.getRight());\n    }\n    return result;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n\t * empty, use the {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @param acceptedFieldNames the list of field names accepted for the target object.\n\t * @return the merged object represented by the given class.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    if (source == null || target == null || clazz == null) {\n        throw new IllegalArgumentException(\"Source, target, and clazz must not be null\");\n    }\n\n    if (acceptedFieldNames == null) {\n        acceptedFieldNames = new ArrayList<>();\n    }\n\n    T merged = clazz.newInstance();\n\n    for (Field field : clazz.getDeclaredFields()) {\n        String fieldName = field.getName();\n        if (acceptedFieldNames.isEmpty() || acceptedFieldNames.contains(fieldName)) {\n            try {\n                Object sourceValue = field.get(source);\n                if (sourceValue != null) {\n                    field.set(merged, sourceValue);\n                }\n            } catch (IllegalAccessException e) {\n                throw new IllegalStateException(\"Failed to access field \" + fieldName, e);\n            }\n        }\n    }\n\n    return merged;\n}\n```", "  ```\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    if (source == null || target == null || clazz == null) {\n        throw new IllegalArgumentException(\"Source, target, and clazz must not be null\");\n    }\n    if (acceptedFieldNames == null) {\n        acceptedFieldNames = new ArrayList<>();\n    }\n    T result = null;\n    try {\n        result = clazz.newInstance();\n    } catch (InstantiationException | IllegalAccessException e) {\n        throw new RuntimeException(\"Failed to create instance of \" + clazz.getName(), e);\n    }\n    for (Field field : clazz.getDeclaredFields()) {\n        String fieldName = field.getName();\n        if (acceptedFieldNames.isEmpty() || acceptedFieldNames.contains(fieldName)) {\n            Object sourceValue = getFieldValue(source, fieldName);\n            Object targetValue = getFieldValue(target, fieldName);\n            if (sourceValue != null) {\n                setFieldValue(result, fieldName, sourceValue);\n            } else if (targetValue != null) {\n                setFieldValue(result, fieldName, targetValue);\n            }\n        }\n    }\n    return result;\n}\n\nprivate static Object getFieldValue(Object object, String fieldName) {\n    try {\n        Field field = object.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        return field.get(object);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        throw new RuntimeException(\"Failed to get field \" + fieldName + \" from \" + object, e);\n    }\n}\n\nprivate static void setFieldValue(Object object, String fieldName, Object value) {\n    try {\n        Field field = object.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(object, value);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        throw new RuntimeException(\"Failed to set field \" + fieldName + \" on \" + object, e);\n    }\n}\n```", "  ```\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    T result = null;\n    if (source != null && target != null && clazz != null) {\n        result = clazz.getConstructor().newInstance();\n        for (Field field : clazz.getDeclaredFields()) {\n            String fieldName = field.getName();\n            if (acceptedFieldNames.isEmpty() || acceptedFieldNames.contains(fieldName)) {\n                Object sourceValue = getFieldValue(source, fieldName);\n                Object targetValue = getFieldValue(target, fieldName);\n                if (sourceValue != null) {\n                    setFieldValue(result, fieldName, sourceValue);\n                } else if (targetValue != null) {\n                    setFieldValue(result, fieldName, targetValue);\n                }\n            }\n        }\n    }\n    return result;\n}\n\nprivate static Object getFieldValue(Object object, String fieldName) {\n    try {\n        Field field = object.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        return field.get(object);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        return null;\n    }\n}\n\nprivate static void setFieldValue(Object object, String fieldName, Object value) {\n    try {\n        Field field = object.getClass().getDeclaredField(fieldName);\n        field.setAccessible(true);\n        field.set(object, value);\n    } catch (NoSuchFieldException | IllegalAccessException e) {\n        // ignore\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<String, Object> objectToMap(Object source) {\n# Natural Language Annotations: /**\n\t * Converts the given object to a Map.\n\t * @param source the object to convert to a Map.\n\t * @return the converted Map.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static Map<String, Object> objectToMap(Object source) {\n    Map<String, Object> map = new HashMap<>();\n    if (source == null) {\n        return map;\n    }\n    for (Field field : source.getClass().getDeclaredFields()) {\n        field.setAccessible(true);\n        map.put(field.getName(), field.get(source));\n    }\n    return map;\n}\n```", "  ```\npublic static Map<String, Object> objectToMap(Object source) {\n    Map<String, Object> map = new HashMap<>();\n    for (Field field : source.getClass().getDeclaredFields()) {\n        field.setAccessible(true);\n        try {\n            map.put(field.getName(), field.get(source));\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n    return map;\n}\n```", "  ```\npublic static Map<String, Object> objectToMap(Object source) {\n    Map<String, Object> map = new HashMap<>();\n    for (Field field : source.getClass().getDeclaredFields()) {\n        field.setAccessible(true);\n        try {\n            map.put(field.getName(), field.get(source));\n        } catch (IllegalAccessException e) {\n            e.printStackTrace();\n        }\n    }\n    return map;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param targetBeanClazz the target class, a subclass of the ChatOptions, to convert\n\t * into.\n\t * @param <T> the target class type.\n\t * @return a new instance of the targetBeanClazz with the values from the sourceBean\n\t * instance.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean = targetBeanClazz.getDeclaredConstructor().newInstance();\n    for (Method method : sourceInterfaceClazz.getMethods()) {\n        String methodName = method.getName();\n        try {\n            Method targetMethod = targetBean.getClass().getMethod(methodName);\n            targetMethod.invoke(targetBean, method.invoke(sourceBean));\n        } catch (Exception e) {\n            // Handle exception\n        }\n    }\n    return targetBean;\n}\n```", "  ```\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean = null;\n    try {\n        targetBean = targetBeanClazz.newInstance();\n    } catch (InstantiationException | IllegalAccessException e) {\n        e.printStackTrace();\n    }\n    for (Method method : sourceInterfaceClazz.getDeclaredMethods()) {\n        String methodName = method.getName();\n        try {\n            Field field = targetBeanClazz.getDeclaredField(methodName);\n            field.setAccessible(true);\n            field.set(targetBean, method.invoke(sourceBean));\n        } catch (NoSuchFieldException | IllegalAccessException | InvocationTargetException e) {\n            e.printStackTrace();\n        }\n    }\n    return targetBean;\n}\n```", "  ```\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean = null;\n    try {\n        targetBean = targetBeanClazz.getDeclaredConstructor().newInstance();\n    } catch (Exception e) {\n        throw new RuntimeException(\"Error creating new instance of target class\", e);\n    }\n    for (Method method : sourceInterfaceClazz.getDeclaredMethods()) {\n        String methodName = method.getName();\n        try {\n            Method targetMethod = targetBean.getClass().getDeclaredMethod(methodName);\n            targetMethod.invoke(targetBean, method.invoke(sourceBean));\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error invoking method \" + methodName, e);\n        }\n    }\n    return targetBean;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    for (Method method : sourceInterfaceClazz.getDeclaredMethods()) {\n        if (method.getName().startsWith(\"get\")) {\n            String fieldName = method.getName().substring(3);\n            Object sourceValue = method.invoke(source);\n            if (sourceValue != null) {\n                Method targetMethod = target.getClass().getMethod(method.getName(), method.getParameterTypes());\n                Object targetValue = targetMethod.invoke(target);\n                if (targetValue != null && overrideNonNullTargetValues) {\n                    targetMethod.invoke(target, sourceValue);\n                }\n            }\n        }\n    }\n    return target;\n}\n```", "  ```\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    // Get the interface methods\n    Method[] interfaceMethods = sourceInterfaceClazz.getMethods();\n\n    // Iterate over the interface methods\n    for (Method method : interfaceMethods) {\n        // Get the method name\n        String methodName = method.getName();\n\n        // Check if the method is a getter method\n        if (methodName.startsWith(\"get\")) {\n            // Get the field name\n            String fieldName = methodName.substring(3);\n\n            // Get the source value\n            Object sourceValue = method.invoke(source);\n\n            // Check if the source value is not null\n            if (sourceValue != null) {\n                // Get the target value\n                Object targetValue = method.invoke(target);\n\n                // Check if the target value is null or the source value should override it\n                if (targetValue == null || overrideNonNullTargetValues) {\n                    // Set the target value\n                    method.invoke(target, sourceValue);\n                }\n            }\n        }\n    }\n\n    return target;\n}\n```", "  ```\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    for (Method method : sourceInterfaceClazz.getMethods()) {\n        String methodName = method.getName();\n        String fieldName = methodName.substring(3);\n        Object sourceValue = method.invoke(source);\n        if (sourceValue != null) {\n            Field field = target.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            Object targetValue = field.get(target);\n            if (targetValue == null || overrideNonNullTargetValues) {\n                field.set(target, sourceValue);\n            }\n        }\n    }\n    return target;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n# Natural Language Annotations: /**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageName The name of the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> classes = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    classes.addAll(reflections.getTypesAnnotatedWith(JacksonAnnotations.class));\n    for (Class<?> clazz : classes) {\n        annotatedClasses.add(TypeReference.get(clazz));\n    }\n    return annotatedClasses;\n}\n```", "  ```\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName, new TypeAnnotationsScanner(), new SubTypesScanner());\n    Set<Class<?>> classes = reflections.getTypesAnnotatedWith(JsonInclude.class, JacksonAnnotations.class);\n    for (Class<?> clazz : classes) {\n        annotatedClasses.add(TypeReference.get(clazz));\n    }\n    return annotatedClasses;\n}\n```", "  ```\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    Set<TypeReference> annotatedClasses = new HashSet<>();\n    Reflections reflections = new Reflections(packageName);\n    Set<Class<?>> classes = reflections.getTypesAnnotatedWith(JsonInclude.class);\n    classes.addAll(reflections.getTypesAnnotatedWith(Jackson.class));\n    for (Class<?> clazz : classes) {\n        annotatedClasses.add(TypeReference.create(clazz));\n    }\n    return annotatedClasses;\n}\n```"]}, "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic List<Document> get() {\n# Natural Language Annotations: /**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@Override\npublic List<Document> get() {\n    // Read the PDF document and extract paragraphs\n    List<Document> paragraphs = new ArrayList<>();\n    try (PDDocument document = PDDocument.load(new File(\"example.pdf\"))) {\n        PDFTextStripper stripper = new PDFTextStripper();\n        String text = stripper.getText(document);\n        String[] paragraphs = text.split(\"\\\\r?\\\\n\");\n        for (String paragraph : paragraphs) {\n            Document doc = new Document();\n            doc.setText(paragraph);\n            paragraphs.add(doc);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return paragraphs;\n}\n```", "  ```\npublic List<Document> get() {\n    // Read and process the PDF document\n    PDDocument pdfDocument = PDDocument.load(new File(\"path/to/document.pdf\"));\n    PDPageTree pageTree = pdfDocument.getPages();\n    List<PDPage> pages = pageTree.getPages();\n\n    // Extract paragraphs from each page\n    List<Document> paragraphs = new ArrayList<>();\n    for (PDPage page : pages) {\n        PDResources resources = page.getResources();\n        PDPageContentStream contentStream = new PDPageContentStream(pdfDocument, page);\n        List<PDTextStream> textStreams = contentStream.getTextStreams();\n        for (PDTextStream textStream : textStreams) {\n            List<PDTextObject> textObjects = textStream.getTextObjects();\n            for (PDTextObject textObject : textObjects) {\n                if (textObject.getBoundingBox().getHeight() > 0) {\n                    paragraphs.add(new Document(textObject.getText()));\n                }\n            }\n        }\n    }\n\n    return paragraphs;\n}\n```", "  ```\npublic List<Document> get() {\n    List<Document> paragraphs = new ArrayList<>();\n    try (PDDocument document = PDDocument.load(new File(\"example.pdf\"))) {\n        PDFTextStripper stripper = new PDFTextStripper();\n        String text = stripper.getText(document);\n        String[] paragraphs = text.split(\"\\n\\n\");\n        for (String paragraph : paragraphs) {\n            Document doc = new Document(paragraph);\n            paragraphs.add(doc);\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    return paragraphs;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n# Natural Language Annotations: /**\n     * If the given {@link FixedBitSet} is large enough to hold {@code numBits+1}, returns the given\n     * bits, otherwise returns a new {@link FixedBitSet} which can hold the requested number of bits.\n     *\n     * <p><b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of the given {@code\n     * bits} if possible. Also, calling {@link #length()} on the returned bits may return a value\n     * greater than {@code numBits}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() >= numBits) {\n        return bits;\n    }\n    return new FixedBitSet(numBits);\n}\n```", "  ```\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() >= numBits) {\n        return bits;\n    }\n    return new FixedBitSet(numBits);\n}\n```", "  ```\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() < numBits) {\n        return new FixedBitSet(numBits);\n    }\n    return bits;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void forEach(IntBiConsumer<T> consumer) {\n# Natural Language Annotations: /**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < size(); i++) {\n        if (get(i) != null) {\n            consumer.accept(i, get(i));\n        }\n    }\n}\n```", "  ```\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < this.size; i++) {\n        if (this.keys[i] != null) {\n            consumer.accept(this.keys[i], this.values[i]);\n        }\n    }\n}\n```", "  ```\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < keys.length; i++) {\n        int key = keys[i];\n        if (key != null) {\n            consumer.accept(key, values[i]);\n        }\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public final long pop() {\n# Natural Language Annotations: /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic final long pop() {\n    if (isEmpty()) {\n        throw new IllegalStateException(\"The LongHeap is empty.\");\n    }\n    long result = heap[1];\n    heap[1] = heap[size];\n    heap[size--] = 0;\n    siftDown(1);\n    return result;\n}\n```", "  ```public final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"PriorityQueue is empty\");\n    }\n    long result = heap[1];\n    heap[1] = heap[size];\n    heap[size] = null;\n    size--;\n    siftDown(1);\n    return result;\n}\n```", "  ```\npublic final long pop() {\n    if (isEmpty()) {\n        throw new IllegalStateException(\"PriorityQueue is empty\");\n    }\n    long result = elements[0];\n    elements[0] = elements[size - 1];\n    elements[size - 1] = null;\n    size--;\n    heapify(0);\n    return result;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @VisibleForTesting    long updateTop(long value) {\n# Natural Language Annotations: /**\n     * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n     * Should be called when the top value changes.\n     * Still log(n) worst case, but it's at least twice as fast to\n     *\n     * <pre class=\"prettyprint\">\n     * pq.updateTop(value);\n     * </pre>\n     * <p>\n     * instead of\n     *\n     * <pre class=\"prettyprint\">\n     * pq.pop();\n     * pq.push(value);\n     * </pre>\n     * <p>\n     * Calling this method on an empty BoundedLongHeap has no visible effect.\n     *\n     * @param value the new element that is less than the current top.\n     * @return the new 'top' element after shuffling the heap.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size == 0) {\n        return value;\n    }\n    long[] heap = getHeap();\n    long top = heap[0];\n    heap[0] = value;\n    int index = 0;\n    while (index < size / 2) {\n        int left = 2 * index + 1;\n        int right = 2 * index + 2;\n        if (left < size && heap[left] > heap[index]) {\n            index = left;\n        } else if (right < size && heap[right] > heap[index]) {\n            index = right;\n        } else {\n            break;\n        }\n        long temp = heap[index];\n        heap[index] = heap[index / 2];\n        heap[index / 2] = temp;\n    }\n    return top;\n}\n```", "  ```\npublic long updateTop(long value) {\n    if (value > top) {\n        throw new IllegalArgumentException(\"New value must be less than current top\");\n    }\n    if (size == 0) {\n        return value;\n    }\n    if (size == 1) {\n        size++;\n        return value;\n    }\n    long oldTop = top;\n    top = value;\n    heapifyUp();\n    return oldTop;\n}\n```", "  ```\nlong updateTop(long value) {\n    long top = peek();\n    if (top == value) {\n        return top;\n    }\n    if (top > value) {\n        long newTop = pop();\n        push(value);\n        return newTop;\n    }\n    return top;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n     * is a useful approximation for cosine distance and not really anything else.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nreturn new ScoreFunction.ApproximateScoreFunction() {\n    @Override\n    public double score(int docId, float[] model) {\n        return BQ.similarity(q, model);\n    }\n};\n```", "  ```\nreturn new ScoreFunction.ApproximateScoreFunction() {\n    @Override\n    public float score(int doc, float subQueryScore) {\n        return (float) q.dotProduct(q, doc);\n    }\n};\n```", "  ```\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public float score(VectorFloat<?> v) {\n            return (float) (1.0 - Math.abs(q.dotProduct(v)) / (q.norm() * v.norm()));\n        }\n    };\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ProductQuantization compute(\n# Natural Language Annotations: /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param clusterCount number of clusters per subspace\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     * @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n     *                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static ProductQuantization compute(double[][] ravv, int M, int clusterCount, boolean globallyCenter, double anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    // Initialize the codebooks by clustering the input data using Product Quantization\n    List<List<double[]>> codebooks = new ArrayList<>();\n    for (int i = 0; i < M; i++) {\n        List<double[]> codebook = new ArrayList<>();\n        for (int j = 0; j < clusterCount; j++) {\n            codebook.add(new double[ravv[0].length]);\n        }\n        codebooks.add(codebook);\n    }\n\n    // Center the vectors globally if necessary\n    if (globallyCenter) {\n        for (int i = 0; i < ravv.length; i++) {\n            for (int j = 0; j < ravv[0].length; j++) {\n                ravv[i][j] -= ravv[i][j];\n            }\n        }\n    }\n\n    // Cluster the input data using Product Quantization\n    for (int i = 0; i < ravv.length; i++) {\n        for (int j = 0; j < M; j++) {\n            int closestCluster = -1;\n            double minDistance = Double.POSITIVE_INFINITY;\n            for (int k = 0; k < clusterCount; k++) {\n                double distance = distance(ravv[i], codebooks.get(j).get(k));\n                if (distance < minDistance) {\n                    closestCluster = k;\n                    minDistance = distance;\n                }\n            }\n            ravv[i] = codebooks.get(j).get(closestCluster);\n        }\n    }\n\n    // Return the codebooks\n    return new ProductQuantization(codebooks);\n}\n```", "  ```\npublic static ProductQuantization compute(double[][] ravv, int M, int clusterCount, boolean globallyCenter, double anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    // Initialize the codebooks by clustering the input data using Product Quantization\n    List<List<double[]>> codebooks = new ArrayList<>();\n    for (int m = 0; m < M; m++) {\n        List<double[]> subspace = new ArrayList<>();\n        for (int i = 0; i < ravv.length; i++) {\n            double[] vector = ravv[i];\n            double[] subspaceVector = new double[vector.length / M];\n            for (int j = 0; j < subspaceVector.length; j++) {\n                subspaceVector[j] = vector[m * subspaceVector.length + j];\n            }\n            subspace.add(subspaceVector);\n        }\n        codebooks.add(subspace);\n    }\n    \n    // Cluster the codebooks using the specified clustering algorithm\n    for (List<double[]> subspace : codebooks) {\n        List<List<double[]>> clusters = new ArrayList<>();\n        for (int i = 0; i < clusterCount; i++) {\n            clusters.add(new ArrayList<>());\n        }\n        for (double[] vector : subspace) {\n            double minDistance = Double.MAX_VALUE;\n            int minIndex = 0;\n            for (int i = 0; i < clusters.size(); i++) {\n                double distance = computeDistance(vector, clusters.get(i).get(0));\n                if (distance < minDistance) {\n                    minDistance = distance;\n                    minIndex = i;\n                }\n            }\n            clusters.get(minIndex).add(vector);\n        }\n        subspace.clear();\n        for (List<double[]> cluster : clusters) {\n            subspace.add(computeCentroid(cluster));\n        }\n    }\n    \n    // Create a new ProductQuantization object with the computed codebooks\n    ProductQuantization productQuantization = new ProductQuantization(codebooks);\n    \n    // Return the computed ProductQuantization object\n    return productQuantization;\n}\n```", "  ```\npublic static ProductQuantization compute(Vector[] ravv, int M, int clusterCount, boolean globallyCenter, double anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    // Initialize the codebooks by clustering the input data using Product Quantization\n    ProductQuantization pq = new ProductQuantization(M, clusterCount, globallyCenter, anisotropicThreshold, simdExecutor, parallelExecutor);\n    pq.cluster(ravv);\n    return pq;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ProductQuantization refine(RandomAccessVectorValues ravv,\n# Natural Language Annotations: /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    ProductQuantization pq = new ProductQuantization(ravv.getNumVectors(), ravv.getDimension());\n    pq.setLloydRounds(lloydsRounds);\n    pq.setRandomVectors(ravv.getRandomVectors());\n    pq.setCodes(ravv.getCodes());\n    pq.setNumVectors(ravv.getNumVectors());\n    pq.setDimension(ravv.getDimension());\n    pq.setVectors(ravv.getVectors());\n    pq.setCodebook(ravv.getCodebook());\n    pq.setCodebookSize(ravv.getCodebookSize());\n    pq.setLloydRounds(ravv.getLloydRounds());\n    pq.setLloydIterations(ravv.getLloydIterations());\n    return pq;\n}\n```", "  ```\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Create a new PQ by fine-tuning this one with the data in `ravv`\n    ProductQuantization newPQ = new ProductQuantization(this);\n    newPQ.lloyd(ravv, lloydsRounds);\n    return newPQ;\n}\n```", "  ```\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Create a new PQ with the same parameters as this one\n    ProductQuantization newPQ = new ProductQuantization(this.k, this.m, this.n, this.b);\n\n    // Perform Lloyd's algorithm on the new data to fine-tune the PQ\n    newPQ.lloyd(ravv, lloydsRounds);\n\n    // Return the fine-tuned PQ\n    return newPQ;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    // Initialize the PQ codebooks\n    PQCodebook[] codebooks = new PQCodebook[numSubspaces];\n    for (int i = 0; i < numSubspaces; i++) {\n        codebooks[i] = new PQCodebook(numBits, numCodes, numSubspaces, i);\n    }\n\n    // Initialize the weighted loss function\n    WeightedLossFunction lossFunction = new WeightedLossFunction(numSubspaces, 1, 0.1);\n\n    // Create the output byte sequence\n    ByteSequence output = new ByteSequence(numSubspaces);\n\n    // Encode the input vector using the PQ codebooks\n    for (int i = 0; i < numSubspaces; i++) {\n        PQCodebook codebook = codebooks[i];\n        float[] subspace = vector.getSubspace(i);\n        byte[] code = codebook.encode(subspace);\n        output.set(i, code);\n    }\n\n    // Compute the weighted loss\n    float loss = lossFunction.computeLoss(output);\n\n    // Normalize the loss\n    float normalizedLoss = loss / numSubspaces;\n\n    // Return the output byte sequence\n    return output;\n}\n```", "  ```\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    ByteSequence<Float> encoded = new ByteSequence<Float>(vector.length());\n    for (int i = 0; i < vector.length(); i++) {\n        float x = vector.get(i);\n        float y = vector.get(i + 1);\n        float z = vector.get(i + 2);\n        float parallelLoss = Math.abs(x - y) + Math.abs(y - z) + Math.abs(z - x);\n        float orthogonalLoss = Math.abs(x) + Math.abs(y) + Math.abs(z);\n        float weightedLoss = parallelLoss * 2 + orthogonalLoss;\n        encoded.set(i, (byte) (weightedLoss / 3));\n    }\n    return encoded;\n}\n```", "  ```\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    ByteSequence<Byte> encoded = new ByteSequence<Byte>();\n    for (int i = 0; i < vector.length(); i++) {\n        float parallel = vector.get(i) * vector.get(i);\n        float orthogonal = vector.get(i) * vector.get(i - 1);\n        float weightedLoss = parallel * PQ_CODEBOOKS.get(i).parallelLoss + orthogonal * PQ_CODEBOOKS.get(i).orthogonalLoss;\n        encoded.add((byte) (weightedLoss * 255));\n    }\n    return encoded;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ByteSequence<?> encode(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nByteSequence<?> encode(VectorFloat<?> vector) {\n    ByteSequence<VectorFloat<?>> encoded = new ByteSequence<>();\n    for (int i = 0; i < subspaces.length; i++) {\n        encoded.add(subspaces[i].encode(vector));\n    }\n    return encoded;\n}\n```", "  ```\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    // Encode the input vector using the PQ codebooks\n    ByteSequence<?> encodedVector = new ByteSequence<>(vector.size());\n    for (int i = 0; i < vector.size(); i++) {\n        encodedVector.set(i, (byte)vector.get(i));\n    }\n    return encodedVector;\n}\n```", "  ```\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    ByteSequence<Subspace> encoded = new ByteSequence<>(vector.getDimension());\n    for (int i = 0; i < vector.getDimension(); i++) {\n        encoded.set(i, (byte) vector.get(i));\n    }\n    return encoded;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    int numElements = encoded.size();\n    for (int i = 0; i < numElements; i++) {\n        int byteValue = encoded.get(i);\n        float decodedValue = (float) byteValue / 255.0f;\n        target.set(i, decodedValue);\n    }\n}\n```", "  ```\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Decode the quantized representation to its approximate original vector\n    target.set(encoded.decode());\n}\n```", "  ```\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Decode the quantized representation to its approximate original vector\n    target.set(encoded.getFloat(0), encoded.getFloat(1), encoded.getFloat(2));\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Calculate the centroid of the encoded data\n    VectorFloat<?> centroid = ...;\n\n    // Decode the quantized representation to its approximate original vector\n    VectorFloat<?> decoded = ...;\n\n    // Calculate the difference between the decoded vector and the centroid\n    VectorFloat<?> delta = decoded - centroid;\n\n    // Add the difference to the target vector\n    target += delta;\n}\n```", "  ```\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Calculate the global centroid\n    VectorFloat<?> centroid = calculateCentroid(encoded);\n\n    // Calculate the offset from the global centroid\n    VectorFloat<?> offset = subtract(encoded, centroid);\n\n    // Decode the offset\n    VectorFloat<?> decoded = decode(offset);\n\n    // Add the global centroid to the decoded vector\n    target = add(decoded, centroid);\n}\n```", "  ```\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Decode the ByteSequence to a VectorFloat\n    VectorFloat decoded = decode(encoded);\n\n    // Get the global centroid\n    VectorFloat centroid = getCentroid();\n\n    // Subtract the centroid from the decoded vector to get the relative vector\n    VectorFloat relative = decoded - centroid;\n\n    // Assign the relative vector to the target\n    target = relative;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public Matrix invert() {\n# Natural Language Annotations: /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic Matrix invert() {\n    // Check if the matrix is square\n    if (!isSquare()) {\n        throw new IllegalArgumentException(\"Matrix must be square\");\n    }\n\n    // Create a copy of the matrix\n    Matrix copy = new Matrix(this);\n\n    // Perform gaussian elimination\n    copy.gaussianElimination();\n\n    // Return the inverse of the matrix\n    return copy;\n}\n```", "  ```\npublic Matrix invert() {\n    // Check if the matrix is square\n    if (!isSquare()) {\n        throw new IllegalArgumentException(\"Matrix must be square\");\n    }\n\n    // Create a copy of the matrix\n    Matrix copy = new Matrix(this);\n\n    // Perform gaussian elimination\n    for (int i = 0; i < rows; i++) {\n        // Find pivot\n        int pivot = copy.findPivot(i);\n\n        // Swap rows\n        copy.swapRows(i, pivot);\n\n        // Scale row\n        copy.scaleRow(i, 1 / copy.get(i, i));\n\n        // Update other rows\n        for (int j = 0; j < rows; j++) {\n            if (i != j) {\n                copy.addRow(i, j, -copy.get(i, j) * copy.get(j, i));\n            }\n        }\n    }\n\n    return copy;\n}\n```", "  ```\npublic Matrix invert() {\n    if (!isSquare()) {\n        throw new IllegalArgumentException(\"Matrix must be square\");\n    }\n\n    // Create a copy of the matrix\n    Matrix copy = new Matrix(this);\n\n    // Perform gaussian elimination\n    for (int i = 0; i < copy.getRows(); i++) {\n        // Find the pivot element\n        double pivot = copy.get(i, i);\n\n        // Swap the current row with the pivot row\n        copy.swapRows(i, i + pivot);\n\n        // Divide the current row by the pivot element\n        copy.divideRow(i, pivot);\n\n        // Subtract the current row from all other rows\n        for (int j = 0; j < copy.getRows(); j++) {\n            if (i != j) {\n                copy.subtractRow(i, j, copy.get(i, j));\n            }\n        }\n    }\n\n    // Return the inverse of the matrix\n    return copy;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n# Natural Language Annotations: /**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.size() != b.size()) {\n        throw new IllegalArgumentException(\"Vectors must have the same dimension\");\n    }\n    float dotProduct = 0;\n    float normA = 0;\n    float normB = 0;\n    for (int i = 0; i < a.size(); i++) {\n        dotProduct += a.get(i) * b.get(i);\n        normA += a.get(i) * a.get(i);\n        normB += b.get(i) * b.get(i);\n    }\n    return dotProduct / (float) Math.sqrt(normA * normB);\n}\n```", "  ```\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.size() != b.size()) {\n        throw new IllegalArgumentException(\"Vectors must have the same dimension\");\n    }\n    float dotProduct = 0;\n    float magnitudeA = 0;\n    float magnitudeB = 0;\n    for (int i = 0; i < a.size(); i++) {\n        dotProduct += a.get(i) * b.get(i);\n        magnitudeA += a.get(i) * a.get(i);\n        magnitudeB += b.get(i) * b.get(i);\n    }\n    float cosine = dotProduct / (Math.sqrt(magnitudeA) * Math.sqrt(magnitudeB));\n    return cosine;\n}\n```", "  ```\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.size() != b.size()) {\n        throw new IllegalArgumentException(\"Vectors must have the same size\");\n    }\n\n    float dotProduct = 0;\n    float magnitudeA = 0;\n    float magnitudeB = 0;\n\n    for (int i = 0; i < a.size(); i++) {\n        dotProduct += a.get(i) * b.get(i);\n        magnitudeA += a.get(i) * a.get(i);\n        magnitudeB += b.get(i) * b.get(i);\n    }\n\n    return dotProduct / (float) Math.sqrt(magnitudeA * magnitudeB);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n# Natural Language Annotations: /**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    // Check if the vectors instance is valid\n    if (vectors == null) {\n        throw new IllegalArgumentException(\"vectors cannot be null\");\n    }\n\n    // Check if the queryVector is valid\n    if (queryVector == null) {\n        throw new IllegalArgumentException(\"queryVector cannot be null\");\n    }\n\n    // Check if the similarityFunction is valid\n    if (similarityFunction == null) {\n        throw new IllegalArgumentException(\"similarityFunction cannot be null\");\n    }\n\n    // Check if the graph is valid\n    if (graph == null) {\n        throw new IllegalArgumentException(\"graph cannot be null\");\n    }\n\n    // Check if the acceptOrds is valid\n    if (acceptOrds == null) {\n        throw new IllegalArgumentException(\"acceptOrds cannot be null\");\n    }\n\n    // Create a new search result object\n    SearchResult result = new SearchResult();\n\n    // Get the number of vectors in the vectors instance\n    int numVectors = vectors.size();\n\n    // Initialize the result with the topK vectors\n    result.vectors = new VectorFloat[topK];\n    result.similarities = new float[topK];\n\n    // Initialize the acceptOrds array to all true\n    boolean[] accept = new boolean[numVectors];\n    for (int i = 0; i < numVectors; i++) {\n        accept[i] = true;\n    }\n\n    // Initialize the vectors and similarities arrays\n    for (int i = 0; i < topK; i++) {\n        result.vectors[i] = new VectorFloat(queryVector.getDimension());\n        result.similarities[i] = 0;\n    }\n\n    // Loop through each vector in the vectors instance\n    for (int i = 0; i < numVectors; i++) {\n        // Check if the vector is accepted\n        if (accept[i]) {\n            // Calculate the similarity between the query vector and the current vector\n            float similarity = similarityFunction.similarity(queryVector, vectors.get(i));\n\n            // Check if the similarity is greater than the minimum similarity\n            if (similarity >= MIN_SIMILARITY) {\n                // Add the vector and similarity to the result\n                result.vectors[i] = vectors.get(i);\n                result.similarities[i] = similarity;\n            }\n        }\n    }\n\n    // Return the result\n    return result;\n}\n```", "  ```\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    // Create a new searcher with the given parameters\n    Searcher searcher = new Searcher(vectors, similarityFunction, graph);\n\n    // Perform the search\n    SearchResult result = searcher.search(queryVector, topK);\n\n    // Return the search result\n    return result;\n}\n```", "  ```\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    SearchResult result = new SearchResult();\n    result.topK = topK;\n    result.vectors = vectors;\n    result.similarityFunction = similarityFunction;\n    result.graph = graph;\n    result.acceptOrds = acceptOrds;\n\n    return result;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int[] nodesCopy() {\n# Natural Language Annotations: /** Returns a copy of the internal nodes array. Not sorted by score! */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic int[] nodesCopy() {\n    return nodes.clone();\n}\n```", "  ```\npublic int[] nodesCopy() {\n    return nodes.clone();\n}\n```", "  ```\npublic int[] nodesCopy() {\n    int[] copy = new int[nodes.length];\n    System.arraycopy(nodes, 0, copy, 0, nodes.length);\n    return copy;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n# Natural Language Annotations: /**\n     * Rerank results and return the worst approximate score that made it into the topK.\n     * The topK results will be placed into `reranked`, and the remainder into `unused`.\n     * <p>\n     * Only the best result or results whose approximate score is at least `rerankFloor` will be reranked.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    float worstApproxScore = 0;\n    for (int i = 0; i < topK; i++) {\n        Node node = reranked.get(i);\n        float approxScore = reranker.score(node);\n        if (approxScore < rerankFloor) {\n            break;\n        }\n        worstApproxScore = Math.max(worstApproxScore, approxScore);\n    }\n    return worstApproxScore;\n}\n```", "  ```\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    // Create a priority queue to hold the topK results\n    PriorityQueue<Node> topKQueue = new PriorityQueue<>(topK, Comparator.comparing(Node::getApproximateScore));\n\n    // Add the topK results from the input queue to the priority queue\n    for (int i = 0; i < topK; i++) {\n        topKQueue.add(reranked.poll());\n    }\n\n    // Rerank the remaining results and add them to the priority queue\n    while (!reranked.isEmpty()) {\n        Node node = reranked.poll();\n        if (node.getApproximateScore() >= rerankFloor) {\n            topKQueue.add(node);\n        } else {\n            unused.add(node);\n        }\n    }\n\n    // Return the worst approximate score that made it into the topK\n    return topKQueue.peek().getApproximateScore();\n}\n```", "  ```\nfloat rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    // Check if the reranker is null\n    if (reranker == null) {\n        return -1;\n    }\n\n    // Get the topK results and their scores\n    List<Node> topKResults = new ArrayList<>();\n    List<Float> topKScore = new ArrayList<>();\n    for (int i = 0; i < topK; i++) {\n        Node result = reranked.poll();\n        topKResults.add(result);\n        topKScore.add(result.getScore());\n    }\n\n    // Rerank the results\n    for (int i = 0; i < topK; i++) {\n        Node result = topKResults.get(i);\n        float score = reranker.rerank(result, topKResults, topKScore);\n        if (score < rerankFloor) {\n            unused.add(result);\n        } else {\n            reranked.add(result);\n        }\n    }\n\n    // Return the worst approximate score that made it into the topK\n    return topKScore.get(topK - 1);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static NodeArray merge(NodeArray a1, NodeArray a2) {\n# Natural Language Annotations: /** always creates a new NodeArray to return, even when a1 or a2 is empty */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n  if (a1.isEmpty() && a2.isEmpty()) {\n    return new NodeArray();\n  } else if (a1.isEmpty()) {\n    return a2;\n  } else if (a2.isEmpty()) {\n    return a1;\n  } else {\n    NodeArray result = new NodeArray();\n    result.addAll(a1);\n    result.addAll(a2);\n    return result;\n  }\n}\n```", "  ```\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n  NodeArray result = new NodeArray();\n  for (int i = 0; i < a1.length; i++) {\n    result.add(a1[i]);\n  }\n  for (int i = 0; i < a2.length; i++) {\n    result.add(a2[i]);\n  }\n  return result;\n}\n```", "  ```\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray result = new NodeArray();\n    for (int i = 0; i < a1.size(); i++) {\n        result.add(a1.get(i));\n    }\n    for (int i = 0; i < a2.size(); i++) {\n        result.add(a2.get(i));\n    }\n    return result;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void addInOrder(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void addInOrder(int newNode, float newScore) {\n    // Check if the new node is worse than all previously stored nodes\n    for (int i = 0; i < nodes.length; i++) {\n        if (nodes[i] == null) {\n            nodes[i] = newNode;\n            scores[i] = newScore;\n            return;\n        }\n        if (scores[i] > newScore) {\n            // Move all nodes with higher score to the right\n            for (int j = nodes.length - 1; j > i; j--) {\n                nodes[j] = nodes[j - 1];\n                scores[j] = scores[j - 1];\n            }\n            nodes[i] = newNode;\n            scores[i] = newScore;\n            return;\n        }\n    }\n}\n```", "  ```\npublic void addInOrder(int newNode, float newScore) {\n    int i = 0;\n    while (i < nodes.length && nodes[i].score > newScore) {\n        i++;\n    }\n    if (i < nodes.length) {\n        for (int j = nodes.length - 1; j >= i; j--) {\n            nodes[j + 1] = nodes[j];\n        }\n        nodes[i] = newNode;\n    }\n}\n```", "  ```\npublic void addInOrder(int newNode, float newScore) {\n    // Check if the new node is worse than all previously stored nodes\n    for (int i = 0; i < nodes.length; i++) {\n        if (newScore > nodes[i].score) {\n            // Insert the new node at the correct position\n            for (int j = nodes.length - 1; j > i; j--) {\n                nodes[j] = nodes[j - 1];\n            }\n            nodes[i] = newNode;\n            return;\n        }\n    }\n    // If the new node is better than all previously stored nodes, add it to the end\n    nodes[nodes.length] = newNode;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int insertSorted(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nint insertSorted(int newNode, float newScore) {\n    int insertPoint = -1;\n    for (int i = 0; i < nodeArray.length; i++) {\n        if (nodeArray[i].score > newScore) {\n            insertPoint = i;\n            break;\n        }\n    }\n    if (insertPoint != -1) {\n        for (int i = nodeArray.length - 1; i > insertPoint; i--) {\n            nodeArray[i] = nodeArray[i - 1];\n        }\n        nodeArray[insertPoint] = newNode;\n    }\n    return insertPoint;\n}\n```", "  ```\npublic int insertSorted(int newNode, float newScore) {\n    if (isEmpty()) {\n        return 0;\n    }\n    int left = 0;\n    int right = size() - 1;\n    while (left <= right) {\n        int mid = (left + right) / 2;\n        if (newScore < scores[mid]) {\n            right = mid - 1;\n        } else if (newScore > scores[mid]) {\n            left = mid + 1;\n        } else {\n            return -1;\n        }\n    }\n    int insertionPoint = left;\n    for (int i = size() - 1; i >= insertionPoint; i--) {\n        nodes[i] = nodes[i - 1];\n        scores[i] = scores[i - 1];\n    }\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    return insertionPoint;\n}\n```", "  ```\nint insertSorted(int newNode, float newScore) {\n    int insertionPoint = -1;\n    for (int i = 0; i < NodeArray.size(); i++) {\n        if (NodeArray.get(i).score > newScore) {\n            insertionPoint = i;\n            break;\n        }\n    }\n    if (insertionPoint == -1) {\n        NodeArray.add(newNode, newScore);\n    } else {\n        NodeArray.add(insertionPoint, newNode, newScore);\n    }\n    return insertionPoint;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void retain(Bits selected) {\n# Natural Language Annotations: /**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void retain(Bits selected) {\n    int[] newArray = new int[selected.cardinality()];\n    int j = 0;\n    for (int i = 0; i < size(); i++) {\n        if (selected.get(i)) {\n            newArray[j++] = get(i);\n        }\n    }\n    setArray(newArray);\n}\n```", "  ```\npublic void retain(Bits selected) {\n    int numRetained = 0;\n    for (int i = 0; i < size(); i++) {\n        if (selected.get(i)) {\n            NodeArray[numRetained++] = NodeArray[i];\n        }\n    }\n    size = numRetained;\n}\n```", "  ```\npublic void retain(BitSet selected) {\n    for (int i = 0; i < nodeArray.length; i++) {\n        if (!selected.get(i)) {\n            nodeArray[i] = null;\n        }\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void add(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic void add(int newNode, float newScore) {\n    // Check if the new node is worse than all previously stored nodes\n    for (int i = 0; i < nodes.length; i++) {\n        if (newScore <= nodes[i].score) {\n            // If the new node is not worse, return without adding it\n            return;\n        }\n    }\n\n    // Add the new node to the array\n    Node[] newNodes = new Node[nodes.length + 1];\n    newNodes[nodes.length] = new Node(newNode, newScore);\n    nodes = newNodes;\n}\n```", "  ```\npublic void add(int newNode, float newScore) {\n    if (nodes.size() == 0) {\n        nodes.add(newNode);\n        scores.add(newScore);\n    } else {\n        int i = 0;\n        while (i < nodes.size() && scores.get(i) >= newScore) {\n            i++;\n        }\n        nodes.add(i, newNode);\n        scores.add(i, newScore);\n    }\n}\n```", "  ```\npublic void add(int newNode, float newScore) {\n    for (int i = 0; i < nodes.length; i++) {\n        if (newScore > nodes[i].score) {\n            nodes[i].node = newNode;\n            nodes[i].score = newScore;\n            return;\n        }\n    }\n    Node[] newNodes = new Node[nodes.length + 1];\n    System.arraycopy(nodes, 0, newNodes, 0, nodes.length);\n    newNodes[nodes.length] = new Node(newNode, newScore);\n    nodes = newNodes;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void addNode(int nodeId, NodeArray nodes) {\n# Natural Language Annotations: /**\n     * Only for internal use and by Builder loading a saved graph\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nvoid addNode(int nodeId, NodeArray nodes) {\n    // Check if nodeId is already in the graph\n    if (nodeId < nodes.length && nodes[nodeId] != null) {\n        throw new IllegalArgumentException(\"Node with id \" + nodeId + \" already exists\");\n    }\n\n    // Create a new node with the given id and add it to the graph\n    Node newNode = new Node(nodeId);\n    nodes[nodeId] = newNode;\n}\n```", "  ```\nvoid addNode(int nodeId, NodeArray nodes) {\n    nodes[nodeId] = new Node();\n}\n```", "  ```\nvoid addNode(int nodeId, NodeArray nodes) {\n    if (nodes[nodeId] != null) {\n        throw new IllegalStateException(\"Node already exists\");\n    }\n    nodes[nodeId] = new Node(nodeId);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized long removeDeletedNodes() {\n# Natural Language Annotations: /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic synchronized long removeDeletedNodes() {\n    long freedMemory = 0;\n    for (Node node : nodes) {\n        if (node.isDeleted()) {\n            freedMemory += node.getSize();\n            node.remove();\n            for (Node neighbor : node.getNeighbors()) {\n                neighbor.removeNeighbor(node);\n            }\n        }\n    }\n    return freedMemory;\n}\n```", "  ```\npublic synchronized long removeDeletedNodes() {\n    long deletedSize = 0;\n    for (Node node : getDeletedNodes()) {\n        deletedSize += node.getSize();\n        removeNode(node);\n    }\n    for (Node node : getAffectedNodes()) {\n        node.updateNeighborList();\n    }\n    return deletedSize;\n}\n```", "  ```\npublic synchronized long removeDeletedNodes() {\n    long size = 0;\n    for (Node node : nodes) {\n        if (node.isMarkedForDeletion()) {\n            size += node.getSize();\n            removeNode(node);\n        }\n    }\n    return size;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException\n# Natural Language Annotations: /**\n     * Write the inline features of the given ordinal to the output at the correct offset.\n     * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Get the offset for the given ordinal\n    long offset = getOffset(ordinal);\n    \n    // Write the inline features to the output at the correct offset\n    for (FeatureId featureId : stateMap.keySet()) {\n        Feature.State state = stateMap.get(featureId);\n        writeInlineFeature(featureId, state, offset);\n    }\n}\n```", "  ```\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    int offset = ordinal * FEATURE_SIZE;\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        int featureId = entry.getKey().getId();\n        int featureState = entry.getValue().getState();\n        output.writeShort(featureId, offset);\n        output.writeByte(featureState, offset + 2);\n    }\n}\n```", "  ```\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Get the offset for the given ordinal\n    int offset = getOffset(ordinal);\n\n    // Write the inline features to the output stream\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        FeatureId featureId = entry.getKey();\n        Feature.State state = entry.getValue();\n\n        // Skip features that are not inline\n        if (!featureId.isInline()) {\n            continue;\n        }\n\n        // Write the feature to the output stream\n        writeFeature(featureId, state, offset);\n\n        // Increment the offset for the next feature\n        offset += featureId.getSize();\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n# Natural Language Annotations: /**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> map = new HashMap<>();\n    int newOrdinal = 0;\n    for (int oldOrdinal = 0; oldOrdinal < graph.size(); oldOrdinal++) {\n        if (graph.get(oldOrdinal) != null) {\n            map.put(oldOrdinal, newOrdinal);\n            newOrdinal++;\n        }\n    }\n    return map;\n}\n```", "  ```\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> map = new HashMap<>();\n    int newOrdinal = 0;\n    for (int i = 0; i < graph.size(); i++) {\n        if (!graph.isDeleted(i)) {\n            map.put(i, newOrdinal++);\n        }\n    }\n    return map;\n}\n```", "  ```\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> map = new HashMap<>();\n    int newOrdinal = 0;\n    for (int oldOrdinal : graph.getNodeIds()) {\n        map.put(oldOrdinal, newOrdinal++);\n    }\n    return map;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void write(GraphIndex graph,\n# Natural Language Annotations: /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void write(GraphIndex graph) {\n    // Create a new DiskANN-style index\n    DiskANNIndex index = new DiskANNIndex(graph);\n\n    // Write the index to disk\n    index.write();\n}\n```", "  ```\npublic static void write(GraphIndex graph) {\n    write(graph, new FeatureSet());\n}\n```", "  ```\npublic static void write(GraphIndex graph) {\n  // Create a new vanilla DiskANN-style index\n  Index index = new Index(graph);\n  \n  // Set the number of features to 0\n  index.setNumFeatures(0);\n  \n  // Set the feature type to \"none\"\n  index.setFeatureType(\"none\");\n  \n  // Set the index type to \"diskann\"\n  index.setIndexType(\"diskann\");\n  \n  // Write the index to disk\n  index.write();\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public float score(int doc, float[] vector) {\n            return similarityFunction.score(ravv.getVector(doc), vector);\n        }\n    };\n}\n```", "  ```\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public ScoreDoc score(int docId, float boost) throws IOException {\n            float score = similarityFunction.score(ravv.getVector(docId), ravv.getVector(docId));\n            return new ScoreDoc(docId, score, boost);\n        }\n    };\n}\n```", "  ```\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public double score(int doc, int target, double[] weights) {\n            return similarityFunction.similarity(ravv.get(doc), ravv.get(target));\n        }\n    };\n}\n```"]}, "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double[] determineStandardDeviationDoubles(\n# Natural Language Annotations: /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double[] standardDeviation = new double[averageScore.length];\n    for (int i = 0; i < averageScore.length; i++) {\n        standardDeviation[i] = Math.sqrt(averageScore[i]);\n    }\n    return standardDeviation;\n}\n```", "  ```\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double[] standardDeviation = new double[averageScore.length];\n    for (int i = 0; i < averageScore.length; i++) {\n        standardDeviation[i] = Math.sqrt(averageScore[i]);\n    }\n    return standardDeviation;\n}\n```", "  ```\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    double[] result = new double[averageScore.length];\n    for (int i = 0; i < averageScore.length; i++) {\n        result[i] = Math.sqrt(averageScore[i] * averageScore[i]);\n    }\n    return result;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata stack(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata metadata = new StackMetadata();\n    metadata.clear();\n    for (ValueSourceInfo type : types) {\n        metadata.add(type);\n    }\n    return metadata;\n}\n```", "  ```\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata metadata = new StackMetadata();\n    metadata.setStack(Arrays.asList(types));\n    return metadata;\n}\n```", "  ```\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata metadata = new StackMetadata();\n    metadata.setStack(types);\n    return metadata;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata locals(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"Invalid number of local types\");\n    }\n    return new StackMetadata(types);\n}\n```", "  ```\npublic StackMetadata locals(ValueSourceInfo... types) {\n    return new StackMetadata(Arrays.asList(types));\n}\n```", "  ```\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"Number of types does not match number of local variables\");\n    }\n    StackMetadata metadata = new StackMetadata();\n    for (int i = 0; i < types.length; i++) {\n        metadata.localVariableTypes.set(i, types[i]);\n    }\n    return metadata;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the name of the method to load\n    String methodName = functionMetadata.getNames()[functionMetadata.getNameIndex()];\n    \n    // Pop the TOS object\n    Object tos = stackMetadata.pop();\n    \n    // Check if the TOS object has a method with the correct name\n    if (tos.getClass().getMethod(methodName) != null) {\n        // If it does, push the unbound method and TOS\n        stackMetadata.push(tos.getClass().getMethod(methodName));\n        stackMetadata.push(tos);\n    } else {\n        // If it doesn't, push NULL and the object returned by the attribute lookup\n        stackMetadata.push(null);\n        stackMetadata.push(tos.getClass().getAttribute(methodName));\n    }\n}\n```", "  ```\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the name of the method to load from the function metadata\n    String methodName = functionMetadata.getName();\n\n    // Pop the top of the stack (the object to load the method from)\n    Object object = stackMetadata.pop();\n\n    // Check if the object has a method with the correct name\n    if (object.hasMethod(methodName)) {\n        // Push the unbound method and the object as the first argument (self)\n        stackMetadata.push(object.getMethod(methodName));\n        stackMetadata.push(object);\n    } else {\n        // Push NULL and the object returned by the attribute lookup\n        stackMetadata.push(null);\n        stackMetadata.push(object.getAttribute(methodName));\n    }\n}\n```", "  ```\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the name of the method to load\n    String methodName = functionMetadata.getMethodName();\n    \n    // Pop the TOS object\n    Object obj = stackMetadata.pop();\n    \n    // Check if the object has a method with the correct name\n    if (obj.hasMethod(methodName)) {\n        // Push the unbound method and TOS\n        stackMetadata.push(obj.getMethod(methodName));\n        stackMetadata.push(obj);\n    } else {\n        // Push NULL and the object returned by the attribute lookup\n        stackMetadata.push(null);\n        stackMetadata.push(obj.getAttribute(methodName));\n    }\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor,\n# Natural Language Annotations: /**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    // Get the number of positional arguments\n    int argc = stackMetadata.getPositionalArgumentCount();\n\n    // Pop the two items from the stack (either self and an unbound method object or NULL and an arbitrary callable)\n    Object self = stackMetadata.pop();\n    Object method = stackMetadata.pop();\n\n    // Push the return value onto the stack\n    stackMetadata.push(method.invoke(self, argc));\n}\n```", "  ```\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    // Get the number of positional arguments\n    int argc = functionMetadata.getPositionalArgumentCount();\n\n    // Pop the positional arguments from the stack\n    Object[] args = new Object[argc];\n    for (int i = 0; i < argc; i++) {\n        args[i] = stackMetadata.pop();\n    }\n\n    // Pop the self and the unbound method object or NULL and the arbitrary callable from the stack\n    Object self = stackMetadata.pop();\n    Object method = stackMetadata.pop();\n\n    // Call the method\n    Object result = methodVisitor.call(self, method, args);\n\n    // Push the return value onto the stack\n    stackMetadata.push(result);\n}\n```", "  ```\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    // Get the number of positional arguments from the FunctionMetadata\n    int argc = functionMetadata.getPositionalArgumentCount();\n\n    // Pop the two items described in LOAD_METHOD from the stack\n    Object self = stackMetadata.pop();\n    Object method = stackMetadata.pop();\n\n    // Call the method with the given arguments\n    Object result = method.call(self, argc, stackMetadata.getPositionalArguments());\n\n    // Push the return value on the stack\n    stackMetadata.push(result);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunction(FunctionMetadata functionMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void callFunction(FunctionMetadata functionMetadata, int argc) {\n    // Pop the arguments from the stack\n    for (int i = argc - 1; i >= 0; i--) {\n        int arg = pop();\n    }\n    // Pop the function to call from the stack\n    int function = pop();\n    // Call the function\n    int result = function.call(argc, argv);\n    // Push the result onto the stack\n    push(result);\n}\n```", "  ```\npublic static void callFunction(FunctionMetadata functionMetadata, int argc) {\n    // Pop the arguments from the stack\n    for (int i = 0; i < argc; i++) {\n        int arg = pop();\n        functionMetadata.addArgument(arg);\n    }\n    \n    // Pop the function from the stack\n    int function = pop();\n    functionMetadata.setFunction(function);\n    \n    // Call the function\n    functionMetadata.call();\n    \n    // Push the result onto the stack\n    int result = functionMetadata.getResult();\n    push(result);\n}\n```", "  ```\npublic static void callFunction(FunctionMetadata functionMetadata, int argc) {\n    // Pop the arguments from the stack\n    Object[] args = new Object[argc];\n    for (int i = 0; i < argc; i++) {\n        args[i] = pop();\n    }\n\n    // Get the function to call\n    Object function = pop();\n\n    // Call the function with the arguments\n    Object result = function.call(args);\n\n    // Push the result onto the stack\n    push(result);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the keyword arguments from the stack\n    int numKeywordArgs = stackMetadata.getNumKeywordArgs();\n    String[] keywordArgs = new String[numKeywordArgs];\n    for (int i = 0; i < numKeywordArgs; i++) {\n        keywordArgs[i] = stackMetadata.getKeywordArg(i);\n    }\n\n    // Get the positional arguments from the stack\n    int numPositionalArgs = stackMetadata.getNumPositionalArgs();\n    Object[] positionalArgs = new Object[numPositionalArgs];\n    for (int i = 0; i < numPositionalArgs; i++) {\n        positionalArgs[i] = stackMetadata.getPositionalArg(i);\n    }\n\n    // Get the function to call from the stack\n    FunctionMetadata functionToCall = stackMetadata.getFunctionToCall();\n\n    // Call the function\n    Object result = functionToCall.call(keywordArgs, positionalArgs);\n\n    // Push the result onto the stack\n    stackMetadata.push(result);\n}\n```", "  ```\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the keyword arguments\n    List<Object> keywordArgs = new ArrayList<>();\n    for (int i = 1; i <= stackMetadata.getTopOfStack(); i++) {\n        keywordArgs.add(stackMetadata.pop());\n    }\n    \n    // Get the positional arguments\n    List<Object> positionalArgs = new ArrayList<>();\n    for (int i = stackMetadata.getTopOfStack() + 1; i <= stackMetadata.getTopOfStack() + functionMetadata.getNumPositionalArgs(); i++) {\n        positionalArgs.add(stackMetadata.pop());\n    }\n    \n    // Get the function to call\n    Object function = stackMetadata.pop();\n    \n    // Call the function\n    Object result = function.call(keywordArgs, positionalArgs);\n    \n    // Push the result onto the stack\n    stackMetadata.push(result);\n}\n```", "  ```\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    // Get the keyword arguments\n    var keywordArguments = new Dictionary<string, object>();\n    for (int i = 1; i < stackMetadata.Count; i++) {\n        keywordArguments.Add(functionMetadata.KeywordArguments[i - 1].Name, stackMetadata.Pop());\n    }\n\n    // Get the positional arguments\n    var positionalArguments = new List<object>();\n    for (int i = stackMetadata.Count - 1; i > functionMetadata.KeywordArguments.Count; i--) {\n        positionalArguments.Add(stackMetadata.Pop());\n    }\n\n    // Call the function\n    var result = functionMetadata.Function.Invoke(positionalArguments.ToArray(), keywordArguments);\n\n    // Push the result onto the stack\n    stackMetadata.Push(result);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    if (instruction.arg & 1) {\n        // TOS is a mapping object containing keyword arguments\n        Map<String, Object> kwargs = (Map<String, Object>) stackMetadata.pop();\n        // TOS[1] is an iterable containing positional arguments\n        Iterable positionalArgs = (Iterable) stackMetadata.pop();\n        // TOS[2] is callable\n        Callable callable = (Callable) stackMetadata.pop();\n        callable.call(positionalArgs, kwargs);\n    } else {\n        // TOS is an iterable containing positional arguments\n        Iterable positionalArgs = (Iterable) stackMetadata.pop();\n        // TOS[1] is callable\n        Callable callable = (Callable) stackMetadata.pop();\n        callable.call(positionalArgs);\n    }\n}\n```", "  ```\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    if (functionMetadata.isMapping()) {\n        // TOS is a mapping object containing keyword arguments\n        Map<String, Object> kwargs = (Map<String, Object>) stackMetadata.pop();\n        // TOS[1] is an iterable containing positional arguments\n        List<Object> args = (List<Object>) stackMetadata.pop();\n        // TOS[2] is callable\n        Callable callable = (Callable) stackMetadata.pop();\n        callable.call(kwargs, args);\n    } else {\n        // TOS is an iterable containing positional arguments\n        List<Object> args = (List<Object>) stackMetadata.pop();\n        // TOS[1] is callable\n        Callable callable = (Callable) stackMetadata.pop();\n        callable.call(args);\n    }\n}\n```", "  ```\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    if ((instruction.arg & 1) != 0) {\n        // TOS is a mapping object containing keyword arguments\n        Map<String, Object> kwargs = (Map<String, Object>) stackMetadata.pop();\n        // TOS[1] is an iterable containing positional arguments\n        Iterable<Object> args = (Iterable<Object>) stackMetadata.pop();\n        // TOS[2] is callable\n        Callable callable = (Callable) stackMetadata.pop();\n        // Call the function with keyword arguments\n        callable.call(kwargs, args);\n    } else {\n        // TOS is an iterable containing positional arguments\n        Iterable<Object> args = (Iterable<Object>) stackMetadata.pop();\n        // TOS[1] is callable\n        Callable callable = (Callable) stackMetadata.pop();\n        // Call the function with positional arguments\n        callable.call(args);\n    }\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex,\n# Natural Language Annotations: /**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // Get the global variable or parameter from the function metadata\n    Object global = functionMetadata.getGlobal(globalIndex);\n    \n    // Push the global variable or parameter onto the stack\n    stackMetadata.push(global);\n}\n```", "  ```\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // Get the global variable or parameter at the specified index\n    Object value = functionMetadata.getGlobalVariable(globalIndex);\n\n    // Push the value onto the stack\n    stackMetadata.push(value);\n}\n```", "  ```\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // Get the global variable or parameter by its index\n    Object global = functionMetadata.getGlobalVariable(globalIndex);\n\n    // Push the global variable or parameter onto the stack\n    stackMetadata.push(global);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n# Natural Language Annotations: /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    PythonCell cell = functionMetadata.getParentFunction().getCells()[cellIndex];\n    stackMetadata.push(cell);\n}\n```", "  ```\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    PythonCell cell = functionMetadata.getCell(cellIndex);\n    if (cell == null) {\n        throw new IllegalArgumentException(\"Invalid cell index: \" + cellIndex);\n    }\n    stackMetadata.push(cell.getValue());\n}\n```", "  ```\nObject cellVariable = functionMetadata.getCellVariable(cellIndex);\nstackMetadata.push(cellVariable);\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n# Natural Language Annotations: /**\n     * Replaces TOS with getattr(TOS, co_names[instruction.arg])\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    stackMetadata.TOS = getattr(stackMetadata.TOS, functionMetadata.co_names[nameIndex]);\n}\n```", "  ```\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    String attrName = functionMetadata.getConstantPool().get(nameIndex).getString();\n    Object value = stackMetadata.pop();\n    stackMetadata.push(value.getClass().getField(attrName).get(value));\n}\n```", "  ```\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    stackMetadata.TOS = functionMetadata.getattr(stackMetadata.TOS, functionMetadata.co_names[nameIndex]);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n# Natural Language Annotations: /**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n     * @param solution never null\n     * @return {@code >= 0}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nreturn Math.log10(scoreDirector.getWorkingSolution().getScore().getScore()) / Math.log10(solution.getScore().getScore());\n```", "  ```\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    double searchSpaceSize = scoreDirector.getWorkingSolution().getEntityList().size();\n    return Math.log10(searchSpaceSize);\n}\n```", "  ```\ndouble getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    return Math.log10(scoreDirector.getSearchSpaceSize(solution));\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void defineClonerFor(ClassCreator classCreator,\n# Natural Language Annotations: /**\n     * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given\n     * ClassCreator\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static void defineClonerFor(ClassCreator classCreator, SolutionDescriptor solutionDescriptor) {\n    // Generate the constructor\n    classCreator.addConstructor(\n        new ConstructorDescriptor(\n            solutionDescriptor.getClassName(), \n            Arrays.asList(\n                new ParameterDescriptor(\"solution\", solutionDescriptor.getClassName())\n            )\n        )\n    );\n    \n    // Generate the clone method\n    classCreator.addMethod(\n        new MethodDescriptor(\n            \"clone\",\n            solutionDescriptor.getClassName(),\n            Arrays.asList(\n                new ParameterDescriptor(\"solution\", solutionDescriptor.getClassName())\n            ),\n            Arrays.asList(\n                new StatementDescriptor(\n                    \"return new \" + solutionDescriptor.getClassName() + \"();\"\n                )\n            )\n        )\n    );\n}\n```", "  ```\npublic static void defineClonerFor(ClassCreator classCreator, SolutionDescriptor solutionDescriptor) {\n    // Generate the constructor\n    classCreator.addConstructor(new ConstructorDescriptor(solutionDescriptor.getClassName(),\n                                                         new ClassDescriptor(solutionDescriptor.getClassName()),\n                                                         new ClassDescriptor(solutionDescriptor.getClassName())));\n\n    // Generate the clone method\n    classCreator.addMethod(new MethodDescriptor(\"clone\",\n                                              new ClassDescriptor(solutionDescriptor.getClassName()),\n                                              new ClassDescriptor(solutionDescriptor.getClassName()),\n                                              new ClassDescriptor(solutionDescriptor.getClassName())));\n\n    // Generate the copy method\n    classCreator.addMethod(new MethodDescriptor(\"copy\",\n                                              new ClassDescriptor(solutionDescriptor.getClassName()),\n                                              new ClassDescriptor(solutionDescriptor.getClassName()),\n                                              new ClassDescriptor(solutionDescriptor.getClassName())));\n}\n```", "  ```\npublic static void defineClonerFor(ClassCreator classCreator, SolutionDescriptor solutionDescriptor) {\n    Class<?> clonedClass = classCreator.createClass(solutionDescriptor.getClonedClass());\n    MethodHandle constructor = classCreator.createConstructor(clonedClass, solutionDescriptor.getConstructorParameters());\n    MethodHandle cloneMethod = classCreator.createMethod(clonedClass, \"clone\", solutionDescriptor.getCloneMethodParameters());\n    MethodHandle copyMethod = classCreator.createMethod(clonedClass, \"copy\", solutionDescriptor.getCopyMethodParameters());\n\n    // Generate the constructor implementation\n    classCreator.generateConstructor(clonedClass, constructor, solutionDescriptor.getConstructorParameters());\n\n    // Generate the clone method implementation\n    classCreator.generateMethod(clonedClass, cloneMethod, solutionDescriptor.getCloneMethodParameters());\n\n    // Generate the copy method implementation\n    classCreator.generateMethod(clonedClass, copyMethod, solutionDescriptor.getCopyMethodParameters());\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n# Natural Language Annotations: /**\n     * Takes a look at the shadow variables of all entities and compares them against the recorded state. Every difference\n     * is added to the violation message. The first N differences up to the {@code violationDisplayLimit} are displayed\n     * in detail; the number of violations exceeding the display limit is reported at the end. The limit applies per each\n     * shadow variable descriptor.\n     * <p>\n     * This method should be called after a forceful trigger of variable listeners.\n     *\n     * @param violationDisplayLimit maximum number of violations reported per shadow variable descriptor\n     * @return description of the violations or {@code null} if there are none\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder violationMessage = new StringBuilder();\n    for (ShadowVariableDescriptor descriptor : shadowVariableDescriptors) {\n        List<ShadowVariable> violations = descriptor.getViolations();\n        if (!violations.isEmpty()) {\n            violationMessage.append(descriptor.getName()).append(\": \");\n            for (int i = 0; i < Math.min(violations.size(), violationDisplayLimit); i++) {\n                ShadowVariable violation = violations.get(i);\n                violationMessage.append(violation.getEntity().getId()).append(\": \")\n                        .append(violation.getVariableName()).append(\"=\").append(violation.getCurrentValue())\n                        .append(\" (expected \").append(violation.getExpectedValue()).append(\")\");\n                if (i < violations.size() - 1) {\n                    violationMessage.append(\", \");\n                }\n            }\n            if (violations.size() > violationDisplayLimit) {\n                violationMessage.append(\" (and \").append(violations.size() - violationDisplayLimit)\n                        .append(\" more)\");\n            }\n            violationMessage.append(\"\\n\");\n        }\n    }\n    return violationMessage.length() == 0 ? null : violationMessage.toString();\n}\n```", "  ```\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder violationMessage = new StringBuilder();\n    for (ShadowVariableDescriptor descriptor : getShadowVariableDescriptors()) {\n        List<ShadowVariableViolation> violations = descriptor.getViolations();\n        if (!violations.isEmpty()) {\n            violationMessage.append(descriptor.getName()).append(\": \");\n            int i = 0;\n            for (ShadowVariableViolation violation : violations) {\n                if (i < violationDisplayLimit) {\n                    violationMessage.append(violation.toString()).append(\", \");\n                }\n                i++;\n            }\n            if (violations.size() > violationDisplayLimit) {\n                violationMessage.append(\"...\");\n            }\n        }\n    }\n    if (violationMessage.length() > 0) {\n        return violationMessage.toString();\n    } else {\n        return null;\n    }\n}\n```", "  ```\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder violationMessage = new StringBuilder();\n    for (ShadowVariableDescriptor descriptor : shadowVariableDescriptors) {\n        String variableName = descriptor.getName();\n        Object recordedValue = descriptor.getRecordedValue();\n        Object currentValue = descriptor.getCurrentValue();\n        if (!Objects.equals(recordedValue, currentValue)) {\n            violationMessage.append(variableName).append(\": \");\n            violationMessage.append(recordedValue).append(\" -> \").append(currentValue).append(\"\\n\");\n        }\n    }\n    if (violationMessage.length() == 0) {\n        return null;\n    }\n    return violationMessage.toString();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n# Natural Language Annotations: /**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    MemberAccessor memberAccessor = memberAccessorMap.get(member);\n    if (memberAccessor == null) {\n        memberAccessor = new MemberAccessor(member, memberAccessorType, annotationClass, domainAccessType);\n        memberAccessorMap.put(member, memberAccessor);\n    }\n    return memberAccessor;\n}\n```", "  ```\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    MemberAccessor memberAccessor = memberAccessorMap.get(member);\n    if (memberAccessor == null) {\n        memberAccessor = new MemberAccessor(member, memberAccessorType, annotationClass, domainAccessType);\n        memberAccessorMap.put(member, memberAccessor);\n    }\n    return memberAccessor;\n}\n```", "  ```\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n        Annotation annotationClass, DomainAccessType domainAccessType) {\n    MemberAccessor memberAccessor = memberAccessorMap.get(member);\n    if (memberAccessor == null) {\n        memberAccessor = new MemberAccessor(member, memberAccessorType, annotationClass, domainAccessType);\n        memberAccessorMap.put(member, memberAccessor);\n    }\n    return memberAccessor;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String getGeneratedClassName(Member member) {\n# Natural Language Annotations: /**\n     * Returns the generated class name for a given member.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static String getGeneratedClassName(Member member) {\n    return GizmoMemberAccessorImplementor.getGeneratedClassName(member);\n}\n```", "  ```\npublic static String getGeneratedClassName(Member member) {\n    return member.getDeclaringClass().getName() + \"$\" + member.getName();\n}\n```", "  ```\npublic static String getGeneratedClassName(Member member) {\n    return GizmoMemberAccessorImplementor.getGeneratedClassName(member);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass,\n# Natural Language Annotations: /**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    if (gizmoClassLoader != null) {\n        // Use the provided classloader to load the MemberAccessor class\n        Class<?> memberAccessorClass = gizmoClassLoader.loadClass(\"MemberAccessor\");\n        // Create a new instance of the MemberAccessor class using the member and annotationClass parameters\n        MemberAccessor memberAccessor = (MemberAccessor) memberAccessorClass.getConstructor(Member.class, Class.class).newInstance(member, annotationClass);\n        return memberAccessor;\n    } else {\n        // Generate the MemberAccessor bytecode using Gizmo\n        byte[] memberAccessorBytecode = generateMemberAccessorBytecode(member, annotationClass, returnTypeRequired);\n        // Load the generated bytecode into a classloader\n        ClassLoader gizmoClassLoader = new ClassLoader() {\n            @Override\n            public Class<?> findClass(String name) {\n                if (name.equals(\"MemberAccessor\")) {\n                    return defineClass(name, memberAccessorBytecode, 0, memberAccessorBytecode.length);\n                } else {\n                    return super.findClass(name);\n                }\n            }\n        };\n        // Create a new instance of the MemberAccessor class using the member and annotationClass parameters\n        MemberAccessor memberAccessor = (MemberAccessor) gizmoClassLoader.loadClass(\"MemberAccessor\").getConstructor(Member.class, Class.class).newInstance(member, annotationClass);\n        return memberAccessor;\n    }\n}\n```", "  ```\nreturn new MemberAccessor(member, annotationClass, returnTypeRequired, gizmoClassLoader) {\n    @Override\n    protected void generate(Gizmo gizmo) {\n        // Generate the bytecode for the member accessor\n        // ...\n    }\n};\n```", "  ```\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    if (gizmoClassLoader == null) {\n        gizmoClassLoader = ClassLoader.getSystemClassLoader();\n    }\n    MemberAccessor accessor = null;\n    try {\n        accessor = (MemberAccessor) gizmoClassLoader.loadClass(MemberAccessor.class.getName()).newInstance();\n    } catch (Exception e) {\n        // handle exception\n    }\n    if (accessor == null) {\n        // generate bytecode for the member\n        accessor = new MemberAccessor(member, annotationClass, returnTypeRequired);\n    }\n    return accessor;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n# Natural Language Annotations: /**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nvoid set(Solution bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```", "  ```\nvoid set(Solution bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```", "  ```\nvoid set(Solution bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n# Natural Language Annotations: /**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nreturn solver.addProblemChange(problemChange);\n```", "  ```\nreturn CompletableFuture.completedFuture(null);\n```", "  ```\nreturn solver.addProblemChange(problemChange);\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static long nextLong(Random random, long n) {\n# Natural Language Annotations: /**\n     * Mimics {@link Random#nextInt(int)} for longs.\n     *\n     * @param random never null\n     * @param n {@code > 0L}\n     * @return like {@link Random#nextInt(int)} but for a long\n     * @see Random#nextInt(int)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static long nextLong(Random random, long n) {\n    return random.nextInt((int) n);\n}\n```", "  ```\npublic static long nextLong(Random random, long n) {\n    return random.nextInt((int) n);\n}\n```", "  ```\npublic static long nextLong(Random random, long n) {\n    return random.nextInt((int) n);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic double calculateSolverTimeGradient(SolverScope<Solver> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        if (termination.getTimeGradient() != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, termination.getTimeGradient());\n        }\n    }\n    return minTimeGradient;\n}\n```", "  ```\npublic double calculateSolverTimeGradient(SolverScope<Solver> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient >= 0.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient;\n}\n```", "  ```\npublic double calculateSolverTimeGradient(SolverScope<Solver> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient >= 0.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\ndouble calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minimumTimeGradient = Double.POSITIVE_INFINITY;\n    for (Termination termination : phaseScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minimumTimeGradient = Math.min(minimumTimeGradient, timeGradient);\n        }\n    }\n    return minimumTimeGradient;\n}\n```", "  ```\ndouble timeGradient = Double.MAX_VALUE;\nfor (Termination termination : phaseScope.getPhase().getTerminationSet()) {\n    if (termination.getTimeGradient() != -1.0) {\n        timeGradient = Math.min(timeGradient, termination.getTimeGradient());\n    }\n}\nreturn timeGradient;\n```", "  ```\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minimumTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : phaseScope.getTerminationList()) {\n        double timeGradient = termination.calculateTimeGradient(phaseScope);\n        if (timeGradient >= 0.0) {\n            minimumTimeGradient = Math.min(minimumTimeGradient, timeGradient);\n        }\n    }\n    return minimumTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic double calculateSolverTimeGradient(SolverScope<Solver> solverScope) {\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```", "  ```\ndouble calculateSolverTimeGradient(SolverScope<Solver> solverScope) {\n    double maxTimeGradient = -Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient > maxTimeGradient && timeGradient != -1.0) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```", "  ```\npublic double calculateSolverTimeGradient(SolverScope<Solver> solverScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination termination : solverScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination<Solution_> termination : phaseScope.getTerminationList()) {\n        double timeGradient = termination.calculateTimeGradient(phaseScope.getWorkingSolution());\n        if (timeGradient >= 0.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```", "  ```\ndouble calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : phaseScope.getTerminationList()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient == -1.0) {\n            continue;\n        }\n        maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n    }\n    return maxTimeGradient;\n}\n```", "  ```\nprivate double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : phaseScope.getTerminationList()) {\n        double timeGradient = termination.calculateTimeGradient(phaseScope.getWorkingSolution());\n        if (timeGradient >= 0.0 && timeGradient > maxTimeGradient) {\n            maxTimeGradient = timeGradient;\n        }\n    }\n    return maxTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n# Natural Language Annotations: /**\n     * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n     * <br />\n     * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n     * unique elements (p_1, p_2, ..., p_k) where\n     * <ul>\n     * <li>p_1 maps to p_2 in the permutation</li>\n     * <li>p_2 maps to p_3 in the permutation</li>\n     * <li>p_(k-1) maps to p_k in the permutation</li>\n     * <li>p_k maps to p_1 in the permutation</li>\n     * <li>In general: p_i maps to p_(i+1) in the permutation</li>\n     * </ul>\n     * For instance, the permutation\n     * <ul>\n     * <li>1 -> 2</li>\n     * <li>2 -> 3</li>\n     * <li>3 -> 1</li>\n     * <li>4 -> 5</li>\n     * <li>5 -> 4</li>\n     * </ul>\n     * can be expressed as `(1, 2, 3)(4, 5)`.\n     *\n     * @return The {@link KOptCycle} corresponding to the permutation described by\n     *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n     * @param kOptDescriptor The descriptor to calculate cycles for\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    List<List<Integer>> cycles = new ArrayList<>();\n    for (int i = 0; i < kOptDescriptor.removedEdgeIndexToTourOrder().size(); i++) {\n        List<Integer> cycle = new ArrayList<>();\n        int current = kOptDescriptor.removedEdgeIndexToTourOrder().get(i);\n        do {\n            cycle.add(current);\n            current = kOptDescriptor.removedEdgeIndexToTourOrder().get(current);\n        } while (current != kOptDescriptor.removedEdgeIndexToTourOrder().get(i));\n        cycles.add(cycle);\n    }\n    return new KOptCycle(cycles);\n}\n```", "  ```\nKOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    List<Integer> removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    List<Integer> permutation = new ArrayList<>(removedEdgeIndexToTourOrder.size());\n    for (int i = 0; i < removedEdgeIndexToTourOrder.size(); i++) {\n        permutation.add(removedEdgeIndexToTourOrder.get(i));\n    }\n    KOptCycle cycles = new KOptCycle();\n    for (int i = 0; i < permutation.size(); i++) {\n        int current = permutation.get(i);\n        int next = permutation.get((i + 1) % permutation.size());\n        if (current != next) {\n            cycles.add(new KOptCycle(current, next));\n        }\n    }\n    return cycles;\n}\n```", "  ```\npublic static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    // Calculate the disjoint k-cycles for the permutation\n    List<KOptCycle> cycles = new ArrayList<>();\n    for (int i = 0; i < kOptDescriptor.removedEdgeIndexToTourOrder().size(); i++) {\n        int currentIndex = kOptDescriptor.removedEdgeIndexToTourOrder().get(i);\n        int nextIndex = kOptDescriptor.removedEdgeIndexToTourOrder().get((i + 1) % kOptDescriptor.removedEdgeIndexToTourOrder().size());\n        if (currentIndex != nextIndex) {\n            cycles.add(new KOptCycle(currentIndex, nextIndex));\n        }\n    }\n    return cycles;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n# Natural Language Annotations: /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"listSize must be greater than or equal to minimumSubListSize\");\n    }\n    int index = ThreadLocalRandom.current().nextInt(listSize);\n    return elements.get(index);\n}\n```", "  ```\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"listSize must be greater than or equal to minimumSubListSize\");\n    }\n    return triangleList.get(random.nextInt(listSize));\n}\n```", "  ```\npublic TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n    if (listSize < minimumSubListSize) {\n        throw new IllegalArgumentException(\"List size must be at least \" + minimumSubListSize);\n    }\n    int subListSize = ThreadLocalRandom.current().nextInt(minimumSubListSize, listSize + 1);\n    List<TriangleElement> subList = new ArrayList<>(subListSize);\n    for (int i = 0; i < subListSize; i++) {\n        subList.add(new TriangleElement(ThreadLocalRandom.current().nextInt(listSize)));\n    }\n    return subList.get(ThreadLocalRandom.current().nextInt(subListSize));\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true)    public List<Object> getJustificationList() {\n# Natural Language Annotations: /**\n     * Return a list of justifications for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n     * (eg. [A, B] for a bi stream),\n     * unless a custom justification mapping was provided, in which case it throws an exception,\n     * pointing users towards {@link #getJustification()}.</li>\n     * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    if (constraintStream) {\n        if (customJustificationMapping) {\n            throw new UnsupportedOperationException(\"Please use getJustification() instead.\");\n        } else {\n            return getMatchingTuple();\n        }\n    } else {\n        return getCalculator().getJustification();\n    }\n}\n```", "  ```\npublic List<Object> getJustificationList() {\n    if (isConstraintStream()) {\n        return getJustificationMapping().orElseThrow(() -> new IllegalStateException(\"Custom justification mapping not provided.\"));\n    } else {\n        return getIndictedObjectList();\n    }\n}\n```", "  ```\npublic List<Object> getJustificationList() {\n    if (this instanceof ConstraintStream) {\n        // For constraint streams, return a list of facts from the matching tuple\n        // unless a custom justification mapping was provided\n        if (getCustomJustificationMapping() != null) {\n            throw new IllegalStateException(\"Custom justification mapping is not supported\");\n        }\n        return getMatchingTuple();\n    } else {\n        // For incremental score calculation, return what the calculator is implemented to return\n        return getCalculator().getJustification();\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>            UniConstraintCollector<A, ?, Result_> compose(\n# Natural Language Annotations: /**\n     * Returns a constraint collector the result of which is a composition of other constraint collectors.\n     * The return value of this collector, incl. the default return value, depends solely on the compose function.\n     *\n     * @param subCollector1 never null, first collector to compose\n     * @param subCollector2 never null, second collector to compose\n     * @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n            UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n            UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n            Function<Tuple2<SubResult1_, SubResult2_>, Result_> composeFunction) {\n    return new UniConstraintCollector<>() {\n        @Override\n        public void accept(A a, SubResultContainer1_ subResultContainer1, SubResultContainer2_ subResultContainer2) {\n            subCollector1.accept(a, subResultContainer1);\n            subCollector2.accept(a, subResultContainer2);\n        }\n\n        @Override\n        public Result_ getResult() {\n            SubResult1_ subResult1 = subCollector1.getResult();\n            SubResult2_ subResult2 = subCollector2.getResult();\n            return composeFunction.apply(new Tuple2<>(subResult1, subResult2));\n        }\n\n        @Override\n        public void merge(Result_ result, SubResultContainer1_ subResultContainer1, SubResultContainer2_ subResultContainer2) {\n            subCollector1.merge(result, subResultContainer1);\n            subCollector2.merge(result, subResultContainer2);\n        }\n    };\n}\n```", "  ```\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\nUniConstraintCollector<A, ?, Result_> compose(\n        UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n        UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n        BiFunction<SubResultContainer1_, SubResultContainer2_, Result_> composeFunction) {\n    return new UniConstraintCollector<A, ?, Result_>() {\n        @Override\n        public void collect(A a, SubResultContainer1_ subResult1, SubResultContainer2_ subResult2) {\n            subCollector1.collect(a, subResult1);\n            subCollector2.collect(a, subResult2);\n        }\n\n        @Override\n        public Result_ getResult() {\n            return composeFunction.apply(subCollector1.getResult(), subCollector2.getResult());\n        }\n\n        @Override\n        public void reset() {\n            subCollector1.reset();\n            subCollector2.reset();\n        }\n    };\n}\n```", "  ```\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\nUniConstraintCollector<A, ?, Result_> compose(\n        UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n        UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n        BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return new UniConstraintCollector<A, ?, Result_>() {\n        @Override\n        public void collect(A tuple, SubResultContainer1_ subResultContainer1, SubResultContainer2_ subResultContainer2) {\n            subCollector1.collect(tuple, subResultContainer1);\n            subCollector2.collect(tuple, subResultContainer2);\n        }\n\n        @Override\n        public Result_ getResult() {\n            return composeFunction.apply(subCollector1.getResult(), subCollector2.getResult());\n        }\n\n        @Override\n        public SubResultContainer1_ getSubResultContainer1() {\n            return subCollector1.getSubResultContainer();\n        }\n\n        @Override\n        public SubResultContainer2_ getSubResultContainer2() {\n            return subCollector2.getSubResultContainer();\n        }\n    };\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>            toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n# Natural Language Annotations: /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n     *                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n     *                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n    UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\n    toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n                      Function<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return ConstraintCollectors.toConnectedRanges(startInclusiveMap, endExclusiveMap, differenceFunction);\n}\n```", "  ```\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n    UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\n    toConnectedRanges(Function<A, PointType_> startInclusiveMap,\n                      Function<A, PointType_> endExclusiveMap,\n                      BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return new UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>() {\n        @Override\n        public Supplier<ConnectedRangeChain<A, PointType_, DifferenceType_>> supplier() {\n            return ConnectedRangeChain::new;\n        }\n\n        @Override\n        public BiConsumer<ConnectedRangeChain<A, PointType_, DifferenceType_>, A> accumulator() {\n            return (chain, fact) -> {\n                PointType_ start = startInclusiveMap.apply(fact);\n                PointType_ end = endExclusiveMap.apply(fact);\n                DifferenceType_ length = differenceFunction.apply(start, end);\n                chain.addRange(start, end, length);\n            };\n        }\n\n        @Override\n        public BinaryOperator<ConnectedRangeChain<A, PointType_, DifferenceType_>> combiner() {\n            return (chain1, chain2) -> {\n                chain1.addAll(chain2);\n                return chain1;\n            };\n        }\n\n        @Override\n        public Function<ConnectedRangeChain<A, PointType_, DifferenceType_>, ConnectedRangeChain<A, PointType_, DifferenceType_>> finisher() {\n            return chain -> chain;\n        }\n\n        @Override\n        public Set<Characteristics> characteristics() {\n            return Collections.emptySet();\n        }\n    };\n}\n```", "  ```\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n    UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\n    toConnectedRanges(Function<A, PointType_> startInclusiveMap,\n                      Function<A, PointType_> endExclusiveMap,\n                      BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n  return UniConstraintCollector.of(\n      () -> new ConnectedRangeChain<>(startInclusiveMap, endExclusiveMap, differenceFunction),\n      (chain, fact) -> chain.add(fact),\n      chain -> chain.toConnectedRanges());\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n# Natural Language Annotations: /**\n     * Compare this {@link ScoreAnalysis} to another {@link ScoreAnalysis}\n     * and retrieve the difference between them.\n     * The comparison is in the direction of {@code this - other}.\n     * <p>\n     * Example: if {@code this} has a score of 100 and {@code other} has a score of 90,\n     * the returned {@link ScoreAnalysis#score} will be 10.\n     * If this and other were inverted, the score would have been -10.\n     * The same applies to all other properties of {@link ScoreAnalysis}.\n     *\n     * <p>\n     * In order to properly diff {@link MatchAnalysis} against each other,\n     * we rely on the user implementing {@link ConstraintJustification} equality correctly.\n     * In other words, the diff will consider two justifications equal if the user says they are equal,\n     * and it expects the hash code to be consistent with equals.\n     *\n     * <p>\n     * If one {@link ScoreAnalysis} provides {@link MatchAnalysis} and the other doesn't, exception is thrown.\n     * Such {@link ScoreAnalysis} instances are mutually incompatible.\n     *\n     * @param other never null\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    ScoreAnalysis<Score_> result = new ScoreAnalysis<>();\n\n    // Check if both ScoreAnalysis instances have MatchAnalysis\n    if (this.matchAnalysis != null && other.matchAnalysis != null) {\n        // Compare MatchAnalysis using ConstraintJustification equality\n        if (this.matchAnalysis.getJustification().equals(other.matchAnalysis.getJustification())) {\n            // If MatchAnalysis is equal, compare the other properties\n            result.score = this.score - other.score;\n            result.matchAnalysis = this.matchAnalysis;\n        } else {\n            // If MatchAnalysis is not equal, throw an exception\n            throw new IllegalArgumentException(\"Mutually incompatible ScoreAnalysis instances\");\n        }\n    } else {\n        // If one ScoreAnalysis does not have MatchAnalysis, throw an exception\n        throw new IllegalArgumentException(\"Mutually incompatible ScoreAnalysis instances\");\n    }\n\n    return result;\n}\n```", "  ```\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    ScoreAnalysis<Score_> diff = new ScoreAnalysis<>();\n    diff.setScore(this.score - other.score);\n    diff.setMatchAnalysis(this.matchAnalysis.diff(other.matchAnalysis));\n    return diff;\n}\n```", "  ```\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    ScoreAnalysis<Score_> result = new ScoreAnalysis<>();\n    result.score = this.score - other.score;\n    result.matchAnalysis = this.matchAnalysis.diff(other.matchAnalysis);\n    return result;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, provide this information in a UI or a service,\n     * use {@link ScoreAnalysis#constraintAnalyses()}\n     * and convert those into a domain-specific API.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"The solution is \");\n    if (isFeasible()) {\n        sb.append(\"feasible\");\n    } else {\n        sb.append(\"infeasible\");\n    }\n    sb.append(\" because of the following constraints:\");\n    for (ConstraintAnalysis constraintAnalysis : constraintAnalyses()) {\n        sb.append(constraintAnalysis.toString());\n    }\n    return sb.toString();\n}\n```", "  ```\npublic String summarize() {\n    // Build the diagnostic text\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"Score quality: \").append(score.getQuality());\n    sb.append(\"\\n\");\n    sb.append(\"Feasible: \").append(score.isFeasible());\n    sb.append(\"\\n\");\n    sb.append(\"Constraints causing the score quality:\");\n    sb.append(\"\\n\");\n    for (Constraint constraint : score.getConstraints()) {\n        sb.append(constraint.getName()).append(\": \").append(constraint.getWeight());\n        sb.append(\"\\n\");\n    }\n    return sb.toString();\n}\n```", "  ```\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"This solution is infeasible because the following constraints are conflicting: \" +\n            String.join(\", \", constraintAnalyses().stream()\n                    .filter(ca -> !ca.isSatisfied())\n                    .map(ca -> ca.getConstraint().getName())\n                    .collect(Collectors.toList()));\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"This method analyzes the score quality using the ConstraintAnalysis API and returns a diagnostic text that explains part of the score quality.\";\n}\n```", "  ```\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"Diagnostic text that explains part of the score quality through the ConstraintAnalysis API.\";\n}\n```", "  ```\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"The score quality is \" + constraintAnalysis.getQuality() + \" out of 1.0, indicating the quality of the solution.\";\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n# Natural Language Annotations: /**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    decimalFormat.setLocale(locale);\n    return decimalFormat.format(number);\n}\n```", "  ```\npublic static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    decimalFormat.setLocale(locale);\n    return decimalFormat.format(number);\n}\n```", "  ```\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    decimalFormat.setLocale(locale);\n    return decimalFormat.format(number);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true, since = \"1.6.0\")    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n# Natural Language Annotations: /**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n     * unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n     *        {@link #getSolverStatus(Object) to get the status} or if the problem changes while solving.\n     * @param problemFinder never null, a function that returns a {@link PlanningSolution}, usually with uninitialized planning\n     *        variables\n     * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n     * @deprecated It is recommended to use {@link #solveBuilder()} while also providing a consumer for the best solution\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n                                                        Function<ProblemId_, PlanningSolution> problemFinder,\n                                                        Consumer<Solution_> bestSolutionConsumer) {\n    return solveBuilder()\n            .withProblemId(problemId)\n            .withProblemFinder(problemFinder)\n            .withBestSolutionConsumer(bestSolutionConsumer)\n            .build();\n}\n```", "  ```\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n                                                        Function<ProblemId_, PlanningSolution> problemFinder,\n                                                        Consumer<PlanningSolution> bestSolutionConsumer) {\n    return solveBuilder().withProblemId(problemId)\n                        .withProblemFinder(problemFinder)\n                        .withBestSolutionConsumer(bestSolutionConsumer)\n                        .build();\n}\n```", "  ```\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n                                                        Function<ProblemId_, PlanningSolution> problemFinder,\n                                                        Consumer<PlanningSolution> bestSolutionConsumer) {\n    return null;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n# Natural Language Annotations: /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    return withSpentLimit(spentLimit);\n}\n```", "  ```\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    TerminationConfig.withSpentLimit(spentLimit);\n    return this;\n}\n```", "  ```\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    return withSpentLimit(spentLimit);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T meldProperty(T a, T b) {\n# Natural Language Annotations: /**\n     * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n     * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n     * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n     * property of the benchmark that didn't fail.\n     * <p>\n     * Null-handling:\n     * <ul>\n     * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n     * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n     * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n     * {@link #mergeProperty(Object, Object)}</li>\n     * </ul>\n     *\n     * @see #mergeProperty(Object, Object)\n     * @param a property {@code a}\n     * @param b property {@code b}\n     * @param <T> the type of property {@code a} and {@code b}\n     * @return sometimes null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["  ```\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b == null) {\n        return a;\n    } else if (a == null && b != null) {\n        return b;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```", "  ```\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b == null) {\n        return a;\n    } else if (a == null && b != null) {\n        return b;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```", "  ```\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b == null) {\n        return a;\n    } else if (a == null && b != null) {\n        return b;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```"]}}