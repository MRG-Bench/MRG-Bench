{"litestar-litestar/file_system.py-info": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n# Natural Language Annotations: \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\nfrom typing import Any, Dict, Union\nfrom pathlib import Path\n\nPathType = Union[str, Path]\n\nclass FileInfo(Dict[str, Any]):\n    pass\n\nclass FileInspector:\n    async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n        file_info = FileInfo()\n        \n        if isinstance(path, str):\n            path = Path(path)\n        \n        try:\n            stat_info = os.stat(path)\n            \n            file_info['size'] = stat_info.st_size\n            file_info['creation_time'] = stat_info.st_ctime\n            file_info['modification_time'] = stat_info.st_mtime\n            file_info['path'] = str(path)\n            file_info['is_file'] = path.is_file()\n            file_info['is_dir'] = path.is_dir()\n            \n            # Include other kwargs if provided, otherwise ignore\n            for key, value in kwargs.items():\n                file_info[key] = value\n            \n        except FileNotFoundError:\n            file_info['error'] = 'File not found'\n        \n        return file_info\n```"]}, "litestar-litestar/typing.py-has_inner_subclass_of": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n# Natural Language Annotations: \"\"\"Whether any generic args are a subclass of the given type.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether any of the type's generic args are a subclass of the given type.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any\n\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    # Check if the class has the attribute '__orig_bases__' which contains generic args for generic classes \n    if not hasattr(self, '__orig_bases__'):\n        return False\n\n    # Extract the generic arguments\n    generic_args = self.__orig_bases__\n\n    # Iterate over each generic argument to check if it is a subclass of cl\n    for arg in generic_args:\n        try:\n            if issubclass(arg, cl):\n                return True\n        except TypeError:\n            # In case arg is not a class or a proper type to check with issubclass\n            continue\n\n    return False\n```"]}, "litestar-litestar/typing.py-get_type_hints": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the type hints for the annotation.\n\n        Args:\n            include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n            resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n        Returns:\n            The type hints.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport inspect\nimport typing\nfrom typing import Any, get_type_hints as original_get_type_hints, TypeVar\n\nT = TypeVar('T')\n\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    # Create a local utility function to resolve generic types if needed\n    def resolve_generic_type(hint):\n        if isinstance(hint, typing._GenericAlias) and hasattr(hint, '__origin__'):\n            origin = hint.__origin__\n            args = hint.__args__\n            return origin[tuple(resolve_generic_type(arg) for arg in args)]\n        return hint\n\n    # Getting type hints considering include_extras parameter\n    local_vars = vars(self)\n    type_hints = original_get_type_hints(self, localns=local_vars, include_extras=include_extras)\n\n    # Resolve generics if required\n    if resolve_generics:\n        resolved_hints = {k: resolve_generic_type(v) for k, v in type_hints.items()}\n        return resolved_hints\n\n    return type_hints\n```\n"]}, "litestar-litestar/typing.py-from_kwarg": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_kwarg(\n# Natural Language Annotations: \"\"\"Create a new FieldDefinition instance.\n\n        Args:\n            annotation: The type of the kwarg.\n            name: Field name.\n            default: A default value.\n            inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n            kwarg_definition: Kwarg Parameter.\n            extra: A mapping of extra values.\n\n        Returns:\n            FieldDefinition instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass FieldDefinition:\n    \"\"\"\n    A class to represent the definition of a field. This is a placeholder implementation.\n    Assume that FieldDefinition takes the same parameters in its constructor as the args.\n    \"\"\"\n    def __init__(self, annotation, name, default=None, inner_types=(), kwarg_definition=None, extra=None):\n        self.annotation = annotation\n        self.name = name\n        self.default = default\n        self.inner_types = inner_types\n        self.kwarg_definition = kwarg_definition\n        self.extra = extra or {}\n\ndef from_kwarg(annotation, name, default=None, inner_types=(), kwarg_definition=None, extra=None):\n    return FieldDefinition(\n        annotation=annotation,\n        name=name,\n        default=default,\n        inner_types=inner_types,\n        kwarg_definition=kwarg_definition,\n        extra=extra\n    )\n```"]}, "litestar-litestar/typing.py-from_parameter": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n# Natural Language Annotations: \"\"\"Initialize ParsedSignatureParameter.\n\n        Args:\n            parameter: inspect.Parameter\n            fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n                :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n        Returns:\n            ParsedSignatureParameter.\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom inspect import Parameter\nfrom typing import Any\n\nclass FieldDefinition:\n    def __init__(self, name: str, type_hint: Any, default: Any):\n        self.name = name\n        self.type_hint = type_hint\n        self.default = default\n\n    def __repr__(self):\n        return f\"FieldDefinition(name={self.name}, type_hint={self.type_hint}, default={self.default})\"\n\nclass ParsedSignatureParameter:\n    @classmethod\n    def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n        name = parameter.name\n        # Get type hint from provided type hints mapping or fallback to `inspect._empty` if not available\n        type_hint = fn_type_hints.get(name, parameter.empty)\n        # Get default value from parameter or `inspect._empty` if not set\n        default = parameter.default if parameter.default is not parameter.empty else None\n\n        return FieldDefinition(name, type_hint, default)\n```\n"]}, "litestar-litestar/_openapi/responses.py-create_success_response": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_success_response(self) -> OpenAPIResponse:\n# Natural Language Annotations: \"\"\"Create the schema for a success response.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom dataclasses import dataclass\nfrom typing import Any, Dict\n\n@dataclass\nclass OpenAPIResponse:\n    description: str\n    content: Dict[str, Any]\n\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"\n    Create the schema for a success response.\n\n    Returns:\n        OpenAPIResponse: An object representing the success response schema.\n    \"\"\"\n    response_description = \"A successful response.\"\n    response_content = {\n        \"application/json\": {\n            \"schema\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"status\": {\"type\": \"string\", \"example\": \"success\"},\n                    \"data\": {\"type\": \"object\", \"additionalProperties\": True}\n                },\n                \"required\": [\"status\", \"data\"]\n            }\n        }\n    }\n    \n    return OpenAPIResponse(description=response_description, content=response_content)\n```"]}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n# Natural Language Annotations: \"\"\"Create the schema for additional responses, if any.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Iterator, Tuple\nfrom fastapi.openapi.models import OpenAPIResponse\n\nclass ResponseCreator:\n\n    def create_additional_responses(self) -> Iterator[Tuple[str, OpenAPIResponse]]:\n        \"\"\"Create the schema for additional responses, if any.\"\"\"\n        # Example response schema; modify this to fit your specific additional responses\n        additional_responses = {\n            \"400\": {\n                \"description\": \"Bad Request\",\n                \"content\": {\n                    \"application/json\": {\n                        \"example\": {\"detail\": \"Invalid request payload\"}\n                    }\n                }\n            },\n            \"404\": {\n                \"description\": \"Not Found\",\n                \"content\": {\n                    \"application/json\": {\n                        \"example\": {\"detail\": \"Resource not found\"}\n                    }\n                }\n            },\n            \"500\": {\n                \"description\": \"Internal Server Error\",\n                \"content\": {\n                    \"application/json\": {\n                        \"example\": {\"detail\": \"Unexpected error occurred\"}\n                    }\n                }\n            }\n        }\n        \n        # Yield each HTTP status code and its corresponding OpenAPIResponse object\n        for status_code, schema in additional_responses.items():\n            yield status_code, OpenAPIResponse(**schema)\n```\n"]}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_path_item(self) -> PathItem:\n# Natural Language Annotations: \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n        Returns:\n            A PathItem instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom dataclasses import dataclass, field\nfrom typing import Dict, Callable, Any\n\n@dataclass\nclass Operation:\n    summary: str\n    description: str\n    parameters: list\n    responses: dict\n\n@dataclass\nclass PathItem:\n    operations: Dict[str, Operation] = field(default_factory=dict)\n\nclass RouteParser:\n    def __init__(self, route: str, methods: Dict[str, Dict[str, Any]]):\n        self.route = route\n        self.methods = methods\n\n    def create_operation(self, http_method: str, specs: Dict[str, Any]) -> Operation:\n        return Operation(\n            summary=specs.get('summary', ''),\n            description=specs.get('description', ''),\n            parameters=specs.get('parameters', []),\n            responses=specs.get('responses', {})\n        )\n    \n    def create_path_item(self) -> PathItem:\n        path_item = PathItem()\n        for method, specs in self.methods.items():\n            operation = self.create_operation(method, specs)\n            path_item.operations[method.lower()] = operation\n        return path_item\n```\n"]}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n# Natural Language Annotations: \"\"\"Create a Schema for a given FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Union\n\nclass Schema:\n    def __init__(self, type_: str):\n        self.type = type_\n\nclass Reference:\n    def __init__(self, ref: str):\n        self.ref = ref\n\nclass FieldDefinition:\n    def __init__(self, field_type: str, is_reference: bool = False, ref_name: str = None):\n        self.field_type = field_type\n        self.is_reference = is_reference\n        self.ref_name = ref_name\n\nclass SchemaBuilder:\n    def for_field_definition(self, field_definition: FieldDefinition) -> Union[Schema, Reference]:\n        if field_definition.is_reference and field_definition.ref_name:\n            return Reference(ref=field_definition.ref_name)\n        else:\n            return Schema(type_=field_definition.field_type)\n```\n"]}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n# Natural Language Annotations: \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Dict\nimport re\n\nclass TypeScriptNamespace:\n    def __init__(self, typescript_code: str):\n        self.typescript_code = typescript_code\n\n    def __str__(self):\n        return self.typescript_code\n\nclass OpenAPI:\n    def __init__(self, schema: Dict[str, Any]):\n        self.schema = schema\n\ndef pascal_case(snake_str: str) -> str:\n    components = snake_str.split('_')\n    return ''.join(x.title() for x in components)\n\ndef convert_openapi_schema_to_typescript(schema: Dict[str, Any], namespace: str) -> str:\n    typescript_lines = [f\"namespace {namespace} {\"]\n    \n    if 'components' in schema and 'schemas' in schema['components']:\n        schemas = schema['components']['schemas']\n        for schema_name, schema_info in schemas.items():\n            ts_type_name = pascal_case(schema_name)\n            ts_interface = f\"export interface {ts_type_name} {{\"\n            \n            if 'properties' in schema_info:\n                for prop_name, prop_details in schema_info['properties'].items():\n                    ts_prop_name = prop_name  # In TypeScript, we might want camelCase\n                    ts_prop_type = convert_json_schema_type_to_typescript(prop_details)\n                    ts_optional = '?' if prop_details.get('nullable', False) or not prop_details.get('required', False) else ''\n                    ts_interface += f\"\\n    {ts_prop_name}{ts_optional}: {ts_prop_type};\"\n                    \n            ts_interface += \"\\n}\"\n            typescript_lines.append(ts_interface)\n    \n    typescript_lines.append(\"}\")\n    return '\\n'.join(typescript_lines)\n\ndef convert_json_schema_type_to_typescript(json_schema: Dict[str, Any]) -> str:\n    json_type = json_schema.get('type', 'any')\n    if 'enum' in json_schema:\n        return ' | '.join(f'\"{value}\"' for value in json_schema['enum'])\n    \n    type_mapping = {\n        'integer': 'number',\n        'number': 'number',\n        'string': 'string',\n        'boolean': 'boolean',\n        'array': 'Array<unknown>',\n        'object': 'Record<string, unknown>',\n        'null': 'null',\n        'any': 'any'\n    }\n    ts_type = type_mapping.get(json_type, 'any')\n    \n    if json_type == 'array' and 'items' in json_schema:\n        item_type = convert_json_schema_type_to_typescript(json_schema['items'])\n        ts_type = f\"Array<{item_type}>\"\n    \n    return ts_type\n\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    typescript_code = convert_openapi_schema_to_typescript(openapi_schema.schema, namespace)\n    return TypeScriptNamespace(typescript_code)\n```"]}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def write(self) -> str:\n# Natural Language Annotations: \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef write(self) -> str:\n    # Define the properties of the TypeScript interface object\n    key_property = \"key: string;\"\n    optional_property = \"optional?: number;\"\n    \n    # Create the TypeScript interface string representation\n    ts_interface = \"{\\n    \" + key_property + \"\\n    \" + optional_property + \"\\n}\"\n    \n    return ts_interface\n```"]}, "litestar-litestar/testing/helpers.py-create_test_client": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_test_client(\n# Natural Language Annotations: \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        route_handlers: A sequence of route handlers, which can include instances of\n            :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom litestar import Litestar\nfrom litestar.testing import TestClient\nfrom typing import Any, Callable, Optional, Sequence, Union\n\n\ndef create_test_client(\n    route_handlers: Union[Callable, Sequence[Callable]],\n    backend: str = \"asyncio\",\n    backend_options: Optional[dict] = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = True,\n    root_path: str = \"\",\n    session_config: Optional[Any] = None,\n    after_exception: Optional[Sequence[Callable]] = None,\n    after_request: Optional[Callable] = None,\n    after_response: Optional[Callable] = None,\n    allowed_hosts: Optional[Union[Sequence[str], Any]] = None,\n    before_request: Optional[Callable] = None,\n    before_send: Optional[Sequence[Callable]] = None,\n    cache_control: Optional[Any] = None,\n    compression_config: Optional[Any] = None,\n    cors_config: Optional[Any] = None,\n    csrf_config: Optional[Any] = None,\n    debug: bool = False,\n    dependencies: Optional[dict] = None,\n    dto: Optional[Any] = None,\n    etag: Optional[Any] = None,\n    event_emitter_backend: Optional[Any] = None,\n    exception_handlers: Optional[dict] = None,\n    guards: Optional[Sequence[Callable]] = None,\n    include_in_schema: bool = True,\n    lifespan: Optional[Sequence[Callable]] = None,\n    listeners: Optional[Sequence[Any]] = None,\n    logging_config: Optional[Any] = None,\n    middleware: Optional[Sequence[Any]] = None,\n    multipart_form_part_limit: Optional[int] = None,\n    on_app_init: Optional[Sequence[Callable]] = None,\n    on_shutdown: Optional[Sequence[Callable]] = None,\n    on_startup: Optional[Sequence[Callable]] = None,\n    openapi_config: Optional[Any] = None,\n    opt: Optional[dict] = None,\n    parameters: Optional[dict] = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Optional[Sequence[Any]] = None,\n    request_class: Optional[type] = None,\n    response_class: Optional[type] = None,\n    response_cookies: Optional[Sequence[Any]] = None,\n    response_headers: Optional[dict] = None,\n    response_cache_config: Optional[Any] = None,\n    return_dto: Optional[Any] = None,\n    route_handlers: Optional[Sequence[Callable]] = None,\n    security: Optional[Sequence[dict]] = None,\n    signature_namespace: Optional[dict] = None,\n    signature_types: Optional[Sequence[type]] = None,\n    state: Optional[Any] = None,\n    static_files_config: Optional[Sequence[Any]] = None,\n    stores: Optional[Union[dict, Any]] = None,\n    tags: Optional[Sequence[str]] = None,\n    template_config: Optional[Any] = None,\n    timeout: Optional[int] = None,\n    type_encoders: Optional[dict] = None,\n    websocket_class: Optional[type] = None,\n    experimental_features: Optional[Sequence[str]] = None,\n) -> TestClient:\n    app = Litestar(\n        route_handlers=route_handlers,\n        root_path=root_path,\n        session_config=session_config,\n        after_exception=after_exception,\n        after_request=after_request,\n        after_response=after_response,\n        allowed_hosts=allowed_hosts,\n        before_request=before_request,\n        before_send=before_send,\n        cache_control=cache_control,\n        compression_config=compression_config,\n        cors_config=cors_config,\n        csrf_config=csrf_config,\n        debug=debug,\n        dependencies=dependencies,\n        dto=dto,\n        etag=etag,\n        event_emitter_backend=event_emitter_backend,\n        exception_handlers=exception_handlers,\n        guards=guards,\n        include_in_schema=include_in_schema,\n        lifespan=lifespan,\n        listeners=listeners,\n        logging_config=logging_config,\n        middleware=middleware,\n        multipart_form_part_limit=multipart_form_part_limit,\n        on_app_init=on_app_init,\n        on_shutdown=on_shutdown,\n        on_startup=on_startup,\n        openapi_config=openapi_config,\n        opt=opt,\n        parameters=parameters,\n        path=path,\n        pdb_on_exception=pdb_on_exception,\n        plugins=plugins,\n        request_class=request_class,\n        response_class=response_class,\n        response_cookies=response_cookies,\n        response_headers=response_headers,\n        response_cache_config=response_cache_config,\n        return_dto=return_dto,\n        security=security,\n        signature_namespace=signature_namespace,\n        signature_types=signature_types,\n        state=state,\n        static_files_config=static_files_config,\n        stores=stores,\n        tags=tags,\n        template_config=template_config,\n        timeout=timeout,\n        type_encoders=type_encoders,\n        websocket_class=websocket_class,\n        experimental_features=experimental_features,\n    )\n\n    return TestClient(\n        app,\n        backend=backend,\n        backend_options=backend_options,\n        base_url=base_url,\n        raise_server_exceptions=raise_server_exceptions,\n    )\n```"]}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def websocket_connect(\n# Natural Language Annotations: \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport asyncio\nimport websockets\nfrom typing import List, Dict, Optional, Any\nfrom urllib.parse import urlencode\n\nclass WebSocketTestSession:\n    def __init__(self, websocket):\n        self.websocket = websocket\n    \n    # The methods here would depend on the actual WebSocketTestSession class implementation.\n\nasync def websocket_connect(\n    url: str,\n    subprotocols: Optional[List[str]] = None,\n    params: Optional[Dict[str, str]] = None,\n    headers: Optional[Dict[str, str]] = None,\n    cookies: Optional[Dict[str, str]] = None,\n    auth: Optional[Any] = None,\n    follow_redirects: bool = True,\n    timeout: Optional[int] = None,\n    extensions: Optional[Dict[str, Any]] = None\n) -> WebSocketTestSession:\n    if params:\n        query_string = urlencode(params)\n        url = f\"{url}?{query_string}\"\n\n    if cookies:\n        cookie_header = \"; \".join(f\"{key}={value}\" for key, value in cookies.items())\n        if headers:\n            headers['Cookie'] = cookie_header\n        else:\n            headers = {'Cookie': cookie_header}\n\n    if auth:\n        if headers is None:\n            headers = {}\n        headers['Authorization'] = auth\n\n    websocket = await websockets.connect(\n        uri=url, \n        subprotocols=subprotocols if subprotocols else [],\n        extra_headers=headers,\n        ping_interval=timeout\n    )\n\n    # A WebSocketTestSession instance is created to handle the connection\n    return WebSocketTestSession(websocket)\n```\n"]}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n# Natural Language Annotations: \"\"\"Create a schema object for a given pydantic model class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n    \"\"\"\n    Create a schema object for a given pydantic model class.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    # Initialize the schema object using the schema_creator and the Pydantic model class\n    schema = schema_creator.create_schema(cls=cls)\n\n    # Retrieve the field configuration or default settings\n    field_config = field_definition.get_default() if field_definition.get_default() is not None else {}\n\n    # Update schema with field-specific details from the field definition\n    field_schema = field_definition.to_schema()  # Assume the field_definition has a method to convert to schema\n    schema.update(field_schema)\n    \n    # Optionally update schema with additional configurations if needed\n    if 'title' in field_config:\n        schema['title'] = field_config['title']\n    if 'description' in field_config:\n        schema['description'] = field_config['description']\n    if 'default' in field_config:\n        schema['default'] = field_config['default']\n    if 'nullable' in field_config:\n        schema['nullable'] = field_config['nullable']\n    \n    # Return the resulting schema object\n    return schema\n```"]}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def cleanup(self) -> None:\n# Natural Language Annotations: \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n        If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport anyio\n\nclass CleanupManager:\n    def __init__(self, generators):\n        \"\"\"Initialize with a list of generator or async generator objects\"\"\"\n        self.generators = generators\n        \n    async def cleanup(self) -> None:\n        async def call_generator(gen):\n            try:\n                # Try using anext for async generators\n                await gen.__anext__()\n            except StopAsyncIteration:\n                # If StopAsyncIteration is raised, the generator is exhausted\n                pass\n            except AttributeError:\n                # If anext doesn't exist, try using next for normal generators\n                try:\n                    next(gen)\n                except StopIteration:\n                    # If StopIteration is raised, the generator is exhausted\n                    pass\n                \n        async with anyio.create_task_group() as task_group:\n            for gen in self.generators:\n                task_group.start_soon(call_generator, gen)\n```\n"]}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_route_middleware_stack(\n# Natural Language Annotations: \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Callable, Any, List, Optional\n\n# Define a type for the ASGIApp, assuming it's a callable that accepts a scope, a receive, and a send\nASGIApp = Callable[[Any, Any, Any], Any]\n\n# Define a simplified middleware signature\nMiddleware = Callable[[ASGIApp], ASGIApp]\n\ndef build_route_middleware_stack(\n    app: Any,  # The Litestar app instance\n    route: Any,  # The route that is being added\n    route_handler: ASGIApp  # The route handler that is being wrapped\n) -> ASGIApp:\n    \"\"\"\n    Construct a middleware stack that serves as the entry point for each route. \n    \"\"\"\n    \n    # Retrieve the middlewares specific to the route or app\n    # This might be an attribute or method depending on app's and route's setup\n    middlewares: List[Middleware] = getattr(app, 'middlewares', [])\n    \n    # If the route itself may have specific middlewares, append them to the list as well\n    route_middlewares: Optional[List[Middleware]] = getattr(route, 'middlewares', None)\n    if route_middlewares:\n        middlewares.extend(route_middlewares)\n\n    # Starting with the innermost handler, apply each middleware from last to first\n    asgi_app = route_handler\n    for middleware in reversed(middlewares):\n        asgi_app = middleware(asgi_app)\n        \n    return asgi_app\n```\n"]}, "litestar-litestar/utils/signature.py-from_fn": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n# Natural Language Annotations: \"\"\"Parse a function signature.\n\n        Args:\n            fn: Any callable.\n            signature_namespace: mapping of names to types for forward reference resolution\n\n        Returns:\n            ParsedSignature\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Callable, Dict, Type\nfrom inspect import signature, Signature, Parameter\n\nclass ParsedSignature:\n    def __init__(self, parameters: Dict[str, Parameter], return_annotation: Any):\n        self.parameters = parameters\n        self.return_annotation = return_annotation\n\n    def __repr__(self):\n        return f\"ParsedSignature(parameters={self.parameters}, return_annotation={self.return_annotation})\"\n\nclass SomeClass:\n    @classmethod\n    def from_fn(cls, fn: Callable, signature_namespace: Dict[str, Any]) -> 'ParsedSignature':\n        # Get the signature object for the callable\n        sig: Signature = signature(fn)\n\n        # Resolve the forward references using the provided namespace\n        parameters = {\n            name: param.replace(annotation=_resolve_forward_reference(param.annotation, signature_namespace))\n            for name, param in sig.parameters.items()\n        }\n        return_annotation = _resolve_forward_reference(sig.return_annotation, signature_namespace)\n\n        # Create an instance of the ParsedSignature class\n        return ParsedSignature(parameters=parameters, return_annotation=return_annotation)\n\ndef _resolve_forward_reference(annotation: Any, namespace: Dict[str, Any]) -> Any:\n    if isinstance(annotation, str):\n        # Attempt to resolve the forward reference\n        return namespace.get(annotation, annotation)\n    return annotation\n```\n"]}, "litestar-litestar/utils/deprecation.py-deprecated": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def deprecated(\n# Natural Language Annotations: \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport warnings\nimport inspect\nfrom functools import wraps\n\ndef deprecated(version, removal_in, alternative=None, info=None, pending=False, kind=None):\n    def decorator(func):\n        message = (f\"{func.__qualname__} is deprecated and will be removed in version {removal_in}. \"\n                   f\"Use {alternative} instead.\" if alternative else f\"{func.__qualname__} is deprecated and will be removed in version {removal_in}.\")\n        if info:\n            message += f\" {info}\"\n        warning_class = PendingDeprecationWarning if pending else DeprecationWarning\n        \n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            warnings.warn(message, category=warning_class, stacklevel=2)\n            return func(*args, **kwargs)\n        \n        return wrapper\n    \n    return decorator\n```\n"]}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n# Natural Language Annotations: \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport asyncio\nfrom typing import Callable, Awaitable, TypeVar, Any, Union\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P')\nT = TypeVar('T')\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        async def async_wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            loop = asyncio.get_event_loop()\n            partial_func = lambda: fn(*args, **kwargs)\n            return await loop.run_in_executor(None, partial_func)\n        return async_wrapper\n```"]}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, TypeVar, get_origin, get_args\n\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    # If there is no namespace, or it is empty, return the original type hint\n    if namespace is None or not namespace:\n        return type_hint\n\n    def resolve_type(t: Any) -> Any:\n        # If t is a TypeVar, find its mapping in the namespace and return it\n        origin = get_origin(t)\n        if isinstance(t, TypeVar) and t.__name__ in namespace:\n            return namespace[t.__name__]\n        \n        # For generics, iterate over its arguments and apply resolution recursively\n        if origin:\n            args = tuple(resolve_type(arg) for arg in get_args(t))\n            return origin[args]\n        \n        # If it's not a TypeVar or generic, return the type as-is\n        return t\n\n    # Create a new dict with TypeVar parameters expanded\n    expanded_type_hint = {name: resolve_type(tp) for name, tp in type_hint.items()}\n    \n    return expanded_type_hint\n```"]}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def simple_asdict(\n# Natural Language Annotations: \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom dataclasses import is_dataclass, fields\nfrom collections.abc import Iterable\n\ndef simple_asdict(obj, exclude_none=False, exclude_empty=False, convert_nested=False, exclude=None):\n    if not is_dataclass(obj):\n        raise ValueError(\"Provided object is not a dataclass instance.\")\n\n    if exclude is None:\n        exclude = set()\n        \n    result = {}\n    for field in fields(obj):\n        field_name = field.name\n        if field_name in exclude:\n            continue\n        \n        value = getattr(obj, field_name)\n        \n        if exclude_none and value is None:\n            continue\n        \n        # Assuming \"Empty\" means falsy values like empty lists, strings, etc.\n        if exclude_empty and not value:\n            continue\n        \n        if is_dataclass(value) and convert_nested:\n            result[field_name] = simple_asdict(value, exclude_none, exclude_empty, convert_nested, exclude)\n        else:\n            result[field_name] = value\n    \n    return result\n```"]}, "litestar-litestar/utils/path.py-join_paths": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def join_paths(paths: Iterable[str]) -> str:\n# Natural Language Annotations: \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\nfrom typing import Iterable\n\ndef join_paths(paths: Iterable[str]) -> str:\n    # Join paths using os.path.join\n    joined_path = os.path.join(*paths)\n    \n    # Normalize the path to remove any redundant separators and up-level references\n    normalized_path = os.path.normpath(joined_path)\n    \n    return normalized_path\n```"]}, "litestar-litestar/utils/helpers.py-get_name": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_name(value: object) -> str:\n# Natural Language Annotations: \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\ndef get_name(value: object) -> str:\n    if hasattr(value, '__name__'):\n        return value.__name__\n    elif hasattr(value, '__class__'):\n        return value.__class__.__name__\n    else:\n        return 'No name attribute available'\n```"]}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n# Natural Language Annotations: \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, TypeGuard\nfrom dataclasses import is_dataclass, dataclass\n\n# Define a protocol to represent a dataclass\nclass DataclassProtocol:\n    pass\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    # Check if the passed annotation is the type of a dataclass\n    if isinstance(annotation, type):\n        return is_dataclass(annotation)\n    return False\n```"]}, "litestar-litestar/utils/predicates.py-is_class_var": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_class_var(annotation: Any) -> bool:\n# Natural Language Annotations: \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, ClassVar, _GenericAlias\n\ndef is_class_var(annotation: Any) -> bool:\n    # Check if the annotation is an instance of ClassVar\n    if isinstance(annotation, _GenericAlias) and annotation.__origin__ is ClassVar:\n        return True\n    return False\n```"]}, "litestar-litestar/utils/module_loader.py-import_string": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def import_string(dotted_path: str) -> Any:\n# Natural Language Annotations: \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef import_string(dotted_path: str) -> Any:\n    try:\n        # Split the dotted path into module path and attribute\n        module_path, _, attribute_name = dotted_path.rpartition('.')\n        \n        # Import the module\n        module = __import__(module_path, fromlist=[attribute_name])\n        \n        # Get the attribute from the module\n        return getattr(module, attribute_name)\n    except (ImportError, AttributeError) as e:\n        # Raise ImportError if something goes wrong\n        raise ImportError(f\"Could not import {dotted_path}\") from e\n```"]}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def unsubscribe(self, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Unsubscribe from ``channels``\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Iterable\n\nclass SubscriptionManager:\n    def __init__(self):\n        self.subscribed_channels = set()\n\n    async def unsubscribe(self, channels: Iterable[str]) -> None:\n        \"\"\"Unsubscribe from ``channels``\"\"\"\n        for channel in channels:\n            if channel in self.subscribed_channels:\n                self.subscribed_channels.remove(channel)\n```"]}, "litestar-litestar/channels/backends/redis.py-publish": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport asyncio\nfrom typing import Iterable\nimport aioredis\n\nclass RedisPublisher:\n    def __init__(self, redis_uri: str):\n        self.redis_uri = redis_uri\n        self.redis = None\n\n    async def connect(self):\n        self.redis = await aioredis.create_redis_pool(self.redis_uri)\n\n    async def close(self):\n        if self.redis:\n            self.redis.close()\n            await self.redis.wait_closed()\n\n    async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n        if not self.redis:\n            raise Exception(\"Redis connection not initialized. Call 'connect' method first.\")\n        \n        # Lua script to atomically publish data to multiple channels\n        lua_script = \"\"\"\n        for i = 1, #KEYS do\n            redis.call('PUBLISH', KEYS[i], ARGV[1])\n        end\n        \"\"\"\n\n        try:\n            # Execute Lua script atomically\n            await self.redis.eval(lua_script, len(channels), *channels, data)\n        except Exception as e:\n            raise Exception(f\"An error occurred while publishing data: {str(e)}\")\n```\n"]}, "litestar-litestar/channels/backends/redis.py-stream_events": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n# Natural Language Annotations: \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport asyncio\nfrom typing import AsyncGenerator, Any, Dict, Set, Tuple\n\nclass EventStreamer:\n    def __init__(self):\n        self.subscribed_channels: Set[str] = set()\n        self.stream_sleep_no_subscriptions: int = 5000  # Example of sleeping time in milliseconds\n        self.event_queue: Dict[str, asyncio.Queue] = {}\n\n    async def subscribe(self, channel: str) -> None:\n        \"\"\"Subscribe to a channel to receive events.\"\"\"\n        if channel not in self.subscribed_channels:\n            self.subscribed_channels.add(channel)\n            self.event_queue[channel] = asyncio.Queue()\n\n    async def add_event(self, channel: str, event: Any) -> None:\n        \"\"\"Add an event to the channel's queue.\"\"\"\n        if channel in self.event_queue:\n            await self.event_queue[channel].put(event)\n\n    async def stream_events(self) -> AsyncGenerator[Tuple[str, Any], None]:\n        \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\n        while True:\n            if not self.subscribed_channels:\n                await asyncio.sleep(self.stream_sleep_no_subscriptions / 1000)  # Convert to seconds\n                continue\n\n            for channel in list(self.subscribed_channels):\n                if channel in self.event_queue and not self.event_queue[channel].empty():\n                    event = await self.event_queue[channel].get()\n                    yield (channel, event)\n```\n"]}, "litestar-litestar/channels/backends/redis.py-get_history": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n# Natural Language Annotations: \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Channel:  # Assuming this is part of a class handling channels, not shown in the signature\n    def __init__(self):\n        self.history = {}  # Dictionary holding channel: list of messages (represented as bytes)\n    \n    async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n        # Fetch the message history for a specific channel\n        messages = self.history.get(channel, [])\n        \n        # If a limit is specified, slice the list to return up to 'limit' messages\n        if limit is not None:\n            return messages[:limit]\n        \n        # If no limit is set, return all messages\n        return messages\n```\n"]}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_transfer_model_type(\n# Natural Language Annotations: \"\"\"Create a model for data transfer.\n\n        Args:\n            model_name: name for the type that should be unique across all transfer types.\n            field_definitions: field definitions for the container type.\n\n        Returns:\n            A ``BackendT`` class.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_transfer_model_type(model_name: str, field_definitions: dict):\n    # Create a dynamic class using type\n    class_attrs = {'__annotations__': field_definitions}\n    \n    # Assuming BackendT is the base class for all transfer models, we use it here\n    class_attrs['__bases__'] = (BackendT,)\n    \n    # Create the class dynamically\n    model_class = type(model_name, (BackendT,), class_attrs)\n    \n    return model_class\n\n# Assuming BackendT is defined somewhere as the base class for transfer models\nclass BackendT:\n    pass\n```\n"]}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    # Assume 'model_type' is a class or data structure that represents the data model\n    # and is already defined or imported elsewhere in the code.\n\n    # If builtins is a dictionary, treat each key-value pair as field and value to populate.\n    if isinstance(builtins, dict):\n        # Create an instance of model_type using the dictionary unpacking\n        model_instance = self.model_type(**builtins)\n        return model_instance\n\n    # If builtins is a list or a set, attempt to create multiple instances of model_type.\n    if isinstance(builtins, (list, set)):\n        model_instances = [self.model_type(**item) for item in builtins if isinstance(item, dict)]\n        return model_instances\n\n    # Raise an exception if builtins does not match expected types for population.\n    raise ValueError(\"Unsupported type for builtins. Expected a dictionary, list, or set.\")\n```\n"]}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: 'ASGIConnection') -> Any:\n    import json\n\n    # Convert the raw bytes into a string representation\n    try:\n        raw_str = raw.decode('utf-8')\n    except UnicodeDecodeError as e:\n        raise ValueError(\"Unable to decode raw bytes\") from e\n    \n    # Parse the JSON string into a Python dictionary (or list)\n    try:\n        parsed_data = json.loads(raw_str)\n    except json.JSONDecodeError as e:\n        raise ValueError(\"Unable to parse JSON from raw data.\") from e\n\n    # Assuming `model_type` has a method or constructor to create an instance from a dictionary\n    if isinstance(parsed_data, list):\n        model_instances = [self.model_type.from_dict(item) for item in parsed_data]\n    else:\n        model_instances = self.model_type.from_dict(parsed_data)\n    \n    return model_instances\n```\n"]}, "litestar-litestar/dto/_backend.py-encode_data": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def encode_data(self, data: Any) -> LitestarEncodableType:\n# Natural Language Annotations: \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Union, List, Dict\n\n# Assuming LitestarEncodableType is a type that can be a string, list, or dictionary\nLitestarEncodableType = Union[str, List, Dict]\n\nclass Encoder:\n    def encode_data(self, data: Any) -> LitestarEncodableType:\n        \"\"\"\n        Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\n        if isinstance(data, (str, List, Dict)):\n            # If data is already of a type that can be encoded, return it directly\n            return data\n        elif isinstance(data, int):\n            # Encode integers as strings\n            return str(data)\n        elif isinstance(data, float):\n            # Encode floats with a precision of 2 that also turns it into a string\n            return f\"{data:.2f}\"\n        elif isinstance(data, bool):\n            # Encode booleans as 'true' or 'false'\n            return 'true' if data else 'false'\n        elif hasattr(data, '__dict__'):\n            # For custom objects, return their dictionary representation\n            return {k: self.encode_data(v) for k, v in data.__dict__.items()}\n        else:\n            # Otherwise, attempt to use string representation\n            return str(data)\n```\n"]}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n# Natural Language Annotations: \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Union, List, Dict\n\nclass TransferType:\n    \"\"\"Placeholder for TransferType class.\"\"\"\n    def __init__(self, type_name: str, is_list: bool = False, sub_type: Any = None):\n        self.type_name = type_name\n        self.is_list = is_list\n        self.sub_type = sub_type\n\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    \n    # If the transfer type is a list, construct the annotation as a list of its subtypes\n    if transfer_type.is_list:\n        if transfer_type.sub_type:\n            sub_annotation = _create_transfer_model_type_annotation(transfer_type.sub_type)\n            return List[sub_annotation]\n        else:\n            return List[Any]\n    \n    # Map of type names to Python equivalent types\n    type_mapping = {\n        'int': int,\n        'float': float,\n        'str': str,\n        'bool': bool,\n        'dict': Dict[str, Any],  # Assuming the simplest case of a dictionary\n        'any': Any\n    }\n    \n    # Resolve the type from the mapping, defaulting to any\n    return type_mapping.get(transfer_type.type_name, Any)\n```"]}, "litestar-litestar/response/file.py-start_response": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def start_response(self, send: Send) -> None:\n# Natural Language Annotations: \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def start_response(self, send) -> None:\n    # Define the response headers and status\n    headers = [\n        (b'content-type', b'text/plain'),\n        # Add more headers as needed\n    ]\n    status_code = 200  # Example status code, replace with the appropriate one\n  \n    # Prepare the start event message\n    start_event = {\n        \"type\": \"http.response.start\",\n        \"status\": status_code,\n        \"headers\": headers\n    }\n    \n    # Emit the start event using the ASGI send function\n    await send(start_event)\n```"]}, "litestar-litestar/connection/request.py-json": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def json(self) -> Any:\n# Natural Language Annotations: \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport json\nfrom typing import Any\n\nclass Request:\n    def __init__(self, body: str):\n        self.body = body\n\n    async def json(self) -> Any:\n        \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\n        try:\n            return json.loads(self.body)\n        except json.JSONDecodeError:\n            raise ValueError(\"Invalid JSON body\")\n\n# Example usage\n# Assuming you have an async context to call this.\n# request = Request(body='{\"key\": \"value\"}')\n# json_body = await request.json()\n```"]}, "litestar-litestar/datastructures/multi_dicts.py-close": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def close(self) -> None:\n# Natural Language Annotations: \"\"\"Close all files in the multi-dict.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass MultiDict:\n    def __init__(self):\n        self.files = []\n\n    def add_file(self, file):\n        self.files.append(file)\n\n    async def close(self) -> None:\n        for file in self.files:\n            try:\n                # Check if the file is still open\n                if not file.closed:\n                    file.close()\n            except Exception as e:\n                print(f\"Error closing file: {e}\")\n\n        # Clear the files list after closing\n        self.files.clear()\n```"]}, "litestar-litestar/datastructures/url.py-from_scope": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_scope(cls, scope: Scope) -> Self:\n# Natural Language Annotations: \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n        Args:\n            scope: A scope\n\n        Returns:\n            A URL\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom urllib.parse import urlunparse\nfrom types import SimpleNamespace\n\nclass Scope(SimpleNamespace):\n    # Sample Scope class implementation for illustration; you can modify based on your actual Scope fields\n    scheme: str\n    hostname: str\n    username: str\n    password: str\n    port: int\n    path: str\n    query: str\n    fragment: str\n\n    def __init__(self, scheme='', hostname='', username='', password='', port=None, path='', query='', fragment=''):\n        self.scheme = scheme\n        self.hostname = hostname\n        self.username = username\n        self.password = password\n        self.port = port\n        self.path = path\n        self.query = query\n        self.fragment = fragment\n\nclass URL:\n    def __init__(self, url: str):\n        self.url = url\n\n    @classmethod\n    def from_scope(cls, scope: Scope) -> 'URL':\n        # Construct the network location part with optional username and password\n        if scope.username or scope.password:\n            netloc = f\"{scope.username}:{scope.password}@{scope.hostname}\"\n        else:\n            netloc = scope.hostname\n\n        # Include the port if it's specified\n        if scope.port:\n            netloc += f\":{scope.port}\"\n\n        # Construct the URL using urlunparse which combines different parts into a URL\n        url = urlunparse((scope.scheme, netloc, scope.path, '', scope.query, scope.fragment))\n        return cls(url)\n```\n"]}, "litestar-litestar/datastructures/headers.py-to_header": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_header(self, include_header_name: bool = False) -> str:\n# Natural Language Annotations: \"\"\"Get the header as string.\n\n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Header:\n    def __init__(self, header_name: str, header_value: str):\n        self.header_name = header_name\n        self.header_value = header_value\n\n    def to_header(self, include_header_name: bool = False) -> str:\n        \"\"\"\n        Get the header as string.\n        \n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\n        if include_header_name:\n            return f\"{self.header_name}: {self.header_value}\"\n        else:\n            return self.header_value\n```"]}, "litestar-litestar/middleware/session/server_side.py-delete": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def delete(self, session_id: str, store: Store) -> None:\n# Natural Language Annotations: \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n        Args:\n            session_id: The session-ID\n            store: Store to delete the session data from\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    try:\n        await store.delete_session_data(session_id)\n    except KeyError:\n        # Fails silently if no such session-ID exists\n        pass\n```"]}, "marimo-marimo/_islands/island_generator.py-add_code": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_code(\n# Natural Language Annotations: \"\"\"Add a code cell to the app.\n\n        *Args:*\n\n        - code (str): The code to add to the app.\n        - display_code (bool): Whether to display the code in the HTML.\n        - display_output (bool): Whether to display the output in the HTML.\n        - is_raw (bool): Whether to handled the code without formatting.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_code(code: str, display_code: bool, display_output: bool, is_raw: bool, is_reactive: bool) -> None:\n    # This function simulates the addition of a code cell to an application environment.\n    # It takes several parameters to determine how the code is managed and displayed.\n    \n    # The actual implementation of how to add code to the app is highly context-dependent.\n    # Here, we'll outline the procedure according to the arguments provided.\n    \n    # 1. Handling raw vs. formatted code\n    if is_raw:\n        code_to_add = code  # Handle the code exactly as provided\n    else:\n        code_to_add = format_code(code)  # Assuming there is a function to format code\n\n    # 2. Do nothing if there's no code to add\n    if not code_to_add.strip():\n        return\n\n    # 3. Display code logic\n    if display_code:\n        print(\"Adding the following code to the app (displayed in HTML):\")\n        print(code_to_add)\n\n    # 4. Execution and output display logic\n    output = \"\"\n    if is_reactive:\n        output = execute_with_pyodide(code_to_add)  # Assuming function to execute in Pyodide\n    else:\n        output = execute_code_locally(code_to_add)  # Assuming function to execute locally\n\n    if display_output:\n        print(\"Output of the code (displayed in HTML):\")\n        print(output)\n\n# Helper function stubs (these would need to be implemented appropriately for a real app)\ndef format_code(code: str) -> str:\n    # Hypothetical formatting logic\n    return code.strip()\n\ndef execute_with_pyodide(code: str) -> str:\n    # Simulate execution using Pyodide\n    # In practice, this would involve interacting with a WebAssembly environment\n    return \"Simulated Pyodide Output\"\n\ndef execute_code_locally(code: str) -> str:\n    # Simulate execution locally, e.g., using exec function\n    try:\n        exec_locals = {}\n        exec(code, {}, exec_locals)\n        return str(exec_locals)\n    except Exception as e:\n        return f\"Error executing code: {str(e)}\"\n```\n"]}, "marimo-marimo/_islands/island_generator.py-build": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def build(self) -> App:\n# Natural Language Annotations: \"\"\"\n        Build the app. This should be called after adding all the code cells.\n\n        *Returns:*\n\n        - App: The built app.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass App:\n    def __init__(self, components):\n        self.components = components\n\n    def __repr__(self):\n        return f\"App with components: {self.components}\"\n\nclass Builder:\n    def __init__(self):\n        self.code_cells = []\n\n    def add_code_cell(self, code_cell):\n        self.code_cells.append(code_cell)\n\n    async def build(self) -> App:\n        # Simulating some asynchronous operations such as compiling or validation\n        import asyncio\n        await asyncio.sleep(1)  # Simulate an async operation delay\n        # After processing, build the app with all the added code cells\n        return App(self.code_cells)\n\n# Example usage:\n# builder = Builder()\n# builder.add_code_cell(\"code snippet 1\")\n# builder.add_code_cell(\"code snippet 2\")\n# app = await builder.build()\n```\n"]}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom dataclasses import fields, is_dataclass\nfrom typing import Any, Type, TypeVar, get_type_hints\n\nT = TypeVar('T')\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    if not is_dataclass(cls):\n        raise ValueError(f\"The provided class {cls.__name__} is not a dataclass.\")\n    \n    # Getting type hints for the dataclass fields\n    type_hints = get_type_hints(cls)\n    \n    # Creating a dictionary of field names and values that match the dataclass fields\n    init_values = {}\n    for field in fields(cls):\n        if field.name in values:\n            value = values[field.name]\n            # Check for type compatibility\n            if not isinstance(value, type_hints[field.name]):\n                raise TypeError(f\"Field '{field.name}' is expected to be {type_hints[field.name]}, \"\n                                f\"got {type(value)} instead.\")\n            init_values[field.name] = value\n        elif field.default is not None:\n            init_values[field.name] = field.default\n        elif field.default_factory is not None:\n            init_values[field.name] = field.default_factory()\n        else:\n            raise ValueError(f\"Missing required field '{field.name}' for dataclass {cls.__name__}.\")\n    \n    # Instantiating the dataclass with the filtered field values\n    return cls(**init_values)\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Union, Type, TypeVar, get_type_hints\nfrom dataclasses import is_dataclass, fields as dataclass_fields\nimport json\nimport re\n\nT = TypeVar('T')\n\ndef camel_to_snake(name: str) -> str:\n    \"\"\"Convert a camelCase string to snake_case.\"\"\"\n    s1 = re.sub('([a-z0-9])([A-Z])', r'\\1_\\2', name)\n    return s1.lower()\n\ndef convert_keys_to_snake_case(d: dict) -> dict:\n    \"\"\"Recursively convert all keys in a dictionary from camelCase to snake_case.\"\"\"\n    if isinstance(d, dict):\n        return {camel_to_snake(k): convert_keys_to_snake_case(v) for k, v in d.items()}\n    elif isinstance(d, list):\n        return [convert_keys_to_snake_case(i) for i in d]\n    return d\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\"\"\"\n    if not is_dataclass(cls):\n        raise ValueError(\"cls must be a dataclass\")\n    \n    if isinstance(message, bytes):\n        try:\n            message = json.loads(message.decode('utf-8'))\n        except json.JSONDecodeError as e:\n            raise ValueError(f\"Failed to decode JSON from bytes: {e}\")\n\n    if not isinstance(message, dict):\n        raise ValueError(\"Message must be a dictionary or JSON bytes representing a dictionary\")\n\n    # Transform camelCase JSON keys to snake_case\n    message = convert_keys_to_snake_case(message)\n\n    # Extract field names from the dataclass\n    cls_fields = {field.name for field in dataclass_fields(cls)}\n    \n    # Filter the message to only include fields present in the dataclass\n    filtered_message = {k: v for k, v in message.items() if k in cls_fields}\n\n    # Get type hints for further parsing if needed\n    cls_annotations = get_type_hints(cls)\n\n    # Instantiate the dataclass\n    return cls(**filtered_message)\n```"]}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def icon(\n# Natural Language Annotations: \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Optional, Dict\n\ndef icon(icon_name: str, \n         size: Optional[int] = 24, \n         color: Optional[str] = 'black', \n         inline: Optional[bool] = True, \n         flip: Optional[str] = None, \n         rotate: Optional[int] = 0, \n         style: Optional[Dict[str, str]] = None) -> str:\n    \"\"\"\n    Displays an icon using the Iconify library.\n\n    Args:\n    - icon_name: the name of the icon to display\n    - size: the size of the icon in pixels\n    - color: the color of the icon\n    - inline: whether to display the icon inline or as a block element\n    - flip: whether to flip the icon horizontally, vertically, or both\n    - rotate: whether to rotate the icon 90, 180, or 270 degrees\n    - style: a dictionary of CSS styles to apply to the icon\n\n    Returns:\n    - An HTML string representing the icon.\n    \"\"\"\n\n    # Base style\n    base_style = {\n        \"display\": \"inline\" if inline else \"block\",\n        \"width\": f\"{size}px\",\n        \"height\": f\"{size}px\",\n        \"color\": color,\n        \"transform\": \"\"\n    }\n\n    # Handle flips\n    if flip:\n        if flip == 'horizontal' or flip == 'both':\n            base_style[\"transform\"] += \"scaleX(-1) \"\n        if flip == 'vertical' or flip == 'both':\n            base_style[\"transform\"] += \"scaleY(-1) \"\n\n    # Handle rotation\n    if rotate in [90, 180, 270]:\n        base_style[\"transform\"] += f\"rotate({rotate}deg) \"\n\n    # Add custom style\n    if style:\n        base_style.update(style)\n\n    # Inline styles applied\n    inline_styles = \"; \".join(f\"{k}: {v}\" for k, v in base_style.items() if v)\n\n    # Return the HTML element for the icon\n    return f'<span class=\"iconify\" data-icon=\"{icon_name}\" style=\"{inline_styles}\"></span>'\n```"]}, "marimo-marimo/_plugins/stateless/image.py-image": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def image(\n# Natural Language Annotations: \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef image(src, alt=None, width=None, height=None, rounded=False, style=None):\n    # Prepare the base style attributes\n    styles = style if style else {}\n    \n    # Add width and height if they are provided\n    if width:\n        styles['width'] = f\"{width}px\"\n    if height:\n        styles['height'] = f\"{height}px\"\n    \n    # Add border-radius if rounded is True\n    if rounded:\n        styles['border-radius'] = '50%' if (width and height and width == height) else '10px'\n    \n    # Construct the style string\n    style_str = \"; \".join(f\"{k}: {v}\" for k, v in styles.items())\n    \n    # Construct the HTML string\n    html_str = f'<img src=\"{src}\"'\n    \n    if alt:\n        html_str += f' alt=\"{alt}\"'\n        \n    if style_str:\n        html_str += f' style=\"{style_str}\"'\n    \n    html_str += '>'\n    \n    # Assuming Html is a class we return an instance of it.\n    # This part of implementation would depend on the framework/environment being used.\n    # Here it's assumed to be a simple wrapper class for HTML strings.\n    return Html(html_str)\n\n# Assumed Html wrapper class\nclass Html:\n    def __init__(self, content):\n        self.content = content\n\n    def __str__(self):\n        return self.content\n```"]}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def hstack(\n# Natural Language Annotations: \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef hstack(items, justify='start', align='start', wrap=False, gap=1.0, widths=None):\n    class Html:\n        # A simple representation of an HTML container for demonstration purposes.\n        def __init__(self, content):\n            self.content = content\n\n        def __str__(self):\n            return self.content\n\n    # Validate widths parameter\n    if widths is not None:\n        if isinstance(widths, str) and widths != \"equal\":\n            raise ValueError(\"widths must be 'equal', None, or a list of relative widths.\")\n        elif isinstance(widths, list) and len(widths) != len(items):\n            raise ValueError(\"The lengths of widths and items must be the same.\")\n\n    # CSS styles\n    justify_map = {\n        'start': 'flex-start',\n        'center': 'center',\n        'end': 'flex-end',\n        'space-between': 'space-between',\n        'space-around': 'space-around'\n    }\n    align_map = {\n        'start': 'flex-start',\n        'end': 'flex-end',\n        'center': 'center',\n        'stretch': 'stretch'\n    }\n    \n    css_justify = justify_map.get(justify, 'flex-start')\n    css_align = align_map.get(align, 'flex-start')\n    flex_wrap = 'wrap' if wrap else 'nowrap'\n    gap_px = f\"{gap * 16}px\"  # Convert rem to px assuming base is 16px\n\n    # Prepare widths if equal\n    if widths == \"equal\":\n        css_widths = \"1 1 0\"  # Flex grow, shrink, basis\n    elif isinstance(widths, list):\n        total_ratio = sum(widths)\n        css_widths = [f\"{(w / total_ratio) * 100}%\" for w in widths]\n    else:\n        css_widths = [None] * len(items)\n\n    # Generate HTML representation\n    content = '<div style=\"display: flex; '\n    content += f'justify-content: {css_justify}; '\n    content += f'align-items: {css_align}; '\n    content += f'flex-wrap: {flex_wrap}; '\n    content += f'gap: {gap_px};\">'\n    \n    for i, item in enumerate(items):\n        width_style = f\"flex: {css_widths[i]};\" if isinstance(css_widths, list) else \"\"\n        content += f'<div style=\"{width_style}\">{str(item)}</div>'\n\n    content += '</div>'\n\n    return Html(content)\n```"]}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def update_progress(\n# Natural Language Annotations: \"\"\"Update the progress indicator.\n\n        **Example.**\n\n        ```python\n        # Increment by 1\n        progress.update()\n\n        # Increment by 10 and update title and subtitle\n        progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n        ```\n\n        **Args.**\n\n        - increment: amount to increment by. Defaults to 1.\n        - title: new title. Defaults to None.\n        - subtitle: new subtitle. Defaults to None.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Progress:\n    def __init__(self, initial_value=0, title=None, subtitle=None):\n        self.value = initial_value\n        self.title = title\n        self.subtitle = subtitle\n\n    def update(self, increment=1, title=None, subtitle=None):\n        # Update the progress value by the increment (default is 1)\n        self.value += increment\n\n        # Update the title if a new title is provided\n        if title is not None:\n            self.title = title\n\n        # Update the subtitle if a new subtitle is provided\n        if subtitle is not None:\n            self.subtitle = subtitle\n\n        # Print or display the updated status for demonstration purposes\n        self.display_status()\n\n    def display_status(self):\n        # Display the current status of the progress\n        print(f\"Progress: {self.value}\")\n        if self.title:\n            print(f\"Title: {self.title}\")\n        if self.subtitle:\n            print(f\"Subtitle: {self.subtitle}\")\n\n# Example usage\nprogress = Progress()\nprogress.update()  # Increment by 1\nprogress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n```\n"]}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_ui_plugin(\n# Natural Language Annotations: \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef build_ui_plugin(component_name, initial_value, label, args, slotted_html):\n    # Import standard library for JSON operations\n    import json\n\n    # Start building the HTML for the component\n    html = f\"<{component_name}\"\n\n    # Add initial value as a data attribute\n    initial_value_json = json.dumps(initial_value)\n    html += f' data-initial-value=\\'{initial_value_json}\\''\n\n    # Add label as a data attribute\n    html += f' data-label=\"{label}\"'\n\n    # Add each argument as a data attribute\n    for arg_name, arg_value in args.items():\n        arg_value_json = json.dumps(arg_value)\n        html += f' data-{arg_name}=\"{arg_value_json}\"'\n\n    # Close the opening tag and add slotted HTML\n    html += f\">{slotted_html}</{component_name}>\"\n\n    # Return the constructed HTML\n    return html\n```"]}, "marimo-marimo/_output/formatting.py-as_html": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def as_html(value: object) -> Html:\n# Natural Language Annotations: \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\nfrom typing import Any\n\nclass Html(str):\n    \"\"\"A simple Html wrapper class.\"\"\"\n    pass\n\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown.\"\"\"\n    # Try to convert the value into an HTML representation.\n\n    # Check if value has a method to convert to HTML directly\n    if hasattr(value, '_repr_html_'):\n        return Html(value._repr_html_())\n\n    # Check if the value can be represented as a string, we encapsulate it in a pre tag for formatting\n    # when there's no better defined HTML representation\n    return Html(f\"<pre>{str(value)}</pre>\")\n```"]}, "marimo-marimo/_output/md.py-md": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def md(text: str) -> Html:\n# Natural Language Annotations: r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom markdown2 import markdown\nfrom typing import Any\n\nclass Html:\n    def __init__(self, html_content: str):\n        self.html_content = html_content\n        \n    def __repr__(self):\n        return self.html_content\n\ndef md(text: str) -> Html:\n    \"\"\"\n    Write markdown.\n\n    This function takes a string of markdown as input and returns an Html\n    object. \n\n    Args:\n    - `text`: a string of markdown\n\n    Returns:\n    - An `Html` object.\n    \"\"\"\n    # Convert markdown to HTML using markdown2\n    html_content = markdown(text)\n    # Return an Html object with the converted content\n    return Html(html_content)\n```"]}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_formatters() -> None:\n# Natural Language Annotations: \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport importlib\nimport sys\nfrom types import ModuleType\n\n# We'll need a registry of formatters for supported libraries\nformatters_registry = {\n    # Example support registration, actual supported libraries to be added here\n    'matplotlib': 'marimo.formatters.matplotlib',\n    'numpy': 'marimo.formatters.numpy',\n    # Add other supported third-party libraries here\n}\n\ndef register_formatter_for_module(module_name: str):\n    \"\"\"\n    Register a formatter for a given module if it exists in the registry.\n    \"\"\"\n    if module_name in formatters_registry:\n        try:\n            formatter_module = formatters_registry[module_name]\n            importlib.import_module(formatter_module)\n            print(f\"Registered formatter for {module_name} from {formatter_module}\")\n        except ImportError as e:\n            print(f\"Failed to register formatter for {module_name}: {str(e)}\")\n\nclass ImportHook:\n    \"\"\"\n    An import hook for registering formatters when a module is imported.\n    \"\"\"\n    def __init__(self):\n        self.original_import = __import__\n    \n    def __call__(self, name, globals=None, locals=None, fromlist=(), level=0):\n        module = self.original_import(name, globals, locals, fromlist, level)\n        # If the imported module is in our registry, register its formatter\n        register_formatter_for_module(name)\n        return module\n\ndef register_formatters() -> None:\n    \"\"\"\n    Hook into Python's import system to register formatters with marimo.\n    \"\"\"\n    # Replace the built-in import function with our custom hook\n    sys.meta_path.insert(0, ImportHook())\n\n# Initialize the formatter registration system\nregister_formatters()\n```\n"]}, "marimo-marimo/_data/series.py-get_category_series_info": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_category_series_info(series: Any) -> CategorySeriesInfo:\n# Natural Language Annotations: \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\nimport pandas as pd\nfrom dataclasses import dataclass\nfrom typing import Any\n\n@dataclass\nclass CategorySeriesInfo:\n    unique_values: int\n    top_value: Any\n    top_freq: int\n    top_freq_percent: float\n\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    if not isinstance(series, pd.Series):\n        raise TypeError(\"Input must be a pandas Series.\")\n\n    value_counts = series.value_counts()\n    unique_values = value_counts.size\n    top_value = value_counts.idxmax()\n    top_freq = value_counts.max()\n    top_freq_percent = (top_freq / series.size) * 100\n    \n    return CategorySeriesInfo(\n        unique_values=unique_values,\n        top_value=top_value,\n        top_freq=top_freq,\n        top_freq_percent=top_freq_percent\n    )\n```"]}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_column_preview(\n# Natural Language Annotations: \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\ndef get_column_preview(data: pd.DataFrame, column_name: str):\n    \"\"\"\n    Generates a preview of the specified column in the provided dataset.\n    \n    Args:\n    - data (pd.DataFrame): The dataset as a pandas DataFrame.\n    - column_name (str): The name of the column to preview.\n    \n    Returns:\n    - None: This function displays a plot and prints an aggregation summary.\n    \"\"\"\n    # Check if the column exists in the DataFrame\n    if column_name not in data.columns:\n        raise ValueError(f\"Column '{column_name}' not found in the dataset.\")\n    \n    # Display the first few values of the column\n    print(f\"Preview of {column_name}:\")\n    print(data[column_name].head())\n    print(\"\\n\")\n    \n    # Aggregate summary\n    print(f\"Aggregation Summary of {column_name}:\")\n    print(data[column_name].describe())\n    print(\"\\n\")\n    \n    # Check if the column is numerical or categorical\n    if pd.api.types.is_numeric_dtype(data[column_name]):\n        # Plot a histogram for numerical data\n        plt.figure(figsize=(10, 6))\n        plt.hist(data[column_name], bins=30, alpha=0.7)\n        plt.title(f\"Histogram of {column_name}\")\n        plt.xlabel(column_name)\n        plt.ylabel(\"Frequency\")\n        plt.grid(True)\n        plt.show()\n    else:\n        # Plot a bar chart for categorical data\n        plt.figure(figsize=(10, 6))\n        data[column_name].value_counts().plot(kind='bar', alpha=0.7)\n        plt.title(f\"Bar Chart of {column_name}\")\n        plt.xlabel(column_name)\n        plt.ylabel(\"Count\")\n        plt.grid(True)\n        plt.show()\n```\n"]}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start_file_watcher(self) -> Disposable:\n# Natural Language Annotations: \"\"\"Starts the file watcher if it is not already started\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Disposable:\n    def __init__(self, dispose_function):\n        self.dispose_function = dispose_function\n        \n    def dispose(self):\n        if callable(self.dispose_function):\n            self.dispose_function()\n\nclass FileWatcher:\n    def __init__(self):\n        self.watching = False\n        self.watching_disposable = None\n    \n    def start_file_watcher(self) -> Disposable:\n        \"\"\"Starts the file watcher if it is not already started\"\"\"\n        # If already watching, do nothing and return the existing disposable.\n        if self.watching:\n            return self.watching_disposable\n\n        # Start the watcher.\n        self.watching = True\n        \n        # Define the dispose logic.\n        def stop_watching():\n            self.watching = False\n            print(\"File watching stopped.\")\n\n        # Create and store the disposable object.\n        self.watching_disposable = Disposable(dispose_function=stop_watching)\n\n        # Simulated start of file watching (could be more complex in a real-world example).\n        print(\"File watching started.\")\n        \n        return self.watching_disposable\n```\n"]}, "marimo-marimo/_server/file_manager.py-save_app_config": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def save_app_config(self, config: Dict[str, Any]) -> str:\n# Natural Language Annotations: \"\"\"Save the app configuration.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport json\n\nclass AppConfigSaver:\n    def __init__(self, file_path: str):\n        self.file_path = file_path\n\n    def save_app_config(self, config: Dict[str, Any]) -> str:\n        \"\"\"Save the app configuration.\"\"\"\n        try:\n            # Convert the config dictionary to a JSON string\n            config_json = json.dumps(config, indent=4)\n            \n            # Write the JSON string to a file\n            with open(self.file_path, 'w') as config_file:\n                config_file.write(config_json)\n            \n            # Return a success message with the file path\n            return f\"Configuration successfully saved to {self.file_path}\"\n        except (IOError, json.JSONDecodeError) as e:\n            # Handle any potential errors during file I/O or JSON conversion\n            return f\"Failed to save configuration: {str(e)}\"\n```"]}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_stdin(self, stdin: str) -> None:\n# Natural Language Annotations: \"\"\"Add a stdin request to the session view.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass SessionView:\n    def __init__(self):\n        self.stdin_requests = []\n\n    def add_stdin(self, stdin: str) -> None:\n        \"\"\"Add a stdin request to the session view.\"\"\"\n        # Appending the stdin string to the list of stdin requests\n        self.stdin_requests.append(stdin)\n```"]}, "marimo-marimo/_server/session/session_view.py-add_operation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_operation(self, operation: MessageOperation) -> None:\n# Natural Language Annotations: \"\"\"Add an operation to the session view.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass MessageOperation:\n    # Assume this class has necessary attributes defined\n    pass\n\nclass SessionView:\n    def __init__(self):\n        self.operations = []  # Initialize a list to store operations\n\n    def add_operation(self, operation: MessageOperation) -> None:\n        \"\"\"Add an operation to the session view.\"\"\"\n        # Append the incoming operation to the operations list\n        self.operations.append(operation)\n```"]}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_cell_console_outputs(\n# Natural Language Annotations: \"\"\"Get the console outputs for the given cell ids.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_cell_console_outputs(cell_outputs_dict, cell_ids):\n    \"\"\"\n    Get the console outputs for the given cell ids.\n\n    Parameters:\n    - cell_outputs_dict: A dictionary where keys are cell ids (strings or integers)\n                         and values are console output (strings).\n    - cell_ids: A list of cell ids for which the console output is needed.\n\n    Returns:\n    - A dictionary with cell ids as keys for the requested ids and their corresponding \n      console outputs as values.\n    \"\"\"\n\n    # Create a dictionary for storing the results\n    result = {}\n\n    # Iterate through each cell id provided\n    for cell_id in cell_ids:\n        # Fetch the output corresponding to the cell id\n        # and add it to the result dictionary if it exists\n        if cell_id in cell_outputs_dict:\n            result[cell_id] = cell_outputs_dict[cell_id]\n\n    return result\n```"]}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n# Natural Language Annotations: \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    # Acquire the lock to ensure thread safety while mutating the graph\n    with self.lock:\n        # Check if the cell_id is already in the graph, if so, raise an exception\n        if cell_id in self.graph:\n            raise ValueError(f\"Cell ID {cell_id} is already registered in the graph.\")\n        \n        # Add the cell to the graph with the provided cell_id\n        self.graph[cell_id] = cell\n```\n"]}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check_for_errors(\n# Natural Language Annotations: \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    errors = {}\n\n    for cell_id, cell in graph.items():\n        # Example checks could include:\n        # 1. Check for invalid connections\n        if 'connections' in cell:\n            for conn in cell['connections']:\n                if conn not in graph:\n                    errors[cell_id] = errors.get(cell_id, []) + ['Invalid connection to non-existent cell {}'.format(conn)]\n\n        # 2. Check for missing required elements\n        if 'type' not in cell:\n            errors[cell_id] = errors.get(cell_id, []) + ['Missing type in cell']\n\n        # 3. Check for non-allowed circular dependencies\n        visited = set()\n\n        def has_circular_dependency(current_cell_id):\n            if current_cell_id in visited:\n                return True\n            visited.add(current_cell_id)\n            for conn in graph.get(current_cell_id, {}).get('connections', []):\n                if has_circular_dependency(conn):\n                    return True\n            visited.remove(current_cell_id)\n            return False\n\n        if has_circular_dependency(cell_id):\n            errors[cell_id] = errors.get(cell_id, []) + ['Circular dependency detected']\n\n        # 4. Any other Marimo specific rule checks can go here...\n\n    return errors\n```"]}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _maybe_register_cell(\n# Natural Language Annotations: \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _maybe_register_cell(cell_id, code, registered_cells, dependency_graph):\n    \"\"\"\n    Register a cell (given by id, code) if not already registered.\n\n    If a cell with id `cell_id` is already registered but with different\n    code, that cell is deleted from the graph and a new cell with the\n    same id but different code is registered.\n\n    Returns:\n    - a set of ids for cells that were previously children of `cell_id`;\n      only non-empty when `cell-id` was already registered but with\n      different code.\n    - an `Error` if the cell couldn't be registered, `None` otherwise\n    \"\"\"\n\n    # Check if the cell is already registered\n    if cell_id in registered_cells:\n        # Check if the registered cell has the same code\n        if registered_cells[cell_id] == code:\n            # The cell is already registered with the same code, nothing to do\n            return set(), None\n        \n        # The cell is registered but with different code\n        # Get the set of children from the dependency graph\n        children = dependency_graph.get(cell_id, set())\n\n        # Remove the cell from the registered cells and dependency graph\n        del registered_cells[cell_id]\n        if cell_id in dependency_graph:\n            del dependency_graph[cell_id]\n\n        # Register the new cell\n        registered_cells[cell_id] = code\n        dependency_graph[cell_id] = set()\n        \n        # Return the children and None as there was no error\n        return children, None\n        \n    else:\n        # Cell not registered, simply register it\n        registered_cells[cell_id] = code\n        dependency_graph[cell_id] = set()\n\n        # Return an empty set and None as there was no error\n        return set(), None\n```"]}, "marimo-marimo/_runtime/runtime.py-run": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run(\n# Natural Language Annotations: \"\"\"Run cells and their descendants.\n\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\n# Assuming there is some background knowledge about the cells, graph, and their execution context.\n# The provided 'run' function should manage these cells effectively in an asynchronous manner.\n\nfrom typing import List, Dict, Any\nimport asyncio\n\nasync def run(graph: Dict[str, Any], execution_requests: List[Dict[str, Any]]) -> None:\n    \"\"\"\n    Runs cells and their descendants.\n\n    Args:\n        graph: A dictionary containing existing cells in the graph.\n        execution_requests: A list of cells to be added to the graph and executed.\n    \"\"\"\n    \n    # Add the execution requests to the graph\n    for request in execution_requests:\n        graph[request['id']] = request\n    \n    # A function to execute a single cell, simulating it might contain top-level await\n    async def execute_cell(cell_id: str, cell_data: Dict[str, Any]) -> Any:\n        # Example: Simulating a pause to mimic awaitable behavior in top-level code\n        await asyncio.sleep(0.1)  # Simulating an asynchronous operation\n        # In this simulation context, we would replace the execution logic with actual cell execution\n        print(f\"Running cell {cell_id}\")\n        # Simulate storing an execution result (not mandatory for this example)\n        cell_data['result'] = f\"Executed {cell_id}\"\n    \n    # Recursive function to run a cell and its descendants\n    async def run_cell_and_descendants(cell_id: str) -> None:\n        descendants = graph[cell_id].get('descendants', [])\n        \n        # Run the current cell\n        await execute_cell(cell_id, graph[cell_id])\n        \n        # Recursively run all descendant cells\n        for descendant_id in descendants:\n            await run_cell_and_descendants(descendant_id)\n\n    # Start the execution process for each requested cell\n    tasks = [run_cell_and_descendants(request['id']) for request in execution_requests]\n    await asyncio.gather(*tasks)\n```\n"]}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_python_isolated() -> bool:\n# Natural Language Annotations: \"\"\"Returns True if not using system Python\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\nimport sys\n\ndef is_python_isolated() -> bool:\n    # Check if the Python executable path indicates a virtual environment or if it's a common location for system-wide installations.\n    executable_path = sys.executable\n    # List of common system paths in Unix-like and Windows systems\n    system_paths = [\"/usr/bin/\", \"/usr/local/bin/\", \"C:\\\\Python\", \"C:\\\\Program Files\\\\Python\"]\n    \n    # Return True if the current Python executable is not located in a system path\n    return not any(executable_path.startswith(path) for path in system_paths)\n```"]}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def missing_modules(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Modules that will fail to import.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef missing_modules(self) -> set[str]:\n    import importlib.util\n    \n    # List of modules that this script will attempt to check if they can be imported\n    module_names = [\"module1\", \"module2\", \"module3\"]  # You should replace these with actual module names you want to check\n\n    # This set will hold the names of modules that fail to import\n    missing = set()\n\n    for module_name in module_names:\n        if not importlib.util.find_spec(module_name):\n            missing.add(module_name)\n\n    return missing\n```"]}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def load_examples(\n# Natural Language Annotations: \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\n\ndef load_examples(folder, role_set):\n    examples = []\n    for filename in os.listdir(folder):\n        file_path = os.path.join(folder, filename)\n        if os.path.isfile(file_path):\n            with open(file_path, 'r') as file:\n                content = file.read()\n                for role in role_set:\n                    if role in content:\n                        examples.append(content)\n                        break\n    return examples\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n# Natural Language Annotations: \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    for plugin in external_plugin_pool:\n        # Assuming that 'plugin' needs to be validated before adding\n        if self.is_plugin_selected(plugin):\n            self.plugin_pool.append(plugin)\n\ndef is_plugin_selected(self, plugin: PluginEntry) -> bool:\n    \"\"\"\n    Example method to check if a plugin is selected.\n    Replace this stub with actual business logic.\n    \n    Parameters:\n    - plugin: The plugin entry to check\n    \n    Returns:\n    - bool: True if the plugin is selected, False otherwise\n    \"\"\"\n    # Example condition to determine whether a plugin is selected\n    return hasattr(plugin, 'selected') and plugin.selected\n```\n\nEnsure to replace the `is_plugin_selected` method logic with real conditions as per your application's requirements."]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def filter_unused_plugins(self, code: str):\n# Natural Language Annotations: \"\"\"\n        Filter out plugins that are not used in the code generated by LLM\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef filter_unused_plugins(self, code: str):\n    # Dummy plugin list, in a real scenario this should be the list of plugins available in the environment\n    available_plugins = ['plugin1', 'plugin2', 'plugin3', 'plugin4']\n\n    # Determine which plugins are used in the code by checking for their presence\n    used_plugins = set(plugin for plugin in available_plugins if plugin in code)\n\n    return list(used_plugins)\n```"]}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def remove_all_delimiters(text: str) -> str:\n# Natural Language Annotations: \"\"\"Remove all the delimiters from the text.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    # Define common delimiters\n    delimiters = set('.,;:!?\"\\'-()[]{}<>|\\\\/')\n\n    # Use list comprehension to filter out delimiters and join the remaining characters\n    return ''.join(char for char in text if char not in delimiters)\n```"]}, "reflex-reflex/app.py-_enable_state": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _enable_state(self) -> None:\n# Natural Language Annotations: \"\"\"Enable state for the app.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    # Assuming that there is an attribute 'state_enabled' to track the state status\n    self.state_enabled = True\n    \n    # If there are any other initializations or setups required for the state,\n    # they can be added here. For example, logging the state change.\n    if hasattr(self, 'on_state_enable'):\n        self.on_state_enable()\n\n    # Possibly broadcasting the state change to interested components or services\n    if hasattr(self, 'notify_state_change'):\n        self.notify_state_change('enabled')\n```"]}, "reflex-reflex/app.py-_add_optional_endpoints": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_optional_endpoints(self):\n# Natural Language Annotations: \"\"\"Add optional api endpoints (_upload).\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    \n    def _upload(data, endpoint=\"/upload\"):\n        \"\"\"\n        This internal function could be used to upload data to a specified endpoint.\n        \n        Parameters:\n            data: The data to upload, possibly in a format suitable for the API.\n            endpoint: The optional endpoint to which data will be uploaded.\n            \n        Returns:\n            A response from the upload process, such as confirmation or error message.\n        \"\"\"\n        # Placeholder for the actual implementation - here you might handle authentication,\n        # set headers, organize data, and make a post request using something like requests.post()\n        # For now, we may just print what we would do.\n        \n        # Example placeholder logic:\n        try:\n            # Assuming we would use a requests.post or similar in a real implementation\n            response = f\"Data to be uploaded to {endpoint}. Data: {data}\"\n            print(response)\n            return f\"Success: {response}\"\n        except Exception as e:\n            # Handle exceptions such as network errors, etc.\n            error_msg = f\"Failed to upload data to {endpoint} with error: {str(e)}\"\n            print(error_msg)\n            return f\"Error: {error_msg}\"\n\n    # Add the _upload function as an attribute or method of the class instance\n    self._upload = _upload\n```"]}, "reflex-reflex/app.py-add_page": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_page(\n# Natural Language Annotations: \"\"\"Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef add_page(component, route=None, title=None, description=None, image=None, on_load=None, meta=None):\n    # Mock a dictionary representing existing routes\n    existing_routes = {}\n\n    if callable(component) and route is None:\n        # If component is callable and route is not provided, use the component's name\n        route = component.__name__\n    elif not callable(component) and route is None:\n        raise ValueError(\"A route must be provided for non-callable components.\")\n    \n    # Check if the route already exists\n    if route in existing_routes:\n        raise ValueError(f\"The route '{route}' already exists.\")\n\n    # Mock logic to add the page to the app\n    existing_routes[route] = {\n        'component': component,\n        'title': title,\n        'description': description,\n        'image': image,\n        'on_load': on_load,\n        'meta': meta\n    }\n\n    return existing_routes[route]\n```"]}, "reflex-reflex/app.py-_setup_overlay_component": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _setup_overlay_component(self):\n# Natural Language Annotations: \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _setup_overlay_component(self):\n    \"\"\"\n    If a State is not used and no overlay_component is specified, \n    do not render the connection modal.\n    \"\"\"\n    \n    # Check for the `state` and `overlay_component` attributes\n    # Assuming `self` has these attributes, otherwise adapt as necessary\n    if hasattr(self, 'state') and hasattr(self, 'overlay_component'):\n        \n        # If state is not used or overlay_component is not specified\n        # Assume not used means it is None or some default value indicating unused\n        # This logic might need adaptation if 'not used' is defined differently\n        if self.state is None or self.overlay_component is None:\n            return None  # Do not render the connection modal\n            \n        # If both are valid, proceed with setting up the overlay component\n        self.render_connection_modal()\n    else:\n        # If the attributes are missing, default to not rendering\n        return None\n```\n"]}, "reflex-reflex/app.py-_compile": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _compile(self, export: bool = False):\n# Natural Language Annotations: \"\"\"Compile the app and output it to the pages folder.\n\n        Args:\n            export: Whether to compile the app for export.\n\n        Raises:\n            ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass ReflexRuntimeError(Exception):\n    \"\"\"Custom exception to handle Reflex runtime errors.\"\"\"\n    pass\n\ndef _compile(self, export: bool = False):\n    \"\"\"\n    Compile the app and output it to the pages folder.\n\n    Args:\n        export (bool): Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    # Placeholder for pages folder. In practice, this would be derived from project settings.\n    pages_folder = \"pages\"\n\n    # Perform compilation tasks.\n    # Here we'll check if any state usage is found in pages to determine the error condition.\n    page_uses_state = self.check_if_pages_use_state()\n\n    # Check if the state subclass is defined\n    rx_state_defined = self.check_if_rx_state_is_defined()\n\n    if page_uses_state and not rx_state_defined:\n        raise ReflexRuntimeError(\"Pages use state but no rx.State subclass is defined.\")\n\n    # If export is true, handle additional export functionality.\n    if export:\n        # Add export specific compilation logic here\n        self.export_compilation_logic()\n\n    # Otherwise, routine compilation logic.\n    self.routine_compilation_logic(pages_folder)\n\ndef check_if_pages_use_state(self):\n    # This would check if any page in the project uses state.\n    # Placeholder logic for demonstration. Replace with actual implementation.\n    return True\n\ndef check_if_rx_state_is_defined(self):\n    # This would check if the project has a defined subclass of rx.State.\n    # Placeholder logic for demonstration. Replace with actual implementation.\n    return False\n\ndef export_compilation_logic(self):\n    # Placeholder for export specific logic.\n    print(\"Executing export compilation logic.\")\n\ndef routine_compilation_logic(self, pages_folder):\n    # Placeholder for routine compilation operations.\n    print(f\"Compiling app to the {pages_folder} folder.\")\n```\n"]}, "reflex-reflex/app.py-modify_state": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n# Natural Language Annotations: \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import AsyncIterator\nfrom some_module import BaseState  # import BaseState from the appropriate module\n\nclass App:\n    def __init__(self):\n        self.initialized = False  # Flag to check initialization state\n\n    async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n        \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\n        if not self.initialized:\n            raise RuntimeError(\"The app has not been initialized yet.\")\n\n        # Example logic to fetch and modify states associated with the token\n        # This would depend on your actual application logic and BaseState class\n        states = await self.fetch_states_by_token(token)\n\n        for state in states:\n            # Modify state logic goes here, for example:\n            # state.modify_some_attribute()\n            yield state\n\n    async def fetch_states_by_token(self, token: str) -> AsyncIterator[BaseState]:\n        # This should be replaced with actual logic to get the states from some data source\n        # Placeholder implementation below, assuming it yields BaseState instances\n        async for state in some_data_source.get_states(token):\n            yield state\n```\n"]}, "reflex-reflex/vars.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport json\n\nclass VarTypeError(Exception):\n    pass\n\ndef create(value, _var_is_local=False, _var_is_string=False, _var_data=None):\n    # Check if the value is JSON-serializable, if not, raise VarTypeError\n    try:\n        json.dumps(value)\n    except (TypeError, OverflowError):\n        raise VarTypeError(\"The value provided is JSON-unserializable.\")\n    \n    # Create the var based on input parameters\n    var = {\n        'value': value,\n        'is_local': _var_is_local,\n        'is_string': _var_is_string,\n        'data': _var_data\n    }\n    \n    return var\n```"]}, "reflex-reflex/vars.py-create_safe": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_safe(\n# Natural Language Annotations: \"\"\"Create a var from a value, asserting that it is not None.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef create_safe(value, _var_is_local=True, _var_is_string=False, _var_data=None):\n    if value is None:\n        raise ValueError(\"The value cannot be None\")\n        \n    var = value\n\n    # Assuming additional hooks and imports associated with the var                 # should be processed here\n    if _var_data is not None:\n        # Process _var_data if needed\n        pass\n\n    # Handle a local variable case if needed, though the logic is not provided\n    # and is currently redundant since we're just returning the var\n    if _var_is_local:\n        # Logic for local variable can be added here if necessary\n        pass\n\n    # Handle the string literal case if needed\n    if _var_is_string:\n        if not isinstance(var, str):\n            raise ValueError(\"The value must be a string when _var_is_string is True\")\n\n    return var\n```"]}, "reflex-reflex/vars.py-foreach": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def foreach(self, fn: Callable) -> Var:\n# Natural Language Annotations: \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Callable, List\n\n\nclass VarTypeError(Exception):\n    pass\n\n\nclass Var:\n    def __init__(self, components: List):\n        self.components = components\n\n    def foreach(self, fn: Callable) -> 'Var':\n        if not isinstance(self.components, list):\n            raise VarTypeError(\"The var is not a list.\")\n        \n        transformed_components = [fn(component) for component in self.components]\n        return Var(transformed_components)\n```"]}, "reflex-reflex/vars.py-get_default_value": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_default_value(self) -> Any:\n# Natural Language Annotations: \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_default_value(self) -> Any:\n    # Default value initialization (example: could be None or a specific type like an empty list)\n    default_value = None\n    \n    # Assuming 'self.var' is the variable for which we are determining the default value\n    if isinstance(self.var, list):\n        default_value = []\n    elif isinstance(self.var, dict):\n        default_value = {}\n    elif isinstance(self.var, str):\n        default_value = ''\n    elif isinstance(self.var, int):\n        default_value = 0\n    elif isinstance(self.var, float):\n        default_value = 0.0\n    elif isinstance(self.var, tuple):\n        default_value = ()\n    elif isinstance(self.var, set):\n        default_value = set()\n    else:\n        try:\n            import pandas as pd\n            if isinstance(self.var, pd.DataFrame):\n                default_value = pd.DataFrame()\n        except ImportError:\n            raise ImportError(\"Pandas is required for dataframe operations\")\n\n    return default_value\n```"]}, "reflex-reflex/state.py-get_skip_vars": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_skip_vars(cls) -> set[str]:\n# Natural Language Annotations: \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"\n    Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    # Assuming cls is a class with defined attributes. \n    # This function might typically skip serialization of certain protected or private variables.\n    skip_vars = set()\n    for var in dir(cls):\n        # Skip private and protected attributes\n        if var.startswith('_'):\n            skip_vars.add(var)\n    return skip_vars\n```"]}, "reflex-reflex/state.py-add_var": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_var(cls, name: str, type_: Any, default_value: Any = None):\n# Natural Language Annotations: \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass State:\n    def __init__(self):\n        self._variables = {}\n\n    def add_var(self, name: str, type_: Any, default_value: Any = None):\n        # Check if the variable already exists\n        if name in self._variables:\n            raise NameError(f\"A variable with the name '{name}' already exists.\")\n        \n        # Add the variable dynamically\n        self._variables[name] = {\n            'type': type_,\n            'value': default_value\n        }\n        \n        # Optionally, setting the attribute makes it directly accessible\n        setattr(self, name, default_value)\n```\n"]}, "reflex-reflex/state.py-reset": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def reset(self):\n# Natural Language Annotations: \"\"\"Reset all the base vars to their default values.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef reset(self):\n    # Assuming 'base vars' refers to instance variables of a class that this method is a part of.\n    # For demonstration, let's assume the default values for the instance variables are:\n    # - var1: 0\n    # - var2: an empty list\n    # - var3: an empty dictionary\n    # These are arbitrary default values, you should replace or extend them with the actual default\n    # values that are appropriate for your use case.\n\n    # Reset variables to their default values\n    self.var1 = 0\n    self.var2 = []\n    self.var3 = {}\n\n    # Add any additional variables or reset logic as required by the actual class implementation.\n```"]}, "reflex-reflex/state.py-get_state": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n# Natural Language Annotations: \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    # Assuming the self object has a `client_token` and a method or attribute\n    # `get_state_by_class` that takes a class type and client token to return the\n    # respective state instance\n    try:\n        # Retrieve the state instance using the state class and client token\n        state_instance = self.get_state_by_class(state_cls, self.client_token)\n        return state_instance\n    except AttributeError as e:\n        raise RuntimeError(f\"Failed to get state: {e}\")\n```"]}, "reflex-reflex/state.py-_process": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n# Natural Language Annotations: \"\"\"Obtain event info and process event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import AsyncIterator\nfrom some_module import StateUpdate, Event  # assuming these classes are defined elsewhere\n\nclass EventProcessor:\n    # This is an example class within which _process would exist\n\n    async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n        \"\"\"\n        Obtain event info and process the event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\n        # Simulate event processing (replace this with actual processing logic)\n        async for state_update in self._simulate_event_processing(event):\n            yield state_update\n\n    async def _simulate_event_processing(self, event: Event) -> AsyncIterator[StateUpdate]:\n        \"\"\"\n        This is an example of a simulated internal method for processing events.\n        Replace this method with actual event processing mechanism.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            StateUpdate: Yields state updates as event gets processed\n        \"\"\"\n        # Example processing logic - this will be unique to your application\n        # Simulate processing with some hypothetical state updates\n        for step in range(3):  # Suppose the processing takes 3 steps\n            await asyncio.sleep(1)  # Simulate asynchronous processing delay\n            state_update = StateUpdate(step=step, info=f'State update for step {step} of the event {event}')\n            yield state_update\n```\n"]}, "reflex-reflex/state.py-_dirty_computed_vars": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _dirty_computed_vars(\n# Natural Language Annotations: \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _dirty_computed_vars(from_vars=None, include_backend=False, dirty_vars=None):\n    \"\"\"\n    Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n        dirty_vars: a set of vars considered dirty. Used when from_vars is not specified.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    # Set of all computed variables that need recalculation\n    computed_vars_to_recalculate = set()\n\n    # A simulation of dependency graph showing which computed vars depend on which vars\n    # In a real scenario, this would be derived from actual data or configuration\n    dependency_graph = {\n        'computed_var1': {'var1', 'var2'},\n        'computed_var2': {'var3', 'var4'},\n        'computed_var3': {'var1', 'var5'},\n        'backend_computed_var1': {'var2', 'var6'},\n        # Add more computed vars and their dependencies as needed\n    }\n\n    # Determine which vars to use as the source of 'dirty' variables to check against\n    if from_vars is None:\n        if dirty_vars is None:\n            raise ValueError(\"Either from_vars or dirty_vars must be provided.\")\n        vars_to_check = dirty_vars\n    else:\n        vars_to_check = from_vars\n\n    # Iterate through all computed vars and check if any of their dependencies are in vars_to_check\n    for computed_var, dependencies in dependency_graph.items():\n        if dependencies.intersection(vars_to_check):\n            # If backend vars should not be included, we skip them\n            if not include_backend and 'backend_' in computed_var:\n                continue\n            computed_vars_to_recalculate.add(computed_var)\n\n    return computed_vars_to_recalculate\n```"]}, "reflex-reflex/state.py-_potentially_dirty_substates": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n# Natural Language Annotations: \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n        Returns:\n            Set of State classes that may need to be fetched to recalc computed vars.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Type\n\nclass BaseState:\n    \"\"\"Base class for States, potentially including methods and variables.\"\"\"\n\nclass DerivedState(BaseState):\n    \"\"\"Derived state class, representing a specific implementation.\"\"\"\n\nclass AnotherDerivedState(BaseState):\n    \"\"\"Another derived state class, representing another scenario.\"\"\"\n\nclass StateWithDependency(BaseState):\n    \"\"\"A state class that depends on other states.\"\"\"\n\nclass UnrelatedState:\n    \"\"\"A class that is not related to BaseState, used for checking inheritance.\"\"\"\n\nclass ExampleClass:\n    @classmethod\n    def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n        # List of all potential substates which could be affected by dirty variables\n        potential_substates = {DerivedState, AnotherDerivedState, StateWithDependency}\n\n        # Return the set of states which are subclasses of BaseState\n        return {substate for substate in potential_substates if issubclass(substate, BaseState)}\n\n# Usage example\nresults = ExampleClass._potentially_dirty_substates()\nprint(results)  # Output: {<class '__main__.DerivedState'>, <class '__main__.AnotherDerivedState'>, <class '__main__.StateWithDependency'>}\n```\n"]}, "reflex-reflex/state.py-get_delta": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_delta(self) -> Delta:\n# Natural Language Annotations: \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Delta:\n    # Assuming Delta is some form of data class or a placeholder class\n    # Define the class according to what delta needs to represent\n    def __init__(self, value=0):\n        self.value = value\n\n    def __repr__(self):\n        return f\"Delta(value={self.value})\"\n\n\nclass State:\n    def __init__(self, current_state):\n        # Let's assume current_state is a numeric type representing some state\n        self.current_state = current_state\n        self.previous_state = None  # Example placeholder for previous state\n\n    def update_state(self, new_state):\n        self.previous_state = self.current_state\n        self.current_state = new_state\n\n    def get_delta(self) -> Delta:\n        if self.previous_state is not None:\n            delta_value = self.current_state - self.previous_state\n        else:\n            delta_value = 0  # Initialize delta as 0 if no previous state\n\n        return Delta(delta_value)\n```\nThis example assumes `Delta` is a class with a `value` attribute. The `get_delta` method calculates the difference between the current state and the previous state of an example `State` class and returns it as a `Delta` object. This is a simple interpretation as the exact context and what constitutes a \"delta\" is not given. Adjust the implementation to suit your application's specifics."]}, "reflex-reflex/model.py-get_db_engine": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_db_engine():\n# Natural Language Annotations: \"\"\"Get the database engine.\n\n        Returns:\n            The database engine.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom sqlalchemy import create_engine\n\ndef get_db_engine():\n    \"\"\"\n    Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    # Replace the following variables with your actual database credentials and information\n    username = 'your_username'\n    password = 'your_password'\n    host = 'your_host'\n    port = 'your_port'\n    db_name = 'your_db_name'\n\n    # Construct the database URL\n    database_url = f'postgresql://{username}:{password}@{host}:{port}/{db_name}'\n\n    # Create the database engine\n    engine = create_engine(database_url)\n    \n    return engine\n```\n\nThis code assumes a PostgreSQL database. Adjust the database URL format if you're using a different database management system, like MySQL, SQLite, etc."]}, "reflex-reflex/model.py-alembic_autogenerate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def alembic_autogenerate(\n# Natural Language Annotations: \"\"\"Generate migration scripts for alembic-detectable changes.\n\n        Args:\n            connection: SQLAlchemy connection to use when detecting changes.\n            message: Human readable identifier describing the generated revision.\n            write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n        Returns:\n            True when changes have been detected.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom alembic import command, script\nfrom alembic.config import Config\nfrom alembic.autogenerate import compare_metadata\nfrom alembic.migration import MigrationContext\nfrom sqlalchemy import MetaData\n\ndef alembic_autogenerate(connection, message, write_migration_scripts):\n    \"\"\"\n    Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    \n    # Create Alembic configuration and script environment\n    alembic_cfg = Config(\"alembic.ini\")\n    script_ = script.ScriptDirectory.from_config(alembic_cfg)\n\n    # Bind the connection to migration context\n    context = MigrationContext.configure(connection)\n\n    # Compare the database schema to the metadata defined in models\n    metadata = MetaData()\n    diff = compare_metadata(context, metadata)\n\n    # Check if there are any differences\n    if diff:\n        if write_migration_scripts:\n            # Generate the revision script\n            command.revision(\n                alembic_cfg,\n                message=message,\n                autogenerate=True,\n            )\n        return True\n    return False\n```"]}, "reflex-reflex/model.py-migrate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def migrate(cls, autogenerate: bool = False) -> bool | None:\n# Natural Language Annotations: \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n        If alembic is not installed or has not been initialized for the project,\n        then no action is performed.\n\n        If there are no revisions currently tracked by alembic, then\n        an initial revision will be created based on sqlmodel metadata.\n\n        If models in the app have changed in incompatible ways that alembic\n        cannot automatically generate revisions for, the app may not be able to\n        start up until migration scripts have been corrected by hand.\n\n        Args:\n            autogenerate: If True, generate migration script and use it to upgrade schema\n                (otherwise, just bring the schema to current \"head\" revision).\n\n        Returns:\n            True - indicating the process was successful.\n            None - indicating the process was skipped.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\nfrom alembic import command\nfrom alembic.config import Config\nfrom alembic.util import CommandError\n\nclass MigrationManager:\n    @classmethod\n    def migrate(cls, autogenerate: bool = False) -> bool | None:\n        alembic_ini_path = 'alembic.ini'\n        migrations_folder = 'migrations'\n        \n        # Check if alembic is initialized by verifying the existence of alembic.ini and migrations folder\n        if not os.path.exists(alembic_ini_path) or not os.path.exists(migrations_folder):\n            print(\"Alembic is not initialized in this project.\")\n            return None\n\n        # Prepare Alembic config\n        config = Config(alembic_ini_path)\n\n        # Determine if an init revision is needed and create it if so\n        try:\n            command.upgrade(config, \"head\")  # Check if there's an existing migration history\n        except CommandError:\n            if autogenerate:\n                print(\"Creating initial migration...\")\n                command.revision(config, autogenerate=True, message=\"Initial migration\")\n            else:\n                print(\"No migrations detected and autogenerate is False. No action performed.\")\n                return None\n\n        # Perform migration\n        try:\n            if autogenerate:\n                print(\"Generating migration script and upgrading schema...\")\n                command.revision(config, autogenerate=True, message=\"Autogenerated migration\")\n                command.upgrade(config, \"head\")\n            else:\n                print(\"Bringing the schema to current 'head' revision...\")\n                command.upgrade(config, \"head\")\n            return True\n\n        except CommandError as e:\n            print(f\"Migration failed: {e}\")\n            return None\n```\n"]}, "reflex-reflex/model.py-select": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def select(cls):\n# Natural Language Annotations: \"\"\"Select rows from the table.\n\n        Returns:\n            The select statement.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef select(cls):\n    \"\"\"\n    Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    # Assuming cls has an attribute '__tablename__' denoting the table name\n    # and '__columns__' is a list of columns in the table.\n    table_name = getattr(cls, '__tablename__', None)\n    columns = getattr(cls, '__columns__', [])\n\n    if not table_name or not columns:\n        raise ValueError(\"The class must have '__tablename__' and '__columns__' attributes.\")\n\n    # Create the select statement\n    select_stmt = f\"SELECT {', '.join(columns)} FROM {table_name}\"\n    return select_stmt\n```"]}, "reflex-reflex/compiler/compiler.py-compile_components": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def compile_components(\n# Natural Language Annotations: \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\nimport subprocess\nimport tempfile\n\ndef compile_components(components: list) -> tuple:\n    \"\"\"\n    Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    # Create a temporary directory to store the compiled components' files\n    temp_dir = tempfile.mkdtemp()\n\n    compiled_output = \"\"\n    \n    # Iterate through each component to compile\n    for component in components:\n        # Define the path for the compiled component\n        compiled_path = os.path.join(temp_dir, component['name'] + '_compiled.py')\n        \n        # Create the initial file for the component in the temporary directory\n        with open(compiled_path, 'w') as component_file:\n            component_file.write(component['code'])\n\n        # Attempt to compile the component file\n        try:\n            # Use subprocess to simulate a compilation (here functional check with Python interpreter)\n            result = subprocess.run(\n                ['python', '-m', 'py_compile', compiled_path],\n                check=True, capture_output=True, text=True\n            )\n            compiled_output += f\"Component {component['name']} compiled successfully.\\n\"\n        except subprocess.CalledProcessError as e:\n            # Capture the error output if compilation fails\n            compiled_output += f\"Compilation failed for {component['name']}: {e.stderr}\\n\"\n     \n    # Return the path where components are compiled and the output message\n    return temp_dir, compiled_output\n\n# Example usage:\n# components = [\n#     {'name': 'componentA', 'code': 'print(\"Hello from A\")'},\n#     {'name': 'componentB', 'code': 'print(\"Hello from B\")'},\n# ]\n# compiled_path, output = compile_components(components)\n# print(compiled_path, output)\n```\nThis code provides a function that compiles a list of custom components using a temporary directory to store the files with error checking for the compilation process."]}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_or_set_last_reflex_version_check_datetime():\n# Natural Language Annotations: \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\nfrom datetime import datetime\nimport os\nimport json\n\n# Define the path to a configuration file\nCHECK_FILE_PATH = \"last_version_check.json\"\n\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"\n    Get the last time a check was made for the latest reflex version.\n    If this is the first time the function is called, or the data is not present,\n    it sets the current datetime as the last check time.\n\n    Returns:\n        The last version check datetime as a datetime object.\n    \"\"\"\n    # If the file does not exist, create it and set the current time\n    if not os.path.exists(CHECK_FILE_PATH):\n        with open(CHECK_FILE_PATH, 'w') as file:\n            current_time = datetime.now().isoformat()\n            json.dump({\"last_check\": current_time}, file)\n        return datetime.fromisoformat(current_time)\n\n    # If the file exists, read the last checked time\n    with open(CHECK_FILE_PATH, 'r') as file:\n        data = json.load(file)\n        last_check_time = data.get(\"last_check\", None)\n\n    # If no last checked time in the file, set it as current time\n    if not last_check_time:\n        with open(CHECK_FILE_PATH, 'w') as file:\n            current_time = datetime.now().isoformat()\n            json.dump({\"last_check\": current_time}, file)\n        return datetime.fromisoformat(current_time)\n\n    # Return the last checked time\n    return datetime.fromisoformat(last_check_time)\n```\n"]}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def preprocess(\n# Natural Language Annotations: \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def preprocess(app, state, event):\n    \"\"\"\n    Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # Initialize an empty list to store state updates\n    state_updates = []\n\n    # Apply middleware to the app (hypothetical middleware processing)\n    processed_event = await app.middleware.process(event)\n\n    # Based on event type, make corresponding state updates\n    if processed_event['type'] == 'update':\n        state.update(processed_event['data'])\n        state_updates.append(processed_event['data'])\n\n    elif processed_event['type'] == 'delete':\n        for key in processed_event['keys_to_delete']:\n            if key in state:\n                state.pop(key)\n                state_updates.append({key: 'deleted'})\n\n    elif processed_event['type'] == 'create':\n        state.update(processed_event['data'])\n        state_updates.append(processed_event['data'])\n\n    # Other kinds of events can be processed similarly\n\n    # Return state updates if any, or None if there's nothing to update\n    return state_updates if state_updates else None\n```"]}, "reflex-reflex/components/component.py-get_event_triggers": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_event_triggers(self) -> Dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Dict, Any\n\nclass Component:\n    def __init__(self):\n        # Example event triggers that a component might have\n        self.event_triggers = {\n            \"on_start\": self.on_start,\n            \"on_stop\": self.on_stop,\n            \"on_error\": self.on_error,\n            \"on_data_received\": self.on_data_received\n        }\n    \n    def on_start(self):\n        # Placeholder method for the start event\n        pass\n    \n    def on_stop(self):\n        # Placeholder method for the stop event\n        pass\n    \n    def on_error(self):\n        # Placeholder method for handling errors\n        pass\n    \n    def on_data_received(self):\n        # Placeholder method for data reception\n        pass\n\n    def get_event_triggers(self) -> Dict[str, Any]:\n        \"\"\"\n        Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n        \"\"\"\n        return self.event_triggers\n```\nThis code defines a class `Component` that includes methods for different types of events such as `on_start`, `on_stop`, `on_error`, and `on_data_received`. The `get_event_triggers` method returns a dictionary that maps event names to their corresponding handler methods."]}, "reflex-reflex/components/component.py-get_props": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_props(cls) -> Set[str]:\n# Natural Language Annotations: \"\"\"Get the unique fields for the component.\n\n        Returns:\n            The unique fields.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Set\n\ndef get_props(cls) -> Set[str]:\n    \"\"\"\n    Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    # Use a set to store unique fields\n    unique_fields = set()\n    \n    # Iterate through all attributes of the class\n    for attr_name in dir(cls):\n        # Check if the attribute is not a method or function\n        attr_value = getattr(cls, attr_name)\n        if not callable(attr_value) and not attr_name.startswith(\"__\"):\n            unique_fields.add(attr_name)\n    \n    return unique_fields\n```"]}, "reflex-reflex/components/component.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Component:\n    def __init__(self, children=None, props=None):\n        self.children = children if children else []\n        self.props = props if props else {}\n\n    def __repr__(self):\n        return f\"Component(children={self.children}, props={self.props})\"\n\n    @classmethod\n    def create(cls, *children, **props) -> 'Component':\n        \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\n        return cls(children=children, props=props)\n```"]}, "reflex-reflex/components/component.py-_add_style_recursive": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_style_recursive(\n# Natural Language Annotations: \"\"\"Add additional style to the component and its children.\n\n        Apply order is as follows (with the latest overriding the earliest):\n        1. Default style from `_add_style`/`add_style`.\n        2. User-defined style from `App.style`.\n        3. User-defined style from `Component.style`.\n        4. style dict and css props passed to the component instance.\n\n        Args:\n            style: A dict from component to styling.\n            theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n        Raises:\n            UserWarning: If `_add_style` has been overridden.\n\n        Returns:\n            The component with the additional style.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _add_style_recursive(component, style, theme=None):\n    \"\"\"\n    Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        component: The root component to which the style will be applied.\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n    \n    Returns:\n        The component with the additional style.\n    \"\"\"\n\n    # Check if the component has overridden the _add_style method\n    if hasattr(component, '_add_style') and callable(getattr(component, '_add_style', None)):\n        raise UserWarning(\"_add_style method has been overridden.\")\n    \n    # Assuming default_style is the style from _add_style/add_style method.\n    default_style = component._add_style() if hasattr(component, '_add_style') else {}\n    \n    # App style could be accessed as a class variable or a singleton pattern etc.\n    app_style = getattr(component.app, 'style', {}) if hasattr(component, 'app') else {}\n    \n    # Component specific style\n    component_style = getattr(component, 'style', {}) if hasattr(component, 'style') else {}\n    \n    # Combine the styles as per the order specified\n    merged_style = {**default_style, **app_style, **component_style, **style}\n    \n    # Apply the merged style to the component\n    if hasattr(component, 'apply_style'):\n        component.apply_style(merged_style)\n    else:\n        # If there's no method to apply style, assume storing in an attribute\n        component.applied_style = merged_style\n    \n    # Recursive part: Apply the styles to all child components\n    if hasattr(component, 'children'):\n        for child in component.children:\n            _add_style_recursive(child, style, theme)\n    \n    return component\n```\n"]}, "reflex-reflex/components/component.py-render": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self) -> Dict:\n# Natural Language Annotations: \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef render(self) -> Dict:\n    # Assuming that self has necessary attributes to be rendered into a dictionary\n    # Example attributes: id, name, type, and style\n\n    # Creating a dictionary to hold the rendered component data\n    rendered_component = {\n        \"id\": getattr(self, 'id', None),\n        \"name\": getattr(self, 'name', None),\n        \"type\": getattr(self, 'type', None),\n        \"style\": getattr(self, 'style', {}),\n        # Additional attributes can be added here based on the requirements\n    }\n\n    # Filtering out None values to ensure clean output\n    rendered_component = {k: v for k, v in rendered_component.items() if v is not None}\n\n    return rendered_component\n```"]}, "reflex-reflex/components/component.py-_get_vars": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_vars(self, include_children: bool = False) -> list[Var]:\n# Natural Language Annotations: \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list:\n    vars_list = []\n\n    # Walk through the component to gather vars from props, styles, and event handlers\n    for attr in ['props', 'styles', 'event_handlers']:\n        if hasattr(self, attr):\n            attr_vars = getattr(self, attr)\n            if isinstance(attr_vars, list):\n                vars_list.extend(attr_vars)\n            else:\n                vars_list.append(attr_vars)\n\n    # If include_children is True, gather vars from children as well\n    if include_children and hasattr(self, 'children'):\n        for child in getattr(self, 'children', []):\n            if hasattr(child, '_get_vars'):\n                vars_list.extend(child._get_vars(include_children=True))\n\n    return vars_list\n```"]}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _has_stateful_event_triggers(self):\n# Natural Language Annotations: \"\"\"Check if component or children have any event triggers that use state.\n\n        Returns:\n            True if the component or children have any event triggers that uses state.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _has_stateful_event_triggers(self):\n    # Base case: Check if the current component has event triggers that use state\n    if hasattr(self, 'event_triggers') and self.event_triggers:\n        for trigger in self.event_triggers:\n            if trigger.uses_state:\n                return True\n    \n    # Recursive case: Check if any children of this component have stateful event triggers\n    if hasattr(self, 'children') and self.children:\n        for child in self.children:\n            if child._has_stateful_event_triggers():\n                return True\n\n    # If neither the component nor its children have stateful event triggers, return False\n    return False\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_code": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_code(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Get custom code for the component and its children.\n\n        Returns:\n            The custom code.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"\n    Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    # Initialize an empty set to store unique custom code\n    custom_codes = set()\n    \n    # Assume this instance has a method to get its own custom code\n    if hasattr(self, 'get_custom_code'):\n        # Add this component's custom code if available\n        component_code = self.get_custom_code()\n        if component_code:\n            custom_codes.add(component_code)\n    \n    # Assume this instance has children and a method to retrieve them\n    if hasattr(self, 'children'):\n        for child in self.children:\n            # Recursively get custom code from each child component\n            if isinstance(child, type(self)) and hasattr(child, '_get_all_custom_code'):\n                child_codes = child._get_all_custom_code()\n                custom_codes.update(child_codes)\n    \n    return custom_codes\n```"]}, "reflex-reflex/components/component.py-_get_all_imports": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n# Natural Language Annotations: \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n        Args:\n            collapse: Whether to collapse the imports by removing duplicates.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom collections import defaultdict\nfrom typing import Dict, List, Union\n\nParsedImportDict = Dict[str, Union[List[str], set]]\n\nclass Component:\n    def __init__(self):\n        # Assume each component has a list of strings indicating its imports\n        self.imports = []\n        # Each component might have children components\n        self.children = []\n\n    def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n        def collect_imports(comp: 'Component', imports_dict: ParsedImportDict):\n            # Accumulate the current component's imports\n            if 'libraries' not in imports_dict:\n                imports_dict['libraries'] = []\n            imports_dict['libraries'].extend(comp.imports)\n\n            # Recursively accumulate imports from children\n            for child in comp.children:\n                collect_imports(child, imports_dict)\n\n        all_imports = defaultdict(list)\n        collect_imports(self, all_imports)\n\n        if collapse:\n            # Eliminate duplicates from the list\n            all_imports['libraries'] = list(set(all_imports['libraries']))\n\n        return all_imports\n```\n"]}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks_internal(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"\n    Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    hooks = {}\n    # Assuming self represents a component and has an attribute `children` which is a list of child components\n    if hasattr(self, 'hooks'):\n        hooks.update(self.hooks)  # Add the component's own hooks\n\n    if hasattr(self, 'children'):\n        for child in self.children:\n            if hasattr(child, '_get_all_hooks_internal'):\n                child_hooks = child._get_all_hooks_internal()\n                hooks.update(child_hooks)  # Add each child's hooks\n\n    return hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the React hooks for this component and its children.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    hooks = {}\n\n    # This is a placeholder implementation. You would typically gather hooks\n    # from this component's internal logic and its children.\n    component_hooks = self.get_component_hooks()\n\n    # Assume self.children is a list of child components which also have hooks\n    for child in self.children:\n        child_hooks = child._get_all_hooks()\n        hooks.update(child_hooks)\n\n    # Merge child hooks with this component's hooks\n    hooks.update(component_hooks)\n\n    return hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_components": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_components(\n# Natural Language Annotations: \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_all_custom_components(seen):\n    \"\"\"\n    Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n\n    # Assuming 'components' is a global or accessible list of all components.\n    # This should contain the definition of all components where each component\n    # has attributes like 'is_custom' and 'tags'.\n\n    # Initialize an empty set to store custom components\n    custom_components = set()\n\n    # Iterate through the components\n    for component in components:\n        # Check if the component is custom and not already seen\n        if component.is_custom and component.tags not in seen:\n            custom_components.add(component)\n            # Optionally, add this component's tags to seen\n            seen.add(component.tags)\n\n    return custom_components\n```\n"]}, "reflex-reflex/components/core/upload.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create an upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The upload component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Component:\n    def __init__(self, *children, **props):\n        self.children = children\n        self.props = props\n\n    def __repr__(self):\n        return f\"Component(children={self.children}, props={self.props})\"\n\nclass UploadComponent(Component):\n    def __init__(self, *children, **props):\n        super().__init__(*children, **props)\n        # Any specific initialization for UploadComponent can be done here\n\n    def __repr__(self):\n        return f\"UploadComponent(children={self.children}, props={self.props})\"\n\nclass UploadComponentFactory:\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        # Validate or modify children or props as needed for an upload component\n        # This could include setting default properties, ensuring required properties, etc.\n        return UploadComponent(*children, **props)\n```\n"]}, "reflex-reflex/components/next/image.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create an Image component from next/image.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the image.\n            height: The height of the image.\n            **props:The props of the component.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, Tuple, Dict\n\ndef create(*children: Any, width: int = 100, height: int = 100, **props: Dict[str, Any]) -> Any:\n    # Creating a representation of an Image component using the given parameters\n    image_component = {\n        \"type\": \"Image\",\n        \"attributes\": {\n            \"width\": width,\n            \"height\": height,\n            **props  # Additional properties that can be passed to the Image component\n        },\n        \"children\": children  # Adding the children elements if any\n    }\n    \n    # Normally, this function might integrate with a library or framework like React/Next.js in JavaScript \n    # and return a DOM element or similar structure. For simplicity in Python, we'll just return the dictionary.\n    return image_component\n```"]}, "reflex-reflex/components/lucide/icon.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Component:\n    # This is a placeholder class for the purpose of this code snippet.\n    def __init__(self, tag, *children, **props):\n        self.tag = tag\n        self.children = children\n        self.props = props\n\nclass Icon(Component):\n    VALID_TAGS = {'icon', 'iconButton', 'iconLink'}\n\n    @classmethod\n    def create(cls, *children, **props) -> Component:\n        # Extract the 'tag' from props if it exists\n        tag = props.get('tag', 'icon')  # Default to 'icon' if not provided\n\n        # Additional checks as per function requirements:\n        if not isinstance(tag, str):\n            raise AttributeError(\"Icon tag must be a string.\")\n\n        if tag not in cls.VALID_TAGS:\n            raise ValueError(f\"{tag} is not a valid icon tag.\")\n\n        # Initialize the Icon component with validated tag, children, and props\n        return cls(tag, *children, **props)\n```"]}, "reflex-reflex/components/tags/tag.py-format_props": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def format_props(self) -> List:\n# Natural Language Annotations: \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import List\n\nclass TagFormatter:\n    def __init__(self, props: dict):\n        self.props = props\n\n    def format_props(self) -> List:\n        # Initialize the list to store formatted properties\n        formatted_props = []\n        \n        # Iterate over each property and its value in the props dictionary\n        for key, value in self.props.items():\n            # Format each property as a string key=value\n            formatted_prop = f\"{key}={value}\"\n            # Append the formatted property string to the result list\n            formatted_props.append(formatted_prop)\n        \n        # Return the list of formatted properties\n        return formatted_props\n```\n"]}, "textual-src/textual/screen.py-focus_next": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Widget:\n    def __init__(self, name, focusable=True):\n        self.name = name\n        self.focusable = focusable\n        self.focused = False\n\n    def __repr__(self):\n        return f\"Widget({self.name}, focusable={self.focusable}, focused={self.focused})\"\n\nclass FocusManager:\n    def __init__(self):\n        self.widgets = []\n        self.current_focus = None\n\n    def add_widget(self, widget: Widget):\n        self.widgets.append(widget)\n\n    def get_focusable_widgets(self, selector: str) -> list:\n        # For simplicity, assume selector \"*\" returns all focusable widgets\n        if selector == \"*\":\n            return [widget for widget in self.widgets if widget.focusable]\n        # Add more complex selector parsing logic as needed\n        return []\n\n    def focus_next(self, selector: str | type = \"*\") -> Widget | None:\n        focusable_widgets = self.get_focusable_widgets(selector)\n        \n        if not focusable_widgets:\n            self.current_focus = None\n            return None\n\n        if self.current_focus is None:\n            self.current_focus = focusable_widgets[0]\n        else:\n            current_index = focusable_widgets.index(self.current_focus) if self.current_focus in focusable_widgets else -1\n            next_index = (current_index + 1) % len(focusable_widgets)\n            self.current_focus = focusable_widgets[next_index]\n        \n        for widget in self.widgets:\n            widget.focused = (widget == self.current_focus)\n        \n        return self.current_focus\n```\n\nThis code defines a simple focus manager and widget model, where the `focus_next` method updates the focus among the focusable widgets matching a given selector. It operates within the constraints provided and assumes a basic understanding of focusable widget selection via a CSS-like selector."]}, "textual-src/textual/screen.py-focus_previous": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    # Get a list of all focusable widgets\n    focusable_widgets = self.get_focusable_widgets(selector)\n\n    # If no widget is currently focused or no focusable widgets are found\n    if not focusable_widgets:\n        return None\n\n    # Get the currently focused widget\n    current_focus = self.get_current_focus()\n\n    # If no widget is currently focused, focus the first one\n    if current_focus is None:\n        self.set_focus(focusable_widgets[0])\n        return focusable_widgets[0]\n\n    # Find the index of the currently focused widget\n    try:\n        current_index = focusable_widgets.index(current_focus)\n    except ValueError:\n        # If the current focus is not in the list of focusable widgets, start from the beginning\n        current_index = 0\n\n    # Focus the previous widget in the list, handling wrap-around\n    previous_index = (current_index - 1) % len(focusable_widgets)\n    self.set_focus(focusable_widgets[previous_index])\n    return focusable_widgets[previous_index]\n\ndef get_focusable_widgets(self, selector: str | type[QueryType]) -> list:\n    # This method would return widgets matching the selector that are focusable\n    pass\n\ndef get_current_focus(self) -> Widget | None:\n    # This method would return the currently focused widget, or None if no widget is focused\n    pass\n\ndef set_focus(self, widget: Widget):\n    # This method would accept a widget and set it as the current focus\n    pass\n```"]}, "textual-src/textual/screen.py-set_focus": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n# Natural Language Annotations: \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    # If there is an already focused widget, unfocus it\n    if self.focused_widget is not None:\n        self.focused_widget.unfocus()\n    \n    # Set the new widget to be focused\n    self.focused_widget = widget\n    \n    # If a widget is provided, focus it\n    if widget is not None:\n        widget.focus()\n        \n        # If scrolling is enabled and the widget should be scrolled into view\n        if scroll_visible:\n            self.scroll_into_view(widget)\n    else:\n        # Effectively, this unfocuses since no widget is being set to focus\n        self.focused_widget = None\n```"]}, "textual-src/textual/strip.py-index_to_cell_position": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def index_to_cell_position(self, index: int) -> int:\n# Natural Language Annotations: \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```\ndef index_to_cell_position(self, index: int) -> int:\n    # Assuming cell lengths are determined by typical display widths\n    # for simplicity (e.g., ascii 1, wide chars 2), use a basic mock function.\n    \n    def char_to_cell_length(char: str) -> int:\n        # In a real scenario, you'd check if char is wide, narrow, or etc.\n        if char.isascii():\n            return 1\n        else:\n            # Here you can define rules for wide characters,\n            # for simplicity, we'll assume non-ascii as 2\n            return 2\n    \n    # Define a string to calculate cell position from; this would be an attribute\n    # in a real-world usage\n    sample_string = getattr(self, 'text', '')\n    \n    # Ensure index is within the permissible range\n    if index < 0 or index > len(sample_string):\n        raise IndexError(\"Index out of bounds\")\n    \n    # Calculate the cell position by summing the cell lengths of characters before index\n    cell_position = 0\n    for char in sample_string[:index]:\n        cell_position += char_to_cell_length(char)\n    \n    return cell_position\n```"]}, "textual-src/textual/strip.py-render": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self, console: Console) -> str:\n# Natural Language Annotations: \"\"\"Render the strip into terminal sequences.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Rendered sequences.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"\n    Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    # Assuming 'self.strip' is the object representing the drawable entity\n    # and it has a method to convert itself to a sequence of strings \n    # interpretative for the console.\n\n    # Convert the strip to the renderable sequence.\n    rendered_sequence = self.strip.to_render_sequence()\n    \n    # Use the Console instance to format or wrap the rendered sequence if necessary\n    # Here, we assume we need to apply console-specific formatting or transformation.\n    formatted_sequence = console.format_sequence(rendered_sequence)\n\n    # Join the sequence into a single string if it's a list or some iterable.\n    return ''.join(formatted_sequence)\n```\n"]}, "textual-src/textual/app.py-batch_update": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def batch_update(self) -> Generator[None, None, None]:\n# Natural Language Annotations: \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["Certainly! Below is the code proposed for the `batch_update` function which acts as a context manager to suspend all repaints until the end of the batch.\n\n```python\nfrom contextlib import contextmanager\nfrom typing import Generator\n\nclass SomeClass:\n    def __init__(self):\n        self._suspend_repaints = False\n    \n    def repaint(self):\n        ''' \n        Repaint something on the screen.\n        Actual implementation details might vary.\n        '''\n        if not self._suspend_repaints:\n            print(\"Repainting...\")\n        else:\n            print(\"Repaints are currently suspended.\")\n\n    @contextmanager\n    def batch_update(self) -> Generator[None, None, None]:\n        \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n        try:\n            self._suspend_repaints = True\n            yield\n        finally:\n            self._suspend_repaints = False\n```\n\nIn this implementation, the `batch_update` function is a context manager that controls the state of `_suspend_repaints` to prevent any repaint action from occurring until the context finishes execution. This pattern is useful for batching updates and reducing the number of repaints, which can be expensive operations."]}, "textual-src/textual/app.py-call_from_thread": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_from_thread(\n# Natural Language Annotations: \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport threading\nfrom queue import Queue, Empty\n\ndef call_from_thread(callback, *args, **kwargs):\n    \"\"\"\n    Run a callable from another thread, and return the result.\n\n    Args:\n        callback: A callable to run.\n        *args: Arguments to the callback.\n        **kwargs: Keyword arguments for the callback.\n\n    Raises:\n        RuntimeError: If the app isn't running or if this method is called from the same\n            thread where the app is running.\n\n    Returns:\n        The result of the callback.\n    \"\"\"\n    \n    if not isinstance(threading.current_thread(), threading._MainThread):\n        raise RuntimeError(\"This method must be called from a thread other than the main thread.\")\n    \n    result_queue = Queue()\n\n    def wrapper():\n        try:\n            # Execute the callback and put the result in the queue\n            result = callback(*args, **kwargs)\n            result_queue.put((True, result))\n        except Exception as e:\n            # If exception occurs, put it in the queue\n            result_queue.put((False, e))\n    \n    # Run the wrapper function in the main thread\n    if threading.main_thread().is_alive():\n        threading.Thread(target=wrapper).start()\n    else:\n        raise RuntimeError(\"The app must be running to use this method.\")\n    \n    # Wait for the result\n    success, payload = result_queue.get()\n    if success:\n        return payload\n    else:\n        raise payload\n```"]}, "textual-src/textual/app.py-run_test": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_test(\n# Natural Language Annotations: \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom contextlib import asynccontextmanager\n\nclass Pilot:\n    # Dummy implementation of Pilot class\n    async def click(self, selector: str):\n        # Simulate clicking an element identified by selector\n        pass\n\n@asynccontextmanager\nasync def run_test(headless: bool = True, size: tuple = None, tooltips: bool = False,\n                   notifications: bool = False, message_hook = None):\n    \"\"\"\n    Asynchronous context manager for testing apps in headless mode.\n\n    Parameters:\n    - headless: Run in headless mode (no output or input).\n    - size: Force terminal size to (WIDTH, HEIGHT), or None to auto-detect.\n    - tooltips: Enable tooltips when testing.\n    - notifications: Enable notifications when testing.\n    - message_hook: Callback called each time any message arrives at any message pump in the app.\n    \"\"\"\n    pilot = Pilot()\n    try:\n        # Setup testing environment here\n        # You can handle size, tooltips, notifications, etc.\n        \n        # Invoke the message_hook if any messages occur (example implementation)\n        if message_hook:\n            # Simulate a message being received\n            message = \"test message\"\n            message_hook(message)\n        \n        yield pilot\n    finally:\n        # Cleanup operations go here\n        pass\n```\n"]}, "textual-src/textual/app.py-run": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def run(\n# Natural Language Annotations: \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef run(headless: bool = False, inline: bool = False, inline_no_clear: bool = False, mouse: bool = False, size: tuple = None, auto_pilot = None):\n    \"\"\"\n    Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`, or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    if headless:\n        print(\"Running in headless mode.\")\n        # Implement logic for running in headless mode:\n        # For example, redirect output or disable GUI elements\n    \n    if inline:\n        print(\"Running inline.\")\n        # Implement logic for running inline within a prompt\n    \n    if inline and not inline_no_clear:\n        print(\"App output will be cleared on exit.\")\n        # Implement logic to clear output on exit if needed\n    \n    if mouse:\n        print(\"Mouse support enabled.\")\n        # Implement logic to enable mouse interactions\n    \n    if size:\n        print(f\"Setting terminal size to: {size}\")\n        # Implement logic to adjust terminal size\n\n    if auto_pilot:\n        print(\"Starting auto pilot.\")\n        # Assume auto_pilot is an asyncio coroutine, run it if necessary\n        # import asyncio and use asyncio.run(auto_pilot()) if that is the case\n        import asyncio\n        asyncio.run(auto_pilot())\n\n    print(\"Running the application\")\n    \n    # This section is a placeholder for actual app logic. For now, we'll just return a simple value:\n    app_return_value = \"App has finished running\"\n    \n    return app_return_value\n```"]}, "textual-src/textual/app.py-switch_mode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_mode(self, mode: str) -> AwaitMount:\n# Natural Language Annotations: \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Optional\n\nclass UnknownModeError(Exception):\n    \"\"\"Custom exception raised when an unknown mode is provided.\"\"\"\n    pass\n\nclass AwaitMount:\n    \"\"\"A placeholder class representing an optionally awaitable object.\"\"\"\n    def __init__(self, mode: str):\n        self.mode = mode\n\n    async def mount(self):\n        \"\"\"Simulated awaitable mounting process.\"\"\"\n        # Placeholder for actual mounting logic\n        print(f\"Mounting screen for mode: {self.mode}\")\n\nclass ModeSwitcher:\n    \"\"\"Class to handle mode switching.\"\"\"\n    \n    def __init__(self):\n        # Define set of known modes for validation\n        self.known_modes = {\"dark\", \"light\", \"eco\"}\n\n    def switch_mode(self, mode: str) -> Optional[AwaitMount]:\n        \"\"\"Switch to a given mode.\"\"\"\n        if mode not in self.known_modes:\n            raise UnknownModeError(f\"Unknown mode: {mode}\")\n\n        # Create an instance of AwaitMount indicating readiness to mount\n        await_mount = AwaitMount(mode)\n\n        # Here, you can add any additional logic required to switch modes\n        \n        return await_mount\n```\n"]}, "textual-src/textual/app.py-push_screen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def push_screen(\n# Natural Language Annotations: \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n        Args:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n                this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n        Raises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport asyncio\n\nclass NoActiveWorker(Exception):\n    \"\"\"Custom exception to be raised when wait_for_dismiss is used outside of a worker.\"\"\"\n    pass\n\nclass Screen:\n    \"\"\"Mock Screen class for demonstration purposes.\"\"\"\n    \n    def __init__(self, name=None):\n        self.name = name or \"Unnamed Screen\"\n    \n    async def dismiss(self, result=None):\n        \"\"\"Simulate dismissing the screen.\"\"\"\n        return result\n\n# Simulate a global context or application state which has a stack of screens\nscreen_stack = []\n\nasync def push_screen(screen, callback=None, wait_for_dismiss=False):\n    \"\"\"\n    Push a new screen on the screen stack, making it the current screen.\n    \n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is dismissed with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen.\n            When set to `False`, awaiting this method will wait for the screen to be mounted.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n        to await the result of the screen.\n    \"\"\"\n    # Check if `screen` is a string and convert to Screen instance if necessary\n    if isinstance(screen, str):\n        screen = Screen(name=screen)\n    \n    # Push the screen onto the stack\n    screen_stack.append(screen)\n    print(f\"Screen {screen.name} has been pushed to the stack. Current stack depth: {len(screen_stack)}.\")\n\n    # If wait_for_dismiss is enabled, simulate a worker environment\n    if wait_for_dismiss:\n        # This block should only be executed in a worker, simulate with a condition here.\n        if not asyncio.get_event_loop().is_running():\n            raise NoActiveWorker(\"wait_for_dismiss set to True, but no active worker detected.\")\n        \n        # Simulate the asynchronous waiting for the screen to be dismissed\n        result = await screen.dismiss()\n        \n        # Call the callback if provided\n        if callback:\n            callback(result)\n        \n        return result\n    else:\n        # Simulate mounting the screen and waiting for it to be mounted\n        await asyncio.sleep(0.1)  # Simulated delay for mounting the screen\n        print(f\"Screen {screen.name} mounted successfully.\")\n        return \"Screen mounted\"\n```\n"]}, "textual-src/textual/app.py-switch_screen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Screen:\n    def __init__(self, name: str):\n        self.name = name\n\nclass AwaitComplete:\n    def __init__(self, success: bool, message: str = ''):\n        self.success = success\n        self.message = message\n\nclass ScreenManager:\n    def __init__(self):\n        self.screen_stack = []\n\n    def install_screen(self, screen: Screen):\n        self.screen_stack.append(screen)\n\n    def get_screen_by_name(self, name: str) -> Screen:\n        for screen in self.screen_stack:\n            if screen.name == name:\n                return screen\n        raise ValueError(f\"Screen with name '{name}' not found.\")\n\n    def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n        # Resolve the screen argument to a Screen object if it's given as a string\n        if isinstance(screen, str):\n            try:\n                screen = self.get_screen_by_name(screen)\n            except ValueError as e:\n                return AwaitComplete(success=False, message=str(e))\n\n        # Perform the switch by replacing the top of the screen stack\n        if not self.screen_stack:\n            self.screen_stack.append(screen)\n        else:\n            self.screen_stack[-1] = screen\n\n        # Return a successful AwaitComplete\n        return AwaitComplete(success=True)\n```\n"]}, "textual-src/textual/app.py-pop_screen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def pop_screen(self) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef pop_screen(self) -> AwaitComplete:\n    if not self.screen_stack:\n        raise IndexError(\"pop from empty screen stack\")\n    \n    # Pop the current screen from the stack\n    replaced_screen = self.screen_stack.pop()\n    \n    # Switch to the previous screen (top of the stack if exists)\n    if self.screen_stack:\n        self.current_screen = self.screen_stack[-1]\n    else:\n        self.current_screen = None # or some default screen\n    \n    # Return the screen that was replaced\n    return replaced_screen\n```"]}, "textual-src/textual/app.py-run_action": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_action(\n# Natural Language Annotations: \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def run_action(action: str, default_namespace: str = None) -> bool:\n    # For the purpose of simulation, let's assume we have predefined actions\n    predefined_actions = {\n        \"namespace1:action1\": lambda: print(\"Executing action1 in namespace1\"),\n        \"namespace1:action2\": lambda: print(\"Executing action2 in namespace1\"),\n        \"namespace2:action1\": lambda: print(\"Executing action1 in namespace2\"),\n        \"app:default_action\": lambda: print(\"Executing default action in app\"),\n    }\n\n    # Parse the action string to find namespace and specific action\n    if ':' in action:\n        namespace, action_name = action.split(':', 1)\n    else:\n        if default_namespace is not None:\n            namespace = default_namespace\n        else:\n            namespace = 'app'\n        action_name = action\n\n    # Construct the full action identifier\n    action_identifier = f\"{namespace}:{action_name}\"\n\n    # Attempt to find and execute the action\n    if action_identifier in predefined_actions:\n        predefined_actions[action_identifier]()\n        return True\n\n    # If the action cannot be found, return False indicating it wasn\u2019t handled\n    return False\n```"]}, "textual-src/textual/file_monitor.py-check": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check(self) -> bool:\n# Natural Language Annotations: \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\nimport time\n\nclass FileMonitor:\n    def __init__(self, file_paths):\n        # Store the list of file paths to monitor\n        self.file_paths = file_paths\n        # Initialize a dictionary to store last modification times for each file\n        self.last_mod_times = {file_path: os.path.getmtime(file_path) for file_path in file_paths}\n\n    def check(self) -> bool:\n        # Iterate over the monitored files\n        for file_path in self.file_paths:\n            # Get the current modification time\n            current_mod_time = os.path.getmtime(file_path)\n            # Compare it with the stored last modification time\n            if current_mod_time > self.last_mod_times[file_path]:\n                # If the file was modified, update the stored time and return True\n                self.last_mod_times[file_path] = current_mod_time\n                return True\n        # If none of the files were modified, return False\n        return False\n```\n"]}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n# Natural Language Annotations: \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    expanded_line = \"\"\n    current_length = 0\n\n    for char in line:\n        if char == '\\t':\n            # Calculate how many spaces to insert to reach the next tab stop\n            space_count = tab_size - (current_length % tab_size)\n            expanded_line += ' ' * space_count\n            current_length += space_count\n        else:\n            # Unicode wide characters take up two cells\n            if unicodedata.east_asian_width(char) in ('W', 'F'):\n                current_length += 2\n            else:\n                current_length += 1\n            expanded_line += char\n\n    return expanded_line\n```"]}, "textual-src/textual/_resolve.py-resolve": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def resolve(\n# Natural Language Annotations: \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef resolve(dimensions, total, gutter, size, viewport):\n    if not dimensions:\n        return []\n\n    n = len(dimensions)\n    total_gutter_space = (n - 1) * gutter\n    available_space = size - total_gutter_space\n    scaled_total = sum(dimensions)\n    \n    scale_factor = min(available_space / scaled_total, viewport / total)\n\n    results = []\n    offset = 0\n    for dim in dimensions:\n        length = dim * scale_factor\n        results.append((offset, length))\n        offset += length + gutter\n\n    return results\n```"]}, "textual-src/textual/widget.py-mount": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def mount(\n# Natural Language Annotations: \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass MountError(Exception):\n    pass\n\nclass WidgetContainer:\n    def __init__(self):\n        self.children = []\n\n    async def mount(self, *widgets, before=None, after=None):\n        if before is not None and after is not None:\n            raise MountError(\"Only one of 'before' or 'after' can be provided.\")\n\n        if before is not None:\n            if isinstance(before, int):\n                index = before\n            elif isinstance(before, str):\n                index = self.query_one(before)\n            else:\n                raise MountError(\"Invalid 'before' parameter.\")\n            self.children[index:index] = widgets  # Insert widgets at index\n        elif after is not None:\n            if isinstance(after, int):\n                index = after + 1\n            elif isinstance(after, str):\n                index = self.query_one(after) + 1\n            else:\n                raise MountError(\"Invalid 'after' parameter.\")\n            self.children[index:index] = widgets  # Insert widgets after index\n        else:\n            self.children.extend(widgets)  # Append widgets to the end\n\n        # Simulating awaitable by returning self (could be a coroutine in a real implementation)\n        return self\n\n    def query_one(self, query):\n        # Simplified query implementation\n        for i, child in enumerate(self.children):\n            if child == query:\n                return i\n        raise MountError(f\"Widget '{query}' not found.\")\n```"]}, "textual-src/textual/widget.py-move_child": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def move_child(\n# Natural Language Annotations: \"\"\"Move a child widget within its parent's list of children.\n\n        Args:\n            child: The child widget to move.\n            before: Child widget or location index to move before.\n            after: Child widget or location index to move after.\n\n        Raises:\n            WidgetError: If there is a problem with the child or target.\n\n        Note:\n            Only one of `before` or `after` can be provided. If neither\n            or both are provided a `WidgetError` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass WidgetError(Exception):\n    \"\"\"Custom exception for widget-related errors.\"\"\"\n    pass\n\ndef move_child(child, before=None, after=None):\n    \"\"\"\n    Move a child widget within its parent's list of children.\n\n    Args:\n        child: The child widget to move.\n        before: Child widget or location index to move before.\n        after: Child widget or location index to move after.\n\n    Raises:\n        WidgetError: If there is a problem with the child or target.\n\n    Note:\n        Only one of `before` or `after` can be provided. If neither\n        or both are provided a `WidgetError` will be raised.\n    \"\"\"\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of 'before' or 'after' can be specified.\")\n\n    if before is None and after is None:\n        raise WidgetError(\"Either 'before' or 'after' must be specified.\")\n\n    parent = child.parent  # Assuming child object has a reference to its parent\n    if not parent:\n        raise WidgetError(\"Child widget does not have a parent.\")\n\n    children = parent.children  # Assuming parent has a children list\n    if child not in children:\n        raise WidgetError(\"The specified child is not in the parent's children list.\")\n\n    # Remove the child from its current position\n    children.remove(child)\n\n    if before is not None:\n        if isinstance(before, int):\n            target_index = before\n            if target_index < 0 or target_index > len(children):\n                raise WidgetError(\"Invalid index specified for 'before'.\")\n        else:\n            if before not in children:\n                raise WidgetError(\"The 'before' widget is not in the parent's children list.\")\n            target_index = children.index(before)\n\n        # Insert the child at the target index\n        children.insert(target_index, child)\n\n    elif after is not None:\n        if isinstance(after, int):\n            target_index = after + 1\n            if target_index < 0 or target_index > len(children):\n                raise WidgetError(\"Invalid index specified for 'after'.\")\n        else:\n            if after not in children:\n                raise WidgetError(\"The 'after' widget is not in the parent's children list.\")\n            target_index = children.index(after) + 1\n\n        # Insert the child at the target index\n        children.insert(target_index, child)\n```"]}, "textual-src/textual/widget.py-_get_box_model": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_box_model(\n# Natural Language Annotations: \"\"\"Process the box model for this widget.\n\n        Args:\n            container: The size of the container widget (with a layout)\n            viewport: The viewport size.\n            width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n            height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n        Returns:\n            The size and margin for this widget.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _get_box_model(container, viewport, width_fraction, height_fraction):\n    # Unpack container and viewport dimensions\n    container_width, container_height = container\n    viewport_width, viewport_height = viewport\n\n    # Calculate the size of the widget based on fractions and viewport size\n    widget_width = viewport_width * width_fraction\n    widget_height = viewport_height * height_fraction\n\n    # Ensure that the calculated widget size does not exceed the container size\n    widget_width = min(widget_width, container_width)\n    widget_height = min(widget_height, container_height)\n\n    # Calculate margins to center the widget in the container\n    horizontal_margin = (container_width - widget_width) / 2\n    vertical_margin = (container_height - widget_height) / 2\n\n    # Return the size and margin as a tuple\n    return (widget_width, widget_height, horizontal_margin, vertical_margin)\n```"]}, "textual-src/textual/widget.py-get_content_width": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_width(self, container: Size, viewport: Size) -> int:\n# Natural Language Annotations: \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    # Determine the optimal content width\n    # Assuming Size is a class with width attributes for container and viewport\n    \n    # The content width should not exceed the container's width\n    max_content_width = container.width\n    \n    # If the viewport is smaller than the container, use the viewport's width\n    if viewport.width < container.width:\n        max_content_width = viewport.width\n\n    # The optimal width should allow for padding or other elements,\n    # so let's assume some padding exists, e.g., 10 units each side\n    padding = 10 * 2  # left + right padding\n    optimal_content_width = max_content_width - padding\n\n    # Ensure optimal width is at least 0\n    return max(0, optimal_content_width)\n```"]}, "textual-src/textual/widget.py-get_content_height": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n# Natural Language Annotations: \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    # Assuming the content's height should be proportional to some combination of container \n    # size and viewport size. The logic here is arbitrary as no specific relationship is given.\n    \n    # Calculate a scaling factor between the container and the viewport\n    scale_factor = min(container.height / viewport.height, 1.0)\n    \n    # Determine content height based on width and scale factor\n    content_height = int(viewport.height * scale_factor)\n    \n    # Ensure the content height does not exceed container height\n    content_height = min(content_height, container.height)\n    \n    return content_height\n```"]}, "textual-src/textual/suggester.py-_get_suggestion": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n# Natural Language Annotations: \"\"\"Used by widgets to get completion suggestions.\n\n        Note:\n            When implementing custom suggesters, this method does not need to be\n            overridden.\n\n        Args:\n            requester: The message target that requested a suggestion.\n            value: The current value to complete.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    # Define a list of possible suggestions, could be from a predefined list, database, or any external source\n    suggestions_list = [\"apple\", \"apricot\", \"banana\", \"blueberry\", \"cherry\", \"date\", \"dragonfruit\", \"grape\", \"kiwi\", \"lemon\"]\n\n    # Filter suggestions based on the input value, for simple demonstration we use `startswith`\n    matching_suggestions = [suggestion for suggestion in suggestions_list if suggestion.startswith(value.lower())]\n\n    # Send the suggestions to the requester (assume requester has a `send_suggestions` method)\n    if hasattr(requester, 'send_suggestions'):\n        await requester.send_suggestions(matching_suggestions)\n    else:\n        # If requester doesn't have `send_suggestions`, raise an AttributeError or handle it accordingly\n        raise AttributeError(\"Requester does not support sending suggestions\")\n```\n"]}, "textual-src/textual/dom.py-add_class": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_class(self, *class_names: str, update: bool = True) -> Self:\n# Natural Language Annotations: \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Node:\n    def __init__(self):\n        self.classes = set()\n        self.style_updated = False\n    \n    def update_styles(self):\n        # Placeholder for whatever logic updates styles when class list changes.\n        self.style_updated = True\n    \n    def add_class(self, *class_names: str, update: bool = True) -> 'Node':\n        # Add the class names to the set of classes\n        self.classes.update(class_names)\n        \n        # If update is True, update the styles\n        if update:\n            self.update_styles()\n        \n        # Return the instance (self)\n        return self\n```"]}, "textual-src/textual/reactive.py-_initialize_object": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _initialize_object(cls, obj: Reactable) -> None:\n# Natural Language Annotations: \"\"\"Set defaults and call any watchers / computes for the first time.\n\n        Args:\n            obj: An object with Reactive descriptors\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    # Iterate over all attributes of the object\n    for attribute_name in dir(obj):\n        # Get the attribute\n        attribute = getattr(obj, attribute_name)\n        \n        # Check if the attribute is a Reactive descriptor\n        if isinstance(attribute, cls.Reactive):\n            # Set the default value if not already set\n            if not hasattr(obj, '_' + attribute_name):\n                setattr(obj, '_' + attribute_name, attribute.default)\n            \n            # If there are any watches or computes, call them\n            if hasattr(attribute, 'watchers'):\n                for watcher in attribute.watchers:\n                    watcher(obj, getattr(obj, attribute_name))\n            \n            if hasattr(attribute, 'computes'):\n                for compute in attribute.computes:\n                    compute(obj)\n```"]}, "textual-src/textual/message_pump.py-call_after_refresh": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Callback:\n    def __init__(self, func, *args, **kwargs):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n\n    def call(self):\n        return self.func(*self.args, **self.kwargs)\n\nclass MessagePump:\n    def __init__(self):\n        # Manage state related to message processing and screen refreshing\n        self.is_processing = False\n        self.callbacks = []\n        self.is_closing = False\n\n    def start_processing(self):\n        self.is_processing = True\n        self.is_closing = False\n\n    def end_processing(self):\n        self.is_processing = False\n        self.refresh()\n\n    def refresh(self):\n        # Logic for refreshing the screen\n        self.process_callbacks()\n\n    def process_callbacks(self):\n        if not self.is_closing:\n            for callback in self.callbacks:\n                callback.call()\n            self.callbacks.clear()\n\n    def close(self):\n        self.is_closing = True\n\n    # The function to schedule the callback\n    def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n        if self.is_closing:\n            return False\n        # Create a Callback object with provided arguments\n        callback_obj = Callback(callback, *args, **kwargs)\n        # Schedule it to run after the screen refresh\n        self.callbacks.append(callback_obj)\n        return True\n```"]}, "textual-src/textual/message_pump.py-call_later": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Callable, Any, List\n\nclass Scheduler:\n    def __init__(self):\n        self.queue: List = []\n        self.closed: bool = False\n\n    def process_messages(self):\n        while self.queue:\n            callback, args, kwargs = self.queue.pop(0)\n            callback(*args, **kwargs)\n\n    def close(self):\n        self.closed = True\n        self.queue.clear()\n\n    def call_later(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n        if self.closed:\n            return False\n        self.queue.append((callback, args, kwargs))\n        return True\n\n# Example usage:\n# scheduler = Scheduler()\n# scheduler.call_later(print, \"Hello,\", \" World!\", end=\"\\n\")\n# scheduler.process_messages()\n# scheduler.close()\n# scheduler.call_later(print, \"This will not be scheduled.\")\n```"]}, "textual-src/textual/message_pump.py-post_message": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def post_message(self, message: Message) -> bool:\n# Natural Language Annotations: \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom queue import Queue\nfrom dataclasses import dataclass\n\n@dataclass\nclass Message:\n    content: str\n    event_type: str = None\n\nclass Widget:\n    def __init__(self):\n        self.message_queue = Queue()\n\n    def post_message(self, message: Message) -> bool:\n        try:\n            self.message_queue.put(message)\n            return True\n        except Exception as e:\n            return False\n```"]}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_values_in_region(self, region: Region) -> list[ValueType]:\n# Natural Language Annotations: \"\"\"Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import List, Any\n\nclass ValueType:\n    # Assume some implementation details for ValueType\n    pass\n\nclass Region:\n    # Assume some implementation details for Region\n    def intersects(self, other: 'Region') -> bool:\n        # Placeholder implementation for intersection logic\n        pass\n\nclass DataStore:\n    def __init__(self):\n        # Assume we have some sort of data storage structure\n        self.data = []  # This should contain tuples or objects with 'value' and 'region' members\n\n    def get_values_in_region(self, region: Region) -> List[ValueType]:\n        values_in_region = []\n        for item in self.data:\n            item_region = item['region']\n            item_value = item['value']\n            if item_region.intersects(region):\n                values_in_region.append(item_value)\n        return values_in_region\n```\n"]}, "textual-src/textual/validation.py-validate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def validate(self, value: str) -> ValidationResult:\n# Natural Language Annotations: \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom urllib.parse import urlparse\nfrom dataclasses import dataclass\n\n@dataclass\nclass ValidationResult:\n    is_valid: bool\n    message: str\n\nclass URLValidator:\n    def validate(self, value: str) -> ValidationResult:\n        parsed_url = urlparse(value)\n        if parsed_url.scheme:\n            return ValidationResult(is_valid=True, message=\"The URL is valid.\")\n        else:\n            return ValidationResult(is_valid=False, message=\"The URL is not valid. It must contain a scheme.\")\n```"]}, "textual-src/textual/geometry.py-clamp": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def clamp(self, width: int, height: int) -> Offset:\n# Natural Language Annotations: \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Offset:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def clamp(self, width: int, height: int) -> 'Offset':\n        # Clamp the x coordinate to be within [0, width]\n        clamped_x = max(0, min(self.x, width))\n        # Clamp the y coordinate to be within [0, height]\n        clamped_y = max(0, min(self.y, height))\n        # Return a new Offset with clamped values\n        return Offset(clamped_x, clamped_y)\n```"]}, "textual-src/textual/constants.py-_get_textual_animations": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_textual_animations() -> AnimationLevel:\n# Natural Language Annotations: \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport os\nfrom enum import Enum\n\nclass AnimationLevel(Enum):\n    NONE = \"none\"\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    ALL = \"all\"\n\ndef _get_textual_animations() -> AnimationLevel:\n    # Default to 'ALL' if the environment variable is not set or invalid\n    default_level = AnimationLevel.ALL\n    \n    # Retrieve the environment variable\n    env_var = os.getenv('ANIMATION_LEVEL', default_level.value).lower()\n    \n    # Check if the environment variable matches any valid AnimationLevel value\n    for level in AnimationLevel:\n        if env_var == level.value:\n            return level\n\n    # Return default level if no match is found\n    return default_level\n```"]}, "textual-src/textual/color.py-parse": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(cls, color_text: str | Color) -> Color:\n# Natural Language Annotations: \"\"\"Parse a string containing a named color or CSS-style color.\n\n        Colors may be parsed from the following formats:\n\n        - Text beginning with a `#` is parsed as a hexadecimal color code,\n         where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n            - `#RGB`\n            - `#RGBA`\n            - `#RRGGBB`\n            - `#RRGGBBAA`\n\n        - Alternatively, RGB colors can also be specified in the format\n         that follows, where R, G, and B must be numbers between 0 and 255\n         and A must be a value between 0 and 1:\n\n            - `rgb(R,G,B)`\n            - `rgb(R,G,B,A)`\n\n        - The HSL model can also be used, with a syntax similar to the above,\n         if H is a value between 0 and 360, S and L are percentages, and A\n         is a value between 0 and 1:\n\n            - `hsl(H,S,L)`\n            - `hsla(H,S,L,A)`\n\n        Any other formats will raise a `ColorParseError`.\n\n        Args:\n            color_text: Text with a valid color format. Color objects will\n                be returned unmodified.\n\n        Raises:\n            ColorParseError: If the color is not encoded correctly.\n\n        Returns:\n            Instance encoding the color specified by the argument.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport re\n\nclass Color:\n    def __init__(self, r, g, b, a=1.0):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.a = a\n\nclass ColorParseError(Exception):\n    pass\n\nclass ColorParser:\n    HEX_SHORT_RE = re.compile(r'^#([0-9A-Fa-f]{3,4})$')\n    HEX_LONG_RE = re.compile(r'^#([0-9A-Fa-f]{6})([0-9A-Fa-f]{2})?$')\n    RGB_RE = re.compile(r'^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$')\n    RGBA_RE = re.compile(r'^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(0(\\.\\d+)?|1(\\.0+)?)\\s*\\)$')\n    HSL_RE = re.compile(r'^hsl\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)$')\n    HSLA_RE = re.compile(r'^hsla\\(\\s*(\\d+)\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(0(\\.\\d+)?|1(\\.0+)?)\\s*\\)$')\n\n    @classmethod\n    def parse(cls, color_text: str | Color) -> Color:\n        if isinstance(color_text, Color):\n            return color_text\n        \n        color_text = color_text.strip()\n\n        hex_match_short = cls.HEX_SHORT_RE.match(color_text)\n        hex_match_long = cls.HEX_LONG_RE.match(color_text)\n        rgb_match = cls.RGB_RE.match(color_text)\n        rgba_match = cls.RGBA_RE.match(color_text)\n        hsl_match = cls.HSL_RE.match(color_text)\n        hsla_match = cls.HSLA_RE.match(color_text)\n\n        if hex_match_short:\n            hex_value = hex_match_short.group(1)\n            if len(hex_value) == 3:  # #RGB\n                r, g, b = (int(hex_value[i] * 2, 16) for i in range(3))\n                a = 1.0\n            else:  # #RGBA\n                r, g, b, a = (int(hex_value[i] * 2, 16) for i in range(4))\n                a /= 255\n            return Color(r, g, b, a)\n\n        elif hex_match_long:\n            r, g, b = (int(hex_match_long.group(1)[i:i+2], 16) for i in (0, 2, 4))\n            a = int(hex_match_long.group(2), 16) / 255 if hex_match_long.group(2) else 1.0\n            return Color(r, g, b, a)\n\n        elif rgb_match:\n            r, g, b = (int(rgb_match.group(i)) for i in range(1, 4))\n            if any(c > 255 for c in (r, g, b)):\n                raise ColorParseError(\"RGB values must be between 0 and 255.\")\n            return Color(r, g, b)\n\n        elif rgba_match:\n            r, g, b = (int(rgba_match.group(i)) for i in range(1, 4))\n            a = float(rgba_match.group(4))\n            if any(c > 255 for c in (r, g, b)) or not (0 <= a <= 1):\n                raise ColorParseError(\"Invalid RGBA values.\")\n            return Color(r, g, b, a)\n\n        elif hsl_match:\n            h = int(hsl_match.group(1))\n            s = int(hsl_match.group(2)) / 100.0\n            l = int(hsl_match.group(3)) / 100.0\n            if not (0 <= h <= 360) or not (0 <= s <= 1) or not (0 <= l <= 1):\n                raise ColorParseError(\"Invalid HSL values.\")\n            return cls.hsl_to_color(h, s, l)\n        \n        elif hsla_match:\n            h = int(hsla_match.group(1))\n            s = int(hsla_match.group(2)) / 100.0\n            l = int(hsla_match.group(3)) / 100.0\n            a = float(hsla_match.group(4))\n            if not (0 <= h <= 360) or not (0 <= s <= 1) or not (0 <= l <= 1) or not (0 <= a <= 1):\n                raise ColorParseError(\"Invalid HSLA values.\")\n            return cls.hsl_to_color(h, s, l, a)\n\n        raise ColorParseError(\"Invalid color format.\")\n\n    @staticmethod\n    def hsl_to_color(h, s, l, a=1.0):\n        c = (1 - abs(2 * l - 1)) * s\n        x = c * (1 - abs((h / 60) % 2 - 1))\n        m = l - c / 2\n        if 0 <= h < 60:\n            rp, gp, bp = c, x, 0\n        elif 60 <= h < 120:\n            rp, gp, bp = x, c, 0\n        elif 120 <= h < 180:\n            rp, gp, bp = 0, c, x\n        elif 180 <= h < 240:\n            rp, gp, bp = 0, x, c\n        elif 240 <= h < 300:\n            rp, gp, bp = x, 0, c\n        else:\n            rp, gp, bp = c, 0, x\n        r = int((rp + m) * 255)\n        g = int((gp + m) * 255)\n        b = int((bp + m) * 255)\n        return Color(r, g, b, a)\n```\n"]}, "textual-src/textual/_slug.py-slug": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def slug(self, text: str) -> str:\n# Natural Language Annotations: \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n        Args:\n            text: The text to generate a slug from.\n\n        Returns:\n            A slug for the given text.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport re\nfrom unidecode import unidecode\n\ndef slug(self, text: str) -> str:\n    # Convert text to lowercase\n    text = text.lower()\n    # Normalize the text to ASCII using unidecode\n    text = unidecode(text)\n    # Replace any character that is not a word character or dash with a space\n    text = re.sub(r'[^\\w\\s-]', '', text)\n    # Replace one or more spaces or dashes with a single dash\n    text = re.sub(r'[\\s-]+', '-', text)\n    # Strip leading and trailing whitespace or dashes\n    text = text.strip('-')\n    # Return the slug which is Markdown-friendly\n    return text\n```"]}, "textual-src/textual/_styles_cache.py-render": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(\n# Natural Language Annotations: \"\"\"Render a widget content plus CSS styles.\n\n        Args:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            content_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef render(styles, size, base_background, background, render_content_line, console, border_title=None, \n           border_subtitle=None, content_size=None, padding=None, crop=None, filters=None, opacity=1.0):\n    \"\"\"\n    Render a widget content plus CSS styles.\n    \"\"\"\n\n    def apply_padding(content, pad):\n        if pad is None:\n            pad = styles.padding\n        if isinstance(pad, int):\n            pad = (pad, pad, pad, pad)\n        top, right, bottom, left = pad\n        padded_content = [\n            [\" \"] * right + line + [\" \"] * left\n            for line in content\n        ]\n        padding_lines = [[\" \"] * (len(padded_content[0]))]\n        return padding_lines * top + padded_content + padding_lines * bottom\n\n    def apply_crop(content, crop_area):\n        if crop_area is None:\n            return content\n        x, y, width, height = crop_area\n        return [line[x:x+width] for line in content[y:y+height]]\n\n    def apply_filters(content, filter_functions):\n        if not filter_functions:\n            return content\n        for filter_func in filter_functions:\n            content = filter_func(content)\n        return content\n\n    def render_border(line, border_elements):\n        if not border_elements:\n            return line\n        title, title_color, title_background, title_style = border_elements\n        # Simplistic version of styling\n        border_line = f\"{title}[{title_color} on {title_background} {title_style}]\"\n        return border_line.center(len(line), \"-\")\n\n    # Start rendering\n    rendered_content = []\n    if content_size is None:\n        content_size = size\n\n    for i in range(content_size[1]):  # Iterate over the height of the content\n        rendered_line = render_content_line(i, content_size, background)\n        rendered_content.append(rendered_line)\n    \n    # Applying padding\n    rendered_content = apply_padding(rendered_content, padding)\n    \n    # Applying crop\n    rendered_content = apply_crop(rendered_content, crop)\n    \n    # Adding border titles/subtitles if any\n    if border_title is not None:\n        rendered_content.insert(0, render_border(rendered_content[0], border_title))\n    if border_subtitle is not None:\n        rendered_content.insert(1, render_border(rendered_content[1], border_subtitle))\n\n    # Apply filters\n    rendered_content = apply_filters(rendered_content, filters)\n\n    # Simulating some form of opacity using console's method or styles\n    final_rendering = [\n        console.render_style(line, opacity, base_background, styles)\n        for line in rendered_content\n    ]\n\n    return final_rendering\n```"]}, "textual-src/textual/document/_document.py-replace_range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n# Natural Language Annotations: \"\"\"Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Location:\n    def __init__(self, row: int, column: int):\n        self.row = row\n        self.column = column\n\nclass EditResult:\n    def __init__(self, success: bool, modified_text: str, message: str = \"\"):\n        self.success = success\n        self.modified_text = modified_text\n        self.message = message\n\nclass Document:\n    def __init__(self, lines: list):\n        self.lines = lines\n\n    def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n        try:\n            # Extract the start and end positions\n            start_row, start_col = start.row, start.column\n            end_row, end_col = end.row, end.column\n\n            # Validate the positions\n            if start_row < 0 or end_row < 0 or start_col < 0 or end_col < 0:\n                return EditResult(False, \"\", \"Start or end positions cannot be negative.\")\n            if start_row >= len(self.lines) or end_row >= len(self.lines):\n                return EditResult(False, \"\", \"Start or end row is out of document bounds.\")\n            if start_col > len(self.lines[start_row]) or (end_col > len(self.lines[end_row]) and end_row < len(self.lines)):\n                return EditResult(False, \"\", \"Start or end column is out of line bounds.\")\n\n            # Retrieve the parts of text to preserve\n            before = self.lines[start_row][:start_col]\n            after = self.lines[end_row][end_col:]\n\n            # Replace the text within the specified range\n            if start_row == end_row:\n                self.lines[start_row] = before + text + after\n            else:\n                # Replace the text spanning multiple lines\n                self.lines[start_row] = before + text + self.lines[end_row][end_col:]\n                # Remove lines between start_row and end_row\n                for _ in range(end_row, start_row, -1):\n                    self.lines.pop(start_row + 1)\n\n            # Return the edited document's text\n            modified_text = \"\\n\".join(self.lines)\n            return EditResult(True, modified_text)\n\n        except Exception as e:\n            return EditResult(False, \"\", f\"An error occurred: {str(e)}\")\n```"]}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def wrap_range(\n# Natural Language Annotations: \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n        This must be called *after* the source document has been edited.\n\n        Args:\n            start: The start location of the edit that was performed in document-space.\n            old_end: The old end location of the edit in document-space.\n            new_end: The new end location of the edit in document-space.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef wrap_range(start, old_end, new_end):\n    \"\"\"\n    Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n    # Calculate the length of the old and new range\n    old_length = old_end - start\n    new_length = new_end - start\n    \n    # Determine the extent of the change; positive if added, negative if removed\n    change_in_length = new_length - old_length\n    \n    # Return a tuple that represents how much needs to be recomputed\n    return (start, start + max(old_length, new_length) + change_in_length)\n```"]}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def offset_to_location(self, offset: Offset) -> Location:\n# Natural Language Annotations: \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass Document:\n    def __init__(self, lines):\n        self.lines = lines\n\nclass Offset:\n    def __init__(self, y_offset: int):\n        self.y_offset = y_offset\n\nclass Location:\n    def __init__(self, line_number: int, column_number: int):\n        self.line_number = line_number\n        self.column_number = column_number\n\nclass TextWrapper:\n    def __init__(self, document: Document, wrap_length: int):\n        self.document = document\n        self.wrap_length = wrap_length\n        self.visual_lines = self.calculate_visual_lines()\n\n    def calculate_visual_lines(self):\n        visual_lines = []\n        for line_number, line in enumerate(self.document.lines):\n            start = 0\n            while start < len(line):\n                visual_lines.append((line_number, start))\n                start += self.wrap_length\n        return visual_lines\n\n    def offset_to_location(self, offset: Offset) -> Location:\n        if offset.y_offset < 0 or offset.y_offset >= len(self.visual_lines):\n            raise ValueError(\"Offset does not correspond to a line in the document.\")\n\n        line_number, start = self.visual_lines[offset.y_offset]\n        return Location(line_number=line_number, column_number=start)\n```\n"]}, "textual-src/textual/css/parse.py-substitute_references": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def substitute_references(\n# Natural Language Annotations: \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\ndef substitute_references(tokens):\n    # Dictionary to hold the values of variables\n    variable_values = {}\n    \n    for token in tokens:\n        # Check if the token is a variable reference\n        if token.name == \"variable_ref\":\n            # Get the value of the referenced variable\n            variable_name = token.value\n            if variable_name in variable_values:\n                referenced_token = variable_values[variable_name]\n                # Create a new token to yield with reference information\n                new_token = Token(\n                    name=referenced_token.name,\n                    value=referenced_token.value,\n                    referenced_by=token.position  # Assuming token has a position attribute\n                )\n                yield new_token\n            else:\n                raise ValueError(f\"Undefined variable reference: {variable_name}\")\n        else:\n            # Regular token, potentially a variable definition\n            yield token\n            # If it's a variable being defined, store its value\n            if token.name == \"variable_def\":\n                variable_values[token.value] = token\n```\n"]}, "textual-src/textual/css/parse.py-parse": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(\n# Natural Language Annotations: \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport re\n\ndef parse(scope, css, read_from, variables, is_default_rules):\n    \"\"\"\n    Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if \n            they're from user defined CSS.\n    \"\"\"\n    \n    # Tokenizing CSS by splitting based on common CSS delimiters\n    # This example is rudimentary and only serves demonstration purposes\n    tokens = re.split(r'(\\s+|;|\\{|\\}|\\:)', css)\n\n    # Substitute variables in place of tokens using the provided variables dictionary\n    substituted_tokens = [variables.get(token, token) for token in tokens]\n\n    # Dummy function to illustrate rule set generation from tokenized CSS\n    # You would implement a CSS rule-set extraction mechanism here\n    # Example: create a dictionary with selectors as keys and styles as values\n    \n    def generate_rule_sets(tokens, scope, is_default_rules):\n        rules = {}\n        current_selector = None\n        current_styles = []\n        inside_block = False\n        \n        for token in tokens:\n            token = token.strip()  # Remove surrounding whitespace\n            if not token:\n                continue\n            \n            if token == '{':\n                inside_block = True\n                current_styles = []\n            elif token == '}':\n                inside_block = False\n                if current_selector is not None:\n                    rules[current_selector] = current_styles.copy()\n                current_selector = None\n            elif inside_block:\n                current_styles.append(token)\n            else:\n                current_selector = token\n        \n        return rules\n    \n    # Generate rules\n    rules = generate_rule_sets(substituted_tokens, scope, is_default_rules)\n    \n    return rules\n```\n"]}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _parse_rules(\n# Natural Language Annotations: \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport re\n\nclass StylesheetError(Exception):\n    pass\n\nclass RuleSet:\n    def __init__(self, selectors, properties):\n        self.selectors = selectors\n        self.properties = properties\n\n    def __repr__(self):\n        return f\"RuleSet(selectors={self.selectors}, properties={self.properties})\"\n\ndef _parse_rules(css, read_from, is_default_rules, scope):\n    \"\"\"\n    Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    if not css.strip():\n        raise StylesheetError(\"Empty CSS input.\")\n\n    rule_regex = r\"(?P<selector>[^{]+)\\{(?P<properties>[^}]+)\\}\"\n    rules = re.finditer(rule_regex, css)\n\n    rule_sets = []\n\n    for rule in rules:\n        selector_text = rule.group('selector').strip()\n        properties_text = rule.group('properties').strip()\n\n        # Split selectors and properties\n        selectors = [s.strip() for s in selector_text.split(',') if s.strip()]\n        if scope:\n            selectors = [f\"{scope} {s}\" for s in selectors]\n\n        properties = {}\n        for prop in properties_text.split(';'):\n            if prop.strip():\n                key, value = map(str.strip, prop.split(':', 1))\n                properties[key] = value\n\n        rule_sets.append(RuleSet(selectors, properties))\n\n    return rule_sets\n```"]}, "textual-src/textual/css/stylesheet.py-parse": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(self) -> None:\n# Natural Language Annotations: \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nclass StylesheetParseError(Exception):\n    \"\"\"Exception raised for errors in the stylesheet parsing.\"\"\"\n    pass\n\nclass StylesheetParser:\n    def __init__(self, source: str):\n        \"\"\"\n        Initializes the parser with the given stylesheet source.\n\n        :param source: A string containing the CSS stylesheet to parse.\n        \"\"\"\n        self.source = source\n\n    def parse(self) -> None:\n        \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\n        # Attempt to parse the stylesheet\n        try:\n            # This is a placeholder for actual parsing logic\n            # In a real scenario, this might involve tokenizing the input,\n            # checking for syntax errors, and storing the parsed data for later use.\n            if not self.source.strip():\n                raise StylesheetParseError(\"The stylesheet is empty or contains only whitespace.\")\n            \n            # Example basic check for balanced curly braces\n            open_braces = self.source.count('{')\n            close_braces = self.source.count('}')\n            \n            if open_braces != close_braces:\n                raise StylesheetParseError(\"Mismatched curly braces in the stylesheet.\")\n\n            # Further CSS parsing logic goes here...\n\n        except Exception as e:\n            # Additionally handle any unexpected errors by raising a StylesheetParseError\n            raise StylesheetParseError(f\"An error occurred while parsing: {e}\")\n```\n"]}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_diffs(diff_string: str) -> dict:\n# Natural Language Annotations: \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport re\nfrom collections import defaultdict\n\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n\n    diff_pattern = re.compile(r'^diff --git a/(.*?) b/(.*?)$')\n    index_pattern = re.compile(r'^index [\\da-f]+\\.\\.[\\da-f]+(?: \\d+)?$')\n    start_hunk_pattern = re.compile(r'^@@ -\\d+(?:,\\d+)? \\+\\d+(?:,\\d+)? @@')\n\n    diffs_dict = defaultdict(lambda: {'hunks': []})\n    current_file = None\n    current_hunk = None\n\n    lines = diff_string.splitlines()\n\n    for line in lines:\n        diff_match = diff_pattern.match(line)\n        if diff_match:\n            current_file = diff_match.group(2)\n            continue\n\n        if index_pattern.match(line):\n            continue\n\n        hunk_match = start_hunk_pattern.match(line)\n        if hunk_match:\n            current_hunk = []\n            diffs_dict[current_file]['hunks'].append(current_hunk)\n            continue\n\n        if current_hunk is not None and (line.startswith('+') or line.startswith('-') or line.startswith(' ')):\n            current_hunk.append(line)\n\n    return diffs_dict\n```\n"]}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n# Natural Language Annotations: \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import Any, List, NamedTuple\n\nclass Message(NamedTuple):\n    sender: str\n    content: str\n\n# Assuming `self` is part of a class that requires `start` method.\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n    \"\"\"\n    # Convert user to string if not already a string to ensure compatibility\n    user_message = str(user)\n    \n    # Create messages\n    system_message = Message(sender='system', content=system)\n    user_message = Message(sender='user', content=user_message)\n\n    # Return the list of messages\n    return [system_message, user_message]\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def next(\n# Natural Language Annotations: \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom typing import List, Optional\nimport random\n\n# Assuming a simple Message class for demonstration\nclass Message:\n    def __init__(self, sender: str, content: str):\n        self.sender = sender\n        self.content = content\n\n    def __repr__(self):\n        return f'{self.sender}: {self.content}'\n\ndef next(messages: List[Message], prompt: Optional[str] = None, step_name: str = \"\") -> List[Message]:\n    \"\"\"\n    Advances the conversation by sending message history to LLM and updating with the response.\n    \n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n    \n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    # Simulate getting a response from a Language Model\n    def simulate_llm_response(prompt: str) -> str:\n        responses = [\n            \"Let's talk more about this.\",\n            \"What do you think about the topic?\",\n            \"Could you elaborate on that?\",\n            \"I'm not sure I understand.\",\n            \"That sounds interesting!\",\n        ]\n        return random.choice(responses)\n    \n    # Generate the entire conversation history as a single string\n    conversation_history = \"\\n\".join([f\"{msg.sender}: {msg.content}\" for msg in messages])\n    \n    # Create the input for the simulated LLM\n    if prompt:\n        input_text = f\"{prompt}\\n\\nConversation:\\n{conversation_history}\"\n    else:\n        input_text = conversation_history\n\n    # Get the LLM response\n    llm_response = simulate_llm_response(input_text)\n    \n    # Append LLM response to the messages\n    messages.append(Message(sender=\"LLM\", content=llm_response))\n    \n    return messages\n```"]}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_toml(self, config_file: Path | str, save=True) -> str:\n# Natural Language Annotations: \"\"\"Write the configuration to a TOML file.\"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport toml\nfrom pathlib import Path\n\nclass ConfigHandler:\n    def __init__(self, config_data: dict):\n        self.config_data = config_data\n\n    def to_toml(self, config_file: Path | str, save=True) -> str:\n        # Ensure the config_file is a Path object\n        config_file = Path(config_file)\n\n        # Convert the config_data to a TOML formatted string\n        toml_string = toml.dumps(self.config_data)\n        \n        # If save is True, write the toml string to the specified file\n        if save:\n            config_file.write_text(toml_string)\n\n        # Return the TOML formatted string representation of the config\n        return toml_string\n```\n"]}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n# Natural Language Annotations: \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\nPlease only return the code surrounded by ```\n", "response": ["```python\nimport difflib\n\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    # Normalize the strings by removing spaces and converting to lowercase\n    normalized_str1 = str1.replace(\" \", \"\").lower()\n    normalized_str2 = str2.replace(\" \", \"\").lower()\n    \n    # Use difflib to compute the similarity ratio\n    similarity_ratio = difflib.SequenceMatcher(None, normalized_str1, normalized_str2).ratio()\n    \n    # Compare the similarity ratio against the threshold\n    return similarity_ratio >= similarity_threshold\n```"]}}