{"langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.io.Files;\n\npublic class DocumentLoader {\n\n    public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n        Preconditions.checkArgument(Files.isDirectory(directoryPath), \"Specified path is not a directory\");\n\n        return Files.newDirectoryStream(directoryPath)\n                .map(file -> {\n                    try {\n                        return documentParser.parse(Files.newInputStream(file));\n                    } catch (IOException e) {\n                        System.out.println(\"Error parsing file \" + file.getFileName() + \": \" + e.getMessage());\n                        return null;\n                    }\n                })\n                .filter(Objects::nonNull)\n                .collect(Collectors.toList());\n    }\n}\n```", "```\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DocumentLoader {\n\n    public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n        if (!Files.isDirectory(directoryPath)) {\n            throw new IllegalArgumentException(\"The specified path is not a directory.\");\n        }\n        try {\n            Files.list(directoryPath)\n                    .filter(Files::isRegularFile)\n                    .forEach(file -> {\n                        try {\n                            Document document = documentParser.parse(Files.newBufferedReader(file));\n                            documents.add(document);\n                        } catch (IOException e) {\n                            // skip documents that fail to load\n                        }\n                    });\n        } catch (IOException e) {\n            // handle exception\n        }\n        return documents;\n    }\n}\n```", "```java\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class DocumentLoader {\n\n    /**\n     * Loads {@link Document}s from the specified directory. Does not use recursion.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n        try {\n            if (!Files.isDirectory(directoryPath)) {\n                throw new IllegalArgumentException(\"The specified path is not a directory.\");\n            }\n\n            Files.newDirectoryStream(directoryPath)\n                    .forEach(file -> {\n                        try {\n                            String fileContent = new Scanner(file).useDelimiter(\"\\\\A\").next();\n                            documents.add(documentParser.parse(file, fileContent));\n                        } catch (FileNotFoundException e) {\n                            // Skip file if it cannot be read\n                        }\n                    });\n        } catch (IOException e) {\n            System.err.println(\"Error loading documents: \" + e.getMessage());\n        }\n        return documents;\n    }\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n# Natural Language Annotations: /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DocumentLoader {\n\n    public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n        try {\n            Files.walk(directoryPath).forEach(filePath -> {\n                if (Files.isRegularFile(filePath)) {\n                    try {\n                        Document document = documentParser.parseDocument(filePath);\n                        if (document != null) {\n                            documents.add(document);\n                        }\n                    } catch (Exception e) {\n                        // Ignore if document cannot be loaded\n                    }\n                } else if (Files.isDirectory(filePath)) {\n                    documents.addAll(loadDocumentsRecursively(filePath, documentParser));\n                }\n            });\n        } catch (IOException e) {\n            // Handle directory access error\n        }\n        return documents;\n    }\n}\n```", "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.io.FileUtils;\n\npublic class DocumentLoader {\n\n    public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n\n        if (!Files.isDirectory(directoryPath)) {\n            throw new IllegalArgumentException(\"Specified path is not a directory.\");\n        }\n\n        Files.walk(directoryPath).forEach(filePath -> {\n            if (filePath.getFileName().toString().endsWith(\".txt\")) {\n                try {\n                    String content = FileUtils.readFileToString(filePath.toFile());\n                    Document document = documentParser.parseDocument(content);\n                    if (document != null) {\n                        documents.add(document);\n                    }\n                } catch (IOException e) {\n                    System.out.println(\"Error loading document from \" + filePath + \": \" + e.getMessage());\n                }\n            }\n        });\n\n        return documents;\n    }\n}\n```", "```java\nimport java.io.File;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DocumentLoader {\n\n    /**\n     * Recursively loads {@link Document}s from the specified directory and its subdirectories.\n     * <br>\n     * The files are parsed using the specified {@link DocumentParser}.\n     * <br>\n     * Skips any {@code Document}s that fail to load.\n     *\n     * @param directoryPath  The path to the directory with files.\n     * @param documentParser The parser to be used for parsing text from each file.\n     * @return list of documents\n     * @throws IllegalArgumentException If specified path is not a directory.\n     */\n    public static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n        List<Document> documents = new ArrayList<>();\n        Files.walk(directoryPath)\n                .filter(Files::isRegularFile)\n                .forEach(file -> {\n                    try {\n                        String content = new String(Files.readAllBytes(file));\n                        documents.add(documentParser.parseDocument(content));\n                    } catch (IOException e) {\n                        // Ignore files that cannot be loaded\n                    }\n                });\n        return documents;\n    }\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public boolean hasSpaceFor(String text) {\n# Natural Language Annotations: /**\n     * Returns {@code true} if the provided text can be added to the current segment.\n     * @param text The text to check.\n     * @return {@code true} if the provided text can be added to the current segment.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Returns {@code true} if the provided text can be added to the current segment.\n * \n * @param text The text to check.\n * @return {@code true} if the provided text can be added to the current segment.\n */\npublic boolean hasSpaceFor(String text) {\n    // assuming there is a global variable or a method to get the current segment size\n    // and a method to calculate the size of the provided text\n    return getCurrentSegmentSize() + text.length() <= getMaxSegmentSize();\n}\n```", "```java\n/**\n * Returns {@code true} if the provided text can be added to the current segment.\n * \n * @param text The text to check.\n * @return {@code true} if the provided text can be added to the current segment.\n */\npublic boolean hasSpaceFor(String text) {\n    // Assuming some predefined maximum segment size\n    int maxSegmentSize = 100;\n    return text.length() <= maxSegmentSize;\n}\n```", "```java\n/**\n * Returns {@code true} if the provided text can be added to the current segment.\n * \n * @param text The text to check.\n * @return {@code true} if the provided text can be added to the current segment.\n */\npublic boolean hasSpaceFor(String text) {\n    // Assuming there's a variable 'maxSegmentSize' that stores the maximum size of the current segment\n    return text.length() <= maxSegmentSize - currentSegmentSize;\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void append(String text) {\n# Natural Language Annotations: /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Appends the provided text to the current segment.\n * @param text The text to append.\n */\npublic void append(String text) {\n    // Your code to append the text will go here\n}\n```", "```java\npublic void append(String text) {\n    /**\n     * Appends the provided text to the current segment.\n     * @param text The text to append.\n     */\n    // TO DO: implement your logic here\n    // For now, just print the text\n    System.out.println(text);\n}\n```", "```java\n/**\n * Appends the provided text to the current segment.\n * @param text The text to append.\n */\npublic void append(String text) {\n    // your code here\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void prepend(String text) {\n# Natural Language Annotations: /**\n     * Prepends the provided text to the current segment.\n     * @param text The text to prepend.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Prepends the provided text to the current segment.\n * @param text The text to prepend.\n */\npublic void prepend(String text) {\n    StringBuilder sb = new StringBuilder(currentText);\n    sb.insert(0, text);\n    currentText = sb.toString();\n}\n```", "```java\n/**\n * Prepends the provided text to the current segment.\n * @param text The text to prepend.\n */\npublic void prepend(String text) {\n    // implementation of prepend logic here\n    // for example:\n    String currentSegment = getCurrentSegment();\n    String newSegment = text + currentSegment;\n    setCurrentSegment(newSegment);\n}\n```", "```java\n/**\n * Prepends the provided text to the current segment.\n * @param text The text to prepend.\n */\npublic void prepend(String text) {\n    // check if text is not null\n    if (text != null) {\n        // prepend the text to the current segment\n        StringBuilder sb = new StringBuilder(currentSegment);\n        currentSegment = sb.insert(0, text).toString();\n    }\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public AiServices<T> retriever(Retriever<TextSegment> retriever) {\n# Natural Language Annotations: /**\n     * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n     * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n     * <br>\n     * Configures a retriever that will be invoked on every method call to fetch relevant information\n     * related to the current user message from an underlying source (e.g., embedding store).\n     * This relevant information is automatically injected into the message sent to the LLM.\n     *\n     * @param retriever The retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n * <br>\n * Configures a retriever that will be invoked on every method call to fetch relevant information\n * related to the current user message from an underlying source (e.g., embedding store).\n * This relevant information is automatically injected into the message sent to the LLM.\n *\n * @param retriever The retriever to be used by the AI Service.\n * @return builder\n */\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    // Add logic to configure the retriever here\n    // For example:\n    this.retriever = retriever;\n    return this;\n}\n```", "```java\n/**\n * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n * <br>\n * Configures a retriever that will be invoked on every method call to fetch relevant information\n * related to the current user message from an underlying source (e.g., embedding store).\n * This relevant information is automatically injected into the message sent to the LLM.\n *\n * @param retriever The retriever to be used by the AI Service.\n * @return builder\n */\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    // implementation details\n    // for now, just return the builder\n    return this;\n}\n```", "```java\n/**\n * Deprecated. Use {@link #contentRetriever(ContentRetriever)}\n * (e.g. {@link EmbeddingStoreContentRetriever}) instead.\n * <br>\n * Configures a retriever that will be invoked on every method call to fetch relevant information\n * related to the current user message from an underlying source (e.g., embedding store).\n * This relevant information is automatically injected into the message sent to the LLM.\n *\n * @param retriever The retriever to be used by the AI Service.\n * @return builder\n * @deprecated\n */\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    // Implementation\n    // ...\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n# Natural Language Annotations: /**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n     * a customized {@link RetrievalAugmentor}.\n     * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Configures a content retriever to be invoked on every method call for retrieving relevant content\n * related to the user's message from an underlying data source\n * (e.g., an embedding store in the case of an {@link EmbeddingStoreContentRetriever}).\n * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n * <br>\n * This method provides a straightforward approach for those who do not require\n * a customized {@link RetrievalAugmentor}.\n * It configures a {@link DefaultRetrievalAugmentor} with the provided {@link ContentRetriever}.\n *\n * @param contentRetriever The content retriever to be used by the AI Service.\n * @return builder\n */\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    this.retrievalAugmentor = new DefaultRetrievalAugmentor(contentRetriever);\n    return this;\n}\n```", "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    // Configures a DefaultRetrievalAugmentor with the provided ContentRetriever.\n    this.retrievalAugmentor = new DefaultRetrievalAugmentor(contentRetriever);\n    return this;\n}\n```", "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    /**\n     * Configures a content retriever to be invoked on every method call for retrieving relevant content\n     * related to the user's message from an underlying data source\n     * (e.g., an embedding store in the case of an EmbeddingStoreContentRetriever).\n     * The retrieved relevant content is then automatically incorporated into the message sent to the LLM.\n     * <br>\n     * This method provides a straightforward approach for those who do not require\n     * a customized RetrievalAugmentor.\n     * It configures a DefaultRetrievalAugmentor with the provided ContentRetriever.\n     *\n     * @param contentRetriever The content retriever to be used by the AI Service.\n     * @return builder\n     */\n    this.contentRetriever = contentRetriever;\n    return this;\n}\n```"]}, "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public String add(Embedding embedding) {\n# Natural Language Annotations: /**\n     * Adds a given embedding to the store.\n     *\n     * @param embedding The embedding to be added to the store.\n     * @return The auto-generated ID associated with the added embedding.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic String add(Embedding embedding) {\n    // Generate a unique ID for the new embedding\n    String newId = UUID.randomUUID().toString();\n\n    // Add the embedding to the store\n    store.put(newId, embedding);\n\n    // Return the generated ID\n    return newId;\n}\n```", "```java\n@Override\npublic String add(Embedding embedding) {\n    // Generate a unique ID for the new embedding\n    String newId = UUID.randomUUID().toString();\n\n    // Add the new embedding to the store with its generated ID\n    store.put(newId, embedding);\n\n    // Return the new ID\n    return newId;\n}\n```", "```java\n/**\n * Adds a given embedding to the store.\n *\n * @param embedding The embedding to be added to the store.\n * @return The auto-generated ID associated with the added embedding.\n */\n@Override\npublic String add(Embedding embedding) {\n    // Generate a unique ID for the new embedding\n    String id = UUID.randomUUID().toString();\n    \n    // Store the embedding with the generated ID\n    storeEmbeddings.put(id, embedding);\n    \n    return id;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n# Natural Language Annotations: /**\n     * Returns {@link ToolSpecification}s for all methods annotated with @{@link Tool} within the specified class.\n     *\n     * @param classWithTools the class.\n     * @return the {@link ToolSpecification}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.sun.source.tree.Tree;\nimport com.sun.source.util.TreePath;\nimport com.sun.source.util.Trees;\nimport com.sun.source.util.TreeScanner;\nimport com.sun.tools.javac.api.JavacTrees;\nimport com.sun.tools.javac.code.Symbol;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.TreeScanner;\n\nimport javax.tools.JavaCompiler;\nimport javax.tools.JavaFileObject;\n\npublic class ToolSpecificationExtractor {\n    public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) throws Exception {\n        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n        JavaFileObject file = JavaSourceFromString.create(\"temp\", \"public class Temp {\" + classWithTools.getName() + \" temp;\");\n        int compilationResult = compiler.getStandardFileManager(null, null, null).getJavaFileObjects(file).toArray(new JavaFileObject[0]);\n        if (compilationResult != 0) {\n            throw new Exception(\"Compilation failed\");\n        }\n        Trees trees = JavacTrees.instance(compiler.getTask(null, null, null, null, null, file).call());\n        return new ToolSpecificationScanner(trees.parse(file, \"Temp\").getCompilationUnit()).scan();\n    }\n\n    private static class ToolSpecificationScanner extends TreeScanner<List<ToolSpecification>, Void> {\n        private List<ToolSpecification> specifications;\n\n        public ToolSpecificationScanner(JCTree tree) {\n            super();\n            this.specifications = new ArrayList<>();\n        }\n\n        @Override\n        public Void visitMethodDecl(JCTree.MethodDecl tree) {\n            if (tree.getModifiers().isStatic() && tree.getModifiers().isPublic()) {\n                for (JCTree.Tree tree1 : tree.getBody().getStatements()) {\n                    if (tree1 instanceof JCTree.TreeMethodInvocation) {\n                        JCTree.TreeMethodInvocation invocation = (JCTree.TreeMethodInvocation) tree1;\n                        if (invocation.getExpression().toString().contains(\"Tool\")) {\n                            specifications.add(new ToolSpecification(tree, invocation));\n                        }\n                    }\n                }\n            }\n            return super.visitMethodDecl(tree);\n        }\n\n        public List<ToolSpecification> scan() {\n            return specifications;\n        }\n    }\n\n    private static class ToolSpecification {\n        private JCTree.MethodDecl method;\n        private JCTree.TreeMethodInvocation invocation;\n\n        public ToolSpecification(JCTree.MethodDecl method, JCTree.TreeMethodInvocation invocation) {\n            this.method = method;\n            this.invocation = invocation;\n        }\n\n        @Override\n        public String toString() {\n            return \"ToolSpecification{\" +\n                    \"method=\" + method +\n                    \", invocation=\" + invocation +\n                    '}';\n        }\n    }\n}\n```", "```java\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.annotation.processing.RoundEnvironment;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\n\nimport java.util.stream.Collectors;\n\npublic class ToolSpecifications {\n    public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n        List<ToolSpecification> toolSpecifications = new ArrayList<>();\n\n        for (Method method : classWithTools.getMethods()) {\n            if (method.isAnnotationPresent(Tool.class)) {\n                Tool toolAnnotation = method.getAnnotation(Tool.class);\n                ToolSpecification toolSpecification = new ToolSpecification(method, toolAnnotation);\n                toolSpecifications.add(toolSpecification);\n            }\n        }\n\n        return toolSpecifications;\n    }\n}\n```", "```java\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.annotation.processing.ProcessingEnvironment;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.ExecutableElement;\nimport javax.lang.model.element.TypeElement;\nimport javax.lang.model.type.TypeMirror;\nimport javax.lang.model.util.Elements;\nimport javax.lang.model.util.Types;\n\nimport com.google.auto.service.AutoService;\n\n@AutoService(Processor.class)\npublic class ToolSpecificationProcessor implements Processor {\n\n    @Override\n    public Set<? extends AbstractProcessor> getSupportedAnnotationTypes() {\n        return Set.of(Tool.class.getName());\n    }\n\n    @Override\n    public boolean process(Set<? extends TypeElement> annotations, ProcessingEnvironment processingEnv) {\n        for (TypeElement typeElement : annotations) {\n            if (typeElement.getQualifiedName().contentEquals(Tool.class.getName())) {\n                Elements elementUtils = processingEnv.getElementUtils();\n                Types typeUtils = processingEnv.getTypeUtils();\n                TypeMirror classMirror = typeElement.asType();\n\n                for (Element enclosedElement : elementUtils.getAllMembers(classMirror).stream()\n                        .filter(element -> element instanceof ExecutableElement)\n                        .map(element -> (ExecutableElement) element)\n                        .collect(Collectors.toList())) {\n\n                    if (enclosedElement.getAnnotation(Tool.class) != null) {\n                        Tool toolAnnotation = enclosedElement.getAnnotation(Tool.class);\n                        String toolName = toolAnnotation.name();\n                        String toolDescription = toolAnnotation.description();\n\n                        ToolSpecification toolSpecification = new ToolSpecification(toolName, toolDescription);\n                        toolSpecifications.add(toolSpecification);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    private List<ToolSpecification> toolSpecifications = new ArrayList<>();\n\n    public static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n        return toolSpecifications;\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ToolSpecification toolSpecificationFrom(Method method) {\n# Natural Language Annotations: /**\n     * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n     *\n     * @param method the method.\n     * @return the {@link ToolSpecification}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n *\n * @param method the method.\n * @return the {@link ToolSpecification}.\n */\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    return method.getAnnotation(Tool.class);\n}\n```", "```java\n/**\n * Returns the {@link ToolSpecification} for the given method annotated with {@link Tool}.\n *\n * @param method the method.\n * @return the {@link ToolSpecification}.\n */\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    return method.getAnnotation(Tool.class);\n}\n```", "```java\n/**\n * Returns the {@link ToolSpecification} for the given method annotated with @{@link Tool}.\n *\n * @param method the method.\n * @return the {@link ToolSpecification}.\n */\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    return method.getAnnotation(Tool.class);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n# Natural Language Annotations: /**\n     * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n     *\n     * @param parameter the parameter.\n     * @return the {@link JsonSchemaProperty}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class JsonSchemaPropertyConverter {\n    public static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n        List<JsonSchemaProperty> jsonSchemaProperties = new ArrayList<>();\n\n        if (parameter instanceof MethodParameter) {\n            MethodParameter methodParameter = (MethodParameter) parameter;\n            JsonSchemaProperty jsonSchemaProperty = new JsonSchemaProperty();\n            // Implement logic to populate jsonSchemaProperty based on methodParameter\n            jsonSchemaProperty.setTitle(methodParameter.getName());\n            jsonSchemaProperties.add(jsonSchemaProperty);\n        } else if (parameter instanceof Field) {\n            Field field = (Field) parameter;\n            JsonSchemaProperty jsonSchemaProperty = new JsonSchemaProperty();\n            // Implement logic to populate jsonSchemaProperty based on field\n            jsonSchemaProperty.setTitle(field.getName());\n            jsonSchemaProperties.add(jsonSchemaProperty);\n        }\n\n        return jsonSchemaProperties;\n    }\n}\n```", "```java\nimport org.json.JSONObject;\nimport java.util.Iterator;\nimport java.util.stream.Stream;\n\npublic static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    return () -> Stream.of(\n        new JsonSchemaProperty(\"type\", parameter.getType().toString()),\n        new JsonSchemaProperty(\"name\", parameter.getName()),\n        new JsonSchemaProperty(\"description\", parameter.getDescription())\n    );\n}\n```", "```java\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\npublic static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    List<JsonSchemaProperty> properties = new ArrayList<>();\n    // implementation to convert parameter to JsonSchemaProperty and add to properties list\n    // for example:\n    JsonSchemaProperty property = new JsonSchemaProperty();\n    property.setName(parameter.getName());\n    property.setDescription(parameter.getDescription());\n    properties.add(property);\n    return properties;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double between(Embedding embeddingA, Embedding embeddingB) {\n# Natural Language Annotations: /**\n     * Calculates cosine similarity between two vectors.\n     * <p>\n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Calculates cosine similarity between two vectors.\n * <p>\n * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n * It produces a value in the range:\n * <p>\n * -1 indicates vectors are diametrically opposed (opposite directions).\n * <p>\n * 0 indicates vectors are orthogonal (no directional similarity).\n * <p>\n * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n * <p>\n * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n * <p>\n * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n * including other all-zeros vectors.\n *\n * @param embeddingA first embedding vector\n * @param embeddingB second embedding vector\n * @return cosine similarity in the range [-1..1]\n */\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = dotProduct(embeddingA, embeddingB);\n    double magnitudeA = magnitude(embeddingA);\n    double magnitudeB = magnitude(embeddingB);\n    return dotProduct / (magnitudeA * magnitudeB);\n}\n\nprivate static double dotProduct(Embedding embeddingA, Embedding embeddingB) {\n    double sum = 0;\n    for (int i = 0; i < embeddingA.size(); i++) {\n        sum += embeddingA.get(i) * embeddingB.get(i);\n    }\n    return sum;\n}\n\nprivate static double magnitude(Embedding embedding) {\n    double sum = 0;\n    for (double value : embedding) {\n        sum += Math.pow(value, 2);\n    }\n    return Math.sqrt(sum);\n}\n```", "```java\n/**\n * Calculates cosine similarity between two vectors.\n * <p>\n * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n * It produces a value in the range:\n * <p>\n * -1 indicates vectors are diametrically opposed (opposite directions).\n * <p>\n * 0 indicates vectors are orthogonal (no directional similarity).\n * <p>\n * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n * <p>\n * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n * <p>\n * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n * including other all-zeros vectors.\n *\n * @param embeddingA first embedding vector\n * @param embeddingB second embedding vector\n * @return cosine similarity in the range [-1..1]\n */\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    double dotProduct = embeddingA.dotProduct(embeddingB);\n    double magnitudeA = embeddingA.magnitude();\n    double magnitudeB = embeddingB.magnitude();\n    \n    return dotProduct / (magnitudeA * magnitudeB);\n}\n```", "```java\npublic class Main {\n    /**\n     * Calculates cosine similarity between two vectors.\n     * \n     * Cosine similarity measures the cosine of the angle between two vectors, indicating their directional similarity.\n     * It produces a value in the range:\n     * <p>\n     * -1 indicates vectors are diametrically opposed (opposite directions).\n     * <p>\n     * 0 indicates vectors are orthogonal (no directional similarity).\n     * <p>\n     * 1 indicates vectors are pointing in the same direction (but not necessarily of the same magnitude).\n     * <p>\n     * Not to be confused with cosine distance ([0..2]), which quantifies how different two vectors are.\n     * <p>\n     * Embeddings of all-zeros vectors are considered orthogonal to all other vectors;\n     * including other all-zeros vectors.\n     *\n     * @param embeddingA first embedding vector\n     * @param embeddingB second embedding vector\n     * @return cosine similarity in the range [-1..1]\n     */\n    public static double between(Embedding embeddingA, Embedding embeddingB) {\n        double dotProduct = dotProduct(embeddingA, embeddingB);\n        double magnitudeA = magnitude(embeddingA);\n        double magnitudeB = magnitude(embeddingB);\n        return dotProduct / (magnitudeA * magnitudeB);\n    }\n\n    private static double dotProduct(Embedding embeddingA, Embedding embeddingB) {\n        int dimension = embeddingA.size();\n        double sum = 0;\n        for (int i = 0; i < dimension; i++) {\n            sum += embeddingA.get(i) * embeddingB.get(i);\n        }\n        return sum;\n    }\n\n    private static double magnitude(Embedding embedding) {\n        int dimension = embedding.size();\n        double sum = 0;\n        for (int i = 0; i < dimension; i++) {\n            sum += embedding.get(i) * embedding.get(i);\n        }\n        return Math.sqrt(sum);\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated    public Map<String, String> asMap() {\n# Natural Language Annotations: /**\n     * Get a copy of the metadata as a map of key-value pairs.\n     *\n     * @return the metadata as a map of key-value pairs.\n     * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Get a copy of the metadata as a map of key-value pairs.\n *\n * @return the metadata as a map of key-value pairs.\n * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n */\n@Deprecated\npublic Map<String, String> asMap() {\n    return toMap();\n}\n```", "```java\n@Deprecated\npublic Map<String, String> asMap() {\n    return toMap();\n}\n```", "```java\n/**\n * Get a copy of the metadata as a map of key-value pairs.\n *\n * @return the metadata as a map of key-value pairs.\n * @deprecated as of 0.31.0, use {@link #toMap()} instead.\n */\n@Deprecated\npublic Map<String, String> asMap() {\n    return new HashMap<>(toMap());\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Document load(DocumentSource source, DocumentParser parser) {\n# Natural Language Annotations: /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Loads a document from the given source using the given parser.\n *\n * <p>Forwards the source Metadata to the parsed Document.\n *\n * @param source The source from which the document will be loaded.\n * @param parser The parser that will be used to parse the document.\n * @return The loaded document.\n * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n */\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source);\n    if (document.isEmpty()) {\n        throw new BlankDocumentException(\"Parsed document is blank/empty\");\n    }\n    document.setMetadata(source.getMetadata());\n    return document;\n}\n```", "```java\n/**\n * Loads a document from the given source using the given parser.\n *\n * <p>Forwards the source Metadata to the parsed Document.\n *\n * @param source The source from which the document will be loaded.\n * @param parser The parser that will be used to parse the document.\n * @return The loaded document.\n * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n */\npublic static Document load(DocumentSource source, DocumentParser parser) {\n    Document document = parser.parse(source);\n    if (document.isEmpty()) {\n        throw new BlankDocumentException(\"Parsed document is empty\");\n    }\n    document.setMetadata(source.getMetadata());\n    return document;\n}\n```", "```java\n/**\n * Loads a document from the given source using the given parser.\n *\n * <p>Forwards the source Metadata to the parsed Document.\n *\n * @param source The source from which the document will be loaded.\n * @param parser The parser that will be used to parse the document.\n * @return The loaded document.\n * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n */\npublic static Document load(DocumentSource source, DocumentParser parser) throws BlankDocumentException {\n    Document document = parser.parse(source);\n    document.setMetadata(source.getMetadata());\n    if (document.isEmpty()) {\n        throw new BlankDocumentException(\"The parsed document is empty.\");\n    }\n    return document;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String singleText() {\n# Natural Language Annotations: /**\n     * Returns text from a single {@link TextContent}.\n     * Use this accessor only if you are certain that the message contains only a single text.\n     * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n     * a {@link RuntimeException} is thrown.\n     *\n     * @return a single text.\n     * @see #hasSingleText()\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Returns text from a single {@link TextContent}.\n * Use this accessor only if you are certain that the message contains only a single text.\n * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n * a {@link RuntimeException} is thrown.\n *\n * @return a single text.\n * @see #hasSingleText()\n */\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"Message does not contain a single TextContent\");\n    }\n    return getContent().getText();\n}\n```", "```java\n/**\n * Returns text from a single {@link TextContent}.\n * Use this accessor only if you are certain that the message contains only a single text.\n * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n * a {@link RuntimeException} is thrown.\n *\n * @return a single text.\n * @see #hasSingleText()\n */\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"Message does not contain a single text\");\n    }\n    return getContent().getText();\n}\n```", "```java\n/**\n * Returns text from a single {@link TextContent}.\n * Use this accessor only if you are certain that the message contains only a single text.\n * If the message contains multiple {@link Content}s, or if the only {@link Content} is not a {@link TextContent},\n * a {@link RuntimeException} is thrown.\n *\n * @return a single text.\n * @see #hasSingleText()\n */\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"Message does not contain a single text\");\n    }\n    return getContent().getText();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default AugmentationResult augment(AugmentationRequest augmentationRequest) {\n# Natural Language Annotations: /**\n     * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n     *\n     * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n     * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n * <br>\n * This method has a default implementation in order to <b>temporarily</b> support\n * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n *\n * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n */\npublic AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Default implementation will be removed soon, use this method to temporarily support current custom implementations of RetrievalAugmentor\n    // For now, just return the original augmentation request with no changes\n    return augmentationRequest;\n}\n```", "```java\n/**\n * Augments the {@link ChatMessage} provided in the {@link AugmentationRequest} with retrieved {@link Content}s.\n * <br>\n * This method has a default implementation in order to <b>temporarily</b> support\n * current custom implementations of {@code RetrievalAugmentor}. The default implementation will be removed soon.\n *\n * @param augmentationRequest The {@code AugmentationRequest} containing the {@code ChatMessage} to augment.\n * @return The {@link AugmentationResult} containing the augmented {@code ChatMessage}.\n */\npublic AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Temporary default implementation, will be removed soon\n    AugmentationResult result = new AugmentationResult();\n    result.setChatMessage(augmentationRequest.getChatMessage());\n    // Assume ContentRetriever is a class that retrieves content\n    ContentRetriever contentRetriever = new ContentRetriever();\n    List<Content> contents = contentRetriever.retrieveContents(augmentationRequest.getChatMessage());\n    result.setContents(contents);\n    return result;\n}\n```", "```\ndef augment(augmentation_request: AugmentationRequest) -> AugmentationResult:\n    \"\"\"\n    Augments the ChatMessage provided in the AugmentationRequest with retrieved Contents.\n    This method has a default implementation in order to temporarily support current custom implementations of RetrievalAugmentor. The default implementation will be removed soon.\n\n    Args:\n        augmentation_request (AugmentationRequest): The AugmentationRequest containing the ChatMessage to augment.\n\n    Returns:\n        AugmentationResult: The AugmentationResult containing the augmented ChatMessage.\n    \"\"\"\n    # Default implementation will be removed soon\n    # For now, it will return a default AugmentationResult\n    return AugmentationResult(ChatMessage())\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    @Deprecated    public UserMessage augment(UserMessage userMessage, Metadata metadata) {\n# Natural Language Annotations: /**\n     * @deprecated use {@link #augment(AugmentationRequest)} instead.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // use {@link #augment(AugmentationRequest)} instead.\n    return augment(new AugmentationRequest(userMessage, metadata));\n}\n```", "```java\n/**\n * @deprecated use {@link #augment(AugmentationRequest)} instead.\n */\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // This method should be replaced with a call to the new augment method\n    return augment(new AugmentationRequest(userMessage, metadata));\n}\n```", "```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // TODO: implement the deprecated method\n    return null;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n# Natural Language Annotations: /**\n     * Injects given {@link Content}s into a given {@link ChatMessage}.\n     * <br>\n     * This method has a default implementation in order to <b>temporarily</b> support\n     * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n     *\n     * @param contents    The list of {@link Content} to be injected.\n     * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n     *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n     * @return The {@link UserMessage} with the injected {@link Content}s.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic class DefaultContentInjector implements ContentInjector {\n    @Override\n    public UserMessage inject(List<Content> contents, ChatMessage chatMessage) {\n        if (chatMessage instanceof UserMessage) {\n            UserMessage userMessage = (UserMessage) chatMessage;\n            for (Content content : contents) {\n                userMessage.addContent(content);\n            }\n            return userMessage;\n        } else if (chatMessage instanceof SystemMessage) {\n            System.out.println(\"Warning: Cannot inject content into SystemMessage.\");\n            return (UserMessage) chatMessage; // Return the original message\n        } else {\n            throw new UnsupportedOperationException(\"Unsupported chat message type\");\n        }\n    }\n}\n```", "```java\n/**\n * Injects given {@link Content}s into a given {@link ChatMessage}.\n * <br>\n * This method has a default implementation in order to <b>temporarily</b> support\n * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n *\n * @param contents    The list of {@link Content} to be injected.\n * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n * @return The {@link UserMessage} with the injected {@link Content}s.\n */\npublic UserMessage defaultChatMessage(List<Content> contents, ChatMessage chatMessage) {\n    if (chatMessage instanceof UserMessage) {\n        UserMessage userMessage = (UserMessage) chatMessage;\n        for (Content content : contents) {\n            userMessage.addContent(content);\n        }\n    } else if (chatMessage instanceof SystemMessage) {\n        SystemMessage systemMessage = (SystemMessage) chatMessage;\n        for (Content content : contents) {\n            systemMessage.addContent(content);\n        }\n    }\n    return chatMessage;\n}\n```", "```java\n/**\n * Injects given {@link Content}s into a given {@link ChatMessage}.\n * <br>\n * This method has a default implementation in order to <b>temporarily</b> support\n * current custom implementations of {@code ContentInjector}. The default implementation will be removed soon.\n *\n * @param contents    The list of {@link Content} to be injected.\n * @param chatMessage The {@link ChatMessage} into which the {@link Content}s are to be injected.\n *                    Can be either a {@link UserMessage} or a {@link SystemMessage}.\n * @return The {@link UserMessage} with the injected {@link Content}s.\n */\npublic UserMessage defaultChatMessage(List<Content> contents, ChatMessage chatMessage) {\n    if (chatMessage instanceof UserMessage) {\n        UserMessage userMessage = (UserMessage) chatMessage;\n        userMessage.getContents().addAll(contents);\n        return userMessage;\n    } else {\n        throw new UnsupportedOperationException(\"Only UserMessage is supported for default implementation\");\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static boolean areNotNullOrBlank(String... strings) {\n# Natural Language Annotations: /**\n   * Are all the given strings not {@code null} and not blank?\n   * @param strings The strings to check.\n   * @return {@code true} if every string is non-{@code null} and non-empty.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Are all the given strings not {@code null} and not blank?\n * @param strings The strings to check.\n * @return {@code true} if every string is non-{@code null} and non-empty.\n */\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String s : strings) {\n        if (s == null || s.trim().isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "```java\n/**\n * Are all the given strings not {@code null} and not blank?\n * @param strings The strings to check.\n * @return {@code true} if every string is non-{@code null} and non-empty.\n */\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (string == null || string.trim().isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```", "```java\n/**\n * Are all the given strings not {@code null} and not blank?\n * @param strings The strings to check.\n * @return {@code true} if every string is non-{@code null} and non-empty.\n */\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String s : strings) {\n        if (s == null || s.trim().isEmpty()) {\n            return false;\n        }\n    }\n    return true;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String generateUUIDFrom(String input) {\n# Natural Language Annotations: /**\n   * Generates a UUID from a hash of the given input string.\n   * @param input The input string.\n   * @return A UUID.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Generates a UUID from a hash of the given input string.\n * @param input The input string.\n * @return A UUID.\n */\npublic static String generateUUIDFrom(String input) {\n    return UUID.nameUUIDFromBytes(input.getBytes()).toString();\n}\n```", "```java\n/**\n * Generates a UUID from a hash of the given input string.\n * @param input The input string.\n * @return A UUID.\n */\npublic static String generateUUIDFrom(String input) {\n    return java.util.UUID.nameUUIDFromBytes(input.getBytes());\n}\n```", "```java\npublic static String generateUUIDFrom(String input) {\n    /**\n     * Generates a UUID from a hash of the given input string.\n     * @param input The input string.\n     * @return A UUID.\n     */\n    return java.util.UUID.nameUUIDFromBytes(input.getBytes()).toString();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static byte[] readBytes(String url) {\n# Natural Language Annotations: /**\n   * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n   * and from files stored on the local filesystem.\n   *\n   * @param url The URL to read from.\n   * @return The content as bytes.\n   * @throws RuntimeException if the request fails.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.io.IOException;\nimport java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Main {\n    public static byte[] readBytes(String url) {\n        try {\n            if (url.startsWith(\"http\")) {\n                HttpClient client = HttpClient.newHttpClient();\n                HttpRequest request = HttpRequest.newBuilder()\n                        .uri(URI.create(url))\n                        .GET()\n                        .build();\n\n                HttpResponse<byte[]> response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());\n                return response.body();\n            } else {\n                return Files.readAllBytes(Paths.get(url));\n            }\n        } catch (IOException | InterruptedException | IOException e) {\n            throw new RuntimeException(\"Failed to read from \" + url, e);\n        }\n    }\n}\n```", "```java\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Main {\n\n    /**\n     * Reads the content as bytes from the given URL as a GET request for HTTP/HTTPS resources,\n     * and from files stored on the local filesystem.\n     *\n     * @param url The URL to read from.\n     * @return The content as bytes.\n     * @throws RuntimeException if the request fails.\n     */\n    public static byte[] readBytes(String url) throws RuntimeException {\n        try {\n            if (url.startsWith(\"http\")) {\n                URL urlObject = new URL(url);\n                HttpURLConnection connection = (HttpURLConnection) urlObject.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n                return readBytes(connection.getInputStream());\n            } else {\n                return Files.readAllBytes(Paths.get(url));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to read from URL: \" + e.getMessage());\n        }\n    }\n\n    private static byte[] readBytes(InputStream inputStream) throws IOException {\n        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {\n            StringBuilder builder = new StringBuilder();\n            char[] buffer = new char[1024];\n            int bytesRead;\n            while ((bytesRead = reader.read(buffer)) != -1) {\n                builder.append(buffer, 0, bytesRead);\n            }\n            return builder.toString().getBytes();\n        }\n    }\n}\n```", "```java\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class Main {\n\n    public static byte[] readBytes(String url) {\n        try {\n            if (url.startsWith(\"http\")) {\n                URL urlObject = new URL(url);\n                HttpURLConnection connection = (HttpURLConnection) urlObject.openConnection();\n                connection.setRequestMethod(\"GET\");\n                connection.connect();\n                InputStream inputStream = connection.getInputStream();\n                return inputStream.readAllBytes();\n            } else {\n                return Files.readAllBytes(Paths.get(url));\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(\"Request failed\", e);\n        }\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int jitterDelayMillis(int attempt) {\n# Natural Language Annotations: /**\n         * This method returns the jitter delay in milliseconds for a given attempt.\n         * @param attempt The attempt number.\n         * @return The jitter delay in milliseconds.\n         */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * This method returns the jitter delay in milliseconds for a given attempt.\n * @param attempt The attempt number.\n * @return The jitter delay in milliseconds.\n */\npublic int jitterDelayMillis(int attempt) {\n    // For this example, let's assume the jitter delay is a random value between 0 and 1000\n    // In a real-world scenario, this could be replaced with a more complex calculation or algorithm\n    return (int) (Math.random() * 1000);\n}\n```", "```java\n/**\n * This method returns the jitter delay in milliseconds for a given attempt.\n * @param attempt The attempt number.\n * @return The jitter delay in milliseconds.\n */\npublic int jitterDelayMillis(int attempt) {\n    // For example purposes, let's assume jitter delay is 100ms for the first attempt\n    // and increases by 50ms for each subsequent attempt\n    return 100 + (attempt - 1) * 50;\n}\n```", "```java\n/**\n * This method returns the jitter delay in milliseconds for a given attempt.\n * @param attempt The attempt number.\n * @return The jitter delay in milliseconds.\n */\npublic int jitterDelayMillis(int attempt) {\n    // A simple example of jitter delay, this could be a complex function based on the actual requirements\n    return (int) (Math.random() * 2000); // Returns a random delay between 0 and 2000 milliseconds\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static IKeyGenerator getKeyGenerator(String name) {\n# Natural Language Annotations: /**\n     * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n     *\n     * @param name\n     * @return \u4e3b\u952e\u751f\u6210\u5668\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n * \n * @param name\n * @return \u4e3b\u952e\u751f\u6210\u5668\n */\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return new KeyGenerator(name);\n}\n\n// Assuming IKeyGenerator and KeyGenerator are defined elsewhere in the codebase\n```", "```java\n/**\n * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n *\n * @param name\n * @return \u4e3b\u952e\u751f\u6210\u5668\n */\npublic static KeyGenerator getKeyGenerator(String name) {\n    return new KeyGenerator(name);\n}\n```", "```java\n/**\n * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n *\n * @param name\n * @return \u4e3b\u952e\u751f\u6210\u5668\n */\npublic static IKeyGenerator getKeyGenerator(String name) {\n    return new KeyGenerator(name);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public QueryCondition when(boolean effective) {\n# Natural Language Annotations: /**\n     * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n     *\n     * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n     * @return {@link QueryCondition}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n *\n * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n * @return {@link QueryCondition}\n */\npublic QueryCondition when(boolean effective) {\n    return effective ? new QueryCondition() : null;\n}\n```", "```java\n/**\n * \u52a8\u6001\u6761\u4ef6\u6784\u9020\u3002\n *\n * @param effective \u662f\u5426\u542f\u7528\u8be5\u6761\u4ef6\n * @return {@link QueryCondition}\n */\npublic QueryCondition when(boolean effective) {\n    return effective ? new QueryCondition() : null;\n}\n```", "```java\npublic QueryCondition when(boolean effective) {\n    return new QueryCondition(effective);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String methodToProperty(String name) {\n# Natural Language Annotations: /**\n     * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Converts a method name to a property name.\n * \n * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n */\npublic static String methodToProperty(String name) {\n    StringBuilder result = new StringBuilder();\n    int i = 0;\n    while (i < name.length()) {\n        char c = name.charAt(i);\n        if (Character.isUpperCase(c)) {\n            if (i > 0) {\n                result.append(\"_\");\n            }\n            result.append(Character.toLowerCase(c));\n        } else {\n            result.append(c);\n        }\n        i++;\n    }\n    return result.toString();\n}\n```", "```java\n/**\n * Converts a method name to a property name.\n * \n * @see org.apache.ibatis.reflection.property.PropertyNamer#methodToProperty(String)\n */\npublic static String methodToProperty(String name) {\n    return name.substring(3, name.length() - 3).replace(\"_\", \"\");\n}\n```", "```java\npublic static String methodToProperty(String name) {\n    return name.substring(3).toLowerCase().replaceFirst(\"^get\", \"\").replaceFirst(\"^is\", \"\").replaceFirst(\"^can\", \"\").replaceFirst(\"^has\", \"\");\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String camelToUnderline(String string) {\n# Natural Language Annotations: /**\n     * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n *\n * @param string\n * @return\n */\npublic static String camelToUnderline(String string) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < string.length(); i++) {\n        char c = string.charAt(i);\n        if (Character.isUpperCase(c)) {\n            if (i > 0) {\n                sb.append('_');\n            }\n            sb.append(Character.toLowerCase(c));\n        } else {\n            sb.append(c);\n        }\n    }\n    return sb.toString();\n}\n```", "```java\n/**\n * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n *\n * @param string\n * @return \n */\npublic static String camelToUnderline(String string) {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < string.length(); i++) {\n        char c = string.charAt(i);\n        if (Character.isUpperCase(c) && i != 0) {\n            sb.append(\"_\");\n        }\n        sb.append(Character.toLowerCase(c));\n    }\n    return sb.toString();\n}\n```", "```java\n/**\n * \u9a7c\u5cf0\u8f6c\u4e0b\u5212\u7ebf\u683c\u5f0f\n *\n * @param string\n * @return String\n */\npublic static String camelToUnderline(String string) {\n    StringBuilder result = new StringBuilder();\n    for (int i = 0; i < string.length(); i++) {\n        char c = string.charAt(i);\n        if (Character.isUpperCase(c) && i != 0) {\n            result.append(\"_\");\n        }\n        result.append(Character.toLowerCase(c));\n    }\n    return result.toString();\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String underlineToCamel(String string) {\n# Natural Language Annotations: /**\n     * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n     *\n     * @param string\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n *\n * @param string\n * @return\n */\npublic static String underlineToCamel(String string) {\n    String[] words = string.split(\"_\");\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < words.length; i++) {\n        if (i == 0) {\n            sb.append(words[i]);\n        } else {\n            sb.append(Character.toUpperCase(words[i].charAt(0)));\n            sb.append(words[i].substring(1));\n        }\n    }\n    return sb.toString();\n}\n```", "```java\n/**\n * \u4e0b\u5212\u7ebf\u8f6c\u9a7c\u5cf0\u683c\u5f0f\n *\n * @param string\n * @return\n */\npublic static String underlineToCamel(String string) {\n    String[] arr = string.split(\"_\");\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < arr.length; i++) {\n        if (i == 0) {\n            sb.append(arr[i]);\n        } else {\n            sb.append(arr[i].substring(0, 1).toUpperCase()).append(arr[i].substring(1));\n        }\n    }\n    return sb.toString();\n}\n```", "```java\npublic static String underlineToCamel(String string) {\n    if (string == null || string.isEmpty()) {\n        return string;\n    }\n    String[] split = string.split(\"_\");\n    StringBuilder camel = new StringBuilder();\n    for (int i = 0; i < split.length; i++) {\n        if (i == 0) {\n            camel.append(split[i].toLowerCase());\n        } else {\n            camel.append(Character.toUpperCase(split[i].charAt(0)));\n            camel.append(split[i].substring(1).toLowerCase());\n        }\n    }\n    return camel.toString();\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n# Natural Language Annotations: /**\n     * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n     *\n     * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * \u4fee\u590d JDK 1.8 \u4e0b ConcurrentHashMap \u5728\u4e0d\u5b58\u5728 key \u65f6,\u6267\u884c putIfAbsent \u64cd\u4f5c\u5bfc\u81f4\u6b7b\u5faa\u73af\u95ee\u9898\n * \n * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n */\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        synchronized (concurrentHashMap) {\n            value = concurrentHashMap.get(key);\n            if (value == null) {\n                value = mappingFunction.apply(key);\n                concurrentHashMap.put(key, value);\n            }\n        }\n    }\n    return value;\n}\n```", "```java\n/**\n * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n *\n * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n *\n * @param concurrentHashMap\n * @param key\n * @param mappingFunction\n * @return\n */\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value;\n    if ((value = concurrentHashMap.get(key)) != null) {\n        return value;\n    }\n    \n    synchronized (concurrentHashMap) {\n        if ((value = concurrentHashMap.get(key)) != null) {\n            return value;\n        }\n        \n        V newValue = mappingFunction.apply(key);\n        concurrentHashMap.putIfAbsent(key, newValue);\n        return newValue;\n    }\n}\n```", "```java\n/**\n * \u4e3b\u8981\u662f\u7528\u4e8e\u4fee\u590d concurrentHashMap \u5728 jdk1.8 \u4e0b\u7684\u6b7b\u5faa\u73af\u95ee\u9898\n *\n * @see <a href=\"https://bugs.openjdk.org/browse/JDK-8161372\">https://bugs.openjdk.org/browse/JDK-8161372</a>\n */\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        synchronized (concurrentHashMap) {\n            value = concurrentHashMap.get(key);\n            if (value == null) {\n                value = mappingFunction.apply(key);\n                concurrentHashMap.put(key, value);\n            }\n        }\n    }\n    return value;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n# Natural Language Annotations: /**\n     * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n     * This class should be removed once we drop Java 8 support.\n     *\n     * @see <a href=\n     * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n * This class should be removed once we drop Java 8 support.\n *\n * @see <a href=\n * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n */\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    if (map.containsKey(key)) {\n        return map.get(key);\n    } else {\n        V value = mappingFunction.apply(key);\n        map.put(key, value);\n        return value;\n    }\n}\n```", "```java\n/**\n * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n * This class should be removed once we drop Java 8 support.\n *\n * @see <a href=\n * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n */\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value == null) {\n        synchronized (map) {\n            value = map.get(key);\n            if (value == null) {\n                value = mappingFunction.apply(key);\n                map.put(key, value);\n            }\n        }\n    }\n    return value;\n}\n```", "```java\n/**\n * A temporary workaround for Java 8 specific performance issue JDK-8161372 .<br>\n * This class should be removed once we drop Java 8 support.\n *\n * @see <a href=\n * \"https://bugs.openjdk.java.net/browse/JDK-8161372\">https://bugs.openjdk.java.net/browse/JDK-8161372</a>\n */\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    if (!map.containsKey(key)) {\n        map.put(key, mappingFunction.apply(key));\n    }\n    return map.get(key);\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n     *\n     * @param entityClass \u5b9e\u4f53\u7c7b\n     * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    return (BaseMapper<E>) new BaseMapper<>(entityClass);\n}\n```", "```java\n/**\n * \u901a\u8fc7 \u5b9e\u4f53\u7c7b \u83b7\u53d6\u5bf9\u5e94 {@link BaseMapper} \u5bf9\u8c61\u3002\n *\n * @param entityClass \u5b9e\u4f53\u7c7b\n * @param <E>         \u5b9e\u4f53\u7c7b\u7c7b\u578b\n * @return {@link BaseMapper} \u5bf9\u8c61\n */\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    // \u901a\u8fc7\u53cd\u5c04\u83b7\u53d6\u5b9e\u4f53\u7c7b\u5bf9\u5e94\u7684Mapper\u63a5\u53e3\n    Class<? extends BaseMapper<E>> mapperClass = getMapperClass(entityClass);\n    try {\n        // \u83b7\u53d6Mapper\u63a5\u53e3\u7684\u5b9e\u4f8b\n        return mapperClass.getDeclaredConstructor().newInstance();\n    } catch (Exception e) {\n        throw new RuntimeException(\"\u65e0\u6cd5\u521b\u5efaMapper\u5bf9\u8c61\", e);\n    }\n}\n\n// \u901a\u8fc7\u5b9e\u4f53\u7c7b\u83b7\u53d6Mapper\u63a5\u53e3\u7684\u53cd\u5c04\u7c7b\nprivate static <E> Class<? extends BaseMapper<E>> getMapperClass(Class<E> entityClass) {\n    return Class.forName(entityClass.getSimpleName() + \"Mapper\");\n}\n```", "```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    // todo: implement logic to get BaseMapper instance based on entityClass\n    // for example:\n    return new BaseMapper<E>() {\n        @Override\n        public void selectById(Long id) {\n            // todo: implement selectById logic\n        }\n\n        @Override\n        public void selectAll() {\n            // todo: implement selectAll logic\n        }\n\n        // ... other mapper methods\n    };\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <M> M ofMapperClass(Class<M> mapperClass) {\n# Natural Language Annotations: /**\n     * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n     *\n     * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n     * @return {@link BaseMapper} \u5bf9\u8c61\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return mapperClass.newInstance();\n}\n```", "```java\n/**\n * \u901a\u8fc7 {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\u7684 Class \u5f15\u7528\u76f4\u63a5\u83b7\u53d6 {@link BaseMapper} \u4ee3\u7406\u5bf9\u8c61\u3002\n *\n * @param <M> mapper\u7684\u7c7b\u578b\n * @param mapperClass {@link BaseMapper} \u63a5\u53e3\u5b9e\u73b0\n * @return {@link BaseMapper} \u5bf9\u8c61\n */\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return mapperClass.newInstance();\n}\n```", "```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return mapperClass.getConstructor().newInstance();\n}\n```"]}, "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n# Natural Language Annotations: /**\n\t * Streams the audio response for the given speech prompt.\n\t * @param speechPrompt The speech prompt containing the text and options for speech\n\t * synthesis.\n\t * @return A Flux of SpeechResponse objects containing the streamed audio and\n\t * metadata.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    // Implement speech synthesis logic here\n    // For example:\n    return Flux.just(new SpeechResponse(\"Synthesized Audio\", \"Metadata\"))\n            .delayElements(Duration.ofSeconds(1))\n            .take(10); // Stream for 10 seconds\n}\n```", "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    // Implement logic to stream audio response for the given speech prompt\n    // For example, using Project Reactor:\n    return Flux.just(new SpeechResponse(\"Audio response for \" + speechPrompt.getText()))\n            .delayElements(Duration.ofSeconds(1))\n            .repeat(speechPrompt.getRepeatCount());\n}\n```", "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    // Implement the logic to process the speech prompt and generate the audio response\n    // For example, using the Spring WebFlux framework and the Spring Cloud Speech API\n    return webClient.post()\n            .uri(\"https://example.com/speech/api/synthesize\")\n            .header(\"Authorization\", \"Bearer YOUR_API_KEY\")\n            .header(\"Content-Type\", \"application/json\")\n            .bodyValue(speechPrompt)\n            .retrieve()\n            .bodyToFlux(SpeechResponse.class);\n}\n```"]}, "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n# Natural Language Annotations: /**\n\t * Merge the default and request options.\n\t * @param requestOptions request options to merge.\n\t * @return the merged options.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```javascript\n/**\n * Merge the default and request options.\n * @param {Object} requestOptions request options to merge.\n * @return {Object} the merged options.\n */\nfunction mergeOptions(requestOptions) {\n    const defaultOptions = {\n        // default embedding options\n    };\n\n    return { ...defaultOptions, ...requestOptions };\n}\n```", "```\n/**\n * Merge the default and request options.\n * @param {EmbeddingOptions} requestOptions request options to merge.\n * @return {EmbeddingOptions} the merged options.\n */\nfunction mergeOptions(requestOptions) {\n  const defaultOptions = {\n    // default embedding options\n  };\n\n  return { ...defaultOptions, ...requestOptions };\n}\n```", "```javascript\n/**\n * Merge the default and request options.\n * @param {Object} requestOptions request options to merge.\n * @return {Object} the merged options.\n */\nfunction mergeOptions(requestOptions) {\n  // Define the default options\n  const defaultOptions = {\n    host: 'localhost',\n    port: 5432,\n    database: 'postgres',\n    user: 'postgres',\n    password: 'password',\n    ssl: false,\n  };\n\n  // Merge the default options with the request options\n  const mergedOptions = { ...defaultOptions, ...requestOptions };\n\n  // Return the merged options\n  return mergedOptions;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n# Natural Language Annotations: /**\n\t * Return the dimension of the requested embedding generative name. If the generative\n\t * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n\t * count the response dimensions.\n\t * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n\t * @param modelName Embedding generative name to retrieve the dimensions for.\n\t * @param dummyContent Dummy content to use for the empirical dimension calculation.\n\t * @return Returns the embedding dimensions for the modelName.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    try {\n        // Try to get the dimensions from the EmbeddingModel\n        return embeddingModel.getDimensions(modelName);\n    } catch (Exception e) {\n        // If the model name is unknown, use the dummy content to determine the dimensions empirically\n        return embeddingModel.embed(dummyContent).length;\n    }\n}\n```", "```java\n/**\n * Return the dimension of the requested embedding generative name. If the generative\n * name is unknown uses the EmbeddingModel to perform a dummy EmbeddingModel#embed and\n * count the response dimensions.\n *\n * @param embeddingModel Fall-back client to determine, empirically the dimensions.\n * @param modelName Embedding generative name to retrieve the dimensions for.\n * @param dummyContent Dummy content to use for the empirical dimension calculation.\n * @return Returns the embedding dimensions for the modelName.\n */\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    try {\n        // Try to get the dimensions from the model directly\n        return embeddingModel.getDimensions(modelName);\n    } catch (Exception e) {\n        // If the model name is unknown, perform an empirical dimension calculation\n        return embeddingModel.embed(dummyContent, modelName).length;\n    }\n}\n```", "```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    if (modelName != null && !modelName.isEmpty()) {\n        // Try to get the dimensions of the requested embedding model\n        try {\n            return embeddingModel.getDimensions(modelName);\n        } catch (Exception e) {\n            // If the model name is unknown, use the dummy content to perform a dummy embed\n            return embeddingModel.embed(dummyContent).length;\n        }\n    } else {\n        // If the model name is empty, return -1 to indicate unknown dimensions\n        return -1;\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n# Natural Language Annotations: /**\n\t * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n\t * {@link PromptMetadata}.\n\t * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n\t * @throws IllegalArgumentException if the prompt index is less than 0.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.Optional;\n\npublic Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index cannot be less than 0\");\n    }\n    // implementation to find the PromptFilterMetadata at the given index\n    // for simplicity, let's assume we have a list of PromptFilterMetadata\n    // in a class variable called \"promptFilterMetadataList\"\n    return Optional.ofNullable(promptFilterMetadataList.get(promptIndex));\n}\n```", "```java\n/**\n * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n * {@link PromptMetadata}.\n * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n * @throws IllegalArgumentException if the prompt index is less than 0.\n */\npublic Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index cannot be less than 0\");\n    }\n    \n    // Assuming you have a list of PromptFilterMetadata\n    List<PromptFilterMetadata> promptFilterMetadataList = getPromptFilterMetadataList();\n    \n    if (promptIndex < promptFilterMetadataList.size()) {\n        return Optional.of(promptFilterMetadataList.get(promptIndex));\n    } else {\n        return Optional.empty();\n    }\n}\n```", "```java\n/**\n * Returns an {@link Optional} {@link PromptFilterMetadata} at the given index.\n * @param promptIndex index of the {@link PromptFilterMetadata} contained in this\n * {@link PromptMetadata}.\n * @return {@link Optional} {@link PromptFilterMetadata} at the given index.\n * @throws IllegalArgumentException if the prompt index is less than 0.\n */\npublic Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index cannot be less than 0\");\n    }\n    // TO DO: implement the logic to find the PromptFilterMetadata at the given index\n    // For now, just return an empty Optional\n    return Optional.empty();\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: default Long getTotalTokens() {\n# Natural Language Annotations: /**\n\t * Return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @return the total number of tokens from both the {@literal prompt} of an AI request\n\t * and {@literal generation} of the AI's response.\n\t * @see #getPromptTokens()\n\t * @see #getGenerationTokens()\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Return the total number of tokens from both the {@literal prompt} of an AI request\n * and {@literal generation} of the AI's response.\n * @return the total number of tokens from both the {@literal prompt} of an AI request\n * and {@literal generation} of the AI's response.\n * @see #getPromptTokens()\n * @see #getGenerationTokens()\n */\npublic long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```", "```java\n/**\n * Return the total number of tokens from both the {@literal prompt} of an AI request\n * and {@literal generation} of the AI's response.\n * @return the total number of tokens from both the {@literal prompt} of an AI request\n * and {@literal generation} of the AI's response.\n * @see #getPromptTokens()\n * @see #getGenerationTokens()\n */\npublic long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```", "```java\n/**\n * Return the total number of tokens from both the {@literal prompt} of an AI request\n * and {@literal generation} of the AI's response.\n * @return the total number of tokens from both the {@literal prompt} of an AI request\n * and {@literal generation} of the AI's response.\n * @see #getPromptTokens()\n * @see #getGenerationTokens()\n */\npublic long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Filter.Operand negate(Filter.Operand operand) {\n# Natural Language Annotations: /**\n\t * Transforms the input expression into a semantically equivalent one with negation\n\t * operators propagated thought the expression tree by following the negation rules:\n\t *\n\t * <pre>\n\t * \tNOT(NOT(a)) = a\n\t *\n\t * \tNOT(a AND b) = NOT(a) OR NOT(b)\n\t * \tNOT(a OR b) = NOT(a) AND NOT(b)\n\t *\n\t * \tNOT(a EQ b) = a NE b\n\t * \tNOT(a NE b) = a EQ b\n\t *\n\t * \tNOT(a GT b) = a LTE b\n\t * \tNOT(a GTE b) = a LT b\n\t *\n\t * \tNOT(a LT b) = a GTE b\n\t * \tNOT(a LTE b) = a GT b\n\t *\n\t * \tNOT(a IN [...]) = a NIN [...]\n\t * \tNOT(a NIN [...]) = a IN [...]\n\t * </pre>\n\t * @param operand Filter expression to negate.\n\t * @return Returns an negation of the input expression.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic class Filter {\n    public enum Operand {\n        NOT,\n        AND,\n        OR,\n        EQ,\n        NE,\n        GT,\n        GTE,\n        LT,\n        LTE,\n        IN,\n        NIN\n    }\n\n    public static Operand negate(Operand operand) {\n        switch (operand) {\n            case NOT:\n                return null;\n            case AND:\n                return OR;\n            case OR:\n                return AND;\n            case EQ:\n                return NE;\n            case NE:\n                return EQ;\n            case GT:\n                return LTE;\n            case GTE:\n                return LT;\n            case LT:\n                return GTE;\n            case LTE:\n                return GT;\n            case IN:\n                return NIN;\n            case NIN:\n                return IN;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported operand: \" + operand);\n        }\n    }\n}\n```", "```java\npublic class Filter {\n    public static class Operand {\n        public enum Operator {\n            AND, OR, EQ, NE, GT, LT, GTE, LTE, IN, NIN\n        }\n\n        public Operand left;\n        public Operand right;\n        public Operator op;\n\n        public Operand(Operator op) {\n            this.op = op;\n        }\n\n        public Operand(Operand left, Operator op, Operand right) {\n            this.left = left;\n            this.op = op;\n            this.right = right;\n        }\n    }\n\n    public static Operand negate(Operand operand) {\n        if (operand.op == Operand.Operator.NOT) {\n            return operand.left;\n        } else if (operand.op == Operand.Operator.AND) {\n            return new Operand(operand.left, Operand.Operator.OR, negate(operand.right));\n        } else if (operand.op == Operand.Operator.OR) {\n            return new Operand(operand.left, Operand.Operator.AND, negate(operand.right));\n        } else if (operand.op == Operand.Operator.EQ) {\n            return new Operand(operand.left, Operand.Operator.NE, operand.right);\n        } else if (operand.op == Operand.Operator.NE) {\n            return new Operand(operand.left, Operand.Operator.EQ, operand.right);\n        } else if (operand.op == Operand.Operator.GT) {\n            return new Operand(operand.left, Operand.Operator.LTE, operand.right);\n        } else if (operand.op == Operand.Operator.GTE) {\n            return new Operand(operand.left, Operand.Operator.LT, operand.right);\n        } else if (operand.op == Operand.Operator.LT) {\n            return new Operand(operand.left, Operand.Operator.GTE, operand.right);\n        } else if (operand.op == Operand.Operator.LTE) {\n            return new Operand(operand.left, Operand.Operator.GT, operand.right);\n        } else if (operand.op == Operand.Operator.IN) {\n            return new Operand(operand.left, Operand.Operator.NIN, operand.right);\n        } else if (operand.op == Operand.Operator.NIN) {\n            return new Operand(operand.left, Operand.Operator.IN, operand.right);\n        } else {\n            throw new UnsupportedOperationException(\"Unsupported operator: \" + operand.op);\n        }\n    }\n}\n```", "```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.BinaryOperand) {\n        Filter.BinaryOperand binary = (Filter.BinaryOperand) operand;\n        Filter.Operand left = negate(binary.getLeft());\n        Filter.Operand right = negate(binary.getRight());\n        if (binary.getOperator() == Filter.Operator.AND) {\n            return Filter.createBinaryOperator(Filter.Operator.OR, left, right);\n        } else if (binary.getOperator() == Filter.Operator.OR) {\n            return Filter.createBinaryOperator(Filter.Operator.AND, left, right);\n        } else if (binary.getOperator() == Filter.Operator.EQ) {\n            return Filter.createBinaryOperator(Filter.Operator.NE, left, right);\n        } else if (binary.getOperator() == Filter.Operator.NE) {\n            return Filter.createBinaryOperator(Filter.Operator.EQ, left, right);\n        } else if (binary.getOperator() == Filter.Operator.GT) {\n            return Filter.createBinaryOperator(Filter.Operator.LTE, left, right);\n        } else if (binary.getOperator() == Filter.Operator.GTE) {\n            return Filter.createBinaryOperator(Filter.Operator.LT, left, right);\n        } else if (binary.getOperator() == Filter.Operator.LT) {\n            return Filter.createBinaryOperator(Filter.Operator.GTE, left, right);\n        } else if (binary.getOperator() == Filter.Operator.LTE) {\n            return Filter.createBinaryOperator(Filter.Operator.GT, left, right);\n        } else if (binary.getOperator() == Filter.Operator.IN) {\n            return Filter.createUnaryOperator(Filter.Operator.NIN, left);\n        } else if (binary.getOperator() == Filter.Operator.NIN) {\n            return Filter.createUnaryOperator(Filter.Operator.IN, left);\n        }\n    } else if (operand instanceof Filter.UnaryOperand) {\n        Filter.UnaryOperand unary = (Filter.UnaryOperand) operand;\n        if (unary.getOperator() == Filter.Operator.NOT) {\n            return unary.getOperand();\n        } else {\n            return Filter.createUnaryOperator(Filter.Operator.NOT, operand);\n        }\n    } else {\n        throw new UnsupportedOperationException(\"Unsupported operand type: \" + operand.getClass());\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object and returns an object represented\n\t * by the given class. The JSON property names are used to match the fields to merge.\n\t * The source non-null values override the target values with the same field name. The\n\t * source null values are ignored. If the acceptedFieldNames is not empty, only the\n\t * fields with the given names are merged and returned. If the acceptedFieldNames is\n\t * empty, use the {@code @JsonProperty} names, inferred from the provided clazz.\n\t * @param <T> they type of the class to return.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param clazz the class to return.\n\t * @param acceptedFieldNames the list of field names accepted for the target object.\n\t * @return the merged object represented by the given class.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    if (clazz == null) {\n        throw new NullPointerException(\"Class cannot be null\");\n    }\n\n    if (acceptedFieldNames == null) {\n        acceptedFieldNames = new ArrayList<>();\n        for (Field field : clazz.getDeclaredFields()) {\n            acceptedFieldNames.add(field.getName());\n        }\n    }\n\n    T merged = clazz.newInstance();\n\n    for (String fieldName : acceptedFieldNames) {\n        try {\n            Field field = clazz.getDeclaredField(fieldName);\n            field.setAccessible(true);\n            if (source != null) {\n                field.set(merged, field.get(source));\n            } else if (target != null) {\n                field.set(merged, field.get(target));\n            }\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            // Ignore\n        }\n    }\n\n    return merged;\n}\n```", "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    if (source == null) {\n        return clazz.cast(target);\n    }\n\n    if (acceptedFieldNames != null && !acceptedFieldNames.isEmpty()) {\n        for (String fieldName : acceptedFieldNames) {\n            try {\n                Field field = clazz.getDeclaredField(fieldName);\n                field.setAccessible(true);\n                field.set(target, source.getClass().getField(fieldName).get(source));\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n    } else {\n        for (Field field : clazz.getDeclaredFields()) {\n            field.setAccessible(true);\n            try {\n                field.set(target, source.getClass().getField(field.getName()).get(source));\n            } catch (Exception e) {\n                // ignore\n            }\n        }\n    }\n\n    return clazz.cast(target);\n}\n```", "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    if (clazz == null || source == null) {\n        return null;\n    }\n\n    try {\n        T merged = clazz.newInstance();\n        if (acceptedFieldNames.isEmpty()) {\n            BeanUtils.copyProperties(target, merged);\n        } else {\n            for (String fieldName : acceptedFieldNames) {\n                BeanUtils.copyProperties(target, merged, fieldName);\n            }\n        }\n        BeanUtils.copyProperties(source, merged);\n        return merged;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<String, Object> objectToMap(Object source) {\n# Natural Language Annotations: /**\n\t * Converts the given object to a Map.\n\t * @param source the object to convert to a Map.\n\t * @return the converted Map.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Converts the given object to a Map.\n * \n * @param source the object to convert to a Map.\n * @return the converted Map.\n */\npublic static Map<String, Object> objectToMap(Object source) {\n    if (source == null) {\n        return Collections.emptyMap();\n    }\n\n    if (source instanceof Map) {\n        return (Map<String, Object>) source;\n    }\n\n    if (source instanceof Collection) {\n        Map<String, Object> map = new HashMap<>();\n        int index = 0;\n        for (Object item : (Collection<?>) source) {\n            map.put(\"item_\" + index, item);\n            index++;\n        }\n        return map;\n    }\n\n    if (source instanceof Array) {\n        Map<String, Object> map = new HashMap<>();\n        for (int i = 0; i < Array.getLength(source); i++) {\n            map.put(\"item_\" + i, Array.get(source, i));\n        }\n        return map;\n    }\n\n    if (source instanceof String) {\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"value\", source);\n        return map;\n    }\n\n    Map<String, Object> map = new HashMap<>();\n    map.put(\"class\", source.getClass().getName());\n    map.put(\"value\", source.toString());\n    return map;\n}\n```", "```java\n/**\n * Converts the given object to a Map.\n * @param source the object to convert to a Map.\n * @return the converted Map.\n */\npublic static Map<String, Object> objectToMap(Object source) {\n    if (source instanceof Map) {\n        return (Map<String, Object>) source;\n    } else if (source instanceof Collection) {\n        Map<String, Object> map = new HashMap<>();\n        int i = 0;\n        for (Object obj : (Collection<?>) source) {\n            map.put(\"item\" + i++, obj);\n        }\n        return map;\n    } else if (source instanceof Array) {\n        Map<String, Object> map = new HashMap<>();\n        int i = 0;\n        for (Object obj : (Object[]) source) {\n            map.put(\"item\" + i++, obj);\n        }\n        return map;\n    } else {\n        return new HashMap<>();\n    }\n}\n```", "```java\n/**\n * Converts the given object to a Map.\n * @param source the object to convert to a Map.\n * @return the converted Map.\n */\npublic static Map<String, Object> objectToMap(Object source) {\n    Map<String, Object> map = new HashMap<>();\n    if (source instanceof Map) {\n        return (Map<String, Object>) source;\n    }\n    if (source instanceof Collection) {\n        List<Map<String, Object>> list = new ArrayList<>();\n        for (Object item : (Collection<?>) source) {\n            list.add(objectToMap(item));\n        }\n        return map.putAll(list);\n    }\n    if (source instanceof Object[]) {\n        Map<String, Object> map2 = new HashMap<>();\n        for (Object item : (Object[]) source) {\n            map2.putAll(objectToMap(item));\n        }\n        return map2;\n    }\n    if (source instanceof Map.Entry) {\n        Map<String, Object> map2 = new HashMap<>();\n        map2.put(((Map.Entry<?, ?>) source).getKey().toString(), objectToMap(((Map.Entry<?, ?>) source).getValue()));\n        return map2;\n    }\n    if (source instanceof Iterable) {\n        List<Map<String, Object>> list = new ArrayList<>();\n        for (Object item : (Iterable<?>) source) {\n            list.add(objectToMap(item));\n        }\n        return map.putAll(list);\n    }\n    if (source instanceof Object[]) {\n        Map<String, Object> map2 = new HashMap<>();\n        for (Object item : (Object[]) source) {\n            map2.putAll(objectToMap(item));\n        }\n        return map2;\n    }\n    if (source != null) {\n        map.put(\"value\", source);\n    }\n    return map;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Returns a new instance of the targetBeanClazz that copies the bean values from the\n\t * sourceBean instance.\n\t * @param sourceBean the source bean to copy the values from.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are copied. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param targetBeanClazz the target class, a subclass of the ChatOptions, to convert\n\t * into.\n\t * @param <T> the target class type.\n\t * @return a new instance of the targetBeanClazz with the values from the sourceBean\n\t * instance.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\n\npublic class BeanCopier {\n    public static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) throws Exception {\n        T targetBean = targetBeanClazz.newInstance();\n        Field[] sourceFields = sourceBean.getClass().getDeclaredFields();\n        for (Field field : sourceFields) {\n            if (sourceInterfaceClazz.getMethod(field.getName()).getReturnType().equals(field.getType())) {\n                field.setAccessible(true);\n                Method targetMethod = targetBeanClazz.getMethod(field.getName(), field.getType());\n                targetMethod.invoke(targetBean, field.get(sourceBean));\n            }\n        }\n        return targetBean;\n    }\n}\n```", "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean;\n    try {\n        targetBean = targetBeanClazz.newInstance();\n    } catch (InstantiationException | IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n    for (Method sourceMethod : sourceInterfaceClazz.getMethods()) {\n        String sourceFieldName = sourceMethod.getName();\n        if (sourceFieldName.startsWith(\"get\")) {\n            String fieldName = sourceFieldName.substring(3);\n            fieldName = fieldName.substring(0, 1).toLowerCase() + fieldName.substring(1);\n            try {\n                Method targetMethod = targetBeanClazz.getMethod(\"set\" + fieldName);\n                targetMethod.invoke(targetBean, sourceMethod.invoke(sourceBean));\n            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {\n                // Ignore\n            }\n        }\n    }\n    return targetBean;\n}\n```", "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    T targetBean;\n    try {\n        targetBean = targetBeanClazz.getConstructor().newInstance();\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n    for (Method method : sourceInterfaceClazz.getMethods()) {\n        if (java.lang.reflect.Modifier.isPublic(method.getModifiers()) && !method.getName().startsWith(\"get\") && !method.getName().startsWith(\"set\")) {\n            continue;\n        }\n        String fieldName = method.getName().substring(3);\n        if (method.getName().startsWith(\"get\")) {\n            try {\n                java.lang.reflect.Field field = targetBeanClazz.getField(fieldName);\n                field.set(targetBean, method.invoke(sourceBean));\n            } catch (Exception e) {\n                // Ignore fields that do not exist in the target class\n            }\n        }\n    }\n    return targetBean;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz,\n# Natural Language Annotations: /**\n\t * Merges the source object into the target object. The source null values are\n\t * ignored. Only objects with Getter and Setter methods are supported.\n\t * @param <T> the type of the source and target object.\n\t * @param source the source object to merge.\n\t * @param target the target object to merge into.\n\t * @param sourceInterfaceClazz the source interface class. Only the fields with the\n\t * same name as the interface methods are merged. This allow the source object to be a\n\t * subclass of the source interface with additional, non-interface fields.\n\t * @param overrideNonNullTargetValues if true, the source non-null values override the\n\t * target values with the same field name. If false, the source non-null values are\n\t * ignored.\n\t * @return the merged target object.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Method[] sourceMethods = sourceInterfaceClazz.getMethods();\n    for (Method sourceMethod : sourceMethods) {\n        if (sourceMethod.getName().startsWith(\"get\") && !sourceMethod.getName().equals(\"getClass\")) {\n            String fieldName = sourceMethod.getName().substring(3);\n            fieldName = Character.toLowerCase(fieldName.charAt(0)) + fieldName.substring(1);\n            try {\n                Field field = target.getClass().getDeclaredField(fieldName);\n                field.setAccessible(true);\n                Object sourceValue = sourceMethod.invoke(source);\n                if (sourceValue != null) {\n                    if (overrideNonNullTargetValues) {\n                        field.set(target, sourceValue);\n                    } else if (!field.get(target).equals(sourceValue)) {\n                        field.set(target, sourceValue);\n                    }\n                }\n            } catch (Exception e) {\n                // Ignore fields without matching getter and setter\n            }\n        }\n    }\n    return target;\n}\n```", "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    if (source == null) {\n        return target;\n    }\n\n    for (Method interfaceMethod : sourceInterfaceClazz.getMethods()) {\n        String fieldName = interfaceMethod.getName().replace(\"get\", \"\").replace(\"set\", \"\").toLowerCase();\n\n        try {\n            Field field = source.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n\n            Object sourceValue = field.get(source);\n            Field targetField = target.getClass().getDeclaredField(fieldName);\n            targetField.setAccessible(true);\n\n            if (overrideNonNullTargetValues && sourceValue != null) {\n                targetField.set(target, sourceValue);\n            } else if (sourceValue != null && !sourceValue.equals(targetField.get(target))) {\n                targetField.set(target, sourceValue);\n            }\n        } catch (NoSuchFieldException | IllegalAccessException e) {\n            // ignore fields without getter and setter\n        }\n    }\n\n    return target;\n}\n```", "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    if (source == null || target == null || sourceInterfaceClazz == null) {\n        return target;\n    }\n\n    for (Method method : sourceInterfaceClazz.getDeclaredMethods()) {\n        if (method.getName().startsWith(\"get\") && !method.getName().equals(\"getClass\")) {\n            String fieldName = method.getName().substring(3);\n            fieldName = Character.toLowerCase(fieldName.charAt(0)) + fieldName.substring(1);\n\n            try {\n                Field field = target.getClass().getDeclaredField(fieldName);\n                if (field != null && Modifier.isPublic(field.getModifiers())) {\n                    try {\n                        Object sourceValue = method.invoke(source);\n                        Object targetValue = field.get(target);\n\n                        if (sourceValue != null) {\n                            if (overrideNonNullTargetValues || targetValue == null) {\n                                field.set(target, sourceValue);\n                            }\n                        }\n                    } catch (IllegalAccessException | InvocationTargetException e) {\n                        // ignore\n                    }\n                }\n            } catch (NoSuchFieldException e) {\n                // ignore\n            }\n        }\n    }\n\n    return target;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n# Natural Language Annotations: /**\n\t * Finds classes in a package that are annotated with JsonInclude or have Jackson\n\t * annotations.\n\t * @param packageName The name of the package to search for annotated classes.\n\t * @return A set of TypeReference objects representing the annotated classes found.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.lang.reflect.Modifier;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.PropertyNamingStrategies;\nimport com.fasterxml.jackson.annotation.PropertyNamingStrategy;\n\npublic class JsonAnnotatedClassFinder {\n\n    public static Set<Class<?>> findJsonAnnotatedClassesInPackage(String packageName) {\n        Set<Class<?>> annotatedClasses = new HashSet<>();\n\n        try {\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            String classPath = packageName.replace('.', '/');\n            String packagePath = \"java/lang\".equals(packageName) ? \"\" : \"META-INF/services/\" + classPath + \"/META-INF/\"\n                    + classPath + \".classes\";\n            String[] classes = classLoader.getResources(packagePath).next().list();\n\n            for (String className : classes) {\n                if (className.endsWith(\".class\")) {\n                    String simpleClassName = className.substring(className.indexOf('/') + 1, className.length() - 6);\n                    Class<?> clazz = classLoader.loadClass(packageName + \".\" + simpleClassName);\n\n                    if (clazz.isAnnotationPresent(JsonInclude.class) || clazz.isAnnotationPresent(PropertyNamingStrategies.class)\n                            || clazz.isAnnotationPresent(PropertyNamingStrategy.class)) {\n                        annotatedClasses.add(clazz);\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Handle exception\n        }\n\n        return annotatedClasses;\n    }\n}\n```", "```java\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\nimport org.reflections.Reflections;\nimport org.reflections.util.ClasspathHelper;\nimport org.reflections.util.ConfigurationBuilder;\n\npublic class Main {\n\n    public static Set<Class<?>> findJsonAnnotatedClassesInPackage(String packageName) {\n        Reflections reflections = new Reflections(new ConfigurationBuilder()\n                .setUrls(ClasspathHelper.forPackage(packageName))\n                .setScanners(new org.reflections.scanners.SubTypesScanner(), new org.reflections.scanners.annotations.Scanner()));\n\n        return reflections.getSubTypesOf(Object.class)\n                .stream()\n                .filter(clazz -> clazz.isAnnotationPresent(JsonInclude.class) || clazz.isAnnotationPresent(JacksonAnnotation.class))\n                .collect(Collectors.toSet());\n    }\n}\n```", "```java\nimport java.lang.reflect.Modifier;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\npublic class JsonAnnotationFinder {\n\n    public static Set<Class<?>> findJsonAnnotatedClassesInPackage(String packageName) {\n        Set<Class<?>> annotatedClasses = new HashSet<>();\n\n        try {\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            if (classLoader == null) {\n                classLoader = ClassLoader.getSystemClassLoader();\n            }\n\n            Set<Class<?>> classes = new HashSet<>();\n            String packagePath = packageName.replace('.', '/');\n            String packageResourceName = packagePath.replace('.', '/') + \".class\";\n            java.net.URL packageResource = classLoader.getResource(packageResourceName);\n            if (packageResource != null) {\n                String packageDir = packageResource.getFile().getParentFile().getPath();\n                classes = findClassesInPackage(packageDir);\n            } else {\n                classes = findClassesInPackage(packageName);\n            }\n\n            for (Class<?> clazz : classes) {\n                if (isAnnotatedWithJsonInclude(clazz) || isAnnotatedWithJackson(clazz)) {\n                    annotatedClasses.add(clazz);\n                }\n            }\n        } catch (Exception e) {\n            // Handle the exception\n        }\n\n        return annotatedClasses;\n    }\n\n    private static Set<Class<?>> findClassesInPackage(String packageName) {\n        Set<Class<?>> classes = new HashSet<>();\n\n        try {\n            String packagePath = packageName.replace('.', '/');\n            String packageResourceName = packagePath.replace('.', '/') + \".class\";\n            java.net.URL packageResource = Thread.currentThread().getContextClassLoader().getResource(packageResourceName);\n            if (packageResource != null) {\n                String packageDir = packageResource.getFile().getParentFile().getPath();\n                classes = findClassesInPackage(packageDir);\n            } else {\n                String classpath = System.getProperty(\"java.class.path\");\n                String[] paths = classpath.split(System.getProperty(\"path.separator\"));\n                for (String path : paths) {\n                    File dir = new File(path);\n                    if (dir.isDirectory()) {\n                        File[] files = dir.listFiles();\n                        if (files != null) {\n                            for (File file : files) {\n                                if (file.isDirectory()) {\n                                    File[] classFiles = file.listFiles();\n                                    if (classFiles != null) {\n                                        for (File classFile : classFiles) {\n                                            if (classFile.getName().endsWith(\".class\")) {\n                                                String className = classFile.getName().substring(0, classFile.getName().length() - 6);\n                                                String classNameWithPackage = packageName + \".\" + className;\n                                                try {\n                                                    classes.add(Class.forName(classNameWithPackage));\n                                                } catch (ClassNotFoundException e) {\n                                                    // Ignore\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        } catch (Exception e) {\n            // Handle the exception\n        }\n\n        return classes;\n    }\n\n    private static Set<Class<?>> findClassesInPackage(String dir) {\n        Set<Class<?>> classes = new HashSet<>();\n\n        File dirFile = new File(dir);\n        if (dirFile.isDirectory()) {\n            File[] files = dirFile.listFiles();\n            if (files != null) {\n                for (File file : files) {\n                    if (file.isDirectory()) {\n                        classes.addAll(findClassesInPackage(file.getAbsolutePath()));\n                    } else if (file.getName().endsWith(\".class\")) {\n                        String className = file.getName().substring(0, file.getName().length() - 6);\n                        try {\n                            classes.add(Class.forName(className));\n                        } catch (ClassNotFoundException e) {\n                            // Ignore\n                        }\n                    }\n                }\n            }\n        }\n\n        return classes;\n    }\n\n    private static boolean isAnnotatedWithJsonInclude(Class<?> clazz) {\n        return clazz.isAnnotationPresent(JsonInclude.class);\n    }\n\n    private static boolean isAnnotatedWithJackson(Class<?> clazz) {\n        return clazz.isAnnotationPresent(com.fasterxml.jackson.annotation.JsonRootName.class) || clazz.isAnnotationPresent(com.fasterxml.jackson.annotation.JsonProperty.class);\n    }\n}\n```"]}, "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override\tpublic List<Document> get() {\n# Natural Language Annotations: /**\n\t * Reads and processes the PDF document to extract paragraphs.\n\t * @return A list of {@link Document} objects representing paragraphs.\n\t */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.text.PDFTextProcessor;\nimport org.apache.pdfbox.text.PDFTextStripper;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DocumentReader {\n    \n    public List<Document> get() {\n        try {\n            // Load the PDF document\n            PDDocument pdfDocument = PDDocument.load(new File(\"path_to_your_pdf_file.pdf\"));\n            \n            // Create a PDF text stripper to extract text\n            PDFTextStripper stripper = new PDFTextProcessor();\n            \n            // Extract text from the PDF\n            String text = stripper.getText(pdfDocument);\n            \n            // Split the text into paragraphs\n            String[] paragraphs = text.split(\"\\\\r?\\\\n\\\\r?\\\\n\");\n            \n            // Create a list to store Document objects\n            List<Document> documents = new ArrayList<>();\n            \n            // Process each paragraph\n            for (String paragraph : paragraphs) {\n                // Create a new Document object\n                Document document = new Document(paragraph);\n                \n                // Add the document to the list\n                documents.add(document);\n            }\n            \n            // Close the PDF document\n            pdfDocument.close();\n            \n            // Return the list of documents\n            return documents;\n        } catch (IOException e) {\n            // Handle the exception\n            return new ArrayList<>();\n        }\n    }\n}\n\nclass Document {\n    private String text;\n    \n    public Document(String text) {\n        this.text = text;\n    }\n    \n    // Getters and setters\n    public String getText() {\n        return text;\n    }\n    \n    public void setText(String text) {\n        this.text = text;\n    }\n}\n```", "```java\nimport org.apache.pdfbox.pdmodel.PDDocument;\nimport org.apache.pdfbox.text.PDFTextProcessor;\nimport org.apache.pdfbox.text.PDFTextToHTML;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class DocumentExtractor {\n    \n    /**\n     * Reads and processes the PDF document to extract paragraphs.\n     * @return A list of Document objects representing paragraphs.\n     * @throws IOException if an error occurs while reading the PDF file\n     */\n    @Override\n    public List<Document> get() throws IOException {\n        PDDocument pdfDocument = PDDocument.load(new File(\"path_to_your_pdf_file.pdf\"));\n        PDFTextToHTML pdfTextToHTML = new PDFTextToHTML();\n        String text = pdfTextToHTML.getText(pdfDocument);\n        String[] paragraphs = text.split(\"\\n\\n\");\n        List<Document> documents = new ArrayList<>();\n        for (String paragraph : paragraphs) {\n            Document document = new Document(paragraph);\n            documents.add(document);\n        }\n        pdfDocument.close();\n        return documents;\n    }\n}\n```", "```java\n@Override\npublic List<Document> get() {\n    // Initialize an empty list to store the extracted paragraphs\n    List<Document> paragraphs = new ArrayList<>();\n\n    // Read the PDF document\n    try {\n        PDDocument pdfDocument = PDDocument.load(new File(\"path_to_your_pdf_file.pdf\"));\n\n        // Get the number of pages in the document\n        int numPages = pdfDocument.getNumberOfPages();\n\n        // Process each page in the document\n        for (int page = 0; page < numPages; page++) {\n            // Extract text from the current page\n            PDPage pageObject = pdfDocument.getPage(page);\n            String text = pageObject.getContents().toString();\n\n            // Split the text into paragraphs\n            String[] paragraphsArray = text.split(\"\\n\\n\");\n\n            // Process each paragraph\n            for (String paragraph : paragraphsArray) {\n                // Remove leading and trailing whitespace\n                paragraph = paragraph.trim();\n\n                // Create a new Document object\n                Document doc = new Document(paragraph);\n\n                // Add the paragraph to the list\n                paragraphs.add(doc);\n            }\n        }\n\n        // Close the PDF document\n        pdfDocument.close();\n    } catch (IOException e) {\n        // Handle the exception\n    }\n\n    // Return the list of paragraphs\n    return paragraphs;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n# Natural Language Annotations: /**\n     * If the given {@link FixedBitSet} is large enough to hold {@code numBits+1}, returns the given\n     * bits, otherwise returns a new {@link FixedBitSet} which can hold the requested number of bits.\n     *\n     * <p><b>NOTE:</b> the returned bitset reuses the underlying {@code long[]} of the given {@code\n     * bits} if possible. Also, calling {@link #length()} on the returned bits may return a value\n     * greater than {@code numBits}.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * If the given FixedBitSet is large enough to hold numBits+1, returns the given bits, \n * otherwise returns a new FixedBitSet which can hold the requested number of bits.\n *\n * <p><b>NOTE:</b> the returned bitset reuses the underlying long[] of the given bits if possible. \n * Also, calling #length() on the returned bits may return a value greater than numBits.\n */\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() >= numBits + 1) {\n        return bits;\n    } else {\n        return new FixedBitSet(numBits + 1);\n    }\n}\n```", "```java\n/**\n * If the given FixedBitSet is large enough to hold numBits+1, returns the given bits, \n * otherwise returns a new FixedBitSet which can hold the requested number of bits.\n * \n * <p><b>NOTE:</b> the returned bitset reuses the underlying long[] of the given bits if possible. \n * Also, calling #length() on the returned bits may return a value greater than numBits.\n */\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    long[] array = bits.getArray();\n    int currentLength = bits.length();\n    if (currentLength >= numBits + 1) {\n        return bits;\n    } else {\n        long[] newArray = new long[(numBits + 1) / Long.BIT_SIZE];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return new FixedBitSet(newArray);\n    }\n}\n```", "```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() >= numBits + 1) {\n        return bits;\n    } else {\n        return new FixedBitSet(Math.max(numBits + 1, bits.length() << 6));\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void forEach(IntBiConsumer<T> consumer) {\n# Natural Language Annotations: /**\n     * Iterates keys in ascending order and calls the consumer for each non-null key-value pair.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static <K extends Comparable<K>, V> void forEach(Map<K, V> map, IntBiConsumer<K, V> consumer) {\n        if (map == null) {\n            throw new NullPointerException(\"The map is null.\");\n        }\n        \n        for (Map.Entry<K, V> entry : map.entrySet()) {\n            if (entry.getValue() != null) {\n                consumer.accept(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n}\n\n@FunctionalInterface\ninterface IntBiConsumer<T, U> {\n    void accept(T t, U u);\n}\n```", "```java\nimport java.util.*;\n\npublic class Main {\n    public static <K extends Comparable<? super K>, V> void forEach(Map<K, V> map, IntBiConsumer<K, V> consumer) {\n        List<Map.Entry<K, V>> list = new ArrayList<>(map.entrySet());\n        Collections.sort(list, Comparator.comparing(Map.Entry::getKey));\n        for (Map.Entry<K, V> entry : list) {\n            if (entry.getValue() != null) {\n                consumer.accept(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n}\n```", "```java\nimport java.util.*;\n\npublic class Main {\n    public static <T> void forEach(KeyValuePairs<T> pairs, IntBiConsumer<T> consumer) {\n        List<Map.Entry<Integer, T>> list = new ArrayList<>(pairs.entrySet());\n        Collections.sort(list, Comparator.comparing(Map.Entry::getKey));\n        \n        for (Map.Entry<Integer, T> entry : list) {\n            if (entry.getValue() != null) {\n                consumer.accept(entry.getKey(), entry.getValue());\n            }\n        }\n    }\n\n    @FunctionalInterface\n    interface IntBiConsumer<T> {\n        void accept(int key, T value);\n    }\n\n    @FunctionalInterface\n    interface KeyValuePairs<T> {\n        Set<Map.Entry<Integer, T>> entrySet();\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public final long pop() {\n# Natural Language Annotations: /**\n     * Removes and returns the least element of the PriorityQueue in log(size) time.\n     *\n     * @throws IllegalStateException if the LongHeap is empty.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic long pop() {\n    if (isEmpty()) {\n        throw new IllegalStateException(\"Cannot pop from an empty LongHeap\");\n    }\n    long min = heap[0];\n    heap[0] = heap[--size];\n    heapifyDown(0);\n    return min;\n}\n```", "```java\npublic long pop() {\n    if (isEmpty()) {\n        throw new IllegalStateException(\"Heap is empty\");\n    }\n    long min = heap[0];\n    heap[0] = heap[heapSize - 1];\n    heapSize--;\n    heapifyDown(0);\n    return min;\n}\n```", "```java\n/**\n * Removes and returns the least element of the PriorityQueue in log(size) time.\n *\n * @throws IllegalStateException if the PriorityQueue is empty.\n */\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"PriorityQueue is empty\");\n    }\n    long min = heap[0];\n    heap[0] = heap[--size];\n    heapifyDown(0);\n    return min;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @VisibleForTesting    long updateTop(long value) {\n# Natural Language Annotations: /**\n     * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n     * Should be called when the top value changes.\n     * Still log(n) worst case, but it's at least twice as fast to\n     *\n     * <pre class=\"prettyprint\">\n     * pq.updateTop(value);\n     * </pre>\n     * <p>\n     * instead of\n     *\n     * <pre class=\"prettyprint\">\n     * pq.pop();\n     * pq.push(value);\n     * </pre>\n     * <p>\n     * Calling this method on an empty BoundedLongHeap has no visible effect.\n     *\n     * @param value the new element that is less than the current top.\n     * @return the new 'top' element after shuffling the heap.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n * Should be called when the top value changes.\n * Still log(n) worst case, but it's at least twice as fast to\n *\n * <pre class=\"prettyprint\">\n * pq.updateTop(value);\n * </pre>\n * <p>\n * instead of\n *\n * <pre class=\"prettyprint\">\n * pq.pop();\n * pq.push(value);\n * </pre>\n * <p>\n * Calling this method on an empty BoundedLongHeap has no visible effect.\n *\n * @param value the new element that is less than the current top.\n * @return the new 'top' element after shuffling the heap.\n */\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size == 0) {\n        return value;\n    }\n    heapifyUp(value);\n    return heap[0];\n}\n\nprivate void heapifyUp(long value) {\n    int index = size;\n    while (index > 0) {\n        int parentIndex = (index - 1) / 2;\n        if (heap[parentIndex] <= value) {\n            break;\n        }\n        heap[index] = heap[parentIndex];\n        index = parentIndex;\n    }\n    heap[index] = value;\n    size++;\n}\n```", "```\n/**\n * Replace the top of the heap with {@code newTop}, and enforce the heap invariant.\n * Should be called when the top value changes.\n * Still log(n) worst case, but it's at least twice as fast to\n *\n * <pre class=\"prettyprint\">\n * pq.updateTop(value);\n * </pre>\n * <p>\n * instead of\n *\n * <pre class=\"prettyprint\">\n * pq.pop();\n * pq.push(value);\n * </pre>\n * <p>\n * Calling this method on an empty BoundedLongHeap has no visible effect.\n *\n * @param value the new element that is less than the current top.\n * @return the new 'top' element after shuffling the heap.\n */\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size() == 0) return value;\n    heapifyDown(0, value);\n    return getTop();\n}\n\nprivate void heapifyDown(int index, long value) {\n    long top = value;\n    int childIndex = 2 * index + 1;\n    while (childIndex < size()) {\n        if (childIndex + 1 < size() && get(childIndex + 1) < get(childIndex)) {\n            childIndex++;\n        }\n        if (get(childIndex) < top) {\n            set(index, get(childIndex));\n            index = childIndex;\n            childIndex = 2 * index + 1;\n        } else {\n            break;\n        }\n    }\n    set(index, top);\n}\n```", "```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (isEmpty()) {\n        return value;\n    }\n    \n    long top = getTop();\n    if (value < top) {\n        heapifyUp(value);\n        return top;\n    }\n    \n    heapifyDown(value);\n    return value;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, which\n     * is a useful approximation for cosine distance and not really anything else.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    // Note that `similarityFunction` is ignored, you always get Hamming distance similarity with BQ, \n    // which is a useful approximation for cosine distance and not really anything else.\n    return (v) -> 1.0f - (float) v.dotProduct(q) / (v.magnitude() * q.magnitude());\n}\n```", "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return new ScoreFunction.ApproximateScoreFunction(new BQ(q, similarityFunction == null ? new HammingDistance() : similarityFunction));\n}\n```", "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public double score(VectorFloat<?> document) {\n            return 1.0 / (1 + HammingDistance.euclideanDistance(q, document));\n        }\n    };\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static ProductQuantization compute(\n# Natural Language Annotations: /**\n     * Initializes the codebooks by clustering the input data using Product Quantization.\n     *\n     * @param ravv the vectors to quantize\n     * @param M number of subspaces\n     * @param clusterCount number of clusters per subspace\n     * @param globallyCenter whether to center the vectors globally before quantization\n     *                       (not recommended when using the quantization for dot product)\n     * @param anisotropicThreshold the threshold of relevance for anisotropic angular distance shaping, giving\n     *        higher priority to parallel error.  Anisotropic shaping requires that your dataset be normalized\n     *        to unit length.  Use a threshold of UNWEIGHTED for isotropic distance\n     *        (i.e. normal, unweighted L2 distance).\n     * @param simdExecutor     ForkJoinPool instance for SIMD operations, best is to use a pool with the size of\n     *                         the number of physical cores.\n     * @param parallelExecutor ForkJoinPool instance for parallel stream operations\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static class ProductQuantization {\n    public static ProductQuantizer compute(\n            double[][] ravv,\n            int M,\n            int clusterCount,\n            boolean globallyCenter,\n            Object anisotropicThreshold,\n            ForkJoinPool simdExecutor,\n            ForkJoinPool parallelExecutor) {\n\n        // Initialize the product quantizer\n        ProductQuantizer pq = new ProductQuantizer(M, clusterCount);\n\n        // Center the vectors globally if required\n        if (globallyCenter) {\n            double[] centroid = computeCentroid(ravv, parallelExecutor);\n            for (double[] vector : ravv) {\n                vector = subtract(vector, centroid);\n            }\n        }\n\n        // Quantize the vectors\n        for (int m = 0; m < M; m++) {\n            double[][] subspace = new double[ravv.length][];\n            for (int i = 0; i < ravv.length; i++) {\n                subspace[i] = ravv[i][m];\n            }\n            quantizeSubspace(subspace, clusterCount, anisotropicThreshold, simdExecutor, pq);\n        }\n\n        return pq;\n    }\n\n    private static double[] computeCentroid(double[][] vectors, ForkJoinPool parallelExecutor) {\n        double[] sum = new double[vectors[0].length];\n        int count = 0;\n\n        parallelExecutor.submit(() -> {\n            for (double[] vector : vectors) {\n                for (int i = 0; i < vector.length; i++) {\n                    sum[i] += vector[i];\n                    count++;\n                }\n            }\n        }).get();\n\n        for (int i = 0; i < sum.length; i++) {\n            sum[i] /= count;\n        }\n\n        return sum;\n    }\n\n    private static void quantizeSubspace(double[][] subspace, int clusterCount, Object anisotropicThreshold, ForkJoinPool simdExecutor, ProductQuantizer pq) {\n        // Perform k-means clustering on the subspace\n        double[][] centroids = kMeans(subspace, clusterCount, simdExecutor);\n\n        // Create the codebook for the subspace\n        pq.addSubspace(centroids, anisotropicThreshold);\n    }\n\n    private static double[][] kMeans(double[][] data, int k, ForkJoinPool simdExecutor) {\n        double[][] centroids = new double[k][];\n        double[][] clusters = new double[data.length][];\n\n        // Initialize the centroids randomly\n        for (int i = 0; i < k; i++) {\n            centroids[i] = data[simdExecutor.submit(() -> {\n                Random random = new Random();\n                int index = random.nextInt(data.length);\n                return data[index];\n            }).get()];\n        }\n\n        while (true) {\n            // Assign each data point to the closest centroid\n            for (int i = 0; i < data.length; i++) {\n                double minDistance = Double.MAX_VALUE;\n                int closestCentroid = -1;\n                for (int j = 0; j < centroids.length; j++) {\n                    double distance = distance(data[i], centroids[j]);\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                        closestCentroid = j;\n                    }\n                }\n                clusters[i] = centroids[closestCentroid];\n            }\n\n            // Update the centroids\n            for (int i = 0; i < centroids.length; i++) {\n                double sum = 0;\n                for (double[] cluster : clusters) {\n                    sum += cluster[i];\n                }\n                centroids[i] = new double[]{sum / clusters.length};\n            }\n\n            // Check for convergence\n            boolean converged = true;\n            for (int i = 0; i < data.length; i++) {\n                double minDistance = Double.MAX_VALUE;\n                for (int j = 0; j < centroids.length; j++) {\n                    double distance = distance(data[i], centroids[j]);\n                    if (distance < minDistance) {\n                        minDistance = distance;\n                    }\n                    if (minDistance != 0) {\n                        converged = false;\n                    }\n                }\n            }\n\n            if (converged) {\n                break;\n            }\n        }\n\n        return centroids;\n    }\n\n    private static double distance(double[] a, double[] b) {\n        double sum = 0;\n        for (int i = 0; i < a.length; i++) {\n            sum += Math.pow(a[i] - b[i], 2);\n        }\n        return Math.sqrt(sum);\n    }\n}\n```", "```java\npublic static ProductQuantization compute(\n        double[][] ravv,\n        int M,\n        int clusterCount,\n        boolean globallyCenter,\n        double anisotropicThreshold,\n        ExecutorService simdExecutor,\n        ExecutorService parallelExecutor) {\n    // Initialize the codebooks\n    double[][] codebooks = new double[M][clusterCount];\n\n    // Center the vectors globally if required\n    if (globallyCenter) {\n        double[] globalCenter = center(ravv);\n        for (double[] vector : ravv) {\n            vector = subtract(vector, globalCenter);\n        }\n    }\n\n    // Initialize the clusters\n    double[][] clusters = new double[ravv.length][M];\n    for (int i = 0; i < ravv.length; i++) {\n        for (int j = 0; j < M; j++) {\n            clusters[i][j] = ravv[i];\n        }\n    }\n\n    // Perform k-means clustering for each subspace\n    for (int i = 0; i < M; i++) {\n        ExecutorService executor = ExecutorService.of(1);\n        List<Future<?>> futures = new ArrayList<>();\n        for (int j = 0; j < clusterCount; j++) {\n            Future<?> future = executor.submit(new KMeansClusterTask(clusters, i, j));\n            futures.add(future);\n        }\n        executor.shutdown();\n        try {\n            for (Future<?> future : futures) {\n                future.get();\n            }\n        } catch (InterruptedException | ExecutionException e) {\n            Thread.currentThread().interrupt();\n        }\n\n        // Update the codebook for the current subspace\n        double[] codebook = new double[clusterCount];\n        for (int j = 0; j < clusterCount; j++) {\n            codebook[j] = clusters[0][j];\n        }\n        for (int j = 1; j < clusters.length; j++) {\n            double distance = distance(clusters[j][i], codebook);\n            int index = 0;\n            for (int k = 1; k < clusterCount; k++) {\n                if (distance > distance(clusters[j][i], codebook[k])) {\n                    index = k;\n                    break;\n                }\n            }\n            if (distance > distance(clusters[j][i], codebook[index])) {\n                codebook[index] = clusters[j][i];\n            }\n        }\n        codebooks[i] = codebook;\n    }\n\n    // Perform anisotropic angular distance shaping if required\n    if (anisotropicThreshold != Double.NEGATIVE_INFINITY) {\n        double[] unitLengths = new double[ravv.length];\n        for (int i = 0; i < ravv.length; i++) {\n            unitLengths[i] = length(ravv[i]);\n        }\n        double[] angles = new double[ravv.length];\n        for (int i = 0; i < ravv.length; i++) {\n            angles[i] = angle(ravv[i], codebooks[0]);\n        }\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < clusterCount; j++) {\n                double[] subspace = new double[ravv.length];\n                for (int k = 0; k < ravv.length; k++) {\n                    subspace[k] = ravv[k][i];\n                }\n                double angle = angle(subspace, codebooks[i][j]);\n                double weight = Math.exp(-anisotropicThreshold * angle);\n                codebooks[i][j] = weightedAverage(codebooks[i][j], subspace, weight, unitLengths, angles);\n            }\n        }\n    }\n\n    return codebooks;\n}\n\nprivate static double[] center(double[][] vectors) {\n    double[] sum = new double[vectors[0].length];\n    for (double[] vector : vectors) {\n        for (int i = 0; i < vector.length; i++) {\n            sum[i] += vector[i];\n        }\n    }\n    double[] center = new double[sum.length];\n    for (int i = 0; i < sum.length; i++) {\n        center[i] = sum[i] / vectors.length;\n    }\n    return center;\n}\n\nprivate static double[] subtract(double[] vector, double[] center) {\n    double[] result = new double[vector.length];\n    for (int i = 0; i < vector.length; i++) {\n        result[i] = vector[i] - center[i];\n    }\n    return result;\n}\n\nprivate static double distance(double[] vector1, double[] vector2) {\n    double sum = 0;\n    for (int i = 0; i < vector1.length; i++) {\n        sum += Math.pow(vector1[i] - vector2[i], 2);\n    }\n    return Math.sqrt(sum);\n}\n\nprivate static double length(double[] vector) {\n    double sum", "```java\npublic static class ProductQuantization {\n    public static class Quantizer {\n        int[] subspaceCentroids;\n        int[] subspaceCodes;\n\n        public Quantizer(int[] subspaceCentroids, int[] subspaceCodes) {\n            this.subspaceCentroids = subspaceCentroids;\n            this.subspaceCodes = subspaceCodes;\n        }\n    }\n\n    public static Quantizer compute(double[][] ravv, int M, int clusterCount, boolean globallyCenter, double anisotropicThreshold, ExecutorService simdExecutor, ExecutorService parallelExecutor) throws Exception {\n        if (globallyCenter) {\n            double[] means = calculateGlobalMeans(ravv);\n            for (double[] vector : ravv) {\n                for (int i = 0; i < vector.length; i++) {\n                    vector[i] -= means[i];\n                }\n            }\n        }\n\n        double[][][] clusters = new double[M][][];\n        for (int i = 0; i < M; i++) {\n            int[] indices = new int[clusterCount];\n            double[] values = new double[clusterCount];\n            for (double[] vector : ravv) {\n                int code = findClosestCentroid(vector, i);\n                indices[code]++;\n                values[code] += vector[i];\n            }\n            clusters[i] = new double[clusterCount][];\n            for (int j = 0; j < clusterCount; j++) {\n                clusters[i][j] = new double[]{indices[j], values[j]};\n            }\n        }\n\n        int[] centroids = new int[M * clusterCount];\n        int[] codes = new int[M * clusterCount];\n        for (int i = 0; i < M; i++) {\n            Arrays.sort(clusters[i], (a, b) -> Double.compare(a[1], b[1]));\n            for (int j = 0; j < clusterCount; j++) {\n                centroids[i * clusterCount + j] = (int) clusters[i][j][0];\n                codes[i * clusterCount + j] = j;\n            }\n        }\n\n        return new Quantizer(centroids, codes);\n    }\n\n    private static double[] calculateGlobalMeans(double[][] ravv) {\n        double[] means = new double[ravv[0].length];\n        for (double[] vector : ravv) {\n            for (int i = 0; i < vector.length; i++) {\n                means[i] += vector[i];\n            }\n        }\n        for (int i = 0; i < means.length; i++) {\n            means[i] /= ravv.length;\n        }\n        return means;\n    }\n\n    private static int findClosestCentroid(double[] vector, int subspace) {\n        double minDistance = Double.MAX_VALUE;\n        int code = -1;\n        for (int i = 0; i < vector.length; i += subspace + 1) {\n            double distance = 0;\n            for (int j = 0; j < subspace; j++) {\n                distance += Math.pow(vector[i + j] - subspaceCentroids[subspace * j + codes[subspace * j]], 2);\n            }\n            if (distance < minDistance) {\n                minDistance = distance;\n                code = i / (subspace + 1);\n            }\n        }\n        return code;\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ProductQuantization refine(RandomAccessVectorValues ravv,\n# Natural Language Annotations: /**\n     * Create a new PQ by fine-tuning this one with the data in `ravv`\n     *\n     * @param lloydsRounds number of Lloyd's iterations to run against\n     *                     the new data.  Suggested values are 1 or 2.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic class ProductQuantization {\n    \n    public static ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n        // Create a new ProductQuantization object\n        ProductQuantization pq = new ProductQuantization();\n        \n        // Refine the PQ\n        for (int i = 0; i < lloydsRounds; i++) {\n            // Get the codebooks from the input\n            int[][] codebooks = ravv.getCodebooks();\n            \n            // Initialize the centroids\n            int[][] centroids = new int[codebooks.length][codebooks[0].length];\n            for (int j = 0; j < codebooks.length; j++) {\n                int[] centroid = new int[codebooks[j].length];\n                for (int k = 0; k < codebooks[j].length; k++) {\n                    int minDist = Integer.MAX_VALUE;\n                    int minIndex = -1;\n                    for (int l = 0; l < codebooks[j].length; l++) {\n                        int dist = (codebooks[j][l] - codebooks[j][k]) * (codebooks[j][l] - codebooks[j][k]);\n                        if (dist < minDist) {\n                            minDist = dist;\n                            minIndex = l;\n                        }\n                    }\n                    centroid[k] = codebooks[j][minIndex];\n                }\n                centroids[j] = centroid;\n            }\n            \n            // Assign new codes\n            int[][] newCodes = new int[codebooks.length][ravv.size()];\n            for (int j = 0; j < codebooks.length; j++) {\n                for (int k = 0; k < ravv.size(); k++) {\n                    int minDist = Integer.MAX_VALUE;\n                    int minIndex = -1;\n                    for (int l = 0; l < centroids[j].length; l++) {\n                        int dist = (ravv.getVector(k) - centroids[j][l]) * (ravv.getVector(k) - centroids[j][l]);\n                        if (dist < minDist) {\n                            minDist = dist;\n                            minIndex = l;\n                        }\n                    }\n                    newCodes[j][k] = minIndex;\n                }\n            }\n            \n            // Update the codebooks\n            codebooks = newCodes;\n        }\n        \n        // Return the refined PQ\n        return pq;\n    }\n}\n```", "```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Create a new PQ with the same codebook as the current one\n    ProductQuantization newPq = new ProductQuantization(this.codebook);\n\n    // Run Lloyd's iterations on the new data\n    for (int i = 0; i < lloydsRounds; i++) {\n        // Assign each vector to the closest centroid\n        for (Vector v : ravv.getVectors()) {\n            int closestCentroidIndex = getClosestCentroid(v);\n            newPq.codebook.getCentroids()[closestCentroidIndex].addVector(v);\n        }\n\n        // Update the centroids\n        newPq.codebook.updateCentroids();\n    }\n\n    return newPq;\n}\n```", "```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    // Create a new PQ\n    ProductQuantization pq = new ProductQuantization();\n\n    // Copy the centroids from the original PQ to the new one\n    pq.centroids = Arrays.copyOf(ravv.centroids, ravv.centroids.length);\n\n    // Run Lloyd's iterations\n    for (int i = 0; i < lloydsRounds; i++) {\n        // Map each vector to its closest centroid\n        int[] assignments = new int[ravv.size()];\n        for (int j = 0; j < ravv.size(); j++) {\n            assignments[j] = findClosestCentroid(ravv.get(j), pq.centroids);\n        }\n\n        // Update the centroids\n        double[][] newCentroids = new double[pq.centroids.length][];\n        for (int k = 0; k < pq.centroids.length; k++) {\n            double[] sum = new double[pq.centroids[k].length];\n            int count = 0;\n            for (int j = 0; j < ravv.size(); j++) {\n                if (assignments[j] == k) {\n                    for (int d = 0; d < sum.length; d++) {\n                        sum[d] += ravv.get(j)[d];\n                    }\n                    count++;\n                }\n            }\n            if (count > 0) {\n                for (int d = 0; d < sum.length; d++) {\n                    sum[d] /= count;\n                }\n                newCentroids[k] = sum.clone();\n            }\n        }\n\n        // Update the centroids of the PQ\n        pq.centroids = newCentroids;\n    }\n\n    return pq;\n}\n\nprivate int findClosestCentroid(double[] vector, double[][] centroids) {\n    int closest = 0;\n    double minDistance = Double.MAX_VALUE;\n    for (int i = 0; i < centroids.length; i++) {\n        double distance = calculateDistance(vector, centroids[i]);\n        if (distance < minDistance) {\n            minDistance = distance;\n            closest = i;\n        }\n    }\n    return closest;\n}\n\nprivate double calculateDistance(double[] v1, double[] v2) {\n    double sum = 0;\n    for (int i = 0; i < v1.length; i++) {\n        sum += Math.pow(v1[i] - v2[i], 2);\n    }\n    return Math.sqrt(sum);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks, weighing parallel loss more than orthogonal loss.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nprivate byte[] encodeAnisotropic(float[] vector) {\n    // Compute the L2 norm of the vector\n    double norm = Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]);\n\n    // Normalize the vector\n    float[] normalizedVector = new float[3];\n    for (int i = 0; i < 3; i++) {\n        normalizedVector[i] = (float) (vector[i] / norm);\n    }\n\n    // Anisotropic encoding using PQ codebooks\n    float[] encodedVector = new float[3];\n    for (int i = 0; i < 3; i++) {\n        // Assume codebooks are stored in a 3x3 matrix\n        float codebook[][] = new float[][] {\n            {1.0f, 0.0f, 0.0f},\n            {0.0f, 1.0f, 0.0f},\n            {0.0f, 0.0f, 1.0f}\n        };\n\n        // Compute the dot product of the vector and the codebook\n        float dotProduct = 0;\n        for (int j = 0; j < 3; j++) {\n            dotProduct += normalizedVector[j] * codebook[i][j];\n        }\n\n        // Use a threshold to determine the sign of the dot product\n        // For simplicity, we use a threshold of 0.0\n        int sign = (dotProduct > 0.0f) ? 1 : -1;\n\n        // Scale the dot product by the sign\n        float scaledDotProduct = sign * Math.abs(dotProduct);\n\n        // Map the scaled dot product to a byte value\n        byte encodedByte = (byte) (scaledDotProduct * 255.0f);\n\n        encodedVector[i] = encodedByte;\n    }\n\n    // Convert the encoded vector to bytes\n    byte[] encodedBytes = new byte[3];\n    for (int i = 0; i < 3; i++) {\n        encodedBytes[i] = encodedVector[i];\n    }\n\n    return encodedBytes;\n}\n```", "```java\nprivate byte[] encodeAnisotropic(float[] vector) {\n    // Convert the input vector to a PQ-encoded vector with anisotropic weighting\n    int numSubspaces = (int) Math.ceil(Math.sqrt(vector.length));\n    int numBytes = numSubspaces * 4; // assuming 4 bytes per subspace\n    byte[] encodedVector = new byte[numBytes];\n\n    for (int i = 0; i < numSubspaces; i++) {\n        int startIdx = i * 4;\n        int endIdx = Math.min(startIdx + 4, vector.length);\n        float[] subspace = Arrays.copyOfRange(vector, startIdx, endIdx);\n        // Apply anisotropic weighting to the subspace\n        float[] weightedSubspace = new float[subspace.length];\n        for (int j = 0; j < subspace.length; j++) {\n            weightedSubspace[j] = subspace[j] * (1 + j * 0.1f); // example weighting\n        }\n        // Encode the weighted subspace using PQ\n        float[] pqEncodedSubspace = pqEncode(weightedSubspace);\n        // Copy the PQ-encoded subspace to the encoded vector\n        System.arraycopy(pqEncodedSubspace, 0, encodedVector, startIdx, pqEncodedSubspace.length);\n    }\n\n    return encodedVector;\n}\n\nprivate float[] pqEncode(float[] subspace) {\n    // PQ encoding implementation (not provided)\n    // This method should return the PQ-encoded subspace\n    return new float[0]; // placeholder\n}\n```", "```java\nprivate byte[] encodeAnisotropic(FloatVector vector) {\n    // assuming FloatVector is a class with a method to get the number of subspaces\n    int numSubspaces = vector.getNumberOfSubspaces();\n    \n    // assuming PQCodebook is a class that stores the quantized codebooks\n    PQCodebook codebooks = PQCodebook.getInstance();\n    \n    byte[] encodedVector = new byte[numSubspaces];\n    \n    for (int i = 0; i < numSubspaces; i++) {\n        // assuming getSubspaceVector method returns the subspace vector\n        FloatVector subspaceVector = vector.getSubspaceVector(i);\n        \n        // assuming codebookForSubspace method returns the codebook for the current subspace\n        PQCodebook codebook = codebooks.getCodebookForSubspace(i);\n        \n        // assuming encode method encodes the vector using the codebook\n        int encodedValue = codebook.encode(subspaceVector);\n        \n        // weighing parallel loss more than orthogonal loss\n        // assuming a simple example where parallel loss is 2 times orthogonal loss\n        int weightedEncodedValue = (int) (2 * encodedValue + Math.sqrt(encodedValue * encodedValue - 1));\n        \n        encodedVector[i] = (byte) weightedEncodedValue;\n    }\n    \n    return encodedVector;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public ByteSequence<?> encode(VectorFloat<?> vector) {\n# Natural Language Annotations: /**\n     * Encodes the input vector using the PQ codebooks.\n     * @return one byte per subspace\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    return vector.mapToBytes((x) -> (byte) (x * 128));\n}\n```", "```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    // Initialize the encoded bytes array\n    byte[] encodedBytes = new byte[vector.size()];\n\n    // Iterate over the vector and encode each element\n    for (int i = 0; i < vector.size(); i++) {\n        float value = vector.get(i);\n        // Use a simple encoding scheme, e.g., 0-255 for float values\n        // This is a very basic example, in real-world scenarios you would use a more efficient encoding scheme like PQ\n        byte encodedByte = (byte) (value * 255);\n        encodedBytes[i] = encodedByte;\n    }\n\n    // Return the encoded bytes as a ByteSequence\n    return ByteSequence.of(encodedBytes);\n}\n```", "```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    int numSubspaces = vector.size();\n    int numBytesPerSubspace = 4; // Assuming float is 4 bytes\n    ByteSequence<?> encodedVector = new ByteSequence<>(numBytesPerSubspace * numSubspaces);\n    for (int i = 0; i < numSubspaces; i++) {\n        float value = vector.get(i);\n        encodedVector.set(i * numBytesPerSubspace, Float.floatToRawIntBits(value));\n    }\n    return encodedVector;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n */\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Assuming ByteSequence is a sequence of bytes representing a quantized float vector\n    // and VectorFloat is a vector of floats\n    \n    // Convert the ByteSequence to a float array\n    float[] floats = new float[encoded.size()];\n    for (int i = 0; i < encoded.size(); i++) {\n        floats[i] = (float) (encoded.get(i) * 255.0); // Assuming quantization is done with 8-bit values\n    }\n    \n    // Dequantize the float array to get the approximate original vector\n    float[] dequantizedFloats = new float[floats.length];\n    for (int i = 0; i < floats.length; i++) {\n        dequantizedFloats[i] = floats[i] / 255.0; // Assuming dequantization is done by dividing by 255\n    }\n    \n    // Convert the dequantized float array to a VectorFloat\n    target.clear();\n    for (float f : dequantizedFloats) {\n        target.add(f);\n    }\n}\n```", "```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n * \n * @param encoded The quantized representation of the vector as a ByteSequence.\n * @param target The target vector to store the decoded result.\n */\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Assuming ByteSequence and VectorFloat are classes with a method to convert ByteSequence to VectorFloat\n    // This is a simplified example, actual implementation may vary based on the actual classes\n    target.set(encoded.toVector());\n}\n```", "```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n * \n * @param encoded the quantized representation\n * @param target the target vector to store the decoded result\n */\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Assuming ByteSequence is a sequence of bytes and VectorFloat is a vector of floats\n    // We'll use a simple linear scaling to decode the bytes to floats\n    for (int i = 0; i < encoded.size(); i++) {\n        float value = (float) encoded.get(i) / 127; // Assuming 8-bit quantization\n        target.set(i, value);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n# Natural Language Annotations: /**\n     * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n */\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    int[] decoded = new int[encoded.size()];\n    for (int i = 0; i < encoded.size(); i++) {\n        decoded[i] = (int) encoded.get(i);\n    }\n    float[] floatDecoded = new float[decoded.length];\n    for (int i = 0; i < decoded.length; i++) {\n        floatDecoded[i] = (float) decoded[i];\n    }\n    float[] vector = new float[floatDecoded.length];\n    for (int i = 0; i < floatDecoded.length; i++) {\n        vector[i] = floatDecoded[i] * 2 - 128;\n    }\n    // Assuming target is a VectorFloat that has a method to add a vector to it\n    target.add(vector);\n}\n```", "```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n */\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Assuming ByteSequence is a sequence of bytes and VectorFloat is a 1D array of floats\n    float[] floatArray = new float[encoded.size()];\n    for (int i = 0; i < encoded.size(); i++) {\n        floatArray[i] = (float) encoded.get(i);\n    }\n    \n    // Assuming the centroid is the average of all possible values\n    float[] centroid = new float[floatArray.length];\n    for (int i = 0; i < floatArray.length; i++) {\n        centroid[i] = 0;\n    }\n    \n    // Assuming the global centroid is the average of all vectors\n    for (int i = 0; i < target.size(); i++) {\n        centroid[i] += target.get(i);\n    }\n    for (int i = 0; i < centroid.length; i++) {\n        centroid[i] /= target.size();\n    }\n    \n    // Calculate the difference between the encoded vector and the centroid\n    float[] diff = new float[floatArray.length];\n    for (int i = 0; i < floatArray.length; i++) {\n        diff[i] = floatArray[i] - centroid[i];\n    }\n    \n    // Scale the difference by the step size (assuming it's 1)\n    for (int i = 0; i < diff.length; i++) {\n        diff[i] *= 1;\n    }\n    \n    // Add the scaled difference to the centroid to get the decoded vector\n    float[] decoded = new float[floatArray.length];\n    for (int i = 0; i < floatArray.length; i++) {\n        decoded[i] = centroid[i] + diff[i];\n    }\n    \n    // Copy the decoded vector into the target array\n    for (int i = 0; i < target.size(); i++) {\n        target.set(i, decoded[i]);\n    }\n}\n```", "```javascript\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n * \n * @param {Uint8Array} encoded The quantized representation.\n * @param {Float32Array} target The target vector.\n */\nfunction decodeCentered(encoded, target) {\n    // Assuming the encoded array contains the indices of the quantized values\n    // and the target array contains the global centroid values\n    const decoded = new Float32Array(target.length);\n    for (let i = 0; i < encoded.length; i++) {\n        decoded[i] = target[encoded[i]];\n    }\n    return decoded;\n}\n\n// Example usage:\nconst encoded = new Uint8Array([1, 2, 3]);\nconst target = new Float32Array([4.0, 5.0, 6.0]);\nconst decoded = decodeCentered(encoded, target);\nconsole.log(decoded);  // Output: Float32Array [ 4, 5, 6 ]\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public Matrix invert() {\n# Natural Language Annotations: /**\n     * Inverts a square matrix using gaussian elimination.\n     * @return The inverse of the matrix.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Inverts a square matrix using gaussian elimination.\n * @return The inverse of the matrix.\n */\npublic Matrix invert() {\n    int n = this.rows;\n    double[][] augmentedMatrix = new double[n][2 * n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            augmentedMatrix[i][j] = this.matrix[i][j];\n            augmentedMatrix[i][j + n] = 0;\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        // Partial pivoting\n        int maxRow = i;\n        for (int k = i + 1; k < n; k++) {\n            if (Math.abs(augmentedMatrix[k][i]) > Math.abs(augmentedMatrix[maxRow][i])) {\n                maxRow = k;\n            }\n        }\n        // Swap rows\n        double[] temp = augmentedMatrix[i];\n        augmentedMatrix[i] = augmentedMatrix[maxRow];\n        augmentedMatrix[maxRow] = temp;\n        // Make pivot element equal to 1\n        double pivot = augmentedMatrix[i][i];\n        for (int j = i; j < 2 * n; j++) {\n            augmentedMatrix[i][j] /= pivot;\n        }\n        // Eliminate below pivot\n        for (int j = 0; j < n; j++) {\n            if (j != i) {\n                double factor = augmentedMatrix[j][i];\n                for (int k = i; k < 2 * n; k++) {\n                    augmentedMatrix[j][k] -= factor * augmentedMatrix[i][k];\n                }\n            }\n        }\n    }\n    // Create result matrix\n    Matrix result = new Matrix(n, n);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            result.matrix[i][j] = augmentedMatrix[i][j + n];\n        }\n    }\n    return result;\n}\n```", "```java\npublic class Matrix {\n    private double[][] matrix;\n\n    public Matrix(double[][] matrix) {\n        this.matrix = matrix;\n    }\n\n    public Matrix invert() {\n        int n = matrix.length;\n        for (int i = 0; i < n; i++) {\n            // Partial pivoting\n            int maxEl = i;\n            for (int k = i + 1; k < n; k++) {\n                if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxEl][i])) {\n                    maxEl = k;\n                }\n            }\n            // Swap rows\n            double[] temp = matrix[i];\n            matrix[i] = matrix[maxEl];\n            matrix[maxEl] = temp;\n\n            // Make pivot element 1\n            double pivot = matrix[i][i];\n            for (int j = i; j < n + 1; j++) {\n                matrix[i][j] /= pivot;\n            }\n\n            // Eliminate below pivot\n            for (int k = 0; k < n; k++) {\n                if (k != i) {\n                    double multiplier = matrix[k][i];\n                    for (int j = i; j < n + 1; j++) {\n                        matrix[k][j] -= multiplier * matrix[i][j];\n                    }\n                }\n            }\n        }\n\n        // Make upper triangular\n        for (int i = n - 1; i >= 0; i--) {\n            for (int k = i - 1; k >= 0; k--) {\n                double multiplier = matrix[k][i];\n                for (int j = i; j < n + 1; j++) {\n                    matrix[k][j] -= multiplier * matrix[i][j];\n                }\n            }\n        }\n\n        // Make upper triangular into identity\n        for (int i = 0; i < n; i++) {\n            double pivot = matrix[i][i];\n            for (int j = 0; j < n + 1; j++) {\n                matrix[i][j] /= pivot;\n            }\n        }\n\n        // Make identity\n        Matrix result = new Matrix(new double[n][n]);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                result.matrix[i][j] = matrix[i][n + j];\n            }\n        }\n        return result;\n    }\n}\n```", "```java\npublic class Matrix {\n    private double[][] matrix;\n\n    public Matrix(double[][] matrix) {\n        this.matrix = matrix;\n    }\n\n    public Matrix invert() {\n        if (!isSquare()) {\n            throw new RuntimeException(\"Matrix is not square\");\n        }\n\n        int n = matrix.length;\n        for (int i = 0; i < n; i++) {\n            // Partial pivoting\n            int maxRow = i;\n            for (int k = i + 1; k < n; k++) {\n                if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {\n                    maxRow = k;\n                }\n            }\n            swapRows(i, maxRow);\n\n            // Make pivot element equal to 1\n            double pivot = matrix[i][i];\n            for (int j = i; j < n + 1; j++) {\n                matrix[i][j] /= pivot;\n            }\n\n            // Eliminate other elements in the pivot column\n            for (int k = 0; k < n; k++) {\n                if (k != i) {\n                    double factor = matrix[k][i];\n                    for (int j = i; j < n + 1; j++) {\n                        matrix[k][j] -= factor * matrix[i][j];\n                    }\n                }\n            }\n        }\n\n        // Swap rows to get the identity matrix on the left\n        for (int i = n - 1; i >= 0; i--) {\n            for (int k = i + 1; k < n; k++) {\n                double factor = matrix[k][i];\n                for (int j = i; j < n + 1; j++) {\n                    matrix[k][j] -= factor * matrix[i][j];\n                }\n            }\n        }\n\n        // Invert the matrix\n        Matrix invertedMatrix = new Matrix(new double[n][n]);\n        for (int i = 0; i < n; i++) {\n            invertedMatrix.matrix[i][i] = 1;\n            for (int j = 0; j < n; j++) {\n                invertedMatrix.matrix[i][j] = matrix[i][n + j];\n            }\n        }\n        return invertedMatrix;\n    }\n\n    private void swapRows(int i, int j) {\n        double[] temp = matrix[i];\n        matrix[i] = matrix[j];\n        matrix[j] = temp;\n    }\n\n    private boolean isSquare() {\n        return matrix.length == matrix[0].length;\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n# Natural Language Annotations: /**\n   * Returns the cosine similarity between the two vectors.\n   *\n   * @throws IllegalArgumentException if the vectors' dimensions differ.\n   */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Main {\n\n    public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n        RealMatrix matrixA = new Array2DRowRealMatrix(new double[][]{a.toArray()});\n        RealMatrix matrixB = new Array2DRowRealMatrix(new double[][]{b.toArray()});\n        \n        if (matrixA.getRowDimension() != matrixB.getRowDimension() || matrixA.getColumnDimension() != matrixB.getColumnDimension()) {\n            throw new IllegalArgumentException(\"Vectors' dimensions differ.\");\n        }\n\n        return matrixA.transpose().multiply(matrixB).getEntry(0, 0) / (matrixA.normF() * matrixB.normF());\n    }\n}\n```", "```java\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Main {\n    /**\n     * Returns the cosine similarity between the two vectors.\n     *\n     * @param a the first vector\n     * @param b the second vector\n     * @return the cosine similarity between the two vectors\n     * @throws IllegalArgumentException if the vectors' dimensions differ\n     */\n    public static float cosine(float[] a, float[] b) {\n        if (a.length != b.length) {\n            throw new IllegalArgumentException(\"Vectors must have the same dimensions\");\n        }\n        \n        RealMatrix matrixA = new Array2DRowRealMatrix(new double[][]{a});\n        RealMatrix matrixB = new Array2DRowRealMatrix(new double[][]{b});\n        \n        double dotProduct = matrixA.dotProduct(matrixB).getEntry(0, 0);\n        double magnitudeA = matrixA.getNorm(1);\n        double magnitudeB = matrixB.getNorm(1);\n        \n        return (float) (dotProduct / (magnitudeA * magnitudeB));\n    }\n}\n```", "```java\nimport java.lang.Math;\n\npublic class VectorUtil {\n    public static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n        if (a.size() != b.size()) {\n            throw new IllegalArgumentException(\"Vectors must have the same dimension\");\n        }\n        \n        float dotProduct = 0;\n        for (int i = 0; i < a.size(); i++) {\n            dotProduct += a.get(i) * b.get(i);\n        }\n        \n        float magnitudeA = 0;\n        for (float value : a) {\n            magnitudeA += value * value;\n        }\n        magnitudeA = (float) Math.sqrt(magnitudeA);\n        \n        float magnitudeB = 0;\n        for (float value : b) {\n            magnitudeB += value * value;\n        }\n        magnitudeB = (float) Math.sqrt(magnitudeB);\n        \n        return dotProduct / (magnitudeA * magnitudeB);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n# Natural Language Annotations: /**\n     * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n     * is the unique owner of the vectors instance passed in here.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    // Ensure that the query vector is not null\n    if (queryVector == null) {\n        throw new NullPointerException(\"Query vector cannot be null\");\n    }\n    \n    // Ensure that the vectors instance is not null\n    if (vectors == null) {\n        throw new NullPointerException(\"vectors instance cannot be null\");\n    }\n    \n    // Ensure that the similarity function is not null\n    if (similarityFunction == null) {\n        throw new NullPointerException(\"Similarity function cannot be null\");\n    }\n    \n    // Ensure that the graph index is not null\n    if (graph == null) {\n        throw new NullPointerException(\"Graph index cannot be null\");\n    }\n    \n    // Ensure that the accept ords is not null\n    if (acceptOrds == null) {\n        throw new NullPointerException(\"Accept ords cannot be null\");\n    }\n    \n    // Ensure that the topK is a positive integer\n    if (topK <= 0) {\n        throw new IllegalArgumentException(\"TopK must be a positive integer\");\n    }\n    \n    // Perform the search\n    return similarityFunction.search(queryVector, topK, vectors, graph, acceptOrds);\n}\n```", "```java\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    return search(queryVector, topK, vectors, similarityFunction, graph, acceptOrds, null);\n}\n\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds, ExecutorService executor) {\n    if (executor == null) {\n        executor = Executors.newSingleThreadExecutor();\n    }\n    \n    Future<SearchResult> future = executor.submit(() -> {\n        return searchQuery(queryVector, topK, vectors, similarityFunction, graph, acceptOrds);\n    });\n    \n    try {\n        return future.get();\n    } catch (InterruptedException | ExecutionException e) {\n        Thread.currentThread().interrupt();\n        throw new RuntimeException(e);\n    } finally {\n        executor.shutdown();\n    }\n}\n\nprivate static SearchResult searchQuery(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    // This is where the actual search logic would go\n    // For now, just a placeholder\n    return new SearchResult();\n}\n```", "```java\n/**\n * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n * is the unique owner of the vectors instance passed in here.\n */\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    int[] indices = vectors.getIndices(acceptOrds);\n    float[] distances = new float[indices.length];\n    for (int i = 0; i < indices.length; i++) {\n        distances[i] = similarityFunction.apply(queryVector, vectors.get(indices[i]));\n    }\n    return new SearchResult(topK, vectors.getIndices(distances), distances);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int[] nodesCopy() {\n# Natural Language Annotations: /** Returns a copy of the internal nodes array. Not sorted by score! */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic int[] nodesCopy() {\n    return Arrays.copyOf(this.nodes, this.nodes.length);\n}\n```", "```java\n/**\n * Returns a copy of the internal nodes array. Not sorted by score!\n */\npublic int[] nodesCopy() {\n    return nodes.clone();\n}\n```", "```java\npublic int[] nodesCopy() {\n    return this.nodes.clone();\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n# Natural Language Annotations: /**\n     * Rerank results and return the worst approximate score that made it into the topK.\n     * The topK results will be placed into `reranked`, and the remainder into `unused`.\n     * <p>\n     * Only the best result or results whose approximate score is at least `rerankFloor` will be reranked.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodeQueue unused) {\n    // Get the topK results from the unused queue and move them to the reranked queue\n    for (int i = 0; i < topK; i++) {\n        Node node = unused.poll();\n        reranked.add(node);\n    }\n\n    // Continue reranking until the reranked queue is full or there are no more nodes in the unused queue\n    while (reranked.size() < topK && !unused.isEmpty()) {\n        Node node = unused.poll();\n        float score = reranker.exactScore(node);\n        if (score >= rerankFloor) {\n            reranked.add(node);\n        } else {\n            unused.add(node);\n        }\n    }\n\n    // Return the worst approximate score that made it into the topK\n    float worstScore = Float.MAX_VALUE;\n    for (Node node : reranked) {\n        worstScore = Math.min(worstScore, reranker.approximateScore(node));\n    }\n    return worstScore;\n}\n```", "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    int rerankedSize = reranked.size();\n    int unusedSize = unused.size();\n    \n    // Sort the unused nodes by their approximate scores\n    unused.sort((a, b) -> Float.compare(a.approximateScore, b.approximateScore));\n    \n    // Select the topK - rerankedSize nodes from unused\n    int remaining = Math.min(topK - rerankedSize, unusedSize);\n    for (int i = 0; i < remaining; i++) {\n        reranked.add(unused.remove(i));\n    }\n    \n    // Rerank the selected nodes\n    for (int i = 0; i < rerankedSize; i++) {\n        reranked.get(i).exactScore = reranker.exactScore(reranked.get(i));\n    }\n    \n    // Find the worst approximate score that made it into the topK\n    float worstScore = Float.POSITIVE_INFINITY;\n    for (int i = 0; i < topK; i++) {\n        if (reranked.get(i).approximateScore < rerankFloor) {\n            return reranked.get(i).approximateScore;\n        }\n        worstScore = Math.min(worstScore, reranked.get(i).approximateScore);\n    }\n    \n    return worstScore;\n}\n```", "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    while (reranked.size() > topK) {\n        Node node = reranked.poll();\n        if (node.approximateScore() >= rerankFloor) {\n            float exactScore = reranker.getExactScore(node);\n            Node bestNewNode = reranked.peek();\n            if (exactScore > bestNewNode.approximateScore()) {\n                reranked.remove(bestNewNode);\n                reranked.add(node);\n            }\n        } else {\n            unused.add(node);\n        }\n    }\n    return reranked.peek().approximateScore();\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static NodeArray merge(NodeArray a1, NodeArray a2) {\n# Natural Language Annotations: /** always creates a new NodeArray to return, even when a1 or a2 is empty */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Merges two NodeArrays into a new NodeArray.\n * \n * @param a1 The first NodeArray to merge.\n * @param a2 The second NodeArray to merge.\n * @return A new NodeArray containing all elements from a1 and a2.\n */\npublic static NodeArray merge(NodeArray a1, NodeArray a2) {\n    NodeArray result = new NodeArray();\n    result.addAll(a1);\n    result.addAll(a2);\n    return result;\n}\n```", "```java\npublic class NodeArray {\n    // ...\n\n    public static NodeArray merge(NodeArray a1, NodeArray a2) {\n        NodeArray result = new NodeArray();\n        result.addAll(a1);\n        result.addAll(a2);\n        return result;\n    }\n}\n```", "```java\npublic class NodeArray {\n    private Node[] nodes;\n\n    public NodeArray(Node[] nodes) {\n        this.nodes = nodes;\n    }\n\n    public static NodeArray merge(NodeArray a1, NodeArray a2) {\n        Node[] mergedNodes = new Node[a1.nodes.length + a2.nodes.length];\n        System.arraycopy(a1.nodes, 0, mergedNodes, 0, a1.nodes.length);\n        System.arraycopy(a2.nodes, 0, mergedNodes, a1.nodes.length, a2.nodes.length);\n        return new NodeArray(mergedNodes);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void addInOrder(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.Arrays;\n\nclass Node {\n    int value;\n    float score;\n    Node[] children;\n\n    public Node(int value, float score) {\n        this.value = value;\n        this.score = score;\n        this.children = new Node[0];\n    }\n}\n\npublic class NodeArray {\n    private Node[] nodes;\n\n    public NodeArray() {\n        this.nodes = new Node[0];\n    }\n\n    public void addInOrder(int newNode, float newScore) {\n        Node[] newNodes = new Node[nodes.length + 1];\n        System.arraycopy(nodes, 0, newNodes, 0, nodes.length);\n        newNodes[nodes.length] = new Node(newNode, newScore);\n        Arrays.sort(newNodes, (a, b) -> Float.compare(b.score, a.score));\n        nodes = newNodes;\n    }\n}\n```", "```java\nimport java.util.Arrays;\n\npublic class NodeArray {\n    private int[] scores;\n    private int size;\n\n    public NodeArray(int capacity) {\n        scores = new int[capacity];\n        size = 0;\n    }\n\n    public void addInOrder(int newNode, float newScore) {\n        if (size == scores.length) {\n            scores = Arrays.copyOf(scores, scores.length * 2);\n        }\n        int i = size - 1;\n        while (i >= 0 && newScore > scores[i]) {\n            scores[i + 1] = scores[i];\n            i--;\n        }\n        scores[i + 1] = (int) newScore;\n        size++;\n    }\n}\n```", "```java\n/**\n * Add a new node to the NodeArray. The new node must be worse than all previously stored nodes.\n * \n * @param newNode   The new node to be added.\n * @param newScore  The score of the new node.\n */\npublic void addInOrder(int newNode, float newScore) {\n    int size = nodeArray.length;\n    // Check if the node array is empty\n    if (size == 0) {\n        // If empty, add the new node to the array\n        nodeArray[0] = newNode;\n        // Update the scores array\n        scores[0] = newScore;\n    } else {\n        // Find the correct position to insert the new node\n        int i;\n        for (i = 0; i < size; i++) {\n            if (scores[i] > newScore) {\n                // Shift elements to the right to make space for the new node\n                System.arraycopy(scores, i, scores, i + 1, size - i);\n                System.arraycopy(nodeArray, i, nodeArray, i + 1, size - i);\n                // Insert the new node\n                scores[i] = newScore;\n                nodeArray[i] = newNode;\n                return;\n            }\n        }\n        // If the new node is better than all existing nodes, add it to the end\n        scores[size] = newScore;\n        nodeArray[size] = newNode;\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public int insertSorted(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray into a correct sort position according to its score.\n     * Duplicate node + score pairs are ignored.\n     *\n     * @return the insertion point of the new node, or -1 if it already existed\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic int insertSorted(int newNode, float newScore) {\n    int[] array = getArray(); // Assume getArray() returns the NodeArray\n    int[] sortedArray = new int[array.length + 1];\n    int insertPoint = -1;\n    \n    for (int i = 0; i < array.length; i++) {\n        if (array[i] == newNode) {\n            return insertPoint; // Node already exists\n        } else if (array[i] > newNode) {\n            sortedArray[i] = array[i];\n            insertPoint = i;\n            break;\n        }\n    }\n    \n    System.arraycopy(array, 0, sortedArray, 0, array.length);\n    System.arraycopy(array, 0, sortedArray, insertPoint + 1, array.length - insertPoint);\n    sortedArray[insertPoint] = newNode;\n    \n    setArray(sortedArray); // Assume setArray() sets the NodeArray\n    \n    return insertPoint;\n}\n```", "```java\npublic int insertSorted(int newNode, float newScore) {\n    Node[] nodeArray = getNodes();\n    int insertionPoint = -1;\n    for (int i = 0; i < nodeArray.length; i++) {\n        if (nodeArray[i] == newNode) {\n            return insertionPoint;  // duplicate, return -1\n        }\n        if (nodeArray[i] > newNode) {\n            insertionPoint = i;\n            break;\n        }\n    }\n    if (insertionPoint == -1) {\n        insertionPoint = nodeArray.length;\n    }\n    Node[] newArray = new Node[nodeArray.length + 1];\n    System.arraycopy(nodeArray, 0, newArray, 0, insertionPoint);\n    newArray[insertionPoint] = newNode;\n    System.arraycopy(nodeArray, insertionPoint, newArray, insertionPoint + 1, nodeArray.length - insertionPoint);\n    setNodes(newArray);\n    return insertionPoint;\n}\n\n// Assuming Node is a class with a score property\nclass Node {\n    int value;\n    float score;\n    public Node(int value, float score) {\n        this.value = value;\n        this.score = score;\n    }\n}\n\n// Assuming getNodes and setNodes are methods to get and set the global Node array\n```", "```java\npublic int insertSorted(int newNode, float newScore) {\n    int[] nodeArray = new int[100]; // assuming a fixed size array for simplicity\n    int insertPoint = -1;\n    boolean exists = false;\n\n    // Check if the array is not empty\n    if (nodeArray.length > 0) {\n        for (int i = 0; i < nodeArray.length; i++) {\n            if (nodeArray[i] == newNode) {\n                exists = true;\n                break;\n            }\n        }\n    }\n\n    // If the node already exists, return -1\n    if (exists) {\n        return -1;\n    }\n\n    // Find the correct insertion point\n    for (int i = 0; i < nodeArray.length; i++) {\n        if (i == nodeArray.length - 1 || newScore < nodeArray[i + 1]) {\n            insertPoint = i + 1;\n            break;\n        }\n    }\n\n    // Insert the new node at the correct position\n    for (int i = nodeArray.length - 1; i >= insertPoint; i--) {\n        nodeArray[i + 1] = nodeArray[i];\n    }\n\n    nodeArray[insertPoint] = newNode;\n\n    return insertPoint;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void retain(Bits selected) {\n# Natural Language Annotations: /**\n     * Retains only the elements in the current NodeArray whose corresponding index\n     * is set in the given BitSet.\n     * <p>\n     * This modifies the array in place, preserving the relative order of the elements retained.\n     * <p>\n     *\n     * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n     *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Retains only the elements in the current NodeArray whose corresponding index\n * is set in the given BitSet.\n * <p>\n * This modifies the array in place, preserving the relative order of the elements retained.\n *\n * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n */\npublic void retain(Bits selected) {\n    int i = 0;\n    int j = 0;\n    while (i < selected.length()) {\n        if (selected.get(i)) {\n            // Swap the element at index i with the element at index j\n            Node temp = NodeArray[i];\n            NodeArray[i] = NodeArray[j];\n            NodeArray[j] = temp;\n            j++;\n        }\n        i++;\n    }\n    // Remove the elements that were not retained\n    NodeArray = Arrays.copyOf(NodeArray, j);\n}\n```", "```java\npublic void retain(Bits selected) {\n    int writeIndex = 0;\n    for (int i = 0; i < selected.length(); i++) {\n        if (selected.get(i)) {\n            NodeArray[writeIndex++] = NodeArray[i];\n        }\n    }\n    // Shift elements to the left to fill the gaps created by removal\n    while (writeIndex < NodeArray.length) {\n        NodeArray[writeIndex++] = null;\n    }\n}\n```", "```java\n/**\n * Retains only the elements in the current NodeArray whose corresponding index\n * is set in the given BitSet.\n * <p>\n * This modifies the array in place, preserving the relative order of the elements retained.\n *\n * @param selected A BitSet where the bit at index i is set if the i-th element should be retained.\n *                 (Thus, the elements of selected represent positions in the NodeArray, NOT node ids.)\n */\npublic void retain(Bits selected) {\n    int writeIndex = 0;\n    for (int i = 0; i < selected.length(); i++) {\n        if (selected.get(i)) {\n            NodeArray[writeIndex++] = NodeArray[i];\n        }\n    }\n    // Shift elements to the left to remove indices that were not selected\n    System.arraycopy(NodeArray, 0, NodeArray, 0, writeIndex);\n    // Remove the unselected elements\n    System.arraycopy(NodeArray, writeIndex, NodeArray, writeIndex, NodeArray.length - writeIndex);\n    NodeArray = Arrays.copyOf(NodeArray, writeIndex);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public void add(int newNode, float newScore) {\n# Natural Language Annotations: /**\n     * Add a new node to the NodeArray. The new node must be worse than all previously stored\n     * nodes.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class NodeArray {\n    private ArrayList<Node> nodes;\n\n    public NodeArray() {\n        this.nodes = new ArrayList<>();\n    }\n\n    public void add(int newNode, float newScore) {\n        // Check if the list is empty\n        if (nodes.isEmpty()) {\n            nodes.add(new Node(newNode, newScore));\n        } else {\n            // Find the position to insert the new node\n            int pos = binarySearch(0, nodes.size() - 1);\n            // Insert the new node at the correct position\n            nodes.add(pos, new Node(newNode, newScore));\n        }\n    }\n\n    private int binarySearch(int low, int high) {\n        while (low <= high) {\n            int mid = (low + high) / 2;\n            if (nodes.get(mid).getScore() < newScore) {\n                low = mid + 1;\n            } else if (nodes.get(mid).getScore() > newScore) {\n                high = mid - 1;\n            } else {\n                // If the scores are equal, insert at the end\n                return mid + 1;\n            }\n        }\n        return low;\n    }\n\n    private class Node {\n        private int value;\n        private float score;\n\n        public Node(int value, float score) {\n            this.value = value;\n            this.score = score;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        public float getScore() {\n            return score;\n        }\n    }\n}\n```", "```java\nimport java.util.Arrays;\n\npublic class NodeArray {\n    private Node[] nodes;\n\n    public NodeArray() {\n        this.nodes = new Node[0];\n    }\n\n    public void add(int newNode, float newScore) {\n        Node[] temp = Arrays.copyOf(nodes, nodes.length + 1);\n        temp[nodes.length] = new Node(newNode, newScore);\n        nodes = Arrays.copyOf(temp, nodes.length + 1);\n        for (int i = 0; i < nodes.length - 1; i++) {\n            if (nodes[nodes.length - 1].score < nodes[i].score) {\n                Node[] tempArray = new Node[nodes.length];\n                System.arraycopy(nodes, 0, tempArray, 0, i);\n                tempArray[i] = nodes[nodes.length - 1];\n                System.arraycopy(nodes, i, tempArray, i + 1, nodes.length - i - 1);\n                nodes = tempArray;\n                break;\n            }\n        }\n    }\n}\n\nclass Node {\n    int node;\n    float score;\n\n    Node(int node, float score) {\n        this.node = node;\n        this.score = score;\n    }\n}\n```", "```java\n/**\n * Add a new node to the NodeArray. The new node must be worse than all previously stored nodes.\n * \n * @param newNode The new node to be added.\n * @param newScore The score of the new node.\n */\npublic void add(int newNode, float newScore) {\n    for (int i = 0; i < nodeArray.length; i++) {\n        if (newScore > nodeArray[i].getScore()) {\n            // Shift all nodes to the right to make space for the new node\n            System.arraycopy(nodeArray, i, nodeArray, i + 1, nodeArray.length - i - 1);\n            // Insert the new node at the correct position\n            nodeArray[i] = new Node(newNode, newScore);\n            return;\n        }\n    }\n    // If the new node is better than all existing nodes, add it at the end\n    nodeArray[nodeArray.length] = new Node(newNode, newScore);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void addNode(int nodeId, NodeArray nodes) {\n# Natural Language Annotations: /**\n     * Only for internal use and by Builder loading a saved graph\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Only for internal use and by Builder loading a saved graph\n */\npublic void addNode(int nodeId, NodeArray nodes) {\n    if (nodes != null) {\n        nodes.addNode(nodeId);\n    } else {\n        // Handle the case when nodes is null, e.g., log an error or throw an exception\n        System.out.println(\"Error: Node array is null\");\n    }\n}\n```", "```java\n/**\n * Only for internal use and by Builder loading a saved graph\n */\nvoid addNode(int nodeId, NodeArray nodes) {\n    for (Node node : nodes) {\n        if (node.getId() == nodeId) {\n            throw new RuntimeException(\"Node with id \" + nodeId + \" already exists\");\n        }\n    }\n    // Add the new node to the graph\n    // Assuming NodeArray has an add method\n    nodes.add(new Node(nodeId));\n}\n```", "```cpp\n/**\n * Only for internal use and by Builder loading a saved graph\n */\nvoid addNode(int nodeId, NodeArray nodes) {\n    // Check if the node id is valid\n    if (nodeId >= 0 && nodeId < nodes.size()) {\n        // Add the node to the array\n        nodes[nodeId] = new Node();\n    } else {\n        // Handle invalid node id\n        // For example, throw an exception\n        throw std::out_of_range(\"Invalid node id\");\n    }\n}\n```\n\n```java\n/**\n * Only for internal use and by Builder loading a saved graph\n */\npublic void addNode(int nodeId, Node[] nodes) {\n    // Check if the node id is valid\n    if (nodeId >= 0 && nodeId < nodes.length) {\n        // Add the node to the array\n        nodes[nodeId] = new Node();\n    } else {\n        // Handle invalid node id\n        // For example, throw an exception\n        throw new ArrayIndexOutOfBoundsException(\"Invalid node id\");\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized long removeDeletedNodes() {\n# Natural Language Annotations: /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic synchronized long removeDeletedNodes() {\n    long freedMemory = 0;\n    for (Node node : graph.getNodes()) {\n        if (node.isDeleted()) {\n            freedMemory += node.getSize();\n            graph.removeNode(node);\n            for (Node neighbor : node.getNeighbors()) {\n                neighbor.removeEdge(node);\n            }\n        }\n    }\n    return freedMemory;\n}\n```", "```java\npublic synchronized long removeDeletedNodes() {\n    /**\n     * Remove nodes marked for deletion from the graph, and update neighbor lists\n     * to maintain connectivity.  Not threadsafe with respect to other modifications;\n     * the `synchronized` flag only prevents concurrent calls to this method.\n     *\n     * @return approximate size of memory no longer used\n     */\n    // implementation of removing nodes and updating neighbor lists\n    // for the sake of this example, let's assume we have a method to remove a node\n    long memorySaved = 0;\n    for (Node node : getNodesToDelete()) {\n        removeNode(node);\n        memorySaved += node.size();\n    }\n    return memorySaved;\n}\n\n// assuming we have a list of nodes to delete\nprivate List<Node> nodesToDelete = new ArrayList<>();\n\n// assuming we have a method to remove a node from the graph\nprivate void removeNode(Node node) {\n    // implementation of removing a node from the graph and updating neighbor lists\n    // ...\n}\n```", "```java\n/**\n * Remove nodes marked for deletion from the graph, and update neighbor lists\n * to maintain connectivity.  Not threadsafe with respect to other modifications;\n * the `synchronized` flag only prevents concurrent calls to this method.\n *\n * @return approximate size of memory no longer used\n */\npublic synchronized long removeDeletedNodes() {\n    long memoryFree = 0;\n    for (Node node : graph) {\n        if (node.isDeleted()) {\n            memoryFree += node.getSize();\n            graph.remove(node);\n            for (Node neighbor : node.getNeighbors()) {\n                neighbor.removeNeighbor(node);\n            }\n        }\n    }\n    return memoryFree;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException\n# Natural Language Annotations: /**\n     * Write the inline features of the given ordinal to the output at the correct offset.\n     * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Write the inline features of the given ordinal to the output at the correct offset.\n    // Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n    // Implementation of this method is dependent on the specific requirements of the project\n    // and the format of the output, which is not specified in the provided information.\n    // For demonstration purposes, we'll assume a basic implementation using a PrintWriter.\n    PrintWriter writer = new PrintWriter(System.out);\n    // For each feature in the state map\n    for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n        // Write the feature's state to the output at the correct offset\n        writer.write(entry.getKey().toString() + \": \" + entry.getValue().toString() + \"\\n\");\n    }\n    writer.flush();\n}\n```", "```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Write the features of the given ordinal to the output at the correct offset.\n    // Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n    // Here, we assume that the output is written to a file or any other output stream.\n    // We assume that the FeatureId and Feature.State are custom classes with necessary methods and fields.\n    // We also assume that the output stream is open and ready for writing.\n    // For simplicity, we use a PrintWriter to write to the output.\n    try (PrintWriter writer = new PrintWriter(System.out)) {\n        // Write the features of the given ordinal to the output at the correct offset.\n        for (Map.Entry<FeatureId, Feature.State> entry : stateMap.entrySet()) {\n            writer.write(entry.getKey().getId() + \" \" + entry.getValue().getState() + \"\\n\");\n        }\n    }\n}\n```", "```java\n/**\n * Write the inline features of the given ordinal to the output at the correct offset.\n * Nothing else is written (no headers, no edges).  The output IS NOT flushed.\n */\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // TO DO: implement the logic to write the inline features to the output\n    // This is a placeholder and should be replaced with the actual implementation\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n# Natural Language Annotations: /**\n     * @return a Map of old to new graph ordinals where the new ordinals are sequential starting at 0,\n     * while preserving the original relative ordering in `graph`.  That is, for all node ids i and j,\n     * if i &lt; j in `graph` then map[i] &lt; map[j] in the returned map.  \"Holes\" left by\n     * deleted nodes are filled in by shifting down the new ordinals.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Main {\n    public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n        Map<Integer, Integer> oldToNew = new HashMap<>();\n        int newOrdinal = 0;\n\n        for (int node : graph.getNodes()) {\n            if (!graph.removedNodes().contains(node)) {\n                oldToNew.put(node, newOrdinal++);\n            }\n        }\n\n        for (int node : graph.getNodes()) {\n            if (graph.removedNodes().contains(node)) {\n                oldToNew.put(node, oldToNew.getOrDefault(node, Integer.MAX_VALUE));\n                for (int i = graph.removedNodes().indexOf(node); i < graph.removedNodes().size() - 1; i++) {\n                    oldToNew.put(graph.removedNodes().get(i + 1), oldToNew.get(graph.removedNodes().get(i)));\n                }\n                oldToNew.put(graph.removedNodes().get(graph.removedNodes().size() - 1), Integer.MAX_VALUE);\n            }\n        }\n\n        return oldToNew;\n    }\n}\n```", "```java\nimport java.util.*;\n\npublic class Main {\n    public static Map<Integer, Integer> sequentialRenumbering(List<Integer> graph) {\n        // Create a map to store the new ordinals\n        Map<Integer, Integer> newOrdinals = new HashMap<>();\n\n        // Create a set to keep track of used indices\n        Set<Integer> usedIndices = new HashSet<>();\n\n        // Iterate over the graph in order\n        for (int i = 0; i < graph.size(); i++) {\n            // If the current node is not in the used indices, add it to the map and the set\n            if (!usedIndices.contains(i)) {\n                newOrdinals.put(i, graph.indexOf(i));\n                usedIndices.add(i);\n            }\n        }\n\n        // Sort the keys of the newOrdinals map\n        List<Integer> sortedKeys = new ArrayList<>(newOrdinals.keySet());\n        Collections.sort(sortedKeys);\n\n        // Create a map of old to new ordinals\n        Map<Integer, Integer> result = new HashMap<>();\n        for (int i = 0; i < sortedKeys.size(); i++) {\n            result.put(sortedKeys.get(i), i);\n        }\n\n        return result;\n    }\n}\n```", "```java\nimport java.util.*;\n\npublic class Main {\n    public static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n        Set<Integer> nodes = new HashSet<>(graph.getNodes());\n        List<Integer> nodeList = new ArrayList<>(nodes);\n        Collections.sort(nodeList);\n        Map<Integer, Integer> result = new HashMap<>();\n        \n        for (int i = 0; i < nodeList.size(); i++) {\n            result.put(nodeList.get(i), i);\n        }\n        \n        return result;\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void write(GraphIndex graph,\n# Natural Language Annotations: /** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void write(GraphIndex graph) {\n    System.out.println(\"Writing graph to disk...\");\n    // Assuming GraphIndex has a method to write itself to disk\n    graph.writeToDisk();\n    System.out.println(\"Graph written successfully.\");\n}\n```", "```java\npublic static void write(GraphIndex graph) {\n    try (BufferedWriter writer = new BufferedWriter(new FileWriter(\"index.bin\"))) {\n        int numNodes = graph.getNodes().size();\n        int numEdges = graph.getEdges().size();\n        writer.write(String.format(\"%d %d\", numNodes, numEdges));\n\n        for (int node : graph.getNodes()) {\n            writer.write(String.format(\"%d \", node));\n        }\n        writer.write(\"\\n\");\n\n        for (int[] edge : graph.getEdges()) {\n            writer.write(String.format(\"%d %d %d \", edge[0], edge[1], edge[2]));\n        }\n    } catch (IOException e) {\n        System.err.println(\"Error writing index: \" + e.getMessage());\n    }\n}\n```", "```java\npublic static void write(GraphIndex graph) {\n    java.io.FileWriter writer = new java.io.FileWriter(\"index.bin\");\n    try {\n        java.io.DataOutputStream out = new java.io.DataOutputStream(writer);\n        out.writeLong(System.currentTimeMillis());\n        for (int i = 0; i < graph.getVertexCount(); i++) {\n            out.writeLong(graph.getVertex(i).getId());\n            out.writeLong(graph.getVertex(i).getOutgoingEdgeCount());\n            for (int j = 0; j < graph.getVertex(i).getOutgoingEdgeCount(); j++) {\n                out.writeLong(graph.getVertex(i).getOutgoingEdge(j).getDestination());\n                out.writeLong(graph.getVertex(i).getOutgoingEdge(j).getWeight());\n            }\n        }\n        out.close();\n    } catch (Exception e) {\n        System.out.println(\"Error writing graph index: \" + e.getMessage());\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n# Natural Language Annotations: /**\n     * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic class ScoreProvider {\n    public static ScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n        return new ScoreProvider(ravv, similarityFunction);\n    }\n\n    private final RandomAccessVectorValues ravv;\n    private final VectorSimilarityFunction similarityFunction;\n\n    private ScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n        this.ravv = ravv;\n        this.similarityFunction = similarityFunction;\n    }\n\n    public double getScore(int vector1Index, int vector2Index) {\n        return similarityFunction.similarity(ravv.getVector(vector1Index), ravv.getVector(vector2Index));\n    }\n}\n```", "```java\npublic class ScoreProvider {\n    public static ScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n        return new ScoreProvider(ravv, similarityFunction);\n    }\n\n    private final RandomAccessVectorValues ravv;\n    private final VectorSimilarityFunction similarityFunction;\n\n    private ScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n        this.ravv = ravv;\n        this.similarityFunction = similarityFunction;\n    }\n\n    public double getScore(int index1, int index2) {\n        return similarityFunction.getScore(ravv.getRandomAccessVector(index1), ravv.getRandomAccessVector(index2));\n    }\n}\n```", "```java\npublic class ScoreProvider {\n    public static ScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n        return new ScoreProvider(ravv, similarityFunction);\n    }\n\n    private final RandomAccessVectorValues ravv;\n    private final VectorSimilarityFunction similarityFunction;\n\n    private ScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n        this.ravv = ravv;\n        this.similarityFunction = similarityFunction;\n    }\n\n    public Score compare(Score other) {\n        return this.similarityFunction.compare(this.ravv, other.ravv);\n    }\n}\n```"]}, "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static double[] determineStandardDeviationDoubles(\n# Natural Language Annotations: /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.*;\n\npublic class StandardDeviationCalculator {\n\n    /**\n     * Calculates standard deviation of {@link BenchmarkResult#getAverageScore()}s from {@code averageScore}.\n     *\n     * @param averageScore not null\n     * @return standard deviation double values\n     */\n    public static double[] determineStandardDeviationDoubles(double[] averageScore) {\n        if (averageScore == null || averageScore.length == 0) {\n            throw new IllegalArgumentException(\"Input array cannot be null or empty\");\n        }\n\n        double sum = 0;\n        for (double value : averageScore) {\n            sum += value;\n        }\n\n        double mean = sum / averageScore.length;\n\n        double sumOfSquares = 0;\n        for (double value : averageScore) {\n            sumOfSquares += Math.pow(value - mean, 2);\n        }\n\n        double variance = sumOfSquares / (averageScore.length - 1);\n        double standardDeviation = Math.sqrt(variance);\n\n        return new double[]{mean, standardDeviation};\n    }\n}\n```", "```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    if (averageScore == null) {\n        throw new NullPointerException(\"Average score cannot be null\");\n    }\n    double sum = 0;\n    for (double value : averageScore) {\n        sum += value;\n    }\n    double mean = sum / averageScore.length;\n    double sumOfSquares = 0;\n    for (double value : averageScore) {\n        sumOfSquares += Math.pow(value - mean, 2);\n    }\n    double variance = sumOfSquares / (averageScore.length - 1);\n    double standardDeviation = Math.sqrt(variance);\n    return new double[]{standardDeviation};\n}\n```", "```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    if (averageScore == null) {\n        throw new NullPointerException(\"averageScore cannot be null\");\n    }\n\n    double sum = 0;\n    for (double score : averageScore) {\n        sum += score;\n    }\n    double mean = sum / averageScore.length;\n\n    double sqSum = 0;\n    for (double score : averageScore) {\n        sqSum += Math.pow(score - mean, 2);\n    }\n    double variance = sqSum / averageScore.length;\n\n    double standardDeviation = Math.sqrt(variance);\n    return new double[]{standardDeviation};\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata stack(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with {@code types} as the stack;\n     * The original stack is cleared.\n     *\n     * @param types The stack types.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata stack = new StackMetadata();\n    stack.clear();\n    stack.pushAll(types);\n    return stack;\n}\n```", "```java\n/**\n * Return a new StackMetadata with {@code types} as the stack;\n * The original stack is cleared.\n *\n * @param types The stack types.\n */\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata newStack = new StackMetadata();\n    newStack.setTypes(types);\n    return newStack;\n}\n```", "```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata newStack = new StackMetadata();\n    newStack.stack = types;\n    this.stack = new StackMetadata();\n    return newStack;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public StackMetadata locals(ValueSourceInfo... types) {\n# Natural Language Annotations: /**\n     * Return a new StackMetadata with the given local types. Throws {@link IllegalArgumentException} if\n     * types.length != localVariableTypes.size().\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Return a new StackMetadata with the given local types. Throws IllegalArgumentException if\n * types.length != localVariableTypes.size().\n * \n * @param types an array of ValueSourceInfo objects representing the local variable types\n * @return a new StackMetadata object\n */\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"Number of local variable types does not match the number of provided types\");\n    }\n    // create new StackMetadata with the given local types\n    StackMetadata stackMetadata = new StackMetadata();\n    for (ValueSourceInfo type : types) {\n        stackMetadata.addLocalVariableType(type);\n    }\n    return stackMetadata;\n}\n```", "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"Number of types does not match the number of local variables\");\n    }\n    // initialize StackMetadata object\n    StackMetadata metadata = new StackMetadata();\n    for (int i = 0; i < types.length; i++) {\n        metadata.setLocalType(i, types[i]);\n    }\n    return metadata;\n}\n```", "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableTypes.size()) {\n        throw new IllegalArgumentException(\"Number of types does not match local variable types\");\n    }\n    // Rest of the function implementation...\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Loads a method named co_names[namei] from the TOS object. TOS is popped. This bytecode distinguishes two cases:\n     * if TOS has a method with the correct name, the bytecode pushes the unbound method and TOS.\n     * TOS will be used as the first argument (self) by CALL_METHOD when calling the unbound method.\n     * Otherwise, NULL and the object return by the attribute lookup are pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    String methodName = functionMetadata.getCoNames().get(0);\n    Object obj = stackMetadata.pop();\n\n    if (obj.getClass().getMethod(methodName, Object.class) != null) {\n        try {\n            Method method = obj.getClass().getMethod(methodName);\n            stackMetadata.push(method);\n            stackMetadata.push(obj);\n        } catch (NoSuchMethodException e) {\n            stackMetadata.push(null);\n            stackMetadata.push(obj.getClass().getDeclaredField(methodName).get(obj));\n        }\n    } else {\n        stackMetadata.push(null);\n        stackMetadata.push(obj.getClass().getDeclaredField(methodName).get(obj));\n    }\n}\n```", "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    String methodName = functionMetadata.getCoNames().get(0);\n\n    Object method = stackMetadata.getAttribute(methodName);\n\n    if (method != null && method instanceof Method) {\n        stackMetadata.push(method);\n        stackMetadata.push(stackMetadata.pop());\n    } else {\n        stackMetadata.push(null);\n        stackMetadata.push(method);\n    }\n}\n```", "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    String methodName = functionMetadata.getCoNames()[0];\n    Object method = stackMetadata.pop().getMethod(methodName);\n    if (method != null) {\n        stackMetadata.push(method);\n        stackMetadata.push(stackMetadata.pop());\n    } else {\n        stackMetadata.push(null, stackMetadata.pop().getAttribute(methodName));\n    }\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor,\n# Natural Language Annotations: /**\n     * Calls a method. argc is the number of positional arguments. Keyword arguments are not supported.\n     * This opcode is designed to be used with LOAD_METHOD. Positional arguments are on top of the stack.\n     * Below them, the two items described in LOAD_METHOD are on the stack\n     * (either self and an unbound method object or NULL and an arbitrary callable).\n     * All of them are popped and the return value is pushed.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    int argc = stackMetadata.popInt();\n    for (int i = 0; i < argc; i++) {\n        stackMetadata.pop();\n    }\n    if (stackMetadata.popBool()) {\n        stackMetadata.pop();\n    }\n    stackMetadata.pop();\n    methodVisitor.visitCallFunction();\n}\n```", "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    // Pop the number of positional arguments from the stack\n    int argc = stackMetadata.popInt();\n    \n    // Pop the callable and its first argument from the stack\n    Object callable = stackMetadata.pop();\n    Object arg1 = stackMetadata.pop();\n    \n    // Push the result of calling the method\n    Object result = methodVisitor.callMethod(callable, argc, arg1);\n    \n    // Push the result back onto the stack\n    stackMetadata.push(result);\n}\n```", "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    Object self = stackMetadata.pop();\n    Object method = stackMetadata.pop();\n    Object[] args = new Object[functionMetadata.getArgCount()];\n    for (int i = 0; i < functionMetadata.getArgCount(); i++) {\n        args[i] = stackMetadata.pop();\n    }\n    Object result = methodVisitor.visitMethod(method, self, args);\n    stackMetadata.push(result);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunction(FunctionMetadata functionMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS...TOS[argc - 1] are the arguments to the function.\n     * TOS[argc] is the function to call. TOS...TOS[argc] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void callFunction(Object[] stack, int argc) {\n    for (int i = argc - 1; i >= 0; i--) {\n        stack[argc - i] = stack[argc - i - 1];\n    }\n    Object function = stack[argc];\n    Object[] args = new Object[argc - 1];\n    System.arraycopy(stack, 0, args, 0, argc - 1);\n    try {\n        function.getClass().getMethod(\"call\", args.getClass()).invoke(function, args);\n    } catch (Exception e) {\n        System.out.println(\"Error calling function: \" + e.getMessage());\n    }\n}\n```", "```java\npublic static void callFunction(FunctionMetadata functionMetadata, int argc, Object[] stack) {\n    if (argc < 1) {\n        throw new RuntimeException(\"Not enough arguments to call a function\");\n    }\n    Object[] args = new Object[argc - 1];\n    System.arraycopy(stack, 0, args, 0, argc - 1);\n    Object function = stack[argc - 1];\n    Object result = functionMetadata.invoke(function, args);\n    stack[0] = result;\n}\n```", "```java\npublic static void callFunction(FunctionMetadata functionMetadata, int argc) {\n    for (int i = argc - 1; i >= 0; i--) {\n        functionMetadata.stack.pop();\n    }\n    functionMetadata.stack.push(functionMetadata.stack.pop());\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. TOS is a tuple containing keyword names.\n     * TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n     * TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n     * TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n     * the result is pushed onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    Object[] args = new Object[stackMetadata.size() - 2];\n    for (int i = 1; i < stackMetadata.size(); i++) {\n        args[i - 1] = stackMetadata.pop();\n    }\n    Object func = stackMetadata.pop();\n    Object[] positionalArgs = new Object[stackMetadata.size() - 1];\n    for (int i = 0; i < stackMetadata.size(); i++) {\n        positionalArgs[i] = stackMetadata.pop();\n    }\n    Object[] allArgs = new Object[args.length + positionalArgs.length];\n    System.arraycopy(args, 0, allArgs, 0, args.length);\n    System.arraycopy(positionalArgs, 0, allArgs, args.length, positionalArgs.length);\n    Object result = functionMetadata.apply(func, allArgs);\n    stackMetadata.push(result);\n}\n```", "```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    Object[] args = new Object[stackMetadata.size()];\n    for (int i = 1; i <= stackMetadata.size(); i++) {\n        args[i - 1] = stackMetadata.pop();\n    }\n    Object func = stackMetadata.pop();\n    Object[] kwargs = new Object[stackMetadata.size()];\n    for (int i = 1; i <= stackMetadata.size(); i++) {\n        kwargs[i - 1] = stackMetadata.pop();\n    }\n    try {\n        func.getClass().getMethod(\"call\", Object[].class, Object[].class).invoke(func, new Object[]{args, kwargs});\n    } catch (Exception e) {\n        // Handle exception\n    }\n}\n```", "```python\ndef call_function_with_keywords(stack, function_metadata, stack_metadata):\n    \"\"\"\n    Calls a function. TOS is a tuple containing keyword names.\n    TOS[1]...TOS[len(TOS)] are the keyword arguments to the function (TOS[1] is (TOS)[0], TOS[2] is (TOS)[1], ...).\n    TOS[len(TOS) + 1]...TOS[argc + 1] are the positional arguments (rightmost first).\n    TOS[argc + 2] is the function to call. TOS...TOS[argc + 2] are all popped and\n    the result is pushed onto the stack.\n    \"\"\"\n    kwargs = dict(zip(stack_metadata['keywords'], stack[1:-2]))\n    args = stack[-2:-1]\n    func = stack[-1]\n    result = func(*args, **kwargs)\n    stack.append(result)\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n# Natural Language Annotations: /**\n     * Calls a function. If the lowest bit of instruction.arg is set, TOS is a mapping object containing keyword\n     * arguments, TOS[1] is an iterable containing positional arguments and TOS[2] is callable. Otherwise,\n     * TOS is an iterable containing positional arguments and TOS[1] is callable.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    if ((stackMetadata.getInstructionArg() & 1) == 1) {\n        Map<String, Object> kwargs = (Map<String, Object>) stackMetadata.getTos();\n        Object[] args = (Object[]) stackMetadata.getTos(1);\n        Object func = stackMetadata.getTos(2);\n        ((Callable) func).call(args, kwargs);\n    } else {\n        Object[] args = (Object[]) stackMetadata.getTos();\n        Object func = stackMetadata.getTos(1);\n        ((Callable) func).call(args);\n    }\n}\n```", "```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    int instructionArg = stackMetadata.getInstructionArg();\n    if ((instructionArg & 1) == 1) {\n        Map<String, Object> kwargs = (Map<String, Object>) stackMetadata.pop();\n        Object[] positionalArgs = (Object[]) stackMetadata.pop();\n        Object func = stackMetadata.pop();\n        ((Callable) func).call(positionalArgs, kwargs);\n    } else {\n        Object[] positionalArgs = (Object[]) stackMetadata.pop();\n        Object func = stackMetadata.pop();\n        ((Callable) func).call(positionalArgs);\n    }\n}\n```", "```\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata) {\n    if ((stackMetadata.getInstructionArg() & 1) == 1) {\n        Map<String, Object> keywordArgs = (Map<String, Object>) stackMetadata.getTOS();\n        List<Object> positionalArgs = (List<Object>) stackMetadata.getTOS(1);\n        Callable callable = (Callable) stackMetadata.getTOS(2);\n        try {\n            callable.callWithKeywordArgs(positionalArgs, keywordArgs);\n        } catch (Exception e) {\n            // handle exception\n        }\n    } else {\n        List<Object> positionalArgs = (List<Object>) stackMetadata.getTOS();\n        Callable callable = (Callable) stackMetadata.getTOS(1);\n        try {\n            callable.call(positionalArgs);\n        } catch (Exception e) {\n            // handle exception\n        }\n    }\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex,\n# Natural Language Annotations: /**\n     * Loads the global variable or parameter indicated by the {@code instruction} argument onto the stack.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex, long instruction) {\n    // Load the global variable or parameter indicated by the instruction argument onto the stack\n    stackMetadata.push(functionMetadata.getGlobalVariable(globalIndex));\n}\n```", "```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // Get the global variable from the function's metadata\n    GlobalVariable globalVariable = functionMetadata.getGlobalVariable(globalIndex);\n    \n    // Load the global variable onto the stack\n    stackMetadata.push(globalVariable.getValue());\n}\n```", "```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    // Get the global variable from the function metadata\n    Object globalVariable = functionMetadata.getGlobalVariables().get(globalIndex);\n    \n    // Push the global variable onto the stack\n    stackMetadata.push(globalVariable);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n# Natural Language Annotations: /**\n     * Loads the cell variable/free variable indicated by the {@code instruction} argument onto the stack.\n     * (which is an {@link PythonCell}, so it can see changes from the parent function).\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Loads the cell variable/free variable indicated by the instruction argument onto the stack.\n * (which is an PythonCell, so it can see changes from the parent function).\n *\n * @param functionMetadata Function metadata\n * @param stackMetadata Stack metadata\n * @param cellIndex Index of the cell variable to load\n */\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    PythonCell cell = functionMetadata.getCell(cellIndex);\n    stackMetadata.push(cell);\n}\n```", "```java\n/**\n * Loads the cell variable/free variable indicated by the instruction argument onto the stack.\n * (which is an PythonCell, so it can see changes from the parent function).\n */\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    PythonCell cell = functionMetadata.getCellVariable(cellIndex);\n    stackMetadata.push(cell);\n}\n```", "```python\ndef load_cell_variable(instruction, stack, cell_index):\n    \"\"\"\n    Loads the cell variable/free variable indicated by the instruction argument onto the stack.\n    (which is a PythonCell, so it can see changes from the parent function).\n    \"\"\"\n    # Assuming instruction is a PythonCell object\n    cell_value = instruction.cell_contents\n    stack.append(cell_value)\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n# Natural Language Annotations: /**\n     * Replaces TOS with getattr(TOS, co_names[instruction.arg])\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    Object TOS = stackMetadata.pop();\n    int co_namesIndex = instruction.arg;\n    Object[] co_names = functionMetadata.getCoNames();\n    Object attribute = TOS.getClass().getDeclaredField(co_names[co_namesIndex]).get(TOS);\n    stackMetadata.push(attribute);\n}\n```", "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    String attributeName = functionMetadata.getCoNames()[nameIndex];\n    Object attributeValue = stackMetadata.getTOS().getAttribute(attributeName);\n    stackMetadata.setTOS(attributeValue);\n}\n```", "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    String attributeName = functionMetadata.getCoNames()[nameIndex];\n    Object attributeValue = stackMetadata.getStack().pop();\n    stackMetadata.getStack().push(attributeValue.getClass().getDeclaredField(attributeName).get(attributeValue));\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n# Natural Language Annotations: /**\n     * Calculates an indication on how big this problem instance is.\n     * This is approximately the base 10 log of the search space size.\n     *\n     * @param solution never null\n     * @return {@code >= 0}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Calculates an indication on how big this problem instance is.\n * This is approximately the base 10 log of the search space size.\n *\n * @param solution never null\n * @return {@code >= 0}\n */\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    return Math.log10(solution.getSearchSpaceSize());\n}\n```", "```java\n/**\n * Calculates an indication on how big this problem instance is.\n * This is approximately the base 10 log of the search space size.\n *\n * @param solution never null\n * @return {@code >= 0}\n */\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    return Math.log10(solution.getSearchSpaceSize());\n}\n```", "```java\n/**\n * Calculates an indication on how big this problem instance is.\n * This is approximately the base 10 log of the search space size.\n *\n * @param solution never null\n * @return {@code >= 0}\n */\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    return Math.log10(solution.getSearchSpaceSize());\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static void defineClonerFor(ClassCreator classCreator,\n# Natural Language Annotations: /**\n     * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given\n     * ClassCreator\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static void defineClonerFor(ClassCreator classCreator) {\n    // Generate the constructor\n    classCreator.addMethod(\"public SolutionCloner(SolutionDescriptor descriptor) {\n        this.descriptor = descriptor;\n    }\");\n\n    // Generate the clone method\n    classCreator.addMethod(\"public Solution clone() {\n        Solution solution = new Solution();\n        solution.copyFrom(descriptor);\n        return solution;\n    }\");\n\n    // Generate the deep clone method\n    classCreator.addMethod(\"public Solution deepClone() {\n        return clone();\n    }\");\n}\n```", "```java\npublic static void defineClonerFor(ClassCreator classCreator) {\n    // Check if the classCreator is not null\n    if (classCreator == null) {\n        throw new NullPointerException(\"ClassCreator cannot be null\");\n    }\n\n    // Generate the constructor for the SolutionCloner\n    classCreator.addMethod(\"public SolutionCloner()\");\n\n    // Generate the clone method for the SolutionCloner\n    classCreator.addMethod(\"public Solution clone() {\n        // Create a new instance of the solution\n        Solution solution = new Solution();\n\n        // Copy properties from the current solution to the new solution\n        // This is a placeholder, actual implementation depends on the Solution class\n        solution.setField1(getField1());\n        solution.setField2(getField2());\n        // ...\n\n        return solution;\n    }\");\n\n    // Generate the deep clone method for the SolutionCloner\n    classCreator.addMethod(\"public Solution deepClone() {\n        // Create a new instance of the solution\n        Solution solution = new Solution();\n\n        // Deep copy properties from the current solution to the new solution\n        // This is a placeholder, actual implementation depends on the Solution class\n        solution.setField1(deepCopyField1());\n        solution.setField2(deepCopyField2());\n        // ...\n\n        return solution;\n    }\");\n}\n```", "```java\n/**\n * Generates the constructor and implementations of SolutionCloner methods for the given SolutionDescriptor using the given ClassCreator\n */\npublic static void defineClonerFor(ClassCreator classCreator) {\n    // Get the SolutionDescriptor from the ClassCreator\n    SolutionDescriptor solutionDescriptor = classCreator.getSolutionDescriptor();\n    \n    // Create a new class that implements SolutionCloner\n    String clonerClassName = solutionDescriptor.getClassName() + \"Cloner\";\n    String clonerClassCode = \"public class \" + clonerClassName + \" implements SolutionCloner {\\n\";\n    \n    // Add constructor to the cloner class\n    clonerClassCode += \"    public \" + clonerClassName + \"(\" + solutionDescriptor.getClassName() + \" solution) {\\n\";\n    clonerClassCode += \"        this.solution = solution;\\n\";\n    clonerClassCode += \"    }\\n\\n\";\n    \n    // Add implementation of clone method\n    clonerClassCode += \"    @Override\\n\";\n    clonerClassCode += \"    public \" + solutionDescriptor.getClassName() + \" clone() {\\n\";\n    clonerClassCode += \"        // Implementation of clone method goes here\\n\";\n    clonerClassCode += \"        return new \" + solutionDescriptor.getClassName() + \"(solution);\\n\";\n    clonerClassCode += \"    }\\n\";\n    \n    // Add implementation of deepClone method\n    clonerClassCode += \"    @Override\\n\";\n    clonerClassCode += \"    public \" + solutionDescriptor.getClassName() + \" deepClone() {\\n\";\n    clonerClassCode += \"        // Implementation of deepClone method goes here\\n\";\n    clonerClassCode += \"        return new \" + solutionDescriptor.getClassName() + \"(solution.deepClone());\\n\";\n    clonerClassCode += \"    }\\n\";\n    \n    // Print the cloner class code\n    System.out.println(clonerClassCode);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n# Natural Language Annotations: /**\n     * Takes a look at the shadow variables of all entities and compares them against the recorded state. Every difference\n     * is added to the violation message. The first N differences up to the {@code violationDisplayLimit} are displayed\n     * in detail; the number of violations exceeding the display limit is reported at the end. The limit applies per each\n     * shadow variable descriptor.\n     * <p>\n     * This method should be called after a forceful trigger of variable listeners.\n     *\n     * @param violationDisplayLimit maximum number of violations reported per shadow variable descriptor\n     * @return description of the violations or {@code null} if there are none\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder message = new StringBuilder();\n    for (ShadowVariableDescriptor descriptor : shadowVariableDescriptors) {\n        int count = 0;\n        for (ShadowVariableRecord record : descriptor.getRecords()) {\n            if (!record.isSameState(descriptor.getRecord())) {\n                if (count < violationDisplayLimit) {\n                    message.append(\"Shadow variable \").append(descriptor.getName()).append(\" is different from recorded state: \").append(record).append(\"\\n\");\n                } else {\n                    message.append(\"... \").append(descriptor.getName()).append(\" has \").append(descriptor.getRecords().size() - violationDisplayLimit).append(\" more violations\\n\");\n                    break;\n                }\n                count++;\n            }\n        }\n    }\n    return message.length() > 0 ? message.toString() : null;\n}\n```", "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder message = new StringBuilder();\n    List<ShadowVariableDescriptor> descriptors = getShadowVariableDescriptors(); // assuming this method exists\n    for (ShadowVariableDescriptor descriptor : descriptors) {\n        List<Violation> violations = descriptor.getViolations();\n        if (!violations.isEmpty()) {\n            message.append(\"Violations in \").append(descriptor.getName()).append(\": \");\n            for (int i = 0; i < Math.min(violationDisplayLimit, violations.size()); i++) {\n                message.append(violations.get(i).getDescription()).append(\", \");\n            }\n            message.delete(message.length() - 2, message.length());\n            if (violations.size() > violationDisplayLimit) {\n                message.append(\" (\").append(violations.size() - violationDisplayLimit).append(\" more)\");\n            }\n            message.append(\"\\n\");\n        }\n    }\n    return message.toString().trim();\n}\n```", "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    StringBuilder violationsMessage = new StringBuilder();\n    for (ShadowVariableDescriptor descriptor : shadowVariables) {\n        int count = 0;\n        for (ShadowVariableRecord record : descriptor.getRecords()) {\n            if (!record.isCurrentState().equals(record.getRecordedState())) {\n                count++;\n                if (count <= violationDisplayLimit) {\n                    violationsMessage.append(\"Shadow variable \").append(descriptor.getName()).append(\" has a difference at record \").append(record.getRecordNumber()).append(\": \").append(record.isCurrentState()).append(\" vs \").append(record.getRecordedState()).append(\"\\n\");\n                } else {\n                    break;\n                }\n            }\n        }\n        if (count > violationDisplayLimit) {\n            violationsMessage.append(\"Shadow variable \").append(descriptor.getName()).append(\" has \").append(count - violationDisplayLimit).append(\" additional violations exceeding the display limit.\\n\");\n        }\n    }\n    return violationsMessage.length() > 0 ? violationsMessage.toString() : null;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n# Natural Language Annotations: /**\n     * Creates a new member accessor based on the given parameters. Caches the result.\n     *\n     * @param member never null, method or field to access\n     * @param memberAccessorType never null\n     * @param annotationClass the annotation the member was annotated with (used for error reporting)\n     * @param domainAccessType never null\n     * @return never null, new {@link MemberAccessor} instance unless already found in memberAccessorMap\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MemberAccessorFactory {\n\n    private static final Map<Member, MemberAccessor> memberAccessorMap = new HashMap<>();\n\n    public static MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n        String key = member.toString() + memberAccessorType.toString() + annotationClass.getName() + domainAccessType.toString();\n        if (!memberAccessorMap.containsKey(key)) {\n            memberAccessorMap.put(key, new MemberAccessor(member, memberAccessorType, annotationClass, domainAccessType));\n        }\n        return memberAccessorMap.get(key);\n    }\n}\n```", "```java\nprivate static final Map<Member, MemberAccessor> memberAccessorMap = new HashMap<>();\n\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType, Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    if (member == null || memberAccessorType == null || domainAccessType == null) {\n        throw new NullPointerException(\"Input parameters cannot be null\");\n    }\n\n    MemberAccessor cachedAccessor = memberAccessorMap.get(member);\n    if (cachedAccessor != null) {\n        return cachedAccessor;\n    }\n\n    MemberAccessor accessor = new MemberAccessor(member, memberAccessorType, annotationClass, domainAccessType);\n    memberAccessorMap.put(member, accessor);\n    return accessor;\n}\n```", "```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MemberAccessorFactory {\n\n    private static final Map<Member, MemberAccessor> memberAccessorMap = new HashMap<>();\n\n    public static MemberAccessor buildAndCacheMemberAccessor(\n        Member member, \n        MemberAccessorType memberAccessorType, \n        Class<?> annotationClass, \n        DomainAccessType domainAccessType\n    ) {\n        MemberAccessor memberAccessor = new MemberAccessor(member, memberAccessorType, annotationClass, domainAccessType);\n\n        if (!memberAccessorMap.containsKey(member)) {\n            memberAccessorMap.put(member, memberAccessor);\n        }\n\n        return memberAccessorMap.get(member);\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static String getGeneratedClassName(Member member) {\n# Natural Language Annotations: /**\n     * Returns the generated class name for a given member.\n     * (Here as accessing any method of GizmoMemberAccessorImplementor\n     * will try to load Gizmo code)\n     *\n     * @param member The member to get the generated class name for\n     * @return The generated class name for member\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Returns the generated class name for a given member.\n * (Here as accessing any method of GizmoMemberAccessorImplementor\n * will try to load Gizmo code)\n *\n * @param member The member to get the generated class name for\n * @return The generated class name for member\n */\npublic static String getGeneratedClassName(Member member) {\n    return \"Gizmo\" + member.getName();\n}\n```", "```java\n/**\n * Returns the generated class name for a given member.\n * (Here as accessing any method of GizmoMemberAccessorImplementor\n * will try to load Gizmo code)\n *\n * @param member The member to get the generated class name for\n * @return The generated class name for member\n */\npublic static String getGeneratedClassName(Member member) {\n    // Assuming member is an instance of Member class\n    // and it has a method to get the generated class name\n    return member.getGeneratedClassName();\n}\n```", "```java\n/**\n * Returns the generated class name for a given member.\n * (Here as accessing any method of GizmoMemberAccessorImplementor\n * will try to load Gizmo code)\n *\n * @param member The member to get the generated class name for\n * @return The generated class name for member\n */\npublic static String getGeneratedClassName(Member member) {\n    return \"Gizmo_\" + member.getName();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass,\n# Natural Language Annotations: /**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    if (gizmoClassLoader != null) {\n        return new MemberAccessor(member, annotationClass, returnTypeRequired);\n    } else {\n        byte[] bytecode = generateBytecode(member, annotationClass, returnTypeRequired);\n        return new MemberAccessor(member, annotationClass, returnTypeRequired, bytecode);\n    }\n}\n\nprivate byte[] generateBytecode(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired) {\n    // Implementation to generate bytecode goes here\n    // For example:\n    // ...\n    return new byte[0];\n}\n```", "```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    if (gizmoClassLoader == null) {\n        return new MemberAccessor(member, annotationClass, returnTypeRequired);\n    }\n\n    String bytecodeName = \"GizmoBytecode_\" + member.getName() + \"_\" + annotationClass.getName();\n    byte[] bytecode = generateGizmoBytecode(member, annotationClass, returnTypeRequired);\n\n    try {\n        Class<?> bytecodeClass = gizmoClassLoader.loadClass(bytecodeName);\n        return (MemberAccessor) bytecodeClass.getConstructor(Member.class, Class.class, boolean.class).newInstance(member, annotationClass, returnTypeRequired);\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to load Gizmo bytecode for \" + member + \" annotated with \" + annotationClass, e);\n    }\n}\n\nprivate byte[] generateGizmoBytecode(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired) {\n    // implement bytecode generation logic here\n    // this may involve using a bytecode manipulation library such as ASM or Javassist\n    // for the sake of simplicity, this method is left unimplemented\n    return new byte[0];\n}\n```", "```java\npublic static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, ClassLoader gizmoClassLoader) {\n    if (gizmoClassLoader == null) {\n        return new MemberAccessor(member, annotationClass, returnTypeRequired);\n    } else {\n        return new MemberAccessor(member, annotationClass, returnTypeRequired, gizmoClassLoader);\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: void set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n# Natural Language Annotations: /**\n     * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n     * best solution.\n     *\n     * @param bestSolution the new best solution that replaces the previous one if there is any\n     * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n * best solution.\n *\n * @param bestSolution the new best solution that replaces the previous one if there is any\n * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n */\nvoid set(Solution bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        // Assuming Solution class has a setter method for the best solution\n        this.bestSolution = bestSolution;\n    }\n}\n```", "```java\n/**\n * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n * best solution.\n *\n * @param bestSolution the new best solution that replaces the previous one if there is any\n * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n */\nvoid set(Solution bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        this.bestSolution = bestSolution;\n    }\n}\n```", "```java\n/**\n * Sets the new best solution if all known problem changes have been processed and thus are contained in this\n * best solution.\n *\n * @param bestSolution the new best solution that replaces the previous one if there is any\n * @param isEveryProblemChangeProcessed a supplier that tells if all problem changes have been processed\n */\nvoid set(Solution bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    if (isEveryProblemChangeProcessed.getAsBoolean()) {\n        // set the new best solution\n        this.bestSolution = bestSolution;\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n# Natural Language Annotations: /**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n * a relevant best solution by the {@link #take()} method.\n *\n * @param solver the solver instance\n * @param problemChange the problem change to be added\n * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n *         a user-defined Consumer\n */\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    return CompletableFuture.runAsync(() -> {\n        // Add the problem change to the solver\n        solver.addProblemChange(problemChange);\n        \n        // Wait for the solver to find a new best solution\n        Solution_ bestSolution = solver.getBestSolution();\n        \n        // Notify the user\n        // Assuming a Consumer interface is defined elsewhere\n        Consumer<Solution_> consumer = solver.getConsumer();\n        consumer.accept(bestSolution);\n    });\n}\n```", "```java\n/**\n * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n * a relevant best solution by the {@link #take()} method.\n *\n * @param solver the solver that will be used to find a solution for the problem change\n * @param problemChange the problem change to be added to the solver\n * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n *         a user-defined Consumer\n */\nCompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    return CompletableFuture.runAsync(() -> {\n        solver.addProblemChange(problemChange);\n    });\n}\n```", "```java\n/**\n * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n * a relevant best solution by the {@link #take()} method.\n *\n * @param <S> the type of the solution\n * @param <C> the type of the problem change\n * @param solver the solver to add the problem change to\n * @param problemChange the problem change to add\n * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n *         a user-defined Consumer\n */\npublic CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    return CompletableFuture.runAsync(() -> {\n        solver.addProblemChange(problemChange);\n    });\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static long nextLong(Random random, long n) {\n# Natural Language Annotations: /**\n     * Mimics {@link Random#nextInt(int)} for longs.\n     *\n     * @param random never null\n     * @param n {@code > 0L}\n     * @return like {@link Random#nextInt(int)} but for a long\n     * @see Random#nextInt(int)\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Mimics {@link Random#nextInt(int)} for longs.\n *\n * @param random never null\n * @param n {@code > 0L}\n * @return like {@link Random#nextInt(int)} but for a long\n * @see Random#nextInt(int)\n */\npublic static long nextLong(Random random, long n) {\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be greater than 0\");\n    }\n    long bits = (long) (random.nextLong() & ((1L << 32) - 1));\n    return (bits % n);\n}\n```", "```java\n/**\n * Mimics {@link Random#nextInt(int)} for longs.\n *\n * @param random never null\n * @param n {@code > 0L}\n * @return like {@link Random#nextInt(int)} but for a long\n * @see Random#nextInt(int)\n */\npublic static long nextLong(Random random, long n) {\n    if (n <= 0) {\n        throw new IllegalArgumentException(\"n must be greater than 0\");\n    }\n    long bits = (long) (random.nextLong() >>> 32);\n    return ((bits % n) + n) % n;\n}\n```", "```java\n/**\n * Mimics {@link Random#nextInt(int)} for longs.\n *\n * @param random never null\n * @param n {@code > 0L}\n * @return like {@link Random#nextInt(int)} but for a long\n * @see Random#nextInt(int)\n */\npublic static long nextLong(Random random, long n) {\n    return (random.nextLong() % n);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new NullPointerException(\"solverScope cannot be null\");\n    }\n    \n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<?> termination : solverScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new NullPointerException(\"solverScope cannot be null\");\n    }\n\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination termination : solverScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new NullPointerException(\"solverScope cannot be null\");\n    }\n\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<Solution_> termination : solverScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? 0.0 : minTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the minimum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the minimum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.POSITIVE_INFINITY;\n    for (Termination<Solution_> termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.POSITIVE_INFINITY ? 0.0 : minTimeGradient;\n}\n```", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    OptionalDouble> timeGradients = phaseScope.getTerminations().stream()\n            .map(Termination::getTimeGradient)\n            .filter(gradient -> gradient != -1.0)\n            .min(Double::compare);\n\n    return timeGradients.orElse(Double.POSITIVE_INFINITY);\n}\n```", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    if (phaseScope == null) {\n        throw new NullPointerException(\"phaseScope is null\");\n    }\n\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<Solution_> termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n\n    if (minTimeGradient == Double.MAX_VALUE) {\n        return Double.NaN; // or throw an exception, depending on the requirements\n    }\n\n    return minTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param solverScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new NullPointerException(\"solverScope cannot be null\");\n    }\n    \n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination termination : solverScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    \n    return maxTimeGradient == Double.NEGATIVE_INFINITY ? 0.0 : maxTimeGradient;\n}\n```", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    if (solverScope == null) {\n        throw new NullPointerException(\"solverScope cannot be null\");\n    }\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination termination : solverScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient == Double.NEGATIVE_INFINITY ? Double.NaN : maxTimeGradient;\n}\n```", "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination<Solution_> termination : solverScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient == Double.NEGATIVE_INFINITY ? 0 : maxTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Override    public double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n# Natural Language Annotations: /**\n     * Calculates the maximum timeGradient of all Terminations.\n     * Not supported timeGradients (-1.0) are ignored.\n     *\n     * @param phaseScope never null\n     * @return the maximum timeGradient of the Terminations.\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    if (phaseScope == null) {\n        throw new NullPointerException(\"phaseScope cannot be null\");\n    }\n\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination<?> termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient == Double.NEGATIVE_INFINITY ? 0.0 : maxTimeGradient;\n}\n```", "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = Double.NEGATIVE_INFINITY;\n    for (Termination<Solution_> termination : phaseScope.getTerminations()) {\n        double timeGradient = termination.getTimeGradient();\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient == Double.NEGATIVE_INFINITY ? 0.0 : maxTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n# Natural Language Annotations: /**\n     * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n     * <br />\n     * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n     * unique elements (p_1, p_2, ..., p_k) where\n     * <ul>\n     * <li>p_1 maps to p_2 in the permutation</li>\n     * <li>p_2 maps to p_3 in the permutation</li>\n     * <li>p_(k-1) maps to p_k in the permutation</li>\n     * <li>p_k maps to p_1 in the permutation</li>\n     * <li>In general: p_i maps to p_(i+1) in the permutation</li>\n     * </ul>\n     * For instance, the permutation\n     * <ul>\n     * <li>1 -> 2</li>\n     * <li>2 -> 3</li>\n     * <li>3 -> 1</li>\n     * <li>4 -> 5</li>\n     * <li>5 -> 4</li>\n     * </ul>\n     * can be expressed as `(1, 2, 3)(4, 5)`.\n     *\n     * @return The {@link KOptCycle} corresponding to the permutation described by\n     *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n     * @param kOptDescriptor The descriptor to calculate cycles for\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Calculate the disjoint k-cycles for {@link KOptDescriptor#removedEdgeIndexToTourOrder()}. <br />\n * <br />\n * Any permutation can be expressed as combination of k-cycles. A k-cycle is a sequence of\n * unique elements (p_1, p_2, ..., p_k) where\n * <ul>\n * <li>p_1 maps to p_2 in the permutation</li>\n * <li>p_2 maps to p_3 in the permutation</li>\n * <li>p_(k-1) maps to p_k in the permutation</li>\n * <li>p_k maps to p_1 in the permutation</li>\n * <li>In general: p_i maps to p_(i+1) in the permutation</li>\n * </ul>\n * For instance, the permutation\n * <ul>\n * <li>1 -> 2</li>\n * <li>2 -> 3</li>\n * <li>3 -> 1</li>\n * <li>4 -> 5</li>\n * <li>5 -> 4</li>\n * </ul>\n * can be expressed as `(1, 2, 3)(4, 5)`.\n *\n * @return The {@link KOptCycle} corresponding to the permutation described by\n *         {@link KOptDescriptor#removedEdgeIndexToTourOrder()}.\n * @param kOptDescriptor The descriptor to calculate cycles for\n */\npublic static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    int[] tourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    int n = tourOrder.length;\n    boolean[] visited = new boolean[n];\n    List<KOptCycle> cycles = new ArrayList<>();\n\n    for (int i = 0; i < n; i++) {\n        if (!visited[i]) {\n            List<Integer> cycle = new ArrayList<>();\n            int j = i;\n            while (!visited[j]) {\n                visited[j] = true;\n                cycle.add(j);\n                j = tourOrder[j];\n            }\n            cycles.add(new KOptCycle(cycle));\n        }\n    }\n\n    return new KOptCycle(cycles);\n}\n```", "```java\nimport java.util.*;\n\npublic class KOptCycleCalculator {\n\n    public static List<List<Integer>> getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n        List<Integer> tourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n        Set<Integer> visited = new HashSet<>();\n        List<List<Integer>> cycles = new ArrayList<>();\n\n        for (int i = 0; i < tourOrder.size(); i++) {\n            if (!visited.contains(i)) {\n                List<Integer> cycle = new ArrayList<>();\n                int j = i;\n                while (!visited.contains(j)) {\n                    visited.add(j);\n                    cycle.add(j);\n                    j = tourOrder.get(j);\n                }\n                cycles.add(cycle);\n            }\n        }\n\n        return cycles;\n    }\n}\n```", "```java\nimport java.util.*;\n\npublic class KOptCycleCalculator {\n    public static KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n        List<Integer> tourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n        Set<Integer> visited = new HashSet<>();\n        List<List<Integer>> cycles = new ArrayList<>();\n\n        for (int i = 0; i < tourOrder.size(); i++) {\n            if (!visited.contains(i)) {\n                List<Integer> cycle = new ArrayList<>();\n                int j = i;\n                while (!visited.contains(j)) {\n                    visited.add(j);\n                    cycle.add(j);\n                    j = tourOrder.get(j);\n                }\n                cycles.add(cycle);\n            }\n        }\n\n        List<KOptCycle> kOptCycles = new ArrayList<>();\n        for (List<Integer> cycle : cycles) {\n            int[] indices = new int[cycle.size()];\n            for (int i = 0; i < cycle.size(); i++) {\n                indices[i] = cycle.get(i);\n            }\n            kOptCycles.add(new KOptCycle(indices));\n        }\n\n        return new KOptCycle(kOptCycles);\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n# Natural Language Annotations: /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\nimport java.util.Random;\n\npublic class Main {\n    public static final int MIN_SUB_LIST_SIZE = 1;\n    public static final int MAX_SUB_LIST_SIZE = 100;\n\n    public static int nextElement(int listSize) throws IllegalArgumentException {\n        if (listSize < MIN_SUB_LIST_SIZE) {\n            throw new IllegalArgumentException(\"listSize should be greater than or equal to \" + MIN_SUB_LIST_SIZE);\n        }\n\n        int maxElement = (listSize * (listSize + 1)) / 2;\n        Random random = new Random();\n        return random.nextInt(maxElement);\n    }\n}\n```", "```java\n/**\n * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n *\n * @param listSize determines the Triangle to select an element from\n * @return next random triangle element\n * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n */\npublic int nextElement(int listSize) throws IllegalArgumentException {\n    // Assuming minimum sublist size is 1 and maximum sublist size is listSize\n    if (listSize < 1) {\n        throw new IllegalArgumentException(\"listSize must be greater than or equal to 1\");\n    }\n\n    int minimumSubListSize = 1;\n    int maximumSubListSize = listSize;\n\n    int totalElements = (listSize * (listSize + 1)) / 2;\n    int randomNumber = (int) (Math.random() * totalElements);\n\n    int currentNumber = 0;\n    int currentSublistSize = 1;\n    while (currentNumber < randomNumber) {\n        currentNumber += currentSublistSize;\n        currentSublistSize++;\n    }\n\n    return currentNumber;\n}\n```", "```java\nimport java.util.Random;\n\npublic class Main {\n    private static final int MIN_SUB_LIST_SIZE = 1;\n\n    public static int nextElement(int listSize) throws IllegalArgumentException {\n        if (listSize < MIN_SUB_LIST_SIZE) {\n            throw new IllegalArgumentException(\"listSize must be greater than or equal to \" + MIN_SUB_LIST_SIZE);\n        }\n\n        int[] triangle = new int[listSize * (listSize + 1) / 2];\n        int index = 0;\n        for (int i = 1; i <= listSize; i++) {\n            for (int j = 1; j <= i; j++) {\n                triangle[index++] = (i + j) * (i + j + 1) / 2 + j;\n            }\n        }\n\n        Random random = new Random();\n        return triangle[random.nextInt(triangle.length)];\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true)    public List<Object> getJustificationList() {\n# Natural Language Annotations: /**\n     * Return a list of justifications for the constraint.\n     * <p>\n     * This method has a different meaning based on which score director the constraint comes from.\n     * <ul>\n     * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n     * (eg. [A, B] for a bi stream),\n     * unless a custom justification mapping was provided, in which case it throws an exception,\n     * pointing users towards {@link #getJustification()}.</li>\n     * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n     * </ul>\n     *\n     * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * Return a list of justifications for the constraint.\n * <p>\n * This method has a different meaning based on which score director the constraint comes from.\n * <ul>\n * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n * (eg. [A, B] for a bi stream),\n * unless a custom justification mapping was provided, in which case it throws an exception,\n * pointing users towards {@link #getJustification()}.</li>\n * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n * </ul>\n *\n * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n * @return never null\n */\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    // TO DO: implement the logic for constraint streams and incremental score calculation\n    // For now, just return an empty list\n    return Collections.emptyList();\n}\n```", "```java\n/**\n * Return a list of justifications for the constraint.\n * <p>\n * This method has a different meaning based on which score director the constraint comes from.\n * <ul>\n * <li>For constraint streams, it returns a list of facts from the matching tuple for backwards compatibility\n * (eg. [A, B] for a bi stream),\n * unless a custom justification mapping was provided, in which case it throws an exception,\n * pointing users towards {@link #getJustification()}.</li>\n * <li>For incremental score calculation, it returns what the calculator is implemented to return.</li>\n * </ul>\n *\n * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n * @return never null\n */\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    // Implementation of the method\n    // For constraint streams, return a list of facts from the matching tuple\n    // For incremental score calculation, return what the calculator is implemented to return\n    // This is a placeholder, actual implementation may vary based on the specific use case\n    return new ArrayList<>();\n}\n```", "```java\n/**\n * @deprecated Prefer {@link #getJustification()} or {@link #getIndictedObjectList()}.\n * @return never null\n */\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    // For constraint streams, return a list of facts from the matching tuple for backwards compatibility\n    // unless a custom justification mapping was provided, in which case it throws an exception,\n    // pointing users towards {@link #getJustification()}.\n    // For incremental score calculation, it returns what the calculator is implemented to return.\n    return getIndictedObjectList();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>            UniConstraintCollector<A, ?, Result_> compose(\n# Natural Language Annotations: /**\n     * Returns a constraint collector the result of which is a composition of other constraint collectors.\n     * The return value of this collector, incl. the default return value, depends solely on the compose function.\n     *\n     * @param subCollector1 never null, first collector to compose\n     * @param subCollector2 never null, second collector to compose\n     * @param composeFunction never null, turns results of the sub collectors to a result of the parent collector\n     * @param <A> generic type of the tuple variable\n     * @param <Result_> generic type of the parent collector's return value\n     * @param <SubResultContainer1_> generic type of the first sub collector's result container\n     * @param <SubResultContainer2_> generic type of the second sub collector's result container\n     * @param <SubResult1_> generic type of the first sub collector's return value\n     * @param <SubResult2_> generic type of the second sub collector's return value\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_> UniConstraintCollector<A, ?, Result_> compose(\n        UniConstraintCollector<A, ?, SubResultContainer1_> subCollector1,\n        UniConstraintCollector<A, ?, SubResultContainer2_> subCollector2,\n        Function<SubResultContainer1_, Function<SubResultContainer2_, Result_>> composeFunction) {\n    return new UniConstraintCollector<A, ?, Result_>() {\n        @Override\n        public UniConstraintCollector<A, ?, Result_> apply(A a) {\n            return new UniConstraintCollector<A, ?, Result_>() {\n                @Override\n                public UniConstraintCollector<A, ?, Result_> apply(A a) {\n                    return new UniConstraintCollector<A, ?, Result_>() {\n                        @Override\n                        public UniConstraintCollector<A, ?, Result_> apply(A a) {\n                            SubResultContainer1_ subResult1 = subCollector1.apply(a).get();\n                            SubResultContainer2_ subResult2 = subCollector2.apply(a).get();\n                            return UniConstraintCollector.of(() -> composeFunction.apply(subResult1).apply(subResult2));\n                        }\n                    };\n                }\n            };\n        }\n    };\n}\n```", "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_> \nUniConstraintCollector<A, ?, Result_> compose(\n        UniConstraintCollector<A, ?, SubResultContainer1_> subCollector1, \n        UniConstraintCollector<A, ?, SubResultContainer2_> subCollector2, \n        Function<SubResultContainer1_, SubResultContainer2_, Result_> composeFunction) {\n    return (uniConstraint, collector) -> {\n        UniConstraintCollector<A, ?, SubResultContainer1_> collector1 = subCollector1.apply(uniConstraint, collector);\n        UniConstraintCollector<A, ?, SubResultContainer2_> collector2 = subCollector2.apply(uniConstraint, collector);\n        return collector1.compose(collector2, composeFunction);\n    };\n}\n```", "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_> \nUniConstraintCollector<A, ?, Result_> compose(\n        UniConstraintCollector<A, ?, SubResultContainer1_> subCollector1, \n        UniConstraintCollector<A, ?, SubResultContainer2_> subCollector2, \n        Function<SubResultContainer1_, Function<SubResultContainer2_, Result_>> composeFunction) {\n    return (collector, a) -> {\n        UniConstraintCollector<A, ?, SubResultContainer1_> collector1 = subCollector1.collector(collector);\n        UniConstraintCollector<A, ?, SubResultContainer2_> collector2 = subCollector2.collector(collector);\n        return collector1.collect(a).thenApply(subResult1 -> collector2.collect(a).thenApply(subResult2 -> composeFunction.apply(subResult1).apply(subResult2)));\n    };\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>            toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n# Natural Language Annotations: /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n     *                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n     *                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>> \nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>> \ntoConnectedRanges(\n    Function<A, PointType_> startInclusiveMap, \n    Function<A, PointType_> endExclusiveMap, \n    Function<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    \n    return new UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>() {\n        @Override\n        public ConnectedRangeChain<A, PointType_, DifferenceType_> collect(FactCollector collector) {\n            List<Range<A>> ranges = new ArrayList<>();\n            List<Range<A>> currentRange = new ArrayList<>();\n            Range<A> lastRange = null;\n            \n            for (A fact : collector) {\n                PointType_ start = startInclusiveMap.apply(fact);\n                PointType_ end = endExclusiveMap.apply(fact);\n                \n                if (lastRange != null && endExclusiveMap.apply(lastRange.getFact()).compareTo(start) <= 0) {\n                    currentRange.add(new Range<>(lastRange));\n                    lastRange = null;\n                }\n                if (lastRange == null || start.compareTo(lastRange.getToExclusive()) > 0) {\n                    lastRange = new Range<>(fact, start, end);\n                    currentRange.add(lastRange);\n                } else {\n                    lastRange.setToExclusive(end);\n                }\n            }\n            \n            if (lastRange != null) {\n                currentRange.add(lastRange);\n            }\n            \n            List<Range<A>> mergedRanges = new ArrayList<>();\n            for (Range<A> range : currentRange) {\n                if (mergedRanges.isEmpty() || range.getFromInclusive().compareTo(mergedRanges.get(mergedRanges.size() - 1).getToExclusive()) > 0) {\n                    mergedRanges.add(range);\n                } else {\n                    Range<A> last = mergedRanges.remove(mergedRanges.size() - 1);\n                    last.setToExclusive(Math.max(last.getToExclusive(), range.getToExclusive()));\n                    mergedRanges.add(last);\n                }\n            }\n            \n            List<Range<A>> connectedRanges = new ArrayList<>();\n            for (Range<A> range : mergedRanges) {\n                if (connectedRanges.isEmpty() || range.getFromInclusive().compareTo(connectedRanges.get(connectedRanges.size() - 1).getToExclusive()) > 0) {\n                    connectedRanges.add(range);\n                } else {\n                    Range<A> last = connectedRanges.remove(connectedRanges.size() - 1);\n                    DifferenceType_ overlap = differenceFunction.apply(last.getToExclusive(), range.getFromInclusive());\n                    DifferenceType_ newEnd = differenceFunction.apply(last.getFromInclusive(), range.getToExclusive());\n                    last.setFromInclusive(last.getFromInclusive());\n                    last.setToExclusive(newEnd);\n                    connectedRanges.add(last);\n                    connectedRanges.add(range);\n                }\n            }\n            \n            List<Break<A>> breaks = new ArrayList<>();\n            for (int i = 0; i < connectedRanges.size() - 1; i++) {\n                Range<A> range = connectedRanges.get(i);\n                Range<A> nextRange = connectedRanges.get(i + 1);\n                DifferenceType_ difference = differenceFunction.apply(range.getToExclusive(), nextRange.getFromInclusive());\n                if (difference > 0) {\n                    breaks.add(new Break<>(range.getToExclusive(), nextRange.getFromInclusive(), difference));\n                }\n            }\n            \n            return new ConnectedRangeChain<>(connectedRanges, breaks);\n        }\n    };\n}\n```", "```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>> \nUniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>> \ntoConnectedRanges(\n    Function<A, PointType_> startInclusiveMap, \n    Function<A, PointType_> endExclusiveMap, \n    Function<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    \n    return collector -> {\n        Map<A, PointType_> startMap = collector.accumulateInto(new HashMap<>(), startInclusiveMap);\n        Map<A, PointType_> endMap = collector.accumulateInto(new HashMap<>(), endExclusiveMap);\n        \n        List<ConnectedRange<A, PointType_, DifferenceType_>> connectedRanges = new ArrayList<>();\n        \n        for (Map.Entry<A, PointType_> start : startMap.entrySet()) {\n            PointType_ startPoint = start.getValue();\n            for (Map.Entry<A, PointType_> end : endMap.entrySet()) {\n                PointType_ endPoint = end.getValue();\n                DifferenceType_ difference = differenceFunction.apply(endPoint, startPoint);\n                if (difference > 0) {\n                    connectedRanges.add(new ConnectedRange<>(start.getKey(), endPoint, difference));\n                }\n            }\n        }\n        \n        List<Break<A, PointType_, DifferenceType_>> breaks = new ArrayList<>();\n        for (int i = 1; i < connectedRanges.size(); i++) {\n            ConnectedRange<A, PointType_, DifferenceType_> current = connectedRanges.get(i);\n            ConnectedRange<A, PointType_, DifferenceType_> previous = connectedRanges.get(i - 1);\n            if (current.getTo().equals(previous.getFrom())) {\n                breaks.add(new Break<>(current.getFrom(), current.getTo(), current.getDifference()));\n            }\n        }\n        \n        return new ConnectedRanges<>(connectedRanges, breaks);\n    };\n}\n```", "```\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>> \n    UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>> \n    toConnectedRanges(\n        Function<A, PointType_> startInclusiveMap, \n        Function<A, PointType_> endExclusiveMap, \n        Function<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return new UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>() {\n        @Override\n        public void collect(A fact, UniConstraintCollector.Context context) {\n            PointType_ start = startInclusiveMap.apply(fact);\n            PointType_ end = endExclusiveMap.apply(fact);\n            SortedSet<ConnectedRange<A, PointType_, DifferenceType_>> ranges = new TreeSet<>(\n                Comparator.comparing(ConnectedRange::getFrom).thenComparing(ConnectedRange::getTo));\n            \n            for (ConnectedRange<A, PointType_, DifferenceType_> range : context.getRanges()) {\n                if (range.getTo().compareTo(start) < 0 || range.getFrom().compareTo(end) > 0) {\n                    continue;\n                }\n                if (range.getFrom().compareTo(start) <= 0 && end.compareTo(range.getTo()) >= 0) {\n                    int overlap = differenceFunction.apply(start, end) - differenceFunction.apply(range.getFrom(), range.getTo());\n                    if (overlap > 0) {\n                        range.setFrom(Math.max(start, range.getFrom()));\n                        range.setTo(Math.min(end, range.getTo()));\n                    }\n                }\n                ranges.add(range);\n            }\n            context.setRanges(ranges);\n        }\n    };\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n# Natural Language Annotations: /**\n     * Compare this {@link ScoreAnalysis} to another {@link ScoreAnalysis}\n     * and retrieve the difference between them.\n     * The comparison is in the direction of {@code this - other}.\n     * <p>\n     * Example: if {@code this} has a score of 100 and {@code other} has a score of 90,\n     * the returned {@link ScoreAnalysis#score} will be 10.\n     * If this and other were inverted, the score would have been -10.\n     * The same applies to all other properties of {@link ScoreAnalysis}.\n     *\n     * <p>\n     * In order to properly diff {@link MatchAnalysis} against each other,\n     * we rely on the user implementing {@link ConstraintJustification} equality correctly.\n     * In other words, the diff will consider two justifications equal if the user says they are equal,\n     * and it expects the hash code to be consistent with equals.\n     *\n     * <p>\n     * If one {@link ScoreAnalysis} provides {@link MatchAnalysis} and the other doesn't, exception is thrown.\n     * Such {@link ScoreAnalysis} instances are mutually incompatible.\n     *\n     * @param other never null\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (this.matchAnalysis == null && other.matchAnalysis != null) {\n        throw new IllegalArgumentException(\"Cannot compare ScoreAnalysis with matchAnalysis: \" + this + \" and \" + other);\n    }\n    if (this.matchAnalysis != null && other.matchAnalysis == null) {\n        throw new IllegalArgumentException(\"Cannot compare ScoreAnalysis with matchAnalysis: \" + this + \" and \" + other);\n    }\n    if (this.matchAnalysis != null && other.matchAnalysis != null) {\n        if (!this.matchAnalysis.equals(other.matchAnalysis)) {\n            throw new IllegalArgumentException(\"Cannot compare ScoreAnalysis with different matchAnalysis: \" + this + \" and \" + other);\n        }\n    }\n    return new ScoreAnalysis<Score_>() {\n        @Override\n        public Score_ score() {\n            return Score_.of(this.score().value() - other.score().value());\n        }\n\n        @Override\n        public MatchAnalysis matchAnalysis() {\n            return this.matchAnalysis;\n        }\n\n        @Override\n        public String toString() {\n            return \"ScoreAnalysis [score=\" + score() + \", matchAnalysis=\" + matchAnalysis + \"]\";\n        }\n    };\n}\n```", "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (this.match == null && other.match != null) {\n        throw new IllegalStateException(\"One ScoreAnalysis provides MatchAnalysis and the other doesn't\");\n    }\n    if (this.match != null && other.match != null && !match.equals(other.match)) {\n        throw new IllegalStateException(\"ScoreAnalysis instances are mutually incompatible\");\n    }\n    return new ScoreAnalysis<>(\n            this.score - other.score,\n            this.precision - other.precision,\n            this.recall - other.recall,\n            this.f1 - other.f1,\n            this.match.equals(other.match) ? this.match : new ConstraintJustification());\n}\n```", "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    if (this.matchAnalysis == null && other.matchAnalysis != null) {\n        throw new IllegalArgumentException(\"Incompatible ScoreAnalysis instances\");\n    }\n    if (this.matchAnalysis != null && other.matchAnalysis == null) {\n        throw new IllegalArgumentException(\"Incompatible ScoreAnalysis instances\");\n    }\n\n    ScoreAnalysis<Score_> diff = new ScoreAnalysis<>();\n\n    if (this.score != other.score) {\n        diff.score = this.score - other.score;\n    }\n\n    if (this.constraintJustification != other.constraintJustification) {\n        if (!this.constraintJustification.equals(other.constraintJustification)) {\n            throw new IllegalArgumentException(\"Constraint justifications must be equal for diff to work\");\n        }\n    }\n\n    diff.constraintJustification = this.constraintJustification;\n\n    if (this.matchAnalysis != null && other.matchAnalysis != null) {\n        diff.matchAnalysis = this.matchAnalysis.diff(other.matchAnalysis);\n    }\n\n    return diff;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains the solution through the {@link ConstraintAnalysis} API to identify which\n     * constraints cause that score quality.\n     * The string is built fresh every time the method is called.\n     * <p>\n     * In case of an {@link Score#isFeasible() infeasible} solution, this can help diagnose the cause of that.\n     *\n     * <p>\n     * Do not parse the return value, its format may change without warning.\n     * Instead, provide this information in a UI or a service,\n     * use {@link ScoreAnalysis#constraintAnalyses()}\n     * and convert those into a domain-specific API.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    // Check if the solution is feasible\n    if (!Score.isFeasible()) {\n        // If infeasible, add a message to the string builder\n        sb.append(\"The solution is infeasible. \");\n        // Add a message to the string builder explaining why the solution is infeasible\n        // (this should be replaced with actual constraint analysis)\n        sb.append(\"Please use ScoreAnalysis.constraintAnalyses() to diagnose the cause.\");\n    } else {\n        // If the solution is feasible, add a message to the string builder\n        sb.append(\"The solution is feasible.\");\n    }\n    // Return the string builder as a string\n    return sb.toString();\n}\n```", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"The solution is \").append(Score.isFeasible() ? \"feasible\" : \"infeasible\").append(\".\\n\");\n    if (!Score.isFeasible()) {\n        for (ConstraintAnalysis analysis : ScoreAnalysis.constraintAnalyses()) {\n            sb.append(\"  - \").append(analysis.getConstraint().getName()).append(\": \").append(analysis.getMessage()).append(\"\\n\");\n        }\n    }\n    return sb.toString();\n}\n```", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder diagnostics = new StringBuilder();\n    if (score.isFeasible()) {\n        diagnostics.append(\"The solution is feasible.\");\n    } else {\n        diagnostics.append(\"The solution is infeasible due to the following constraints: \");\n        for (ConstraintAnalysis analysis : constraintAnalyses()) {\n            diagnostics.append(analysis.getDiagnosticText()).append(\", \");\n        }\n        diagnostics.delete(diagnostics.length() - 2, diagnostics.length()); // remove trailing comma and space\n    }\n    return diagnostics.toString();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @SuppressWarnings(\"java:S3457\")    public String summarize() {\n# Natural Language Annotations: /**\n     * Returns a diagnostic text that explains part of the score quality through the {@link ConstraintAnalysis} API.\n     * The string is built fresh every time the method is called.\n     *\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"Constraint analysis is used to evaluate the quality of the score. It provides a detailed report on the constraint satisfaction level, highlighting areas of improvement and potential issues.\";\n}\n```", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"This diagnostic text explains part of the score quality through the ConstraintAnalysis API.\";\n}\n```", "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    return \"The score quality is determined by the ConstraintAnalysis API, which provides diagnostic text to help improve the model's performance.\";\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: private static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n# Natural Language Annotations: /**\n     * In order for tests to work currently regardless of the default system locale,\n     * we need to set the locale to a known value before running the tests.\n     * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n     * we cannot expect them to be in the locale that the test expects them to be in.\n     * This method exists to allow for an override.\n     *\n     * @param number never null\n     * @param decimalFormat never null\n     * @param locale never null\n     * @return the given decimalFormat with the given locale\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n/**\n * In order for tests to work currently regardless of the default system locale,\n * we need to set the locale to a known value before running the tests.\n * And because the DecimalFormat instances are initialized statically for reasons of performance,\n * we cannot expect them to be in the locale that the test expects them to be in.\n * This method exists to allow for an override.\n *\n * @param number never null\n * @param decimalFormat never null\n * @param locale never null\n * @return the given decimalFormat with the given locale\n */\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    return decimalFormat.format(number);\n}\n```", "```java\n/**\n * In order for tests to work currently regardless of the default system locale,\n * we need to set the locale to a known value before running the tests.\n * And because the {@link DecimalFormat} instances are initialized statically for reasons of performance,\n * we cannot expect them to be in the locale that the test expects them to be in.\n * This method exists to allow for an override.\n *\n * @param number never null\n * @param decimalFormat never null\n * @param locale never null\n * @return the given decimalFormat with the given locale\n */\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    return decimalFormat.format(number);\n}\n```", "```java\n/**\n * In order for tests to work currently regardless of the default system locale,\n * we need to set the locale to a known value before running the tests.\n * And because the DecimalFormat instances are initialized statically for reasons of performance,\n * we cannot expect them to be in the locale that the test expects them to be in.\n * This method exists to allow for an override.\n *\n * @param number never null\n * @param decimalFormat never null\n * @param locale never null\n * @return the given decimalFormat with the given locale\n */\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    decimalFormat.applyPattern(decimalFormat.toPattern());\n    decimalFormat.setLocale(locale);\n    return decimalFormat.format(number);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: @Deprecated(forRemoval = true, since = \"1.6.0\")    default SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n# Natural Language Annotations: /**\n     * Submits a planning problem to solve and returns immediately.\n     * The planning problem is solved on a solver {@link Thread}, as soon as one is available.\n     * <p>\n     * When the solver finds a new best solution, the {@code bestSolutionConsumer} is called every time,\n     * on a consumer {@link Thread}, as soon as one is available (taking into account any throttling waiting time),\n     * unless a newer best solution is already available by then (in which case skip ahead discards it).\n     * <p>\n     * Defaults to logging exceptions as an error.\n     * <p>\n     * To stop a solver job before it naturally terminates, call {@link #terminateEarly(Object)}.\n     *\n     * @param problemId never null, a ID for each planning problem. This must be unique.\n     *        Use this problemId to {@link #terminateEarly(Object) terminate} the solver early,\n     *        {@link #getSolverStatus(Object) to get the status} or if the problem changes while solving.\n     * @param problemFinder never null, a function that returns a {@link PlanningSolution}, usually with uninitialized planning\n     *        variables\n     * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n     * @deprecated It is recommended to use {@link #solveBuilder()} while also providing a consumer for the best solution\n     * @return never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n    Function<ProblemId_, PlanningSolution> problemFinder,\n    Consumer<Solution_> bestSolutionConsumer) {\n    // Create a new solver job\n    SolverJob<Solution_, ProblemId_> solverJob = new SolverJob<>(problemId, problemFinder, bestSolutionConsumer);\n\n    // Start the solver job\n    solverJob.start();\n\n    // Return the solver job\n    return solverJob;\n}\n```", "```java\n/**\n * Submits a planning problem to solve and returns immediately.\n * The planning problem is solved on a solver Thread, as soon as one is available.\n * <p>\n * When the solver finds a new best solution, the bestSolutionConsumer is called every time,\n * on a consumer Thread, as soon as one is available (taking into account any throttling waiting time),\n * unless a newer best solution is already available by then (in which case skip ahead discards it).\n * <p>\n * Defaults to logging exceptions as an error.\n * <p>\n * To stop a solver job before it naturally terminates, call #terminateEarly(Object).\n *\n * @param problemId never null, a ID for each planning problem. This must be unique.\n *        Use this problemId to #terminateEarly(Object) terminate the solver early,\n *        #getSolverStatus(Object) to get the status or if the problem changes while solving.\n * @param problemFinder never null, a function that returns a PlanningSolution, usually with uninitialized planning\n *        variables\n * @param bestSolutionConsumer never null, called multiple times, on a consumer thread\n * @deprecated It is recommended to use #solveBuilder() while also providing a consumer for the best solution\n * @return never null\n */\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault <Solution_, ProblemId_> SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n    Function<ProblemId_, PlanningSolution> problemFinder,\n    Consumer<PlanningSolution> bestSolutionConsumer) {\n    // implementation\n}\n```", "```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n                                                  Function<ProblemId_, PlanningSolution> problemFinder,\n                                                  Consumer<PlanningSolution> bestSolutionConsumer) {\n    return solveBuilder(problemId, problemFinder, bestSolutionConsumer, (e) -> {\n        // Defaults to logging exceptions as an error\n        // You can replace this with your own exception handling logic\n        // For example:\n        // logger.error(\"An error occurred while solving the problem\", e);\n    });\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n# Natural Language Annotations: /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\n    // implementation here\n    return this;\n}\n```", "```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    /**\n     * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n     *\n     * @param spentLimit sometimes null\n     * @return this, never null\n     */\n    return this;\n}\n```", "```java\n/**\n * As defined by {@link TerminationConfig#withSpentLimit(Duration)}, but returns this.\n *\n * @param spentLimit sometimes null\n * @return this, never null\n */\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    // implementation here\n    return this;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: public static <T> T meldProperty(T a, T b) {\n# Natural Language Annotations: /**\n     * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n     * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n     * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n     * property of the benchmark that didn't fail.\n     * <p>\n     * Null-handling:\n     * <ul>\n     * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n     * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n     * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n     * {@link #mergeProperty(Object, Object)}</li>\n     * </ul>\n     *\n     * @see #mergeProperty(Object, Object)\n     * @param a property {@code a}\n     * @param b property {@code b}\n     * @param <T> the type of property {@code a} and {@code b}\n     * @return sometimes null\n     */\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b == null) {\n        return a;\n    } else if (a == null && b != null) {\n        return b;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```", "```java\n/**\n * A relaxed version of {@link #mergeProperty(Object, Object)}. Used primarily for merging failed benchmarks,\n * where a property remains the same over benchmark runs (for example: dataset problem size), but the property in\n * the failed benchmark isn't initialized, therefore null. When merging, we can still use the correctly initialized\n * property of the benchmark that didn't fail.\n * <p>\n * Null-handling:\n * <ul>\n * <li>if <strong>both</strong> properties <strong>are null</strong>, returns null</li>\n * <li>if <strong>only one</strong> of the properties <strong>is not null</strong>, returns that property</li>\n * <li>if <strong>both</strong> properties <strong>are not null</strong>, returns\n * {@link #mergeProperty(Object, Object)}</li>\n * </ul>\n *\n * @see #mergeProperty(Object, Object)\n * @param a property {@code a}\n * @param b property {@code b}\n * @param <T> the type of property {@code a} and {@code b}\n * @return sometimes null\n */\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null) {\n        return a;\n    } else {\n        return b;\n    }\n}\n```", "```\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b == null) {\n        return a;\n    } else if (b != null && a == null) {\n        return b;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```"]}}