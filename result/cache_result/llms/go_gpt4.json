{"dtm-dtmsvr/storage/boltdb/boltdb.go-cleanupExpiredData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n# Natural Language Annotations: // cleanupExpiredData will clean the expired data in boltdb, the\n//\n//\texpired time is configurable.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"time\"\n\n\tbolt \"go.etcd.io/bbolt\"\n)\n\n// cleanupExpiredData will clean the expired data in boltdb, the\n// expired time is configurable.\nfunc cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n\t// Define the time threshold\n\texpirationThreshold := time.Now().Add(-expire)\n\n\t// Start a write transaction\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\t// Iterate through all the buckets in the bolt database\n\t\treturn tx.ForEach(func(name []byte, b *bolt.Bucket) error {\n\t\t\t// For each bucket, create a cursor to traverse through key/value pairs\n\t\t\tc := b.Cursor()\n\n\t\t\t// Iterate through each key-value pair\n\t\t\tfor k, v := c.First(); k != nil; k, v = c.Next() {\n\t\t\t\t// Assuming the value or key contains a timestamp, parse it\n\t\t\t\t// Here we are using the key as timestamp for expiry check\n\t\t\t\t// Conversion logic must match with data storage logic\n\t\t\t\t// This example assumes the timestamp is stored in the key as int64 in bytes\n\t\t\t\ttimestamp := int64(binary.BigEndian.Uint64(k))\n\t\t\t\trecordTime := time.Unix(0, timestamp)\n\n\t\t\t\t// If the record is expired, delete it\n\t\t\t\tif recordTime.Before(expirationThreshold) {\n\t\t\t\t\tif err := c.Delete(); err != nil {\n\t\t\t\t\t\t// If we can't delete, return the error\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Continue if no error during iteration\n\t\t\treturn nil\n\t\t})\n\t})\n\n\t// Return any error encountered during the update transaction\n\treturn err\n}\n```"]}, "dtm-dtmsvr/config/config.go-MustLoadConfig": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MustLoadConfig(confFile string) {\n# Natural Language Annotations: // MustLoadConfig load config from env and file\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/spf13/viper\"\n)\n\nfunc MustLoadConfig(confFile string) {\n\t// Set the file name of the configurations file\n\tviper.SetConfigFile(confFile)\n\n\t// Read in environment variables that match\n\tviper.AutomaticEnv()\n\n\t// Attempt to read the configuration from the file\n\tif err := viper.ReadInConfig(); err != nil {\n\t\tlog.Fatalf(\"Fatal error config file: %s \\n\", err)\n\t}\n\n\t// Check that the configuration file is actually found\n\tif viper.ConfigFileUsed() == \"\" {\n\t\tlog.Fatalf(\"Fatal error: Config file not found\")\n\t}\n\n\t// Output information about loaded configuration\n\tfmt.Printf(\"Using config file: %s\\n\", viper.ConfigFileUsed())\n}\n\nfunc main() {\n\tconfFile := \"config.yaml\" // Replace with your config file path\n\tMustLoadConfig(confFile)\n\n\t// Example usage of config\n\tmyConfigValue := viper.GetString(\"my_config_key\")\n\tfmt.Printf(\"My Config Value: %s\\n\", myConfigValue)\n}\n```\nThis function reads configuration settings from an environment variable and a given configuration file using the `viper` library in Go. It logs an error message and exits if it fails to read the configuration file or if the configuration file is not found."]}, "dtm-client/dtmcli/dtmimp/utils.go-MustRemarshal": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MustRemarshal(from interface{}, to interface{}) {\n# Natural Language Annotations: // MustRemarshal marshal and unmarshal, and check error\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"log\"\n)\n\n// MustRemarshal marshal and unmarshal, and check error\nfunc MustRemarshal(from interface{}, to interface{}) {\n\t// Marshal the 'from' interface\n\tdata, err := json.Marshal(from)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to marshal: %v\", err)\n\t}\n  \n\t// Unmarshal the data into 'to' interface\n\terr = json.Unmarshal(data, to)\n\tif err != nil {\n\t\tlog.Fatalf(\"Failed to unmarshal: %v\", err)\n\t}\n}\n```"]}, "kitex-tool/internal_pkg/generator/type.go-FixHasStreamingForExtendedService": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *ServiceInfo) FixHasStreamingForExtendedService() {\n# Natural Language Annotations: // FixHasStreamingForExtendedService updates the HasStreaming field for extended services.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Assume that ServiceInfo is a struct with a field HasStreaming and any other necessary fields\n// Also assume there is a mechanism to determine if the service is an extended service and if it should have streaming.\n\ntype ServiceInfo struct {\n    Name          string\n    IsExtended    bool\n    HasStreaming  bool\n}\n\n// FixHasStreamingForExtendedService updates the HasStreaming field for extended services.\nfunc (s *ServiceInfo) FixHasStreamingForExtendedService() {\n    if s.IsExtended {\n        // Logic to determine if the extended service should have streaming\n        // For the sake of this example, let's assume extended services always have streaming\n        s.HasStreaming = true\n    }\n}\n```"]}, "kitex-tool/internal_pkg/generator/type.go-HasStreamingRecursive": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *ServiceInfo) HasStreamingRecursive() bool {\n# Natural Language Annotations: // HasStreamingRecursive recursively check if the service has streaming method\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *ServiceInfo) HasStreamingRecursive() bool {\n    // Recursively check all methods of the service\n    for _, method := range s.Methods {\n        if method.IsStreaming {\n            return true\n        }\n    }\n    \n    // If no streaming method is found at this level, check nested services if any\n    for _, nestedService := range s.NestedServices {\n        if nestedService.HasStreamingRecursive() {\n            return true\n        }\n    }\n    \n    return false\n}\n```"]}, "kitex-tool/internal_pkg/generator/generator.go-Unpack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Config) Unpack(args []string) error {\n# Natural Language Annotations: // Unpack restores the Config from a slice of \"key=val\" strings.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (c *Config) Unpack(args []string) error {\n    for _, arg := range args {\n        // Split the string into key and value at the first '=' character\n        pair := strings.SplitN(arg, \"=\", 2)\n\n        // Check if we have both key and value\n        if len(pair) != 2 {\n            return fmt.Errorf(\"invalid format: %s\", arg)\n        }\n\n        key := pair[0]\n        value := pair[1]\n\n        // Use reflection or switch-case to set the fields in the Config struct\n        // I will assume Config is kind of a map; implement according to your specific struct\n        switch key {\n        // example assuming Config has fields like these\n        case \"setting1\":\n            c.Setting1 = value\n        case \"setting2\":\n            c.Setting2 = value\n        // add cases for other expected keys\n        default:\n            return fmt.Errorf(\"unknown key: %s\", key)\n        }\n    }\n    return nil\n}\n```"]}, "kitex-tool/internal_pkg/util/util.go-CombineOutputPath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CombineOutputPath(outputPath, ns string) string {\n# Natural Language Annotations: // CombineOutputPath read the output and path variables and render them into the final path\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport \"path/filepath\"\n\n// CombineOutputPath reads the output and path variables and renders them into the final path\nfunc CombineOutputPath(outputPath, ns string) string {\n    return filepath.Join(outputPath, ns)\n}\n```"]}, "kitex-pkg/rpcinfo/stats_util.go-CalcEventCostUs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CalcEventCostUs(start, end Event) uint64 {\n# Natural Language Annotations: // CalcEventCostUs calculates the duration between start and end and returns in microsecond.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport \"time\"\n\n// Event struct that has a Time field to store the event's time\ntype Event struct {\n\tTime time.Time\n}\n\n// CalcEventCostUs calculates the duration between start and end and returns it in microseconds.\nfunc CalcEventCostUs(start, end Event) uint64 {\n\t// Calculate the duration between the start and end events\n\tduration := end.Time.Sub(start.Time)\n\t\n\t// Convert the duration to microseconds and return it\n\treturn uint64(duration.Microseconds())\n}\n```"]}, "kitex-pkg/rpcinfo/invocation.go-NewInvocation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewInvocation(service, method string, pkgOpt ...string) *invocation {\n# Natural Language Annotations: // NewInvocation creates a new Invocation with the given service, method and optional package.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype invocation struct {\n\tservice string\n\tmethod  string\n\tpkgOpt  string\n}\n\n// NewInvocation creates a new Invocation with the given service, method, and optional package.\nfunc NewInvocation(service, method string, pkgOpt ...string) *invocation {\n\tvar pkg string\n\tif len(pkgOpt) > 0 {\n\t\tpkg = pkgOpt[0]\n\t}\n\n\treturn &invocation{\n\t\tservice: service,\n\t\tmethod:  method,\n\t\tpkgOpt:  pkg,\n\t}\n}\n```"]}, "kitex-pkg/retry/retryer.go-InitWithPolicies": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n# Natural Language Annotations: // InitWithPolicies to init Retryer with methodPolicies\n// Notice, InitWithPolicies is export func, the lock should be added inside\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n    // Add a lock to ensure concurrent access safety\n    rc.mutex.Lock()\n    defer rc.mutex.Unlock()\n\n    // Iterate over the methodPolicies map and initialize each policy\n    for method, policy := range methodPolicies {\n        if err := rc.InitializePolicyForMethod(method, policy); err != nil {\n            return err\n        }\n    }\n\n    // Successfully initialized all policies without errors\n    return nil\n}\n```"]}, "kitex-pkg/retry/retryer.go-WithRetryIfNeeded": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n# Natural Language Annotations: // WithRetryIfNeeded to check if there is a retryer can be used and if current call can retry.\n// When the retry condition is satisfied, use retryer to call\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n    // Check if there is a retry policy available\n    if callOptRetry != nil && callOptRetry.Condition != nil {\n        // Attempt the original RPC call\n        for attempts := 0; attempts <= callOptRetry.MaxAttempts; attempts++ {\n            lastRI, err = rpcCall(ctx, ri, request)\n            // If the call is successful, or if there is an error that should not trigger a retry, break out\n            if err == nil || !callOptRetry.Condition(err, lastRI) {\n                return lastRI, false, err\n            }\n            // Optionally, wait for some time before retrying\n            if callOptRetry.WaitDuration != 0 {\n                time.Sleep(callOptRetry.WaitDuration)\n            }\n        }\n    } else {\n        // If there's no retry policy, simply call the RPC once\n        lastRI, err = rpcCall(ctx, ri, request)\n    }\n    // If we've exhausted the retries or no retry was set up then recycle\n    return lastRI, true, err\n}\n```"]}, "kitex-pkg/discovery/discovery.go-DefaultDiff": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefaultDiff(cacheKey string, prev, next Result) (Change, bool) {\n# Natural Language Annotations: // DefaultDiff provides a natural implementation for the Diff method of the Resolver interface.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc DefaultDiff(cacheKey string, prev, next Result) (Change, bool) {\n    // Step 1: Compare the results\n    if prev == next {\n        // No change between previous and next results\n        return Change{}, false\n    }\n\n    // Step 2: Create a change object detailing the difference\n    change := Change{\n        CacheKey: cacheKey,\n        Previous: prev,\n        Current:  next,\n    }\n\n    // Step 3: Return the change object and true indicating a change occurred\n    return change, true\n}\n```"]}, "kitex-pkg/protocol/bthrift/binary.go-SetSpanCache": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func SetSpanCache(enable bool) {\n# Natural Language Annotations: // SetSpanCache enable/disable binary protocol bytes/string allocator\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\n// SetSpanCache enables or disables the binary protocol bytes/string allocator based on the 'enable' boolean.\nfunc SetSpanCache(enable bool) {\n\tif enable {\n\t\t// Enable the binary protocol bytes/string allocator.\n\t\t// Implementation to enable the cache should go here.\n\t\tprintln(\"Span cache enabled\")\n\t} else {\n\t\t// Disable the binary protocol bytes/string allocator.\n\t\t// Implementation to disable the cache should go here.\n\t\tprintln(\"Span cache disabled\")\n\t}\n}\n```"]}, "kitex-pkg/protocol/bthrift/unknown.go-GetUnknownFields": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetUnknownFields(v interface{}) (fields []UnknownField, err error) {\n# Natural Language Annotations: // GetUnknownFields deserialize unknownFields stored in v to a list of *UnknownFields.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// UnknownField represents a field that does not have a defined structure.\ntype UnknownField struct {\n\tKey   string\n\tValue interface{}\n}\n\n// GetUnknownFields deserializes unknown fields stored in the input `v`\n// to a list of `UnknownField`. It expects `v` to be a JSON-like structure\n// such as a map or struct.\nfunc GetUnknownFields(v interface{}) (fields []UnknownField, err error) {\n\t// Marshal the input interface `v` into JSON bytes\n\tdata, err := json.Marshal(v)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error marshalling input: %v\", err)\n\t}\n\n\t// Unmarshal the JSON bytes into a map of string to empty interface\n\tvar unknownMap map[string]interface{}\n\terr = json.Unmarshal(data, &unknownMap)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error unmarshalling into map: %v\", err)\n\t}\n\n\t// Traverse the map and convert each entry into an `UnknownField`\n\tfor key, value := range unknownMap {\n\t\tfields = append(fields, UnknownField{Key: key, Value: value})\n\t}\n\n\treturn fields, nil\n}\n```"]}, "kitex-pkg/protocol/bthrift/unknown.go-WriteUnknownFields": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n# Natural Language Annotations: // WriteUnknownFields writes fs into buf, and return written offset of the buf.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n)\n\n// UnknownField represents a field with an ID and data\ntype UnknownField struct {\n\tID   int\n\tData []byte\n}\n\n// WriteUnknownFields writes fs into buf, and returns the offset up to which the buf has been written\nfunc WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n\tif len(buf) == 0 {\n\t\treturn 0, errors.New(\"buffer is empty\")\n\t}\n\n\tbyteBuffer := bytes.NewBuffer(buf[:0]) // Use a byte buffer for more convenient writing\n\n\tfor _, field := range fs {\n\t\t// Write field ID as int\n\t\tif err := binary.Write(byteBuffer, binary.LittleEndian, int32(field.ID)); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Write field data length\n\t\tif err := binary.Write(byteBuffer, binary.LittleEndian, int32(len(field.Data))); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\n\t\t// Write field data\n\t\tif _, err := byteBuffer.Write(field.Data); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\n\t// Check if byteBuffer has surpassed original buffer size\n\tif byteBuffer.Len() > len(buf) {\n\t\treturn 0, errors.New(\"buffer overflow\")\n\t}\n\n\tcopy(buf, byteBuffer.Bytes())\n\treturn byteBuffer.Len(), nil\n}\n```"]}, "kitex-pkg/circuitbreak/circuitbreak.go-NewCircuitBreakerMW": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n# Natural Language Annotations: // NewCircuitBreakerMW creates a circuit breaker MW using the given Control strategy and Panel.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n    return func(next endpoint.Endpoint) endpoint.Endpoint {\n        return func(ctx context.Context, request interface{}) (interface{}, error) {\n            // Check if the circuit breaker allows the request to proceed\n            if control.ShouldOpen(panel) {\n                return nil, errors.New(\"circuit breaker is open\")\n            }\n\n            // Proceed with the request if allowed\n            response, err := next(ctx, request)\n\n            // Update the circuit breaker state based on the response or error\n            if err != nil {\n                control.RecordFailure(panel, err)\n            } else {\n                control.RecordSuccess(panel, response)\n            }\n\n            return response, err\n        }\n    }\n}\n```"]}, "kitex-pkg/circuitbreak/cbsuite.go-RPCInfo2Key": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RPCInfo2Key(ri rpcinfo.RPCInfo) string {\n# Natural Language Annotations: // RPCInfo2Key is to generate circuit breaker key through rpcinfo\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc RPCInfo2Key(ri rpcinfo.RPCInfo) string {\n    // Extract relevant information from the rpcinfo.RPCInfo struct to generate the key.\n    // Assuming the rpcinfo.RPCInfo struct contains fields like Method, ServiceName, or Endpoint,\n    // customize this according to the actual structure definition.\n\n    // Example, using hypothetical fields Method, ServiceName, and Endpoint:\n    keyComponents := []string{\n        ri.ServiceName,\n        ri.Method,\n        ri.Endpoint,\n    }\n\n    // Combine the extracted components into a single string key suitable for a circuit breaker\n    circuitBreakerKey := strings.Join(keyComponents, \"_\")\n\n    return circuitBreakerKey\n}\n```"]}, "kitex-pkg/circuitbreak/default.go-ErrorTypeOnServiceLevel": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ErrorTypeOnServiceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n# Natural Language Annotations: // ErrorTypeOnServiceLevel determines the error type with a service level criteria.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n    \"context\"\n    \"errors\"\n    \"net/http\"\n)\n\n// ErrorType is an enumerated type representing different kinds of error categories.\ntype ErrorType int\n\nconst (\n    NetworkError ErrorType = iota\n    ClientError\n    ServerError\n    UnknownError\n)\n\n// ErrorTypeOnServiceLevel determines the error type with a service level criteria.\n// It examines the error and the context to classify the error into one of several predefined types.\nfunc ErrorTypeOnServiceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n    if err == nil {\n        return UnknownError\n    }\n\n    // Example: Check if the error is a context deadline exceeded error.\n    if errors.Is(err, context.DeadlineExceeded) {\n        return NetworkError\n    }\n\n    // Example: Check if the error is a context canceled error.\n    if errors.Is(err, context.Canceled) {\n        return NetworkError\n    }\n\n    // Example: Check if the error can be cast to a HTTP error to determine client or server errors.\n    if httpErr, ok := err.(interface{ StatusCode() int }); ok {\n        statusCode := httpErr.StatusCode()\n        if statusCode >= 400 && statusCode < 500 {\n            return ClientError\n        } else if statusCode >= 500 && statusCode < 600 {\n            return ServerError\n        }\n    }\n\n    return UnknownError\n}\n```"]}, "kitex-pkg/circuitbreak/default.go-ErrorTypeOnInstanceLevel": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ErrorTypeOnInstanceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n# Natural Language Annotations: // ErrorTypeOnInstanceLevel determines the error type with an instance level criteria.\n// Basically, it treats only the connection error as failure.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n    \"context\"\n    \"net\"\n)\n\ntype ErrorType int\n\nconst (\n    Success ErrorType = iota\n    Failure\n    Unknown\n)\n\nfunc ErrorTypeOnInstanceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n    if err != nil {\n        if _, ok := err.(net.Error); ok {\n            // If the error satisfies the net.Error interface, treat it as a connection error\n            return Failure\n        }\n        return Unknown\n    }\n    return Success\n}\n```"]}, "kitex-pkg/utils/ring.go-NewRing": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewRing(size int) *Ring {\n# Natural Language Annotations: // Deprecated: it's not used by kitex anymore.\n// NewRing creates a ringbuffer with fixed size.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Ring is a simple ring buffer structure.\ntype Ring struct {\n\tdata  []interface{}\n\tsize  int\n\tstart int\n\tend   int\n}\n\n// NewRing creates a Ring (ring buffer) of a fixed size.\nfunc NewRing(size int) *Ring {\n\tif size <= 0 {\n\t\treturn nil\n\t}\n\treturn &Ring{\n\t\tdata: make([]interface{}, size),\n\t\tsize: size,\n\t}\n}\n```"]}, "kitex-pkg/utils/thrift.go-Serialize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *ThriftMessageCodec) Serialize(msg thrift.TStruct) (b []byte, err error) {\n# Natural Language Annotations: // Serialize serialize message into bytes. This is normal thrift serialize func.\n// Notice: Binary generic use Encode instead of Serialize.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (t *ThriftMessageCodec) Serialize(msg thrift.TStruct) (b []byte, err error) {\n    \n    // Create a buffer to write serialized bytes into\n    var buf bytes.Buffer\n    \n    // Create a new Binary Protocol using a Transport from the Buffer\n    transport := thrift.NewTMemoryBuffer()\n    protocol := thrift.NewTBinaryProtocolTransport(transport)\n\n    // Write the Thrift structure to the protocol\n    if err := msg.Write(protocol); err != nil {\n        return nil, err\n    }\n\n    // Retrieve the written bytes from the buffer\n    return transport.Buffer.Bytes(), nil\n}\n```"]}, "kitex-pkg/utils/thrift.go-Deserialize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *ThriftMessageCodec) Deserialize(msg thrift.TStruct, b []byte) (err error) {\n# Natural Language Annotations: // Deserialize deserialize bytes into message. This is normal thrift deserialize func.\n// Notice: Binary generic use Decode instead of Deserialize.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (t *ThriftMessageCodec) Deserialize(msg thrift.TStruct, b []byte) (err error) {\n    transport := thrift.NewTMemoryBufferLen(len(b))\n    _, err = transport.Write(b)\n    if err != nil {\n        return err\n    }\n\n    protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()\n    protocol := protocolFactory.GetProtocol(transport)\n\n    err = msg.Read(protocol)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```"]}, "kitex-pkg/utils/thrift.go-MarshalError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MarshalError(method string, err error) []byte {\n# Natural Language Annotations: // MarshalError convert go error to thrift exception, and encode exception over buffered binary transport.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n    \"bytes\"\n    \"github.com/apache/thrift/lib/go/thrift\"\n)\n\n// MarshalError converts a Go error to a Thrift exception, and then encodes the exception over buffered binary transport.\nfunc MarshalError(method string, err error) []byte {\n    // Create a buffer for the binary transport\n    buffer := thrift.NewTMemoryBuffer()\n    protocol := thrift.NewTBinaryProtocolTransport(buffer)\n\n    // Create a Thrift Application Exception with the error message\n    exception := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, err.Error())\n\n    // Write the exception to the protocol with the method name\n    exception.Write(protocol)\n\n    // Return the bytes from the buffer\n    return buffer.Bytes()\n}\n```"]}, "kitex-pkg/utils/rpcstats.go-CalculateEventCost": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CalculateEventCost(rpcstats rpcinfo.RPCStats, start, end stats.Event) time.Duration {\n# Natural Language Annotations: // CalculateEventCost get events from rpcstats, and calculates the time duration of (end - start).\n// It returns 0 when get nil rpcinfo event of either stats event.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc CalculateEventCost(rpcstats rpcinfo.RPCStats, start, end stats.Event) time.Duration {\n    // Check if either start or end event is nil, if so return 0\n    if !rpcstats.HasEvent(start) || !rpcstats.HasEvent(end) {\n        return 0\n    }\n\n    // Get the time of the start and end events\n    startTime := rpcstats.GetEventTime(start)\n    endTime := rpcstats.GetEventTime(end)\n\n    // Calculate the duration between the end and start event\n    duration := endTime.Sub(startTime)\n\n    // Return the calculated duration\n    return duration\n}\n```\n"]}, "kitex-pkg/utils/json.go-_Map2JSONStr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func _Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n# Natural Language Annotations: // Map2JSONStr transform map[string]string to json str, perf is better than use json lib directly\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// _Map2JSONStr transforms map[string]string to a JSON string with better performance than using a JSON library directly.\nfunc _Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n\tif mapInfo == nil {\n\t\treturn \"\", errors.New(\"input map cannot be nil\")\n\t}\n\n\tvar sb strings.Builder\n\tsb.WriteString(\"{\")\n\tfirst := true\n\n\tfor key, value := range mapInfo {\n\t\tif !first {\n\t\t\tsb.WriteString(\",\")\n\t\t}\n\t\tsb.WriteString(\"\\\"\")\n\t\tsb.WriteString(escapeString(key))\n\t\tsb.WriteString(\"\\\":\\\"\")\n\t\tsb.WriteString(escapeString(value))\n\t\tsb.WriteString(\"\\\"\")\n\t\tfirst = false\n\t}\n\n\tsb.WriteString(\"}\")\n\n\treturn sb.String(), nil\n}\n\n// escapeString escapes special JSON characters in a string.\nfunc escapeString(s string) string {\n\tvar sb strings.Builder\n\tfor _, r := range s {\n\t\tswitch r {\n\t\tcase '\\\\':\n\t\t\tsb.WriteString(`\\\\`)\n\t\tcase '\"':\n\t\t\tsb.WriteString(`\\\"`)\n\t\tcase '\\b':\n\t\t\tsb.WriteString(`\\b`)\n\t\tcase '\\f':\n\t\t\tsb.WriteString(`\\f`)\n\t\tcase '\\n':\n\t\t\tsb.WriteString(`\\n`)\n\t\tcase '\\r':\n\t\t\tsb.WriteString(`\\r`)\n\t\tcase '\\t':\n\t\t\tsb.WriteString(`\\t`)\n\t\tdefault:\n\t\t\tsb.WriteRune(r)\n\t\t}\n\t}\n\treturn sb.String()\n}\n```"]}, "kitex-pkg/utils/json.go-_JSONStr2Map": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func _JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n# Natural Language Annotations: // JSONStr2Map transform json str to map[string]string, perf is better than use json lib directly\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// _JSONStr2Map transforms a JSON string representation to a map[string]string.\n// The function assumes that the JSON string is flat with string keys and string values.\nfunc _JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n\t// Initialize the map to store the key-value pairs\n\tmapInfo = make(map[string]string)\n\t\n\t// Trim spaces and remove surrounding curly braces from the JSON input string\n\tjsonStr = strings.TrimSpace(jsonStr)\n\tif len(jsonStr) < 2 || jsonStr[0] != '{' || jsonStr[len(jsonStr)-1] != '}' {\n\t\treturn nil, errors.New(\"invalid JSON format\")\n\t}\n\tjsonStr = jsonStr[1 : len(jsonStr)-1]\n\n\t// Splitting based on comma to extract individual key-value pairs\n\tpairs := strings.Split(jsonStr, \",\")\n\n\tfor _, pair := range pairs {\n\t\t// Splitting each key-value pair based on colon\n\t\tkv := strings.SplitN(pair, \":\", 2)\n\t\tif len(kv) != 2 {\n\t\t\treturn nil, errors.New(\"invalid key-value pair\")\n\t\t}\n\n\t\t// Trim extra spaces and surrounding quotes from keys and values\n\t\tkey := strings.Trim(kv[0], \" \\\"\")\n\t\tvalue := strings.Trim(kv[1], \" \\\"\")\n\n\t\t// Add the key-value pair to the map\n\t\tmapInfo[key] = value\n\t}\n\n\treturn mapInfo, nil\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCaller": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCaller(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCaller is used to get the Service Name of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n)\n\nfunc GetCaller(ctx context.Context) (string, bool) {\n\t// Use a key to extract the caller name from the context\n\t// Assuming the context holds the service name under the key \"callerServiceName\"\n\tconst callerKey = \"callerServiceName\"\n\n\t// Extract the service name from the context\n\tserviceName, ok := ctx.Value(callerKey).(string)\n\tif !ok {\n\t\t// Return false if unable to get the service name\n\t\treturn \"\", false\n\t}\n\n\t// Return the service name and true indicating success\n\treturn serviceName, true\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetMethod(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetMethod is used to get the current RPC Method name.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\nfunc GetMethod(ctx context.Context) (string, bool) {\n\tmd, ok := metadata.FromIncomingContext(ctx)\n\tif !ok {\n\t\treturn \"\", false\n\t}\n\n\tif methodNames, ok := md[\":method\"]; ok && len(methodNames) > 0 {\n\t\treturn methodNames[0], true\n\t}\n\n\treturn \"\", false\n}\n\nfunc main() {\n\t// Example usage\n\tctx := metadata.NewIncomingContext(context.Background(), metadata.Pairs(\":method\", \"ExampleRPCMethod\"))\n\tmethod, success := GetMethod(ctx)\n\tif success {\n\t\tfmt.Println(\"Method:\", method)\n\t} else {\n\t\tfmt.Println(\"Failed to get method name\")\n\t}\n}\n```\n"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerHandlerMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerHandlerMethod(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCallerHandlerMethod is used to get the method name of caller.\n// Only the caller is a Kitex server will have this method information by default, or you can set K_METHOD into context.Context then kitex will get it.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n)\n\nconst K_METHOD = \"K_METHOD\"\n\nfunc GetCallerHandlerMethod(ctx context.Context) (string, bool) {\n\t// Try to retrieve the method name from the context using the key K_METHOD\n\tif methodName, ok := ctx.Value(K_METHOD).(string); ok {\n\t\t// If the method name exists and is a string, return it along with true\n\t\treturn methodName, true\n\t}\n\n\t// If the method name cannot be retrieved, return an empty string and false\n\treturn \"\", false\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetIDLServiceName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetIDLServiceName(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetIDLServiceName gets the serviceName which defined in IDL.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n    \"context\"\n)\n\n// Assuming there's some sort of context key or a way to extract the serviceName based on your application's needs.\n// This is a placeholder for whatever mechanism you'd use to define the key.\ntype ContextKey string\n\nconst ServiceNameKey ContextKey = \"serviceName\"\n\n// GetIDLServiceName gets the serviceName defined in IDL.\n// Return false if failed to get the information.\nfunc GetIDLServiceName(ctx context.Context) (string, bool) {\n    // Attempt to get the service name from the context\n    if serviceName, ok := ctx.Value(ServiceNameKey).(string); ok && serviceName != \"\" {\n        return serviceName, true\n    }\n    return \"\", false\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerAddr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerAddr(ctx context.Context) (net.Addr, bool) {\n# Natural Language Annotations: // GetCallerAddr is used for the server to get the Address of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// GetCallerAddr is used for the server to get the Address of the caller.\n// Return false if failed to get the information.\nfunc GetCallerAddr(ctx context.Context) (net.Addr, bool) {\n\t// Extract the request object from context\n\treq, ok := ctx.Value(http.ServerContextKey).(*http.Request)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\t// Get the remote address of the client (caller)\n\tremoteAddr, err := net.ResolveTCPAddr(\"tcp\", req.RemoteAddr)\n\tif err != nil {\n\t\treturn nil, false\n\t}\n\n\treturn remoteAddr, true\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerIP": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerIP(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCallerIP is used for the server to get the IP of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"net/http\"\n)\n\n// GetCallerIP is used for the server to get the IP of the caller.\n// Return false if failed to get the information.\nfunc GetCallerIP(ctx context.Context) (string, bool) {\n\t// Attempt to get the request from the context\n\treq, ok := ctx.Value(http.Request{}).(*http.Request)\n\tif !ok || req == nil {\n\t\treturn \"\", false\n\t}\n\n\t// Check if the X-Forwarded-For header exists which is common in proxied requests\n\txfwd := req.Header.Get(\"X-Forwarded-For\")\n\tif xfwd != \"\" {\n\t\treturn xfwd, true\n\t}\n\n\t// If X-Forwarded-For is not set, use RemoteAddr\n\tip, _, err := net.SplitHostPort(req.RemoteAddr)\n\tif err != nil {\n\t\treturn \"\", false\n\t}\n\n\t// Check to see if the extracted IP is a valid IP address\n\tparsedIP := net.ParseIP(ip)\n\tif parsedIP == nil {\n\t\treturn \"\", false\n\t}\n\n\treturn ip, true\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetTransportProtocol": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetTransportProtocol(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetTransportProtocol gets the transport protocol of the request.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n)\n\nfunc GetTransportProtocol(ctx context.Context) (string, bool) {\n\treq, ok := ctx.Value(http.ServerContextKey).(*http.Request)\n\tif !ok || req == nil {\n\t\treturn \"\", false\n\t}\n\n\tif req.TLS != nil {\n\t\treturn \"https\", true\n\t}\n\n\treturn \"http\", true\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetRPCInfo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetRPCInfo(ctx context.Context) (rpcinfo.RPCInfo, bool) {\n# Natural Language Annotations: // GetRPCInfo gets the RPCInfo in ctx.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\n\t\"yourpackage/rpcinfo\" // replace with the actual import path of your rpcinfo package\n)\n\n// GetRPCInfo gets the RPCInfo in ctx.\nfunc GetRPCInfo(ctx context.Context) (rpcinfo.RPCInfo, bool) {\n\t// Assuming `rpcinfoKey` is the key used to store RPCInfo in the context\n\trpcInfoKey := \"rpcinfoKey\"\n\n\t// Attempt to retrieve the RPCInfo from the context using the rpcInfoKey\n\trpcInfo, ok := ctx.Value(rpcInfoKey).(rpcinfo.RPCInfo)\n\tif !ok {\n\t\t// Return false if the RPCInfo could not be retrieved successfully\n\t\treturn rpcinfo.RPCInfo{}, false\n\t}\n\n\t// Return the retrieved RPCInfo and true indicating success\n\treturn rpcInfo, true\n}\n```"]}, "kitex-pkg/remote/trans_errors.go-NewTransError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewTransError(typeID int32, err error) *TransError {\n# Natural Language Annotations: // NewTransError to build TransError with typeID and rawErr.\n// rawErr can be used by errors.Is(target) to check err type, like read timeout.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n)\n\n// TransError is a custom error type that includes a typeID and supports unwrapping.\ntype TransError struct {\n\ttypeID int32\n\terr    error\n}\n\n// Error implements the error interface for TransError, returning the error message.\nfunc (te *TransError) Error() string {\n\tif te.err == nil {\n\t\treturn \"Unknown error\"\n\t}\n\treturn te.err.Error()\n}\n\n// Unwrap returns the inner error, allowing errors.Is and errors.As to work with TransError.\nfunc (te *TransError) Unwrap() error {\n\treturn te.err\n}\n\n// NewTransError creates a new instance of TransError with a given typeID and error.\nfunc NewTransError(typeID int32, err error) *TransError {\n\treturn &TransError{\n\t\ttypeID: typeID,\n\t\terr:    err,\n\t}\n}\n\nfunc main() {\n\t// Example usage\n\terr := errors.New(\"read timeout\")\n\ttransErr := NewTransError(1, err)\n\n\tif errors.Is(transErr, err) {\n\t\tprintln(\"The error matches the underlying error.\")\n\t} else {\n\t\tprintln(\"The error does not match.\")\n\t}\n}\n```"]}, "kitex-pkg/remote/trans/gonet/bytebuffer.go-NewBufferReader": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBufferReader(ir io.Reader) remote.ByteBuffer {\n# Natural Language Annotations: // NewBufferReader creates a new remote.ByteBuffer using the given netpoll.ZeroCopyReader.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage remote\n\nimport (\n\t\"bytes\"\n\t\"io\"\n)\n\n// ByteBuffer represents a buffer that holds bytes.\ntype ByteBuffer struct {\n\tbuffer *bytes.Buffer\n}\n\n// NewByteBuffer creates a new ByteBuffer.\nfunc NewByteBuffer(r io.Reader) ByteBuffer {\n\tbuf := new(bytes.Buffer)\n\tbuf.ReadFrom(r)\n\treturn ByteBuffer{buffer: buf}\n}\n\n// NewBufferReader creates a new ByteBuffer using the given io.Reader.\nfunc NewBufferReader(ir io.Reader) ByteBuffer {\n\treturn NewByteBuffer(ir)\n}\n```"]}, "kitex-pkg/remote/trans/gonet/bytebuffer.go-WriteDirect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n# Natural Language Annotations: // WriteDirect is a way to write []byte without copying, and splits the original buffer.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n    // Check if the remaining capacity is less than the length of the byte slice\n    if remainCap < len(p) {\n        return fmt.Errorf(\"not enough remaining capacity\")\n    }\n\n    // Here, implement logic to write directly into the buffer without copying\n    // and ensure splitting the original buffer is handled.\n\n    // Assuming rw.buffer is our slice where data should be written directly\n    // This will vary based on the actual structure and logic of bufferReadWriter\n    if len(rw.buffer)+len(p) > cap(rw.buffer) {\n        // Split original buffer if needed\n        newBuff := make([]byte, len(rw.buffer), len(rw.buffer)+remainCap)\n        copy(newBuff, rw.buffer)\n        rw.buffer = newBuff\n    }\n\n    // Append the byte slice directly to the buffer (modify as per your buffer design)\n    rw.buffer = append(rw.buffer, p...)\n\n    return nil\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/server_handler.go-invokeStreamUnaryHandler": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func invokeStreamUnaryHandler(ctx context.Context, st streaming.Stream, mi serviceinfo.MethodInfo,\n# Natural Language Annotations: // invokeStreamUnaryHandler allows unary APIs over HTTP2 to use the same server middleware as non-streaming APIs.\n// For thrift unary APIs over HTTP2, it's enabled by default.\n// For grpc(protobuf) unary APIs, it's disabled by default to keep backward compatibility.\nPlease only return the code surrounded by ```\n", "response": ["```python\nfrom contextlib import asynccontextmanager\nimport typing\n\nclass Context:\n    pass  # Placeholder for context.Context\n\nclass Stream:\n    pass  # Placeholder for streaming.Stream\n\nclass MethodInfo:\n    def __init__(self, name: str, is_thrift_unary: bool, is_grpc_unary: bool):\n        self.name = name\n        self.is_thrift_unary = is_thrift_unary\n        self.is_grpc_unary = is_grpc_unary\n\nasync def invoke_thrift_handler(ctx: Context, st: Stream, mi: MethodInfo):\n    # Placeholder for function to handle thrift unary calls\n    pass\n\nasync def invoke_grpc_handler(ctx: Context, st: Stream, mi: MethodInfo):\n    # Placeholder for function to handle grpc unary calls\n    pass\n\nasync def invokeStreamUnaryHandler(ctx: Context, st: Stream, mi: MethodInfo):\n    \"\"\"\n    Allows unary APIs over HTTP2 to use the same server middleware as non-streaming APIs.\n    For thrift unary APIs, this is enabled by default.\n    For grpc unary APIs, this is disabled by default to maintain backward compatibility.\n    \"\"\"\n    if mi.is_thrift_unary:\n        await invoke_thrift_handler(ctx, st, mi)\n    elif mi.is_grpc_unary:\n        # Invoke gRPC handler with caution, as it's disabled by default\n        await invoke_grpc_handler(ctx, st, mi)\n```\n"]}, "kitex-pkg/remote/trans/nphttp2/metadata/metadata.go-FromOutgoingContext": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromOutgoingContext(ctx context.Context) (MD, bool) {\n# Natural Language Annotations: // FromOutgoingContext returns the outgoing metadata in ctx if it exists.  The\n// returned MD should not be modified. Writing to it may cause races.\n// Modification should be made to copies of the returned MD.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc/metadata\"\n)\n\n// FromOutgoingContext returns the outgoing metadata in ctx if it exists.\n// The returned MD should not be modified. Writing to it may cause races.\n// Modification should be made to copies of the returned MD.\nfunc FromOutgoingContext(ctx context.Context) (metadata.MD, bool) {\n\tmd, ok := metadata.FromOutgoingContext(ctx)\n\treturn md, ok\n}\n\nfunc main() {\n\t// Example usage:\n\tctx := context.Background()\n\tctx = metadata.NewOutgoingContext(ctx, metadata.Pairs(\"key\", \"value\"))\n\tmd, ok := FromOutgoingContext(ctx)\n\tif ok {\n\t\tfmt.Println(\"Outgoing metadata found:\", md)\n\t} else {\n\t\tfmt.Println(\"No outgoing metadata found.\")\n\t}\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/status/status.go-WithDetails": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Status) WithDetails(details ...proto.Message) (*Status, error) {\n# Natural Language Annotations: // WithDetails returns a new status with the provided details messages appended to the status.\n// If any errors are encountered, it returns nil and the first error encountered.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"errors\"\n\t\"google.golang.org/protobuf/proto\"\n)\n\n// Status is a placeholder for whatever status type you are using.\ntype Status struct {\n\tdetails []proto.Message\n}\n\n// WithDetails returns a new status with the provided details messages appended to the status.\n// If any errors are encountered, it returns nil and the first error encountered.\nfunc (s *Status) WithDetails(details ...proto.Message) (*Status, error) {\n\tif s == nil {\n\t\treturn nil, errors.New(\"status is nil\")\n\t}\n\n\t// Clone the original status to ensure immutability of the original.\n\tnewStatus := &Status{}\n\t*newStatus = *s\n\n\t// Append each proto.Message detail.\n\tfor _, detail := range details {\n\t\tif detail == nil {\n\t\t\treturn nil, errors.New(\"one of the provided details is nil\")\n\t\t}\n\n\t\t// In a real implementation, you might want to deep copy the detail if necessary\n\t\tnewStatus.details = append(newStatus.details, detail)\n\t}\n\n\treturn newStatus, nil\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/status/status.go-FromError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromError(err error) (s *Status, ok bool) {\n# Natural Language Annotations: // FromError returns a Status representing err if it was produced from this\n// package or has a method `GRPCStatus() *Status`. Otherwise, ok is false and a\n// Status is returned with codes.Unknown and the original error message.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc FromError(err error) (s *Status, ok bool) {\n    type grpcStatus interface {\n        GRPCStatus() *Status\n    }\n\n    if err == nil {\n        return new(Status), true\n    }\n\n    // Check if the error has a GRPCStatus method\n    if gs, hasGRPCStatus := err.(grpcStatus); hasGRPCStatus {\n        return gs.GRPCStatus(), true\n    }\n\n    // Error doesn't have GRPCStatus, return status with codes.Unknown\n    return &Status{\n        Code:    codes.Unknown,\n        Message: err.Error(),\n    }, false\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/status/status.go-FromContextError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromContextError(err error) *Status {\n# Natural Language Annotations: // FromContextError converts a context error into a Status.  It returns a\n// Status with codes.OK if err is nil, or a Status with codes.Unknown if err is\n// non-nil and not a context error.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc FromContextError(err error) *Status {\n    if err == nil {\n        return &Status{Code: codes.OK}\n    }\n    \n    ctxErr, ok := err.(context.Canceled)\n    if ok {\n        return &Status{Code: codes.Canceled}\n    }\n\n    ctxErr, ok = err.(context.DeadlineExceeded)\n    if ok {\n        return &Status{Code: codes.DeadlineExceeded}\n    }\n\n    return &Status{Code: codes.Unknown}\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/bdp_estimator.go-calculate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *bdpEstimator) calculate(d [8]byte) {\n# Natural Language Annotations: // calculate is called when an ack for a bdp ping is received.\n// Here we calculate the current bdp and bandwidth sample and\n// decide if the flow control windows should go up.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (b *bdpEstimator) calculate(d [8]byte) {\n\t// Convert the 8-byte array into a uint64 representing the round-trip time (RTT) or whatever metric the ping provides\n\tmetric := binary.BigEndian.Uint64(d[:])\n\n\t// Calculate the current bandwidth-delay product (BDP)\n\t// This assumes we have a known bandwidth 'bw' in bits/sec and 'metric' represents the delay in seconds\n\tcurrentBDP := b.currentBandwidth * metric\n\tb.samples = append(b.samples, currentBDP)\n\n\t// Calculate current bandwidth sample from the BDP; assuming metric provides a delay and we have a currentBandwidth rate\n\tbandwidthSample := currentBDP / metric\n\tb.bandwidthSamples = append(b.bandwidthSamples, bandwidthSample)\n\n\t// Calculate the average bandwidth and BDP from the samples collected so far\n\tvar totalBDP, totalBW uint64\n\tfor _, sample := range b.samples {\n\t\ttotalBDP += sample\n\t}\n\tfor _, sample := range b.bandwidthSamples {\n\t\ttotalBW += sample\n\t}\n\taverageBDP := totalBDP / uint64(len(b.samples))\n\taverageBandwidth := totalBW / uint64(len(b.bandwidthSamples))\n\n\t// Decide if the flow control windows should increase\n\tthresholdBDP := b.initialBDP * 2 // Example threshold to avoid excessive increase\n\tif averageBDP > thresholdBDP {\n\t\t// Increase flow control window, this is just an illustrative example\n\t\tb.flowControlWindow += averageBDP - thresholdBDP\n\t}\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/http2_server.go-finishStream": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *http2Server) finishStream(s *Stream, rst bool, rstCode http2.ErrCode, hdr *headerFrame, eosReceived bool) {\n# Natural Language Annotations: // finishStream closes the stream and puts the trailing headerFrame into controlbuf.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (t *http2Server) finishStream(s *Stream, rst bool, rstCode http2.ErrCode, hdr *headerFrame, eosReceived bool) {\n    // If rst is true, send a RST_STREAM frame with the specified error code.\n    if rst {\n        // Prepare a RST_STREAM frame with the stream's ID and the specified error code.\n        t.writeFrameToControlBuffer(&rstStreamFrame{\n            id:  uint32(s.id),\n            err: rstCode,\n        })\n    }\n    \n    // Close the stream, indicating that no more data can be sent on this stream.\n    s.close()\n\n    // If a header frame is provided, push it to the control buffer.\n    if hdr != nil {\n        // Push the trailing header frame into the control buffer.\n        t.controlBuf.put(hdr)\n    }\n    \n    // If end of stream was received, handle any necessary finalization here.\n    if eosReceived {\n        // Perform operations needed when EOS is received.\n        s.handleEOS()\n    }\n\n    // Perform any additional cleanup or bookkeeping necessary after finishing the stream.\n    // This might include removing the stream from active maps or notifying other systems.\n    t.removeStream(s)\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/http2_server.go-closeStream": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *http2Server) closeStream(s *Stream, rst bool, rstCode http2.ErrCode, eosReceived bool) {\n# Natural Language Annotations: // closeStream clears the footprint of a stream when the stream is not needed any more.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (t *http2Server) closeStream(s *Stream, rst bool, rstCode http2.ErrCode, eosReceived bool) {\n    // Check if stream is already closed, return if so\n    if s.state == StateClosed {\n        return\n    }\n\n    // If reset (rst) is requested, reset the stream with the provided code\n    if rst {\n        t.writeStreamReset(s.id, rstCode)\n    }\n\n    // Mark stream as closed\n    s.state = StateClosed\n\n    // If end of stream (EOS) is received, handle any cleanup specific to that case\n    if eosReceived {\n        // Potentially notify of completion or other clean-up tasks specific to EOS\n    }\n\n    // Remove stream from any tracking maps/lists to clear its footprint\n    t.streams.Delete(s.id)\n\n    // Optional: perform any additional resource cleanup if needed\n    s.cleanupResources()\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/transport.go-TLSConfig": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TLSConfig(tlsConfig *tls.Config) *tls.Config {\n# Natural Language Annotations: // TLSConfig checks and supplement the tls config provided by user.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc TLSConfig(tlsConfig *tls.Config) *tls.Config {\n    if tlsConfig == nil {\n        tlsConfig = &tls.Config{}\n    }\n\n    // Example: Ensuring that minimum TLS version is set\n    if tlsConfig.MinVersion == 0 {\n        tlsConfig.MinVersion = tls.VersionTLS12\n    }\n\n    // Example: Setting some recommended ciphersuites if not set\n    if len(tlsConfig.CipherSuites) == 0 {\n        tlsConfig.CipherSuites = []uint16{\n            tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,\n            tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,\n            tls.TLS_RSA_WITH_AES_128_GCM_SHA256,\n            tls.TLS_RSA_WITH_AES_256_GCM_SHA384,\n        }\n    }\n\n    // Example: Optionally enforce strict client certificate verification\n    if tlsConfig.ClientAuth == tls.NoClientCert {\n        tlsConfig.ClientAuth = tls.RequireAndVerifyClientCert\n    }\n\n    return tlsConfig\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/http_util.go-encodeTimeout": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func encodeTimeout(t time.Duration) string {\n# Natural Language Annotations: // TODO(zhaoq): It is the simplistic and not bandwidth efficient. Improve it.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc encodeTimeout(t time.Duration) string {\n\t// If the duration is negative or zero, return \"0s\" as per Go's convention.\n\tif t <= 0 {\n\t\treturn \"0s\"\n\t}\n\n\t// Go's time.Duration represents a duration in nanoseconds.\n\t// We'll encode it in the form: NhNmNs (e.g., 1h15m30s).\n\t// Start by getting the total number of seconds.\n\tseconds := int64(t.Seconds())\n\n\t// Calculate hours, minutes, and remaining seconds.\n\thours := seconds / 3600\n\tseconds %= 3600\n\tminutes := seconds / 60\n\tseconds %= 60\n\n\t// Build the string representation.\n\tvar result string\n\tif hours > 0 {\n\t\tresult += fmt.Sprintf(\"%dh\", hours)\n\t}\n\tif minutes > 0 {\n\t\tresult += fmt.Sprintf(\"%dm\", minutes)\n\t}\n\tif seconds > 0 {\n\t\tresult += fmt.Sprintf(\"%ds\", seconds)\n\t}\n\n\tif result == \"\" {\n\t\treturn \"0s\"\n\t}\n\treturn result\n}\n```"]}, "kitex-pkg/remote/trans/netpoll/bytebuf.go-AppendBuffer": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *netpollByteBuffer) AppendBuffer(buf remote.ByteBuffer) (err error) {\n# Natural Language Annotations: // AppendBuffer appends buf to the original buffer.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (b *netpollByteBuffer) AppendBuffer(buf remote.ByteBuffer) (err error) {\n\t// Retrieve the bytes from the remote.ByteBuffer\n\tnewData, err := buf.Bytes()\n\tif err != nil {\n\t\treturn err\n\t}\n\t\n\t// Append the new data to the existing buffer's data\n\tb.data = append(b.data, newData...)\n\t\n\treturn nil\n}\n```"]}, "kitex-pkg/remote/codec/util.go-SetOrCheckMethodName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func SetOrCheckMethodName(methodName string, message remote.Message) error {\n# Natural Language Annotations: // SetOrCheckMethodName is used to set method name to invocation.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Assuming a simplified representation of the remote.Message structure for this example\ntype remoteMessage struct {\n\tinvocationMethodName string\n}\n\nfunc (m *remoteMessage) setMethodName(methodName string) {\n\tm.invocationMethodName = methodName\n}\n\nfunc (m *remoteMessage) getMethodName() string {\n\treturn m.invocationMethodName\n}\n\n// SetOrCheckMethodName is used to set the method name to the invocation.\nfunc SetOrCheckMethodName(methodName string, message *remoteMessage) error {\n\t// Check if the method name is empty\n\tif strings.TrimSpace(methodName) == \"\" {\n\t\treturn errors.New(\"methodName should not be empty\")\n\t}\n\n\t// Check if the message already has a method name set\n\tcurrentMethodName := message.getMethodName()\n\tif currentMethodName != \"\" && currentMethodName != methodName {\n\t\treturn errors.New(\"method name already set to a different value\")\n\t}\n\n\t// Set the method name to the message's invocation\n\tmessage.setMethodName(methodName)\n\treturn nil\n}\n\n// Example usage\nfunc main() {\n\tmessage := &remoteMessage{}\n\terr := SetOrCheckMethodName(\"NewMethod\", message)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Method name set successfully.\")\n\t}\n}\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-MarshalThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MarshalThriftData(ctx context.Context, codec remote.PayloadCodec, data interface{}) ([]byte, error) {\n# Natural Language Annotations: // MarshalThriftData only encodes the data (without the prepending methodName, msgType, seqId)\n// It will allocate a new buffer and encode to it\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"git.apache.org/thrift.git/lib/go/thrift\"\n)\n\n// Assuming `remote.PayloadCodec` interfaces with `Encode(ctx context.Context, data interface{}) ([]byte, error)`\ntype PayloadCodec interface {\n\tEncode(ctx context.Context, data interface{}) ([]byte, error)\n}\n\nfunc MarshalThriftData(ctx context.Context, codec PayloadCodec, data interface{}) ([]byte, error) {\n\tif codec == nil {\n\t\treturn nil, errors.New(\"codec cannot be nil\")\n\t}\n\n\tif data == nil {\n\t\treturn nil, errors.New(\"data cannot be nil\")\n\t}\n\n\t// Use the codec to encode the data to Thrift byte format\n\tencodedData, err := codec.Encode(ctx, data)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a buffer to hold the final encoded bytes\n\tbuffer := bytes.NewBuffer(nil)\n\n\t// Write the encoded data directly to the buffer\n\tif _, err := buffer.Write(encodedData); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn buffer.Bytes(), nil\n}\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-marshalBasicThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func marshalBasicThriftData(ctx context.Context, tProt thrift.TProtocol, data interface{}) error {\n# Natural Language Annotations: // marshalBasicThriftData only encodes the data (without the prepending method, msgType, seqId)\n// It uses the old thrift way which is much slower than FastCodec and Frugal\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc marshalBasicThriftData(ctx context.Context, tProt thrift.TProtocol, data interface{}) error {\n    switch v := data.(type) {\n    case int:\n        return tProt.WriteI32(int32(v))\n    case int32:\n        return tProt.WriteI32(v)\n    case int64:\n        return tProt.WriteI64(v)\n    case float64:\n        return tProt.WriteDouble(v)\n    case string:\n        return tProt.WriteString(v)\n    case bool:\n        return tProt.WriteBool(v)\n    case []byte:\n        return tProt.WriteBinary(v)\n    case map[string]interface{}:\n        if err := tProt.WriteMapBegin(thrift.STRING, thrift.STRUCT, len(v)); err != nil {\n            return err\n        }\n        for key, val := range v {\n            if err := tProt.WriteString(key); err != nil {\n                return err\n            }\n            if err := marshalBasicThriftData(ctx, tProt, val); err != nil {\n                return err\n            }\n        }\n        if err := tProt.WriteMapEnd(); err != nil {\n            return err\n        }\n    case []interface{}:\n        if err := tProt.WriteListBegin(thrift.STRUCT, len(v)); err != nil {\n            return err\n        }\n        for _, item := range v {\n            if err := marshalBasicThriftData(ctx, tProt, item); err != nil {\n                return err\n            }\n        }\n        if err := tProt.WriteListEnd(); err != nil {\n            return err\n        }\n    default:\n        return fmt.Errorf(\"unsupported data type: %T\", data)\n    }\n    return nil\n}\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-UnmarshalThriftException": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func UnmarshalThriftException(tProt thrift.TProtocol) error {\n# Natural Language Annotations: // UnmarshalThriftException decode thrift exception from tProt\n// If your input is []byte, you can wrap it with `NewBinaryProtocol(remote.NewReaderBuffer(buf))`\nPlease only return the code surrounded by ```\n", "response": ["To implement the `UnmarshalThriftException` function that decodes a Thrift exception from a given `thrift.TProtocol`, we need to write a function that will handle the protocol read operations to extract the exception from the Thrift message. We will utilize the Thrift library for Go to achieve this.\n\nBelow is how you can implement the function:\n\n```go\nfunc UnmarshalThriftException(tProt thrift.TProtocol) error {\n    _, msgType, seqID, err := tProt.ReadMessageBegin()\n    if err != nil {\n        return err\n    }\n\n    if msgType != thrift.EXCEPTION {\n        return thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, \"Not an exception message\")\n    }\n\n    appEx := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, \"Unknown Exception\")\n    if err := appEx.Read(tProt); err != nil {\n        return err\n    }\n\n    err = tProt.ReadMessageEnd()\n    if err != nil {\n        return err\n    }\n\n    return appEx\n}\n```\n\nThis code does the following:\n\n1. Reads the message header using `ReadMessageBegin`.\n2. Checks if the message type is an exception (`thrift.EXCEPTION`).\n3. If it's not an exception, returns an appropriate error.\n4. If it is an exception, creates a new `TApplicationException`, and reads the exception data from the protocol into `appEx`.\n5. Ends the message reading using `ReadMessageEnd`.\n6. Returns the `appEx`, which encapsulates the Thrift exception."]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-UnmarshalThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n# Natural Language Annotations: // UnmarshalThriftData only decodes the data (after methodName, msgType and seqId)\n// It will decode from the given buffer.\n// Note:\n// 1. `method` is only used for generic calls\n// 2. if the buf contains an exception, you should call UnmarshalThriftException instead.\nPlease only return the code surrounded by ```\n", "response": ["```\npackage main\n\nimport (\n    \"context\"\n    \"errors\"\n\n    \"github.com/apache/thrift/lib/go/thrift\"\n    \"your/package/remote\" // Adjust the import path as necessary\n)\n\n// UnmarshalThriftException is a placeholder for handling exceptions\nfunc UnmarshalThriftException(buf []byte) (error, bool) {\n    // Dummy implementation to check for an exception in the buffer.\n    // You should replace this with actual logic to detect exceptions.\n    // For now, let's assume if the buffer starts with a specific sequence it is an exception.\n    if len(buf) > 0 && buf[0] == 0x01 { // Example condition\n        return errors.New(\"Detected exception in Thrift data\"), true\n    }\n    return nil, false\n}\n\nfunc UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n    // Check if the buffer contains an exception\n    if err, isException := UnmarshalThriftException(buf); isException {\n        return err\n    }\n\n    // Initialize Thrift binary protocol\n    transport := thrift.NewTMemoryBuffer()\n    if _, err := transport.Write(buf); err != nil {\n        return err\n    }\n\n    protocol := thrift.NewTBinaryProtocolTransport(transport)\n\n    // Reading and decoding just after methodName, msgType and seqId\n    // If buf doesn't start with methodName, msgType and seqId, you should handle how to skip them here\n    // Assuming you have codecs that handle these and position buffer correctly.\n\n    // Attempt to decode data\n    if err := codec.Decode(protocol, data); err != nil {\n        return err\n    }\n\n    return nil\n}\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-unmarshalThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c thriftCodec) unmarshalThriftData(ctx context.Context, tProt *BinaryProtocol, method string, data interface{}, dataLen int) error {\n# Natural Language Annotations: // unmarshalThriftData only decodes the data (after methodName, msgType and seqId)\n// method is only used for generic calls\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (c thriftCodec) unmarshalThriftData(ctx context.Context, tProt *BinaryProtocol, method string, data interface{}, dataLen int) error {\n    // Prepare a buffer to read the incoming data\n    buf := make([]byte, dataLen)\n    if _, err := tProt.Read(buf); err != nil {\n        return fmt.Errorf(\"failed to read binary protocol data: %w\", err)\n    }\n\n    // Create a Transport with the buffer\n    transport := NewMemoryBufferLen(dataLen)\n    if _, err := transport.Write(buf); err != nil {\n        return fmt.Errorf(\"failed to write to memory buffer: %w\", err)\n    }\n\n    // Create a new protocol instance for the transport\n    protocol := NewBinaryProtocol(transport)\n\n    // Using reflection to handle generic interface unmarshalling\n    if err := dataFromProtocol(ctx, protocol, method, data); err != nil {\n        return fmt.Errorf(\"error unmarshalling data: %w\", err)\n    }\n\n    return nil\n}\n\nfunc dataFromProtocol(ctx context.Context, protocol *BinaryProtocol, method string, data interface{}) error {\n    // Using Go reflection to decode data based on its type\n    rv := reflect.ValueOf(data)\n    if rv.Kind() != reflect.Ptr || rv.IsNil() {\n        return fmt.Errorf(\"data must be a non-nil pointer\")\n    }\n\n    // Unmarshal data from the protocol to the provided interface\n    if err := protocol.ReadStruct(rv.Interface()); err != nil {\n        return err\n    }\n\n    return nil\n}\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-decodeBasicThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n# Natural Language Annotations: // decodeBasicThriftData decode thrift body the old way (slow)\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"fmt\"\n)\n\nfunc decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n\tif tProt == nil || data == nil {\n\t\treturn errors.New(\"nil protocol or data interface\")\n\t}\n\t\n\t// Read the message\n\t_, _, seqID, err := tProt.ReadMessageBegin()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"error reading message begin: %w\", err)\n\t}\n\tdefer tProt.ReadMessageEnd()\n\t\n\t// Check the method name if required\n\t// This check is not explicitly mentioned but can be useful depending on implementation\n\tif method != \"\" && method != seqID {\n\t\treturn errors.New(\"method mismatch\")\n\t}\n\t\n\t// Use slow decoding method\n\tswitch val := data.(type) {\n\tcase *SomeStructType:\n\t\t// Decode into a specific structure\n\t\terr = val.Read(tProt)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"error reading data into struct: %w\", err)\n\t\t}\n\tdefault:\n\t\treturn errors.New(\"unsupported data interface type\")\n\t}\n\t\n\treturn nil\n}\n```\n\nNote: In this code, `SomeStructType` is a placeholder for the specific type you want to decode the data into. Replace it with the actual type you need to use."]}, "kitex-pkg/remote/remotecli/conn_wrapper.go-GetConn": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (cm *ConnWrapper) GetConn(ctx context.Context, d remote.Dialer, ri rpcinfo.RPCInfo) (net.Conn, error) {\n# Natural Language Annotations: // GetConn returns a connection using the given Dialer and RPCInfo.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (cm *ConnWrapper) GetConn(ctx context.Context, d remote.Dialer, ri rpcinfo.RPCInfo) (net.Conn, error) {\n\t// Utilize the Dialer to establish a connection\n\tconn, err := d.Dial(ctx, ri)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t\n\t// Return the established connection\n\treturn conn, nil\n}\n```"]}, "kitex-pkg/remote/connpool/long_pool.go-Evict": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *pool) Evict() (evicted int) {\n# Natural Language Annotations: // Evict cleanups the expired connections.\n// Evict returns how many connections has been evicted.\nPlease only return the code surrounded by ```\n", "response": ["The function `Evict` is designed to clean up expired connections from a hypothetical connection pool, and it returns the number of connections that have been evicted. Below is the implementation based on the provided function signature and natural language annotations:\n\n```go\nfunc (p *pool) Evict() (evicted int) {\n    evicted = 0 // Initialize the evicted count to zero.\n\n    // Assuming p.connections is a slice of connections and each connection has an expired() method.\n    // The expired() method determines if a connection is expired (returns true if it is expired).\n    for i := 0; i < len(p.connections); {\n        connection := p.connections[i]\n        if connection.expired() {\n            // Remove the expired connection from the slice.\n            p.connections = append(p.connections[:i], p.connections[i+1:]...)\n            evicted++ // Increment the evicted count.\n        } else {\n            i++ // Move to the next connection only if no eviction occurred.\n        }\n    }\n\n    return evicted // Return the total number of connections evicted.\n}\n```\n\nIn this implementation:\n- We loop through the connection pool and check if each connection is expired using an assumed `expired()` method.\n- If a connection is expired, we remove it from the pool and adjust the slice accordingly.\n- The number of evicted connections is counted and returned."]}, "kitex-pkg/loadbalance/lbcache/cache.go-NewBalancerFactory": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n# Natural Language Annotations: // NewBalancerFactory get or create a balancer factory for balancer instance\n// cache key with resolver name, balancer name and options\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n    // Use a map to function as a cache with the key derived from resolver name, balancer name, and options\n    cacheKey := resolver.Name() + \"-\" + balancer.Name() + \"-\" + opts.String()\n    \n    // Initialize a map to cache created BalancerFactories\n    var cache = make(map[string]*BalancerFactory)\n    \n    // Check if the BalancerFactory already exists in the cache\n    if factory, exists := cache[cacheKey]; exists {\n        return factory\n    }\n    \n    // If not, create a new BalancerFactory\n    newFactory := &BalancerFactory{\n        Resolver: resolver,\n        Balancer: balancer,\n        Options: opts,\n    }\n    \n    // Store the new BalancerFactory in the cache\n    cache[cacheKey] = newFactory\n    \n    return newFactory\n}\n```\n"]}, "kitex-pkg/stats/event.go-DefineNewEvent": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefineNewEvent(name string, level Level) (Event, error) {\n# Natural Language Annotations: // DefineNewEvent allows user to add event definitions during program initialization.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Level represents the severity level of an event.\ntype Level int\n\nconst (\n\tLow Level = iota\n\tMedium\n\tHigh\n)\n\n// Event represents an event with a name and a severity level.\ntype Event struct {\n\tName  string\n\tLevel Level\n}\n\n// DefineNewEvent allows user to add event definitions during program initialization.\nfunc DefineNewEvent(name string, level Level) (Event, error) {\n\tif name == \"\" {\n\t\treturn Event{}, errors.New(\"event name cannot be empty\")\n\t}\n\tif level < Low || level > High {\n\t\treturn Event{}, errors.New(\"invalid event level\")\n\t}\n\n\tnewEvent := Event{\n\t\tName:  name,\n\t\tLevel: level,\n\t}\n\n\treturn newEvent, nil\n}\n\nfunc main() {\n\t// Example usage\n\tevent, err := DefineNewEvent(\"SystemStart\", Medium)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Defined event:\", event)\n\t}\n}\n```"]}, "kitex-pkg/generic/thriftidl_provider.go-NewThriftFileProviderWithDynamicGo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n# Natural Language Annotations: // NewThriftFileProviderWithDynamicGo create a ThriftIDLProvider with dynamicgo by given path and include dirs\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"github.com/thriftrw/thriftrw-go\"\n\t\"github.com/thriftrw/thriftrw-go/idl\"\n\t\"os\"\n)\n\n// DescriptorProvider is an interface that provides descriptors.\n// Assume that this interface is defined elsewhere in your project.\ntype DescriptorProvider interface{}\n\n// NewThriftFileProviderWithDynamicGo creates a ThriftIDLProvider with dynamicgo by the given path and include directories.\nfunc NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n\t// Check if the provided path exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn nil, errors.New(\"specified path does not exist\")\n\t}\n\n\t// Initialize idl.Loader with provided include directories\n\tloader := idl.Loader{\n\t\tIncludePaths: includeDirs,\n\t}\n\n\t// Load the Thrift file\n\tthrift, err := loader.Load(path)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create DescriptorProvider using thrift\n\tprovider := thriftrw.New(thrift)\n\treturn provider, nil\n}\n```"]}, "kitex-pkg/generic/thriftidl_provider.go-NewThriftContentWithAbsIncludePathProviderWithDynamicGo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n# Natural Language Annotations: // NewThriftContentWithAbsIncludePathProviderWithDynamicGo create abs include path DescriptorProvider with dynamicgo\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"errors\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// ThriftContentWithAbsIncludePathProvider is a struct that you would need to have defined elsewhere in your code\ntype ThriftContentWithAbsIncludePathProvider struct {\n\tMainIDLPath  string\n\tIncludePaths map[string]string\n}\n\n// NewThriftContentWithAbsIncludePathProviderWithDynamicGo creates an absolute include path DescriptorProvider with dynamic go\nfunc NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n\tif mainIDLPath == \"\" {\n\t\treturn nil, errors.New(\"mainIDLPath cannot be empty\")\n\t}\n\n\t// Convert all include paths to absolute paths\n\tabsIncludes := make(map[string]string)\n\tfor key, path := range includes {\n\t\tabsPath, err := filepath.Abs(path)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tabsIncludes[key] = absPath\n\t}\n\n\tprovider := &ThriftContentWithAbsIncludePathProvider{\n\t\tMainIDLPath:  mainIDLPath,\n\t\tIncludePaths: absIncludes,\n\t}\n\n\treturn provider, nil\n}\n```"]}, "kitex-pkg/generic/generic.go-MapThriftGeneric": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MapThriftGeneric(p DescriptorProvider) (Generic, error) {\n# Natural Language Annotations: // MapThriftGeneric map mapping generic\n// Base64 codec for binary field is disabled by default. You can change this option with SetBinaryWithBase64.\n// eg:\n//\n//\tg, err := generic.MapThriftGeneric(p)\n//\tSetBinaryWithBase64(g, true)\n//\n// String value is returned for binary field by default. You can change the return value to []byte for binary field with SetBinaryWithByteSlice.\n// eg:\n//\n//\tSetBinaryWithByteSlice(g, true)\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t// Assuming necessary imports for DescriptorProvider and Generic\n)\n\ntype DescriptorProvider interface {\n\t// Assume necessary methods are defined here\n}\n\ntype Generic struct {\n\t// Assume structure of the Generic type\n}\n\n// Option type for configuring the output of MapThriftGeneric\ntype Option func(*Generic)\n\n// MapThriftGeneric maps a DescriptorProvider to a Generic structure.\n// It allows options to configure how binary fields are returned.\nfunc MapThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n\tvar g Generic\n\t// Map the DescriptorProvider to the Generic type\n\t// Logic to map the DescriptorProvider to Generic goes here\n\n\t// Applying any options passed to the function\n\tfor _, opt := range opts {\n\t\topt(&g)\n\t}\n\n\t// Return the mapped Generic object and nil error by default\n\treturn g, nil\n}\n\n// You can define SetBinaryWithBase64 as an Option to set the binary field format\nfunc SetBinaryWithBase64(g *Generic, useBase64 bool) {\n\t// Logic to configure binary with Base64\n}\n\n// Define SetBinaryWithByteSlice as an Option to set the binary field format to a byte slice\nfunc SetBinaryWithByteSlice(g *Generic, useByteSlice bool) {\n\t// Logic to configure binary value to return as []byte\n}\n```"]}, "kitex-pkg/generic/generic.go-JSONThriftGeneric": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n# Natural Language Annotations: // JSONThriftGeneric json mapping generic.\n// Base64 codec for binary field is enabled by default. You can change this option with SetBinaryWithBase64.\n// eg:\n//\n//\tg, err := generic.JSONThriftGeneric(p)\n//\tSetBinaryWithBase64(g, false)\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Assume DescriptorProvider, Generic, Option, and SetBinaryWithBase64 are defined in the actual implementation\n\n// DescriptorProvider is a placeholder for whatever type p is supposed to be. Define appropriately.\ntype DescriptorProvider interface{}\n\n// Generic is a placeholder for the return type. Define appropriately.\ntype Generic struct {\n\t// Implementation assumes various properties and methods\n\tbinaryWithBase64 bool\n}\n\n// Option is a placeholder for the option type. Define appropriately.\ntype Option func(*Generic) error\n\n// JSONThriftGeneric json mapping generic.\n// Base64 codec for binary field is enabled by default. You can change this option with SetBinaryWithBase64.\n// eg: g, err := generic.JSONThriftGeneric(p); SetBinaryWithBase64(g, false)\nfunc JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n\t// Start implementing the function\n\n\t// Initialize Generic structure with default settings\n\tg := Generic{\n\t\tbinaryWithBase64: true, // Default setting\n\t}\n\n\t// Validate DescriptorProvider input (stub, assume validation function exists)\n\tif p == nil {\n\t\treturn Generic{}, errors.New(\"invalid DescriptorProvider\")\n\t}\n\n\t// Apply functional options that modify the Generic structure\n\tfor _, opt := range opts {\n\t\tif err := opt(&g); err != nil {\n\t\t\treturn Generic{}, fmt.Errorf(\"failed to apply option: %w\", err)\n\t\t}\n\t}\n\n\t// Ensure g is correctly set up based on p and opts before returning\n\t// Here you'd typically have logic that utilizes p to configure g\n\n\t// Return the configured Generic struct along with no error\n\treturn g, nil\n}\n\n// Sample option function to change binaryWithBase64\nfunc SetBinaryWithBase64(g *Generic, enabled bool) error {\n\tif g == nil {\n\t\treturn errors.New(\"Generic is nil\")\n\t}\n\tg.binaryWithBase64 = enabled\n\treturn nil\n}\n```"]}, "kitex-pkg/generic/generic.go-JSONPbGeneric": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n# Natural Language Annotations: // JSONPbGeneric json mapping generic.\n// Uses dynamicgo for json to protobufs conversion, so DynamicGo field is true by default.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\n// Define necessary interfaces and structs as they are not given.\n\ntype Option func(*options)\n\ntype options struct {\n    DynamicGo bool\n}\n\ntype Generic interface{}\n\ntype PbDescriptorProviderDynamicGo interface {\n    ToProto() (Generic, error)\n}\n\n// JSONPbGeneric json mapping generic.\n// Uses dynamicgo for json to protobufs conversion, so DynamicGo field is true by default.\nfunc JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n    // Set default options\n    defaultOptions := options{\n        DynamicGo: true,\n    }\n\n    // Apply user-provided options\n    for _, opt := range opts {\n        opt(&defaultOptions)\n    }\n\n    // Perform conversion using the PbDescriptorProviderDynamicGo\n    if !defaultOptions.DynamicGo {\n        return nil, errors.New(\"DynamicGo must be enabled\")\n    }\n\n    result, err := p.ToProto()\n    if err != nil {\n        return nil, err\n    }\n\n    return result, nil\n}\n\n// Usage demonstration - main function\nfunc main() {\n    // Assuming we have a PbDescriptorProviderDynamicGo implementation\n    var provider PbDescriptorProviderDynamicGo\n\n    // Call the function\n    generic, err := JSONPbGeneric(provider)\n    if err != nil {\n        fmt.Println(\"Error:\", err)\n        return\n    }\n\n    fmt.Println(\"Generic result:\", generic)\n}\n```"]}, "kitex-pkg/generic/thrift/write.go-writeStruct": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n# Natural Language Annotations: // writeStruct iter with Descriptor, can check the field's required and others\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/example/descriptor\" // Assume this is where TypeDescriptor is defined\n)\n\n// writerOption is a struct that may contain various options for writing. Define its fields as needed.\ntype writerOption struct {\n\t// Add relevant fields here if needed\n}\n\n// writeStruct iterates over the structure described by the TypeDescriptor.\n// It checks the field's requirements and writes the values to the thrift protocol.\nfunc writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n\t// Convert val to a reflect.Value\n\tv := reflect.ValueOf(val)\n\tif v.Kind() != reflect.Struct {\n\t\treturn fmt.Errorf(\"val is not a struct\")\n\t}\n\n\t// Iterate over fields in the struct\n\tfor _, fieldDesc := range t.Fields {\n\t\tfieldValue := v.FieldByName(fieldDesc.Name)\n\t\tif !fieldValue.IsValid() {\n\t\t\tif fieldDesc.Required {\n\t\t\t\treturn fmt.Errorf(\"required field %s is missing\", fieldDesc.Name)\n\t\t\t}\n\t\t\t// Skip writing this field if it is not valid and not required\n\t\t\tcontinue\n\t\t}\n\n\t\t// Handle the writing of different types\n\t\tif err := writeField(out, fieldValue, fieldDesc); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// writeField is a helper function responsible for writing a single field of the struct to the protocol.\nfunc writeField(out thrift.TProtocol, val reflect.Value, fieldDesc descriptor.FieldDescriptor) error {\n\t// Begin writing the field to the protocol\n\tif err := out.WriteFieldBegin(fieldDesc.Name, fieldDesc.Type, fieldDesc.ID); err != nil {\n\t\treturn err\n\t}\n\n\t// Depending on the field type, write the value\n\tswitch fieldDesc.Type {\n\tcase thrift.STRING:\n\t\tif err := out.WriteString(val.String()); err != nil {\n\t\t\treturn err\n\t\t}\n\tcase thrift.I32:\n\t\tif err := out.WriteI32(int32(val.Int())); err != nil {\n\t\t\treturn err\n\t\t}\n\t// Add cases for other types as needed\n\tdefault:\n\t\treturn fmt.Errorf(\"unsupported field type: %v\", fieldDesc.Type)\n\t}\n\n\t// End writing the field\n\treturn out.WriteFieldEnd()\n}\n```"]}, "kitex-pkg/generic/descriptor/tree.go-addRoute": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n *node) addRoute(path string, function *FunctionDescriptor) {\n# Natural Language Annotations: // addRoute adds a node with the given function to the path.\n// Not concurrency-safe!\nPlease only return the code surrounded by ```\n", "response": ["```go\n// FunctionDescriptor represents the structure or type of the function descriptor.\ntype FunctionDescriptor struct {\n\t// Add necessary fields here\n}\n\n// node represents a single element of a routing tree.\ntype node struct {\n\tpath     string\n\tfunction *FunctionDescriptor\n\tchildren []*node\n}\n\n// addRoute adds a node with the given function to the path.\n// Not concurrency-safe!\nfunc (n *node) addRoute(path string, function *FunctionDescriptor) {\n\t// Split the path to process each part individually.\n\tpathParts := splitPath(path)\n\n\t// Start with the current node.\n\tcurrentNode := n\n\n\tfor _, part := range pathParts {\n\t\t// Find if there's already a child node with the given path part.\n\t\tchildFound := false\n\t\tfor _, child := range currentNode.children {\n\t\t\tif child.path == part {\n\t\t\t\t// Proceed with the existing child node.\n\t\t\t\tcurrentNode = child\n\t\t\t\tchildFound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\n\t\t// If no child found, create a new node and add it to children.\n\t\tif !childFound {\n\t\t\tnewNode := &node{path: part}\n\t\t\tcurrentNode.children = append(currentNode.children, newNode)\n\t\t\tcurrentNode = newNode\n\t\t}\n\t}\n\n\t// Assign the function descriptor to the final node in the path.\n\tcurrentNode.function = function\n}\n\n// Helper function to split path into its components.\nfunc splitPath(path string) []string {\n\t// Trim leading and trailing slashes and split by remaining slashes.\n\treturn filterEmpty(strings.Split(strings.Trim(path, \"/\"), \"/\"))\n}\n\n// Helper function to filter out empty strings from an array.\nfunc filterEmpty(parts []string) []string {\n\tfiltered := []string{}\n\tfor _, part := range parts {\n\t\tif part != \"\" {\n\t\t\tfiltered = append(filtered, part)\n\t\t}\n\t}\n\treturn filtered\n}\n```"]}, "kitex-pkg/mem/span.go-NewSpanCache": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewSpanCache(spanSize int) *spanCache {\n# Natural Language Annotations: // NewSpanCache returns a spanCache with the given spanSize,\n// each span is used to allocate a binary of a specific size level.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype spanCache struct {\n    spanSize int\n    spans    map[int][]byte\n}\n\n// NewSpanCache returns a spanCache with the given spanSize,\n// each span is used to allocate a binary of a specific size level.\nfunc NewSpanCache(spanSize int) *spanCache {\n    return &spanCache{\n        spanSize: spanSize,\n        spans:    make(map[int][]byte),\n    }\n}\n```"]}, "kitex-pkg/profiler/profiler.go-Pause": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *profiler) Pause() {\n# Natural Language Annotations: // Pause the profiler.\n// The profiler has been paused when Pause() return\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (p *profiler) Pause() {\n\t// Assume the profiler has a method or a way to pause its operations.\n\tp.paused = true\n\t// Additional logic to suspend any ongoing profiling tasks can be added here.\n}\n```"]}, "kitex-pkg/profiler/profiler.go-Resume": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *profiler) Resume() {\n# Natural Language Annotations: // Resume the profiler.\n// The profiler has been resumed when Resume() return\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (p *profiler) Resume() {\n    // Check if the profiler is currently paused\n    if !p.isPaused {\n        return // If not paused, do nothing and return\n    }\n    \n    // Perform actions to resume the profiler\n    // This may include resetting timers, restarting processes, etc.\n    p.isPaused = false // Update the state to indicate the profiler is now running\n    \n    // Signal or perform any other necessary operations to truly resume the profiler\n    if p.resumeChannel != nil {\n        p.resumeChannel <- struct{}{} // Notify that the profiler has been resumed\n    }\n    \n    // At the end of this function, the profiler has resumed\n}\n```"]}, "kitex-pkg/acl/acl.go-NewACLMiddleware": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewACLMiddleware(rules []RejectFunc) endpoint.Middleware {\n# Natural Language Annotations: // NewACLMiddleware creates a new ACL middleware using the provided reject funcs.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Assume endpoint is a package with the following Middleware type\ntype Middleware func(endpoint.Endpoint) endpoint.Endpoint\n\n// Assume RejectFunc is a function type that returns an error if the request should be rejected\ntype RejectFunc func(ctx context.Context, request interface{}) error\n\n// NewACLMiddleware creates a new ACL middleware using the provided reject funcs.\nfunc NewACLMiddleware(rules []RejectFunc) endpoint.Middleware {\n\treturn func(next endpoint.Endpoint) endpoint.Endpoint {\n\t\treturn func(ctx context.Context, request interface{}) (response interface{}, err error) {\n\t\t\tfor _, rule := range rules {\n\t\t\t\terr := rule(ctx, request)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn next(ctx, request)\n\t\t}\n\t}\n}\n\n// Mock endpoint package for demonstration\npackage endpoint\n\nimport \"context\"\n\n// Endpoint is a type alias for a function that handles a request and returns a response or error.\ntype Endpoint func(ctx context.Context, request interface{}) (response interface{}, err error)\n\n// Mock implementation for a testing scenario\nfunc main() {\n\tacceptAll := func(ctx context.Context, request interface{}) error {\n\t\treturn nil\n\t}\n\n\trejectAll := func(ctx context.Context, request interface{}) error {\n\t\treturn errors.New(\"access denied\")\n\t}\n\n\tmiddleware := NewACLMiddleware([]RejectFunc{acceptAll, rejectAll})\n\n\t// Example endpoint implementation\n\tendpoint := func(ctx context.Context, request interface{}) (interface{}, error) {\n\t\treturn \"success\", nil\n\t}\n\n\tsecuredEndpoint := middleware(endpoint)\n\n\tresponse, err := securedEndpoint(context.Background(), \"request\")\n\tif err != nil {\n\t\tfmt.Printf(\"Request failed: %v\\n\", err)\n\t} else {\n\t\tfmt.Printf(\"Response: %v\\n\", response)\n\t}\n}\n```"]}, "kitex-client/context_middleware.go-WithContextMiddlewares": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n# Natural Language Annotations: // WithContextMiddlewares add middlewares into current ctx\n// Every client receive this ctx will execute the middlewares.\n// Note that ContextMiddleware is prior to the ClientMiddleware.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n    \"context\"\n\n    \"github.com/go-kit/kit/endpoint\"\n)\n\n// contextKey is a type used for keys in context, to avoid collisions\ntype contextKey string\n\n// middlewaresKey is the key used to store middlewares in the context\nconst middlewaresKey contextKey = \"middlewaresKey\"\n\n// WithContextMiddlewares adds middlewares into the current context.\n// Every client that receives this context will execute the middlewares.\n// Note that ContextMiddleware is prioritized over ClientMiddleware.\nfunc WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n    existingMws, _ := ctx.Value(middlewaresKey).([]endpoint.Middleware)\n    allMws := append(existingMws, mws...)\n    return context.WithValue(ctx, middlewaresKey, allMws)\n}\n\n// FromContextMiddlewares extracts middlewares from the context if available.\nfunc FromContextMiddlewares(ctx context.Context) []endpoint.Middleware, bool {\n    mws, ok := ctx.Value(middlewaresKey).([]endpoint.Middleware)\n    return mws, ok\n}\n```"]}, "kitex-client/stream.go-RecvMsg": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) RecvMsg(m interface{}) (err error) {\n# Natural Language Annotations: // RecvMsg receives a message from the server.\n// If an error is returned, stream.DoFinish() will be called to record the end of stream\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *stream) RecvMsg(m interface{}) (err error) {\n    // Attempt to receive a message from the stream\n    err = s.receive(m)\n    \n    // Check if there was an error during receiving\n    if err != nil {\n        // If there was an error, record the end of the stream\n        s.DoFinish()\n        return err\n    }\n    \n    // Return nil if message received successfully\n    return nil\n}\n```"]}, "kitex-client/stream.go-SendMsg": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) SendMsg(m interface{}) (err error) {\n# Natural Language Annotations: // SendMsg sends a message to the server.\n// If an error is returned, stream.DoFinish() will be called to record the end of stream\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *stream) SendMsg(m interface{}) (err error) {\n    // Attempt to send message to server.\n    err = s.sendToServer(m)\n    \n    // Check if there was an error during sending.\n    if err != nil {\n        // Record the end of the stream since there was an issue.\n        s.DoFinish()\n    }\n    \n    // Return any error encountered during the sending process.\n    return err\n}\n```"]}, "kitex-client/stream.go-DoFinish": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) DoFinish(err error) {\n# Natural Language Annotations: // DoFinish implements the streaming.WithDoFinish interface, and it records the end of stream\n// It will release the connection.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *stream) DoFinish(err error) {\n    // Check if there is an error provided\n    if err != nil {\n        // Log or handle the error as necessary\n        fmt.Printf(\"Stream finished with error: %v\\n\", err)\n    } else {\n        // Log successful completion if needed\n        fmt.Println(\"Stream finished successfully.\")\n    }\n    \n    // Release the connection associated with the stream\n    if s.connection != nil {\n        s.releaseConnection()\n        s.connection = nil\n    }\n    \n    // Record the end of the stream\n    s.isFinished = true\n}\n\n// Assuming there are helper methods for releasing connection\nfunc (s *stream) releaseConnection() {\n    // Implementation code for releasing the connection\n    fmt.Println(\"Connection released.\")\n}\n```"]}, "kitex-client/client.go-NewClient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...Option) (Client, error) {\n# Natural Language Annotations: // NewClient creates a kitex.Client with the given ServiceInfo, it is from generated code.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...Option) (Client, error) {\n    // Ensure the service info is not nil\n    if svcInfo == nil {\n        return nil, errors.New(\"service information cannot be nil\")\n    }\n\n    // Initialize the client configuration with the provided service info and options\n    clientConfig := buildClientConfig(svcInfo, opts...)\n\n    // Create and return the kitex.Client using the configuration\n    client, err := kitex.NewClient(clientConfig)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to create client: %v\", err)\n    }\n    \n    return client, nil\n}\n\n// Helper function to build client configuration based on service info and options\nfunc buildClientConfig(svcInfo *serviceinfo.ServiceInfo, opts ...Option) kitex.ClientConfig {\n    // Initialize the client configuration with default values\n    config := kitex.ClientConfig{\n        ServiceName: svcInfo.ServiceName,\n        // Set other default configuration values as needed\n    }\n\n    // Apply options to customize the client configuration\n    for _, opt := range opts {\n        opt(&config)\n    }\n\n    return config\n}\n```"]}, "kitex-client/middlewares.go-newResolveMWBuilder": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.MiddlewareBuilder {\n# Natural Language Annotations: // newResolveMWBuilder creates a middleware for service discovery.\n// This middleware selects an appropriate instance based on the resolver and loadbalancer given.\n// If retryable error is encountered, it will retry until timeout or an unretryable error is returned.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.MiddlewareBuilder {\n    return func(next endpoint.Endpoint) endpoint.Endpoint {\n        return func(ctx context.Context, request interface{}) (response interface{}, err error) {\n            var (\n                retryTimeout = time.Second * 30 // Define a reasonable retry timeout\n                startTime    = time.Now()\n            )\n\n            for {\n                // Get the available instances from the load balancer resolver\n                instance, err := lbf.Resolve()\n                if err != nil {\n                    if isUnretryableError(err) {\n                        return nil, err // Return if the error is unretryable\n                    }\n\n                    if time.Since(startTime) > retryTimeout {\n                        return nil, fmt.Errorf(\"retry timeout exceeded: %w\", err) // Retry timeout exceeded\n                    }\n\n                    time.Sleep(time.Millisecond * 100) // Delay a bit before retrying\n                    continue\n                }\n\n                // Set the selected instance in the context\n                ctx = context.WithValue(ctx, \"instance\", instance)\n\n                // Call the next middleware/endpoint in the chain\n                response, err = next(ctx, request)\n                if err != nil {\n                    if isRetryableError(err) && time.Since(startTime) <= retryTimeout {\n                        time.Sleep(time.Millisecond * 100) // Delay a bit before retrying\n                        continue\n                    }\n                    return nil, err // Return on unretryable error or timeout exceeded\n                }\n\n                return response, nil // Successful execution\n            }\n        }\n    }\n}\n\nfunc isRetryableError(err error) bool {\n    // Dummy implementation for determining retryable errors\n    return errors.Is(err, someRetryableError)\n}\n\nfunc isUnretryableError(err error) bool {\n    // Dummy implementation for determining unretryable errors\n    return errors.Is(err, someUnretryableError)\n}\n```\n"]}, "kitex-client/middlewares.go-DefaultClientErrorHandler": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefaultClientErrorHandler(ctx context.Context, err error) error {\n# Natural Language Annotations: // DefaultClientErrorHandler is Default ErrorHandler for client\n// when no ErrorHandler is specified with Option `client.WithErrorHandler`, this ErrorHandler will be injected.\n// for thrift\u3001KitexProtobuf, >= v0.4.0 wrap protocol error to TransError, which will be more friendly.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// TransError is a custom error type that wraps protocol errors.\ntype TransError struct {\n\tOriginalError error\n\tMessage       string\n}\n\nfunc (te *TransError) Error() string {\n\treturn fmt.Sprintf(\"TransError: %s - %s\", te.Message, te.OriginalError.Error())\n}\n\n// DefaultClientErrorHandler is the default error handler for the client.\nfunc DefaultClientErrorHandler(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// For thrift and KitexProtobuf, >= v0.4.0, wrap protocol error into TransError\n\tif isProtocolError(err) {\n\t\treturn &TransError{\n\t\t\tOriginalError: err,\n\t\t\tMessage:       \"Protocol Error\",\n\t\t}\n\t}\n\n\t// Return the original error if it's not a protocol error\n\treturn err\n}\n\n// Helper function to determine if an error is a protocol error\nfunc isProtocolError(err error) bool {\n\t// Implement logic to identify protocol errors\n\t// This is a placeholder implementation; adjust criteria as necessary\n\tif errors.Is(err, certainSpecificErrorType) {\n\t\treturn true\n\t}\n\treturn false\n}\n\n// Placeholder for demonstration purposes; replace with actual error types\nvar certainSpecificErrorType = errors.New(\"specific_protocol_error\")\n```"]}, "kitex-client/middlewares.go-ClientErrorHandlerWithAddr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ClientErrorHandlerWithAddr(ctx context.Context, err error) error {\n# Natural Language Annotations: // ClientErrorHandlerWithAddr is ErrorHandler for client, which will add remote addr info into error\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n)\n\n// ClientErrorHandlerWithAddr is an ErrorHandler for the client, which will add remote address info into the error.\nfunc ClientErrorHandlerWithAddr(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\n\t// Extract the remote address from the context\n\tremoteAddr, ok := ctx.Value(\"remoteAddr\").(net.Addr)\n\tif !ok {\n\t\treturn fmt.Errorf(\"error: %v; remote address not found in context\", err)\n\t}\n\n\t// Append the remote address information to the error\n\treturn fmt.Errorf(\"%v; remote address: %v\", err, remoteAddr.String())\n}\n```"]}, "kitex-client/option.go-WithInstanceMW": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithInstanceMW(mw endpoint.Middleware) Option {\n# Natural Language Annotations: // WithInstanceMW adds middleware for client to handle request after service discovery and loadbalance process.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithInstanceMW(mw endpoint.Middleware) Option {\n    return func(o *options) {\n        o.instanceMW = append(o.instanceMW, mw)\n    }\n}\n```"]}, "kitex-client/option.go-WithHostPorts": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithHostPorts(hostports ...string) Option {\n# Natural Language Annotations: // WithHostPorts specifies the target instance addresses when doing service discovery.\n// It overwrites the results from the Resolver.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithHostPorts(hostports ...string) Option {\n    return func(o *options) {\n        o.hostPorts = hostports\n    }\n}\n```"]}, "kitex-client/option.go-WithShortConnection": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithShortConnection() Option {\n# Natural Language Annotations: // WithShortConnection forces kitex to close connection after each call is finished.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithShortConnection() Option {\n    return func(o *options) {\n        o.shortConnection = true\n    }\n}\n```"]}, "kitex-client/option.go-WithLongConnection": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithLongConnection(cfg connpool.IdleConfig) Option {\n# Natural Language Annotations: // WithLongConnection enables long connection with kitex's built-in pooling implementation.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithLongConnection(cfg connpool.IdleConfig) Option {\n    return func(config *Config) {\n        config.UseLongConnection = true\n        config.ConnectionPoolConfig = cfg\n    }\n}\n```\n"]}, "kitex-client/option.go-WithMuxConnection": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMuxConnection(connNum int) Option {\n# Natural Language Annotations: // WithMuxConnection specifies the transport type to be mux.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithMuxConnection(connNum int) Option {\n    return func(o *Options) {\n        o.TransportType = \"mux\"\n        o.ConnectionNumber = connNum\n    }\n}\n```"]}, "kitex-client/option.go-WithTimeoutProvider": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithTimeoutProvider(p rpcinfo.TimeoutProvider) Option {\n# Natural Language Annotations: // WithTimeoutProvider adds a TimeoutProvider to the client.\n// Note that the timeout settings provided by the TimeoutProvider\n// will be applied before the other timeout options in this package\n// and those in the callopt package. Thus it can not modify the\n// timeouts set by WithRPCTimeout or WithConnectTimeout.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithTimeoutProvider(p rpcinfo.TimeoutProvider) Option {\n\treturn func(o *Options) {\n\t\tif o.TimeoutProvider == nil {\n\t\t\to.TimeoutProvider = p\n\t\t}\n\t}\n}\n```\n"]}, "kitex-client/option.go-WithCodec": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithCodec(c remote.Codec) Option {\n# Natural Language Annotations: // WithCodec to set a codec that handle other protocols which not support by kitex\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithCodec(c remote.Codec) Option {\n    return func(o *options) {\n        o.codec = c\n    }\n}\n```"]}, "kitex-client/option.go-WithPayloadCodec": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithPayloadCodec(c remote.PayloadCodec) Option {\n# Natural Language Annotations: // WithPayloadCodec to set a payloadCodec that handle other payload which not support by kitex\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithPayloadCodec(c remote.PayloadCodec) Option {\n    return func(o *Options) {\n        o.customPayloadCodec = c\n    }\n}\n```\n"]}, "kitex-client/option.go-WithConnReporterEnabled": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithConnReporterEnabled() Option {\n# Natural Language Annotations: // WithConnReporterEnabled to enable reporting connection pool stats.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithConnReporterEnabled() Option {\n    return func(options *Options) {\n        options.ConnReporterEnabled = true\n    }\n}\n```"]}, "kitex-client/option.go-WithFailureRetry": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithFailureRetry(p *retry.FailurePolicy) Option {\n# Natural Language Annotations: // WithFailureRetry sets the failure retry policy for client, it will take effect for all methods.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Option is a function that configures a client.\ntype Option func(*Client)\n\n// FailurePolicy defines the retry policy parameters.\ntype FailurePolicy struct {\n    MaxRetries      int\n    RetryDelay      time.Duration\n    ExponentialBackoff bool\n}\n\n// WithFailureRetry sets the failure retry policy for the client,\n// it applies to all methods of the client.\nfunc WithFailureRetry(p *FailurePolicy) Option {\n    return func(c *Client) {\n        c.failurePolicy = p\n    }\n}\n\n// Client represents a client that can be configured with options.\ntype Client struct {\n    failurePolicy *FailurePolicy\n}\n```\n"]}, "kitex-client/option.go-WithBackupRequest": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithBackupRequest(p *retry.BackupPolicy) Option {\n# Natural Language Annotations: // WithBackupRequest sets the backup request policy for client, it will take effect for all methods.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithBackupRequest(p *retry.BackupPolicy) Option {\n    return func(client *Client) {\n        client.backupPolicy = p\n    }\n}\n```"]}, "kitex-client/option.go-WithSpecifiedResultRetry": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithSpecifiedResultRetry(rr *retry.ShouldResultRetry) Option {\n# Natural Language Annotations: // WithSpecifiedResultRetry is used with FailureRetry.\n// When you enable FailureRetry and want to retry with the specified error or response, you can configure this Option.\n// ShouldResultRetry is defined inside retry.FailurePolicy, so WithFailureRetry also can set ShouldResultRetry.\n// But if your retry policy is enabled by remote config, WithSpecifiedResultRetry is useful.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\n// Let's assume an Option type definition exists in your codebase\ntype Option func(*retry.FailurePolicy)\n\n// WithSpecifiedResultRetry is used with FailureRetry.\n// It configures a retry option to retry on specific responses or errors.\nfunc WithSpecifiedResultRetry(rr *retry.ShouldResultRetry) Option {\n\treturn func(fp *retry.FailurePolicy) {\n\t\tfp.ShouldResultRetry = rr\n\t}\n}\n```\n\nThis code defines a function `WithSpecifiedResultRetry` that takes a pointer to `retry.ShouldResultRetry` and returns an `Option` function. When this `Option` is applied, it sets the `ShouldResultRetry` field of the `retry.FailurePolicy` to the provided `rr` function or object, which dictates when a result should trigger a retry. This fits with enabling specific retry behavior if the failure retry policy is controlled remotely, allowing custom configuration at runtime."]}, "kitex-client/option.go-WithGRPCInitialConnWindowSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialConnWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialConnWindowSize sets the value for initial window size on a connection of grpc.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the WithInitialConnWindowSize DialOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype Option func(*Config)\n\ntype Config struct {\n    initialWindowSize uint32\n}\n\n// WithGRPCInitialConnWindowSize sets the value for initial window size on a connection of gRPC.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\nfunc WithGRPCInitialConnWindowSize(s uint32) Option {\n    return func(cfg *Config) {\n        const minWindowSize uint32 = 64 * 1024 // 64K\n        if s >= minWindowSize {\n            cfg.initialWindowSize = s\n        } else {\n            cfg.initialWindowSize = minWindowSize\n        }\n    }\n}\n```\n"]}, "kitex-client/option.go-WithGRPCMaxHeaderListSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxHeaderListSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxHeaderListSize returns a DialOption that specifies the maximum\n// (uncompressed) size of header list that the client is prepared to accept.\n// It corresponds to the WithMaxHeaderListSize DialOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithGRPCMaxHeaderListSize(s uint32) Option {\n    return func(o *DialOptions) {\n        o.MaxHeaderListSize = s\n    }\n}\n```"]}, "kitex-client/option.go-WithGRPCKeepaliveParams": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveParams returns a DialOption that specifies keepalive parameters for the client transport.\n// It corresponds to the WithKeepaliveParams DialOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) Option {\n    return grpc.WithKeepaliveParams(kp)\n}\n```"]}, "kitex-client/option.go-WithWarmingUp": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithWarmingUp(wuo *warmup.ClientOption) Option {\n# Natural Language Annotations: // WithWarmingUp forces the client to do some warm-ups at the end of the initialization.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithWarmingUp(wuo *warmup.ClientOption) Option {\n\treturn func(o *Options) {\n\t\tif wuo != nil {\n\t\t\t// Perform necessary warm-up operations using the warmup.ClientOption\n\t\t\twuo.WarmUp()\n\t\t}\n\t}\n}\n```"]}, "kitex-client/callopt/options.go-WithHostPort": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithHostPort(hostport string) Option {\n# Natural Language Annotations: // WithHostPort specifies the target address for a RPC call.\n// The given address will overwrite the result from Resolver.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithHostPort(hostport string) Option {\n    return func(o *options) {\n        o.targetAddress = hostport\n    }\n}\n```"]}, "kitex-client/callopt/options.go-WithURL": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithURL(url string) Option {\n# Natural Language Annotations: // WithURL specifies the target for a RPC call with url.\n// The given url will be resolved to hostport and overwrites the result from Resolver.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Option is a type alias for a function that configures an RPC client\ntype Option func(*RPCClient)\n\n// WithURL specifies the target for an RPC call with provided URL.\n// The given URL will be resolved to hostport and will overwrite the result from the Resolver.\nfunc WithURL(url string) Option {\n\treturn func(client *RPCClient) {\n\t\t// Assume resolveURL is a function that resolves the URL to a hostport.\n\t\thostport := resolveURL(url) \n\t\t\n\t\t// Set the resolved hostport in the client, overwriting any existing target.\n\t\tclient.target = hostport\n\t}\n}\n\n// Dummy implementation for resolveURL for demonstration purposes\nfunc resolveURL(url string) string {\n\t// Logic to resolve the URL to hostport should be implemented here\n\treturn \"resolved-hostport-from-url\"\n}\n\n// RPCClient is a dummy structure for demonstration purposes\ntype RPCClient struct {\n\ttarget string\n}\n```"]}, "kitex-client/callopt/options.go-WithRPCTimeout": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithRPCTimeout(d time.Duration) Option {\n# Natural Language Annotations: // WithRPCTimeout specifies the RPC timeout for a RPC call.\n// FIXME: callopt.WithRPCTimeout works only when client.WithRPCTimeout or\n// client.WithTimeoutProvider is specified.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"time\"\n\t\"google.golang.org/grpc/callopt\"\n)\n\ntype Option struct {\n\toption func() error\n}\n\nfunc WithRPCTimeout(d time.Duration) Option {\n\treturn Option{\n\t\toption: func() error {\n\t\t\tif client.WithRPCTimeout == nil && client.WithTimeoutProvider == nil {\n\t\t\t\treturn errors.New(\"Must specify either client.WithRPCTimeout or client.WithTimeoutProvider\")\n\t\t\t}\n\t\t\treturn callopt.WithRPCTimeout(d)\n\t\t},\n\t}\n}\n```"]}, "kitex-client/callopt/options.go-WithConnectTimeout": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithConnectTimeout(d time.Duration) Option {\n# Natural Language Annotations: // WithConnectTimeout specifies the connection timeout for a RPC call.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Option represents a configuration option for an RPC client\ntype Option func(*RPCClient)\n\n// RPCClient is a hypothetical struct representing an RPC client\ntype RPCClient struct {\n    connectTimeout time.Duration\n}\n\n// WithConnectTimeout specifies the connection timeout for an RPC call.\nfunc WithConnectTimeout(d time.Duration) Option {\n    return func(client *RPCClient) {\n        client.connectTimeout = d\n    }\n}\n```\n"]}, "kitex-client/callopt/options.go-WithFallback": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithFallback(fb *fallback.Policy) Option {\n# Natural Language Annotations: // WithFallback is used to set the fallback policy for a RPC call.\n// Demos are provided below:\n//\n//\tdemo1. call with fallback for error\n//\t\t`resp, err := cli.Mock(ctx, req, callopt.WithFallback(fallback.ErrorFallback(yourFBFunc))`\n//\tdemo2. call with fallback for error and enable reportAsFallback, which sets reportAsFallback to be true and will do report(metric) as Fallback result\n//\t\t`resp, err := cli.Mock(ctx, req, callopt.WithFallback(fallback.ErrorFallback(yourFBFunc).EnableReportAsFallback())`\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithFallback(fb *fallback.Policy) Option {\n    return func(callOptions *callOptions) {\n        callOptions.fallbackPolicy = fb\n    }\n}\n```"]}, "kitex-server/option_advanced.go-WithServerBasicInfo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithServerBasicInfo(ebi *rpcinfo.EndpointBasicInfo) Option {\n# Natural Language Annotations: // WithServerBasicInfo provides initial information for client endpoint in RPCInfo.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithServerBasicInfo(ebi *rpcinfo.EndpointBasicInfo) Option {\n    return func(r *rpcinfo.RPCInfo) {\n        r.Client.Endpoint = ebi\n    }\n}\n```"]}, "kitex-server/option_advanced.go-WithSupportedTransportsFunc": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithSupportedTransportsFunc(f func(option remote.ServerOption) []string) Option {\n# Natural Language Annotations: // WithSupportedTransportsFunc sets a function which converts supported transports from server option.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Define the remote and Option types and WithSupportedTransportsFunc function as per the signature and annotations.\n\npackage main\n\n// Assume remote package and ServerOption are defined elsewhere\n// For the purpose of this demonstration, define them as types\ntype remote struct{}\ntype ServerOption struct {}\ntype Option struct {}\n\n// WithSupportedTransportsFunc sets a function which converts supported transports from server option.\nfunc WithSupportedTransportsFunc(f func(option ServerOption) []string) Option {\n\t// logic to wrap the function f in an Option\n\t// This is a placeholder and the actual implementation may differ based on how Option is expected to work\n\treturn Option{}\n}\n\nfunc main() {\n\t// Example usage of WithSupportedTransportsFunc\n\topt := WithSupportedTransportsFunc(func(opt ServerOption) []string {\n\t\t// mock logic to return supported transports\n\t\treturn []string{\"HTTP\", \"HTTPS\"}\n\t})\n\n\t// Normally, you'd do something with the opt, e.g., use it in a server setup\n\t_ = opt\n}\n```"]}, "kitex-server/option.go-WithMiddleware": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMiddleware(mw endpoint.Middleware) Option {\n# Natural Language Annotations: // WithMiddleware adds middleware for server to handle request.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithMiddleware(mw endpoint.Middleware) Option {\n    return func(s *Server) {\n        s.middleware = append(s.middleware, mw)\n    }\n}\n```\n"]}, "kitex-server/option.go-WithMiddlewareBuilder": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMiddlewareBuilder(mwb endpoint.MiddlewareBuilder, funcName ...string) Option {\n# Natural Language Annotations: // WithMiddlewareBuilder adds middleware that depend on context for server to handle request\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithMiddlewareBuilder(mwb endpoint.MiddlewareBuilder, funcName ...string) Option {\n\treturn func(server *Server) {\n\t\tfor _, name := range funcName {\n\t\t\tif mw, err := mwb.Build(name); err == nil {\n\t\t\t\tserver.UseMiddleware(mw)\n\t\t\t} else {\n\t\t\t\t// Handle error if middleware cannot be built\n\t\t\t\tlog.Printf(\"Error building middleware for %s: %v\", name, err)\n\t\t\t}\n\t\t}\n\t}\n}\n```"]}, "kitex-server/option.go-WithExitWaitTime": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithExitWaitTime(timeout time.Duration) Option {\n# Natural Language Annotations: // WithExitWaitTime sets the wait duration for graceful shutdown.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"time\"\n)\n\n// Option is a type that represents a configuration function.\ntype Option func(*config)\n\n// config is a placeholder for whatever configuration struct you might have.\ntype config struct {\n\texitWaitTime time.Duration\n}\n\n// WithExitWaitTime sets the wait duration for graceful shutdown.\nfunc WithExitWaitTime(timeout time.Duration) Option {\n\treturn func(cfg *config) {\n\t\tcfg.exitWaitTime = timeout\n\t}\n}\n```"]}, "kitex-server/option.go-WithMaxConnIdleTime": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMaxConnIdleTime(timeout time.Duration) Option {\n# Natural Language Annotations: // WithMaxConnIdleTime sets the max idle time on connection from clients.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Option represents a configuration option for setting max connection idle time.\ntype Option struct {\n    MaxConnIdleTime time.Duration\n}\n\n// WithMaxConnIdleTime sets the maximum idle time for connections coming from clients.\nfunc WithMaxConnIdleTime(timeout time.Duration) Option {\n    return Option{\n        MaxConnIdleTime: timeout,\n    }\n}\n```"]}, "kitex-server/option.go-WithPayloadCodec": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithPayloadCodec(c remote.PayloadCodec) Option {\n# Natural Language Annotations: // WithPayloadCodec to set a payloadCodec that handle other payload which not support by kitex\nPlease only return the code surrounded by ```\n", "response": ["```go\n// WithPayloadCodec to set a payloadCodec that handle other payload which not supported by kitex\nfunc WithPayloadCodec(c remote.PayloadCodec) Option {\n    return func(o *Options) {\n        o.PayloadCodec = c\n    }\n}\n```"]}, "kitex-server/option.go-WithGRPCInitialWindowSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialWindowSize returns a Option that sets window size for stream.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the InitialWindowSize ServerOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithGRPCInitialWindowSize(s uint32) Option {\n    // Define the lower bound for the initial window size\n    const minimumWindowSize uint32 = 64 * 1024 // 64K\n\n    // Ensure the window size is not less than the minimum\n    if s < minimumWindowSize {\n        return nil // or some default Option, or handle the error as per requirement\n    }\n\n    return func(o *serverOptions) {\n        o.initialWindowSize = s\n    }\n}\n```"]}, "kitex-server/option.go-WithGRPCInitialConnWindowSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialConnWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialConnWindowSize returns an Option that sets window size for a connection.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the InitialConnWindowSize ServerOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype Option func(*ServerOptions)\n\ntype ServerOptions struct {\n    initialConnWindowSize uint32\n}\n\nfunc WithGRPCInitialConnWindowSize(s uint32) Option {\n    // Define a constant for the minimum window size\n    const minWindowSize uint32 = 64 * 1024 // 64K\n\n    // Return an Option that sets the initial connection window size, respecting the lower bound\n    return func(opts *ServerOptions) {\n        if s >= minWindowSize {\n            opts.initialConnWindowSize = s\n        }\n    }\n}\n```"]}, "kitex-server/option.go-WithGRPCKeepaliveParams": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveParams(kp grpc.ServerKeepalive) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveParams returns an Option that sets keepalive and max-age parameters for the server.\n// It corresponds to the KeepaliveParams ServerOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithGRPCKeepaliveParams(kp grpc.ServerKeepaliveParams) Option {\n    return func(o *Options) {\n        if o.serverOptions == nil {\n            o.serverOptions = []grpc.ServerOption{}\n        }\n        o.serverOptions = append(o.serverOptions, grpc.KeepaliveParams(kp))\n    }\n}\n```"]}, "kitex-server/option.go-WithGRPCKeepaliveEnforcementPolicy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveEnforcementPolicy(kep grpc.EnforcementPolicy) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveEnforcementPolicy returns an Option that sets keepalive enforcement policy for the server.\n// It corresponds to the KeepaliveEnforcementPolicy ServerOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithGRPCKeepaliveEnforcementPolicy(kep grpc.EnforcementPolicy) Option {\n    return func(o *options) {\n        o.keepaliveEnforcementPolicy = kep\n    }\n}\n```"]}, "kitex-server/option.go-WithGRPCMaxConcurrentStreams": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxConcurrentStreams(n uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxConcurrentStreams returns an Option that will apply a limit on the number\n// of concurrent streams to each ServerTransport.\n// It corresponds to the MaxConcurrentStreams ServerOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Option is a type that usually represents a configuration setting or modifier for some object.\ntype Option func(*ServerConfig)\n\n// ServerConfig represents the server configuration.\ntype ServerConfig struct {\n    maxConcurrentStreams uint32\n}\n\n// WithGRPCMaxConcurrentStreams returns an Option that will apply a limit on the number\n// of concurrent streams to each ServerTransport.\nfunc WithGRPCMaxConcurrentStreams(n uint32) Option {\n    return func(cfg *ServerConfig) {\n        cfg.maxConcurrentStreams = n\n    }\n}\n```\n"]}, "kitex-server/option.go-WithGRPCMaxHeaderListSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxHeaderListSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxHeaderListSize returns a ServerOption that sets the max (uncompressed) size\n// of header list that the server is prepared to accept.\n// It corresponds to the MaxHeaderListSize ServerOption of gRPC.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc WithGRPCMaxHeaderListSize(s uint32) Option {\n\treturn func(o *ServerOptions) {\n\t\to.MaxHeaderListSize = s\n\t}\n}\n```"]}, "kitex-server/genericserver/server.go-NewServerWithServiceInfo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewServerWithServiceInfo(handler generic.Service, g generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n# Natural Language Annotations: // NewServerWithServiceInfo creates a generic server with the given handler, serviceInfo and options.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc NewServerWithServiceInfo(handler generic.Service, g generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n    // Create a new server instance using the provided service info, generic and handler\n    srv := server.New(handler, g)\n\n    // Apply service information to the server\n    if svcInfo != nil {\n        srv.WithServiceInfo(*svcInfo)\n    }\n\n    // Iterate through the provided options and apply each to the server\n    for _, opt := range opts {\n        srv.ApplyOption(opt)\n    }\n\n    // Return the constructed server instance\n    return srv\n}\n```"]}, "weaver-validate.go-validateRegistrations": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func validateRegistrations(regs []*codegen.Registration) error {\n# Natural Language Annotations: // validateRegistrations validates the provided registrations, returning an\n// diagnostic error if they are invalid. Note that some validation is performed\n// by 'weaver generate', but because users can run a Service Weaver app after\n// forgetting to run 'weaver generate', some checks have to be done at runtime.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc validateRegistrations(regs []*codegen.Registration) error {\n    for _, reg := range regs {\n        // Example validation checks:\n        \n        // Check if the registration is nil\n        if reg == nil {\n            return fmt.Errorf(\"registration is nil\")\n        }\n        \n        // Check for required fields in the registration\n        if reg.ServiceName == \"\" {\n            return fmt.Errorf(\"service name is missing in registration\")\n        }\n        \n        if reg.Version == \"\" {\n            return fmt.Errorf(\"version is missing in registration for service: %s\", reg.ServiceName)\n        }\n        \n        // Check if the service is running\n        if !isServiceRunning(reg) {\n            return fmt.Errorf(\"service %s is not running\", reg.ServiceName)\n        }\n        \n        // Any other runtime-specific validations can be added here\n    }\n    return nil\n}\n\n// isServiceRunning is a mock function to demonstrate runtime checks.\n// In a real implementation, add logic to check if the service is properly running.\nfunc isServiceRunning(reg *codegen.Registration) bool {\n    // Placeholder for actual runtime check logic\n    return true\n}\n```\n"]}, "weaver-sim/generators.go-Range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Range(low, high int) Generator[int] {\n# Natural Language Annotations: // Range returns a [Generator] that returns integers equiprobably in the range\n// [low, high). Range panics if low >= high.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// Generator is a function that yields integers.\ntype Generator func() int\n\n// Range returns a Generator that yields integers equiprobably in the range [low, high).\n// It panics if low >= high.\nfunc Range(low, high int) Generator {\n\tif low >= high {\n\t\tpanic(\"low must be less than high\")\n\t}\n\n\trand.Seed(time.Now().UnixNano())\n\n\treturn func() int {\n\t\treturn rand.Intn(high-low) + low\n\t}\n}\n\nfunc main() {\n\tgen := Range(1, 10)\n\n\tfor i := 0; i < 5; i++ {\n\t\tfmt.Println(gen())\n\t}\n}\n```\n"]}, "weaver-sim/generators.go-String": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func String() Generator[string] {\n# Natural Language Annotations: // Strings\n// String returns a [Generator] that returns moderately sized readable strings,\n// with a bias towards smaller strings.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc String() Generator[string] {\n\trand.Seed(time.Now().UnixNano())\n\tletters := []rune(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\treturn func() string {\n\t\tsize := rand.Intn(8) + 3 // Bias towards smaller strings, length between 3 and 10\n\t\trunes := make([]rune, size)\n\t\tfor i := range runes {\n\t\t\trunes[i] = letters[rand.Intn(len(letters))]\n\t\t}\n\t\treturn string(runes)\n\t}\n}\n\n// Generator is a type definition for a function that generates strings.\ntype Generator[T any] func() T\n```"]}, "weaver-sim/generators.go-OneOf": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OneOf[T any](xs ...T) Generator[T] {\n# Natural Language Annotations: // Combinators\n// OneOf returns a [Generator] that returns one of the provided values\n// equiprobably. OneOf panics if no values are provided.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// Generator is a function that returns a value of type T.\ntype Generator[T any] func() T\n\n// OneOf returns a Generator that returns one of the provided values equiprobably.\n// OneOf panics if no values are provided.\nfunc OneOf[T any](xs ...T) Generator[T] {\n\tif len(xs) == 0 {\n\t\tpanic(\"OneOf requires at least one value\")\n\t}\n\t\n\trand.Seed(time.Now().UnixNano())\n\t\n\treturn func() T {\n\t\tindex := rand.Intn(len(xs))\n\t\treturn xs[index]\n\t}\n}\n\nfunc main() {\n\t// Example usage:\n\tgen := OneOf(1, 2, 3, 4, 5)\n\t\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(gen())\n\t}\n}\n```"]}, "weaver-sim/generators.go-Weight": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Weight[T any](choices []Weighted[T]) Generator[T] {\n# Natural Language Annotations: // Weight returns a [Generator] that generates values using the provided\n// generators. A generator is chosen with probability proportional to its\n// weight. For example, given the following choices:\n//\n//   - Weighted{1.0, OneOf(\"a\")}\n//   - Weighted{2.0, OneOf(\"b\")}\n//\n// Weight returns \"b\" twice as often as it returns \"a\". Note that the provided\n// weights do not have to sum to 1.\n//\n// Weight panics if no choices are provided, if any weight is negative, or if\n// the sum of all weight is 0.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"errors\"\n\t\"math/rand\"\n\t\"time\"\n)\n\n// Weighted is a struct that defines a weighted generator\ntype Weighted[T any] struct {\n\tWeight    float64\n\tGenerator Generator[T]\n}\n\n// Generator is a type alias for a function that returns a value of type T\ntype Generator[T any] func() T\n\n// Weight returns a generator that generates values using the provided generators\n// A generator is chosen with probability proportional to its weight\nfunc Weight[T any](choices []Weighted[T]) Generator[T] {\n\tif len(choices) == 0 {\n\t\tpanic(\"no choices provided\")\n\t}\n\n\ttotalWeight := 0.0\n\tfor _, choice := range choices {\n\t\tif choice.Weight < 0 {\n\t\t\tpanic(\"negative weight is not allowed\")\n\t\t}\n\t\ttotalWeight += choice.Weight\n\t}\n\n\tif totalWeight == 0 {\n\t\tpanic(\"sum of weights cannot be zero\")\n\t}\n\n\t// Seed the random number generator\n\trand.Seed(time.Now().UnixNano())\n\n\treturn func() T {\n\t\tr := rand.Float64() * totalWeight\n\t\taccum := 0.0\n\t\tfor _, choice := range choices {\n\t\t\taccum += choice.Weight\n\t\t\tif r < accum {\n\t\t\t\treturn choice.Generator()\n\t\t\t}\n\t\t}\n\t\t// should never reach here if logic is correct\n\t\tpanic(errors.New(\"unreachable code reached\"))\n\t}\n}\n```"]}, "weaver-sim/rand.go-pick": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func pick[T any](r *rand.Rand, xs []T) T {\n# Natural Language Annotations: // pick returns a randomly selected element from the provided slice. pick\n// panics if the provided slice is empty.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"math/rand\"\n)\n\nfunc pick[T any](r *rand.Rand, xs []T) T {\n\tif len(xs) == 0 {\n\t\tpanic(\"the provided slice is empty\")\n\t}\n\treturn xs[r.Intn(len(xs))]\n}\n```"]}, "weaver-sim/rand.go-remove": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (i *ints) remove(x int) {\n# Natural Language Annotations: // remove removes the provided element from the set. remove is a noop if the\n// provided element is not in the set.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\n// Define a new type based on a slice of ints\ntype ints []int\n\n// Method to remove an element from the ints slice\nfunc (i *ints) remove(x int) {\n    // Create a new slice to hold the result\n    var result []int\n\n    // Iterate over the elements of the original slice\n    for _, val := range *i {\n        // If the current element is not the one to remove, add it to the result\n        if val != x {\n            result = append(result, val)\n        }\n    }\n\n    // Update the original slice to reflect the elements which do not include the element to remove\n    *i = result\n}\n\nfunc main() {\n    // Example usage\n    nums := ints{1, 2, 3, 4, 3}\n    nums.remove(3)\n    // Print the slice after removing\n    fmt.Println(nums) // Output: [1 2 4]\n}\n```\nNote: Ensure that the main function and the fmt package's usage are part of your implementation environment when you test the `remove` method, as they are included here for demonstration purposes."]}, "weaver-runtime/config.go-ParseConfig": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseConfig(file string, input string, sectionValidator func(string, string) error) (*protos.AppConfig, error) {\n# Natural Language Annotations: // ParseConfig parses the specified configuration input, which should\n// hold a set of sections in TOML format from the specified file.\n// The section corresponding to the common Service Weaver application\n// configuration is parsed and returned as a *AppConfig.\n//\n// sectionValidator(key, val) is used to validate every section config entry.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"github.com/pelletier/go-toml\"\n\t\"errors\"\n)\n\n// Assuming protos and AppConfig are defined elsewhere in the codebase\n// For demonstration purposes, let's consider the structure as follows:\npackage protos\n\ntype AppConfig struct {\n\t// Define your fields here based on the expected structure\n}\n\nimport (\n\t\"os\"\n\n\t\"github.com/pelletier/go-toml\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"github.com/yourorg/protos\"\n)\n\nfunc ParseConfig(file string, input string, sectionValidator func(string, string) error) (*protos.AppConfig, error) {\n\t// Read the TOML file\n\tconfigData, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the TOML data\n\ttomlTree, err := toml.LoadBytes(configData)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Assume input is the section name we need to work with\n\tsection := tomlTree.Get(input)\n\tif section == nil {\n\t\treturn nil, errors.New(\"specified section not found in configuration\")\n\t}\n\n\t// Convert section to a map for validation\n\tsectionMap, ok := section.(map[string]interface{})\n\tif !ok {\n\t\treturn nil, errors.New(\"failed to convert section to expected format\")\n\t}\n\n\t// Validate each entry in the section\n\tfor key, val := range sectionMap {\n\t\tvalStr := fmt.Sprintf(\"%v\", val)\n\t\tif err := sectionValidator(key, valStr); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Convert the section to *AppConfig\n\t// This step assumes that you have some method of converting a map to AppConfig\n\tappConfig := &protos.AppConfig{}\n\t// Fill in the appConfig fields based on your application's requirements\n\n\treturn appConfig, nil\n}\n```\n"]}, "weaver-runtime/traces/db.go-OpenDB": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OpenDB(ctx context.Context, fname string) (*DB, error) {\n# Natural Language Annotations: // OpenDB opens the trace database persisted in the provided file. If the\n// file doesn't exist, this call creates it.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"database/sql\"\n\t\"fmt\"\n\t\"os\"\n\n\t_ \"github.com/mattn/go-sqlite3\"\n)\n\n// DB is a placeholder for a database interface.\ntype DB struct {\n\t*sql.DB\n}\n\n// OpenDB opens the trace database persisted in the provided file. If the\n// file doesn't exist, this call creates it.\nfunc OpenDB(ctx context.Context, fname string) (*DB, error) {\n\t// Check if file exists, if not, create an empty file\n\tif _, err := os.Stat(fname); os.IsNotExist(err) {\n\t\tfile, err := os.Create(fname)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to create file: %w\", err)\n\t\t}\n\t\tfile.Close()\n\t}\n\n\t// Open the database\n\tdb, err := sql.Open(\"sqlite3\", fname)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to open database: %w\", err)\n\t}\n\n\t// Return the database wrapper\n\treturn &DB{db}, nil\n}\n```"]}, "weaver-runtime/traces/db.go-QueryTraces": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n# Natural Language Annotations: // QueryTraces returns the summaries of the traces that match the given\n// query arguments, namely:\n//   - That have been generated by the given application version.\n//   - That fit entirely in the given [startTime, endTime] time interval.\n//   - Whose duration is in the given [durationLower, durationUpper) range.\n//   - Who have an error status.\n//   - Who are in the most recent limit of trace spans.\n//\n// Any query argument that has a zero value (e.g., empty app or version,\n// zero endTime) is ignored, i.e., it matches all spans.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"time\"\n)\n\n// TraceSummary is a stub representing a summary of a trace.\ntype TraceSummary struct {\n\tID        string\n\tApp       string\n\tVersion   string\n\tStartTime time.Time\n\tEndTime   time.Time\n\tDuration  time.Duration\n\tError     bool\n}\n\n// DB is a mock database structure with a method to get traces.\ntype DB struct{}\n\nfunc (d *DB) getAllTraces() []TraceSummary {\n\t// This is a stub. Replace with actual database query to fetch traces.\n\treturn []TraceSummary{}\n}\n\nfunc (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n\tallTraces := d.getAllTraces()\n\tvar result []TraceSummary\n\n\tfor _, trace := range allTraces {\n\t\tif app != \"\" && trace.App != app {\n\t\t\tcontinue\n\t\t}\n\t\tif version != \"\" && trace.Version != version {\n\t\t\tcontinue\n\t\t}\n\t\tif !startTime.IsZero() && trace.StartTime.Before(startTime) {\n\t\t\tcontinue\n\t\t}\n\t\tif !endTime.IsZero() && trace.EndTime.After(endTime) {\n\t\t\tcontinue\n\t\t}\n\t\tif durationLower > 0 && trace.Duration < durationLower {\n\t\t\tcontinue\n\t\t}\n\t\tif durationUpper > 0 && trace.Duration >= durationUpper {\n\t\t\tcontinue\n\t\t}\n\t\tif onlyErrors && !trace.Error {\n\t\t\tcontinue\n\t\t}\n\n\t\tresult = append(result, trace)\n\t\tif limit > 0 && int64(len(result)) >= limit {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif len(result) == 0 {\n\t\treturn nil, errors.New(\"no matching traces found\")\n\t}\n\n\treturn result, nil\n}\n```"]}, "weaver-runtime/retry/retry.go-Continue": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r *Retry) Continue(ctx context.Context) bool {\n# Natural Language Annotations: // Continue sleeps for an exponentially increasing interval (with jitter). It\n// stops its sleep early and returns false if context becomes done. If the\n// return value is false, ctx.Err() is guaranteed to be non-nil. The first\n// call does not sleep.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (r *Retry) Continue(ctx context.Context) bool {\n    // If this is the first call, the function should return true immediately without sleeping\n    if r.attempt == 0 {\n        r.attempt++\n        return true\n    }\n\n    // Calculate exponential backoff with jitter\n    delay := r.baseDelay * (1 << (r.attempt - 1)) // Exponential calculation\n    jitter := delay / 2 // Half jitter\n    delayWithJitter := delay + time.Duration(rand.Int63n(int64(jitter))) - jitter\n\n    // Create a new context with the delay\n    timeoutCtx, cancel := context.WithTimeout(ctx, delayWithJitter)\n    defer cancel()\n\n    // Wait for one of the contexts to be done\n    select {\n    case <-timeoutCtx.Done(): // The sleep time is over, continue retrying\n        r.attempt++\n        return true\n    case <-ctx.Done(): // The main context is done, stop retrying\n        return false\n    }\n}\n\ntype Retry struct {\n    baseDelay time.Duration // base delay duration\n    attempt   int           // current attempt count\n}\n```\n\nPlease ensure the `Retry` struct is declared and initialized appropriately in your broader application code, and that `context` and `time` packages are imported. This implementation provides an exponential backoff strategy with jitter, handling the immediate return on the first call and respecting the context's cancellation to abort retries early if needed."]}, "weaver-runtime/colors/tabularizer.go-Row": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *Tabularizer) Row(values ...any) {\n# Natural Language Annotations: // Row buffers a new Row to be tabularized. The Row isn't written until Flush\n// is called. Note that every Row reported to a tabularizer must be the same\n// length. A value can be a text, atom, string, or fmt.Stringer.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage tabularizer\n\nimport (\n    \"fmt\"\n)\n\n// Tabularizer represents the structure that holds rows to be tabularized.\ntype Tabularizer struct {\n    rows    [][]any  // to store buffered rows\n    colCount int     // to enforce consistent row length\n    flushed  bool    // to indicate if flush has been called\n}\n\n// NewTabularizer initializes a new Tabularizer instance.\nfunc NewTabularizer(numCols int) *Tabularizer {\n    return &Tabularizer{\n        rows:    make([][]any, 0),\n        colCount: numCols,\n    }\n}\n\n// Row buffers a new row to be tabularized. The Row isn't written until Flush\n// is called. Note that every Row reported to a tabularizer must be the same\n// length. A value can be a text, atom, string, or fmt.Stringer.\nfunc (t *Tabularizer) Row(values ...any) {\n    if t.flushed {\n        panic(\"cannot add rows after flush is called\")\n    }\n\n    if len(values) != t.colCount {\n        panic(fmt.Sprintf(\"row length %d does not match expected length %d\", len(values), t.colCount))\n    }\n\n    for _, value := range values {\n        if _, ok := value.(fmt.Stringer); !ok {\n            switch value.(type) {\n            case string, int, float64, bool:\n                // allowed types\n            default:\n                panic(fmt.Sprintf(\"unsupported value type: %T\", value))\n            }\n        }\n    }\n\n    t.rows = append(t.rows, values)\n}\n\n// Flush would typically write out buffered rows to a destination.\nfunc (t *Tabularizer) Flush() {\n    // Implementation of flush logic\n    t.flushed = true\n    // Example: Print the buffered rows as tabularized output\n    for _, row := range t.rows {\n        for _, column := range row {\n            if str, ok := column.(fmt.Stringer); ok {\n                fmt.Print(str.String(), \"\\t\")\n            } else {\n                fmt.Print(column, \"\\t\")\n            }\n        }\n        fmt.Println()\n    }\n    t.rows = make([][]any, 0) // clear the buffer\n}\n```\n"]}, "weaver-runtime/colors/tabularizer.go-Flush": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *Tabularizer) Flush() {\n# Natural Language Annotations: // Flush writes all buffered rows. Flush should only be called once, after all\n// rows have been written.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (t *Tabularizer) Flush() {\n    // Check if there are any buffered rows to write\n    if len(t.bufferedRows) > 0 {\n        // Write all buffered rows to the desired output\n        for _, row := range t.bufferedRows {\n            t.output.Write(row)\n        }\n        \n        // Clear the buffered rows since they have been written\n        t.bufferedRows = nil\n    }\n\n    // Marking that flush has been called to avoid any future calls\n    t.isFlushed = true\n}\n```"]}, "weaver-runtime/protomsg/io.go-Write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Write(dst io.Writer, msg proto.Message) error {\n# Natural Language Annotations: // Write writes a length prefixed protobuf to dst. Use Read to read it.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"encoding/binary\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"io\"\n)\n\nfunc Write(dst io.Writer, msg proto.Message) error {\n\t// Marshal the message into protocol buffer bytes\n\tdata, err := proto.Marshal(msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Get the length of the data\n\tlength := uint32(len(data))\n\n\t// Write the length in a prefixed format\n\tif err := binary.Write(dst, binary.BigEndian, length); err != nil {\n\t\treturn err\n\t}\n\n\t// Write the actual data to the destination writer\n\t_, err = dst.Write(data)\n\treturn err\n}\n```"]}, "weaver-runtime/bin/bin.go-ReadComponentGraph": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadComponentGraph(file string) ([]string, graph.Graph, error) {\n# Natural Language Annotations: // ReadComponentGraph reads component graph information from the specified\n// binary. It returns a slice of components and a component graph whose nodes\n// are indices into that slice.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"github.com/yourusername/graph\" // Replace with actual import path for your graph package\n)\n\n// ReadComponentGraph reads component graph information from the specified\n// file. It returns a slice of components and a component graph whose nodes\n// are indices into that slice.\nfunc ReadComponentGraph(file string) ([]string, graph.Graph, error) {\n\t// Open the file\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer f.Close()\n\n\t// Create a scanner to read the file content\n\tscanner := bufio.NewScanner(f)\n\n\tvar components []string\n\tcomponentIndexMap := make(map[string]int)\n\tg := graph.NewGraph() // Assume NewGraph initializes the graph structure\n\n\tfor scanner.Scan() {\n\t\t// Read each line\n\t\tline := scanner.Text()\n\n\t\t// Assuming the format: component1 component2 ... componentN\n\t\tparts := strings.Fields(line)\n\n\t\t// Verify there are at least two components to form an edge\n\t\tif len(parts) < 2 {\n\t\t\treturn nil, nil, errors.New(\"invalid format in input file\")\n\t\t}\n\n\t\t// Ensure all components are indexed\n\t\tfor _, comp := range parts {\n\t\t\tif _, exists := componentIndexMap[comp]; !exists {\n\t\t\t\tcomponentIndexMap[comp] = len(components)\n\t\t\t\tcomponents = append(components, comp)\n\t\t\t}\n\t\t}\n\n\t\t// Add edges between the first component to all others in the same line\n\t\tsrcIndex := componentIndexMap[parts[0]]\n\t\tfor _, comp := range parts[1:] {\n\t\t\tdestIndex := componentIndexMap[comp]\n\t\t\tg.AddEdge(srcIndex, destIndex)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn components, g, nil\n}\n```"]}, "weaver-runtime/bin/bin.go-ReadListeners": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadListeners(file string) ([]codegen.ComponentListeners, error) {\n# Natural Language Annotations: // ReadListeners reads the sets of listeners associated with each component\n// in the specified binary.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\n// ComponentListeners represents a structure to hold listeners associated with a component\ntype ComponentListeners struct {\n\tComponentName string   `json:\"component_name\"`\n\tListeners     []string `json:\"listeners\"`\n}\n\n// ReadListeners reads the sets of listeners associated with each component\n// in the specified binary JSON file.\nfunc ReadListeners(file string) ([]ComponentListeners, error) {\n\t// Check if the file exists\n\tif _, err := os.Stat(file); os.IsNotExist(err) {\n\t\treturn nil, errors.New(\"file does not exist\")\n\t}\n\n\t// Read the contents of the file\n\tfileContents, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the JSON data\n\tvar listeners []ComponentListeners\n\terr = json.Unmarshal(fileContents, &listeners)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn listeners, nil\n}\n```"]}, "weaver-runtime/bin/bin.go-ReadVersions": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadVersions(filename string) (Versions, error) {\n# Natural Language Annotations: // ReadVersions reads the module version and deployer API version from the\n// specified binary.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"bytes\"\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"os\"\n)\n\n// Versions is a struct to hold the module version and deployer API version\ntype Versions struct {\n\tModuleVersion   uint32\n\tDeployerAPIVersion uint32\n}\n\n// ReadVersions reads the module version and deployer API version from the specified binary.\nfunc ReadVersions(filename string) (Versions, error) {\n\t// Open the binary file\n\tfile, err := os.Open(filename)\n\tif err != nil {\n\t\treturn Versions{}, err\n\t}\n\tdefer file.Close()\n\n\t// Read the bytes from the binary file\n\tbuffer := make([]byte, 8) // Assuming each version is stored as a uint32\n\t_, err = file.Read(buffer)\n\tif err != nil {\n\t\treturn Versions{}, err\n\t}\n\n\t// Use a bytes buffer to decode the uint32 values\n\tbuf := bytes.NewReader(buffer)\n\n\tvar moduleVersion, deployerAPIVersion uint32\n\n\t// Read the module version\n\terr = binary.Read(buf, binary.LittleEndian, &moduleVersion)\n\tif err != nil {\n\t\treturn Versions{}, err\n\t}\n\n\t// Read the deployer API version\n\terr = binary.Read(buf, binary.LittleEndian, &deployerAPIVersion)\n\tif err != nil {\n\t\treturn Versions{}, err\n\t}\n\n\t// Return the versions\n\treturn Versions{\n\t\tModuleVersion:      moduleVersion,\n\t\tDeployerAPIVersion: deployerAPIVersion,\n\t}, nil\n}\n```"]}, "weaver-runtime/prometheus/prometheus.go-TranslateMetricsToPrometheusTextFormat": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*metrics.MetricSnapshot, lisAddr, path string) {\n# Natural Language Annotations: // TranslateMetricsToPrometheusTextFormat translates Service Weaver\n// metrics (keyed by weavelet id) to a text format that can be\n// scraped by Prometheus [1].\n//\n// [1] https://prometheus.io/\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"metrics\" // Assuming this is the import path for MetricSnapshot\n)\n\n// TranslateMetricsToPrometheusTextFormat translates Service Weaver\n// metrics (keyed by weavelet id) to a text format that can be\n// scraped by Prometheus.\nfunc TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*metrics.MetricSnapshot, lisAddr, path string) {\n\t// Iterate over each metric snapshot to convert its data into Prometheus text format\n\tfor _, snapshot := range ms {\n\t\t// Construct the metric name and labels assuming they exist within the snapshot\n\t\tmetricName := sanitizeMetricName(snapshot.Name)\n\t\tfor _, labelSet := range snapshot.Data {\n\t\t\t// Extract labels and values, sanitize if necessary\n\t\t\tlabels := make([]string, 0, len(labelSet.Labels))\n\t\t\tfor k, v := range labelSet.Labels {\n\t\t\t\tlabels = append(labels, fmt.Sprintf(`%s=\"%s\"`, sanitizeLabelName(k), v))\n\t\t\t}\n\t\t\tlabelStr := strings.Join(labels, \",\")\n\n\t\t\t// Format the metric in Prometheus text format\n\t\t\tif labelStr != \"\" {\n\t\t\t\tlabelStr = \"{\" + labelStr + \"}\"\n\t\t\t}\n\t\t\tfmt.Fprintf(w, \"%s%s %v\\n\", metricName, labelStr, labelSet.Value)\n\t\t}\n\t}\n}\n\n// sanitizeMetricName ensures the metric name conforms to the Prometheus naming convention\nfunc sanitizeMetricName(name string) string {\n\treturn strings.ReplaceAll(name, \" \", \"_\")\n}\n\n// sanitizeLabelName ensures the label name conforms to the Prometheus naming conventions\nfunc sanitizeLabelName(name string) string {\n\treturn strings.ReplaceAll(name, \" \", \"_\")\n}\n```\n"]}, "weaver-runtime/codegen/graph.go-ExtractEdges": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ExtractEdges(data []byte) [][2]string {\n# Natural Language Annotations: // ExtractEdges returns the edges corresponding to MakeEdgeString() results\n// that occur in data.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"regexp\"\n)\n\nfunc ExtractEdges(data []byte) [][2]string {\n\t// Define the pattern for extracting \"MakeEdgeString()\" results\n\t// Assuming the function MakeEdgeString outputs edges in a format like \"(node1,node2)\"\n\t// The regex below matches patterns like \"(node1,node2)\"\n\tpattern := `\\(([^,]+),([^,]+)\\)`\n\tre := regexp.MustCompile(pattern)\n\n\tmatches := re.FindAllSubmatch(data, -1)\n\n\tvar edges [][2]string\n\tfor _, match := range matches {\n\t\tif len(match) == 3 { // match[0] is the whole match, match[1] is the first group, match[2] is the second\n\t\t\tedges = append(edges, [2]string{string(match[1]), string(match[2])})\n\t\t}\n\t}\n\n\treturn edges\n}\n```"]}, "weaver-runtime/codegen/registry.go-ComponentConfigValidator": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ComponentConfigValidator(path, cfg string) error {\n# Natural Language Annotations: // ComponentConfigValidator checks that cfg is a valid configuration\n// for the component type whose fully qualified name is given by path.\n//\n// TODO(mwhittaker): Move out of codegen package? It's not used by the\n// generated code.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage yourpackage\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\nfunc ComponentConfigValidator(path, cfg string) error {\n\t// Check if path is fully qualified, i.e., it contains '.' character\n\tif !strings.Contains(path, \".\") {\n\t\treturn errors.New(\"invalid path: path should be fully qualified and contain at least one dot\")\n\t}\n\n\t// Validate that cfg is not empty\n\tif cfg == \"\" {\n\t\treturn errors.New(\"invalid configuration: configuration should not be empty\")\n\t}\n\n\t// Add more specific checks for cfg based on the component type identified by path\n\t// This is a placeholder for validations specific to the component\n\t// type that should be implemented based on your application logic.\n\n\t// Assuming cfg is a JSON string and requires JSON format validation\n\t// var jsonCfg map[string]interface{}\n\t// if err := json.Unmarshal([]byte(cfg), &jsonCfg); err != nil {\n\t// \treturn errors.New(\"invalid configuration: should be a valid JSON\")\n\t// }\n\n\t// Add additional validation logic as needed\n\n\t// If the configuration and the path are validated, return nil\n\treturn nil\n}\n```\n\nThis provided implementation performs initial checks to ensure the `path` is fully qualified and the `cfg` is not an empty string. The next steps would be to customize validation according to the specifics of how `cfg` should be formatted for the given `path`, which could often involve more detailed checks such as format validation (e.g., JSON)."]}, "weaver-runtime/codegen/registry.go-CallGraph": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CallGraph() []CallEdge {\n# Natural Language Annotations: // CallGraph returns the component call graph (as a list of CallEdge values).\nPlease only return the code surrounded by ```\n", "response": ["```\ntype CallEdge struct {\n\tFrom string\n\tTo   string\n}\n\n// CallGraph returns the component call graph as a list of CallEdge values.\nfunc CallGraph() []CallEdge {\n\t// Example call graph as an adjacency list representation\n\tadjacencyList := map[string][]string{\n\t\t\"A\": {\"B\", \"C\"},\n\t\t\"B\": {\"D\"},\n\t\t\"C\": {\"D\", \"E\"},\n\t\t\"D\": {\"F\"},\n\t\t\"E\": {},\n\t\t\"F\": {},\n\t}\n\n\tvar callEdges []CallEdge\n\n\t// Construct the call edges from the adjacency list\n\tfor from, targets := range adjacencyList {\n\t\tfor _, to := range targets {\n\t\t\tcallEdges = append(callEdges, CallEdge{From: from, To: to})\n\t\t}\n\t}\n\n\treturn callEdges\n}\n```"]}, "weaver-runtime/codegen/listeners.go-MakeListenersString": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MakeListenersString(component string, listeners []string) string {\n# Natural Language Annotations: // All listeners used by a given component are embedded in the generated\n// binary as specially formatted strings. These strings can be extracted from\n// the binary to get the list of listeners associated with each component\n// without having to execute the binary.\n//\n// The set of listeners used by a given component is represented by a string\n// fragment that looks like:\n// \u27e6checksum:wEaVeRlIsTeNeRs:component\u2192listeners\u27e7\n//\n// checksum is the first 8 bytes of the hex encoding of the SHA-256 of\n// the string \"wEaVeRlIsTeNeRs:component\u2192listeners\"; component is the fully\n// qualified component type name; listeners is a comma-separated list of\n// all listener names associated with a given component.\n// MakeListenersString returns a string that should be emitted into generated\n// code to represent the set of listeners associated with a given component.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\n// MakeListenersString generates a specially formatted string for a component and its listeners\nfunc MakeListenersString(component string, listeners []string) string {\n\t// Join listeners into a comma-separated string\n\tlistenersStr := \"\"\n\tif len(listeners) > 0 {\n\t\tlistenersStr = listeners[0]\n\t\tfor _, listener := range listeners[1:] {\n\t\t\tlistenersStr += \",\" + listener\n\t\t}\n\t}\n\n\t// Construct the full string for the checksum\n\tfullStr := fmt.Sprintf(\"wEaVeRlIsTeNeRs:%s\u2192%s\", component, listenersStr)\n\n\t// Compute the SHA-256 checksum of the full string\n\tsum := sha256.Sum256([]byte(fullStr))\n\n\t// Get the first 8 bytes of the checksum as a hex string\n\tchecksum := hex.EncodeToString(sum[:])[:8]\n\n\t// Format the required string\n\tresult := fmt.Sprintf(\"\u27e6%s:wEaVeRlIsTeNeRs:%s\u2192%s\u27e7\", checksum, component, listenersStr)\n\n\treturn result\n}\n```"]}, "weaver-runtime/codegen/listeners.go-ExtractListeners": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ExtractListeners(data []byte) []ComponentListeners {\n# Natural Language Annotations: // ExtractListeners returns the components and their listeners encoded using\n// MakeListenersString() in data.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// Assuming the structure of ComponentListeners and a potential MakeListenersString function based on the given context\ntype ComponentListeners struct {\n\tComponent string\n\tListeners []string\n}\n\n// MakeListenersString may look something like this, although this is just a guess based on the context\nfunc MakeListenersString(components []ComponentListeners) string {\n\tbytes, _ := json.Marshal(components) // encoding as JSON string\n\treturn string(bytes)\n}\n\n// ExtractListeners extracts the components and their listeners encoded using\n// MakeListenersString() in data.\nfunc ExtractListeners(data []byte) []ComponentListeners {\n\tvar components []ComponentListeners\n\n\t// Attempt to unmarshal the data\n\terr := json.Unmarshal(data, &components)\n\tif err != nil {\n\t\t// Returning an empty slice if there\u2019s an error\n\t\tfmt.Println(\"Error while decoding:\", err.Error())\n\t\treturn []ComponentListeners{}\n\t}\n\n\treturn components\n}\n\n// Example testing in a main function\nfunc main() {\n\t// Example data\n\texampleData := `[{\"Component\": \"Engine\", \"Listeners\": [\"FuelPump\", \"IgnitionSystem\"]}, {\"Component\": \"Brakes\", \"Listeners\": [\"Hydraulics\", \"PadWearSensor\"]}]`\n\tcomponents := ExtractListeners([]byte(exampleData))\n\n\tfor _, component := range components {\n\t\tfmt.Printf(\"Component: %s, Listeners: %v\\n\", component.Component, component.Listeners)\n\t}\n}\n```\n"]}, "weaver-runtime/codegen/hash.go-Sum64": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (h *Hasher) Sum64() uint64 {\n# Natural Language Annotations: // Sum64 returns the 64-bit hash of the sequence of values added so far.\n// The resulting is in the range [1,2^64-2], i.e., it is never 0 or math.MaxUint64.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (h *Hasher) Sum64() uint64 {\n    // Start with a fixed seed value, could be any non-zero value less than MaxUint64\n    const Seed uint64 = 1\n    hash := Seed\n    \n    // Example of processing the internal state to compute the hash\n    for _, value := range h.values {\n        // A simple example of mixing function, replace with an appropriate hash function\n        hash = hash*31 + uint64(value)\n    }\n\n    // Ensure that the result is not 0 or MaxUint64\n    if hash == 0 {\n        hash = 1\n    } else if hash == ^uint64(0) { // ^uint64(0) means all bits 1, which is MaxUint64\n        hash = ^uint64(0) - 1 // MaxUint64 - 1\n    }\n\n    return hash\n}\n```"]}, "weaver-runtime/graph/adjacency.go-NewAdjacencyGraph": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n# Natural Language Annotations: // NewAdjacencyGraph returns a Graph represented using adjacency lists.\n//\n// It panics if it specified edge nodes aren't in nodes.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype Node struct {\n    ID int\n}\n\ntype Edge struct {\n    From Node\n    To   Node\n}\n\ntype Graph struct {\n    adjacencyList map[int][]int\n}\n\nfunc NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n    nodeSet := make(map[int]bool)\n    for _, node := range nodes {\n        nodeSet[node.ID] = true\n    }\n\n    adjacencyList := make(map[int][]int)\n    for _, node := range nodes {\n        adjacencyList[node.ID] = []int{}\n    }\n\n    for _, edge := range edges {\n        if !nodeSet[edge.From.ID] || !nodeSet[edge.To.ID] {\n            panic(\"specified edge nodes aren't in nodes\")\n        }\n        adjacencyList[edge.From.ID] = append(adjacencyList[edge.From.ID], edge.To.ID)\n    }\n\n    return Graph{adjacencyList: adjacencyList}\n}\n```"]}, "weaver-runtime/graph/dfs.go-DFSAll": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DFSAll(g Graph, enter, exit func(Node)) {\n# Natural Language Annotations: // DFSAll performs a depth first search of all nodes in g.\n// If enter is non-nil, it is called on entry to a node.\n// If exit is non-nil, it is called on exit from a node.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main \n\ntype Node interface{}\n\ntype Graph interface {\n    // Nodes should return all nodes in the graph\n    Nodes() []Node\n\n    // Successors should return all successor nodes of the given node\n    Successors(node Node) []Node\n}\n\nfunc DFSAll(g Graph, enter, exit func(Node)) {\n    visited := make(map[Node]bool) // to keep track of visited nodes\n\n    // helper function to perform DFS on a node recursively\n    var dfs func(node Node)\n    dfs = func(node Node) {\n        // mark the node as visited\n        if visited[node] {\n            return\n        }\n        visited[node] = true\n\n        // call the enter function if it's non-nil\n        if enter != nil {\n            enter(node)\n        }\n\n        // visit all the successors/neighbors of the node\n        for _, successor := range g.Successors(node) {\n            if !visited[successor] {\n                dfs(successor)\n            }\n        }\n\n        // call the exit function if it's non-nil\n        if exit != nil {\n            exit(node)\n        }\n    }\n\n    // execute DFS for each unvisited node in the graph\n    for _, node := range g.Nodes() {\n        if !visited[node] {\n            dfs(node)\n        }\n    }\n}\n```"]}, "weaver-runtime/metrics/labels.go-newLabelExtractor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func newLabelExtractor[L comparable]() *labelExtractor[L] {\n# Natural Language Annotations: // newLabelExtractor returns a new labelExtractor that can extract the labels\n// from a label struct of type L. L must be a valid label struct type.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport \"reflect\"\n\n// labelExtractor is a structure that will hold functions/behavior for extracting labels from a given struct type L.\ntype labelExtractor[L comparable] struct {\n\textractLabelsFunc func(L) []string\n}\n\n// newLabelExtractor returns a new labelExtractor that can extract the labels from a label struct of type L.\n// L must be a valid label struct type, and this function assumes labels are string properties of L.\n// The returned labelExtractor is built using reflection to extract labels.\nfunc newLabelExtractor[L comparable]() *labelExtractor[L] {\n\textractor := &labelExtractor[L]{\n\t\textractLabelsFunc: func(labelStruct L) []string {\n\t\t\tvar labels []string\n\t\t\t\n\t\t\tv := reflect.ValueOf(labelStruct)\n\t\t\tt := reflect.TypeOf(labelStruct)\n\n\t\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\t\tfieldValue := v.Field(i)\n\t\t\t\tif fieldValue.Kind() == reflect.String {\n\t\t\t\t\tlabels = append(labels, fieldValue.String())\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn labels\n\t\t},\n\t}\n\n\treturn extractor\n}\n```"]}, "weaver-runtime/metrics/metrics.go-Snapshot": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Metric) Snapshot() *MetricSnapshot {\n# Natural Language Annotations: // Snapshot returns a snapshot of the metric. You must call Init at least once\n// before calling Snapshot.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\n// Assuming the Metric and MetricSnapshot structs are defined earlier in the code\ntype Metric struct {\n\t// fields and methods related to Metric\n\tisInitialized bool\n\t// other fields\n}\n\ntype MetricSnapshot struct {\n\t// fields representing a snapshot of Metric's state\n}\n\n// This method initializes the Metric instance\nfunc (m *Metric) Init() {\n\tif !m.isInitialized {\n\t\tm.isInitialized = true\n\t\t// initialize other necessary fields\n\t}\n}\n\n// Snapshot method creates and returns a snapshot of the Metric\nfunc (m *Metric) Snapshot() *MetricSnapshot {\n\t// Ensure that Init has been called\n\tif !m.isInitialized {\n\t\tpanic(\"Snapshot called without initialization\")\n\t}\n\n\t// Code to create a snapshot of the current Metric\n\tsnapshot := &MetricSnapshot{\n\t\t// populate fields from m to create a snapshot\n\t}\n\n\treturn snapshot\n}\n```"]}, "weaver-internal/tool/generate/types.go-sizeOfType": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (tset *typeSet) sizeOfType(t types.Type) int {\n# Natural Language Annotations: // sizeOfType returns the size of the serialization of t if t is fixed size, or\n// returns -1 otherwise.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (tset *typeSet) sizeOfType(t types.Type) int {\n    // Assuming types.Type is an interface or a struct and has some method or field to determine if it is fixed size\n    if t.IsFixedSize() { // This method should indicate whether the type is of fixed size\n        return t.Size() // This method should return the size of the type\n    }\n    return -1 // Return -1 if the type is not of fixed size\n}\n```"]}, "weaver-internal/tool/generate/types.go-isMeasurable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (tset *typeSet) isMeasurable(t types.Type) bool {\n# Natural Language Annotations: // isMeasurable returns whether the provided type is measurable.\n//\n// Informally, we say a type is measurable if we can cheaply compute the size\n// of its serialization at runtime. Some examples:\n//\n//   - Every fixed size type (e.g., int, bool, [3]int, struct{x, y int}) is\n//     measurable (with some restrictions on package locality; see below).\n//   - Strings are not fixed size, but they are measurable because we can\n//     cheaply compute the length of a string at runtime.\n//   - []string is not measurable because computing the size of the\n//     serialization of a []string would require us to compute the length of\n//     every string in the slice. This is a potentially expensive operation\n//     if the slice contains a large number of strings, so we consider\n//     []string to be not measurable.\n//   - For simplicity, we only consider a type measurable if the type and all\n//     its nested types are package local. For example, a struct { x\n//     otherpackage.T } is not measurable, even if otherpackage.T is\n//     measurable. We make an exception for weaver.AutoMarshal.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"go/types\"\n\t\"strings\"\n)\n\ntype typeSet struct {\n\tlocalPackages map[string]bool // stores package paths considered as local\n}\n\n// isMeasurable returns whether the provided type is measurable.\nfunc (tset *typeSet) isMeasurable(t types.Type) bool {\n\tswitch v := t.(type) {\n\tcase *types.Basic:\n\t\t// Basic types are always measurable\n\t\treturn true\n\tcase *types.Array:\n\t\t// Array is measurable if its element type is measurable\n\t\treturn tset.isMeasurable(v.Elem())\n\tcase *types.Slice:\n\t\t// Slices are not measurable\n\t\treturn false\n\tcase *types.Struct:\n\t\t// A struct is measurable if all its fields are measurable and it's package local\n\t\treturn tset.isPackageLocal(t) && tset.areFieldsMeasurable(v)\n\tcase *types.Pointer:\n\t\t// A pointer is measurable if it points to a measurable type\n\t\treturn tset.isMeasurable(v.Elem())\n\tcase *types.Named:\n\t\t// Check if the named type's underlying type is measurable\n\t\t// We make an exception for weaver.AutoMarshal\n\t\tif v.Obj().Pkg() != nil && v.Obj().Pkg().Path() == \"weaver\" && v.Obj().Name() == \"AutoMarshal\" {\n\t\t\treturn true\n\t\t}\n\t\treturn tset.isPackageLocal(t) && tset.isMeasurable(v.Underlying())\n\tcase *types.Map, *types.Chan, *types.Interface, *types.Signature:\n\t\t// Maps, channels, interfaces, and functions are not measurable\n\t\treturn false\n\tdefault:\n\t\treturn false\n\t}\n}\n\n// Check if all fields of a struct type are measurable\nfunc (tset *typeSet) areFieldsMeasurable(s *types.Struct) bool {\n\tfor i := 0; i < s.NumFields(); i++ {\n\t\tif !tset.isMeasurable(s.Field(i).Type()) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Check if the type is defined in a local package\nfunc (tset *typeSet) isPackageLocal(t types.Type) bool {\n\tnamed, ok := t.(*types.Named)\n\tif !ok || named.Obj().Pkg() == nil {\n\t\treturn false\n\t}\n\tpackagePath := named.Obj().Pkg().Path()\n\t// Check if the package path is one of local packages\n\treturn tset.localPackages[packagePath]\n}\n\nfunc main() {\n\t// Example usage:\n\t// Define types and a typeSet for demonstration purposes\n\t// The localPackages can be populated with the paths considered local\n}\n```"]}, "weaver-internal/tool/generate/types.go-isValidRouterType": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func isValidRouterType(t types.Type) bool {\n# Natural Language Annotations: // isValidRouterType returns whether the provided type is a valid router type.\n// A router type can be one of the following: an integer (signed or unsigned),\n// a float, or a string. Alternatively, it can be a struct that may optioanly\n// embed the weaver.AutoMarshal struct and rest of the fields must be either\n// integers, floats, or strings.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"go/types\"\n\t\"strings\"\n)\n\nfunc isValidRouterType(t types.Type) bool {\n\t// Check if the type is a Basic type and its kind is int, uint, float, or string\n\tswitch bt := t.(type) {\n\tcase *types.Basic:\n\t\tswitch bt.Kind() {\n\t\tcase types.Int, types.Int8, types.Int16, types.Int32, types.Int64:\n\t\t\treturn true\n\t\tcase types.Uint, types.Uint8, types.Uint16, types.Uint32, types.Uint64:\n\t\t\treturn true\n\t\tcase types.Float32, types.Float64:\n\t\t\treturn true\n\t\tcase types.String:\n\t\t\treturn true\n\t\t}\n\tcase *types.Struct:\n\t\t// Iterate through each field\n\t\tfor i := 0; i < bt.NumFields(); i++ {\n\t\t\tfield := bt.Field(i)\n\t\t\tfieldType := field.Type()\n\n\t\t\t// If the field is anonymous and named, check if it's weaver.AutoMarshal struct\n\t\t\tif field.Embedded() {\n\t\t\t\tif namedFieldType, ok := fieldType.(*types.Named); ok {\n\t\t\t\t\tif strings.HasSuffix(namedFieldType.Obj().Name(), \"weaver.AutoMarshal\") {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If a field type is not supported, return false\n\t\t\tif !isValidRouterType(fieldType) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t}\n\n\t// All other types are considered invalid\n\treturn false\n}\n```"]}, "weaver-internal/tool/generate/generator.go-sanitize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func sanitize(t types.Type) string {\n# Natural Language Annotations: // sanitize generates a (somewhat pretty printed) name for the provided type\n// that is a valid go identifier [1]. sanitize also produces unique names. That\n// is, if u != t, then sanitize(u) != sanitize(t).\n//\n// Some examples:\n//\n//   - map[int]string -> map_int_string_589aebd1\n//   - map[int][]X    -> map_int_slice_X_ac498abc\n//   - []int          -> slice_int_1048ebf9\n//   - [][]string     -> slice_slice_string_13efa8aa\n//   - [20]int        -> array_20_int_00ae9a0a\n//   - *int           -> ptr_int_916711b2\n//\n// [1]: https://go.dev/ref/spec#Identifiers\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/sha1\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"go/types\"\n\t\"strings\"\n)\n\n// sanitize generates a (somewhat pretty printed) name for the provided type\n// that is a valid go identifier. sanitize also produces unique names. That\n// is, if u != t, then sanitize(u) != sanitize(t).\nfunc sanitize(t types.Type) string {\n\tvar builder strings.Builder\n\n\tswitch t := t.(type) {\n\tcase *types.Basic:\n\t\tbuilder.WriteString(t.Name())\n\n\tcase *types.Slice:\n\t\tbuilder.WriteString(\"slice_\")\n\t\tbuilder.WriteString(sanitize(t.Elem()))\n\n\tcase *types.Array:\n\t\tbuilder.WriteString(\"array_\")\n\t\tbuilder.WriteString(fmt.Sprintf(\"%d_\", t.Len()))\n\t\tbuilder.WriteString(sanitize(t.Elem()))\n\n\tcase *types.Pointer:\n\t\tbuilder.WriteString(\"ptr_\")\n\t\tbuilder.WriteString(sanitize(t.Elem()))\n\n\tcase *types.Map:\n\t\tbuilder.WriteString(\"map_\")\n\t\tbuilder.WriteString(sanitize(t.Key()))\n\t\tbuilder.WriteString(\"_\")\n\t\tbuilder.WriteString(sanitize(t.Elem()))\n\n\tcase *types.Named:\n\t\tbuilder.WriteString(t.Obj().Name())\n\t}\n\n\thash := sha1.Sum([]byte(builder.String()))\n\thashStr := hex.EncodeToString(hash[:])[:8]\n\treturn fmt.Sprintf(\"%s_%s\", builder.String(), hashStr)\n}\n```"]}, "weaver-internal/tool/generate/generator.go-uniqueName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func uniqueName(t types.Type) string {\n# Natural Language Annotations: // uniqueName returns a unique pretty printed representation of the provided\n// type (e.g., \"int\", \"map[int]bool\"). The key property is that if u != t, then\n// uniqueName(u) != uniqueName(t).\n//\n// Note that types.TypeString returns a pretty printed representation of a\n// string, but it is not guaranteed to be unique. For example, if have `type\n// int bool`, then TypeString returns \"int\" for both the named type int and the\n// primitive type int.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"go/types\"\n)\n\nfunc uniqueName(t types.Type) string {\n\t// Check if the type has a named type; if yes, prepend the package path\n\tif named, ok := t.(*types.Named); ok {\n\t\tobj := named.Obj()\n\t\tif obj.Pkg() != nil {\n\t\t\t// Concatenate package path and object name for uniqueness\n\t\t\treturn fmt.Sprintf(\"%s.%s\", obj.Pkg().Path(), obj.Name())\n\t\t}\n\t\t// For un-named packages (e.g. the local package), just return the name\n\t\treturn obj.Name()\n\t}\n\t// For unnamed types, use the standard TypeString representation\n\treturn types.TypeString(t, func(pkg *types.Package) string {\n\t\treturn pkg.Path()\n\t})\n}\n```"]}, "weaver-internal/tool/certs/certs.go-GenerateSignedCert": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n# Natural Language Annotations: // GenerateSignedCert generates a certificate for the given DNS names, signed\n// by the given Certificate Authority, and a corresponding private key.\n//\n// The returned certificate has a one-year validity and should only ever\n// be used on a temporary basis.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n)\n\nfunc GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n\t// Generate a new ECDSA private key\n\tpriv, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to generate private key: %v\", err)\n\t}\n\n\t// Fill out the basic certificate information including the DNS names\n\tnotBefore := time.Now()\n\tnotAfter := notBefore.Add(365 * 24 * time.Hour) // 1 year validity\n\n\tserialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)\n\tserialNumber, err := rand.Int(rand.Reader, serialNumberLimit)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to generate serial number: %v\", err)\n\t}\n\n\ttemplate := x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tCommonName: names[0], // Use the first name as common name\n\t\t},\n\t\tNotBefore:             notBefore,\n\t\tNotAfter:              notAfter,\n\t\tKeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},\n\t\tBasicConstraintsValid: true,\n\t\tDNSNames:              names,\n\t}\n\n\t// Create the certificate based on the template\n\tcertDER, err := x509.CreateCertificate(rand.Reader, &template, ca, &priv.PublicKey, caKey)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to create certificate: %v\", err)\n\t}\n\n\t// Parse the certificate\n\tcert, err := x509.ParseCertificate(certDER)\n\tif err != nil {\n\t\treturn nil, nil, fmt.Errorf(\"failed to parse certificate: %v\", err)\n\t}\n\n\t// Return the generated certificate and private key\n\treturn cert, priv, nil\n}\n```"]}, "weaver-internal/weaver/load.go-updateAssignment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (lc *loadCollector) updateAssignment(assignment *protos.Assignment) {\n# Natural Language Annotations: // updateAssignment updates a load collector with the latest assignment. The\n// load reported by a load collector is always scoped to a single assignment.\n// A load report never spans more than one assignment. Thus, UpdateAssignment\n// also clears the load collector's accumulated load.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (lc *loadCollector) updateAssignment(assignment *protos.Assignment) {\n\t// Update the load collector's assignment to the new assignment.\n\tlc.currentAssignment = assignment\n\n\t// Clear the accumulated load, as the load is scoped to the new assignment.\n\tlc.accumulatedLoad = nil\n}\n```"]}, "weaver-internal/weaver/load.go-report": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (lc *loadCollector) report() *protos.LoadReport_ComponentLoad {\n# Natural Language Annotations: // report returns a report of the collected load. If the load collector\n// doesn't have any collected load---this is possible if the load collector\n// doesn't have an assignment yet---then Report returns nil.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (lc *loadCollector) report() *protos.LoadReport_ComponentLoad {\n    // Check if there is any collected load in the load collector\n    if lc == nil || lc.collectedLoad == nil {\n        // If there is no collected load or the load collector is not initialized, return nil\n        return nil\n    }\n    // Otherwise, construct and return a LoadReport_ComponentLoad with the collected data\n    return &protos.LoadReport_ComponentLoad{\n        LoadDetails: lc.collectedLoad,\n    }\n}\n```"]}, "weaver-internal/weaver/load.go-subslices": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func subslices(load float64, xs []uint64, n int) []*protos.LoadReport_SubsliceLoad {\n# Natural Language Annotations: // subslices returns n splits of the provided points with roughly the same\n// load. For example, given xs = []uint64{10, 20, 30, 40, 50, 60, 70, 80}, n =\n// 4, and a load of 10.0, subslices will return the following four splits:\n//\n//   - {Start: 10, Load: 2.5} // [10, 30)\n//   - {Start: 30, Load: 2.5} // [30, 50)\n//   - {Start: 50, Load: 2.5} // [50, 70)\n//   - {Start: 70, Load: 2.5} // [70, infinity)\n//\n// The returned splits are as even as possible on a best effort basis.\n// subslices only guarantees that the returned splits are contiguous and\n// sorted.\n//\n// REQUIRES xs is sorted in increasing order\n// REQUIRES n > 0\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\n\t\"example.com/protos\"\n)\n\nfunc subslices(load float64, xs []uint64, n int) []*protos.LoadReport_SubsliceLoad {\n\t// Check if xs is empty or n is zero or negative\n\tif len(xs) == 0 || n <= 0 {\n\t\treturn nil\n\t}\n\t\n\t// Number of points in each subslice\n\tpointsPerSubslice := float64(len(xs)) / float64(n)\n\t\n\t// Conversion of total load among subslices\n\tsubload := load / float64(n)\n\t\n\tsubslices := make([]*protos.LoadReport_SubsliceLoad, 0, n)\n\tprevIndex := 0.0\n\t\n\tfor i := 0; i < n; i++ {\n\t\t// Calculate the end index for the current subslice\n\t\tnextIndex := math.Min(pointsPerSubslice*(float64(i)+1), float64(len(xs)))\n\t\t\n\t\tstart := xs[int(prevIndex)]\n\t\t\n\t\t// If it's the last subslice, include the rest of the slice\n\t\tif i == n-1 {\n\t\t\tsubslices = append(subslices, &protos.LoadReport_SubsliceLoad{\n\t\t\t\tStart: start,\n\t\t\t\tLoad:  subload,\n\t\t\t})\n\t\t} else {\n\t\t\tsubslices = append(subslices, &protos.LoadReport_SubsliceLoad{\n\t\t\t\tStart: start,\n\t\t\t\tLoad:  subload,\n\t\t\t})\n\t\t\tprevIndex = nextIndex\n\t\t}\n\t}\n\treturn subslices\n}\n\nfunc main() {\n\txs := []uint64{10, 20, 30, 40, 50, 60, 70, 80}\n\tn := 4\n\tload := 10.0\n\tresult := subslices(load, xs, n)\n\tfor _, r := range result {\n\t\tfmt.Printf(\"Start: %d, Load: %.2f\\n\", r.Start, r.Load)\n\t}\n}\n```\n"]}, "weaver-internal/weaver/routing.go-update": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rb *routingBalancer) update(assignment *protos.Assignment) {\n# Natural Language Annotations: // update updates the balancer with the provided assignment\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (rb *routingBalancer) update(assignment *protos.Assignment) {\n    // Check for nil input to avoid runtime errors\n    if assignment == nil {\n        return\n    }\n    \n    // Ideally, this should be a safe operation ensuring thread safety if needed\n    rb.mu.Lock()\n    defer rb.mu.Unlock()\n    \n    // Update the internal state of the balancer with the new assignment\n    // Assuming `rb` has a field `currentAssignment` of type `*protos.Assignment`\n    rb.currentAssignment = assignment\n\n    // If there are other internal states or caches dependent on the routing \n    // assignment, they should be updated here as well\n    \n    // Acknowledge the successful update, useful for logs\n    // log.Printf(\"Routing balancer updated with new assignment: %+v\", assignment)\n\n    // If there are event hooks or subscribers that need to be notified about \n    // the update, trigger those here\n}\n```"]}, "weaver-internal/status/registry.go-NewRegistry": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewRegistry(_ context.Context, dir string) (*Registry, error) {\n# Natural Language Annotations: // NewRegistry returns a registry that persists data to the provided directory.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage registry\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\n// Registry represents a data persistence system.\ntype Registry struct {\n\tdir string\n}\n\n// NewRegistry returns a registry that persists data to the provided directory.\nfunc NewRegistry(ctx context.Context, dir string) (*Registry, error) {\n\t// Validate the directory path.\n\tif dir == \"\" {\n\t\treturn nil, errors.New(\"directory path cannot be empty\")\n\t}\n\n\t// Ensure the directory exists.\n\terr := os.MkdirAll(dir, os.ModePerm)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Resolve the directory path into an absolute path for consistency.\n\tabsDir, err := filepath.Abs(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new Registry instance with the directory path.\n\tregistry := &Registry{\n\t\tdir: absDir,\n\t}\n\n\t// Return the registry instance.\n\treturn registry, nil\n}\n```"]}, "weaver-internal/routing/routing.go-FormatAssignment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FormatAssignment(a *protos.Assignment) string {\n# Natural Language Annotations: // FormatAssignment pretty formats the provided assignment.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc FormatAssignment(a *protos.Assignment) string {\n\tvar builder strings.Builder\n\n\t// Assuming Assignment has fields Name, DueDate, and Description.\n\tbuilder.WriteString(\"Assignment Details:\\n\")\n\tbuilder.WriteString(fmt.Sprintf(\"Name: %s\\n\", a.Name))\n\tbuilder.WriteString(fmt.Sprintf(\"Due Date: %s\\n\", a.DueDate.Format(\"January 2, 2006\")))\n\tbuilder.WriteString(fmt.Sprintf(\"Description: %s\\n\", a.Description))\n\n\treturn builder.String()\n}\n```"]}, "weaver-internal/routing/routing.go-EqualSlices": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EqualSlices(replicas []string) *protos.Assignment {\n# Natural Language Annotations: // EqualSlices returns an assignment with slices of roughly equal size.\n// Replicas are assigned to slices in a round robin fashion. The returned\n// assignment has a version of 0.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"github.com/golang/protobuf/proto\" // Assume proto contains a struct Assignment\n\t\"your_project_path/protos\"         // Assume protos contains a package for protobuf generated code\n)\n\n// EqualSlices assigns replicas to slices in a round-robin fashion\nfunc EqualSlices(replicas []string) *protos.Assignment {\n\tnumReplicas := len(replicas)\n\tif numReplicas == 0 {\n\t\treturn &protos.Assignment{\n\t\t\tSlices:  make([]*protos.Slice, 0),\n\t\t\tVersion: 0,\n\t\t}\n\t}\n\n\t// Determine the number of slices needed, assuming slice count is same as replica count initially.\n\t// We'll distribute replicas across each slice.\n\tnumSlices := numReplicas // Or any other logic that defines the number of slices\n\n\t// Initialize slices\n\tslices := make([][]string, numSlices)\n\tfor i := range slices {\n\t\tslices[i] = []string{}\n\t}\n\n\t// Round-robin assignment\n\tfor i, replica := range replicas {\n\t\tsliceIdx := i % numSlices\n\t\tslices[sliceIdx] = append(slices[sliceIdx], replica)\n\t}\n\n\t// Convert to protocompatible slices\n\tprotoSlices := make([]*protos.Slice, numSlices)\n\tfor i, slc := range slices {\n\t\tprotoSlices[i] = &protos.Slice{Replicas: slc}\n\t}\n\n\t// Create and return the final assignment\n\treturn &protos.Assignment{\n\t\tSlices:  protoSlices,\n\t\tVersion: 0,\n\t}\n}\n```"]}, "weaver-internal/queue/queue.go-Pop": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (q *Queue[T]) Pop(ctx context.Context) (elem T, err error) {\n# Natural Language Annotations: // Pop removes the element from the front of the queue and returns it.\n// It blocks if the queue is empty.\n// It returns an error if the passed-in context is canceled.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sync\"\n)\n\n// Generic queue structure with mutex for thread safety\ntype Queue[T any] struct {\n\telements []T\n\tlock     sync.Mutex\n\tnonEmpty *sync.Cond\n}\n\n// Create new queue\nfunc NewQueue[T any]() *Queue[T] {\n\tq := &Queue[T]{}\n\tq.nonEmpty = sync.NewCond(&q.lock)\n\treturn q\n}\n\n// Pop removes and returns the front element of the queue.\n// It blocks if the queue is empty, or returns an error if context is canceled.\nfunc (q *Queue[T]) Pop(ctx context.Context) (elem T, err error) {\n\tq.lock.Lock()\n\tdefer q.lock.Unlock()\n\n\tfor len(q.elements) == 0 {\n\t\t// Check if context is done\n\t\tif ctx.Err() != nil {\n\t\t\treturn elem, ctx.Err()\n\t\t}\n\n\t\t// Wait for a non-empty queue or context done\n\t\twaitCh := make(chan struct{})\n\t\tgo func() {\n\t\t\tq.nonEmpty.Wait()\n\t\t\tclose(waitCh)\n\t\t}()\n\n\t\tselect {\n\t\tcase <-ctx.Done(): // Context canceled or deadline exceeded\n\t\t\treturn elem, ctx.Err()\n\t\tcase <-waitCh:\n\t\t\tif ctx.Err() != nil {\n\t\t\t\treturn elem, ctx.Err()\n\t\t\t}\n\t\t}\n\t}\n\n\t// Context is not canceled and queue is non-empty\n\telem = q.elements[0]\n\tq.elements = q.elements[1:]\n\treturn elem, nil\n}\n\nfunc main() {\n\t// Example usage of the Queue\n\t// To be added as needed in the context of actual application\n}\n```"]}, "weaver-internal/pipe/pipe.go-MakePipePair": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Cmd) MakePipePair() (PipePair, error) {\n# Natural Language Annotations: // MakePipePair makes a pair of pipes that can be used for bi-directional\n// communication with the child process.\n//\n// Cmd.ExtraFiles should not be modified directly if MakePipePair is called.\n//\n// Wait will close ParentWriter automatically after seeing the command exit. A\n// caller need only close ParentWriter to force the pipe to close sooner. For\n// example, if the command being run will not exit until standard input is\n// closed, the caller must close ParentWriter.\n//\n// Wait will close ParentReader automatically after seeing the command exit, so\n// most callers need not close ParentReader themselves. It is thus incorrect to\n// call Wait before all reads from ParentReader have completed. For the same\n// reason, it is incorrect to use Run when using MakePipePair. See the\n// exec.Cmd.StdoutPipe example [1] for idiomatic usage.\n//\n// [1]: https://pkg.go.dev/os/exec#example-Cmd.StdoutPipe\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"os\"\n\t\"os/exec\"\n)\n\n// PipePair struct represents the pair of pipes used for communication\ntype PipePair struct {\n\tParentReader *os.File\n\tParentWriter *os.File\n}\n\n// Cmd struct is a placeholder for exec.Cmd or similar command execution structs\ntype Cmd struct {\n\tExtraFiles []*os.File\n\t// Other relevant fields would go here\n}\n\n// MakePipePair makes a pair of pipes for bi-directional communication with child process.\nfunc (c *Cmd) MakePipePair() (PipePair, error) {\n\t// Create a pipe for reading and writing\n\tparentReader, childWriter, err := os.Pipe()\n\tif err != nil {\n\t\treturn PipePair{}, err\n\t}\n\n\tchildReader, parentWriter, err := os.Pipe() // Second pipe for bi-directional communication\n\tif err != nil {\n\t\tparentReader.Close() // close any opened resources in case of error\n\t\tchildWriter.Close()\n\t\treturn PipePair{}, err\n\t}\n\n\t// Update the ExtraFiles slice to include the pipe's file descriptors\n\t// This avoids direct manipulation of ExtraFiles from outside.\n\tc.ExtraFiles = append(c.ExtraFiles, childReader, childWriter)\n\n\t// Return the PipePair containing parent side of the pipes\n\treturn PipePair{\n\t\tParentReader: parentReader,\n\t\tParentWriter: parentWriter,\n\t}, nil\n}\n\nfunc main() {\n\t// Example of how the Cmd struct and MakePipePair would be used\n\tcmd := &Cmd{}\n\tpipePair, err := cmd.MakePipePair()\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer pipePair.ParentReader.Close()\n\tdefer pipePair.ParentWriter.Close()\n\n\t// Further implementation for utilizing the pipePair\n}\n```"]}, "weaver-internal/register/writeonce.go-Write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) Write(val T) {\n# Natural Language Annotations: // Write writes to the register, or panics if the register was already written.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport \"sync\"\n\n// WriteOnce is a struct that ensures that a value can only be written once.\ntype WriteOnce[T any] struct {\n\tonce  sync.Once // ensures that 'Write' can only be called once\n\tvalue T         // the value to be written once\n}\n\n// Write writes to the register, or panics if the register was already written.\nfunc (w *WriteOnce[T]) Write(val T) {\n\tw.once.Do(func() {\n\t\tw.value = val // successfully write the value\n\t})\n\t\n\t// If once.Do has already executed, panic since we cannot write again\n\tif w.value != val {\n\t\tpanic(\"Register has already been written to\")\n\t}\n}\n```"]}, "weaver-internal/register/writeonce.go-TryWrite": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) TryWrite(val T) bool {\n# Natural Language Annotations: // TryWrite tries to write to the register and returns if the write succeeds.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (w *WriteOnce[T]) TryWrite(val T) bool {\n    if w.HasBeenWritten() { // Assume HasBeenWritten is a method that checks if a write has already occurred\n        return false\n    }\n    w.Value = val       // Assume Value is the field where the value is stored\n    w.SetWritten()      // Assume SetWritten is a method that marks the register as written\n    return true\n}\n```"]}, "weaver-internal/register/writeonce.go-Read": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) Read() T {\n# Natural Language Annotations: // Read returns the value of the register, blocking until it is written.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"sync\"\n)\n\n// WriteOnce is a structure that encapsulates a value of type T that can be set once.\ntype WriteOnce[T any] struct {\n\tvalue   T\n\twritten bool\n\tmux     sync.Mutex\n\tcond    *sync.Cond\n}\n\n// NewWriteOnce initializes a new WriteOnce object.\nfunc NewWriteOnce[T any]() *WriteOnce[T] {\n\tw := &WriteOnce[T]{}\n\tw.cond = sync.NewCond(&w.mux)\n\treturn w\n}\n\n// Write sets the value of the WriteOnce object and marks it as written.\nfunc (w *WriteOnce[T]) Write(value T) {\n\tw.mux.Lock()\n\tdefer w.mux.Unlock()\n\tif !w.written { // Ensure the value is only set once\n\t\tw.value = value\n\t\tw.written = true\n\t\t// Signal that the value has been written\n\t\tw.cond.Broadcast()\n\t}\n}\n\n// Read waits until a value is written and then returns it.\nfunc (w *WriteOnce[T]) Read() T {\n\tw.mux.Lock()\n\tdefer w.mux.Unlock()\n\tfor !w.written {\n\t\tw.cond.Wait() // Block until the value is written\n\t}\n\treturn w.value\n}\n```"]}, "weaver-internal/versioned/versioned.go-RLock": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (v *Versioned[T]) RLock(version string) string {\n# Natural Language Annotations: // RLock waits until the current version is different than the passed-in\n// version, and then acquires the read lock and returns the new\n// version.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype Versioned[T any] struct {\n\tmu      sync.RWMutex\n\tversion string\n\tdata    T\n}\n\nfunc (v *Versioned[T]) RLock(version string) string {\n\tv.mu.RLock()\n\tdefer v.mu.RUnlock()\n\n\tfor {\n\t\tcurrentVersion := v.version\n\t\tif currentVersion != version {\n\t\t\treturn currentVersion\n\t\t}\n\n\t\tv.mu.RUnlock()    // Release the read lock temporarily\n\t\ttime.Sleep(10 * time.Millisecond) // Sleep for a bit before trying again\n\t\tv.mu.RLock()      // Re-acquire the read lock\n\t}\n}\n```"]}, "weaver-internal/net/call/stub.go-makeStubMethods": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func makeStubMethods(fullName string, reg *codegen.Registration) []stubMethod {\n# Natural Language Annotations: // makeStubMethods returns a slice of stub methods for the component methods of reg.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc makeStubMethods(fullName string, reg *codegen.Registration) []stubMethod {\n    var stubs []stubMethod\n\n    // Loop through each method in the registration component methods\n    for _, method := range reg.Methods {\n        // Create a stub method for each\n        stub := stubMethod{\n            name:      method.Name,\n            receiver:  fullName, // Using fullName as the receiver type\n            signature: method.Signature, // Assuming method's signature holds necessary info\n            body:      generateStubBody(method),\n        }\n        stubs = append(stubs, stub)\n    }\n\n    return stubs\n}\n\n// Helper function to generate a stub body for a given method\nfunc generateStubBody(method codegen.Method) string {\n    // Generate a basic stub body for illustration purposes, this can be expanded to suit specific requirements\n    return \"return nil // TODO: implement \" + method.Name\n}\n```"]}, "weaver-internal/net/call/call.go-Serve": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Serve(ctx context.Context, l Listener, opts ServerOptions) error {\n# Natural Language Annotations: // Serve starts listening for connections and requests on l. It always returns a\n// non-nil error and closes l.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"net\"\n\t\"sync\"\n)\n\n// Define Listener and ServerOptions interfaces/types according to your specific use case.\ntype Listener interface {\n\tnet.Listener\n\tClose() error\n}\n\ntype ServerOptions struct {\n\t// Define server options here\n}\n\n// Serve starts listening for connections and requests on l. It always returns a non-nil error and closes l.\nfunc Serve(ctx context.Context, l Listener, opts ServerOptions) error {\n\tdefer l.Close()\n\n\t// Create a wait group to handle potential concurrent connections\n\tvar wg sync.WaitGroup\n\terrorChan := make(chan error, 1)\n\n\tgo func() {\n\t\t<-ctx.Done() // Listen for context cancellation\n\t\terrorChan <- ctx.Err()\n\t}()\n\n\tfor {\n\t\tconn, err := l.Accept()\n\t\tif err != nil {\n\t\t\treturn err // Return the accept error and close the listener\n\t\t}\n\n\t\twg.Add(1)\n\t\tgo func(conn net.Conn) {\n\t\t\tdefer wg.Done()\n\t\t\tdefer conn.Close()\n\n\t\t\t// Handle the connection (This part will need to be implemented)\n\t\t\thandleConnection(ctx, conn, opts)\n\n\t\t}(conn)\n\t}\n\n\twg.Wait()\n\tselect {\n\tcase err := <-errorChan:\n\t\treturn err\n\tdefault:\n\t\treturn errors.New(\"Serve: listener was closed\")\n\t}\n}\n\n// handleConnection is a placeholder for connection handling logic.\nfunc handleConnection(ctx context.Context, conn net.Conn, opts ServerOptions) {\n\tfmt.Println(\"Handling connection...\")\n\t// Implement the specific logic for handling each connection here\n\t// For example, serving requests, reading/writing data etc.\n}\n```"]}, "weaver-internal/net/call/call.go-Connect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Connect(ctx context.Context, resolver Resolver, opts ClientOptions) (Connection, error) {\n# Natural Language Annotations: // Connect creates a connection to the servers at the endpoints returned by the\n// resolver.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n    \"context\"\n    \"errors\"\n    \"fmt\"\n    // Here I am assuming that Connection, Resolver, and ClientOptions are defined in another part of your codebase\n    // or imported from other packages\n    // import \"package/path\" \n)\n\n// Placeholder types for the purpose of demonstration\ntype Connection struct {}\ntype Resolver interface {\n    Resolve() ([]string, error)\n}\ntype ClientOptions struct {}\n\n// Connect creates a connection to the servers at the endpoints returned by the resolver.\nfunc Connect(ctx context.Context, resolver Resolver, opts ClientOptions) (Connection, error) {\n    endpoints, err := resolver.Resolve()\n    if err != nil {\n        return Connection{}, fmt.Errorf(\"failed to resolve endpoints: %w\", err)\n    }\n\n    if len(endpoints) == 0 {\n        return Connection{}, errors.New(\"no endpoints resolved\")\n    }\n\n    // Assuming you have some logic to connect to the endpoints\n    // Here we return a dummy Connection assuming the connection was successful\n    // Replace the following line with actual connection logic\n    connection := Connection{}\n\n    // Check if context is done or canceled\n    select {\n    case <-ctx.Done():\n        return Connection{}, ctx.Err()\n    default:\n        // Continue with the connection if context is not canceled\n    }\n\n    // Return the established connection\n    return connection, nil\n}\n```"]}, "weaver-internal/net/call/msg.go-writeMessage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n# Natural Language Annotations: // # Message formats\n//\n// All messages have the following format:\n//    id        [8]byte       -- identifier used to track the message\n//    type      [1]byte       -- messageType\n//    length    [7]byte       -- length of the remainder of the message\n//    payload   [length]byte  -- message-type-specific data\n//\n// The format of payload depends on the message type.\n//\n// versionMessage: this is the first message sent on a connection by both sides.\n//    version  [4]byte\n//\n// requestMessage:\n//    headerLen         [4]byte         -- length of the encoded header\n//    header            [headerLen]byte -- encoded header information\n//    payload                           -- call argument serialization\n//\n// The header is encoded using Service Weaver's encoding format for a type that\n// looks like:\n//\n// struct header {\n//   MethodKey       [16]byte\n//   Deadline        int64\n//   TraceContext    [25]byte\n//   MetadataContext map[string]string\n// }\n//\n// responseMessage:\n//    payload holds call result serialization\n//\n// responseError:\n//    payload holds error serialization\n//\n// cancelMessage:\n//    payload is empty\n// writeMessage formats and sends a message over w.\n//\n// The message payload is formed by concatenating extraHdr and payload.\n// (Allowing two arguments to form the payload avoids unnecessary allocation\n// and copying when we want to prepend some data to application supplied data).\n//\n// The write is guarded by wlock, which must not be locked when passed in.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"errors\"\n\t\"io\"\n\t\"sync\"\n)\n\n// messageType represents the type of message to be sent.\ntype messageType byte\n\nconst (\n\tversionMessage messageType = iota\n\trequestMessage\n\tresponseMessage\n\tresponseError\n\tcancelMessage\n)\n\n// writeMessage formats and sends a message over the given io.Writer.\nfunc writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n\t// Locking to ensure thread-safe write operation\n\twlock.Lock()\n\tdefer wlock.Unlock()\n\n\t// Create message header\n\tvar header [16]byte\n\n\t// Set the message ID in the header\n\tbinary.BigEndian.PutUint64(header[0:8], id)\n\n\t// Set the message type\n\theader[8] = byte(mt)\n\n\t// Concatenate extraHdr and payload to form the full message payload\n\tfullPayload := append(extraHdr, payload...)\n\n\t// Check if we need to flatten the payload\n\tif flattenLimit > 0 && len(fullPayload) > flattenLimit {\n\t\treturn errors.New(\"payload exceeds flatten limit\")\n\t}\n\n\t// Set the length of the remainder of the message (7 bytes)\n\tpayloadLength := make([]byte, 7)\n\tbinary.BigEndian.PutUint64(append(make([]byte, 1), payloadLength...), uint64(len(fullPayload)))\n\n\t// Write the complete message\n\tif _, err := w.Write(append(header[:], append(payloadLength, fullPayload...)...)); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```"]}, "weaver-internal/net/call/trace.go-writeTraceContext": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeTraceContext(ctx context.Context, enc *codegen.Encoder) {\n# Natural Language Annotations: // writeTraceContext serializes the trace context (if any) contained in ctx\n// into enc.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc writeTraceContext(ctx context.Context, enc *codegen.Encoder) {\n    // Assume that the trace context is a custom type or structure stored in the context.\n    // Use a type assertion or a known key to retrieve it.\n    \n    // Let's assume we are storing the trace context with a key of type string\n    traceContextKey := \"traceContext\"\n\n    // Attempt to retrieve the trace context from the context with the specified key\n    if trace, ok := ctx.Value(traceContextKey).(traceContextType); ok {\n        // traceContextType should be replaced with the actual type of the trace context\n\n        // Serialize the trace context into the encoder.\n        // This requires a method or a function to encode the trace context appropriately.\n        err := enc.Encode(trace) // Assuming enc.Encode can serialize the traceContextType\n        if err != nil {\n            // Handle any encoding errors, for example, you might want to log it\n            log.Printf(\"Error encoding trace context: %v\", err)\n        }\n    } else {\n        // Optionally handle the case where no trace context exists.\n        // For example, you could log this information.\n        log.Println(\"No trace context found in the context.\")\n    }\n}\n```\n\nIn the supplied function:\n\n- We are retrieving the trace context from the given `context.Context` object using a known key, which we assume is of type string.\n- We check whether the retrieved value is of the expected `traceContextType`.\n- If the trace context exists, we serialize it using the `Encoder` object's `Encode` method. \n- Errors in encoding are logged, and if there is no trace context found, this is also logged. \n- Remember to replace `traceContextType` and the specific serialization logic with the actual types and methods used in your context."]}, "weaver-internal/net/call/trace.go-readTraceContext": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func readTraceContext(dec *codegen.Decoder) *trace.SpanContext {\n# Natural Language Annotations: // readTraceContext returns a span context with tracing information stored in dec.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc readTraceContext(dec *codegen.Decoder) *trace.SpanContext {\n    // Initialize a new SpanContext object\n    spanContext := new(trace.SpanContext)\n    \n    // Decode tracing information from the decoder into the SpanContext\n    if !dec.Decode(spanContext) {\n        // Handle decoding failure, maybe return a nil or a default SpanContext\n        return nil\n    }\n    \n    // Return the populated SpanContext\n    return spanContext\n}\n```"]}, "ollama-types/model/name.go-ParseNameBare": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseNameBare(s string) Name {\n# Natural Language Annotations: // ParseNameBare parses s as a name string and returns a Name. No merge with\n// [DefaultName] is performed.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype Name struct {\n\tFirst string\n\tLast  string\n}\n\n// ParseNameBare parses s as a name string and returns a Name. No merge with [DefaultName] is performed.\nfunc ParseNameBare(s string) Name {\n\t// Split the input string s based on spaces\n\tparts := strings.Fields(s)\n\n\t// Initialize an empty Name\n\tvar name Name\n\n\t// Assign the first part as First name if available, and the last part as Last name if available.\n\tif len(parts) > 0 {\n\t\tname.First = parts[0]\n\t\tif len(parts) > 1 {\n\t\t\tname.Last = parts[len(parts)-1]\n\t\t}\n\t}\n\n\treturn name\n}\n```"]}, "ollama-types/model/name.go-ParseNameFromFilepath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseNameFromFilepath(s string) (n Name) {\n# Natural Language Annotations: // ParseNameFromFilepath parses a 4-part filepath as a Name. The parts are\n// expected to be in the form:\n//\n// { host } \"/\" { namespace } \"/\" { model } \"/\" { tag }\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n    \"strings\"\n)\n\n// Name represents a structured format for the parsed name components\ntype Name struct {\n    Host      string\n    Namespace string\n    Model     string\n    Tag       string\n}\n\n// ParseNameFromFilepath parses a 4-part filepath as a Name. The parts are\n// expected to be in the form: { host } \"/\" { namespace } \"/\" { model } \"/\" { tag }\nfunc ParseNameFromFilepath(s string) (n Name) {\n    parts := strings.Split(s, \"/\")\n\n    if len(parts) != 4 {\n        return Name{}\n    }\n\n    n = Name{\n        Host:      parts[0],\n        Namespace: parts[1],\n        Model:     parts[2],\n        Tag:       parts[3],\n    }\n\n    return n\n}\n```"]}, "ollama-types/model/name.go-DisplayShortest": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n Name) DisplayShortest() string {\n# Natural Language Annotations: // DisplayShort returns a short string version of the name.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (n Name) DisplayShortest() string {\n\t// Convert the Name type to a string and return its shortest version.\n\t// Assuming \"shortest version\" means either initials or a truncated version of the name.\n\t// Here, let's return the initials of the name as the shortest representation.\n\t\n\t// Split the name by spaces to get individual components\n\tparts := strings.Fields(string(n))\n\n\t// Collect the initials\n\tinitials := \"\"\n\tfor _, part := range parts {\n\t\tif len(part) > 0 {\n\t\t\tinitials += string(part[0])\n\t\t}\n\t}\n\n\treturn initials\n}\n```"]}, "ollama-types/model/name.go-Filepath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n Name) Filepath() string {\n# Natural Language Annotations: // Filepath returns a canonical filepath that represents the name with each part from\n// host to tag as a directory in the form:\n//\n//\t{host}/{namespace}/{model}/{tag}\n//\n// It uses the system's filepath separator and ensures the path is clean.\n//\n// It panics if the name is not fully qualified. Use [Name.IsFullyQualified]\n// to check if the name is fully qualified.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"strings\"\n)\n\n// Assuming Name is a struct with the necessary fields and method\ntype Name struct {\n\tHost      string\n\tNamespace string\n\tModel     string\n\tTag       string\n}\n\n// IsFullyQualified checks if all necessary fields of Name are populated\nfunc (n Name) IsFullyQualified() bool {\n\treturn n.Host != \"\" && n.Namespace != \"\" && n.Model != \"\" && n.Tag != \"\"\n}\n\n// Filepath returns a canonical filepath as described in the annotation\nfunc (n Name) Filepath() string {\n\tif !n.IsFullyQualified() {\n\t\tpanic(\"name is not fully qualified\")\n\t}\n\t\n\tparts := []string{n.Host, n.Namespace, n.Model, n.Tag}\n\tpath := filepath.Join(parts...)\n\treturn filepath.Clean(path)\n}\n```"]}, "ollama-server/prompt.go-Prompt": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Prompt(tmpl *template.Template, system, prompt, response string, generate bool) (string, error) {\n# Natural Language Annotations: // Prompt renders a prompt from a template. If generate is set to true,\n// the response and parts of the template following it are not rendered\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"text/template\"\n)\n\nfunc Prompt(tmpl *template.Template, system, prompt, response string, generate bool) (string, error) {\n\tif tmpl == nil {\n\t\treturn \"\", errors.New(\"template is nil\")\n\t}\n\n\t// Create a data map for the template execution\n\tdata := map[string]interface{}{\n\t\t\"System\":  system,\n\t\t\"Prompt\":  prompt,\n\t\t\"Response\": response,\n\t}\n\n\tvar buf bytes.Buffer\n\n\t// If generate is true, we only render up to the point before the response section in tmpl\n\tif generate {\n\t\t// Here we have to assume there's a way to render parts of the template since Go templates do not\n\t\t// inherently have a mechanism to render up to a certain point only,\n\t\t// one would typically split the template or have flags within the template to conditionally render\n\t\t// specific parts, which cannot be inferred from just the function signature and comment.\n\t\t\n\t\t// Assuming that the template has conditional logic to handle what's rendered depending on `generate`\n\t\t// Please note that actual template logic should be further defined based on the template structure\n\t\tdata[\"SkipResponse\"] = true\n\t} else {\n\t\tdata[\"SkipResponse\"] = false\n\t}\n\n\terr := tmpl.Execute(&buf, data)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\treturn buf.String(), nil\n}\n```"]}, "ollama-server/sched.go-unload": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (runner *runnerRef) unload() {\n# Natural Language Annotations: // The refMu must already be held when calling unload\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (runner *runnerRef) unload() {\n\t// Assumes that refMu lock is already held by the caller\n\tif runner != nil {\n\t\t// Perform any necessary actions to \"unload\" the runner\n\t\t// This part of the implementation depends on what unloading entails\n\t\t// Here is a placeholder for unloading logic\n\t\t// For example, releasing resources, stopping processes, etc.\n\t\t\n\t\t// Sample logic:\n\t\t// Stop the process\n\t\tif runner.process != nil {\n\t\t\trunner.process.stop()\n\t\t}\n\t\t\n\t\t// Release resources\n\t\trunner.releaseResources()\n\n\t\t// Set the runner reference to nil to mark it as unloaded\n\t\trunner = nil\n\t}\n}\n```"]}, "lo-retry.go-NewDebounce": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n# Natural Language Annotations: // NewDebounce creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/mz32VMK2nqe\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\nfunc NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n\tvar mu sync.Mutex     // To guard concurrent access to the debounced function execution\n\tvar timer *time.Timer // Timer to hold the debounce duration\n\tvar functions []func()\n\n\t// Store the functions to be executed debounced\n\tfunctions = append(functions, f...)\n\n\t// cancel function to stop the running timer\n\tcancel := func() {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tif timer != nil {\n\t\t\ttimer.Stop()\n\t\t\ttimer = nil\n\t\t}\n\t}\n\n\t// debounced function\n\tdebounced := func() {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\n\t\tif timer != nil {\n\t\t\ttimer.Stop()\n\t\t}\n\n\t\t// Setting a new timer and execute the functions after the timer completes\n\t\ttimer = time.AfterFunc(duration, func() {\n\t\t\tfor _, fn := range functions {\n\t\t\t\tfn()\n\t\t\t}\n\t\t})\n\t}\n\n\treturn debounced, cancel\n}\n\nfunc main() {\n\t// Example usage\n\tdebouncedPrint, cancel := NewDebounce(2*time.Second, func() {\n\t\tfmt.Println(\"Function executed!\")\n\t})\n\n\t// Executing the debounced function multiple times\n\tdebouncedPrint()\n\ttime.Sleep(1 * time.Second)\n\tdebouncedPrint()\n\ttime.Sleep(1 * time.Second)\n\tdebouncedPrint()\n\n\t// To test cancel, uncomment:\n\t// time.Sleep(500 * time.Millisecond)\n\t// cancel()\n\n\t// Give enough time for the debounced function to execute\n\ttime.Sleep(3 * time.Second)\n}\n```"]}, "lo-retry.go-NewDebounceBy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n# Natural Language Annotations: // NewDebounceBy creates a debounced instance for each distinct key, that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/d3Vpt6pxhY8\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\n// NewDebounceBy creates a debounced instance for each distinct key,\n// that delays invoking functions given until after the specified duration has elapsed.\nfunc NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n\tvar mu sync.Mutex\n\ttimers := make(map[T]*time.Timer)\n\tcounts := make(map[T]int)\n\n\t// Helper function to reset the timer for a given key\n\tresetTimer := func(key T) {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tif timer, exists := timers[key]; exists {\n\t\t\ttimer.Stop()\n\t\t}\n\t\tcounts[key] = 0\n\t}\n\n\t// Function to be invoked, debounced by the key\n\ttrigger := func(key T) {\n\t\tmu.Lock()\n\t\tif _, exists := timers[key]; !exists {\n\t\t\ttimers[key] = time.NewTimer(duration)\n\t\t} else {\n\t\t\ttimers[key].Reset(duration)\n\t\t}\n\t\tcounts[key]++\n\t\ttimer := timers[key]\n\t\tcount := counts[key]\n\t\tmu.Unlock()\n\n\t\tgo func() {\n\t\t\t<-timer.C\n\t\t\tmu.Lock()\n\t\t\tif counts[key] == count {\n\t\t\t\tfor _, fn := range f {\n\t\t\t\t\tfn(key, count)\n\t\t\t\t}\n\t\t\t\tdelete(timers, key)\n\t\t\t\tdelete(counts, key)\n\t\t\t}\n\t\t\tmu.Unlock()\n\t\t}()\n\t}\n\n\treturn trigger, resetTimer\n}\n\nfunc main() {\n\t// Example usage for testing\n\ttrigger, reset := NewDebounceBy(500*time.Millisecond, func(key string, count int) {\n\t\tprintln(\"Function executed for key:\", key, \"with count:\", count)\n\t})\n\n\ttrigger(\"key1\")\n\ttime.Sleep(200 * time.Millisecond)\n\ttrigger(\"key1\")\n\ttime.Sleep(200 * time.Millisecond)\n\ttrigger(\"key1\")\n\ttime.Sleep(600 * time.Millisecond) // Wait enough time to see the execution\n\n\treset(\"key1\")\n\ttrigger(\"key1\")\n\ttime.Sleep(600 * time.Millisecond) // Should execute after resetting and triggering again\n}\n```"]}, "lo-errors.go-Try6": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n# Natural Language Annotations: // Try6 has the same behavior as Try, but callback returns 6 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n    _, _, _, _, _, err := callback()\n    return err == nil\n}\n```"]}, "lo-errors.go-TryOr6": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n# Natural Language Annotations: // TryOr6 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\n// TryOr6 has the same behavior as Must, but returns a default value in case of error.\nfunc TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n\ta, b, c, d, e, f, err := callback()\n\tif err != nil {\n\t\treturn fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF, false\n\t}\n\treturn a, b, c, d, e, f, true\n}\n\nfunc main() {\n\t// Example usage of the TryOr6 function\n\tcallback := func() (int, string, float64, bool, rune, byte, error) {\n\t\treturn 1, \"success\", 3.14, true, 'r', 'b', nil\n\t}\n\tfallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF := 0, \"fallback\", 0.0, false, 'x', 'y'\n\n\ta, b, c, d, e, f, ok := TryOr6(callback, fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF)\n\tfmt.Println(a, b, c, d, e, f, ok) // 1, \"success\", 3.14, true, 'r', 'b', true\n\n\tcallbackError := func() (int, string, float64, bool, rune, byte, error) {\n\t\treturn 0, \"\", 0, false, ' ', 0, fmt.Errorf(\"an error occurred\")\n\t}\n\n\ta, b, c, d, e, f, ok = TryOr6(callbackError, fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF)\n\tfmt.Println(a, b, c, d, e, f, ok) // 0, \"fallback\", 0.0, false, 'x', 'y', false\n}\n```"]}, "lo-string.go-Substring": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Substring[T ~string](str T, offset int, length uint) T {\n# Natural Language Annotations: // Substring return part of a string.\n// Play: https://go.dev/play/p/TQlxQi82Lu1\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc Substring[T ~string](str T, offset int, length uint) T {\n\trunes := []rune(str) // Convert the string to a slice of runes to safely handle Unicode characters\n\tstrLen := len(runes)\n\n\t// Handling negative offset\n\tif offset < 0 {\n\t\toffset = strLen + offset\n\t}\n\n\t// If offset is out of bounds, return an empty string\n\tif offset >= strLen || offset < 0 {\n\t\treturn T(\"\")\n\t}\n\n\t// Calculate end position\n\tend := offset + int(length)\n\n\t// If end exceeds string length, set end to string length\n\tif end > strLen {\n\t\tend = strLen\n\t}\n\n\treturn T(runes[offset:end])\n}\n\nfunc main() {\n\tstr := \"Hello, World!\"\n\tsub := Substring(string(str), 7, 5)\n\tfmt.Println(sub) // Output: World\n}\n```"]}, "lo-string.go-PascalCase": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func PascalCase(str string) string {\n# Natural Language Annotations: // PascalCase converts string to pascal case.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"strings\"\n\t\"unicode\"\n)\n\n// PascalCase converts string to pascal case.\nfunc PascalCase(str string) string {\n\t// Split the string by spaces or any other delimiters\n\twords := strings.FieldsFunc(str, func(r rune) bool {\n\t\treturn !unicode.IsLetter(r) && !unicode.IsNumber(r)\n\t})\n\n\t// Capitalize each word and concatenate\n\tvar result strings.Builder\n\tfor _, word := range words {\n\t\tif len(word) > 0 {\n\t\t\t// Capitalize the first letter and add the rest in lowercase\n\t\t\tresult.WriteString(strings.ToUpper(word[:1]))\n\t\t\tif len(word) > 1 {\n\t\t\t\tresult.WriteString(strings.ToLower(word[1:]))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result.String()\n}\n```"]}, "lo-map.go-PickByValues": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func PickByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n# Natural Language Annotations: // PickByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/1zdzSvbfsJc\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc PickByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n\t// Create a map to store the result\n\tout := make(Map)\n\n\t// Create a set-like map to check if a value is in the given values\n\tvalueSet := make(map[V]struct{})\n\tfor _, v := range values {\n\t\tvalueSet[v] = struct{}{}\n\t}\n\n\t// Iterate over the input map and add entries matching the values\n\tfor key, value := range in {\n\t\tif _, exists := valueSet[value]; exists {\n\t\t\tout[key] = value\n\t\t}\n\t}\n\n\treturn out\n}\n```"]}, "lo-map.go-OmitByValues": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OmitByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n# Natural Language Annotations: // OmitByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/9UYZi-hrs8j\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc OmitByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n\t// Create a set of values to omit for quick look-up\n\tvaluesToOmit := make(map[V]struct{})\n\tfor _, value := range values {\n\t\tvaluesToOmit[value] = struct{}{}\n\t}\n\n\t// Create a new map for the filtered output\n\tout := make(Map)\n\n\t// Iterate over the input map\n\tfor key, value := range in {\n\t\t// Check if the current value is in the set of values to omit\n\t\tif _, found := valuesToOmit[value]; !found {\n\t\t\tout[key] = value\n\t\t}\n\t}\n\n\treturn out\n}\n```"]}, "lo-tuples.go-Zip9": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Zip9[A, B, C, D, E, F, G, H, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n# Natural Language Annotations: // Zip9 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport \"reflect\"\n\n// Tuple9 is a struct that groups nine elements of different types.\ntype Tuple9[A, B, C, D, E, F, G, H, I any] struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n\tF F\n\tG G\n\tH H\n\tI I\n}\n\n// Zip9 creates a slice of Tuple9s, each containing one element from each input slice.\n// If the slices have different lengths, zero values are used to pad the shorter ones.\nfunc Zip9[A, B, C, D, E, F, G, H, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n\t// Determine the maximum length among the slices\n\tmaxLen := max(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n\n\tresult := make([]Tuple9[A, B, C, D, E, F, G, H, I], maxLen)\n\n\t// Iterate over each index and create a Tuple9\n\tfor idx := 0; idx < maxLen; idx++ {\n\t\tvar elem Tuple9[A, B, C, D, E, F, G, H, I]\n\t\tif idx < len(a) {\n\t\t\telem.A = a[idx]\n\t\t} else {\n\t\t\telem.A = zeroValue[A]()\n\t\t}\n\t\tif idx < len(b) {\n\t\t\telem.B = b[idx]\n\t\t} else {\n\t\t\telem.B = zeroValue[B]()\n\t\t}\n\t\tif idx < len(c) {\n\t\t\telem.C = c[idx]\n\t\t} else {\n\t\t\telem.C = zeroValue[C]()\n\t\t}\n\t\tif idx < len(d) {\n\t\t\telem.D = d[idx]\n\t\t} else {\n\t\t\telem.D = zeroValue[D]()\n\t\t}\n\t\tif idx < len(e) {\n\t\t\telem.E = e[idx]\n\t\t} else {\n\t\t\telem.E = zeroValue[E]()\n\t\t}\n\t\tif idx < len(f) {\n\t\t\telem.F = f[idx]\n\t\t} else {\n\t\t\telem.F = zeroValue[F]()\n\t\t}\n\t\tif idx < len(g) {\n\t\t\telem.G = g[idx]\n\t\t} else {\n\t\t\telem.G = zeroValue[G]()\n\t\t}\n\t\tif idx < len(h) {\n\t\t\telem.H = h[idx]\n\t\t} else {\n\t\t\telem.H = zeroValue[H]()\n\t\t}\n\t\tif idx < len(i) {\n\t\t\telem.I = i[idx]\n\t\t} else {\n\t\t\telem.I = zeroValue[I]()\n\t\t}\n\t\tresult[idx] = elem\n\t}\n\n\treturn result\n}\n\n// Helper function to find the maximum in a list of integers.\nfunc max(nums ...int) int {\n\tmaxVal := nums[0]\n\tfor _, num := range nums {\n\t\tif num > maxVal {\n\t\t\tmaxVal = num\n\t\t}\n\t}\n\treturn maxVal\n}\n\n// Helper function to get the zero value for any type.\nfunc zeroValue[T any]() T {\n\tvar zero T\n\trv := reflect.ValueOf(&zero).Elem()\n\trv.Set(reflect.Zero(rv.Type()))\n\treturn zero\n}\n```"]}, "lo-tuples.go-ZipBy9": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n# Natural Language Annotations: // ZipBy9 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n    // Determine the maximum length among all slices\n    maxLen := len(a)\n    \n    if len(b) > maxLen {\n        maxLen = len(b)\n    }\n    if len(c) > maxLen {\n        maxLen = len(c)\n    }\n    if len(d) > maxLen {\n        maxLen = len(d)\n    }\n    if len(e) > maxLen {\n        maxLen = len(e)\n    }\n    if len(f) > maxLen {\n        maxLen = len(f)\n    }\n    if len(g) > maxLen {\n        maxLen = len(g)\n    }\n    if len(h) > maxLen {\n        maxLen = len(h)\n    }\n    if len(i) > maxLen {\n        maxLen = len(i)\n    }\n\n    // Create a slice for the output\n    result := make([]Out, 0, maxLen)\n\n    for index := 0; index < maxLen; index++ {\n        // Get element from each slice or zero value if index exceeds slice length\n        var av A\n        var bv B\n        var cv C\n        var dv D\n        var ev E\n        var fv F\n        var gv G\n        var hv H\n        var iv I\n\t\t\n\t\tif index < len(a) {\n            av = a[index]\n        }\n        if index < len(b) {\n            bv = b[index]\n        }\n        if index < len(c) {\n            cv = c[index]\n        }\n        if index < len(d) {\n            dv = d[index]\n        }\n        if index < len(e) {\n            ev = e[index]\n        }\n        if index < len(f) {\n            fv = f[index]\n        }\n        if index < len(g) {\n            gv = g[index]\n        }\n        if index < len(h) {\n            hv = h[index]\n        }\n        if index < len(i) {\n            iv = i[index]\n        }\n\n\t\t// Apply the iteratee function and append to result\n        result = append(result, iteratee(av, bv, cv, dv, ev, fv, gv, hv, iv))\n    }\n\n    return result\n}\n```"]}, "lo-channel.go-ChannelDispatcher": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n# Natural Language Annotations: // ChannelDispatcher distributes messages from input channels into N child channels.\n// Close events are propagated to children.\n// Underlying channels can have a fixed buffer capacity or be unbuffered when cap is 0.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"sync\"\n)\n\n// DispatchingStrategy is an interface for strategies that determine how to dispatch messages.\ntype DispatchingStrategy[T any] interface {\n\tDispatch(channels []chan T, message T)\n}\n\nfunc ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n\t// Create the output channels with the specified buffer capacity\n\toutChannels := make([]chan T, count)\n\tfor i := 0; i < count; i++ {\n\t\toutChannels[i] = make(chan T, channelBufferCap)\n\t}\n\n\t// Start a goroutine to dispatch messages\n\tgo func() {\n\t\t// Wait group to ensure all output channels are closed before exiting the goroutine\n\t\tvar wg sync.WaitGroup\n\t\twg.Add(count)\n\n\t\tdefer func() {\n\t\t\tfor _, ch := range outChannels {\n\t\t\t\tclose(ch)\n\t\t\t\twg.Done()\n\t\t\t}\n\t\t}()\n\n\t\t// Distribute messages from the stream into output channels based on the strategy\n\t\tfor message := range stream {\n\t\t\tstrategy.Dispatch(outChannels, message)\n\t\t}\n\n\t\t// Ensure we wait if necessary\n\t\twg.Wait()\n\t}()\n\n\t// Return output channels as read-only\n\toutReadOnlyChannels := make([]<-chan T, count)\n\tfor i, ch := range outChannels {\n\t\toutReadOnlyChannels[i] = ch\n\t}\n\n\treturn outReadOnlyChannels\n}\n\nfunc main() {\n\t// Example usage\n}\n```"]}, "lo-channel.go-DispatchingStrategyRoundRobin": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n# Natural Language Annotations: // DispatchingStrategyRoundRobin distributes messages in a rotating sequential manner.\n// If the channel capacity is exceeded, the next channel will be selected and so on.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []chan T) int {\n    if len(channels) == 0 {\n        return -1 // Return -1 if no channels are available\n    }\n    \n    n := len(channels)\n    startIndex := int(index % uint64(n)) // Start index for round-robin\n    \n    for i := 0; i < n; i++ {\n        chIndex := (startIndex + i) % n\n        select {\n        case channels[chIndex] <- msg:\n            return chIndex // Successfully sent the message, return the channel index\n        default:\n            // Channel is full, attempt to send to the next one\n        }\n    }\n    \n    return -1 // All channels are full\n}\n```"]}, "lo-channel.go-FanOut": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n# Natural Language Annotations: // FanOut broadcasts all the upstream messages to multiple downstream channels.\n// When upstream channel reach EOF, downstream channels close. If any downstream\n// channels is full, broadcasting is paused.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n    // Create an array of downstream channels\n    downstreams := make([]chan T, count)\n    for i := 0; i < count; i++ {\n        downstreams[i] = make(chan T, channelsBufferCap)\n    }\n\n    go func() {\n        defer func() {\n            // Close all downstream channels when upstream is done\n            for _, ch := range downstreams {\n                close(ch)\n            }\n        }()\n\n        for item := range upstream {\n            // Try to send the item to all downstream channels\n            for _, ch := range downstreams {\n                select {\n                case ch <- item:\n                    // Successfully sent item to the channel\n                default:\n                    // Pause broadcasting if the channel buffer is full by blocking\n                    ch <- item\n                }\n            }\n        }\n    }()\n\n    // Convert []chan T to []<-chan T and return\n    downstreamsReadOnly := make([]<-chan T, count)\n    for i, ch := range downstreams {\n        downstreamsReadOnly[i] = ch\n    }\n\n    return downstreamsReadOnly\n}\n```"]}, "lo-slice.go-Shuffle": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Shuffle[T any, Slice ~[]T](collection Slice) Slice {\n# Natural Language Annotations: // Shuffle returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.\n// Play: https://go.dev/play/p/Qp73bnTDnc7\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc Shuffle[T any, Slice ~[]T](collection Slice) Slice {\n\trand.Seed(time.Now().UnixNano())\n\tn := len(collection)\n\tshuffled := make(Slice, n)\n\tcopy(shuffled, collection)\n\n\tfor i := n - 1; i > 0; i-- {\n\t\tj := rand.Intn(i + 1)\n\t\tshuffled[i], shuffled[j] = shuffled[j], shuffled[i]\n\t}\n\n\treturn shuffled\n}\n```"]}, "lo-slice.go-Fill": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Fill[T Clonable[T]](collection []T, initial T) []T {\n# Natural Language Annotations: // Fill fills elements of array with `initial` value.\n// Play: https://go.dev/play/p/VwR34GzqEub\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport \"fmt\"\n\n// Clonable is an interface that requires a Clone method.\ntype Clonable[T any] interface {\n\tClone() T\n}\n\n// Fill fills elements of the collection with `initial` value.\nfunc Fill[T Clonable[T]](collection []T, initial T) []T {\n\tfor i := range collection {\n\t\tcollection[i] = initial.Clone()\n\t}\n\treturn collection\n}\n\n// Example clonal type\ntype ExampleType struct {\n\tValue int\n}\n\n// Clone method for ExampleType\nfunc (e ExampleType) Clone() ExampleType {\n\treturn ExampleType{Value: e.Value}\n}\n\nfunc main() {\n\texample := ExampleType{Value: 10}\n\tcollection := make([]ExampleType, 5)\n\tfilledCollection := Fill(collection, example)\n\tfor _, v := range filledCollection {\n\t\tfmt.Println(v.Value)\n\t}\n}\n```\n\nThis code defines a generic `Fill` function that fills a collection with clones of an initial value. The `ExampleType` struct implements the `Clonable` interface with a `Clone` method, allowing you to test the `Fill` function in the `main` function."]}, "lo-slice.go-Repeat": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Repeat[T Clonable[T]](count int, initial T) []T {\n# Natural Language Annotations: // Repeat builds a slice with N copies of initial value.\n// Play: https://go.dev/play/p/g3uHXbmc3b6\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport \"fmt\"\n\n// Clonable is an interface that requires a Clone method\ntype Clonable[T any] interface {\n\tClone() T\n}\n\n// Repeat builds a slice with `count` copies of the `initial` value.\nfunc Repeat[T Clonable[T]](count int, initial T) []T {\n\tresult := make([]T, count)\n\tfor i := 0; i < count; i++ {\n\t\tresult[i] = initial.Clone()\n\t}\n\treturn result\n}\n\n// Example implementation of a type that satisfies Clonable\n\ntype Example struct {\n\tValue int\n}\n\nfunc (e Example) Clone() Example {\n\treturn Example{Value: e.Value}\n}\n\nfunc main() {\n\tinitialValue := Example{Value: 42}\n\tcopies := Repeat(5, initialValue)\n\n\tfor _, v := range copies {\n\t\tfmt.Println(v)\n\t}\n}\n```\nThis code is a Go implementation of the `Repeat` function using a generic type `T` that implements the `Clonable[T]` interface. The function will return a slice containing `count` number of copies of the `initial` element by utilizing a `Clone` method. An example implementation with a `struct` named `Example` demonstrates the use of this interface and function."]}, "lo-slice.go-DropByIndex": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DropByIndex[T any](collection []T, indexes ...int) []T {\n# Natural Language Annotations: // DropByIndex drops elements from a slice or array by the index.\n// A negative index will drop elements from the end of the slice.\n// Play: https://go.dev/play/p/bPIH4npZRxS\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc DropByIndex[T any](collection []T, indexes ...int) []T {\n\t// Creating a map to hold the indexes to drop for quick lookup\n\tindexesToDrop := make(map[int]struct{})\n\n\tfor _, index := range indexes {\n\t\t// Handling negative indices, which should drop elements from the end\n\t\tif index < 0 {\n\t\t\tindex = len(collection) + index\n\t\t}\n\t\t// Only consider valid indices\n\t\tif index >= 0 && index < len(collection) {\n\t\t\tindexesToDrop[index] = struct{}{}\n\t\t}\n\t}\n\n\t// Create the result slice to return\n\tresult := make([]T, 0, len(collection)-len(indexesToDrop))\n\n\t// Append elements that are not in the indexesToDrop map\n\tfor i, val := range collection {\n\t\tif _, exists := indexesToDrop[i]; !exists {\n\t\t\tresult = append(result, val)\n\t\t}\n\t}\n\n\treturn result\n}\n```"]}, "lo-intersect.go-Some": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Some[T comparable](collection []T, subset []T) bool {\n# Natural Language Annotations: // Some returns true if at least 1 element of a subset is contained into a collection.\n// If the subset is empty Some returns false.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc Some[T comparable](collection []T, subset []T) bool {\n    if len(subset) == 0 {\n        return false\n    }\n\n    elementSet := make(map[T]struct{}, len(collection))\n    for _, item := range collection {\n        elementSet[item] = struct{}{}\n    }\n\n    for _, item := range subset {\n        if _, exists := elementSet[item]; exists {\n            return true\n        }\n    }\n\n    return false\n}\n```"]}, "lo-find.go-FindKeyBy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FindKeyBy[K comparable, V any](object map[K]V, predicate func(key K, value V) bool) (K, bool) {\n# Natural Language Annotations: // FindKeyBy returns the key of the first element predicate returns truthy for.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc FindKeyBy[K comparable, V any](object map[K]V, predicate func(key K, value V) bool) (K, bool) {\n    for key, value := range object {\n        if predicate(key, value) {\n            return key, true\n        }\n    }\n    var zeroKey K\n    return zeroKey, false\n}\n```"]}, "lo-find.go-FirstOr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FirstOr[T any](collection []T, fallback T) T {\n# Natural Language Annotations: // FirstOr returns the first element of a collection or the fallback value if empty.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc FirstOr[T any](collection []T, fallback T) T {\n    if len(collection) > 0 {\n        return collection[0]\n    }\n    return fallback\n}\n```"]}, "lo-find.go-LastOr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func LastOr[T any](collection []T, fallback T) T {\n# Natural Language Annotations: // LastOr returns the last element of a collection or the fallback value if empty.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc LastOr[T any](collection []T, fallback T) T {\n    if len(collection) == 0 {\n        return fallback\n    }\n    return collection[len(collection)-1]\n}\n```"]}, "lo-math.go-Range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Range(elementNum int) []int {\n# Natural Language Annotations: // Range creates an array of numbers (positive and/or negative) with given length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc Range(elementNum int) []int {\n    result := make([]int, elementNum)\n    for i := 0; i < elementNum; i++ {\n        result[i] = i\n    }\n    return result\n}\n```"]}, "lo-math.go-RangeFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RangeFrom[T constraints.Integer | constraints.Float](start T, elementNum int) []T {\n# Natural Language Annotations: // RangeFrom creates an array of numbers from start with specified length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"golang.org/x/exp/constraints\"\n)\n\n// RangeFrom creates an array of numbers from start with specified length\nfunc RangeFrom[T constraints.Integer | constraints.Float](start T, elementNum int) []T {\n\tresult := make([]T, elementNum)\n\tfor i := 0; i < elementNum; i++ {\n\t\tresult[i] = start + T(i)\n\t}\n\treturn result\n}\n\nfunc main() {\n\t// Example usage\n\tintRange := RangeFrom(5, 5)\n\tfmt.Println(intRange) // Output: [5 6 7 8 9]\n\n\tfloatRange := RangeFrom(5.5, 5)\n\tfmt.Println(floatRange) // Output: [5.5 6.5 7.5 8.5 9.5]\n}\n```"]}, "lo-math.go-Mean": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Mean[T constraints.Float | constraints.Integer](collection []T) T {\n# Natural Language Annotations: // Mean calculates the mean of a collection of numbers.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"golang.org/x/exp/constraints\"\n)\n\nfunc Mean[T constraints.Float | constraints.Integer](collection []T) T {\n\tvar sum T\n\tfor _, value := range collection {\n\t\tsum += value\n\t}\n\tif len(collection) == 0 {\n\t\tvar zero T\n\t\treturn zero // Handle empty slice case by returning zero value.\n\t}\n\treturn sum / T(len(collection))\n}\n```"]}, "lo-math.go-MeanBy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MeanBy[T any, R constraints.Float | constraints.Integer](collection []T, iteratee func(item T) R) R {\n# Natural Language Annotations: // MeanBy calculates the mean of a collection of numbers using the given return value from the iteration function.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"golang.org/x/exp/constraints\"\n)\n\n// MeanBy calculates the mean of a collection of numbers using the given return value from the iteration function.\nfunc MeanBy[T any, R constraints.Float | constraints.Integer](collection []T, iteratee func(item T) R) R {\n\tvar sum R\n\tcount := len(collection)\n\n\tfor _, item := range collection {\n\t\tsum += iteratee(item)\n\t}\n\n\tif count == 0 {\n\t\tvar zero R\n\t\treturn zero // Avoid division by zero\n\t}\n\n\treturn sum / R(count)\n}\n```"]}, "conc-waitgroup.go-WaitAndRecover": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (h *WaitGroup) WaitAndRecover() *panics.Recovered {\n# Natural Language Annotations: // WaitAndRecover will block until all goroutines spawned with Go exit and\n// will return a *panics.Recovered if one of the child goroutines panics.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\n\t\"github.com/example/panics\" // hypothetical package for panic recovery\n)\n\ntype WaitGroup struct {\n\twg sync.WaitGroup\n\tmu sync.Mutex\n\tpanicRecovered *panics.Recovered\n}\n\nfunc (h *WaitGroup) WaitAndRecover() *panics.Recovered {\n\tch := make(chan *panics.Recovered, 1)\n\n\t// goroutine to wait for all routines and handle panic collection\n\tgo func() {\n\t\tdefer func() {\n\t\t\tif r := recover(); r != nil {\n\t\t\t\th.mu.Lock()\n\t\t\t\tdefer h.mu.Unlock()\n\t\t\t\t// collect the panic information\n\t\t\t\th.panicRecovered = panics.NewRecovered(r) // hypothetical function to recover panic information\n\t\t\t\tch <- h.panicRecovered\n\t\t\t} else {\n\t\t\t\tclose(ch)\n\t\t\t}\n\t\t}()\n\t\th.wg.Wait()\n\t\tclose(ch)\n\t}()\n\n\t// wait for done signal or recovered panic\n\tselect {\n\tcase recovered := <-ch:\n\t\treturn recovered\n\t}\n\treturn nil\n}\n\nfunc main() {\n\tvar wg WaitGroup\n\n\tfor i := 0; i < 5; i++ {\n\t\twg.wg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.wg.Done()\n\t\t\tif i == 2 {\n\t\t\t\tpanic(fmt.Sprintf(\"goroutine %d panicked\", i))\n\t\t\t}\n\t\t}(i)\n\t}\n\n\trecovered := wg.WaitAndRecover()\n\tif recovered != nil {\n\t\tfmt.Printf(\"Recovered panic: %v\\n\", recovered)\n\t} else {\n\t\tfmt.Println(\"All goroutines completed without panic\")\n\t}\n}\n```\n\nThis code snippet creates a `WaitAndRecover` function for a custom `WaitGroup` type that waits for all spawned goroutines to finish and recovers any panics that may have occurred in the child goroutines. It utilizes a hypothetical `panics` package to handle panic recovery and return detailed information about the panic."]}, "conc-stream/stream.go-Wait": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Stream) Wait() {\n# Natural Language Annotations: // Wait signals to the stream that all tasks have been submitted. Wait will\n// not return until all tasks and callbacks have been run.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *Stream) Wait() {\n\t// Create a channel to signal completion of all tasks and callbacks.\n\tdone := make(chan struct{})\n\n\t// Start a goroutine to monitor the completion of tasks.\n\tgo func() {\n\t\t// Assuming `s.tasks` is a channel or slice of tasks to be executed.\n\t\tfor task := range s.tasks {\n\t\t\t// Execute each task (assuming tasks are functions with no return).\n\t\t\ttask()\n\t\t\t// Execute any callbacks related to the task (assuming they're queued in `s.callbacks`).\n\t\t\tfor _, callback := range s.callbacks {\n\t\t\t\tcallback()\n\t\t\t}\n\t\t}\n\t\t// Signal that all tasks and callbacks have been completed.\n\t\tclose(done)\n\t}()\n\n\t// Wait for the done signal which indicates all tasks and callbacks are completed.\n\t<-done\n}\n```\n\nThis function assumes that `s.tasks` is a channel or a slice from which tasks are executed consecutively and that `s.callbacks` holds any callbacks that need to be executed after tasks. This would require further context on how tasks and callbacks are managed within the `Stream` structure. Furthermore, this function uses a channel `done` to signal the completion of all tasks and callbacks."]}, "OpenGFW-analyzer/udp/internal/quic/packet_protector.go-UnProtect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (pp *PacketProtector) UnProtect(packet []byte, pnOffset, pnMax int64) ([]byte, error) {\n# Natural Language Annotations: // UnProtect decrypts a QUIC packet.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (pp *PacketProtector) UnProtect(packet []byte, pnOffset, pnMax int64) ([]byte, error) {\n    // Validate the input parameters.\n    if len(packet) == 0 || pnOffset < 0 || pnOffset >= int64(len(packet)) {\n        return nil, fmt.Errorf(\"invalid packet or pnOffset\")\n    }\n\n    // Define variables for decryption.\n    decryptedPacket := make([]byte, len(packet))\n    copy(decryptedPacket, packet)\n    \n    // Here we assume that `decrypt` is a method implemented to decrypt the QUIC packet.\n    // It uses the given `pnOffset` for decryption position and some form of handling to consider from `pnMax`.\n    err := pp.decrypt(decryptedPacket, pnOffset, pnMax)\n    if err != nil {\n        return nil, fmt.Errorf(\"decryption failed: %v\", err)\n    }\n\n    // Return the decrypted packet.\n    return decryptedPacket, nil\n}\n\n// Example method definition for decrypt - This is just an assumption as the actual decryption algorithm is not specified.\nfunc (pp *PacketProtector) decrypt(packet []byte, pnOffset, pnMax int64) error {\n    // Implement the decryption logic based on QUIC specifications.\n    // Note: Actual decryption logic might be implemented using cryptographic libraries and following QUIC's cipher suite.\n    \n    // Dummy decryption process (to be replaced with actual logic).\n    return nil\n}\n```\n"]}, "hatchet-pkg/encryption/local.go-NewLocalEncryption": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*localEncryptionService, error) {\n# Natural Language Annotations: // NewLocalEncryption creates a new local encryption service. keysetBytes is the raw keyset in\n// base64-encoded JSON format. This can be generated by calling hatchet-admin keyset create-local.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// localEncryptionService is a placeholder for the actual implementation of the encryption service.\ntype localEncryptionService struct {\n\tMasterKey    []byte\n\tPrivateEc256 []byte\n\tPublicEc256  []byte\n}\n\n// NewLocalEncryption creates a new local encryption service.\n// It receives the masterKey, privateEc256, and publicEc256 in byte slice form,\n// which represent various cryptographic components necessary for the service.\nfunc NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*localEncryptionService, error) {\n\t// Validate the received keys. For the purpose of this example, a simple length check is done.\n\tif len(masterKey) == 0 || len(privateEc256) == 0 || len(publicEc256) == 0 {\n\t\treturn nil, errors.New(\"input keys cannot be empty\")\n\t}\n  \n\t// Encode the keys and return a new local encryption service instance\n\tmasterKeyEncoded := base64.StdEncoding.EncodeToString(masterKey)\n\tprivateEc256Encoded := base64.StdEncoding.EncodeToString(privateEc256)\n\tpublicEc256Encoded := base64.StdEncoding.EncodeToString(publicEc256)\n\n\tkeyset := map[string]string{\n\t\t\"masterKey\":     masterKeyEncoded,\n\t\t\"privateEc256\":  privateEc256Encoded,\n\t\t\"publicEc256\":   publicEc256Encoded,\n\t}\n\n\t// Convert the keyset to JSON\n\tkeysetBytes, err := json.Marshal(keyset)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to marshal keyset: %v\", err)\n\t}\n\n\t// Create the local encryption service with the encoded keys\n\tservice := &localEncryptionService{\n\t\tMasterKey:    keyset[\"masterKey\"],\n\t\tPrivateEc256: keyset[\"privateEc256\"],\n\t\tPublicEc256:  keyset[\"publicEc256\"],\n\t}\n\n\treturn service, nil\n}\n```\n"]}, "hatchet-pkg/encryption/cloudkms.go-NewCloudKMSEncryption": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewCloudKMSEncryption(keyUri string, credentialsJSON, privateEc256, publicEc256 []byte) (*cloudkmsEncryptionService, error) {\n# Natural Language Annotations: // NewCloudKMSEncryption creates a GCP CloudKMS-backed encryption service.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"cloud.google.com/go/kms/apiv1\"\n\t\"google.golang.org/api/option\"\n\tkmspb \"google.golang.org/genproto/googleapis/cloud/kms/v1\"\n)\n\n// cloudkmsEncryptionService represents a KMS-backed encryption service.\ntype cloudkmsEncryptionService struct {\n\tclient   *kms.KeyManagementClient\n\tkeyUri   string\n\tprivEC256 []byte\n\tpubEC256  []byte\n}\n\n// NewCloudKMSEncryption creates a GCP CloudKMS-backed encryption service.\nfunc NewCloudKMSEncryption(keyUri string, credentialsJSON, privateEc256, publicEc256 []byte) (*cloudkmsEncryptionService, error) {\n\t// Initialize a KMS client.\n\tctx := context.Background()\n\n\tclient, err := kms.NewKeyManagementClient(ctx, option.WithCredentialsJSON(credentialsJSON))\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to create KMS client: %v\", err)\n\t}\n\n\t// Prepare an instance of cloudkmsEncryptionService with necessary details.\n\tservice := &cloudkmsEncryptionService{\n\t\tclient:   client,\n\t\tkeyUri:   keyUri,\n\t\tprivEC256: privateEc256,\n\t\tpubEC256:  publicEc256,\n\t}\n\n\t// You may add additional setup steps if needed.\n\n\treturn service, nil\n}\n```"]}, "hatchet-internal/datautils/render.go-RenderTemplateFields": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n# Natural Language Annotations: // RenderTemplateFields recursively processes the input map, rendering any string fields using the data map.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\n// RenderTemplateFields recursively processes the input map, rendering any string fields using the data map.\nfunc RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n\tif data == nil || input == nil {\n\t\treturn nil, errors.New(\"data or input map cannot be nil\")\n\t}\n\n\t// Helper function to recursively render templates\n\tvar render func(interface{}) (interface{}, error)\n\n\trender = func(value interface{}) (interface{}, error) {\n\t\tswitch v := value.(type) {\n\t\tcase string:\n\t\t\t// Render the string template\n\t\t\treturn renderString(v, data), nil\n\t\tcase map[string]interface{}:\n\t\t\trenderedMap := make(map[string]interface{})\n\t\t\tfor key, val := range v {\n\t\t\t\trenderedVal, err := render(val)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\trenderedMap[key] = renderedVal\n\t\t\t}\n\t\t\treturn renderedMap, nil\n\t\tcase []interface{}:\n\t\t\trenderedSlice := make([]interface{}, len(v))\n\t\t\tfor i, elem := range v {\n\t\t\t\trenderedElem, err := render(elem)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\t\t\t\trenderedSlice[i] = renderedElem\n\t\t\t}\n\t\t\treturn renderedSlice, nil\n\t\tdefault:\n\t\t\treturn v, nil\n\t\t}\n\t}\n\n\t// Start rendering from the top-level input map\n\treturn render(input).(map[string]interface{}), nil\n}\n\n// renderString replaces placeholders in the format {key} with values from the data map\nfunc renderString(template string, data map[string]interface{}) string {\n\tfor key, val := range data {\n\t\tif strVal, ok := val.(string); ok {\n\t\t\tplaceholder := fmt.Sprintf(\"{%s}\", key)\n\t\t\ttemplate = strings.ReplaceAll(template, placeholder, strVal)\n\t\t}\n\t}\n\treturn template\n}\n```"]}, "mox-ratelimit/ratelimit.go-Reset": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (l *Limiter) Reset(ip net.IP, tm time.Time) {\n# Natural Language Annotations: // Reset sets the counter to 0 for key and ip, and subtracts from the ipmasked counts.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (l *Limiter) Reset(ip net.IP, tm time.Time) {\n    key := l.generateKey(ip, tm) // Assuming a method to generate a key based on ip and time\n    l.counter[key] = 0           // Reset the counter for the specific key\n\n    maskedIP := l.maskIP(ip)     // Assuming a method to mask the IP for aggregated counting\n    if count, exists := l.ipmasked[maskedIP]; exists {\n        l.ipmasked[maskedIP] = count - 1 // Subtract from the masked IP count\n        if l.ipmasked[maskedIP] < 0 {\n            l.ipmasked[maskedIP] = 0 // Ensure the count does not drop below zero\n        }\n    }\n}\n```"]}, "mox-dns/dns.go-ParseDomainLax": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseDomainLax(s string) (Domain, error) {\n# Natural Language Annotations: // ParseDomainLax parses a domain like ParseDomain, but allows labels with\n// underscores if the entire domain name is ASCII-only non-IDNA and Pedantic mode\n// is not enabled. Used for interoperability, e.g. domains may specify MX\n// targets with underscores.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n)\n\n// Domain represents a simplified domain structure\ntype Domain struct {\n\tLabels []string\n}\n\n// ParseDomainLax parses a domain similar to ParseDomain but allows labels with underscores\n// if the entire domain name is ASCII-only non-IDNA and Pedantic mode is not enabled.\nfunc ParseDomainLax(s string) (Domain, error) {\n\t// Split the input string by \".\" to get individual labels\n\tlabels := strings.Split(s, \".\")\n\tfor _, label := range labels {\n\t\t// Check if Pedantic mode is enabled by looking for a config environmental variable or flag\n\t\t// Assuming there is a function `isPedanticModeEnabled()` defined elsewhere\n\n\t\t// For simplicity, let's assume Pedantic mode is disabled\n\t\t// Validate each label\n\t\tif !isASCIIOnly(label) {\n\t\t\treturn Domain{}, errors.New(\"domain contains non-ASCII characters\")\n\t\t}\n\n\t\t// In Pedantic mode, underscores are not allowed in domain labels\n\t\tif false { // replace 'false' with isPedanticModeEnabled() if you have a function for it\n\t\t\tif strings.Contains(label, \"_\") {\n\t\t\t\treturn Domain{}, errors.New(\"domain contains underscores in labels, which is not allowed in Pedantic mode\")\n\t\t\t}\n\t\t}\n\n\t\tif !isLabelValid(label) {\n\t\t\treturn Domain{}, errors.New(\"invalid domain label\")\n\t\t}\n\t}\n\n\treturn Domain{Labels: labels}, nil\n}\n\n// Helper function to check if a label is ASCII-only\nfunc isASCIIOnly(label string) bool {\n\tfor _, r := range label {\n\t\tif r > 127 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// Helper function to validate a domain label\nfunc isLabelValid(label string) bool {\n\tif label == \"\" || len(label) > 63 {\n\t\treturn false\n\t}\n\n\t// A simplistic there about: labels:\n\t// 1. Must not start or end with a hyphen\n\t// 2. Only contains letters, digits, hyphens, or underscores\n\t// ASCII-only assumption already made in calling function\n\tif label[0] == '-' || label[len(label)-1] == '-' {\n\t\treturn false\n\t}\n\n\tfor _, r := range label {\n\t\tif !(r == '-' || r == '_' || ('a' <= r && r <= 'z') || ('A' <= r && r <= 'Z') || ('0' <= r && r <= '9')) {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\nfunc main() {\n\t// Testing the function\n\tdomainStr := \"example_with_underscores.com\"\n\tdomain, err := ParseDomainLax(domainStr)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tprintln(\"Parsed domain:\", strings.Join(domain.Labels, \".\"))\n}\n```"]}, "mox-dmarcdb/eval.go-AddEvaluation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n# Natural Language Annotations: // AddEvaluation adds the result of a DMARC evaluation for an incoming message\n// to the database.\n//\n// AddEvaluation sets Evaluation.IntervalHours based on\n// aggregateReportingIntervalSeconds.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"time\"\n)\n\n// Evaluation represents the evaluation of a DMARC report\ntype Evaluation struct {\n\tIntervalHours int\n\t// other fields related to the evaluation\n}\n\n// AddEvaluation adds the result of a DMARC evaluation for an incoming message\n// to the database.\n//\n// AddEvaluation sets Evaluation.IntervalHours based on\n// aggregateReportingIntervalSeconds.\nfunc AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n\t// Convert the aggregate reporting interval from seconds to hours\n\te.IntervalHours = aggregateReportingIntervalSeconds / 3600\n\n\t// The code needed to add this evaluation to a database would go here\n\t// For example, using a pseudocode function like `database.SaveEvaluation(ctx, e)`\n\t// If there's an error from the database operation, it should be returned\n\t// Example:\n\t// err := database.SaveEvaluation(ctx, e)\n\t// if err != nil {\n\t//     return fmt.Errorf(\"failed to add evaluation to database: %v\", err)\n\t// }\n\n\t// Here we simulate a successful database saving operation\n\tfmt.Println(\"Evaluation added to database:\", e)\n\n\t// If everything goes well, return nil (no error)\n\treturn nil\n}\n```"]}, "mox-dmarcdb/eval.go-EvaluationStats": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EvaluationStats(ctx context.Context) (map[string]EvaluationStat, error) {\n# Natural Language Annotations: // EvaluationStats returns evaluation counts and report-sending status per domain.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// EvaluationStat represents the evaluation counts and report-sending status for a domain.\ntype EvaluationStat struct {\n\tEvaluationCounts int  // Number of evaluations performed.\n\tReportSent       bool // Whether the report has been sent or not.\n}\n\n// EvaluationStats returns evaluation counts and report-sending status per domain.\nfunc EvaluationStats(ctx context.Context) (map[string]EvaluationStat, error) {\n\t// Simulated data source (could be a database, API, etc.)\n\t// In a real implementation, this would involve fetching data based on the context.\n\tevaluationData := map[string]EvaluationStat{\n\t\t\"example.com\": {\n\t\t\tEvaluationCounts: 10,\n\t\t\tReportSent:       true,\n\t\t},\n\t\t\"testsite.com\": {\n\t\t\tEvaluationCounts: 5,\n\t\t\tReportSent:       false,\n\t\t},\n\t\t\"sampledomain.org\": {\n\t\t\tEvaluationCounts: 15,\n\t\t\tReportSent:       true,\n\t\t},\n\t}\n\n\t// Simulating a context cancellation or error check\n\tif ctx.Err() != nil {\n\t\treturn nil, ctx.Err()\n\t}\n\n\t// Returning evaluation statistics\n\treturn evaluationData, nil\n}\n\nfunc main() {\n\t// Example usage of the EvaluationStats function\n\tctx := context.Background() // Using a simple background context\n\tstats, err := EvaluationStats(ctx)\n\tif err != nil {\n\t\tfmt.Println(\"Error fetching evaluation stats:\", err)\n\t\treturn\n\t}\n\n\tfor domain, stat := range stats {\n\t\tfmt.Printf(\"Domain: %s, Evaluations: %d, Report Sent: %t\\n\", domain, stat.EvaluationCounts, stat.ReportSent)\n\t}\n}\n```"]}, "mox-dmarcdb/eval.go-EvaluationsDomain": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EvaluationsDomain(ctx context.Context, domain dns.Domain) ([]Evaluation, error) {\n# Natural Language Annotations: // EvaluationsDomain returns all evaluations for a domain.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc EvaluationsDomain(ctx context.Context, domain dns.Domain) ([]Evaluation, error) {\n    // Initialize an empty slice to hold evaluations\n    var evaluations []Evaluation\n\n    // Retrieve the evaluations from some storage or service based on the domain\n    // Placeholder implementation; replace with actual retrieval logic\n    /*\n       Example of data retrieval, replace with actual data source:\n       evaluations, err := myDatabase.GetEvaluationsByDomain(ctx, domain)\n       if err != nil {\n           return nil, fmt.Errorf(\"failed to retrieve evaluations for domain %s: %w\", domain, err)\n       }\n    */\n\n    // Check if there's an evaluation service or repo implemented\n    evaluationService, err := getEvaluationService()\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to acquire evaluation service: %w\", err)\n    }\n\n    // Fetch the evaluations using the domain as a filter\n    evaluations, err = evaluationService.GetEvaluationsForDomain(ctx, domain)\n    if err != nil {\n        return nil, fmt.Errorf(\"error fetching evaluations for domain %s: %w\", domain, err)\n    }\n\n    // Return the slice of evaluations\n    return evaluations, nil\n}\n```"]}, "mox-dmarcdb/eval.go-RemoveEvaluationsDomain": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RemoveEvaluationsDomain(ctx context.Context, domain dns.Domain) error {\n# Natural Language Annotations: // RemoveEvaluationsDomain removes evaluations for domain so they won't be sent in\n// an aggregate report.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"sync\"\n)\n\n// Mock struct definitions\ntype Domain struct {\n\tName string\n}\n\n// Dummy in-memory store to hold evaluations for each domain\nvar domainEvaluationsStore = make(map[string]bool)\nvar mu sync.Mutex\n\n// RemoveEvaluationsDomain removes evaluations for a domain so they won't be sent in an aggregate report.\nfunc RemoveEvaluationsDomain(ctx context.Context, domain Domain) error {\n\t// Validate the domain parameter\n\tif domain.Name == \"\" {\n\t\treturn errors.New(\"domain name cannot be empty\")\n\t}\n\n\tmu.Lock()\n\tdefer mu.Unlock()\n\t\n\t// Check if the domain has evaluations\n\tif _, exists := domainEvaluationsStore[domain.Name]; !exists {\n\t\treturn errors.New(\"no evaluations found for the domain\")\n\t}\n\n\t// Remove evaluations for the domain\n\tdelete(domainEvaluationsStore, domain.Name)\n\n\treturn nil\n}\n```"]}, "mox-dmarcdb/reports.go-AddReport": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func AddReport(ctx context.Context, f *dmarcrpt.Feedback, fromDomain dns.Domain) error {\n# Natural Language Annotations: // AddReport adds a DMARC aggregate feedback report from an email to the database,\n// and updates prometheus metrics.\n//\n// fromDomain is the domain in the report message From header.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n\t\"gorm.io/gorm\"\n\t\"dmarcrpt\"\n\t\"dns\"\n)\n\n// Mockup of the structures to provide context\n\n// Define the database instance, assuming GORM or similar ORM is being used\nvar db *gorm.DB\n\n// Define the Prometheus metrics\nvar (\n\treportsReceived = prometheus.NewCounterVec(\n\t\tprometheus.CounterOpts{\n\t\t\tName: \"dmarc_reports_received_total\",\n\t\t\tHelp: \"Total number of DMARC reports received\",\n\t\t},\n\t\t[]string{\"domain\"},\n\t)\n)\n\nfunc init() {\n\t// Register prometheus metrics\n\tprometheus.MustRegister(reportsReceived)\n}\n\n// AddReport adds a DMARC aggregate feedback report from an email to the database,\n// and updates prometheus metrics.\nfunc AddReport(ctx context.Context, f *dmarcrpt.Feedback, fromDomain dns.Domain) error {\n\t// Validate the feedback report and domain\n\tif f == nil {\n\t\treturn errors.New(\"feedback report is nil\")\n\t}\n\tif fromDomain == \"\" {\n\t\treturn errors.New(\"fromDomain is empty\")\n\t}\n\n\t// Start a database transaction\n\ttx := db.WithContext(ctx).Begin()\n\tif tx.Error != nil {\n\t\treturn tx.Error\n\t}\n\n\t// Insert the feedback report into the database\n\tif err := tx.Create(&f).Error; err != nil {\n\t\ttx.Rollback()\n\t\treturn err\n\t}\n\n\t// Commit the transaction\n\tif err := tx.Commit().Error; err != nil {\n\t\treturn err\n\t}\n\n\t// Update Prometheus metrics for the received report\n\treportsReceived.WithLabelValues(string(fromDomain)).Inc()\n\n\tlog.Printf(\"Report added successfully for domain: %s\", fromDomain)\n\n\treturn nil\n}\n```"]}, "mox-junk/bloom.go-NewBloom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBloom(data []byte, k int) (*Bloom, error) {\n# Natural Language Annotations: // NewBloom returns a bloom filter with given initial data.\n//\n// The number of bits in data must be a power of 2.\n// K is the number of \"hashes\" (bits) to store/lookup for each value stored.\n// Width is calculated as the number of bits needed to represent a single bit/hash\n// position in the data.\n//\n// For each value stored/looked up, a hash over the value is calculated. The hash\n// is split into \"k\" values that are \"width\" bits wide, each used to lookup a bit.\n// K * width must not exceed 256.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"math\"\n)\n\ntype Bloom struct {\n\tdata   []byte\n\tk      int\n\twidth  uint\n}\n\nfunc log2(x int) int {\n\treturn int(math.Log2(float64(x)))\n}\n\nfunc isPowerOfTwo(x int) bool {\n\treturn (x != 0) && ((x & (x - 1)) == 0)\n}\n\nfunc NewBloom(data []byte, k int) (*Bloom, error) {\n\t// Check if the number of bits in data is a power of 2\n\tbitLength := len(data) * 8\n\tif !isPowerOfTwo(bitLength) {\n\t\treturn nil, errors.New(\"number of bits in data must be a power of 2\")\n\t}\n\n\t// Calculate the width (number of bits needed to represent a bit position)\n\twidth := uint(math.Ceil(math.Log2(float64(bitLength))))\n\n\t// Ensure that k * width does not exceed 256\n\tif k*int(width) > 256 {\n\t\treturn nil, errors.New(\"k * width must not exceed 256\")\n\t}\n\n\t// Initialize and return a new Bloom filter\n\tbloom := &Bloom{\n\t\tdata:  data,\n\t\tk:     k,\n\t\twidth: width,\n\t}\n\n\treturn bloom, nil\n}\n```\n"]}, "mox-junk/filter.go-NewFilter": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n# Natural Language Annotations: // NewFilter creates a new filter with empty bloom filter and database files. The\n// filter is marked as new until the first save, will be done automatically if\n// TrainDirs is called. If the bloom and/or database files exist, an error is\n// returned.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n    // Check if database file already exists\n    if _, err := os.Stat(dbPath); !os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"database file %s already exists\", dbPath)\n    }\n\n    // Check if bloom filter file already exists\n    if _, err := os.Stat(bloomPath); !os.IsNotExist(err) {\n        return nil, fmt.Errorf(\"bloom filter file %s already exists\", bloomPath)\n    }\n\n    // Create a new, empty Filter instance\n    filter := &Filter{\n        // Initialize the fields of the Filter struct\n        dbPath:   dbPath,\n        bloomPath: bloomPath,\n        isNew:    true,  // Mark the filter as new\n        params:   params,\n    }\n\n    // Initialize any other necessary fields or resources\n\n    // Return the newly created Filter and no error\n    return filter, nil\n}\n```"]}, "mox-junk/filter.go-ClassifyMessagePath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham, nspam int, rerr error) {\n# Natural Language Annotations: // ClassifyMessagePath is a convenience wrapper for calling ClassifyMessage on a file.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n    \"context\"\n    \"os\"\n)\n\n// Assuming you have a Filter struct with some relevant methods defined\ntype Filter struct {\n    // Assume necessary fields are defined here\n}\n\n// A stub method signature for ClassifyMessage which will be used within ClassifyMessagePath\nfunc (f *Filter) ClassifyMessage(ctx context.Context, message string) (float64, map[string]struct{}, int, int, error) {\n    // Assume this function returns probability, words, nham, nspam, and error based on the message content\n    return 0.0, nil, 0, 0, nil\n}\n\n// ClassifyMessagePath is a convenience wrapper for calling ClassifyMessage on a file.\nfunc (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham, nspam int, rerr error) {\n    // Open the file at the given path\n    file, err := os.Open(path)\n    if err != nil {\n        return 0.0, nil, 0, 0, err\n    }\n    defer file.Close()\n\n    // Read the file content\n    info, err := file.Stat()\n    if err != nil {\n        return 0.0, nil, 0, 0, err\n    }\n\n    data := make([]byte, info.Size())\n    _, err = file.Read(data)\n    if err != nil {\n        return 0.0, nil, 0, 0, err\n    }\n\n    // Convert the file content to a string for classification\n    messageContent := string(data)\n\n    // Call the ClassifyMessage method with the content of the file\n    probability, words, nham, nspam, rerr = f.ClassifyMessage(ctx, messageContent)\n\n    return probability, words, nham, nspam, rerr\n}\n```"]}, "mox-junk/filter.go-TrainDirs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n# Natural Language Annotations: // TrainDirs trains and saves a filter with mail messages from different types\n// of directories.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"path/filepath\"\n)\n\n// Filter struct serving as a placeholder for filter implementation details.\ntype Filter struct {\n    // Add fields here to represent the learning model, e.g., word frequencies, probabilities, etc.\n}\n\n// TrainDirs trains and saves a filter with mail messages from different types of directories.\nfunc (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n    // Process ham files\n    if err := f.processFiles(hamDir, hamFiles, \"ham\"); err != nil {\n        return fmt.Errorf(\"failed to process ham files: %w\", err)\n    }\n    \n    // Process sentiment files\n    if err := f.processFiles(sentDir, sentFiles, \"sentiment\"); err != nil {\n        return fmt.Errorf(\"failed to process sentiment files: %w\", err)\n    }\n    \n    // Process spam files\n    if err := f.processFiles(spamDir, spamFiles, \"spam\"); err != nil {\n        return fmt.Errorf(\"failed to process spam files: %w\", err)\n    }\n    \n    // Save the trained filter model\n    if err := f.saveModel(); err != nil {\n        return fmt.Errorf(\"failed to save filter model: %w\", err)\n    }\n    \n    return nil\n}\n\n// Helper method to process files given a directory, list of files, and their category\nfunc (f *Filter) processFiles(directory string, files []string, category string) error {\n    for _, file := range files {\n        filePath := filepath.Join(directory, file)\n        content, err := ioutil.ReadFile(filePath)\n        if err != nil {\n            return fmt.Errorf(\"failed to read file %s: %w\", filePath, err)\n        }\n\n        // Assuming `train` is a method for training data on the filter\n        // based on content and category.\n        f.train(string(content), category)\n    }\n    return nil\n}\n\n// Train is a placeholder for actual training logic\nfunc (f *Filter) train(content, category string) {\n    // Implement logic to parse the content and update the filter's model.\n    // For category, you might want to adjust how data is processed.\n    fmt.Printf(\"Training on data from %s category\\n\", category)\n}\n\n// SaveModel is a placeholder for actual model-saving logic\nfunc (f *Filter) saveModel() error {\n    // Implement logic to save the filter's state/models to a file or database.\n    fmt.Println(\"Model saved successfully\")\n    return nil\n}\n```"]}, "mox-webmail/message.go-parseListPostAddress": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func parseListPostAddress(s string) *MessageAddress {\n# Natural Language Annotations: // parses List-Post header, returning an address if it could be found, and nil otherwise.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"net/mail\"\n\t\"regexp\"\n\t\"strings\"\n)\n\n// MessageAddress is a type alias for mail.Address to represent email address.\ntype MessageAddress mail.Address\n\n// parseListPostAddress parses a List-Post header, returning an address if it could be found, and nil otherwise.\nfunc parseListPostAddress(s string) *MessageAddress {\n\t// Regular expression to match the List-Post address inside \"<>\"\n\tre := regexp.MustCompile(`<([^>]+)>`)\n\n\t// Look for matches of the form <address>\n\tmatches := re.FindStringSubmatch(s)\n\n\tif len(matches) > 1 {\n\t\t// Parse the found address to ensure it's a valid email address\n\t\taddr, err := mail.ParseAddress(matches[1])\n\t\tif err == nil {\n\t\t\treturn (*MessageAddress)(addr) // Convert to *MessageAddress type\n\t\t}\n\t}\n\n\treturn nil\n}\n```"]}, "mox-webmail/webmail.go-sanitizeNode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func sanitizeNode(node *html.Node) {\n# Natural Language Annotations: // sanitizeNode removes script elements, on* attributes, javascript: href\n// attributes, adds target=\"_blank\" to all links and to a base tag.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"golang.org/x/net/html\"\n\t\"strings\"\n)\n\nfunc sanitizeNode(node *html.Node) {\n\tif node == nil {\n\t\treturn\n\t}\n\n\tvar sanitize func(*html.Node)\n\tsanitize = func(n *html.Node) {\n\t\t// Remove script elements\n\t\tif n.Type == html.ElementNode && n.Data == \"script\" {\n\t\t\tremoveNode(n)\n\t\t\treturn // If node is removed, no need to process its children\n\t\t}\n\n\t\t// Process attributes of the node\n\t\tif n.Type == html.ElementNode {\n\t\t\tfor i := 0; i < len(n.Attr); i++ {\n\t\t\t\tattr := n.Attr[i]\n\n\t\t\t\t// Remove on* attributes\n\t\t\t\tif strings.HasPrefix(attr.Key, \"on\") {\n\t\t\t\t\tn.Attr = append(n.Attr[:i], n.Attr[i+1:]...)\n\t\t\t\t\ti-- // Adjust index due to attribute slice modification\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\t// Sanitize href attributes starting with \"javascript:\"\n\t\t\t\tif attr.Key == \"href\" && strings.HasPrefix(attr.Val, \"javascript:\") {\n\t\t\t\t\tn.Attr[i].Val = \"#\"\n\t\t\t\t}\n\n\t\t\t\t// Add target=\"_blank\" to links <a> and <base> elements\n\t\t\t\tif attr.Key == \"href\" && (n.Data == \"a\" || n.Data == \"base\") {\n\t\t\t\t\thasTarget := false\n\t\t\t\t\tfor _, a := range n.Attr {\n\t\t\t\t\t\tif a.Key == \"target\" {\n\t\t\t\t\t\t\thasTarget = true\n\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif !hasTarget {\n\t\t\t\t\t\tn.Attr = append(n.Attr, html.Attribute{Key: \"target\", Val: \"_blank\"})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Recursively sanitize child nodes\n\t\tfor c := n.FirstChild; c != nil; c = c.NextSibling {\n\t\t\tsanitize(c)\n\t\t}\n\t}\n\n\t// Helper function to remove a node\n\tremoveNode := func(n *html.Node) {\n\t\tif n.Parent != nil {\n\t\t\tn.Parent.RemoveChild(n)\n\t\t}\n\t}\n\n\t// Start sanitization from the given node\n\tsanitize(node)\n}\n```"]}, "mox-dnsbl/dnsbl.go-Lookup": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Lookup(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain, ip net.IP) (rstatus Status, rexplanation string, rerr error) {\n# Natural Language Annotations: // Lookup checks if \"ip\" occurs in the DNS block list \"zone\" (e.g. dnsbl.example.org).\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"strings\"\n\n\t\"golang.org/x/net/dns/dnsmessage\"\n\t\"golang.org/x/net/dns/dnsresolver\"\n)\n\ntype Status int\n\nconst (\n\tStatusNotListed Status = iota\n\tStatusListed\n)\n\nfunc Lookup(ctx context.Context, elog *Logger, resolver dnsresolver, zone string, ip net.IP) (rstatus Status, rexplanation string, rerr error) {\n\t// Convert IP address to reverse notation\n\tip4 := ip.To4()\n\tif ip4 == nil {\n\t\treturn StatusNotListed, \"\", fmt.Errorf(\"only IPv4 addresses are supported\")\n\t}\n\n\t// Prepare reverse IP address for DNS query\n\treverseIP := fmt.Sprintf(\"%d.%d.%d.%d.%s\", ip4[3], ip4[2], ip4[1], ip4[0], zone)\n\n\t// Log the query attempt\n\telog.Printf(\"Checking DNSBL for: %s\", reverseIP)\n\n\t// Prepare DNS question\n\tquestion := dnsmessage.Question{\n\t\tName:  dnsmessage.MustNewName(reverseIP + \".\"),\n\t\tType:  dnsmessage.TypeA,\n\t\tClass: dnsmessage.ClassINET,\n\t}\n\n\t// Perform DNS query\n\tresponse, err := resolver.Query(ctx, question)\n\tif err != nil {\n\t\treturn StatusNotListed, \"\", fmt.Errorf(\"dns query error: %w\", err)\n\t}\n\n\t// Check the answer section of the DNS response\n\tfor _, ans := range response.Answers {\n\t\tif ans.Header.Type == dnsmessage.TypeA {\n\t\t\t// IP found in the DNSBL\n\t\t\treturn StatusListed, \"IP is blacklisted\", nil\n\t\t}\n\t}\n\n\t// If no A record found, IP is not listed\n\treturn StatusNotListed, \"IP is not blacklisted\", nil\n}\n\n// Logger is a simple logger interface to match \"elog\" in function signature.\ntype Logger struct{}\n\nfunc (l *Logger) Printf(format string, v ...interface{}) {\n\tfmt.Printf(format, v...)\n}\n\ntype dnsresolver interface {\n\tQuery(ctx context.Context, q dnsmessage.Question) (dnsmessage.Message, error)\n}\n\n// Example usage of dnsresolver (replace with a concrete implementation)\ntype MockDNSResolver struct{}\n\nfunc (r *MockDNSResolver) Query(ctx context.Context, q dnsmessage.Question) (dnsmessage.Message, error) {\n\t// Mock response for illustration\n\tmockResponse := dnsmessage.Message{\n\t\tHeader: dnsmessage.Header{\n\t\t\tOpcode: dnsmessage.OpQuery,\n\t\t\tRCode:  dnsmessage.RCodeSuccess,\n\t\t},\n\t\tQuestions: []dnsmessage.Question{q},\n\t}\n\treturn mockResponse, nil\n}\n\n// Main function to demonstrate usage\nfunc main() {\n\tctx := context.Background()\n\tlogger := &Logger{}\n\tresolver := &MockDNSResolver{}\n\tip := net.ParseIP(\"127.0.0.2\")\n\tzone := \"dnsbl.example.org\"\n\n\tstatus, explanation, err := Lookup(ctx, logger, resolver, zone, ip)\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(\"Status:\", status)\n\tfmt.Println(\"Explanation:\", explanation)\n}\n```"]}, "mox-dnsbl/dnsbl.go-CheckHealth": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CheckHealth(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain) (rerr error) {\n# Natural Language Annotations: // CheckHealth checks whether the DNSBL \"zone\" is operating correctly by\n// querying for 127.0.0.2 (must be present) and 127.0.0.1 (must not be present).\n// Users of a DNSBL should periodically check if the DNSBL is still operating\n// properly.\n// For temporary errors, ErrDNS is returned.\nPlease only return the code surrounded by ```\n", "response": ["```go\n// Import necessary packages\nimport (\n    \"context\"\n    \"errors\"\n    \"net\"\n    \"time\"\n\n    \"golang.org/x/exp/slog\"\n    \"github.com/miekg/dns\"\n)\n\n// Define the ErrDNS for temporary DNS errors\nvar ErrDNS = errors.New(\"temporary DNS error\")\n\n// CheckHealth checks whether the DNSBL \"zone\" is operating correctly\nfunc CheckHealth(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain) (rerr error) {\n    // Define the IP addresses to check\n    mustExistIP := \"127.0.0.2\"\n    mustNotExistIP := \"127.0.0.1\"\n\n    // A helper function to perform a DNS query for a given IP address\n    queryDNS := func(ipAddress string) (bool, error) {\n        m := new(dns.Msg)\n        m.SetQuestion(dns.Fqdn(ipAddress+\".\"+string(zone)), dns.TypeA)\n        in, err := dns.Exchange(m, resolver.Address)\n        if err != nil {\n            return false, err\n        }\n        return len(in.Answer) > 0, nil\n    }\n\n    // Check if 127.0.0.2 is present\n    isPresent, err := queryDNS(mustExistIP)\n    if err != nil {\n        elog.Error(err.Error()) // Log the error\n        return ErrDNS\n    }\n    if !isPresent {\n        elog.Error(\"Expected entry for 127.0.0.2 is missing\")\n        return errors.New(\"expected entry for 127.0.0.2 is missing\")\n    }\n\n    // Check if 127.0.0.1 is not present\n    isPresent, err = queryDNS(mustNotExistIP)\n    if err != nil {\n        elog.Error(err.Error()) // Log the error\n        return ErrDNS\n    }\n    if isPresent {\n        elog.Error(\"Unexpected entry for 127.0.0.1 is present\")\n        return errors.New(\"unexpected entry for 127.0.0.1 is present\")\n    }\n\n    elog.Info(\"DNSBL zone is operational\")\n    // All checks passed\n    return nil\n}\n```"]}, "mox-dmarcrpt/parse.go-ParseMessageReport": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseMessageReport(elog *slog.Logger, r io.ReaderAt) (*Feedback, error) {\n# Natural Language Annotations: // ParseMessageReport parses an aggregate feedback report from a mail message. The\n// maximum message size is 15MB, the maximum report size after decompression is\n// 20MB.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"slog\"\n)\n\n// Feedback is a placeholder for the parsed feedback report.\ntype Feedback struct {\n\t// Define fields for Feedback struct based on the expected report content.\n}\n\n// ParseMessageReport parses an aggregate feedback report from a mail message.\n// The maximum message size is 15MB, the maximum report size after decompression is 20MB.\nfunc ParseMessageReport(elog *slog.Logger, r io.ReaderAt) (*Feedback, error) {\n\tconst maxMessageSize = 15 * 1024 * 1024  // 15MB\n\tconst maxReportSize = 20 * 1024 * 1024   // 20MB\n\n\t// Create a limited reader to ensure message does not exceed maxMessageSize\n\tlimitedReader := io.NewSectionReader(r, 0, maxMessageSize)\n\n\t// Read the entire message into memory\n\tmessage, err := ioutil.ReadAll(limitedReader)\n\tif err != nil {\n\t\telog.Error(\"Error reading message:\", err)\n\t\treturn nil, err\n\t}\n\n\t// Attempt to decompress the message assuming gzip\n\treport, err := decompressReport(message, elog)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Ensure the decompressed report size does not exceed maxReportSize\n\tif len(report) > maxReportSize {\n\t\telog.Error(\"Report exceeds maximum size after decompression\")\n\t\treturn nil, errors.New(\"report exceeds maximum size after decompression\")\n\t}\n\n\t// Parse the report into a Feedback instance\n\tfeedback, err := parseFeedbackReport(report, elog)\n\tif err != nil {\n\t\telog.Error(\"Error parsing feedback report:\", err)\n\t\treturn nil, err\n\t}\n\n\treturn feedback, nil\n}\n\nfunc decompressReport(message []byte, elog *slog.Logger) ([]byte, error) {\n\tgzipReader, err := gzip.NewReader(bytes.NewReader(message))\n\tif err != nil {\n\t\telog.Error(\"Error creating gzip reader:\", err)\n\t\treturn nil, err\n\t}\n\tdefer gzipReader.Close()\n\n\treport, err := ioutil.ReadAll(gzipReader)\n\tif err != nil {\n\t\telog.Error(\"Error decompressing report:\", err)\n\t\treturn nil, err\n\t}\n\n\treturn report, nil\n}\n\nfunc parseFeedbackReport(report []byte, elog *slog.Logger) (*Feedback, error) {\n\t// Implement the logic to parse the report byte slice into a Feedback struct.\n\t// This is a placeholder for actual implementation.\n\t\n\t// For demonstration purposes, returning an empty Feedback instance.\n\treturn &Feedback{}, nil\n}\n\nfunc main() {\n\t// Example usage of the ParseMessageReport function.\n\telog := slog.New(log.Default())\n\t// Replace nil with a valid io.ReaderAt source in actual use cases.\n\tfeedback, err := ParseMessageReport(elog, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tlog.Println(\"Feedback parsed successfully:\", feedback)\n}\n```\n"]}, "mox-mox-/lifecycle.go-Register": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *connections) Register(nc net.Conn, protocol, listener string) {\n# Natural Language Annotations: // Register adds a connection for receiving an immediate i/o deadline on shutdown.\n// When the connection is closed, Remove must be called to cancel the registration.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (c *connections) Register(nc net.Conn, protocol, listener string) {\n\t// Add the connection to the connections list/map for tracking\n\tc.mu.Lock()\n\tc.activeConns[nc] = struct{}{}\n\tc.mu.Unlock()\n\n\t// Set an immediate i/o deadline for the connection on shutdown\n\t// You should have a mechanism to trigger the shutdown\n\tgo func() {\n\t\t<-c.shutdownChan\n\t\tnc.SetDeadline(time.Now())\n\t}()\n\n\t// You may have some logging or other logic for registering the connection\n\t// Log the registration event\n\tfmt.Printf(\"Connection registered: %v, Protocol: %s, Listener: %s\\n\", nc.RemoteAddr(), protocol, listener)\n}\n\n// Assume connections is a struct that holds active connections and\n// a mechanism for handling shutdown\ntype connections struct {\n\tmu            sync.Mutex\n\tactiveConns   map[net.Conn]struct{}\n\tshutdownChan  chan struct{}\n}\n\n// Example struct initialization and methods are assumed to be defined elsewhere\n// You would likely have a NewConnections function and a Remove method.\n```"]}, "mox-smtpclient/dial.go-Dial": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n# Natural Language Annotations: // Dial connects to host by dialing ips, taking previous attempts in dialedIPs into\n// accounts (for greylisting, blocklisting and ipv4/ipv6).\n//\n// If the previous attempt used IPv4, this attempt will use IPv6 (useful in case\n// one of the IPs is in a DNSBL).\n//\n// The second attempt for an address family we prefer the same IP as earlier, to\n// increase our chances if remote is doing greylisting.\n//\n// Dial updates dialedIPs, callers may want to save it so it can be taken into\n// account for future delivery attempts.\n//\n// The first matching protocol family from localIPs is set for the local side\n// of the TCP connection.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\t\"time\"\n\n\t\"golang.org/x/exp/slog\"\n)\n\ntype Dialer interface {\n\tDialContext(ctx context.Context, network, address string) (net.Conn, error)\n}\n\ntype IPDomain string\n\nfunc Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n\tvar protocolPreference, chosenIP net.IP\n\n\t// Determine the next IP to try based on previous attempts\n\tfor _, candidateIP := range ips {\n\t\tfamily := ipFamily(candidateIP)\n\t\talreadyDialed := false\n\t\tfor _, prevIP := range dialedIPs[host.String()] {\n\t\t\tif candidateIP.Equal(prevIP) {\n\t\t\t\talreadyDialed = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !alreadyDialed {\n\t\t\tchosenIP = candidateIP\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// If all IPs tried in previous attempts, just reattempt with a different family\n\tif chosenIP == nil {\n\t\tfor _, candidateIP := range ips {\n\t\t\tfamily := ipFamily(candidateIP)\n\t\t\talreadyDialed := false\n\t\t\tfor _, prevIP := range dialedIPs[host.String()] {\n\t\t\t\tif !candidateIP.Equal(prevIP) && family != ipFamily(prevIP) {\n\t\t\t\t\talreadyDialed = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif !alreadyDialed {\n\t\t\t\tchosenIP = candidateIP\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\tif chosenIP == nil {\n\t\trerr = errors.New(\"no suitable IPs found for dialing\")\n\t\telog.Error(\"Dial failed\", slog.Error(rerr))\n\t\treturn\n\t}\n\n\t// Set the local address with appropriate address family\n\tvar localAddr *net.TCPAddr\n\tfor _, localIP := range localIPs {\n\t\tif ipFamily(localIP) == ipFamily(chosenIP) {\n\t\t\tlocalAddr = &net.TCPAddr{IP: localIP}\n\t\t\tbreak\n\t\t}\n\t}\n\n\t// Create a context with a timeout for dialing\n\tctxDial, cancel := context.WithTimeout(ctx, 30*time.Second)\n\tdefer cancel()\n\n\t// Dial the chosen IP\n\taddress := net.JoinHostPort(chosenIP.String(), strconv.Itoa(port))\n\tconn, rerr = dialer.DialContext(ctx, \"tcp\", address)\n\tif rerr != nil {\n\t\telog.Error(\"Dial attempt failed\", slog.String(\"ip\", chosenIP.String()), slog.Error(rerr))\n\t\treturn\n\t}\n\n\t// Record the IP that was successfully dialed\n\tif dialedIPs[host.String()] == nil {\n\t\tdialedIPs[host.String()] = []net.IP{}\n\t}\n\tdialedIPs[host.String()] = append(dialedIPs[host.String()], chosenIP)\n\n\t// Log the successful connection\n\telog.Info(\"Connection successful\", slog.String(\"host\", host.String()), slog.String(\"ip\", chosenIP.String()))\n\n\tip = chosenIP\n\treturn\n}\n\nfunc ipFamily(ip net.IP) int {\n\tif ip.To4() != nil {\n\t\treturn 4\n\t}\n\treturn 6\n}\n```"]}, "mox-smtpclient/gather.go-GatherIPs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GatherIPs(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, network string, host dns.IPDomain, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n# Natural Language Annotations: // GatherIPs looks up the IPs to try for connecting to host, with the IPs ordered\n// to take previous attempts into account. For use with DANE, the CNAME-expanded\n// name is returned, and whether the DNS responses were authentic.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"slog\"\n\t\"dns\"\n\t\"errors\"\n)\n\nfunc GatherIPs(\n\tctx context.Context,\n\telog *slog.Logger,\n\tresolver dns.Resolver,\n\tnetwork string,\n\thost dns.IPDomain,\n\tdialedIPs map[string][]net.IP,\n) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n\n\t// Perform DNS lookup for the given host\n\trecords, err := resolver.LookupHost(ctx, string(host))\n\tif err != nil {\n\t\telog.Error(\"DNS lookup failed\", slog.String(\"host\", string(host)), slog.Error(err))\n\t\treturn false, false, \"\", nil, false, err\n\t}\n\n\t// Track unique IPs and determine dualstack presence\n\tipSet := make(map[string]net.IP)\n\tvar ipv4, ipv6 int\n\n\tfor _, record := range records {\n\t\tip := net.ParseIP(record)\n\t\tif ip != nil {\n\t\t\tif ip.To4() != nil {\n\t\t\t\tipv4++\n\t\t\t} else if ip.To16() != nil {\n\t\t\t\tipv6++\n\t\t\t}\n\t\t\tipSet[record] = ip\n\t\t}\n\t}\n\n\t// Determine if the lookup is dualstack\n\tdualstack = ipv4 > 0 && ipv6 > 0\n\n\t// Append unique IP addresses to the list\n\tfor _, ip := range ipSet {\n\t\tips = append(ips, ip)\n\t}\n\n\t// Check previous connection attempts and adjust order of IPs\n\tif previousIPs, found := dialedIPs[string(host)]; found {\n\t\telog.Info(\"Found previous IPs for host\", slog.String(\"host\", string(host)), slog.Int(\"count\", len(previousIPs)))\n\t\t// Move previously dialled IPs to the front\n\t\tips = append(previousIPs, ips...)\n\t}\n\n\t// Assume responses are already validated for authenticity here\n\tauthentic = true\n\texpandedAuthentic = true\n\texpandedHost = dns.Domain(string(host))\n\n\telog.Info(\"IP gathering complete\", slog.String(\"host\", string(host)), slog.Int(\"ipCount\", len(ips)))\n\treturn authentic, expandedAuthentic, expandedHost, ips, dualstack, nil\n}\n```\n"]}, "mox-tlsrpt/report.go-TLSFailureDetails": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TLSFailureDetails(err error) (ResultType, string) {\n# Natural Language Annotations: // TLSFailureDetails turns errors encountered during TLS handshakes into a result\n// type and failure reason code for use with FailureDetails.\n//\n// Errors from crypto/tls, including local and remote alerts, from crypto/x509,\n// and generic i/o and timeout errors are recognized.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/tls\"\n\t\"crypto/x509\"\n\t\"errors\"\n\t\"io\"\n\t\"net\"\n)\n\n// ResultType is a placeholder for the actual result type in your application.\ntype ResultType int\n\nconst (\n\tResultTypeTLSHandshakeFailure ResultType = iota\n\tResultTypeX509CertError\n\tResultTypeIOError\n\tResultTypeTimeout\n\tResultTypeUnknown\n)\n\n// TLSFailureDetails turns errors encountered during TLS handshakes into a result\n// type and failure reason code for use with FailureDetails.\nfunc TLSFailureDetails(err error) (ResultType, string) {\n\tif err == nil {\n\t\treturn ResultTypeUnknown, \"No error provided\"\n\t}\n\n\t// Check for crypto/tls errors\n\tvar tlsAlert tls.AlertError\n\tif errors.As(err, &tlsAlert) {\n\t\treturn ResultTypeTLSHandshakeFailure, \"TLS Alert: \" + tlsAlert.Error()\n\t}\n\n\t// Check for crypto/x509.CertificateInvalidError\n\tvar certInvalidError x509.CertificateInvalidError\n\tif errors.As(err, &certInvalidError) {\n\t\treturn ResultTypeX509CertError, \"X509 Certificate Invalid: \" + certInvalidError.Error()\n\t}\n\n\t// Check for network errors\n\tvar netErr net.Error\n\tif errors.As(err, &netErr) {\n\t\tif netErr.Timeout() {\n\t\t\treturn ResultTypeTimeout, \"Network Timeout: \" + netErr.Error()\n\t\t}\n\t\treturn ResultTypeIOError, \"Network Error: \" + netErr.Error()\n\t}\n\n\t// Check for generic IO errors\n\tif errors.Is(err, io.EOF) {\n\t\treturn ResultTypeIOError, \"Unexpected EOF: \" + err.Error()\n\t}\n\n\t// If none of the above, return unknown\n\treturn ResultTypeUnknown, \"Unknown Error: \" + err.Error()\n}\n```"]}, "mox-tlsrpt/report.go-ParseMessage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n# Natural Language Annotations: // ParseMessage parses a Report from a mail message.\n// The maximum size of the message is 15MB, the maximum size of the\n// decompressed report is 20MB.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"compress/gzip\"\n\t\"errors\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\n\t\"golang.org/x/exp/slog\"\n)\n\n// Assume ReportJSON is a predefined structure that you need to return\ntype ReportJSON struct {\n\t// Define fields related to the report\n}\n\n// ParseMessage parses a Report from a mail message.\n// The maximum size of the message is 15MB, the maximum size of the\n// decompressed report is 20MB.\nfunc ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n\tconst MaxMessageSize = 15 * 1024 * 1024 // 15MB\n\tconst MaxDecompressedSize = 20 * 1024 * 1024 // 20MB\n\n\t// Create a limited section reader\n\treader := io.NewSectionReader(r, 0, MaxMessageSize)\n\n\t// Read the message data into memory\n\tmessageData, err := ioutil.ReadAll(reader)\n\tif err != nil {\n\t\telog.Error(\"error reading message data\", slog.String(\"error\", err.Error()))\n\t\treturn nil, err\n\t}\n\n\t// Attempt to decompress the message data\n\tdecompressedData, err := decompressData(messageData)\n\tif err != nil {\n\t\telog.Error(\"error decompressing data\", slog.String(\"error\", err.Error()))\n\t\treturn nil, err\n\t}\n\n\tif len(decompressedData) > MaxDecompressedSize {\n\t\terr := errors.New(\"decompressed data exceeds maximum allowed size\")\n\t\telog.Error(\"error with decompressed data size\", slog.String(\"error\", err.Error()))\n\t\treturn nil, err\n\t}\n\n\t// Here you would normally parse the decompressed data into a ReportJSON structure\n\treport := &ReportJSON{}\n\t// Imagine some parsing logic here...\n\n\treturn report, nil\n}\n\n// decompressData decompresses bytes using gzip\nfunc decompressData(data []byte) ([]byte, error) {\n\tbuf := bytes.NewReader(data)\n\tgz, err := gzip.NewReader(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer gz.Close()\n\n\tdecompressedData, err := ioutil.ReadAll(gz)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn decompressedData, nil\n}\n\nfunc main() {\n\t// Example of elog usage with the standard logger\n\telog := slog.New(slog.NewTextHandler(os.Stdout))\n\t// Example invocation, requires implementing the ReaderAt interface\n\t// ParseMessage(elog, yourReaderAtImplementation)\n}\n```\n"]}, "mox-spf/received.go-Header": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r Received) Header() string {\n# Natural Language Annotations: // Header returns a Received-SPF header including trailing crlf that can be\n// prepended to an incoming message.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (r Received) Header() string {\n    // Assuming Received type has required fields to construct SPF header\n    // Typically, these might include the SPF result, the receiving mail server, etc.\n    \n    // Format the SPF header according to the typical structure\n    header := \"Received-SPF: \" + r.spfResult + \" ( \" + r.receivingMailServer + \" )\\r\\n\"\n    \n    return header\n}\n```"]}, "mox-spf/spf.go-Evaluate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Evaluate(ctx context.Context, elog *slog.Logger, record *Record, resolver dns.Resolver, args Args) (rstatus Status, mechanism, rexplanation string, rauthentic bool, rerr error) {\n# Natural Language Annotations: // Evaluate evaluates the IP and names from args against the SPF DNS record for the domain.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"net\"\n\t\"strings\"\n\n\t\"golang.org/x/net/dns/dnsmessage\"\n\t\"golang.org/x/net/dns/dnsresolver\"\n)\n\ntype Status int\n\nconst (\n\tStatusNone Status = iota\n\tStatusPass\n\tStatusFail\n\tStatusSoftFail\n\tStatusNeutral\n\tStatusTempError\n\tStatusPermError\n)\n\ntype Record struct {\n\tDomain string\n}\n\ntype Args struct {\n\tIP   string\n\tName string\n}\n\ntype Resolver interface {\n\tLookupTXT(ctx context.Context, name string) ([]string, error)\n}\n\n// Evaluate evaluates the IP and names from args against the SPF DNS record for the domain.\nfunc Evaluate(ctx context.Context, elog *slog.Logger, record *Record, resolver dns.Resolver, args Args) (rstatus Status, mechanism, rexplanation string, rauthentic bool, rerr error) {\n\tspfRecords, err := resolver.LookupTXT(ctx, record.Domain)\n\tif err != nil {\n\t\telog.Error(\"DNS TXT record lookup failed\", err)\n\t\treturn StatusTempError, \"\", \"Could not fetch TXT record\", false, err\n\t}\n\n\tvar spfRecord string\n\tfor _, rec := range spfRecords {\n\t\tif strings.HasPrefix(rec, \"v=spf1\") {\n\t\t\tspfRecord = rec\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif spfRecord == \"\" {\n\t\treturn StatusNeutral, \"\", \"No SPF record found\", false, nil\n\t}\n\n\ttokens := strings.Fields(spfRecord)\n\tfor _, token := range tokens[1:] { // Skip the \"v=spf1\" prefix\n\t\tprefix, value := parseMechanism(token)\n\n\t\tswitch prefix {\n\t\tcase \"ip4\":\n\t\t\tip := net.ParseIP(args.IP)\n\t\t\tif ip != nil && ip.To4() != nil && ip.String() == value {\n\t\t\t\treturn StatusPass, prefix, \"\", true, nil\n\t\t\t}\n\t\tcase \"ip6\":\n\t\t\tip := net.ParseIP(args.IP)\n\t\t\tif ip != nil && ip.To16() != nil && ip.String() == value {\n\t\t\t\treturn StatusPass, prefix, \"\", true, nil\n\t\t\t}\n\t\tcase \"include\":\n\t\t\tincludeStatus, _, _, _, _ := Evaluate(ctx, elog, &Record{Domain: value}, resolver, args)\n\t\t\tif includeStatus == StatusPass {\n\t\t\t\treturn StatusPass, prefix, \"\", true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn StatusFail, \"none\", \"IP does not match any mechanisms\", false, nil\n}\n\nfunc parseMechanism(token string) (prefix, value string) {\n\tparts := strings.SplitN(token, \":\", 2)\n\tprefix = parts[0]\n\tif len(parts) > 1 {\n\t\tvalue = parts[1]\n\t}\n\treturn\n}\n```\n"]}, "mox-spf/parse.go-Record": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r Record) Record() (string, error) {\n# Natural Language Annotations: // Record returns an DNS record, to be configured as a TXT record for a domain,\n// e.g. a TXT record for example.com.\nPlease only return the code surrounded by ```\n", "response": ["```go\ntype Record struct {\n    Domain string // Domain name for the DNS TXT record\n    Value  string // The value/content of the TXT record\n}\n\n// Record returns a DNS record, configured as a TXT record for a domain.\nfunc (r Record) Record() (string, error) {\n    if r.Domain == \"\" {\n        return \"\", fmt.Errorf(\"domain name is required\")\n    }\n\n    if r.Value == \"\" {\n        return \"\", fmt.Errorf(\"TXT record value is required\")\n    }\n\n    // Format the TXT record as a string\n    formattedRecord := fmt.Sprintf(\"TXT record for %s: \\\"%s\\\"\", r.Domain, r.Value)\n    return formattedRecord, nil\n}\n```"]}, "mox-message/part.go-EnsurePart": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EnsurePart(elog *slog.Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n# Natural Language Annotations: // EnsurePart parses a part as with Parse, but ensures a usable part is always\n// returned, even if error is non-nil. If a parse error occurs, the message is\n// returned as application/octet-stream, and headers can still be read if they\n// were valid.\n//\n// If strict is set, fewer attempts are made to continue parsing when errors are\n// encountered, such as with invalid content-type headers or bare carriage returns.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"mime\"\n\t\"mime/multipart\"\n\t\"net/textproto\"\n\n\t\"golang.org/x/sync/errgroup\"\n\t\"log\"\n)\n\n// Part structure represents a part of a multipart message\ntype Part struct {\n\tHeader  textproto.MIMEHeader\n\tContent []byte\n\tValid   bool\n}\n\n// EnsurePart parses a part as with Parse, but ensures a usable part is always returned\nfunc EnsurePart(elog *log.Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n\tpart := Part{Valid: false}\n\n\t// Create a section reader from the ReaderAt interface\n\tsectionReader := io.NewSectionReader(r, 0, size)\n\n\tmr := multipart.NewReader(sectionReader, \"boundary_string_here\")\n\tp, err := mr.NextPart()\n\n\tif err != nil {\n\t\telog.Println(\"Error: unable to parse muiltipart part:\", err)\n\t\tpart.Header = make(textproto.MIMEHeader)\n\t\tpart.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\tpart.Content = make([]byte, 0)\n\t\treturn part, err\n\t}\n\n\tpart.Header = p.Header\n\tcontent, readErr := io.ReadAll(p)\n\n\tif readErr != nil && strict {\n\t\telog.Println(\"Strict mode: cannot continue parsing due to read error:\", readErr)\n\t\tpart.Content = make([]byte, 0)\n\t\treturn part, readErr\n\t}\n\n\tif readErr != nil && !strict {\n\t\telog.Println(\"Warning: unable to read complete content, treating as octet-stream:\", readErr)\n\t\tpart.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\tpart.Content = make([]byte, 0)\n\t} else {\n\t\tpart.Content = content\n\t\tpart.Valid = true\n\t}\n\n\t// Check for valid content type if strict\n\tif strict {\n\t\t_, _, parseErr := mime.ParseMediaType(part.Header.Get(\"Content-Type\"))\n\t\tif parseErr != nil {\n\t\t\telog.Println(\"Strict mode: invalid content type, resetting to octet-stream:\", parseErr)\n\t\t\tpart.Header.Set(\"Content-Type\", \"application/octet-stream\")\n\t\t\tpart.Valid = false\n\t\t}\n\t}\n\n\treturn part, nil\n}\n\nfunc main() {\n\t// Example of usage\n\telog := log.New(io.Discard, \"\", log.LstdFlags)\n\treader := io.ReaderAt(nil) // Placeholder: Provide appropriate ReaderAt for a real scenario\n\n\tsize := int64(0) // Provide appropriate size for a real scenario\n\tpart, err := EnsurePart(elog, true, reader, size)\n\tif err != nil {\n\t\tfmt.Println(\"An error occurred:\", err)\n\t}\n\tfmt.Println(\"Part header:\", part.Header)\n\tfmt.Println(\"Part content:\", string(part.Content))\n}\n```"]}, "mox-message/part.go-ParseNextPart": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n# Natural Language Annotations: // ParseNextPart parses the next (sub)part of this multipart message.\n// ParseNextPart returns io.EOF and a nil part when there are no more parts.\n// Only used for initial parsing of message. Once parsed, use p.Parts.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n    if p == nil || len(p.Parts) == 0 {\n        elog.Print(\"No more parts to parse, returning EOF\")\n        return nil, io.EOF\n    }\n\n    nextPart := p.Parts[0] // Assume Parts is a slice of *Part or similar\n    p.Parts = p.Parts[1:]  // Remove the first part from the list\n    elog.Print(\"Parsed next part successfully\")\n    return nextPart, nil\n}\n```"]}, "mox-message/messageid.go-MessageIDCanonical": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MessageIDCanonical(s string) (string, bool, error) {\n# Natural Language Annotations: // MessageIDCanonical parses the Message-ID, returning a canonical value that is\n// lower-cased, without <>, and no unneeded quoting. For matching in threading,\n// with References/In-Reply-To. If the message-id is invalid (e.g. no <>), an error\n// is returned. If the message-id could not be parsed as address (localpart \"@\"\n// domain), the raw value and the bool return parameter true is returned. It is\n// quite common that message-id's don't adhere to the localpart @ domain\n// syntax.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// MessageIDCanonical parses the Message-ID, returning a canonical value that is\n// lower-cased, without <>, and no unneeded quoting. For matching in threading,\n// with References/In-Reply-To. If the message-id is invalid (e.g. no <>), an error\n// is returned. If the message-id could not be parsed as address (localpart \"@\"\n// domain), the raw value and the bool return parameter true is returned. It is\n// quite common that message-id's don't adhere to the localpart @ domain\n// syntax.\nfunc MessageIDCanonical(s string) (string, bool, error) {\n\ts = strings.TrimSpace(s)\n\tif len(s) < 3 || s[0] != '<' || s[len(s)-1] != '>' {\n\t\treturn \"\", false, errors.New(\"invalid message-id format (missing angle brackets)\")\n\t}\n\n\t// Strip the angle brackets\n\trawID := s[1 : len(s)-1]\n\n\t// Check format for local-part \"@\" domain\n\tif !strings.Contains(rawID, \"@\") {\n\t\t// Raw value and true if it couldn\u2019t be parsed as localpart \"@\" domain\n\t\treturn rawID, true, nil\n\t}\n\n\t// Lower-cased canonical value\n\tcanonicalID := strings.ToLower(rawID)\n\n\treturn canonicalID, false, nil\n}\n```"]}, "mox-message/decode.go-DecodeReader": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DecodeReader(charset string, r io.Reader) io.Reader {\n# Natural Language Annotations: // DecodeReader returns a reader that reads from r, decoding as charset. If\n// charset is empty, us-ascii, utf-8 or unknown, the original reader is\n// returned and no decoding takes place.\nPlease only return the code surrounded by ```\n", "response": ["To create a function `DecodeReader` in Go that fulfills the provided requirements, we need to handle reading from an `io.Reader` while potentially decoding from specific character sets. Since Go's standard library supports UTF-8 but not other charsets directly, additional packages might be required for handling different encodings. However, given the task requirements, we'll demonstrate handling the specified character sets without external library dependencies for simplicity.\n\n```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"io\"\n\t\"io/ioutil\"\n)\n\nfunc DecodeReader(charset string, r io.Reader) io.Reader {\n\t// If charset is \"\", \"us-ascii\", \"utf-8\", or unknown, return the original reader\n\tif charset == \"\" || charset == \"us-ascii\" || charset == \"utf-8\" || charset == \"unknown\" {\n\t\treturn r\n\t}\n\n\t// Future implementation required for other encodings\n\t// This is just an illustrative placeholder since Go's standard library requires\n\t// third-party packages to handle many charset conversions.\n\t\n\t// Example: if you wanted to expand this function, you could potentially use\n\t// a library like golang.org/x/text/encoding to decode charsets\n\t//\n\t// rdr := transform.NewReader(r, encoding.ReplaceCharset(charset).NewDecoder())\n\n\t// For now, since we only conditionally handle character sets, we'll\n\t// just return the reader as is (if it's not one of the specified common sets).\n\treturn r\n}\n\nfunc main() {\n\tdata := \"This is some UTF-8 data\"\n\treader := bytes.NewReader([]byte(data))\n\toutReader := DecodeReader(\"utf-8\", reader)\n\n\tresult, _ := ioutil.ReadAll(outReader)\n\tprintln(string(result))\n}\n```\n\nThis basic implementation of `DecodeReader` tackles the specific requirements but doesn't apply any charset transformation beyond checking specified common character sets. Realistically, handling other charsets would involve using third-party libraries."]}, "mox-message/referencedids.go-ReferencedIDs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReferencedIDs(references []string, inReplyTo []string) ([]string, error) {\n# Natural Language Annotations: // ReferencedIDs returns the Message-IDs referenced from the References header(s),\n// with a fallback to the In-Reply-To header(s). The ids are canonicalized for\n// thread-matching, like with MessageIDCanonical. Empty message-id's are skipped.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// MessageIDCanonical canonicalizes a given message ID.\nfunc MessageIDCanonical(messageID string) string {\n\t// Canonicalization logic can be implemented as required.\n\t// For this example, we'll assume it simply trims whitespace and converts to lowercase.\n\treturn strings.TrimSpace(strings.ToLower(messageID))\n}\n\n// ReferencedIDs returns the canonicalized Message-IDs from the References headers,\n// fallback to the In-Reply-To headers if necessary.\nfunc ReferencedIDs(references []string, inReplyTo []string) ([]string, error) {\n\tvar messageIDs []string\n\n\t// Collect message IDs from references\n\tfor _, refHeader := range references {\n\t\tids := strings.Fields(refHeader) // assuming message-ids are space separated\n\t\tfor _, id := range ids {\n\t\t\tcanonicalID := MessageIDCanonical(id)\n\t\t\tif canonicalID != \"\" {\n\t\t\t\tmessageIDs = append(messageIDs, canonicalID)\n\t\t\t}\n\t\t}\n\t}\n\n\t// Fallback to in-reply-to headers if no valid references are found\n\tif len(messageIDs) == 0 {\n\t\tfor _, replyHeader := range inReplyTo {\n\t\t\tids := strings.Fields(replyHeader) // assuming message-ids are space separated\n\t\t\tfor _, id := range ids {\n\t\t\t\tcanonicalID := MessageIDCanonical(id)\n\t\t\t\tif canonicalID != \"\" {\n\t\t\t\t\tmessageIDs = append(messageIDs, canonicalID)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif len(messageIDs) == 0 {\n\t\treturn nil, errors.New(\"no valid message IDs found in either References or In-Reply-To headers\")\n\t}\n\n\treturn messageIDs, nil\n}\n```\n"]}, "mox-message/authresults.go-ParseAuthResults": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseAuthResults(s string) (ar AuthResults, err error) {\n# Natural Language Annotations: // ParseAuthResults parses a Authentication-Results header value.\n//\n// Comments are not populated in the returned AuthResults.\n// Both crlf and lf line-endings are accepted. The input string must end with\n// either crlf or lf.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"strings\"\n)\n\n// AuthResults represents the parsed result of an Authentication-Results header\ntype AuthResults struct {\n\tAuthServID string\n\tResults    []Result\n}\n\n// Result represents a single authentication result\ntype Result struct {\n\tMethod  string\n\tValue   string\n\tDetails map[string]string\n}\n\n// ParseAuthResults parses an Authentication-Results header value.\n// Both crlf and lf line-endings are accepted. The input string must end with\n// either crlf or lf.\nfunc ParseAuthResults(s string) (ar AuthResults, err error) {\n\t// Trim any final newline characters\n\ts = strings.TrimRight(s, \"\\r\\n\")\n\tif s == \"\" {\n\t\treturn ar, errors.New(\"input string is empty\")\n\t}\n\n\tparts := strings.SplitN(s, \";\", 2)\n\tif len(parts) < 2 {\n\t\treturn ar, errors.New(\"invalid format: missing semicolon\")\n\t}\n\n\tar.AuthServID = strings.TrimSpace(parts[0])\n\tresultsRaw := strings.Split(parts[1], \";\")\n\n\tfor _, resultRaw := range resultsRaw {\n\t\tresultRaw = strings.TrimSpace(resultRaw)\n\t\tif resultRaw == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tmethodParts := strings.SplitN(resultRaw, \"=\", 2)\n\t\tif len(methodParts) != 2 {\n\t\t\treturn ar, errors.New(\"invalid format: missing equals sign\")\n\t\t}\n\n\t\tmethod := strings.TrimSpace(methodParts[0])\n\t\tvalueDetails := strings.TrimSpace(methodParts[1])\n\t\tvalueParts := strings.SplitN(valueDetails, \" \", 2)\n\t\tvalue := valueParts[0]\n\n\t\tvar details map[string]string\n\t\tif len(valueParts) > 1 {\n\t\t\tdetails = parseDetails(valueParts[1])\n\t\t}\n\n\t\tar.Results = append(ar.Results, Result{\n\t\t\tMethod:  method,\n\t\t\tValue:   value,\n\t\t\tDetails: details,\n\t\t})\n\t}\n\n\treturn ar, nil\n}\n\nfunc parseDetails(detailsString string) map[string]string {\n\tdetails := make(map[string]string)\n\tdetailParts := strings.Fields(detailsString)\n\n\tfor _, part := range detailParts {\n\t\tkeyValue := strings.SplitN(part, \"=\", 2)\n\t\tif len(keyValue) == 2 {\n\t\t\tkey := strings.TrimSpace(keyValue[0])\n\t\t\tvalue := strings.TrimSpace(keyValue[1])\n\t\t\tdetails[key] = value\n\t\t}\n\t}\n\n\treturn details\n}\n```\n"]}, "mox-store/msgreader.go-FileMsgReader": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FileMsgReader(prefix []byte, msgFile *os.File) *MsgReader {\n# Natural Language Annotations: // FileMsgReader makes a MsgReader for an open file.\n// If initialization fails, reads will return the error.\n// Only call close on the returned MsgReader if you want to close msgFile.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n)\n\n// MsgReader is a struct that wraps around a file and a prefix.\ntype MsgReader struct {\n\tprefix  []byte\n\tmsgFile *os.File\n\terr     error\n}\n\n// Read reads from the file, prepending the prefix to each read segment.\nfunc (mr *MsgReader) Read(p []byte) (int, error) {\n\tif mr.err != nil {\n\t\treturn 0, mr.err\n\t}\n\n\tprefixLength := copy(p, mr.prefix)\n\tn, err := mr.msgFile.Read(p[prefixLength:])\n\treturn n + prefixLength, err\n}\n\n// Close closes the MsgReader and optionally the underlying file if required.\nfunc (mr *MsgReader) Close() error {\n\tif mr.msgFile != nil {\n\t\treturn mr.msgFile.Close()\n\t}\n\treturn nil\n}\n\n// FileMsgReader makes a MsgReader for an open file.\n// If initialization fails, reads will return the error.\n// Only call close on the returned MsgReader if you want to close msgFile.\nfunc FileMsgReader(prefix []byte, msgFile *os.File) *MsgReader {\n\tif msgFile == nil {\n\t\treturn &MsgReader{\n\t\t\terr: errors.New(\"msgFile is nil\"),\n\t\t}\n\t}\n\n\treturn &MsgReader{\n\t\tprefix:  prefix,\n\t\tmsgFile: msgFile,\n\t\terr:     nil,\n\t}\n}\n```"]}, "mox-store/import.go-ParseDovecotKeywordsFlags": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseDovecotKeywordsFlags(r io.Reader, log mlog.Log) ([]string, error) {\n# Natural Language Annotations: // ParseDovecotKeywordsFlags attempts to parse a dovecot-keywords file. It only\n// returns valid flags/keywords, as lower-case. If an error is encountered and\n// returned, any keywords that were found are still returned. The returned list has\n// both system/well-known flags and custom keywords.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"strings\"\n\n\t\"github.com/some/package/mlog\" // Replace with the actual package import path for mlog\n)\n\n// ParseDovecotKeywordsFlags attempts to parse a dovecot-keywords file.\n// It only returns valid flags/keywords, as lower-case.\n// If an error is encountered and returned, any keywords that were found\n// are still returned. The returned list has both system/well-known flags\n// and custom keywords.\nfunc ParseDovecotKeywordsFlags(r io.Reader, log mlog.Log) ([]string, error) {\n\tvar keywords []string\n\n\t// Create a scanner to read the file line by line\n\tscanner := bufio.NewScanner(r)\n\n\t// Possible well-known/system flags in Dovecot\n\tsystemFlags := map[string]bool{\n\t\t\"\\\\seen\":      true,\n\t\t\"\\\\answered\":  true,\n\t\t\"\\\\flagged\":   true,\n\t\t\"\\\\deleted\":   true,\n\t\t\"\\\\draft\":     true,\n\t\t\"\\\\recent\":    true,\n\t\t// Add more system flags if necessary\n\t}\n\n\tfor scanner.Scan() {\n\t\tline := strings.TrimSpace(scanner.Text())\n\t\tif line == \"\" {\n\t\t\tcontinue\n\t\t}\n\n\t\tline = strings.ToLower(line)\n\n\t\tif systemFlags[line] || isCustomKeyword(line) {\n\t\t\tkeywords = append(keywords, line)\n\t\t} else {\n\t\t\tlog.Warning(fmt.Sprintf(\"Unknown keyword or flag: %s\", line))\n\t\t}\n\t}\n\n\t// Check if there was an error during scanning\n\tif err := scanner.Err(); err != nil {\n\t\tlog.Error(\"Error reading dovecot-keywords file\", err)\n\t\treturn keywords, err\n\t}\n\n\treturn keywords, nil\n}\n\n// isCustomKeyword checks if a given string is a valid custom keyword\n// As an example, custom keywords should not contain whitespace or special chars\nfunc isCustomKeyword(keyword string) bool {\n\tfor _, char := range keyword {\n\t\tif !isAlnum(char) && string(char) != \"-\" && string(char) != \"_\" {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n// isAlnum checks if a character is alphanumeric (A-Z, a-z, 0-9)\nfunc isAlnum(char rune) bool {\n\treturn (char >= 'a' && char <= 'z') || (char >= 'A' && char <= 'Z') || (char >= '0' && char <= '9')\n}\n```"]}, "mox-store/account.go-MessageRuleset": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MessageRuleset(log mlog.Log, dest config.Destination, m *Message, msgPrefix []byte, msgFile *os.File) *config.Ruleset {\n# Natural Language Annotations: // MessageRuleset returns the first ruleset (if any) that matches the message\n// represented by msgPrefix and msgFile, with smtp and validation fields from m.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc MessageRuleset(log mlog.Log, dest config.Destination, m *Message, msgPrefix []byte, msgFile *os.File) *config.Ruleset {\n    // Retrieve possible rulesets from the destination\n    possibleRulesets := dest.GetRulesets()\n\n    // Iterate over each ruleset and try to match it against the message\n    for _, ruleset := range possibleRulesets {\n        // Check if the ruleset matches the message by comparing fields\n        // This includes checking the smtp fields and validation fields, along with msgPrefix and msgFile\n\n        // Check if smtp fields match\n        if !ruleset.MatchesSMTP(m.SMTP) {\n            continue\n        }\n\n        // Check if validation fields match        \n        if !ruleset.MatchesValidation(m.Validation) {\n            continue\n        }\n\n        // Check if the message prefix matches\n        if !ruleset.MatchesPrefix(msgPrefix) {\n            continue\n        }\n\n        // Check if the message file matches\n        if !ruleset.MatchesFile(msgFile) {\n            continue\n        }\n\n        // If all checks passed, return the current ruleset\n        return ruleset\n    }\n\n    // No matching ruleset found, return nil\n    return nil\n}\n```\n"]}, "mox-smtp/address.go-ParseAddress": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseAddress(s string) (address Address, err error) {\n# Natural Language Annotations: // ParseAddress parses an email address. UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"net/mail\"\n)\n\n// Address represents a parsed email address.\ntype Address struct {\n\tName    string\n\tAddress string\n}\n\n// ErrBadAddress is returned when the email address is invalid.\nvar ErrBadAddress = errors.New(\"invalid address\")\n\n// ParseAddress parses an email address. UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nfunc ParseAddress(s string) (address Address, err error) {\n\t// Use the standard library's mail package to parse the address.\n\tparsedAddress, err := mail.ParseAddress(s)\n\tif err != nil {\n\t\treturn Address{}, ErrBadAddress\n\t}\n\n\t// Return the parsed address.\n\treturn Address{\n\t\tName:    parsedAddress.Name,\n\t\tAddress: parsedAddress.Address,\n\t}, nil\n}\n```"]}, "mox-smtp/address.go-ParseLocalpart": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseLocalpart(s string) (localpart Localpart, err error) {\n# Natural Language Annotations: // ParseLocalpart parses the local part.\n// UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"unicode/utf8\"\n)\n\n// Define an error for invalid addresses\nvar ErrBadAddress = errors.New(\"invalid local part address\")\n\n// Define a Localpart type, you can adjust this based on your use case\ntype Localpart string\n\n// ParseLocalpart parses the local part\n// UTF-8 is allowed\n// Returns ErrBadAddress for invalid addresses\nfunc ParseLocalpart(s string) (localpart Localpart, err error) {\n\t// Check if the string s is a valid UTF-8 encoded string\n\tif !utf8.ValidString(s) {\n\t\treturn \"\", ErrBadAddress\n\t}\n\n\t// Additional checks for the local part can be added here\n\n\t// If all checks pass, return the local part as a Localpart type\n\treturn Localpart(s), nil\n}\n\n// Below is an example of how you might use the ParseLocalpart function\n// func main() {\n//     lp, err := ParseLocalpart(\"example_localpart\")\n//     if err != nil {\n//         fmt.Println(\"Error:\", err)\n//     } else {\n//         fmt.Println(\"Parsed localpart:\", lp)\n//     }\n// }\n```\nThis Go code defines a function `ParseLocalpart` that validates a string as a local part, checking that it's a valid UTF-8 encoded string and returning an error if it's not. You can further customize this function based on any additional rules you have for what constitutes a valid local part."]}, "mox-smtp/data.go-DataWrite": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DataWrite(w io.Writer, r io.Reader) error {\n# Natural Language Annotations: // DataWrite reads data (a mail message) from r, and writes it to smtp\n// connection w with dot stuffing, as required by the SMTP data command.\n//\n// Messages with bare carriage returns or bare newlines result in an error.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n)\n\nfunc DataWrite(w io.Writer, r io.Reader) error {\n\tscanner := bufio.NewScanner(r)\n\tscanner.Split(bufio.ScanLines) // Ensure we read line by line\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\n\t\tif strings.Contains(line, \"\\r\\n\") {\n\t\t\t// Valid CR + LF, do nothing special\n\t\t\tline = strings.ReplaceAll(line, \"\\r\\n\", \"\\n\")\n\t\t} else if strings.Contains(line, \"\\n\") || strings.Contains(line, \"\\r\") {\n\t\t\t// Bare LF or CR found, this is an error\n\t\t\treturn errors.New(\"input contains bare newlines or carriage returns\")\n\t\t}\n\n\t\t// Implement dot-stuffing\n\t\tif strings.HasPrefix(line, \".\") {\n\t\t\tline = \".\" + line\n\t\t}\n\n\t\tif _, err := fmt.Fprintf(w, \"%s\\n\", line); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// Check for errors while scanning\n\tif err := scanner.Err(); err != nil {\n\t\treturn err\n\t}\n\n\t// End with \\r\\n.\\r\\n as per SMTP protocol requirements\n\tendSequence := []byte(\"\\r\\n.\\r\\n\")\n\tif _, err := w.Write(endSequence); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```"]}, "mox-scram/scram.go-NewServer": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (server *Server, rerr error) {\n# Natural Language Annotations: // NewServer returns a server given the first SCRAM message from a client.\n//\n// If cs is set, the PLUS variant can be negotiated, binding the authentication\n// exchange to the TLS channel (preventing MitM attempts). If a client\n// indicates it supports the PLUS variant, but thinks the server does not, the\n// authentication attempt will fail.\n//\n// If channelBindingRequired is set, the client has indicated it will do channel\n// binding and not doing so will cause the authentication to fail.\n//\n// The sequence for data and calls on a server:\n//\n//   - Read initial data from client, call NewServer (this call), then ServerFirst and write to the client.\n//   - Read response from client, call Finish or FinishFinal and write the resulting string.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/subtle\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"hash\"\n\t\"strings\"\n\n\t\"golang.org/x/crypto/pbkdf2\"\n\t\"golang.org/x/crypto/scram\"\n\t\"os\"\n\n\t\"crypto/tls\"\n)\n\ntype Server struct {\n\tclientFirst                  []byte\n\tcs                           *tls.ConnectionState\n\th                            func() hash.Hash\n\tchannelBindingRequired       bool\n\tclientNonce                  string\n\tserverNonce                  string\n\tsaltedPassword               []byte\n\tclientSupportsChannelBinding bool\n}\n\nfunc (s *Server) ServerFirst() (serverFirstMessage string, rerr error) {\n\tserverNonce := s.serverNonce\n\tsaltedPassword, err := s.generateSaltedPassword()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tstoredKey, serverKey := s.generateKeys(saltedPassword)\n\n\ts.serverNonce = generateNonce()\n\tserverFirstMessage = \"r=\" + s.clientNonce + s.serverNonce + \",s=\" + base64.StdEncoding.EncodeToString(saltedPassword)\n\tserverFirstMessage += \",i=4096\" // Using a hardcoded iteration count of 4096\n\treturn serverFirstMessage, nil\n}\n\nfunc (s *Server) Finish(response []byte) (result string, rerr error) {\n\t// Process and validate the response from client\n\t// Place logic here\n\n\treturn \"result_string\", nil\n}\n\nfunc NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (server *Server, rerr error) {\n\t// Parse clientFirst message to extract client nonce and other details\n\tclientFirstParts := strings.Split(string(clientFirst), \",\")\n\tif len(clientFirstParts) < 2 {\n\t\treturn nil, errors.New(\"invalid client first message\")\n\t}\n\tclientNonce := strings.Split(clientFirstParts[0], \"=\")[1]\n\tchannelBindingSupported := strings.Contains(clientFirstParts[1], \"p=tls-server-end-point\")\n\n\t// Create the server object\n\ts := &Server{\n\t\tclientFirst:                  clientFirst,\n\t\tcs:                           cs,\n\t\th:                            h,\n\t\tchannelBindingRequired:       channelBindingRequired,\n\t\tclientNonce:                  clientNonce,\n\t\tserverNonce:                  generateNonce(),\n\t\tclientSupportsChannelBinding: channelBindingSupported,\n\t}\n\n\t// If channel binding is required but not supported, return an error\n\tif channelBindingRequired && !channelBindingSupported {\n\t\treturn nil, errors.New(\"channel binding required but not supported\")\n\t}\n\n\treturn s, nil\n}\n\nfunc (s *Server) generateSaltedPassword() ([]byte, error) {\n\t// Should be replaced with a real password retrieval and salting mechanism\n\tpassword := \"secret_password\"\n\tsalt := make([]byte, 16)\n\t_, err := rand.Read(salt)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn pbkdf2.Key([]byte(password), salt, 4096, s.h().Size(), s.h), nil\n}\n\nfunc (s *Server) generateKeys(saltedPassword []byte) ([]byte, []byte) {\n\t// Simplified key generation\n\tstoredKey := saltedPassword\n\tserverKey := saltedPassword\n\treturn storedKey, serverKey\n}\n\nfunc generateNonce() string {\n\tnonce := make([]byte, 16)\n\t_, err := rand.Read(nonce)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn base64.StdEncoding.EncodeToString(nonce)\n}\n```\n"]}, "mox-scram/scram.go-ServerFirst": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Server) ServerFirst(iterations int, salt []byte) (string, error) {\n# Natural Language Annotations: // ServerFirst returns the string to send back to the client. To be called after NewServer.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *Server) ServerFirst(iterations int, salt []byte) (string, error) {\n    // Ensure that the server instance is initialized\n    if s == nil {\n        return \"\", fmt.Errorf(\"server instance is not initialized\")\n    }\n    \n    // Validate the iterations count\n    if iterations <= 0 {\n        return \"\", fmt.Errorf(\"iterations must be greater than zero\")\n    }\n\n    // Convert the salt byte array to a base64 string\n    saltEncoded := base64.StdEncoding.EncodeToString(salt)\n\n    // Construct the message to send back to the client\n    // Example format: \"r=<nonce>,s=<salt>,i=<iterations>\"\n    message := fmt.Sprintf(\"r=%s,s=%s,i=%d\", s.nonce, saltEncoded, iterations)\n\n    return message, nil\n}\n```"]}, "mox-scram/scram.go-Finish": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n# Natural Language Annotations: // Finish takes the final client message, and the salted password (probably\n// from server storage), verifies the client, and returns a message to return\n// to the client. If err is nil, authentication was successful. If the\n// authorization requested is not acceptable, the server should call\n// FinishError instead.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/hmac\"\n\t\"crypto/sha256\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"fmt\"\n)\n\ntype Server struct {\n\t// Add any additional fields if needed\n}\n\n// mock implementation of FinishError, define it based on actual requirements\nfunc (s *Server) FinishError() (serverFinal string, rerr error) {\n\treturn \"\", errors.New(\"authentication failed: authorization requested is not acceptable\")\n}\n\n// Finish takes the final client message, and the salted password (probably\n// from server storage), verifies the client, and returns a message to return\n// to the client. If err is nil, authentication was successful. If the\n// authorization requested is not acceptable, the server should call\n// FinishError instead.\nfunc (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n\t// Step 1: Verify the client's message using HMAC with the salted password\n\t// This example assumes that the clientFinal is a HMAC signature of some data using the saltedPassword as the key\n\n\t// Derive server signature using the provided saltedPassword and some server data (e.g. a challenge or a nonce)\n\tserverData := []byte(\"some server data\") // This would typically be derived from the authentication process\n\texpectedHMAC := hmac.New(sha256.New, saltedPassword)\n\texpectedHMAC.Write(serverData)\n\texpectedSignature := expectedHMAC.Sum(nil)\n\n\t// Step 2: Compare client provided signature (clientFinal) with expected signature\n\tif !hmac.Equal(clientFinal, expectedSignature) {\n\t\t// If the signatures don't match, return an authentication failure\n\t\treturn s.FinishError()\n\t}\n\n\t// Step 3: If verification succeeds, construct the server's final message\n\t// This message might include success confirmation, session identifier, or other data\n\tserverFinal = base64.StdEncoding.EncodeToString([]byte(\"authentication successful\"))\n\n\t// Return the final server message and nil error indicating successful authentication\n\treturn serverFinal, nil\n}\n\nfunc main() {\n\tserver := &Server{}\n\tclientFinal := []byte(\"client's signed message\")\n\tsaltedPassword := []byte(\"server's known salted password\")\n\tserverFinal, err := server.Finish(clientFinal, saltedPassword)\n\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Server Final Message:\", serverFinal)\n\t}\n}\n```\n"]}, "mox-scram/scram.go-ClientFirst": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Client) ClientFirst() (clientFirst string, rerr error) {\n# Natural Language Annotations: // ClientFirst returns the first client message to write to the server.\n// No channel binding is done/supported.\n// A random nonce is generated.\nPlease only return the code surrounded by ```\n", "response": ["```go\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"errors\"\n\t\"io\"\n)\n\n// Client represents a client structure\ntype Client struct {\n\tnonce string\n}\n\n// generateNonce generates a random nonce\nfunc generateNonce(size int) (string, error) {\n\tnonce := make([]byte, size)\n\tif _, err := io.ReadFull(rand.Reader, nonce); err != nil {\n\t\treturn \"\", err\n\t}\n\treturn base64.StdEncoding.EncodeToString(nonce), nil\n}\n\n// ClientFirst returns the first client message to write to the server.\nfunc (c *Client) ClientFirst() (clientFirst string, rerr error) {\n\tnonce, err := generateNonce(24) // size of nonce can typically be around 24 bytes\n\tif err != nil {\n\t\treturn \"\", errors.New(\"failed to generate nonce\")\n\t}\n\tc.nonce = nonce\n\tclientFirst = \"n,,n=*,r=\" + nonce // typical format for a SCRAM message\n\treturn clientFirst, nil\n}\n```"]}, "mox-scram/scram.go-ServerFinal": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Client) ServerFinal(serverFinal []byte) (rerr error) {\n# Natural Language Annotations: // ServerFinal processes the final message from the server, verifying that the\n// server knows the password.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"hash\"\n\t\"hash/hmac\"\n)\n\n// Assuming the Client struct has a Password field and a computed serverSignature\ntype Client struct {\n\tPassword        string\n\tserverSignature []byte\n}\n\n// HMAC function to compute HMAC using a given hash function and key\nfunc computeHMAC(h func() hash.Hash, key, data []byte) []byte {\n\tmac := hmac.New(h, key)\n\tmac.Write(data)\n\treturn mac.Sum(nil)\n}\n\n// Mock hash function placeholder for illustration. In a real scenario, use an appropriate hash function.\nfunc mockHash() hash.Hash {\n\treturn hmac.NewHashFunction() // Replace with an actual hash function\n}\n\n// ServerFinal processes the final message from the server, verifying that the\n// server knows the password.\nfunc (c *Client) ServerFinal(serverFinal []byte) (rerr error) {\n\t// We assume that the serverFinal message contains the server proof or some data we need to verify\n\t// For illustration, we'll compute a serverProof using HMAC\n\t// In a real implementation, you would use the real server proof data and the appropriate hash function\n\t\n\t// Compute expected server proof based on known serverSignature\n\texpectedServerProof := computeHMAC(mockHash, []byte(c.Password), c.serverSignature)\n\t\n\t// Verify that the server's final message matches the expected server proof\n\tif !hmac.Equal(serverFinal, expectedServerProof) {\n\t\treturn errors.New(\"server proof does not match, server might not know the password\")\n\t}\n\n\t// If everything matches, return nil to indicate success\n\treturn nil\n}\n\n// Example usage\nfunc main() {\n\tclient := &Client{\n\t\tPassword:        \"secretPassword\",\n\t\tserverSignature: []byte(\"serverSignature\"),\n\t}\n\n\t// Fake server final message matching the expected proof\n\tserverFinal := computeHMAC(mockHash, []byte(client.Password), client.serverSignature)\n\n\t// Process server final message\n\tif err := client.ServerFinal(serverFinal); err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t} else {\n\t\tfmt.Println(\"Server verified successfully.\")\n\t}\n}\n```\n"]}, "mox-autotls/autotls.go-SetAllowedHostnames": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n# Natural Language Annotations: // SetAllowedHostnames sets a new list of allowed hostnames for automatic TLS.\n// After setting the host names, a goroutine is start to check that new host names\n// are fully served by publicIPs (only if non-empty and there is no unspecified\n// address in the list). If no, log an error with a warning that ACME validation\n// may fail.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"net\"\n\tmlog \"path_to_mlog_package\"\n\tdns \"path_to_dns_package\"\n\t\"sync\"\n)\n\ntype Manager struct {\n\tallowedHostnames map[dns.Domain]struct{}\n\tmu               sync.RWMutex\n}\n\nfunc (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n\t// Set the allowed hostnames in the manager\n\tm.mu.Lock()\n\tm.allowedHostnames = hostnames\n\tm.mu.Unlock()\n\n\tif !checkHosts || len(publicIPs) == 0 {\n\t\treturn\n\t}\n\n\t// If there are public IPs provided, start a goroutine to validate hostnames\n\tgo func() {\n\t\tfor hostname := range hostnames {\n\t\t\tips, err := resolver.LookupIPAddr(nil, string(hostname))\n\t\t\tif err != nil {\n\t\t\t\tlog.Errorf(\"Failed to resolve hostname %s: %v\", hostname, err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif !areAllIPsServed(ips, publicIPs) {\n\t\t\t\tlog.Errorf(\"Hostname %s is not fully served by the provided public IPs. This may cause ACME validation to fail.\", hostname)\n\t\t\t}\n\t\t}\n\t}()\n}\n\nfunc areAllIPsServed(resolvedIPs []net.IPAddr, publicIPs []string) bool {\n\tpublicIPSet := make(map[string]struct{}, len(publicIPs))\n\tfor _, ip := range publicIPs {\n\t\tpublicIPSet[ip] = struct{}{}\n\t}\n\n\tfor _, ip := range resolvedIPs {\n\t\tif _, exists := publicIPSet[ip.String()]; !exists {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n```"]}, "mox-autotls/autotls.go-HostPolicy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n# Natural Language Annotations: // HostPolicy decides if a host is allowed for use with ACME, i.e. whether a\n// certificate will be returned if present and/or will be requested if not yet\n// present. Only hosts added with SetAllowedHostnames are allowed. During shutdown,\n// no new connections are allowed.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n    // Check if the Manager is in the process of shutting down; if so, disallow new connections\n    if m.isShuttingDown {\n        return fmt.Errorf(\"disallowed connection attempt during shutdown for host: %s\", host)\n    }\n\n    // Check if the host is in the list of allowed hostnames\n    m.lock.RLock()\n    defer m.lock.RUnlock()\n    if _, allowed := m.allowedHostnames[host]; !allowed {\n        return fmt.Errorf(\"host %s is not allowed\", host)\n    }\n\n    // The host is allowed\n    return nil\n}\n```"]}, "mox-imapserver/protocol.go-containsSeq": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (ss numSet) containsSeq(seq msgseq, uids []store.UID, searchResult []store.UID) bool {\n# Natural Language Annotations: // containsSeq returns whether seq is in the numSet, given uids and (saved) searchResult.\n// uids and searchResult must be sorted. searchResult can have uids that are no longer in uids.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (ss numSet) containsSeq(seq msgseq, uids []store.UID, searchResult []store.UID) bool {\n    // Check if searchResult has elements not in uids, remove them\n    filteredSearchResult := filterUids(searchResult, uids)\n    \n    // Sequentially check if seq exists in filtered searchResult\n    for i := 0; i <= len(filteredSearchResult)-len(seq); i++ {\n        match := true\n        for j := 0; j < len(seq); j++ {\n            if seq[j] != filteredSearchResult[i+j] {\n                match = false\n                break\n            }\n        }\n        if match {\n            return true\n        }\n    }\n    return false\n}\n\n// Helper function to remove UIDs in searchResult which are not present in uids\nfunc filterUids(searchResult []store.UID, uids []store.UID) []store.UID {\n    var filteredResult []store.UID\n    i, j := 0, 0\n\n    for i < len(searchResult) && j < len(uids) {\n        if searchResult[i] < uids[j] {\n            i++\n        } else if searchResult[i] > uids[j] {\n            j++\n        } else {\n            filteredResult = append(filteredResult, searchResult[i])\n            i++\n            j++\n        }\n    }\n    \n    return filteredResult\n}\n```"]}, "mox-imapserver/protocol.go-interpretStar": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s numSet) interpretStar(uids []store.UID) numSet {\n# Natural Language Annotations: // interpretStar returns a numset that interprets stars in a numset, returning a new\n// numset without stars with increasing first/last.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"sort\"\n\t\"strings\"\n)\n\ntype UID string\n\ntype numSet []int\n\n// interpretStar returns a numset that interprets stars in a numset, returning a new\n// numset without stars with increasing first/last.\nfunc (s numSet) interpretStar(uids []UID) numSet {\n\tvar result numSet\n\tstarIndex := strings.Index(strings.Join(s, \"\"), \"*\")\n\n\tif starIndex == -1 {\n\t\treturn s\n\t}\n\n\tfor _, uid := range uids {\n\t\tnumVal := extractNumeric(uid)\n\t\tresult = append(result, numVal)\n\t}\n\n\tsort.Ints(result)\n\n\treturn result\n}\n\n// Helper function to extract numeric value from UID string\nfunc extractNumeric(uid UID) int {\n\t// Assuming UID strings are well-formed and contain numbers\n\tnumStr := \"\"\n\tfor _, char := range uid {\n\t\tif char >= '0' && char <= '9' {\n\t\t\tnumStr += string(char)\n\t\t}\n\t}\n\tnum, _ := strconv.Atoi(numStr)\n\treturn num\n}\n```"]}, "mox-http/web.go-ServeHTTP": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *serve) ServeHTTP(xw http.ResponseWriter, r *http.Request) {\n# Natural Language Annotations: // ServeHTTP is the starting point for serving HTTP requests. It dispatches to the\n// right pathHandler or WebHandler, and it generates access logs and tracks\n// metrics.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *serve) ServeHTTP(xw http.ResponseWriter, r *http.Request) {\n    // Generate access logs\n    log.Printf(\"Received request: %s %s from %s\", r.Method, r.URL.Path, r.RemoteAddr)\n\n    // Track metrics\n    metrics.RecordRequest(r.Method, r.URL.Path)\n\n    // Dispatch to the right handler\n    switch r.URL.Path {\n    case \"/path1\":\n        s.pathHandler1(xw, r)\n    case \"/path2\":\n        s.pathHandler2(xw, r)\n    // Add more paths and handlers as needed\n    default:\n        // Use a default web handler or return 404 not found if the path doesn't match\n        http.NotFound(xw, r)\n    }\n}\n```\n"]}, "mox-moxio/bufpool.go-Readline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n# Natural Language Annotations: // Readline reads a \\n- or \\r\\n-terminated line. Line is returned without \\n or \\r\\n.\n// If the line was too long, ErrLineTooLong is returned.\n// If an EOF is encountered before a \\n, io.ErrUnexpectedEOF is returned.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"io\"\n\t\"strings\"\n)\n\nvar (\n\tErrLineTooLong      = errors.New(\"line too long\")\n\tErrUnexpectedEOF    = errors.New(\"unexpected EOF\")\n\tDefaultMaxLineLength = 4096 // or any other suitable length\n)\n\ntype Bufpool struct {\n\tMaxLineLength int\n}\n\n// Readline reads a \\n- or \\r\\n-terminated line. The line is returned without \\n or \\r\\n.\n// If the line was too long, ErrLineTooLong is returned.\n// If an EOF is encountered before a \\n, io.ErrUnexpectedEOF is returned.\nfunc (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n\tvar sb strings.Builder\n\tmaxLineLength := b.MaxLineLength\n\tif maxLineLength == 0 {\n\t\tmaxLineLength = DefaultMaxLineLength\n\t}\n\n\tfor {\n\t\tpart, isPrefix, err := r.ReadLine()\n\n\t\tif err != nil {\n\t\t\tif err == io.EOF && sb.Len() > 0 {\n\t\t\t\treturn sb.String(), nil\n\t\t\t}\n\t\t\tif err == io.EOF {\n\t\t\t\treturn \"\", ErrUnexpectedEOF\n\t\t\t}\n\t\t\treturn \"\", err\n\t\t}\n\n\t\tsb.Write(part)\n\t\t\n\t\tif isPrefix {\n\t\t\tif sb.Len() > maxLineLength {\n\t\t\t\treturn \"\", ErrLineTooLong\n\t\t\t}\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn sb.String(), nil\n}\n```"]}, "mox-moxio/linkcopy.go-LinkOrCopy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func LinkOrCopy(log mlog.Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n# Natural Language Annotations: // LinkOrCopy attempts to make a hardlink dst. If that fails, it will try to do a\n// regular file copy. If srcReaderOpt is not nil, it will be used for reading. If\n// sync is true and the file is copied, Sync is called on the file after writing to\n// ensure the file is written on disk. Callers should also sync the directory of\n// the destination file, but may want to do that after linking/copying multiple\n// files. If dst was created and an error occurred, it is removed.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\n\tmlog \"github.com/some/log/package\"\n)\n\nfunc LinkOrCopy(log mlog.Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n\t// Try to create a hard link first\n\terr := os.Link(src, dst)\n\tif err == nil {\n\t\t// Link successful, exit early\n\t\treturn nil\n\t}\n\n\t// Log the failed attempt to create a hard link\n\tlog.Errorf(\"Failed to link %s -> %s: %v\", src, dst, err)\n\n\t// Open the source for reading\n\tvar srcReader io.Reader\n\tif srcReaderOpt != nil {\n\t\tsrcReader = srcReaderOpt\n\t} else {\n\t\tsrcFile, err := os.Open(src)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer srcFile.Close()\n\t\tsrcReader = srcFile\n\t}\n\n\t// Create the destination file\n\tdstFile, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer func() {\n\t\tif rerr != nil {\n\t\t\tdstFile.Close()\n\t\t\tos.Remove(dst) // Attempt to remove file if an error occurred\n\t\t}\n\t}()\n\n\t// Copy content from src to dst\n\t_, err = io.Copy(dstFile, srcReader)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Sync the file if required\n\tif sync {\n\t\terr = dstFile.Sync()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn dstFile.Close()\n}\n```"]}, "mox-moxio/base64writer.go-Base64Writer": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Base64Writer(w io.Writer) io.WriteCloser {\n# Natural Language Annotations: // Base64Writer turns a writer for data into one that writes base64 content on\n// \\r\\n separated lines of max 78+2 characters length.\nPlease only return the code surrounded by ```\n", "response": ["```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"encoding/base64\"\n\t\"io\"\n)\n\ntype base64WriteCloser struct {\n\twriter *bufio.Writer\n\tencoder *base64.Encoding\n}\n\nfunc (bwc *base64WriteCloser) Write(p []byte) (n int, err error) {\n\tencoded := make([]byte, base64.StdEncoding.EncodedLen(len(p)))\n\tbase64.StdEncoding.Encode(encoded, p)\n\n\tlines := splitIntoLines(encoded, 76) // Split into lines of max 76 bytes (resulting in 78 chars with CRLF)\n\n\tfor _, line := range lines {\n\t\tif _, err = bwc.writer.Write(line); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t\tif _, err = bwc.writer.WriteString(\"\\r\\n\"); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\t\n\treturn len(p), nil\n}\n\nfunc splitIntoLines(data []byte, lineLength int) [][]byte {\n\tvar lines [][]byte\n\tfor len(data) > lineLength {\n\t\tlines = append(lines, data[:lineLength])\n\t\tdata = data[lineLength:]\n\t}\n\tif len(data) > 0 {\n\t\tlines = append(lines, data)\n\t}\n\treturn lines\n}\n\nfunc (bwc *base64WriteCloser) Close() error {\n\treturn bwc.writer.Flush()\n}\n\nfunc Base64Writer(w io.Writer) io.WriteCloser {\n\treturn &base64WriteCloser{\n\t\twriter: bufio.NewWriter(w),\n\t\tencoder: base64.StdEncoding,\n\t}\n}\n```"]}, "mox-dkim/sig.go-Header": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Sig) Header() (string, error) {\n# Natural Language Annotations: // Header returns the DKIM-Signature header in string form, to be prepended to a\n// message, including DKIM-Signature field name and trailing \\r\\n.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (s *Sig) Header() (string, error) {\n\tif s == nil {\n\t\treturn \"\", fmt.Errorf(\"Sig is nil\")\n\t}\n\n\t// The DKIM-Signature field name\n\tdkimSignatureFieldName := \"DKIM-Signature\"\n\n\t// Assemble the DKIM-Signature header value based on the contents of the Sig struct, \n\t// assuming Sig has methods to provide necessary components\n\theaderValue, err := s.assembleHeaderValue()\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Create the complete DKIM-Signature header\n\tdkimSignatureHeader := dkimSignatureFieldName + \": \" + headerValue + \"\\r\\n\"\n\n\treturn dkimSignatureHeader, nil\n}\n\n// Assuming assembleHeaderValue is a method of Sig that constructs the DKIM-Signature header value\nfunc (s *Sig) assembleHeaderValue() (string, error) {\n\t// Implement the logic to create the header value from the Sig struct's fields\n\t// This is a placeholder and should be replaced with actual header value computation\n\treturn \"v=1; a=rsa-sha256; ...\", nil\n}\n```"]}, "mox-dkim/txt.go-Record": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r *Record) Record() (string, error) {\n# Natural Language Annotations: // Record returns a DNS TXT record that should be served at\n// <selector>._domainkey.<domain>.\n//\n// Only values that are not the default values are included.\nPlease only return the code surrounded by ```\n", "response": ["```go\nfunc (r *Record) Record() (string, error) {\n\tconst defaultKey = \"default_value\" // Example default value, adjust according to actual defaults\n\tconst defaultDomain = \"default_domain\"\n\n\t// Check if the selector or domain are default values\n\t// Replace these with the actual default checks as needed\n\tif r.Selector == defaultKey || r.Domain == defaultDomain {\n\t\treturn \"\", fmt.Errorf(\"invalid record, default selector or domain found\")\n\t}\n\n\t// Construct the DNS TXT record name\n\trecordName := fmt.Sprintf(\"%s._domainkey.%s\", r.Selector, r.Domain)\n\n\t// Assuming r.Value holds the TXT record value\n\t// This assumes value should not be returned if it's a default; otherwise adjust logic as needed\n\tif r.Value == defaultKey {\n\t\treturn \"\", fmt.Errorf(\"value is default, not including in the record\")\n\t}\n\n\treturn fmt.Sprintf(\"%s %s\", recordName, r.Value), nil\n}\n```"]}}