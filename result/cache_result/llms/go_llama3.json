{"dtm-dtmsvr/storage/boltdb/boltdb.go-cleanupExpiredData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n# Natural Language Annotations: // cleanupExpiredData will clean the expired data in boltdb, the\n//\n//\texpired time is configurable.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n    now := time.Now().UTC()\n    bucket := db.View(func(tx *bolt.Tx) error {\n        return nil\n    })\n    if bucket == nil {\n        return errors.New(\"bucket not found\")\n    }\n    return bucket.ForEach(func(key, value []byte) error {\n        expiryTime, err := strconv.Atoi(string(value))\n        if err != nil {\n            return err\n        }\n        expiryTime := now.Add(-expire).Unix()\n        if expiryTime > int64(expiryTime) {\n            return bucket.Delete(key)\n        }\n        return nil\n    })\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"time\"\n\n\t\"github.com/boltdb/bolt\"\n)\n\nfunc cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n\t// Get the current time\n\tcurrentTime := time.Now()\n\n\t// Get the timestamp of expired data\n\texpireTime := currentTime.Add(-expire)\n\n\t// Create a bucket to store the expired data\n\tbucketName := \"expired_data\"\n\n\t// Open the bucket\n\terr := db.Update(func(tx *bolt.Tx) error {\n\t\tbucket, err := tx.Bucket([]byte(bucketName))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\t// Delete expired data\n\t\terr = bucket.ForEach(func(key, value []byte) error {\n\t\t\ttimestamp, err := time.Parse(time.RFC3339, string(value))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif timestamp.Before(expireTime) {\n\t\t\t\treturn bucket.Delete(key)\n\t\t\t}\n\t\t\treturn nil\n\t\t})\n\t\treturn err\n\t})\n\treturn err\n}\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"time\"\n\n    \"github.com/boltdb/bolt\"\n)\n\nfunc cleanupExpiredData(expire time.Duration, db *bolt.DB) error {\n    // Get the current time\n    now := time.Now().Unix()\n\n    // Create a bucket to store the expired data\n    expiredBucket := []byte(\"expired\")\n\n    // Get all expired keys\n    cursor := db.View(func(tx *bolt.Tx) error {\n        return tx.Bucket(expiredBucket).Cursor()\n    })\n    if cursor == nil {\n        return nil\n    }\n\n    // Clean expired data\n    for k, v := cursor.First(); k != nil; k, v = cursor.Next() {\n        keyTime, err := strconv.Atoi(string(k))\n        if err != nil {\n            return err\n        }\n        if int64(keyTime) < now-expire {\n            // Delete expired data\n            return db.Update(func(tx *bolt.Tx) error {\n                return tx.Bucket(expiredBucket).Delete(k)\n            })\n        }\n    }\n\n    return nil\n}\n```"]}, "dtm-dtmsvr/config/config.go-MustLoadConfig": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MustLoadConfig(confFile string) {\n# Natural Language Annotations: // MustLoadConfig load config from env and file\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport os\nimport json\n\ndef MustLoadConfig(confFile):\n    # Check if config file exists in environment variable\n    if 'CONF_FILE' in os.environ:\n        conf_file_path = os.environ['CONF_FILE']\n    else:\n        # If not, try to load from default file path\n        conf_file_path = confFile\n\n    # Check if config file exists\n    if not os.path.exists(conf_file_path):\n        raise Exception(f\"Config file not found: {conf_file_path}\")\n\n    # Load config from file\n    with open(conf_file_path, 'r') as file:\n        config = json.load(file)\n\n    return config\n```", "```python\nimport os\nimport json\n\ndef MustLoadConfig(confFile):\n    # check if config file exists in env\n    if 'CONFIG_FILE' in os.environ:\n        confFile = os.environ['CONFIG_FILE']\n    \n    # try to load config from file\n    try:\n        with open(confFile, 'r') as file:\n            config = json.load(file)\n            return config\n    except FileNotFoundError:\n        print(f\"Config file {confFile} not found.\")\n        return {}\n    except json.JSONDecodeError:\n        print(f\"Failed to parse config file {confFile}.\")\n        return {}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"os\"\n\t\"log\"\n)\n\ntype Config struct {\n\t// Add your config fields here\n}\n\nfunc MustLoadConfig(confFile string) (*Config, error) {\n\t// Check if the configuration file exists in the environment\n\tif os.Getenv(\"CONFIG_FILE\") != \"\" {\n\t\t// If it does, use it\n\t\tconfFile = os.Getenv(\"CONFIG_FILE\")\n\t}\n\n\t// Load the configuration from the file\n\tdata, err := os.ReadFile(confFile)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Unmarshal the configuration\n\tvar config Config\n\tif err := json.Unmarshal(data, &config); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &config, nil\n}\n```"]}, "dtm-client/dtmcli/dtmimp/utils.go-MustRemarshal": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MustRemarshal(from interface{}, to interface{}) {\n# Natural Language Annotations: // MustRemarshal marshal and unmarshal, and check error\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n)\n\nfunc MustRemarshal(from interface{}, to interface{}) error {\n\tjsonBytes, err := json.Marshal(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\terr = json.Unmarshal(jsonBytes, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n\nfunc main() {\n\ttype Person struct {\n\t\tName string\n\t\tAge  int\n\t}\n\n\tp := Person{\n\t\tName: \"John\",\n\t\tAge:  30,\n\t}\n\n\tvar p2 Person\n\terr := MustRemarshal(p, &p2)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(p2)\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// MustRemarshal marshals and unmarshals the given interface to and from JSON, and checks for errors.\nfunc MustRemarshal(from interface{}, to interface{}) error {\n\t// Marshal the input interface to JSON\n\tjsonBytes, err := json.Marshal(from)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal the JSON bytes back to the output interface\n\terr = json.Unmarshal(jsonBytes, to)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Check if the output interface is the same as the input interface\n\tif from != to {\n\t\treturn fmt.Errorf(\"marshaled and unmarshaled values do not match\")\n\t}\n\n\treturn nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// MustRemarshal marshals the given object to a JSON string, checks for errors, and then unmarshals the JSON string back into a new object.\nfunc MustRemarshal(from interface{}, to interface{}) {\n\t// Marshal the object to a JSON string\n\tjsonStr, err := json.Marshal(from)\n\tif err != nil {\n\t\tfmt.Printf(\"Error marshaling object: %v\\n\", err)\n\t\tpanic(err)\n\t}\n\n\t// Unmarshal the JSON string back into a new object\n\tif err := json.Unmarshal(jsonStr, to); err != nil {\n\t\tfmt.Printf(\"Error unmarshaling JSON: %v\\n\", err)\n\t\tpanic(err)\n\t}\n}\n```"]}, "kitex-tool/internal_pkg/generator/type.go-FixHasStreamingForExtendedService": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *ServiceInfo) FixHasStreamingForExtendedService() {\n# Natural Language Annotations: // FixHasStreamingForExtendedService updates the HasStreaming field for extended services.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass ServiceInfo:\n    def __init__(self, name, has_streaming):\n        self.name = name\n        self.has_streaming = has_streaming\n\ndef fix_has_streaming_for_extended_service(s: 'ServiceInfo') -> None:\n    \"\"\"\n    FixHasStreamingForExtendedService updates the HasStreaming field for extended services.\n    \"\"\"\n    s.has_streaming = True\n```", "```python\ndef fix_has_streaming_for_extended_service(s):\n    # Update the HasStreaming field for extended services\n    s.HasStreaming = True\n```", "```python\ndef fix_has_streaming_for_extended_service(s):\n    # FixHasStreamingForExtendedService updates the HasStreaming field for extended services.\n    s.HasStreaming = True\n```"]}, "kitex-tool/internal_pkg/generator/type.go-HasStreamingRecursive": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *ServiceInfo) HasStreamingRecursive() bool {\n# Natural Language Annotations: // HasStreamingRecursive recursively check if the service has streaming method\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass ServiceInfo:\n    def __init__(self, name, methods=None):\n        self.name = name\n        self.methods = methods if methods else []\n\n    def has_streaming_recursive(self):\n        def recursive_check(service):\n            if not isinstance(service, ServiceInfo):\n                return False\n            if any(method.startswith('stream') for method in service.methods):\n                return True\n            for child in service.methods:\n                if isinstance(child, ServiceInfo):\n                    if recursive_check(child):\n                        return True\n            return False\n\n        return recursive_check(self)\n```", "```python\ndef has_streaming_recursive(self, service):\n    if not service:\n        return False\n    if hasattr(service, 'has_streaming_method'):\n        return service.has_streaming_method()\n    if hasattr(service, 'services'):\n        for sub_service in service.services:\n            if has_streaming_recursive(self, sub_service):\n                return True\n    return False\n```", "```python\ndef has_streaming_recursive(self, service):\n    if not hasattr(service, 'methods'):\n        return False\n    for method in service.methods:\n        if method.streaming:\n            return True\n        if hasattr(method, 'subservices'):\n            if has_streaming_recursive(self, method.subservices):\n                return True\n    return False\n```"]}, "kitex-tool/internal_pkg/generator/generator.go-Unpack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Config) Unpack(args []string) error {\n# Natural Language Annotations: // Unpack restores the Config from a slice of \"key=val\" strings.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef unpack(self, args):\n    \"\"\"\n    Unpack restores the Config from a slice of \"key=val\" strings.\n    \"\"\"\n    config = {}\n    for arg in args:\n        key, value = arg.split('=')\n        config[key] = value\n    return config\n```", "```python\ndef unpack(self, args):\n    config = {}\n    for arg in args:\n        key, value = arg.split('=')\n        config[key] = value\n    self.config = config\n```", "```go\nfunc (c *Config) Unpack(args []string) error {\n    for _, arg := range args {\n        parts := strings.SplitN(arg, \"=\", 2)\n        if len(parts) != 2 {\n            return errors.New(\"invalid argument format: \" + arg)\n        }\n        key, value := parts[0], parts[1]\n        c[key] = value\n    }\n    return nil\n}\n```"]}, "kitex-tool/internal_pkg/util/util.go-CombineOutputPath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CombineOutputPath(outputPath, ns string) string {\n# Natural Language Annotations: // CombineOutputPath read the output and path variables and render them into the final path\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef CombineOutputPath(outputPath, ns):\n    \"\"\"\n    Combine the output and path variables into the final path.\n\n    Args:\n        outputPath (str): The output path variable.\n        ns (str): The namespace variable.\n\n    Returns:\n        str: The combined output path.\n    \"\"\"\n    return outputPath + \"/\" + ns\n```", "```python\ndef combine_output_path(output_path, ns):\n    \"\"\"\n    Combine the output and path variables into the final path.\n    \n    Args:\n        output_path (str): The output path variable.\n        ns (str): The path variable.\n    \n    Returns:\n        str: The combined path.\n    \"\"\"\n    return output_path + ns\n```", "```python\ndef CombineOutputPath(outputPath, ns):\n    \"\"\"\n    Combine the output and path variables into the final path.\n\n    Args:\n        outputPath (str): The output path.\n        ns (str): The namespace.\n\n    Returns:\n        str: The final combined path.\n    \"\"\"\n    return f\"{outputPath}/{ns}\"\n```"]}, "kitex-pkg/rpcinfo/stats_util.go-CalcEventCostUs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CalcEventCostUs(start, end Event) uint64 {\n# Natural Language Annotations: // CalcEventCostUs calculates the duration between start and end and returns in microsecond.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom datetime import datetime\n\ndef calc_event_cost_us(start: datetime, end: datetime) -> int:\n    \"\"\"\n    Calculates the duration between start and end in microseconds.\n\n    Args:\n        start (datetime): The start time of the event.\n        end (datetime): The end time of the event.\n\n    Returns:\n        int: The duration between start and end in microseconds.\n    \"\"\"\n    return int((end - start).total_seconds() * 1e6)\n```", "```python\ndef calc_event_cost_us(start, end):\n    \"\"\"\n    Calculates the duration between start and end and returns in microseconds.\n    \n    Args:\n        start (Event): The start event.\n        end (Event): The end event.\n    \n    Returns:\n        uint64: The duration between start and end in microseconds.\n    \"\"\"\n    return (end - start).total_seconds() * 1e6\n```", "```python\nfrom datetime import datetime\n\ndef CalcEventCostUs(start: datetime, end: datetime) -> int:\n    \"\"\"\n    Calculates the duration between start and end and returns in microseconds.\n    \n    Args:\n    start (datetime): The start time of the event.\n    end (datetime): The end time of the event.\n    \n    Returns:\n    int: The duration of the event in microseconds.\n    \"\"\"\n    return (end - start).total_seconds() * 1e6\n```"]}, "kitex-pkg/rpcinfo/invocation.go-NewInvocation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewInvocation(service, method string, pkgOpt ...string) *invocation {\n# Natural Language Annotations: // NewInvocation creates a new Invocation with the given service, method and optional package.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\ntype Invocation struct {\n    Service string\n    Method  string\n    Pkg     string\n}\n\nfunc NewInvocation(service string, method string, pkgOpt ...string) *Invocation {\n    invocation := &Invocation{\n        Service: service,\n        Method:  method,\n    }\n    if len(pkgOpt) > 0 {\n        invocation.Pkg = pkgOpt[0]\n    }\n    return invocation\n}\n```", "```go\ntype Invocation struct {\n    Service string\n    Method  string\n    Package string\n}\n\nfunc NewInvocation(service string, method string, pkgOpt ...string) *Invocation {\n    invocation := &Invocation{\n        Service: service,\n        Method:  method,\n    }\n    if len(pkgOpt) > 0 {\n        invocation.Package = pkgOpt[0]\n    }\n    return invocation\n}\n```", "```python\nclass Invocation:\n    def __init__(self, service, method, *pkgOpt):\n        self.service = service\n        self.method = method\n        self.pkgOpt = pkgOpt\n\ndef NewInvocation(service, method, *pkgOpt):\n    return Invocation(service, method, *pkgOpt)\n```"]}, "kitex-pkg/retry/retryer.go-InitWithPolicies": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n# Natural Language Annotations: // InitWithPolicies to init Retryer with methodPolicies\n// Notice, InitWithPolicies is export func, the lock should be added inside\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n    // Acquire a lock to ensure thread safety\n    rc.mu.Lock()\n    defer rc.mu.Unlock()\n    \n    // Check if methodPolicies is nil\n    if methodPolicies == nil {\n        return errors.New(\"methodPolicies cannot be nil\")\n    }\n    \n    // Iterate through each method in methodPolicies\n    for method, policy := range methodPolicies {\n        // Check if the policy is valid\n        if policy == nil {\n            return errors.New(\"policy cannot be nil\")\n        }\n        \n        // Store the policy in the container\n        rc.methodPolicies[method] = policy\n    }\n    \n    return nil\n}\n```", "```go\nfunc (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n    // lock should be added inside\n    rc.mu.Lock()\n    defer rc.mu.Unlock()\n    \n    if methodPolicies == nil {\n        return errors.New(\"method policies cannot be nil\")\n    }\n    \n    rc.methodPolicies = methodPolicies\n    \n    return nil\n}\n```", "```go\nfunc (rc *Container) InitWithPolicies(methodPolicies map[string]Policy) error {\n    lock := sync.RWMutex{}\n    lock.Lock()\n    defer lock.Unlock()\n    rc.MethodPolicies = methodPolicies\n    return nil\n}\n```"]}, "kitex-pkg/retry/retryer.go-WithRetryIfNeeded": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n# Natural Language Annotations: // WithRetryIfNeeded to check if there is a retryer can be used and if current call can retry.\n// When the retry condition is satisfied, use retryer to call\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nfunc (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n    if callOptRetry != nil && callOptRetry.Retryable(ri) {\n        retryer := rc.GetRetryer()\n        if retryer != nil {\n            return retryer.Retry(ctx, rpcCall, ri, request)\n        }\n    }\n    return ri, false, nil\n}\n```", "```python\nfrom typing import Callable, Any\n\nclass Container:\n    def __init__(self, retryer: 'Retryer'):\n        self.retryer = retryer\n\nclass Retryer:\n    def __call__(self, ctx: 'context.Context', ri: 'rpcinfo.RPCInfo', request: Any) -> 'rpcinfo.RPCInfo':\n        # implement your retry logic here\n        pass\n\nclass rpcinfo:\n    pass\n\nclass rpcCallFunc:\n    def __init__(self, func: Callable):\n        self.func = func\n\ndef WithRetryIfNeeded(ctx: 'context.Context', callOptRetry: 'Policy', rpcCall: rpcCallFunc, ri: rpcinfo.RPCInfo, request: Any) -> (rpcinfo.RPCInfo, bool, Exception):\n    if callOptRetry and ri.retryable:\n        return self.retryer(ctx, ri, request)\n    else:\n        return rpcCall.func(ctx, ri, request)\n\nclass Policy:\n    def __init__(self, retryable: bool):\n        self.retryable = retryable\n\nclass context:\n    pass\n```", "```sql\nfunc (rc *Container) WithRetryIfNeeded(ctx context.Context, callOptRetry *Policy, rpcCall RPCCallFunc, ri rpcinfo.RPCInfo, request interface{}) (lastRI rpcinfo.RPCInfo, recycleRI bool, err error) {\n    if callOptRetry != nil && callOptRetry.RetryPolicy != nil {\n        retryer := rc.GetRetryer(callOptRetry.RetryPolicy)\n        if retryer != nil && callOptRetry.RetryPolicy.CanRetry(ri) {\n            return retryer.Call(ctx, rpcCall, ri, request)\n        }\n    }\n    return ri, false, nil\n}\n```"]}, "kitex-pkg/discovery/discovery.go-DefaultDiff": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefaultDiff(cacheKey string, prev, next Result) (Change, bool) {\n# Natural Language Annotations: // DefaultDiff provides a natural implementation for the Diff method of the Resolver interface.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef default_diff(cache_key, prev, next):\n    \"\"\"\n    Provides a natural implementation for the Diff method of the Resolver interface.\n    \n    Args:\n    cache_key (str): The key used for caching.\n    prev (Result): The previous result.\n    next (Result): The next result.\n    \n    Returns:\n    tuple: A tuple containing the change and a boolean indicating whether the change is significant.\n    \"\"\"\n    # For this example, we'll assume Result is a class with attributes 'data' and 'cache_key'.\n    # We'll also assume that 'data' is the actual data stored in the result, and 'cache_key' is the key used for caching.\n    change = next.data - prev.data\n    significant_change = change != 0\n    \n    return change, significant_change\n```", "```python\ndef DefaultDiff(cacheKey, prev, next):\n    \"\"\"\n    Provides a natural implementation for the Diff method of the Resolver interface.\n    \n    Args:\n        cacheKey (str): The cache key to be used.\n        prev (Result): The previous result.\n        next (Result): The next result.\n    \n    Returns:\n        tuple: A tuple containing the change and a boolean indicating whether a change was detected.\n    \"\"\"\n    # Check if the cache key is the same for both results\n    if cacheKey == prev.cacheKey == next.cacheKey:\n        # If the cache key is the same, check if the results are different\n        if prev.value != next.value:\n            # If the results are different, return the difference and True\n            return next.value - prev.value, True\n        else:\n            # If the results are the same, return 0 and False\n            return 0, False\n    else:\n        # If the cache key is different, return the difference and True\n        return next.value - prev.value, True\n```", "```go\n// DefaultDiff provides a natural implementation for the Diff method of the Resolver interface.\nfunc DefaultDiff(cacheKey string, prev, next Result) (Change, bool) {\n    // Check if the cache key is different in the previous and next results\n    if prev.CacheKey != next.CacheKey {\n        return Change{Type: \"cacheKeyMismatch\"}, true\n    }\n\n    // Check if the result is the same in the previous and next results\n    if prev.Data == next.Data {\n        return Change{Type: \"noChange\"}, false\n    }\n\n    // Check if the result is updated in the next result\n    if prev.Data == nil && next.Data != nil {\n        return Change{Type: \"updated\"}, true\n    }\n\n    // Check if the result is deleted in the next result\n    if prev.Data != nil && next.Data == nil {\n        return Change{Type: \"deleted\"}, true\n    }\n\n    // Check if the result is updated with a different value in the next result\n    if prev.Data != nil && next.Data != nil && prev.Data != next.Data {\n        return Change{Type: \"updated\"}, true\n    }\n\n    // If none of the above conditions are met, return a \"noChange\" change with a value of false\n    return Change{Type: \"noChange\"}, false\n}\n```"]}, "kitex-pkg/protocol/bthrift/binary.go-SetSpanCache": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func SetSpanCache(enable bool) {\n# Natural Language Annotations: // SetSpanCache enable/disable binary protocol bytes/string allocator\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass SpanCache:\n    def __init__(self):\n        self.enabled = False\n\n    def enable(self):\n        self.enabled = True\n\n    def disable(self):\n        self.enabled = False\n\ndef SetSpanCache(enable: bool):\n    span_cache = SpanCache()\n    if enable:\n        span_cache.enable()\n    else:\n        span_cache.disable()\n    return span_cache.enabled\n```", "```python\ndef SetSpanCache(enable: bool):\n    \"\"\"\n    SetSpanCache enable/disable binary protocol bytes/string allocator\n    \"\"\"\n    # Implementation specific to your programming language (e.g. Python, Java, C++, etc.)\n    # For Python implementation:\n    if enable:\n        # Enable the span cache\n        import os\n        os.environ['SPANCACHE_ENABLED'] = 'true'\n    else:\n        # Disable the span cache\n        import os\n        os.environ['SPANCACHE_ENABLED'] = 'false'\n```", "```python\ndef set_span_cache(enable: bool) -> None:\n    \"\"\"\n    SetSpanCache enable/disable binary protocol bytes/string allocator\n    \"\"\"\n    if enable:\n        # Enable binary protocol bytes/string allocator\n        # Add your implementation here to enable the cache\n        pass\n    else:\n        # Disable binary protocol bytes/string allocator\n        # Add your implementation here to disable the cache\n        pass\n```"]}, "kitex-pkg/protocol/bthrift/unknown.go-GetUnknownFields": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetUnknownFields(v interface{}) (fields []UnknownField, err error) {\n# Natural Language Annotations: // GetUnknownFields deserialize unknownFields stored in v to a list of *UnknownFields.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport json\n\nclass UnknownField:\n    def __init__(self, name: str, value: str):\n        self.name = name\n        self.value = value\n\ndef get_unknown_fields(v):\n    try:\n        data = json.loads(v)\n        unknown_fields = []\n        for key, value in data.items():\n            if isinstance(value, str):\n                unknown_fields.append(UnknownField(key, value))\n        return unknown_fields, None\n    except json.JSONDecodeError as e:\n        return [], e\n```", "```go\nfunc GetUnknownFields(v interface{}) (fields []UnknownField, err error) {\n    var unknownFields map[string]interface{}\n    switch v := v.(type) {\n    case map[string]interface{}:\n        unknownFields = v\n    case *map[string]interface{}:\n        unknownFields = *v\n    default:\n        return fields, errors.New(\"input must be a map\")\n    }\n\n    fields = make([]UnknownField, 0, len(unknownFields))\n    for key, value := range unknownFields {\n        field := UnknownField{\n            Name:  key,\n            Value: value,\n        }\n        fields = append(fields, field)\n    }\n\n    return fields, nil\n}\n```", "```go\n// Package unknownfields contains functions to work with unknown fields.\npackage unknownfields\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n)\n\n// UnknownField represents an unknown field.\ntype UnknownField struct {\n\tName  string\n\tValue interface{}\n}\n\n// GetUnknownFields deserializes unknown fields stored in v to a list of *UnknownField.\nfunc GetUnknownFields(v interface{}) ([]UnknownField, error) {\n\tif v == nil {\n\t\treturn nil, nil\n\t}\n\n\tswitch v := v.(type) {\n\tcase map[string]interface{}:\n\t\tfields := make([]UnknownField, 0)\n\t\tfor k, v := range v {\n\t\t\tfield := UnknownField{\n\t\t\t\tName:  k,\n\t\t\t\tValue: v,\n\t\t\t}\n\t\t\tfields = append(fields, field)\n\t\t}\n\t\treturn fields, nil\n\tcase []interface{}:\n\t\tfields := make([]UnknownField, 0)\n\t\tfor _, item := range v {\n\t\t\tswitch item := item.(type) {\n\t\t\tcase map[string]interface{}:\n\t\t\t\tfor k, v := range item {\n\t\t\t\t\tfield := UnknownField{\n\t\t\t\t\t\tName:  k,\n\t\t\t\t\t\tValue: v,\n\t\t\t\t\t}\n\t\t\t\t\tfields = append(fields, field)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tfield := UnknownField{\n\t\t\t\t\tName:  \"unknown\",\n\t\t\t\t\tValue: item,\n\t\t\t\t}\n\t\t\t\tfields = append(fields, field)\n\t\t\t}\n\t\t}\n\t\treturn fields, nil\n\tdefault:\n\t\treturn nil, fmt.Errorf(\"unknown type: %T\", v)\n\t}\n}\n```"]}, "kitex-pkg/protocol/bthrift/unknown.go-WriteUnknownFields": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n# Natural Language Annotations: // WriteUnknownFields writes fs into buf, and return written offset of the buf.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nfunc WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n    for _, field := range fs {\n        // Check if field has a name\n        if field.Name != \"\" {\n            // Write field name\n            n := len(field.Name)\n            if int64(n) > int64(len(buf)) {\n                return 0, errors.New(\"not enough space in buf\")\n            }\n            copy(buf, field.Name)\n            offset += n\n            // Write field type and value\n            if int64(len(field.Type)) > int64(len(buf)-offset) {\n                return offset, errors.New(\"not enough space in buf\")\n            }\n            copy(buf[offset:], field.Type)\n            offset += len(field.Type)\n            if int64(len(field.Value)) > int64(len(buf)-offset) {\n                return offset, errors.New(\"not enough space in buf\")\n            }\n            copy(buf[offset:], field.Value)\n            offset += len(field.Value)\n        } else {\n            // If field has no name, write its type and value directly\n            if int64(len(field.Type)) > int64(len(buf)) {\n                return 0, errors.New(\"not enough space in buf\")\n            }\n            copy(buf, field.Type)\n            offset += len(field.Type)\n            if int64(len(field.Value)) > int64(len(buf)-offset) {\n                return offset, errors.New(\"not enough space in buf\")\n            }\n            copy(buf[offset:], field.Value)\n            offset += len(field.Value)\n        }\n    }\n    return offset, nil\n}\n```", "```go\nfunc WriteUnknownFields(buf []byte, fs []UnknownField) (offset int, err error) {\n    offset = 0\n    for _, field := range fs {\n        fieldData, err := field.Marshal()\n        if err != nil {\n            return 0, err\n        }\n        offset += len(fieldData)\n        buf = append(buf, fieldData...)\n    }\n    return offset, nil\n}\n```", "```go\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n)\n\ntype UnknownField struct {\n    Name  string\n    Value string\n}\n\nfunc (buf []byte) WriteUnknownFields(fs []UnknownField) (int, error) {\n    offset := len(buf)\n    for _, field := range fs {\n        fieldBytes := []byte(field.Name + \"=\" + field.Value)\n        if len(fieldBytes) > len(buf)-offset {\n            return 0, errors.New(\"not enough space in buffer\")\n        }\n        copy(buf[offset:], fieldBytes)\n        offset += len(fieldBytes)\n    }\n    return offset, nil\n}\n\nfunc main() {\n    buf := make([]byte, 1024)\n    fields := []UnknownField{\n        {\"name\", \"John\"},\n        {\"age\", \"30\"},\n    }\n    offset, err := WriteUnknownFields(buf, fields)\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(\"Written offset:\", offset)\n    }\n}\n```"]}, "kitex-pkg/circuitbreak/circuitbreak.go-NewCircuitBreakerMW": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n# Natural Language Annotations: // NewCircuitBreakerMW creates a circuit breaker MW using the given Control strategy and Panel.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n    return func(next endpoint.Handler) endpoint.Handler {\n        return func(ctx context.Context, req *http.Request) (*http.Response, error) {\n            if control.IsOpen() {\n                return http.StatusGatewayTimeout, errors.New(\"circuit is open\")\n            }\n            return next(ctx, req)\n        }\n    }\n}\n```", "```go\n// NewCircuitBreakerMW creates a circuit breaker MW using the given Control strategy and Panel.\nfunc NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n    return func(next endpoint.Handler) endpoint.Handler {\n        return func(ctx context.Context, req *endpoint.Request) (*endpoint.Response, error) {\n            // Implement circuit breaker logic here\n            // For example:\n            if control.IsOpen() {\n                return nil, errors.New(\"circuit is open\")\n            }\n            return next(ctx, req)\n        }\n    }\n}\n```", "```go\n// NewCircuitBreakerMW creates a circuit breaker MW using the given Control strategy and Panel.\nfunc NewCircuitBreakerMW(control Control, panel circuitbreaker.Panel) endpoint.Middleware {\n    return func(next endpoint.Handler) endpoint.Handler {\n        return func(ctx context.Context, req *http.Request) (*http.Response, error) {\n            if control.IsOpen() {\n                return http.StatusGatewayTimeout, errors.New(\"circuit is open\")\n            }\n            return next(ctx, req)\n        }\n    }\n}\n```"]}, "kitex-pkg/circuitbreak/cbsuite.go-RPCInfo2Key": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RPCInfo2Key(ri rpcinfo.RPCInfo) string {\n# Natural Language Annotations: // RPCInfo2Key is to generate circuit breaker key through rpcinfo\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nfunc RPCInfo2Key(ri rpcinfo.RPCInfo) string {\n    return ri.Method + \"_\" + ri.Service + \"_\" + ri.Endpoint\n}\n```", "```python\ndef RPCInfo2Key(ri: 'rpcinfo.RPCInfo') -> str:\n    \"\"\"\n    This function generates a circuit breaker key through rpcinfo.\n    \n    Parameters:\n    ri (rpcinfo.RPCInfo): The rpcinfo object containing the necessary information to generate the circuit breaker key.\n    \n    Returns:\n    str: A string representing the circuit breaker key.\n    \"\"\"\n    return f\"{ri.service_name}_{ri.method_name}_{ri.host}_{ri.port}\"\n```", "```python\ndef RPCInfo2Key(ri: 'rpcinfo.RPCInfo') -> str:\n    \"\"\"\n    RPCInfo2Key is to generate circuit breaker key through rpcinfo\n    \"\"\"\n    return f\"{ri.service_name}:{ri.method_name}:{ri.version}\"\n```"]}, "kitex-pkg/circuitbreak/default.go-ErrorTypeOnServiceLevel": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ErrorTypeOnServiceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n# Natural Language Annotations: // ErrorTypeOnServiceLevel determines the error type with a service level criteria.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom contextlib import contextmanager\n\ndef ErrorTypeOnServiceLevel(ctx context.Context, request, response interface{}, err error) -> str:\n    \"\"\"\n    Determines the error type with a service level criteria.\n\n    Args:\n        ctx (context.Context): The current context.\n        request (interface): The incoming request.\n        response (interface): The response to be sent.\n        err (error): The error that occurred.\n\n    Returns:\n        str: The error type with a service level criteria.\n    \"\"\"\n    # Implement your logic here to determine the error type based on the service level criteria\n    # For example:\n    if err is None:\n        return \"NO_ERROR\"\n    elif ctx.Value(\"service_level\") == \"high\":\n        return \"HIGH_ERROR\"\n    elif ctx.Value(\"service_level\") == \"low\":\n        return \"LOW_ERROR\"\n    else:\n        return \"MEDIUM_ERROR\"\n```", "```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass ErrorType:\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n\nclass ServiceLevelError(Exception):\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n\nclass ServiceLevel:\n    def __init__(self, level: str):\n        self.level = level\n\n    def error_type(self, code: int, message: str) -> ErrorType:\n        return ErrorType(code, message)\n\nclass ErrorTypeOnServiceLevel(Generic[T]):\n    def __init__(self, service_level: ServiceLevel, request: T, response: T, err: Exception):\n        self.service_level = service_level\n        self.request = request\n        self.response = response\n        self.err = err\n\n    def determine(self) -> ErrorType:\n        error_code = 500\n        error_message = \"Internal Server Error\"\n\n        if isinstance(self.err, ServiceLevelError):\n            error_code = self.err.code\n            error_message = self.err.message\n\n        return self.service_level.error_type(error_code, error_message)\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom contextlib import contextmanager\n\nclass ErrorType:\n    def __init__(self, code: int, message: str):\n        self.code = code\n        self.message = message\n\nclass ServiceLevelErrorType:\n    def __init__(self, service_level: str):\n        self.service_level = service_level\n\n    def __str__(self):\n        return f\"ServiceLevelErrorType: {self.service_level}\"\n\nclass ErrorTypeOnServiceLevel(ABC):\n    @abstractmethod\n    def determine_error_type(self, ctx, request, response, err):\n        pass\n\nclass ServiceLevelErrorTypeOnServiceLevel(ErrorTypeOnServiceLevel):\n    def determine_error_type(self, ctx, request, response, err):\n        # Determine error type based on service level criteria\n        # For example, let's assume we have three service levels: 'low', 'medium', 'high'\n        if err is None:\n            return ErrorType(0, \"No error\")\n        elif 'low' in ctx.Value('service_level'):\n            if err.status_code < 500:\n                return ErrorType(0, \"No error\")\n            else:\n                return ErrorType(1, \"Low-level error\")\n        elif 'medium' in ctx.Value('service_level'):\n            if err.status_code < 400:\n                return ErrorType(0, \"No error\")\n            elif err.status_code < 500:\n                return ErrorType(1, \"Medium-level error\")\n            else:\n                return ErrorType(2, \"Medium-level error\")\n        elif 'high' in ctx.Value('service_level'):\n            return ErrorType(2, \"High-level error\")\n        else:\n            return ErrorType(3, \"Unknown service level\")\n\n# Usage example\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\n\nservice_level = ContextVar('service_level', default='low')\n\n@contextmanager\ndef set_service_level(level):\n    service_level.set(level)\n    try:\n        yield\n    finally:\n        service_level.clear()\n\nwith set_service_level('high'):\n    error_type = ServiceLevelErrorTypeOnServiceLevel().determine_error_type(None, None, None, None)\n    print(error_type)\n```"]}, "kitex-pkg/circuitbreak/default.go-ErrorTypeOnInstanceLevel": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ErrorTypeOnInstanceLevel(ctx context.Context, request, response interface{}, err error) ErrorType {\n# Natural Language Annotations: // ErrorTypeOnInstanceLevel determines the error type with an instance level criteria.\n// Basically, it treats only the connection error as failure.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import TypeVar, Generic\n\nT = TypeVar('T')\n\nclass ErrorType:\n    SUCCESS = \"success\"\n    FAILURE = \"failure\"\n\nclass ErrorTypeOnInstanceLevel(Generic[T]):\n    def __init__(self, ctx: object, request: object, response: object, err: Exception) -> str:\n        if isinstance(err, ConnectionError):\n            return ErrorType.FAILURE\n        else:\n            return ErrorType.SUCCESS\n```", "```python\ndef error_type_on_instance_level(ctx context.Context, request, response interface{}, err error) -> str:\n    \"\"\"\n    Determines the error type with an instance level criteria.\n    Basically, it treats only the connection error as failure.\n    \n    Args:\n        ctx (context.Context): The context of the request.\n        request: The request object.\n        response: The response object.\n        err (error): The error object.\n    \n    Returns:\n        str: The error type.\n    \"\"\"\n    if err != nil:\n        if isinstance(err, errors.ConnectionError):\n            return \"connection_error\"\n        else:\n            return \"other_error\"\n    else:\n        return \"no_error\"\n```", "```python\nfrom contextlib import contextmanager\n\ndef error_type_on_instance_level(ctx context.Context, request, response, err error) -> str:\n    \"\"\"\n    Determines the error type with an instance level criteria.\n    Basically, it treats only the connection error as failure.\n    \n    Args:\n        ctx (context.Context): The context object.\n        request: The request object.\n        response: The response object.\n        err (error): The error object.\n    \n    Returns:\n        str: The error type.\n    \"\"\"\n    if err == context.DeadlineExceeded or err == context.Canceled:\n        return \"TIMEOUT\"\n    elif isinstance(err, context.DeadlineExceeded):\n        return \"TIMEOUT\"\n    elif isinstance(err, context.Canceled):\n        return \"TIMEOUT\"\n    else:\n        return \"FAILURE\"\n```"]}, "kitex-pkg/utils/ring.go-NewRing": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewRing(size int) *Ring {\n# Natural Language Annotations: // Deprecated: it's not used by kitex anymore.\n// NewRing creates a ringbuffer with fixed size.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\n// NewRing creates a ringbuffer with fixed size.\n// Deprecated: it's not used by kitex anymore.\nfunc NewRing(size int) *Ring {\n    return &Ring{data: make([]byte, size), size: size}\n}\n\ntype Ring struct {\n    data []byte\n    size int\n    r, w int\n}\n```", "```go\n// NewRing is deprecated and not used by kitex anymore.\nfunc NewRing(size int) *Ring {\n    return &Ring{\n        size: size,\n        buffer: make([]byte, size),\n        head:  0,\n        tail:  0,\n        count: 0,\n    }\n}\n\ntype Ring struct {\n    size int\n    buffer []byte\n    head  int\n    tail  int\n    count int\n}\n```", "```go\n// NewRing creates a ringbuffer with fixed size.\n// Deprecated: it's not used by kitex anymore.\nfunc NewRing(size int) *Ring {\n    return &Ring{size: size}\n}\n\ntype Ring struct {\n    size int\n    data []int\n    front int\n    rear   int\n}\n```"]}, "kitex-pkg/utils/thrift.go-Serialize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *ThriftMessageCodec) Serialize(msg thrift.TStruct) (b []byte, err error) {\n# Natural Language Annotations: // Serialize serialize message into bytes. This is normal thrift serialize func.\n// Notice: Binary generic use Encode instead of Serialize.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef serialize(t, msg):\n    \"\"\"\n    Serialize a Thrift message into bytes.\n\n    Args:\n        t: Thrift message codec\n        msg: Thrift message to be serialized\n\n    Returns:\n        A tuple containing the serialized message as bytes and an error, if any.\n    \"\"\"\n    return t.Encode(msg)\n```", "```python\ndef Serialize(t, msg):\n    \"\"\"\n    Serialize serialize message into bytes. This is normal thrift serialize func.\n    Notice: Binary generic use Encode instead of Serialize.\n\n    :param t: ThriftMessageCodec\n    :param msg: thrift.TStruct\n    :return: b []byte, err error\n    \"\"\"\n    # Assuming t is an instance of ThriftMessageCodec\n    # and msg is an instance of thrift.TStruct\n    return t.Encode(msg)\n```", "```python\ndef serialize(t, msg):\n    \"\"\"\n    Serialize message into bytes.\n\n    :param t: ThriftMessageCodec\n    :param msg: thrift.TStruct\n    :return: b []byte, err error\n    \"\"\"\n    # Notice: Binary generic use Encode instead of Serialize.\n    return msg.Encode()\n```"]}, "kitex-pkg/utils/thrift.go-Deserialize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *ThriftMessageCodec) Deserialize(msg thrift.TStruct, b []byte) (err error) {\n# Natural Language Annotations: // Deserialize deserialize bytes into message. This is normal thrift deserialize func.\n// Notice: Binary generic use Decode instead of Deserialize.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef deserialize(codec, msg, b):\n    \"\"\"\n    Deserialize bytes into message.\n    \n    Args:\n    codec (ThriftMessageCodec): Thrift message codec\n    msg (thrift.TStruct): Thrift message structure\n    b (bytes): Bytes to deserialize\n    \n    Returns:\n    error: Error if deserialization fails, None otherwise\n    \"\"\"\n    return codec.Decode(msg, b)\n```", "```python\ndef deserialize(t, msg, b):\n    # Decode binary bytes into message\n    return t.Decode(msg, b)\n```", "```python\ndef deserialize(codec, msg, b):\n    return codec.Decode(msg, b)\n```"]}, "kitex-pkg/utils/thrift.go-MarshalError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MarshalError(method string, err error) []byte {\n# Natural Language Annotations: // MarshalError convert go error to thrift exception, and encode exception over buffered binary transport.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"google.golang.org/protobuf/proto\"\n\t\"google.golang.org/protobuf/types/known/anypb\"\n\t\"google.golang.org/protobuf/types/known/structpb\"\n\t\"google.golang.org/third_party/thrift/protocol\"\n\t\"google.golang.org/third_party/thrift/transport\"\n)\n\nfunc MarshalError(method string, err error) []byte {\n\t// Create a new Any message to hold the error\n\terrMsg := &anypb.Any{\n\t\tTypeUrl: \"type.googleapis.com/google.rpc.Error\",\n\t\tValue: &structpb.Struct{\n\t\t\tFields: map[string]*structpb.Value{\n\t\t\t\t\"message\": {\n\t\t\t\t\tKind: &structpb.Value_StringValue{\n\t\t\t\t\t\tStringValue: method + \": \" + err.Error(),\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Marshal the error message to bytes\n\terrBytes, _ := proto.Marshal(errMsg)\n\n\t// Create a new TBinaryProtocol\n\tproto := protocol.NewTBinaryProtocol(transport.NewBuffer(nil))\n\n\t// Write the error bytes to the protocol\n\tproto.WriteMessageBegin(\"Error\")\n\tproto.WriteI32(len(errBytes))\n\tproto.WriteMessageBegin(\"error\")\n\tproto.WriteMessageBegin(\"value\")\n\tproto.WriteMessageBegin(\"struct\")\n\tproto.WriteMessageBegin(\"fields\")\n\tproto.WriteMessageBegin(\"map<str,str>\")\n\tproto.WriteMessageBegin(\"key\")\n\tproto.WriteMessageBegin(\"string\")\n\tproto.WriteString(\"message\")\n\tproto.WriteMessageEnd()\n\tproto.WriteMessageBegin(\"value\")\n\tproto.WriteMessageBegin(\"string\")\n\tproto.WriteString(err.Error())\n\tproto.WriteMessageEnd()\n\tproto.WriteMessageEnd()\n\tproto.WriteMessageEnd()\n\tproto.WriteMessageEnd()\n\n\t// Get the bytes of the protocol\n\tbuf := proto.GetBuffer()\n\tbuf.Flush()\n\n\treturn buf.Bytes()\n}\n```", "```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"log\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n)\n\nfunc MarshalError(method string, err error) []byte {\n\t// Create a new TException\n\tvar (\n\t\texception = thrift.NewTApplicationException()\n\t)\n\n\t// Set the exception type and message\n\texception.Type = thrift.NewTString(\"Error\")\n\texception.Message = thrift.NewTString(method + \": \" + err.Error())\n\n\t// Create a TTransport\n\ttransport := thrift.NewTMemoryBuffer()\n\n\t// Create a TProtocol\n\tprotocol := thrift.NewTBinaryProtocoltransport)\n\n\t// Write the exception to the protocol\n\texception.Write(protocol)\n\n\t// Get the encoded bytes\n\tencoded := transport.GetBuffer()\n\n\treturn encoded\n}\n```", "```go\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"errors\"\n    \"fmt\"\n    \"log\"\n    \"strconv\"\n\n    \"github.com/apache/thrift/lib/go/thrift\"\n)\n\nfunc MarshalError(method string, err error) []byte {\n    // Create a new Thrift protocol\n    proto := thrift.NewTCompactProtocolFactory().GetProtocol(nil)\n\n    // Create a new Thrift exception\n    thriftErr := thrift.NewTApplicationException()\n    thriftErr.SetName(method)\n    thriftErr.SetMessage(err.Error())\n\n    // Encode the exception\n    encoder, err := thrift.NewTMemoryBuffer(thriftErr.Size())\n    if err != nil {\n        log.Fatal(err)\n    }\n    proto.WriteMessageBegin(thriftERR, thrift.TMessageType_EXCEPTION, 0)\n    proto.WriteMessageEnd()\n    proto.Flush(encoder)\n    data := encoder.GetBuffer()\n\n    // Encode the error code\n    code := strconv.Itoa(int(err.(*errors.errorString).Errno()))\n    binary.BigEndian.PutUint32(data, uint32(code))\n\n    return data\n}\n```"]}, "kitex-pkg/utils/rpcstats.go-CalculateEventCost": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CalculateEventCost(rpcstats rpcinfo.RPCStats, start, end stats.Event) time.Duration {\n# Natural Language Annotations: // CalculateEventCost get events from rpcstats, and calculates the time duration of (end - start).\n// It returns 0 when get nil rpcinfo event of either stats event.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom datetime import datetime\n\ndef calculate_event_cost(rpcstats, start, end):\n    \"\"\"\n    Calculate the time duration between two events in rpcstats.\n\n    Args:\n        rpcstats (rpcinfo.RPCStats): An instance of RPCStats.\n        start (stats.Event): The start event.\n        end (stats.Event): The end event.\n\n    Returns:\n        time.Duration: The time duration between the two events. Returns 0 if either start or end is None.\n    \"\"\"\n    if start is None or end is None:\n        return 0\n\n    start_time = datetime.strptime(start.Timestamp, '%Y-%m-%dT%H:%M:%SZ')\n    end_time = datetime.strptime(end.Timestamp, '%Y-%m-%dT%H:%M:%SZ')\n\n    return (end_time - start_time).total_seconds()\n```", "```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom typing import Optional\n\n@dataclass\nclass Event:\n    timestamp: datetime\n\n@dataclass\nclass RPCStats:\n    events: list[Event]\n\ndef calculate_event_cost(rpcstats: RPCStats, start: Event, end: Event) -> Optional[float]:\n    \"\"\"\n    Calculate the time duration between two events.\n\n    Args:\n    rpcstats (RPCStats): RPC stats containing a list of events.\n    start (Event): The start event.\n    end (Event): The end event.\n\n    Returns:\n    float: The time duration between the start and end events in seconds. Returns 0 if either the start or end event is None.\n    \"\"\"\n    if start is None or end is None:\n        return 0\n\n    return (end.timestamp - start.timestamp).total_seconds()\n```", "```python\nfrom dataclasses import dataclass\nfrom datetime import datetime\n\n@dataclass\nclass RPCStats:\n    event: object\n\n@dataclass\nclass Event:\n    timestamp: datetime\n\ndef calculate_event_cost(rpcstats: RPCStats, start: Event, end: Event) -> int:\n    \"\"\"\n    Calculate the time duration of an event.\n\n    Args:\n        rpcstats (RPCStats): RPC stats.\n        start (Event): Start event.\n        end (Event): End event.\n\n    Returns:\n        int: Time duration in seconds. Returns 0 if either start or end is None.\n    \"\"\"\n    if not rpcstats.event or not start or not end:\n        return 0\n\n    start_time = start.timestamp\n    end_time = end.timestamp\n\n    if start_time > end_time:\n        return 0\n\n    return (end_time - start_time).total_seconds()\n```"]}, "kitex-pkg/utils/json.go-_Map2JSONStr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func _Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n# Natural Language Annotations: // Map2JSONStr transform map[string]string to json str, perf is better than use json lib directly\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"strconv\"\n)\n\nfunc Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n\tjsonStr := \"\"\n\tfor k, v := range mapInfo {\n\t\tjsonStr += \"\\\"\" + k + \"\\\":\\\"\" + v + \"\\\",\"\n\t}\n\tjsonStr = jsonStr[:len(jsonStr)-1] // remove the last comma\n\tjsonStr = \"{\" + jsonStr + \"}\"\n\treturn jsonStr, nil\n}\n\nfunc main() {\n\tmapInfo := map[string]string{\n\t\t\"name\":  \"John\",\n\t\t\"age\":  \"30\",\n\t\t\"city\": \"New York\",\n\t}\n\tstr, err := Map2JSONStr(mapInfo)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(str)\n}\n```", "```javascript\nfunction map2jsonstr(mapInfo) {\n    let jsonStr = '{';\n    for (let key in mapInfo) {\n        jsonStr += '\"' + key + '\": \"' + mapInfo[key] + '\", ';\n    }\n    jsonStr = jsonStr.slice(0, -2) + '}';\n    return jsonStr;\n}\n```", "```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"strings\"\n)\n\nfunc Map2JSONStr(mapInfo map[string]string) (str string, err error) {\n    var bytes []byte\n    bytes, err = json.Marshal(mapInfo)\n    if err != nil {\n        return\n    }\n    str = string(bytes)\n    str = strings.ReplaceAll(str, \"\\\"\\\"\", \"\\\"\")\n    str = strings.ReplaceAll(str, \"\\\\n\", \"\\n\")\n    return\n}\n\nfunc main() {\n    mapInfo := map[string]string{\n        \"name\":  \"John\",\n        \"age\":   \"30\",\n        \"email\": \"john@example.com\",\n    }\n    str, err := Map2JSONStr(mapInfo)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(str)\n}\n```"]}, "kitex-pkg/utils/json.go-_JSONStr2Map": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func _JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n# Natural Language Annotations: // JSONStr2Map transform json str to map[string]string, perf is better than use json lib directly\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\nfunc JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n\tvar mapInfoMap map[string]interface{}\n\terr = json.Unmarshal([]byte(jsonStr), &mapInfoMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tmapInfo = make(map[string]string)\n\tfor k, v := range mapInfoMap {\n\t\tmapInfo[k] = v.(string)\n\t}\n\treturn\n}\n\nfunc main() {\n\tjsonStr := `{\"name\": \"John\", \"age\": 30}`\n\tmapInfo, err := JSONStr2Map(jsonStr)\n\tif err != nil {\n\t\tprintln(err.Error())\n\t\treturn\n\t}\n\tfor k, v := range mapInfo {\n\t\tprintln(k, v)\n\t}\n}\n```", "```go\npackage main\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"strconv\"\n    \"strings\"\n)\n\nfunc JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n    // check if the input is empty\n    if len(jsonStr) == 0 {\n        return nil, errors.New(\"input is empty\")\n    }\n\n    // remove leading and trailing whitespace\n    jsonStr = strings.TrimSpace(jsonStr)\n\n    // check if the input is a valid JSON string\n    var info interface{}\n    err = json.Unmarshal([]byte(jsonStr), &info)\n    if err != nil {\n        return nil, err\n    }\n\n    // if the input is a map\n    if m, ok := info.(map[string]interface{}); ok {\n        mapInfo = make(map[string]string)\n        for k, v := range m {\n            switch v := v.(type) {\n            case string:\n                mapInfo[k] = v\n            case float64:\n                mapInfo[k] = strconv.FormatFloat(v, 'f', -1, 64)\n            default:\n                return nil, errors.New(\"unsupported value type in JSON\")\n            }\n        }\n        return mapInfo, nil\n    } else {\n        return nil, errors.New(\"input is not a map\")\n    }\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n)\n\nfunc JSONStr2Map(jsonStr string) (mapInfo map[string]string, err error) {\n\tvar data map[string]interface{}\n\terr = json.Unmarshal([]byte(jsonStr), &data)\n\tif err != nil {\n\t\treturn\n\t}\n\tmapInfo = make(map[string]string)\n\tfor k, v := range data {\n\t\tmapInfo[k] = v.(string)\n\t}\n\treturn\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCaller": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCaller(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCaller is used to get the Service Name of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport inspect\nfrom typing import Context\n\ndef get_caller(ctx: Context) -> tuple:\n    \"\"\"\n    Get the Service Name of the caller.\n    \n    Args:\n    ctx (Context): The context object.\n    \n    Returns:\n    tuple: A tuple containing the service name and a boolean indicating whether the operation was successful.\n    \"\"\"\n    try:\n        # Get the current frame\n        frame = inspect.stack()[2]\n        # Get the function name from the frame\n        func_name = frame.function\n        # Extract the class name from the function name\n        service_name = func_name.split('.')[0]\n        # Return the service name and True to indicate success\n        return service_name, True\n    except Exception as e:\n        # Return an empty string and False to indicate failure\n        return \"\", False\n```", "```python\nimport inspect\n\ndef get_caller(ctx):\n    \"\"\"\n    Get the Service Name of the caller.\n\n    Args:\n        ctx (context.Context): The context object.\n\n    Returns:\n        tuple: A string representing the service name and a boolean indicating whether the information was retrieved successfully.\n    \"\"\"\n    try:\n        stack = inspect.stack()\n        frame = stack[2]\n        module_name = inspect.getmodule(frame[0]).__name__\n        service_name = module_name.split('.')[-1]\n        return service_name, True\n    except Exception:\n        return '', False\n```", "```sql\nfunc GetCaller(ctx context.Context) (string, bool) {\n    // Get the caller's PC address\n    pc, ok := ctx.Value(\"caller\").(string)\n    if !ok {\n        return \"\", false\n    }\n    // Get the function name from the caller's PC address\n    funcName := runtime.FuncForPC(pc).Name()\n    // Extract the service name from the function name\n    serviceName := strings.Split(funcName, \".\")[0]\n    return serviceName, true\n}\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetMethod(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetMethod is used to get the current RPC Method name.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom grpc import RpcError\n\ndef get_method(ctx):\n    \"\"\"\n    Get the current RPC method name.\n\n    Args:\n        ctx (grpc.ServicerContext): The context of the RPC call.\n\n    Returns:\n        tuple: A tuple containing the method name and a boolean indicating whether the operation was successful.\n    \"\"\"\n    try:\n        method_name = ctx.method().name\n        return method_name, True\n    except RpcError:\n        return None, False\n```", "```python\nimport grpc\nfrom google.protobuf.descriptor import FieldDescriptor\n\ndef get_method(ctx):\n    # Get the method name from the context\n    method = ctx.invocation_metadata().get('method')\n    if method:\n        return method, True\n    else:\n        return '', False\n```", "```python\nimport contextvars\n\ndef get_method(ctx):\n    method_var = contextvars.get('method')\n    if method_var is None:\n        return '', False\n    else:\n        return method_var, True\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerHandlerMethod": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerHandlerMethod(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCallerHandlerMethod is used to get the method name of caller.\n// Only the caller is a Kitex server will have this method information by default, or you can set K_METHOD into context.Context then kitex will get it.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef get_caller_handler_method(ctx):\n    \"\"\"\n    Get the method name of the caller.\n\n    Args:\n        ctx (context.Context): The context object.\n\n    Returns:\n        tuple: A tuple containing the method name and a boolean indicating whether the operation was successful.\n    \"\"\"\n    import inspect\n    frame = inspect.stack()[1]  # Get the caller's frame\n    return frame.function, True\n```", "```python\nfrom kitex.core import ctx\n\ndef get_caller_handler_method(ctx):\n    \"\"\"\n    Get the method name of the caller.\n\n    Args:\n    ctx (context.Context): The context of the caller.\n\n    Returns:\n    tuple: A tuple containing the method name and a boolean indicating whether the information was successfully obtained.\n    \"\"\"\n    method_name = ctx.get('K_METHOD')\n    if method_name is None:\n        method_name = ctx.get('kitex_server_method')\n    return method_name if method_name is not None else ('', False)\n```", "```python\nimport contextvars\nfrom typing import ContextManager\n\n# Create a context variable to store the method name\nmethod_name = contextvars.ContextVar('method_name', default=None)\n\ndef GetCallerHandlerMethod(ctx: ContextManager) -> (str, bool):\n    \"\"\"\n    Get the method name of the caller.\n\n    Only the caller is a Kitex server will have this method information by default, \n    or you can set K_METHOD into context.Context then kitex will get it.\n    \n    Return false if failed to get the information.\n    \"\"\"\n    try:\n        # Get the method name from the context\n        method_name.set(ctx.get('K_METHOD'))\n        return method_name.get(), True\n    except KeyError:\n        # Return the default method name if not found\n        return 'Unknown', False\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetIDLServiceName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetIDLServiceName(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetIDLServiceName gets the serviceName which defined in IDL.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Dict, Any\nimport contextlib\n\ndef get_idl_service_name(ctx: Dict[str, Any]) -> (str, bool):\n    try:\n        service_name = ctx.get('serviceName')\n        if service_name:\n            return service_name, True\n        else:\n            return '', False\n    except Exception as e:\n        return '', False\n```", "```python\nfrom typing import Context\n\ndef get_idl_service_name(ctx: Context) -> tuple[str, bool]:\n    # Implement your logic to get the serviceName from IDL here\n    # For example, let's assume we have a function called 'get_service_name_from_idl' that does this\n    service_name = get_service_name_from_idl()\n    \n    # Return the service name and a boolean indicating success or failure\n    return service_name, True if service_name else False\n```", "```python\nfrom google.cloud import aiplatform\nfrom google.cloud import aiplatform_v1\n\ndef get_idl_service_name(ctx):\n    \"\"\"\n    Get the serviceName which defined in IDL.\n\n    Args:\n        ctx (context.Context): The context of the function call.\n\n    Returns:\n        tuple: A tuple containing the serviceName and a boolean indicating whether the operation was successful.\n    \"\"\"\n    try:\n        # Create a client instance\n        aiplatform_v1beta1 = aiplatform_v1 beta1\n        client = aiplatform_v1beta1.IdlServiceClient()\n\n        # Get the IDL service name\n        service_name = client.get_service().name\n\n        # Return the service name and True to indicate success\n        return service_name, True\n\n    except Exception as e:\n        # Return an empty string and False to indicate failure\n        return \"\", False\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerAddr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerAddr(ctx context.Context) (net.Addr, bool) {\n# Natural Language Annotations: // GetCallerAddr is used for the server to get the Address of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net\"\n\t\"sync\"\n)\n\nvar (\n\tremoteAddrKey = &sync.Mutex{}\n\tremoteAddr     string\n)\n\nfunc GetCallerAddr(ctx context.Context) (net.Addr, bool) {\n\tremoteAddrKey.Lock()\n\tdefer remoteAddrKey.Unlock()\n\n\tremote, ok := net.FromNet(ctx)\n\tif !ok {\n\t\treturn nil, false\n\t}\n\n\treturn remote, true\n}\n```", "```python\nimport inspect\n\ndef get_caller_addr(ctx):\n    \"\"\"\n    Get the address of the caller of this function.\n    \n    Args:\n        ctx: The context of the function call.\n    \n    Returns:\n        A tuple containing the address of the caller and a boolean indicating whether the operation was successful.\n    \"\"\"\n    try:\n        frame, _, _, _, frame_info = inspect.stack()[1]\n        return frame_info.function, True\n    except Exception:\n        return None, False\n```", "```python\nimport inspect\n\ndef get_caller_addr():\n    \"\"\"\n    Get the address of the caller.\n\n    Returns:\n        tuple: A tuple containing the address of the caller and a boolean indicating whether the operation was successful.\n    \"\"\"\n    caller_frame = inspect.stack()[2]\n    caller_module = inspect.getmodule(caller_frame[0])\n    if caller_module is None:\n        return None, False\n    try:\n        addr = caller_module.__file__\n        return addr, True\n    except Exception:\n        return None, False\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetCallerIP": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetCallerIP(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetCallerIP is used for the server to get the IP of the caller.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc GetCallerIP(ctx context.Context) (string, bool) {\n\t// Get the client's IP address from the Gin context\n\tIP := ctx.Value(\"remoteaddr\")\n\n\t// If the IP is not found, return an empty string and false\n\tif IP == nil {\n\t\treturn \"\", false\n\t}\n\n\t// Return the IP as a string and true\n\treturn IP.(string), true\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\nfunc GetCallerIP(ctx context.Context) (string, bool) {\n\tc, ok := ctx.Value(\"remote_ip\")).(string)\n\tif !ok {\n\t\tc = ctx.Value(\"X-Real-IP\").(string)\n\t\tif c == \"\" {\n\t\t\tc = ctx.Value(\"X-Forwarded-For\").(string)\n\t\t}\n\t\tc = strings.TrimSpace(c)\n\t\tif c == \"\" {\n\t\t\treturn \"\", false\n\t\t}\n\t}\n\treturn c, true\n}\n\nfunc main() {\n\tr := gin.Default()\n\tr.Use(func(c *gin.Context) {\n\t\tc.Set(\"remote_ip\", c.ClientIP())\n\t\tc.Next()\n\t})\n\tr.GET(\"/test\", func(c *gin.Context) {\n\t\tip, ok := GetCallerIP(c.Request.Context())\n\t\tif !ok {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": \"Failed to get caller's IP\"})\n\t\t\treturn\n\t\t}\n\t\tc.JSON(http.StatusOK, gin.H{\"caller_ip\": ip})\n\t})\n\tr.Run(\":8080\")\n}\n```", "```python\nimport logging\nimport functools\nimport ipaddress\nfrom flask import request\n\ndef get_caller_ip():\n    try:\n        remote_addr = request.remote_addr\n        if remote_addr:\n            ipaddress.ip_address(remote_addr)\n            return remote_addr, True\n    except Exception as e:\n        logging.error(f\"Failed to get caller's IP: {e}\")\n    return None, False\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetTransportProtocol": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetTransportProtocol(ctx context.Context) (string, bool) {\n# Natural Language Annotations: // GetTransportProtocol gets the transport protocol of the request.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Context\n\ndef get_transport_protocol(ctx: Context) -> (str, bool):\n    # Get the transport protocol of the request\n    try:\n        protocol = ctx.Request().URL.Scheme\n        return protocol, True\n    except Exception:\n        return \"\", False\n```", "```python\nfrom typing import ContextManager\n\ndef get_transport_protocol(ctx: ContextManager) -> (str, bool):\n    # Get the transport protocol of the request\n    try:\n        # Assuming ctx is a request object with a transport protocol attribute\n        protocol = ctx.transport_protocol\n        return protocol, True\n    except AttributeError:\n        # Return false if failed to get the information\n        return \"\", False\n```", "```python\ndef get_transport_protocol(ctx):\n    \"\"\"\n    Gets the transport protocol of the request.\n    \n    Args:\n        ctx (context.Context): The context of the request.\n    \n    Returns:\n        tuple: A tuple containing the transport protocol and a boolean indicating if the information was retrieved successfully.\n    \"\"\"\n    transport_protocol = ctx.Request().URL.Scheme\n    return transport_protocol, True\n```"]}, "kitex-pkg/utils/kitexutil/kitexutil.go-GetRPCInfo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GetRPCInfo(ctx context.Context) (rpcinfo.RPCInfo, bool) {\n# Natural Language Annotations: // GetRPCInfo gets the RPCInfo in ctx.\n// Return false if failed to get the information.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Context\n\nclass RPCInfo:\n    pass\n\ndef GetRPCInfo(ctx: Context) -> (RPCInfo, bool):\n    try:\n        # Assuming ctx is an object with an RPCInfo attribute\n        rpc_info = ctx.RPCInfo\n        return rpc_info, True\n    except AttributeError:\n        return None, False\n```", "```python\nfrom grpc import RpcInfo\n\ndef get_rpc_info(ctx):\n    try:\n        rpc_info = RpcInfo.from_context(ctx)\n        return rpc_info, True\n    except Exception:\n        return None, False\n```", "```python\nfrom typing import Dict\n\nclass rpcinfo:\n    def __init__(self, rpcinfo: Dict):\n        self.rpcinfo = rpcinfo\n\ndef GetRPCInfo(ctx: Dict) -> (rpcinfo, bool):\n    try:\n        rpc_info = ctx['rpc_info']\n        return rpcinfo(rpc_info), True\n    except KeyError:\n        return rpcinfo(None), False\n```"]}, "kitex-pkg/remote/trans_errors.go-NewTransError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewTransError(typeID int32, err error) *TransError {\n# Natural Language Annotations: // NewTransError to build TransError with typeID and rawErr.\n// rawErr can be used by errors.Is(target) to check err type, like read timeout.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\ntype TransError struct {\n    TypeID int32\n    Err    error\n}\n\nfunc NewTransError(typeID int32, err error) *TransError {\n    return &TransError{\n        TypeID: typeID,\n        Err:    err,\n    }\n}\n```", "```go\ntype TransError struct {\n    TypeID int32\n    RawErr error\n}\n\nfunc NewTransError(typeID int32, err error) *TransError {\n    return &TransError{\n        TypeID: typeID,\n        RawErr: err,\n    }\n}\n```", "```go\ntype TransError struct {\n    TypeID int32\n    Err    error\n}\n\nfunc NewTransError(typeID int32, err error) *TransError {\n    return &TransError{\n        TypeID: typeID,\n        Err:    err,\n    }\n}\n```"]}, "kitex-pkg/remote/trans/gonet/bytebuffer.go-NewBufferReader": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBufferReader(ir io.Reader) remote.ByteBuffer {\n# Natural Language Annotations: // NewBufferReader creates a new remote.ByteBuffer using the given netpoll.ZeroCopyReader.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewBufferReader(ir io.Reader) *remote.ByteBuffer {\n    return remote.NewByteBuffer(ir)\n}\n```", "```go\nfunc NewBufferReader(ir io.Reader) *remote.ByteBuffer {\n    return &remote.ByteBuffer{Reader: ir}\n}\n```", "```go\nfunc NewBufferReader(ir io.Reader) *remote.ByteBuffer {\n    return &remote.ByteBuffer{Reader: netpoll.ZeroCopyReader{R: ir}}\n}\n```"]}, "kitex-pkg/remote/trans/gonet/bytebuffer.go-WriteDirect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n# Natural Language Annotations: // WriteDirect is a way to write []byte without copying, and splits the original buffer.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n    if len(p) > remainCap {\n        return errors.New(\"not enough capacity in the buffer\")\n    }\n    copy(rw.buf[:remainCap], p)\n    rw.offset += len(p)\n    rw.r = rw.offset\n    return nil\n}\n```", "```go\nfunc (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n    // Check if the buffer has enough capacity to write the entire byte slice\n    if remainCap < cap(p) {\n        return errors.New(\"not enough capacity in the buffer\")\n    }\n\n    // Calculate the number of bytes that can be written to the buffer\n    writeCap := min(remainCap, len(p))\n\n    // Copy the byte slice to the buffer\n    copy(rw.buf[0:writeCap], p[:writeCap])\n\n    // Update the remaining capacity\n    rw.remainCap -= writeCap\n\n    // Move the buffer pointer forward\n    rw.buf = rw.buf[writeCap:]\n\n    return nil\n}\n\nfunc min(a, b int) int {\n    if a < b {\n        return a\n    }\n    return b\n}\n```", "```go\nfunc (rw *bufferReadWriter) WriteDirect(p []byte, remainCap int) error {\n    if len(p) > remainCap {\n        return errors.New(\"write size exceeds remaining capacity\")\n    }\n    if len(p) > len(rw.buf) {\n        // split the buffer\n        newBuf := make([]byte, len(rw.buf)+remainCap)\n        copy(newBuf, rw.buf)\n        rw.buf = newBuf\n    }\n    copy(rw.buf[len(rw.buf)-remainCap:], p)\n    rw.offset += len(p)\n    return nil\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/server_handler.go-invokeStreamUnaryHandler": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func invokeStreamUnaryHandler(ctx context.Context, st streaming.Stream, mi serviceinfo.MethodInfo,\n# Natural Language Annotations: // invokeStreamUnaryHandler allows unary APIs over HTTP2 to use the same server middleware as non-streaming APIs.\n// For thrift unary APIs over HTTP2, it's enabled by default.\n// For grpc(protobuf) unary APIs, it's disabled by default to keep backward compatibility.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom contextlib import contextmanager\nfrom typing import ContextManager\n\nclass StreamingStream:\n    pass\n\nclass MethodInfo:\n    pass\n\nclass ServiceInfo:\n    class MethodInfo:\n        pass\n\nclass Context:\n    pass\n\ndef invokeStreamUnaryHandler(ctx: Context, st: StreamingStream, mi: ServiceInfo.MethodInfo) -> ContextManager:\n    if isinstance(mi, ServiceInfo.MethodInfo) and isinstance(st, StreamingStream):\n        # For thrift unary APIs over HTTP2, it's enabled by default\n        # For grpc(protobuf) unary APIs, it's disabled by default to keep backward compatibility\n        if hasattr(mi, 'grpc_api') and mi.grpc_api:\n            return None\n        else:\n            return st\n    else:\n        return st\n```", "```python\ndef invokeStreamUnaryHandler(ctx, stream, method_info):\n    \"\"\"\n    invokeStreamUnaryHandler allows unary APIs over HTTP2 to use the same server middleware as non-streaming APIs.\n    \n    For thrift unary APIs over HTTP2, it's enabled by default.\n    \n    For grpc(protobuf) unary APIs, it's disabled by default to keep backward compatibility.\n    \n    :param ctx: The context.\n    :param stream: The streaming stream.\n    :param method_info: The service info.\n    :return: None\n    \"\"\"\n    if isinstance(stream, grpc.Stream) and isinstance(method_info, grpc.MethodInfo):\n        # Check if the method info is a unary method\n        if method_info.unary_only:\n            # Enable unary handler for grpc unary APIs\n            # We assume that the unary handler is implemented elsewhere in the codebase\n            unary_handler = getUnaryHandler(method_info)\n            unary_handler(ctx, stream)\n        else:\n            # If it's not a unary method, just pass through to the default handler\n            pass\n    elif isinstance(stream, http2.Stream):\n        # For thrift unary APIs over HTTP2, invoke the unary handler\n        unary_handler = getUnaryHandler(method_info)\n        unary_handler(ctx, stream)\n    else:\n        # For other types of streams, just pass through to the default handler\n        pass\n```", "```python\ndef invokeStreamUnaryHandler(ctx context.Context, st streaming.Stream, mi serviceinfo.MethodInfo):\n    # Check if the API is a unary API\n    if not mi.is_unary:\n        return False\n\n    # Check if the API is a gRPC API\n    if mi.api_type == 'grpc':\n        # For gRPC APIs, it's disabled by default to keep backward compatibility\n        return False\n\n    # For other APIs (like thrift), it's enabled by default\n    return True\n```"]}, "kitex-pkg/remote/trans/nphttp2/metadata/metadata.go-FromOutgoingContext": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromOutgoingContext(ctx context.Context) (MD, bool) {\n# Natural Language Annotations: // FromOutgoingContext returns the outgoing metadata in ctx if it exists.  The\n// returned MD should not be modified. Writing to it may cause races.\n// Modification should be made to copies of the returned MD.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom contextlib import contextmanager\nfrom typing import Dict\n\ndef from_outgoing_context(ctx):\n    \"\"\"\n    Returns the outgoing metadata in ctx if it exists.\n    \n    The returned MD should not be modified. Writing to it may cause races.\n    Modification should be made to copies of the returned MD.\n    \n    Args:\n        ctx (Dict): The context object.\n    \n    Returns:\n        Dict: The outgoing metadata if it exists, otherwise an empty dictionary.\n        bool: Whether the outgoing metadata exists.\n    \"\"\"\n    @contextmanager\n    def get_metadata():\n        metadata = ctx.get('metadata')\n        if metadata is not None:\n            yield metadata.copy()\n        else:\n            yield {}\n    \n    with get_metadata() as md:\n        return md, metadata is not None\n```", "```python\nfrom typing import Dict\n\ndef from_outgoing_context(ctx: Dict) -> (Dict, bool):\n    \"\"\"\n    Returns the outgoing metadata in ctx if it exists.\n    \n    Args:\n    ctx: The context from which to retrieve the outgoing metadata.\n    \n    Returns:\n    A tuple of the outgoing metadata and a boolean indicating whether the metadata existed in the context.\n    \"\"\"\n    md = ctx.get('md')\n    return md, md is not None\n```", "```python\nfrom typing import Dict\n\ndef from_outgoing_context(ctx):\n    \"\"\"\n    Returns the outgoing metadata in ctx if it exists. \n    The returned MD should not be modified. Writing to it may cause races.\n    Modification should be made to copies of the returned MD.\n    \n    Args:\n        ctx (context.Context): The context containing the outgoing metadata.\n    \n    Returns:\n        tuple: A tuple containing the outgoing metadata and a boolean indicating if the metadata exists.\n    \"\"\"\n    metadata = ctx.get('metadata')\n    if metadata is not None:\n        return metadata.copy(), True\n    else:\n        return {}, False\n```"]}, "kitex-pkg/remote/trans/nphttp2/status/status.go-WithDetails": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Status) WithDetails(details ...proto.Message) (*Status, error) {\n# Natural Language Annotations: // WithDetails returns a new status with the provided details messages appended to the status.\n// If any errors are encountered, it returns nil and the first error encountered.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Status:\n    def __init__(self, code, message):\n        self.code = code\n        self.message = message\n        self.details = []\n\n    def WithDetails(self, *details):\n        for detail in details:\n            if not isinstance(detail, str):\n                return None, f\"Invalid detail: {detail}\"\n            self.details.append(detail)\n        return self, None\n```", "```python\nclass Status:\n    def __init__(self, code, message):\n        self.code = code\n        self.message = message\n        self.details = []\n\n    def WithDetails(self, *details):\n        new_status = Status(self.code, self.message)\n        new_status.details = self.details + list(details)\n        return new_status, None\n\nclass proto_Message:\n    def __init__(self, message):\n        self.message = message\n\ndef main():\n    status = Status(200, \"OK\")\n    detail1 = proto_Message(\"Detail 1\")\n    detail2 = proto_Message(\"Detail 2\")\n    new_status, error = status.WithDetails(detail1.message, detail2.message)\n    print(new_status.code)\n    print(new_status.message)\n    for detail in new_status.details:\n        print(detail)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\ndef with_details(self, *details):\n    \"\"\"\n    Returns a new status with the provided details messages appended to the status.\n    If any errors are encountered, it returns None and the first error encountered.\n    \"\"\"\n    new_status = self.copy()\n    for detail in details:\n        try:\n            new_status.details.append(detail)\n        except Exception as e:\n            return None, e\n    return new_status, None\n```"]}, "kitex-pkg/remote/trans/nphttp2/status/status.go-FromError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromError(err error) (s *Status, ok bool) {\n# Natural Language Annotations: // FromError returns a Status representing err if it was produced from this\n// package or has a method `GRPCStatus() *Status`. Otherwise, ok is false and a\n// Status is returned with codes.Unknown and the original error message.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef from_error(err):\n    \"\"\"\n    Returns a Status representing err if it was produced from this package or has a method `GRPCStatus() *Status`. \n    Otherwise, ok is false and a Status is returned with codes.Unknown and the original error message.\n    \"\"\"\n    if hasattr(err, 'GRPCStatus'):\n        return err.GRPCStatus()\n    else:\n        return {\"code\": \"UNKNOWN\", \"message\": str(err)}, False\n```", "```python\ndef from_error(err):\n    \"\"\"\n    Returns a Status representing err if it was produced from this package or has a method `GRPCStatus() *Status`.\n    Otherwise, ok is false and a Status is returned with codes.UNKNOWN and the original error message.\n    \"\"\"\n    if hasattr(err, 'GRPCStatus'):\n        return err.GRPCStatus()\n    else:\n        return {\"ok\": False, \"status\": \"UNKNOWN\", \"message\": str(err)}\n```", "```python\nfrom google.rpc import status\n\ndef from_error(err):\n    if hasattr(err, 'grpc_status'):\n        return status.from_grpc_error(err), True\n    else:\n        return status.Unknown('Unknown error: ' + str(err)), False\n```"]}, "kitex-pkg/remote/trans/nphttp2/status/status.go-FromContextError": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FromContextError(err error) *Status {\n# Natural Language Annotations: // FromContextError converts a context error into a Status.  It returns a\n// Status with codes.OK if err is nil, or a Status with codes.Unknown if err is\n// non-nil and not a context error.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom google.cloud import error\n\ndef from_context_error(err):\n    if err is None:\n        return error.Code.OK\n    elif isinstance(err, error.Error):\n        return error.Code.UNKNOWN\n    else:\n        return error.Code.UNKNOWN\n```", "```python\nfrom grpc import Status\n\ndef from_context_error(err):\n    \"\"\"\n    Converts a context error into a Status.\n    \n    Args:\n        err: An error to convert.\n    \n    Returns:\n        A Status with codes.OK if err is None, or a Status with codes.UNKNOWN if err is non-nil and not a context error.\n    \"\"\"\n    if err is None:\n        return Status.OK\n    elif isinstance(err, Exception):\n        return Status.UNKNOWN\n    else:\n        return Status.UNKNOWN\n```", "```javascript\nclass Status {\n  static OK = { code: 0, message: 'OK' };\n  static Unknown = { code: 1, message: 'Unknown error' };\n\n  static FromContextError(err) {\n    if (!err) {\n      return Status.OK;\n    } else if (err instanceof Error && err.name === 'ContextError') {\n      return Status.Unknown;\n    } else {\n      return Status.Unknown;\n    }\n  }\n}\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/bdp_estimator.go-calculate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *bdpEstimator) calculate(d [8]byte) {\n# Natural Language Annotations: // calculate is called when an ack for a bdp ping is received.\n// Here we calculate the current bdp and bandwidth sample and\n// decide if the flow control windows should go up.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef calculate(self, d):\n    # calculate is called when an ack for a bdp ping is received\n    # Here we calculate the current bdp and bandwidth sample and\n    # decide if the flow control windows should go up.\n    \n    # Check if the received data is not empty\n    if d:\n        # Calculate the current bandwidth sample\n        bandwidth_sample = len(d) / self.time_to_ack\n        \n        # Calculate the current bdp\n        bdp = self.current_bdp + bandwidth_sample\n        \n        # Check if the flow control window should go up\n        if bdp > self.max_bdp:\n            self.max_bdp = bdp\n            self.flow_control_window = self.max_bdp\n            \n    else:\n        # If the received data is empty, reset the flow control window\n        self.flow_control_window = 0\n```", "```python\ndef calculate(self, d):\n    \"\"\"\n    Calculate the current bandwidth delay product (BDP) and bandwidth sample\n    and decide if the flow control window should be increased.\n    \n    Parameters:\n    d (bytearray): The ack for a bdp ping.\n    \n    Returns:\n    bool: True if the flow control window should be increased, False otherwise.\n    \"\"\"\n    # Calculate the current BDP\n    bdp = self.calculate_bdp(d)\n    \n    # Calculate the bandwidth sample\n    bandwidth_sample = self.calculate_bandwidth_sample(d)\n    \n    # Decide if the flow control window should be increased\n    if bandwidth_sample > self.get_bandwidth_threshold():\n        return True\n    else:\n        return False\n```", "```python\ndef calculate(self, data):\n    # Extract the sequence number and timestamp from the ack\n    seq_num = int.from_bytes(data[:4], 'big')\n    timestamp = int.from_bytes(data[4:8], 'big')\n\n    # Calculate the round-trip time (RTT)\n    rtt = timestamp - self.last_timestamp\n\n    # Calculate the bandwidth-delay product (BDP)\n    bdp = self.bdp_estimator.bdp\n\n    # Calculate the bandwidth sample\n    bandwidth = bdp / rtt\n\n    # Check if the flow control window should increase\n    if bandwidth > self.bandwidth_threshold:\n        self.flow_control_window += 1\n\n    # Update the last timestamp\n    self.last_timestamp = timestamp\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/http2_server.go-finishStream": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *http2Server) finishStream(s *Stream, rst bool, rstCode http2.ErrCode, hdr *headerFrame, eosReceived bool) {\n# Natural Language Annotations: // finishStream closes the stream and puts the trailing headerFrame into controlbuf.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef finishStream(self, stream, rst, rst_code, header_frame, eos_received):\n    \"\"\"\n    Closes the stream and puts the trailing headerFrame into controlbuf.\n    \n    Args:\n        stream: The stream to be closed.\n        rst: Whether to send a reset stream frame.\n        rst_code: The reset stream code.\n        header_frame: The trailing header frame to be put into controlbuf.\n        eos_received: Whether the end of stream has been received.\n    \"\"\"\n    # Close the stream\n    stream.Close()\n    \n    # Put the trailing header frame into controlbuf\n    self.controlbuf.append(header_frame)\n    \n    # If reset is True, send a reset stream frame\n    if rst:\n        # Create a reset stream frame\n        rst_frame = self.createResetStreamFrame(rst_code)\n        \n        # Send the reset stream frame\n        self.sendFrame(rst_frame)\n```", "```python\ndef finish_stream(self, stream, reset, reset_code, header_frame, eos_received):\n    \"\"\"\n    Closes the stream and puts the trailing headerFrame into controlbuf.\n    \n    Args:\n        stream (Stream): The stream to be closed.\n        reset (bool): Whether to reset the stream.\n        reset_code (http2.ErrCode): The reset code for the stream.\n        header_frame (HeaderFrame): The trailing header frame to be added to controlbuf.\n        eos_received (bool): Whether the end of stream has been received.\n    \"\"\"\n    stream.close()\n    self.controlbuf.append(header_frame)\n```", "```python\ndef finish_stream(self, s, rst, rst_code, hdr, eos_received):\n    \"\"\"\n    Closes the stream and puts the trailing headerFrame into controlbuf.\n    \n    :param s: The stream to close\n    :param rst: Whether to send a reset frame\n    :param rst_code: The reset code to include in the reset frame\n    :param hdr: The header frame to include in the controlbuf\n    :param eos_received: Whether the end of stream has been received\n    \"\"\"\n    s.close()\n    self.controlbuf.append(hdr)\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/http2_server.go-closeStream": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *http2Server) closeStream(s *Stream, rst bool, rstCode http2.ErrCode, eosReceived bool) {\n# Natural Language Annotations: // closeStream clears the footprint of a stream when the stream is not needed any more.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef close_stream(self, t, s, rst, rst_code, eos_received):\n    \"\"\"\n    Closes a stream in an HTTP/2 server.\n\n    Args:\n        t (http2.Server): The HTTP/2 server instance.\n        s (http2.Stream): The stream to be closed.\n        rst (bool): Whether to send a reset frame.\n        rst_code (http2.ErrCode): The error code to be sent in the reset frame.\n        eos_received (bool): Whether the end of stream has been received.\n    \"\"\"\n\n    # Check if the stream is not None\n    if s is not None:\n        # Clear the stream's footprint in the server\n        t.streams[s] = None\n\n        # If a reset frame is required, send it\n        if rst:\n            # Send a reset frame with the given error code\n            s.reset(rst_code)\n\n        # If the end of stream has been received, mark the stream as closed\n        if eos_received:\n            s.close()\n```", "```python\ndef close_stream(t, s, rst, rst_code, eos_received):\n    \"\"\"\n    Clears the footprint of a stream when the stream is not needed anymore.\n\n    Args:\n        t (http2Server): The http2 server instance.\n        s (Stream): The stream to be closed.\n        rst (bool): Whether to reset the stream.\n        rst_code (http2.ErrCode): The error code for the reset.\n        eos_received (bool): Whether end of stream is received.\n    \"\"\"\n    # Clear the stream's data\n    s.data = None\n    # Reset the stream if required\n    if rst:\n        s.reset(rst_code)\n    # Mark the end of the stream if required\n    if eos_received:\n        s.eos = True\n    # Remove the stream from the server's streams\n    t.streams.remove(s)\n```", "```python\ndef closeStream(t, s, rst, rstCode, eosReceived):\n    # Close the stream if it's not needed anymore\n    s.setClosed(True)\n    if rst:\n        s.reset(rstCode)\n    if eosReceived:\n        s.endStream()\n    else:\n        s.close()\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/transport.go-TLSConfig": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TLSConfig(tlsConfig *tls.Config) *tls.Config {\n# Natural Language Annotations: // TLSConfig checks and supplement the tls config provided by user.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef TLSConfig(tls_config):\n    \"\"\"\n    Checks and supplements the tls config provided by user.\n\n    Args:\n        tls_config (dict): The TLS configuration provided by the user.\n\n    Returns:\n        dict: The supplemented TLS configuration.\n    \"\"\"\n    # Check if tls_config has required fields\n    required_fields = ['ciphers', 'insecureSkipVerify']\n    for field in required_fields:\n        if field not in tls_config:\n            raise ValueError(f\"Missing required field: {field}\")\n\n    # Check if ciphers is a list\n    if not isinstance(tls_config['ciphers'], list):\n        raise ValueError(\"Ciphers must be a list\")\n\n    # Supplement the tls_config with default values\n    tls_config.setdefault('MinVersion', 1)\n    tls_config.setdefault('MaxVersion', 1)\n    tls_config.setdefault('CurvePreferences', ['X25519', 'P-384'])\n\n    return tls_config\n```", "```python\ndef TLSConfig(tls_config):\n    \"\"\"\n    Checks and supplements the tls config provided by user.\n    \n    :param tls_config: The tls config to be checked and supplemented.\n    :return: The supplemented tls config.\n    \"\"\"\n    \n    # Check if the provided config is None\n    if tls_config is None:\n        raise ValueError(\"TLS config cannot be None\")\n    \n    # Check if the provided config has a valid protocol version\n    if not tls_config.GetVersion():\n        raise ValueError(\"Invalid TLS protocol version\")\n    \n    # Check if the provided config has a valid cipher suite\n    if not tls_config.CipherSuites:\n        raise ValueError(\"Invalid cipher suite\")\n    \n    # Check if the provided config has a valid certificate\n    if not tls_config.GetCertificate():\n        raise ValueError(\"Invalid certificate\")\n    \n    # Supplement the config with default values if necessary\n    if not tls_config.MinVersion:\n        tls_config.MinVersion = 1.2\n    if not tls_config.MaxVersion:\n        tls_config.MaxVersion = 1.3\n    \n    return tls_config\n```", "```python\nimport ssl\n\ndef TLSConfig(tls_config):\n    \"\"\"\n    Checks and supplements the tls config provided by user.\n    \n    Args:\n        tls_config (dict): The tls config provided by user.\n    \n    Returns:\n        dict: The supplemented tls config.\n    \"\"\"\n    \n    # Check if tls_config is None, if so, create a default tls config\n    if tls_config is None:\n        tls_config = {}\n    \n    # Set the default values if not provided\n    if 'cert_reqs' not in tls_config:\n        tls_config['cert_reqs'] = ssl.CERT_REQUIRED\n    if 'ca_certs' not in tls_config:\n        tls_config['ca_certs'] = '/etc/ssl/certs/ca-certificates.pem'\n    if 'ciphers' not in tls_config:\n        tls_config['ciphers'] = 'ALL:@SECLEVEL=1'\n    \n    return tls_config\n```"]}, "kitex-pkg/remote/trans/nphttp2/grpc/http_util.go-encodeTimeout": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func encodeTimeout(t time.Duration) string {\n# Natural Language Annotations: // TODO(zhaoq): It is the simplistic and not bandwidth efficient. Improve it.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport base64\n\ndef encodeTimeout(t):\n    \"\"\"\n    Encode a given time.Duration into a string.\n    \n    Args:\n    t (time.Duration): The time.Duration to be encoded.\n    \n    Returns:\n    str: The encoded time.Duration as a string.\n    \"\"\"\n    # Convert time.Duration to bytes\n    bytes_t = str(t).encode('utf-8')\n    \n    # Encode bytes to base64\n    encoded_t = base64.b64encode(bytes_t)\n    \n    # Decode the bytes to string\n    encoded_t = encoded_t.decode('utf-8')\n    \n    return encoded_t\n```", "```python\nimport base64\nimport struct\n\ndef encodeTimeout(t):\n    # Convert time.Duration to uint64\n    uint64 = int(t.Nanoseconds() / 1e9)\n    # Convert uint64 to bytes\n    bytes = struct.pack('>Q', uint64)\n    # Encode bytes to base64\n    encoded = base64.b64encode(bytes)\n    return encoded.decode('utf-8')\n```", "```python\nimport base64\n\ndef encodeTimeout(t):\n    # TODO(zhaoq): It is the simplistic and not bandwidth efficient. Improve it.\n    return base64.b64encode(str(t).encode('utf-8')).decode('utf-8')\n```"]}, "kitex-pkg/remote/trans/netpoll/bytebuf.go-AppendBuffer": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *netpollByteBuffer) AppendBuffer(buf remote.ByteBuffer) (err error) {\n# Natural Language Annotations: // AppendBuffer appends buf to the original buffer.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef append_buffer(b, buf):\n    \"\"\"\n    Append buf to the original buffer.\n    \n    Args:\n        b (bytearray): The original buffer.\n        buf (bytearray): The buffer to be appended.\n    \n    Returns:\n        None\n    \"\"\"\n    b.extend(buf)\n```", "```python\ndef append_buffer(b, buf):\n    \"\"\"\n    AppendBuffer appends buf to the original buffer.\n    \n    Args:\n        b (bytearray): The original buffer.\n        buf (bytearray): The buffer to be appended.\n    \n    Returns:\n        None\n    \"\"\"\n    b.extend(buf)\n```", "```python\ndef append_buffer(self, buf):\n    \"\"\"\n    AppendBuffer appends buf to the original buffer.\n\n    Args:\n        buf (bytes): The buffer to append.\n\n    Returns:\n        None\n    \"\"\"\n    self.data += buf\n```"]}, "kitex-pkg/remote/codec/util.go-SetOrCheckMethodName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func SetOrCheckMethodName(methodName string, message remote.Message) error {\n# Natural Language Annotations: // SetOrCheckMethodName is used to set method name to invocation.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef set_or_check_method_name(method_name: str, message: dict) -> str:\n    \"\"\"\n    Set or check method name to invocation.\n\n    Args:\n        method_name (str): The name of the method.\n        message (dict): The message to be invoked.\n\n    Returns:\n        str: The result of the operation.\n    \"\"\"\n    if 'invocation' in message:\n        message['invocation'] = method_name\n        return f\"Method name '{method_name}' set to invocation.\"\n    else:\n        return f\"Method name '{method_name}' is not set to invocation.\"\n```", "```python\nclass Message:\n    def __init__(self, method_name, value=None):\n        self.method_name = method_name\n        self.value = value\n\ndef SetOrCheckMethodName(methodName, message):\n    if message.method_name == methodName:\n        return None\n    else:\n        message.method_name = methodName\n        return None\n```", "```python\ndef set_or_check_method_name(method_name: str, message: dict) -> str:\n    \"\"\"\n    Set or check method name to invocation.\n\n    Args:\n        method_name (str): The name of the method.\n        message (dict): A dictionary containing the method invocation details.\n\n    Returns:\n        str: The method name if it was set, otherwise None.\n    \"\"\"\n    if 'method_name' in message:\n        message['method_name'] = method_name\n        return method_name\n    else:\n        return None\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-MarshalThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MarshalThriftData(ctx context.Context, codec remote.PayloadCodec, data interface{}) ([]byte, error) {\n# Natural Language Annotations: // MarshalThriftData only encodes the data (without the prepending methodName, msgType, seqId)\n// It will allocate a new buffer and encode to it\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef marshal_thrift_data(ctx, codec, data):\n    \"\"\"\n    Marshal Thrift data without prepending methodName, msgType, seqId.\n\n    Args:\n        ctx (context.Context): The context.\n        codec (remote.PayloadCodec): The payload codec.\n        data (interface): The data to be marshaled.\n\n    Returns:\n        tuple: A tuple containing the marshaled data and an error if any.\n    \"\"\"\n    # Allocate a new buffer\n    buffer = bytearray()\n\n    # Encode data to the buffer\n    err := codec.Encode(data, buffer)\n\n    # Return the marshaled data and the error\n    return buffer, err\n```", "```go\npackage remote\n\nimport (\n    \"context\"\n    \"encoding/binary\"\n    \"errors\"\n\n    \"github.com/apache/thrift/lib/go/thrift\"\n)\n\nfunc MarshalThriftData(ctx context.Context, codec PayloadCodec, data interface{}) ([]byte, error) {\n    // Create a new buffer\n    buf := bytes.NewBuffer(make([]byte, 0, 1024))\n\n    // Encode data to the buffer\n    err := codec.Encode(data, buf)\n    if err != nil {\n        return nil, err\n    }\n\n    return buf.Bytes(), nil\n}\n```", "```python\nimport thrift\nfrom thrift import TSerializer\nfrom thrift.Thrift import TType\n\ndef MarshalThriftData(ctx, codec, data):\n    \"\"\"\n    Marshal Thrift data into a byte stream.\n\n    This function encodes the data into a Thrift byte stream without prepending the \n    methodName, msgType, seqId. It allocates a new buffer and encodes to it.\n\n    Args:\n        ctx (context.Context): A context object.\n        codec (remote.PayloadCodec): A Thrift payload codec.\n        data (interface): The data to be encoded.\n\n    Returns:\n        A tuple containing the encoded byte stream and an error.\n    \"\"\"\n    serializer = TSerializer()\n    buf = bytearray()\n    try:\n        serializer.begin(buf)\n        codec.write(data, serializer)\n        serializer.end()\n        return buf, None\n    except Exception as e:\n        return None, e\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-marshalBasicThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func marshalBasicThriftData(ctx context.Context, tProt thrift.TProtocol, data interface{}) error {\n# Natural Language Annotations: // marshalBasicThriftData only encodes the data (without the prepending method, msgType, seqId)\n// It uses the old thrift way which is much slower than FastCodec and Frugal\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport thrift.protocol.TProtocol\nfrom thrift.Thrift import TType\nfrom thrift.Thrift import TMessageType\n\ndef marshalBasicThriftData(ctx context.Context, tProt thrift.TProtocol, data interface{}) error {\n    return tProt.WriteMessageBegin(TMessageType.STRUCT, 0, 0)\n    for fieldId, field in enumerate(data.__dict__):\n        tProt.WriteFieldBegin(fieldId, field, TType.STRING)\n        tProt.WriteString(field)\n        tProt.WriteFieldEnd()\n    return tProt.WriteMessageEnd()\n}\n```", "```python\nimport contextlib\nimport thrift.protocol.TProtocol\n\ndef marshalBasicThriftData(ctx contextlib.Context, tProt thrift.TProtocol.TBinaryProtocol, data):\n    if not isinstance(data, (dict, list, int, float, str, bool, type(None))):\n        raise ValueError(\"Unsupported data type\")\n    \n    if isinstance(data, dict):\n        return tProt.writeStructBegin()\n        for key, value in data.items():\n            tProt.writeFieldBegin(key)\n            marshalBasicThriftData(ctx, tProt, value)\n            tProt.writeFieldEnd()\n        tProt.writeStructEnd()\n    elif isinstance(data, list):\n        tProt.writeListBegin(len(data))\n        for item in data:\n            marshalBasicThriftData(ctx, tProt, item)\n        tProt.writeListEnd()\n    else:\n        tProt.writeFieldBegin(data)\n        tProt.writeFieldEnd()\n    return None\n```", "```python\nimport thrift.protocol.TProtocol\nfrom thrift.Thrift import TType\n\ndef marshalBasicThriftData(ctx, tProt, data):\n    \"\"\"\n    marshalBasicThriftData only encodes the data (without the prepending method, msgType, seqId)\n    It uses the old thrift way which is much slower than FastCodec and Frugal\n    \"\"\"\n    tProt.writeMessageBegin(None, None, 0)\n    tProt.writeStructBegin('data')\n    for key, value in data.items():\n        tProt.writeFieldBegin(key, TType.STRING, 0)\n        tProt.writeString(key)\n        tProt.writeFieldEnd()\n        tProt.writeFieldBegin(key, TType.STRING, 1)\n        tProt.writeString(str(value))\n        tProt.writeFieldEnd()\n    tProt.writeStructEnd()\n    tProt.writeMessageEnd()\n    return tProt.trans()\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-UnmarshalThriftException": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func UnmarshalThriftException(tProt thrift.TProtocol) error {\n# Natural Language Annotations: // UnmarshalThriftException decode thrift exception from tProt\n// If your input is []byte, you can wrap it with `NewBinaryProtocol(remote.NewReaderBuffer(buf))`\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc UnmarshalThriftException(tProt thrift.TProtocol) (err error) {\n    var thriftException thrift.ThriftException\n    return thrift.NewBinaryProtocol(remote.NewReaderBuffer(tProt)).ReadStruct(&thriftException)\n}\n```", "```go\nfunc UnmarshalThriftException(tProt thrift.TProtocol) (err error) {\n    var exception thrift.TStruct\n    if err = tProt.ReadStruct(&exception); err != nil {\n        return\n    }\n    return\n}\n```", "```python\ndef unmarshal_thrift_exception(t_prot):\n    \"\"\"\n    Unmarshal Thrift exception from the given protocol.\n    \n    Args:\n    t_prot (thrift.TProtocol): The protocol to unmarshal from.\n    \n    Returns:\n    error: The unmarshaled Thrift exception.\n    \"\"\"\n    try:\n        return t_prot.readMessageBegin()\n    except Exception as e:\n        return e\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-UnmarshalThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n# Natural Language Annotations: // UnmarshalThriftData only decodes the data (after methodName, msgType and seqId)\n// It will decode from the given buffer.\n// Note:\n// 1. `method` is only used for generic calls\n// 2. if the buf contains an exception, you should call UnmarshalThriftException instead.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n    // Check if the buffer contains an exception\n    if err := codec.UnmarshalException(buf); err != nil {\n        // If it does, call UnmarshalThriftException to handle it\n        return remote.UnmarshalThriftException(ctx, codec, method, buf)\n    }\n\n    // Otherwise, unmarshal the data from the buffer\n    return codec.UnmarshalData(buf, data)\n}\n```", "```go\nfunc UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n    // Unmarshal Thrift data from the given buffer\n    var thriftData thrift.ThriftData\n    if err := codec.Unmarshal(buf, &thriftData); err != nil {\n        return err\n    }\n    \n    // Unmarshal the Thrift data into the provided data interface\n    switch thriftData.MsgType {\n    case thrift.Exception:\n        return UnmarshalThriftException(ctx, codec, buf, data)\n    default:\n        switch thriftData.MsgType {\n        case thrift.Request:\n            if err := thriftData.Request.Unmarshal(data); err != nil {\n                return err\n            }\n        case thrift.Response:\n            if err := thriftData.Response.Unmarshal(data); err != nil {\n                return err\n            }\n        // Add more message types as needed\n        }\n    }\n    return nil\n}\n```", "```go\nfunc UnmarshalThriftData(ctx context.Context, codec remote.PayloadCodec, method string, buf []byte, data interface{}) error {\n    // Check if the buffer contains an exception\n    if codec.IsException(buf) {\n        return remote.UnmarshalThriftException(ctx, codec, buf)\n    }\n\n    // Decode the data from the buffer\n    err := codec.Unmarshal(buf, data)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-unmarshalThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c thriftCodec) unmarshalThriftData(ctx context.Context, tProt *BinaryProtocol, method string, data interface{}, dataLen int) error {\n# Natural Language Annotations: // unmarshalThriftData only decodes the data (after methodName, msgType and seqId)\n// method is only used for generic calls\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom thrift import TBinaryProtocol\nfrom thrift.protocol import TProtocol\n\ndef unmarshalThriftData(ctx, tProt, method, data, dataLen):\n    # Skip method, msgType and seqId\n    tProt.readI32()  # Skip method\n    tProt.readI32()  # Skip msgType\n    tProt.readI32()  # Skip seqId\n\n    # Unmarshal the rest of the data\n    return tProt.readStruct(data)\n```", "```python\nimport thrift\nfrom thrift.protocol import TBinaryProtocol\nfrom thrift.server import TServer\nfrom thrift.Thrift import TType\n\ndef unmarshalThriftData(ctx context.Context, tProt TBinaryProtocol.TProtocol, method string, data interface{}, dataLen int) error {\n    // Read methodName\n    methodName, _ := tProt.ReadMessageBegin()\n    \n    // Read msgType\n    msgType, _ := tProt.ReadMessageEnd()\n    \n    // Read seqId\n    seqId, _ := tProt.ReadI32()\n    \n    // Skip the methodName, msgType and seqId\n    tProt.Skip(dataLen - 4)\n    \n    // Decode the data\n    data, err := tProt.ReadBinary(dataLen - 4)\n    if err != nil {\n        return err\n    }\n    \n    return nil\n}\n```", "```python\nimport thrift\n\ndef unmarshalThriftData(ctx, tProt, method, data, dataLen):\n    # Skip the first 4 bytes (method, msgType and seqId)\n    method_bytes = data[:4]\n    data = data[4:]\n\n    # Check if the Thrift codec is TCompactProtocol\n    if not isinstance(tProt, thrift.TCompactProtocol):\n        raise ValueError(\"Unsupported Thrift codec\")\n\n    # Unmarshal the data\n    try:\n        thrift_data = tProt.readMessageBegin()\n        thrift_data = tProt.readStructBegin()\n        thrift_data = tProt.readFieldBegin()\n        thrift_data = tProt.readString()\n        thrift_data = tProt.readI32()\n        thrift_data = tProt.readStructEnd()\n        thrift_data = tProt.readMessageEnd()\n    except Exception as e:\n        return e\n\n    return thrift_data\n```"]}, "kitex-pkg/remote/codec/thrift/thrift_data.go-decodeBasicThriftData": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n# Natural Language Annotations: // decodeBasicThriftData decode thrift body the old way (slow)\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport thrift\n\ndef decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n    // decode thrift body the old way (slow)\n    return tProt.ReadMessageBegin()\n    value, err := tProt.ReadStructBegin()\n    if err != nil {\n        return err\n    }\n    for {\n        field, err := tProt.ReadFieldBegin()\n        if err != nil {\n            break\n        }\n        fieldName, _ := tProt.ReadFieldEnd()\n        fieldType, _ := tProt.ReadFieldBegin()\n        fieldValue, err := tProt.ReadFieldEnd()\n        if err != nil {\n            break\n        }\n        // process field value\n        // ...\n        if err := tProt.ReadFieldStop(); err != nil {\n            return err\n        }\n    }\n    return tProt.ReadMessageEnd()\n}\n```", "```go\nfunc decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n    // decode thrift body the old way (slow)\n    var thriftStruct thrift.TStruct\n    err := tProt.ReadStruct(&thriftStruct)\n    if err != nil {\n        return err\n    }\n    // decode each field from the struct\n    for _, field := range thriftStruct.Fields {\n        switch field.Type {\n        case thrift.TType_STRING:\n            str, err := tProt.ReadString()\n            if err != nil {\n                return err\n            }\n            switch field.Name {\n            case \"field1\":\n                // decode field1\n                data.(map[string]interface{})[field.Name] = str\n            case \"field2\":\n                // decode field2\n                data.(map[string]interface{})[field.Name] = str\n            // add more cases for other fields\n            }\n        case thrift.TType_I8:\n            i8, err := tProt.ReadI8()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = i8\n        case thrift.TType_I16:\n            i16, err := tProt.ReadI16()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = i16\n        case thrift.TType_I32:\n            i32, err := tProt.ReadInt32()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = i32\n        case thrift.TType_I64:\n            i64, err := tProt.ReadInt64()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = i64\n        case thrift.TType_DOUBLE:\n            double, err := tProt.ReadDouble()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = double\n        case thrift.TType_BOOL:\n            boolValue, err := tProt.ReadBool()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = boolValue\n        case thrift.TType_BINARY:\n            bin, err := tProt.ReadBinary()\n            if err != nil {\n                return err\n            }\n            data.(map[string]interface{})[field.Name] = bin\n        default:\n            return fmt.Errorf(\"unsupported type: %d\", field.Type)\n        }\n    }\n    return nil\n}\n```", "```python\nimport thrift.protocol as thrift_protocol\nfrom thrift import TTransport, TType\nfrom thrift.Thrift import TException\n\ndef decodeBasicThriftData(ctx context.Context, tProt thrift.TProtocol, method string, data interface{}) error {\n    // decode thrift body the old way (slow)\n    thrift_prot = thrift_protocol.TBinaryProtocolAccelerated.TBinaryProtocolAccelerated(tProt)\n    thrift_data = thrift_prot.read_message_begin()\n    if thrift_data.ttype != TType.STRUCT:\n        return errors.New(\"Invalid data type\")\n    thrift_struct = thrift_data.tvalue\n    // ... rest of the function remains the same ...\n    return nil\n}\n```"]}, "kitex-pkg/remote/remotecli/conn_wrapper.go-GetConn": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (cm *ConnWrapper) GetConn(ctx context.Context, d remote.Dialer, ri rpcinfo.RPCInfo) (net.Conn, error) {\n# Natural Language Annotations: // GetConn returns a connection using the given Dialer and RPCInfo.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass ConnWrapper:\n    def GetConn(self, ctx: context.Context, d: 'remote.Dialer', ri: 'rpcinfo.RPCInfo') -> Optional[tuple]:\n        return d.Dial(ctx, ri)\n```", "```python\nfrom typing import Optional\n\nclass ConnWrapper:\n    def GetConn(self, ctx, d, ri) -> Optional[tuple]:\n        # GetConn returns a connection using the given Dialer and RPCInfo.\n        return d.Dial(ctx, ri)\n```", "```python\nfrom typing import Callable, Dict, Optional\n\nclass ConnWrapper:\n    def GetConn(self, ctx: Dict, d: Callable, ri: Dict) -> (Optional[Dict], Optional[Dict]):\n        # GetConn returns a connection using the given Dialer and RPCInfo.\n        return d(ctx, ri)\n```"]}, "kitex-pkg/remote/connpool/long_pool.go-Evict": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *pool) Evict() (evicted int) {\n# Natural Language Annotations: // Evict cleanups the expired connections.\n// Evict returns how many connections has been evicted.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom collections import deque\n\nclass Pool:\n    def __init__(self):\n        self.connections = deque()\n        self.max_size = 100\n\n    def Evict(self):\n        \"\"\"\n        Evict cleanups the expired connections.\n        Evict returns how many connections has been evicted.\n        \"\"\"\n        expired_connections = 0\n        while len(self.connections) > 0 and self.connections[0].timestamp < time.time() - 60:  # assuming connections have a 'timestamp' attribute\n            self.connections.popleft()\n            expired_connections += 1\n        return expired_connections\n```", "```python\nclass Pool:\n    def __init__(self):\n        # Initialize pool with connections and their expiration times\n        self.connections = {}\n        self.expiration_times = {}\n\n    def add_connection(self, conn, expiration_time):\n        self.connections[conn] = expiration_time\n        self.expiration_times[conn] = expiration_time\n\n    def evict(self):\n        # Get the current time\n        import time\n        current_time = time.time()\n        \n        # Find expired connections\n        expired_connections = {conn: expiration_time for conn, expiration_time in self.expiration_times.items() if current_time > expiration_time}\n        \n        # Evict expired connections\n        for conn in expired_connections:\n            del self.connections[conn]\n            del self.expiration_times[conn]\n        \n        # Return the number of evicted connections\n        return len(expired_connections)\n```", "```python\nclass Pool:\n    def __init__(self):\n        self.connections = []\n        self.expiration_time = 60  # expiration time in seconds\n\n    def add(self, conn):\n        self.connections.append(conn)\n\n    def check_expiration(self):\n        current_time = time.time()\n        expired_connections = [conn for conn in self.connections if current_time - conn['created_at'] > self.expiration_time]\n        return expired_connections\n\n    def evict(self):\n        expired_connections = self.check_expiration()\n        evicted_count = len(expired_connections)\n        self.connections = [conn for conn in self.connections if conn not in expired_connections]\n        return evicted_count\n```"]}, "kitex-pkg/loadbalance/lbcache/cache.go-NewBalancerFactory": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n# Natural Language Annotations: // NewBalancerFactory get or create a balancer factory for balancer instance\n// cache key with resolver name, balancer name and options\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n    key := fmt.Sprintf(\"%s_%s_%v\", resolver.Name(), balancer.Name(), opts)\n    if cf, ok := balancerFactories.Load(key); ok {\n        return cf.(*BalancerFactory)\n    }\n    cf := &BalancerFactory{\n        resolver: resolver,\n        balancer: balancer,\n        opts:     opts,\n    }\n    balancerFactories.Store(key, cf)\n    return cf\n}\n```", "```go\ntype balancerFactory struct {\n    resolverDiscovery  discovery.Resolver\n    balancerInstance  loadbalance.Loadbalancer\n    opts              Options\n    cache             map[string]*BalancerFactory\n}\n\nfunc NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts Options) *BalancerFactory {\n    cacheKey := fmt.Sprintf(\"%s_%s_%v\", resolver.Name(), balancer.Name(), opts)\n    if factory, ok := balancerFactory.cache[cacheKey]; ok {\n        return factory\n    }\n    factory := &balancerFactory{\n        resolverDiscovery:  resolver,\n        balancerInstance:  balancer,\n        opts:              opts,\n        cache:             map[string]*BalancerFactory{},\n    }\n    balancerFactory.cache[cacheKey] = factory\n    return factory\n}\n```", "```go\nimport (\n\t\"context\"\n\t\"sync\"\n\n\t\"discovery\"\n\t\"loadbalance\"\n\t\"options\"\n)\n\ntype BalancerFactory struct {\n\tresolverName string\n\tbalancerName string\n\topts         options.Options\n\tcache        sync.Map\n}\n\nfunc (bf *BalancerFactory) GetBalancer() (*loadbalance.Loadbalancer, error) {\n\tkey := bf.cacheKey()\n\tval, ok := bf.cache.Load(key)\n\tif ok {\n\t\treturn val.(*loadbalance.Loadbalancer), nil\n\t}\n\tbalancer, err := bf.newBalancer()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tbf.cache.Store(key, balancer)\n\treturn balancer, nil\n}\n\nfunc (bf *BalancerFactory) cacheKey() string {\n\treturn bf.resolverName + \":\" + bf.balancerName + \":\" + string(bf.opts)\n}\n\nfunc NewBalancerFactory(resolver discovery.Resolver, balancer loadbalance.Loadbalancer, opts options.Options) *BalancerFactory {\n\treturn &BalancerFactory{\n\t\tresolverName: resolver.Name(),\n\t\tbalancerName: balancer.Name(),\n\t\topts:         opts,\n\t}\n}\n```"]}, "kitex-pkg/stats/event.go-DefineNewEvent": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefineNewEvent(name string, level Level) (Event, error) {\n# Natural Language Annotations: // DefineNewEvent allows user to add event definitions during program initialization.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom enum import Enum\n\nclass Level(Enum):\n    DEBUG = 1\n    INFO = 2\n    WARNING = 3\n    ERROR = 4\n    CRITICAL = 5\n\nclass Event:\n    def __init__(self, name: str, level: Level):\n        self.name = name\n        self.level = level\n\ndef DefineNewEvent(name: str, level: Level) -> (Event, None):\n    \"\"\"\n    DefineNewEvent allows user to add event definitions during program initialization.\n    \n    Args:\n        name (str): The name of the event.\n        level (Level): The level of the event.\n    \n    Returns:\n        Event: The newly defined event.\n        None: If an error occurs.\n    \"\"\"\n    try:\n        return Event(name, level)\n    except Exception as e:\n        return None, e\n```", "```python\nfrom enum import Enum\n\nclass Level(Enum):\n    DEBUG = 1\n    INFO = 2\n    WARNING = 3\n    ERROR = 4\n\nclass Event:\n    def __init__(self, name, level):\n        self.name = name\n        self.level = level\n\ndef DefineNewEvent(name: str, level: Level) -> (Event, None):\n    \"\"\"\n    DefineNewEvent allows user to add event definitions during program initialization.\n    \n    Args:\n        name (str): The name of the event.\n        level (Level): The level of the event.\n\n    Returns:\n        Event: The defined event.\n    \"\"\"\n    return Event(name, level)\n```", "```python\nfrom enum import Enum\n\nclass Level(Enum):\n    DEBUG = 1\n    INFO = 2\n    WARNING = 3\n    ERROR = 4\n\nclass Event:\n    def __init__(self, name, level):\n        self.name = name\n        self.level = level\n\ndef DefineNewEvent(name: str, level: Level) -> (Event, str):\n    \"\"\"\n    DefineNewEvent allows user to add event definitions during program initialization.\n    \n    Args:\n        name (str): The name of the event.\n        level (Level): The level of the event.\n        \n    Returns:\n        Event: The newly defined event.\n        str: An empty string if the event is defined successfully, otherwise an error message.\n    \"\"\"\n    try:\n        return Event(name, level), \"\"\n    except Exception as e:\n        return None, f\"Error defining event: {str(e)}\"\n```"]}, "kitex-pkg/generic/thriftidl_provider.go-NewThriftFileProviderWithDynamicGo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n# Natural Language Annotations: // NewThriftFileProviderWithDynamicGo create a ThriftIDLProvider with dynamicgo by given path and include dirs\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n    thriftFileProvider := &ThriftFileProviderWithDynamicGo{\n        path: path,\n        includeDirs: includeDirs,\n    }\n    return thriftFileProvider, nil\n}\n\ntype ThriftFileProviderWithDynamicGo struct {\n    path string\n    includeDirs []string\n}\n\nfunc (t *ThriftFileProviderWithDynamicGo) GetDescriptor() ([]*thrift.ThriftDescriptor, error) {\n    // implementation of GetDescriptor method\n    return nil, nil\n}\n\nfunc (t *ThriftFileProviderWithDynamicGo) GetIncludes() ([]*thrift.ThriftInclude, error) {\n    // implementation of GetIncludes method\n    return nil, nil\n}\n\nfunc (t *ThriftFileProviderWithDynamicGo) GetNamespaces() ([]*thrift.ThriftNamespace, error) {\n    // implementation of GetNamespaces method\n    return nil, nil\n}\n\nfunc (t *ThriftFileProviderWithDynamicGo) GetServices() ([]*thrift.ThriftService, error) {\n    // implementation of GetServices method\n    return nil, nil\n}\n```", "```go\npackage thrift\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/apache/thrift/compiler/go/dynamicgo\"\n\t\"github.com/apache/thrift/compiler/generate\"\n)\n\nfunc NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n\t// Create a new dynamicgo provider\n\tprovider, err := dynamicgo.NewProvider(path, includeDirs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new Thrift file provider\n\tprovider = &thriftFileProvider{\n\t\tprovider: provider,\n\t}\n\n\t// Check if the file exists\n\tif _, err := os.Stat(path); os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"file not found: %s\", path)\n\t}\n\n\t// Generate Thrift files\n\tif err := provider.Generate(); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn provider, nil\n}\n\n```", "```go\npackage thrift\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/dynamicgo/thrift\"\n)\n\nfunc NewThriftFileProviderWithDynamicGo(path string, includeDirs ...string) (DescriptorProvider, error) {\n\t// Create a new ThriftIDLProvider instance\n\tprovider, err := thrift.NewThriftIDLProvider(path, includeDirs)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new dynamicgo provider\n\tdynamicProvider := &dynamicgo.Provider{}\n\n\t// Set the ThriftIDLProvider to the dynamicgo provider\n\tdynamicProvider.SetThriftIDLProvider(provider)\n\n\t// Return the dynamicgo provider and nil error\n\treturn dynamicProvider, nil\n}\n```"]}, "kitex-pkg/generic/thriftidl_provider.go-NewThriftContentWithAbsIncludePathProviderWithDynamicGo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n# Natural Language Annotations: // NewThriftContentWithAbsIncludePathProviderWithDynamicGo create abs include path DescriptorProvider with dynamicgo\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage thrift\n\nimport (\n\t\"fmt\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n)\n\ntype ThriftContentWithAbsIncludePathProvider struct {\n\tmainIDLPath string\n\tincludes    map[string]string\n}\n\nfunc NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n\tif mainIDLPath == \"\" {\n\t\treturn nil, fmt.Errorf(\"mainIDLPath is required\")\n\t}\n\n\tabsIncludes := make(map[string]string)\n\tfor key, value := range includes {\n\t\tabsValue, err := filepath.Abs(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tabsIncludes[key] = absValue\n\t}\n\n\treturn &ThriftContentWithAbsIncludePathProvider{\n\t\tmainIDLPath: mainIDLPath,\n\t\tincludes:    absIncludes,\n\t}, nil\n}\n```", "```go\npackage thrift\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/apache/thrift/compiler/thrift\"\n)\n\ntype ThriftContentWithAbsIncludePathProvider struct {\n\tincludes map[string]string\n}\n\nfunc NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*ThriftContentWithAbsIncludePathProvider, error) {\n\t// Read the main IDL file\n\tmainIDLData, err := ioutil.ReadFile(mainIDLPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the absolute path of the main IDL file\n\tmainIDLAbsPath, err := filepath.Abs(mainIDLPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a map to store the absolute paths of the includes\n\tabsIncludes := make(map[string]string)\n\n\t// Iterate over the includes\n\tfor key, value := range includes {\n\t\t// Get the absolute path of the include file\n\t\tabsIncludePath, err := filepath.Abs(value)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Add the absolute path to the map\n\t\tabsIncludes[key] = absIncludePath\n\t}\n\n\t// Create a new ThriftContentWithAbsIncludePathProvider\n\treturn &ThriftContentWithAbsIncludePathProvider{\n\t\tincludes: absIncludes,\n\t}, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\t\"strings\"\n\n\t\"github.com/apache/thrift/compiler/go/gen\"\n)\n\nfunc NewThriftContentWithAbsIncludePathProviderWithDynamicGo(mainIDLPath string, includes map[string]string) (*gen.AbsIncludePathDescriptorProvider, error) {\n\t// Read the contents of the main IDL file\n\tmainIDLBytes, err := ioutil.ReadFile(mainIDLPath)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new Thrift parser\n\tparser := gen.NewParser()\n\n\t// Parse the main IDL file\n\tif err := parser.Parse(mainIDLPath, mainIDLBytes); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new AbsIncludePathDescriptorProvider\n\tprovider := &gen.AbsIncludePathDescriptorProvider{\n\t\tIncludes: includes,\n\t}\n\n\t// Set the include path for the provider\n\tprovider.IncludePath = filepath.Dir(mainIDLPath)\n\n\t// Create a new Thrift content with the provider\n\tcontent := &gen.ThriftContent{\n\t\tProvider: provider,\n\t}\n\n\t// Generate the Thrift content\n\tif err := content.Generate(parser); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn provider, nil\n}\n```"]}, "kitex-pkg/generic/generic.go-MapThriftGeneric": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MapThriftGeneric(p DescriptorProvider) (Generic, error) {\n# Natural Language Annotations: // MapThriftGeneric map mapping generic\n// Base64 codec for binary field is disabled by default. You can change this option with SetBinaryWithBase64.\n// eg:\n//\n//\tg, err := generic.MapThriftGeneric(p)\n//\tSetBinaryWithBase64(g, true)\n//\n// String value is returned for binary field by default. You can change the return value to []byte for binary field with SetBinaryWithByteSlice.\n// eg:\n//\n//\tSetBinaryWithByteSlice(g, true)\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/apache/thrift/lib/go/thrift/protocol\"\n)\n\ntype Generic struct {\n\t// Add fields as needed\n}\n\nfunc (g *Generic) SetBinaryWithBase64(value bool) {\n\t// Implement logic to set base64 codec for binary field\n}\n\nfunc (g *Generic) SetBinaryWithByteSlice(value bool) {\n\t// Implement logic to set return value to []byte for binary field\n}\n\nfunc MapThriftGeneric(p DescriptorProvider) (Generic, error) {\n\tg := &Generic{}\n\ttransport, err := thrift.NewTSocket(p.GetAddress())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprotocolFactory := thrift.NewTBinaryProtocolFactoryDefault()\n\tclient := thrift.NewTCompactProtocolFactory()\n\tclientTransport := thrift.NewTSocketTransport(transport)\n\tclientProtocol := protocolFactory.GetProtocol(clientTransport)\n\tclientTransport.Open()\n\tdefer clientTransport.Close()\n\tclient = thrift.NewTCompactClient(clientProtocol)\n\tdefer client.Close()\n\t// Call the thrift service\n\t// Assuming the service method returns a Generic object\n\tresult, err := client.MapThriftGeneric(context.Background())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tg = result\n\treturn g, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/apache/thrift/lib/go/thrift/protocol/TBinaryProtocol\"\n\t\"github.com/apache/thrift/lib/go/thrift/transport/TBufferedTransport\"\n)\n\ntype Generic struct{}\n\nfunc (g *Generic) MapThriftGeneric(p DescriptorProvider) (*Generic, error) {\n\ttransportFactory := thrift.NewTBufferedTransportFactory()\n\tprotocolFactory := thrift.NewTBinaryProtocolFactoryWithNegotiation(true)\n\ttransport, err := transportFactory.GetTransport(context.Background())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprotocol := protocolFactory.GetProtocol(transport)\n\tclient := NewDescriptorProviderClient(protocol)\n\tdefer transport.Close()\n\n\tvar descriptorDescriptor DescriptorDescriptor\n\terr = client.GetDescriptor(context.Background(), &descriptorDescriptor)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn g, nil\n}\n\nfunc main() {\n\tp := NewDescriptorProvider()\n\tg, err := MapThriftGeneric(p)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(g)\n}\n```", "```go\npackage generic\n\nimport (\n\t\"context\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"thrift\"\n)\n\n// MapThriftGeneric maps the thrift descriptor to a generic object\nfunc MapThriftGeneric(p DescriptorProvider) (Generic, error) {\n\t// TODO: implement logic to map thrift descriptor to generic object\n\t// For now, just return a generic object with an error\n\treturn Generic{}, status.Error(codes.Unimplemented, \"MapThriftGeneric is not implemented\")\n}\n\n// SetBinaryWithBase64 enables base64 codec for binary field\nfunc SetBinaryWithBase64(g Generic, enable bool) {\n\t// TODO: implement logic to enable base64 codec for binary field\n\t// For now, do nothing\n}\n\n// SetBinaryWithByteSlice enables byte slice return value for binary field\nfunc SetBinaryWithByteSlice(g Generic, enable bool) {\n\t// TODO: implement logic to enable byte slice return value for binary field\n\t// For now, do nothing\n}\n```"]}, "kitex-pkg/generic/generic.go-JSONThriftGeneric": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n# Natural Language Annotations: // JSONThriftGeneric json mapping generic.\n// Base64 codec for binary field is enabled by default. You can change this option with SetBinaryWithBase64.\n// eg:\n//\n//\tg, err := generic.JSONThriftGeneric(p)\n//\tSetBinaryWithBase64(g, false)\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n    // Set default options\n    var options = []Option{\n        SetBinaryWithBase64(true),\n    }\n\n    // Merge user provided options\n    for _, opt := range opts {\n        options = append(options, opt)\n    }\n\n    // Create a new generic instance\n    g, err := NewGeneric(p, options...)\n    if err != nil {\n        return nil, err\n    }\n\n    return g, nil\n}\n```", "```go\npackage thrift\n\nimport (\n\t\"github.com/apache/thrift/lib/go/thrift\"\n\t\"github.com/apache/thrift/lib/go/thrift/protocol\"\n\t\"github.com/apache/thrift/lib/go/thrift/transport\"\n\t\"github.com/thrift/protobuf\"\n)\n\n// JSONThriftGeneric returns a generic JSON Thrift codec.\nfunc JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n\t// Create a new JSON codec\n\tjsonCodec := protocol.NewTJSONProtocolFactory(p)\n\n\t// Create a new transport\n\ttransport := transport.NewTBufferedTransportFactory()\n\n\t// Create a new generic codec\n\tg := thrift.NewGenericCodec(jsonCodec, transport)\n\n\t// Apply options\n\tfor _, opt := range opts {\n\t\topt(g)\n\t}\n\n\treturn g, nil\n}\n\n// SetBinaryWithBase64 sets whether to use base64 for binary fields.\nfunc SetBinaryWithBase64(g Generic, enable bool) {\n\tg.SetBinaryWithBase64(enable)\n}\n```", "```go\npackage thrift\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"github.com/apache/thrift/lib/thrift/protocol\"\n\t\"github.com/apache/thrift/lib/thrift/transport\"\n\t\"github.com/apache/thrift/lib/thrift/processor\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"github.com/gorilla/mux\"\n\t\"github.com/thrift/kit/thrift-go/thrift/json\"\n)\n\n// JSONThriftGeneric is a generic JSON Thrift handler.\nfunc JSONThriftGeneric(p DescriptorProvider, opts ...Option) (Generic, error) {\n\tg := &Generic{\n\t\tprocessor: processor.NewTJSONProcessor(p),\n\t\ttransport: transport.NewBufferedTransport(),\n\t}\n\n\tfor _, opt := range opts {\n\t\topt(g)\n\t}\n\n\treturn g, nil\n}\n\n// SetBinaryWithBase64 sets whether to use base64 encoding for binary fields.\nfunc SetBinaryWithBase64(g *Generic, v bool) {\n\tg.codec = &json.TJSONCodec{\n\t\tEncodeBinaryWithBase64: v,\n\t}\n}\n\n// Generic is a generic JSON Thrift handler.\ntype Generic struct {\n\tprocessor *processor.TJSONProcessor\n\ttransport transport.TTransport\n\tcodec    *json.TJSONCodec\n}\n\n// ServeHTTP is the HTTP handler for the generic JSON Thrift handler.\nfunc (g *Generic) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tvar ctx context.Context\n\tvar cancel context.CancelFunc\n\n\tswitch r.Method {\n\tcase http.MethodGet:\n\t\tctx, cancel = context.WithCancel(context.Background())\n\t\tdefer cancel()\n\n\t\treq := &processor.TJSONRequest{}\n\t\tif err := json.Decode(r.Body, req); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tresp := g.processor.Process(ctx, req)\n\t\tif err := json.Encode(w, resp); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\tcase http.MethodPost:\n\t\tctx, cancel = context.WithCancel(context.Background())\n\t\tdefer cancel()\n\n\t\treq := &processor.TJSONRequest{}\n\t\tif err := json.Decode(r.Body, req); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\tresp := g.processor.Process(ctx, req)\n\t\tif err := json.Encode(w, resp); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\n\tdefault:\n\t\thttp.Error(w, \"method not supported\", http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n}\n\n// Option is an option for the generic JSON Thrift handler.\ntype Option func(*Generic)\n\n// RegisterRoutes registers routes for the generic JSON Thrift handler.\nfunc RegisterRoutes(router *mux.Router, prefix string) {\n\tg := &Generic{}\n\tg.router = router.PathPrefix(prefix).Subrouter()\n\tg.router.HandleFunc(\"/thrift\", g.ServeHTTP).Methods(http.MethodGet, http.MethodPost)\n}\n\n// ServeHTTP is the HTTP handler for the generic JSON Thrift handler.\nfunc (g *Generic) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\tg.ServeHTTP(w, r)\n}\n```"]}, "kitex-pkg/generic/generic.go-JSONPbGeneric": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n# Natural Language Annotations: // JSONPbGeneric json mapping generic.\n// Uses dynamicgo for json to protobufs conversion, so DynamicGo field is true by default.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n    // Create a new generic instance\n    generic := NewGeneric()\n\n    // Convert JSON to protobuf using DynamicGo\n    if err := p.ToProtobuf(generic, true); err != nil {\n        return nil, err\n    }\n\n    // Apply any additional options\n    for _, opt := range opts {\n        opt(generic)\n    }\n\n    return generic, nil\n}\n```", "```go\nfunc JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n    // Create a new instance of the generic type\n    generic := NewGeneric()\n\n    // Set DynamicGo to true by default\n    generic.DynamicGo = true\n\n    // Apply any additional options\n    for _, opt := range opts {\n        opt(generic)\n    }\n\n    // Convert JSON to protobuf using DynamicGo\n    err := p.ConvertToPb(generic)\n    if err != nil {\n        return nil, err\n    }\n\n    return generic, nil\n}\n```", "```go\nfunc JSONPbGeneric(p PbDescriptorProviderDynamicGo, opts ...Option) (Generic, error) {\n    // Create a new Generic object from the PbDescriptorProviderDynamicGo\n    generic := &Generic{\n        DynamicGo: true,\n    }\n    \n    // Set up the dynamicgo field\n    if p.DynamicGo != nil {\n        generic.DynamicGo = *p.DynamicGo\n    }\n    \n    // Call the configure method to set up the Generic object\n    if err := generic.Configure(p); err != nil {\n        return nil, err\n    }\n    \n    // Call the init method to initialize the Generic object\n    if err := generic.Init(opts...); err != nil {\n        return nil, err\n    }\n    \n    return generic, nil\n}\n```"]}, "kitex-pkg/generic/thrift/write.go-writeStruct": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n# Natural Language Annotations: // writeStruct iter with Descriptor, can check the field's required and others\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n    // Get the fields of the struct\n    fields := t.Fields\n    \n    // Check if the struct has any fields\n    if len(fields) == 0 {\n        return errors.New(\"struct has no fields\")\n    }\n    \n    // Write the struct header\n    out.WriteMessageBegin(thrift.STRUCT, t.Name, 0)\n    \n    // Iterate over the fields\n    for _, field := range fields {\n        // Check if the field is required\n        if field.Required && field.Tag == thrift.OPTIONAL {\n            return errors.New(\"required field is optional\")\n        }\n        \n        // Get the field value\n        value := reflect.ValueOf(val).FieldByName(field.Name)\n        \n        // Check if the field exists\n        if !value.IsValid() {\n            return errors.New(\"field does not exist\")\n        }\n        \n        // Write the field\n        err := writeField(ctx, out, value, field)\n        if err != nil {\n            return err\n        }\n    }\n    \n    // Write the struct footer\n    out.WriteMessageEnd()\n    \n    return nil\n}\n```", "```go\nfunc writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n    // Check if the value is nil, if so return nil\n    if val == nil {\n        return nil\n    }\n\n    // Get the type descriptor's fields\n    fields := t.GetFields()\n\n    // Check if the value implements the thrift.TStruct interface\n    if val, ok := val.(thrift.TStruct); ok {\n        // Iterate over the type descriptor's fields\n        for _, field := range fields {\n            // Check if the field is required\n            if field.Required == true {\n                // If the field is required, check if the value has the field\n                if _, ok := val.(map[string]interface{})[field.Name]; !ok {\n                    return errors.New(\"required field \" + field.Name + \" is missing\")\n                }\n            }\n\n            // Check if the field is optional and has a default value\n            if field.Required == false && field.Default != nil {\n                // If the field is optional and has a default value, check if the value has the field\n                if _, ok := val.(map[string]interface{})[field.Name]; !ok {\n                    // If the field is not present, use the default value\n                    val.(map[string]interface{})[field.Name] = field.Default\n                }\n            }\n        }\n    }\n\n    // Write the struct to the output protocol\n    return out.WriteStruct(val)\n}\n```", "```go\nfunc writeStruct(ctx context.Context, val interface{}, out thrift.TProtocol, t *descriptor.TypeDescriptor, opt *writerOption) error {\n    // Check if the value is nil\n    if val == nil {\n        return thrift.NewTProtocolException(\"value is nil\")\n    }\n\n    // Get the type of the value\n    vtype := reflect.TypeOf(val)\n\n    // Check if the type of the value matches the type described by the descriptor\n    if vtype != t.GetType() {\n        return thrift.NewTProtocolException(\"type mismatch\")\n    }\n\n    // Check if the struct has required fields\n    for _, field := range t.GetFields() {\n        if field.GetTag().Required {\n            // Check if the field is present in the value\n            if !vtype.FieldByName(field.GetName()).IsExported() {\n                return thrift.NewTProtocolException(\"required field missing\")\n            }\n        }\n    }\n\n    // Write the struct to the protocol\n    return out.WriteStruct(val, t, opt)\n}\n```"]}, "kitex-pkg/generic/descriptor/tree.go-addRoute": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n *node) addRoute(path string, function *FunctionDescriptor) {\n# Natural Language Annotations: // addRoute adds a node with the given function to the path.\n// Not concurrency-safe!\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Node:\n    def __init__(self, path, func):\n        self.path = path\n        self.func = func\n        self.children = {}\n\nclass FunctionDescriptor:\n    def __init__(self, func):\n        self.func = func\n\nclass Router:\n    def __init__(self):\n        self.root = Node(\"\", None)\n\n    def addRoute(self, path, func):\n        current = self.root\n        for segment in path.split(\"/\"):\n            if segment != \"\":\n                if segment not in current.children:\n                    current.children[segment] = Node(segment, None)\n                current = current.children[segment]\n        current.func = func\n\n# Example usage:\ndef my_function():\n    print(\"Hello, world!\")\n\nrouter = Router()\nrouter.addRoute(\"/hello/world\", FunctionDescriptor(my_function))\n```", "```python\nclass Node:\n    def __init__(self, path, func):\n        self.path = path\n        self.func = func\n        self.children = {}\n\nclass FunctionDescriptor:\n    def __init__(self, func):\n        self.func = func\n\ndef add_route(n, path, function):\n    \"\"\"\n    Adds a node with the given function to the path.\n\n    :param n: The current node\n    :type n: Node\n    :param path: The path to add the node to\n    :type path: str\n    :param function: The function to add to the path\n    :type function: FunctionDescriptor\n    :return: None\n    \"\"\"\n    paths = path.split('/')\n    current = n\n    for p in paths:\n        if p not in current.children:\n            current.children[p] = Node(p, None)\n        current = current.children[p]\n    current.func = function.func\n```", "```python\nclass Node:\n    def __init__(self, path, func):\n        self.path = path\n        self.func = func\n        self.next = None\n\nclass FunctionDescriptor:\n    def __init__(self, func):\n        self.func = func\n\nclass Router:\n    def __init__(self):\n        self.head = None\n\n    def addRoute(self, path, func):\n        new_node = Node(path, FunctionDescriptor(func))\n        if self.head is None:\n            self.head = new_node\n        else:\n            current = self.head\n            while current.next:\n                current = current.next\n            current.next = new_node\n\ndef create_function_descriptor(func):\n    return FunctionDescriptor(func)\n\n# Example usage:\ndef hello_world():\n    print(\"Hello, World!\")\n\nrouter = Router()\nrouter.addRoute(\"/hello\", create_function_descriptor(hello_world))\n```"]}, "kitex-pkg/mem/span.go-NewSpanCache": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewSpanCache(spanSize int) *spanCache {\n# Natural Language Annotations: // NewSpanCache returns a spanCache with the given spanSize,\n// each span is used to allocate a binary of a specific size level.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\ntype SpanCache struct {\n    spans []int\n    size  int\n}\n\ntype Span struct {\n    id   int\n    size int\n}\n\nfunc NewSpanCache(spanSize int) *SpanCache {\n    return &SpanCache{\n        size:  spanSize,\n        spans: make([]int, 0, spanSize),\n    }\n}\n\nfunc (s *SpanCache) GetSpan() *Span {\n    for i, span := range s.spans {\n        if span == 0 {\n            s.spans[i] = s.size\n            return &Span{id: i, size: s.size}\n        }\n    }\n    s.spans = append(s.spans, s.size)\n    return &Span{id: len(s.spans) - 1, size: s.size}\n}\n\nfunc (s *SpanCache) ReleaseSpan(id int) {\n    if id < len(s.spans) {\n        s.spans[id] = 0\n    }\n}\n```", "```go\ntype SpanCache struct {\n    spans map[int][]byte\n}\n\nfunc NewSpanCache(spanSize int) *SpanCache {\n    return &SpanCache{\n        spans: make(map[int][]byte),\n    }\n}\n```", "```go\ntype SpanCache struct {\n    cache map[int][]byte\n    spanSize int\n}\n\nfunc NewSpanCache(spanSize int) *SpanCache {\n    return &SpanCache{\n        cache: make(map[int][]byte),\n        spanSize: spanSize,\n    }\n}\n```"]}, "kitex-pkg/profiler/profiler.go-Pause": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *profiler) Pause() {\n# Natural Language Annotations: // Pause the profiler.\n// The profiler has been paused when Pause() return\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Profiler:\n    def __init__(self):\n        self.paused = False\n\n    def pause(self):\n        \"\"\"Pause the profiler.\"\"\"\n        self.paused = True\n```", "```python\nclass Profiler:\n    def __init__(self):\n        self.paused = False\n\n    def pause(self):\n        \"\"\"\n        Pause the profiler.\n        The profiler has been paused when pause() return\n        \"\"\"\n        self.paused = True\n```", "```python\nclass Profiler:\n    def __init__(self):\n        self.paused = False\n\n    def pause(self):\n        \"\"\"\n        Pause the profiler.\n        The profiler has been paused when Pause() return\n        \"\"\"\n        self.paused = True\n```"]}, "kitex-pkg/profiler/profiler.go-Resume": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *profiler) Resume() {\n# Natural Language Annotations: // Resume the profiler.\n// The profiler has been resumed when Resume() return\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Profiler:\n    def __init__(self):\n        self.paused = True\n\n    def resume(self):\n        \"\"\"\n        Resume the profiler.\n        The profiler has been resumed when resume() return\n        \"\"\"\n        self.paused = False\n```", "```python\nclass Profiler:\n    def __init__(self):\n        self.paused = True\n\n    def pause(self):\n        self.paused = True\n\n    def resume(self):\n        \"\"\"\n        Resume the profiler.\n        The profiler has been resumed when Resume() return\n        \"\"\"\n        self.paused = False\n        return self.paused\n```", "```python\ndef resume(self):\n    \"\"\"\n    Resume the profiler.\n    \n    The profiler has been resumed when Resume() return\n    \"\"\"\n    # Implement the logic to resume the profiler here\n    # For example:\n    self.resumed = True\n```"]}, "kitex-pkg/acl/acl.go-NewACLMiddleware": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewACLMiddleware(rules []RejectFunc) endpoint.Middleware {\n# Natural Language Annotations: // NewACLMiddleware creates a new ACL middleware using the provided reject funcs.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewACLMiddleware(rules []endpoint.RejectFunc) endpoint.Middleware {\n    return func(next endpoint.Endpoint) endpoint.Endpoint {\n        return func(ctx context.Context, req interface{}) (interface{}, error) {\n            for _, rule := range rules {\n                if !rule(ctx, req) {\n                    return nil, errors.New(\"access denied\")\n                }\n            }\n            return next(ctx, req)\n        }\n    }\n}\n```", "```go\nfunc NewACLMiddleware(rules []endpoint.RejectFunc) endpoint.Middleware {\n    return func(next endpoint.HandlerFunc) endpoint.HandlerFunc {\n        return func(ctx context.Context, req *endpoint.Request) (*endpoint.Response, error) {\n            for _, rule := range rules {\n                if rule(ctx, req) {\n                    return nil, errors.New(\"access denied\")\n                }\n            }\n            return next(ctx, req)\n        }\n    }\n}\n```", "```go\nfunc NewACLMiddleware(rules []endpoint.RejectFunc) endpoint.Middleware {\n    return func(next endpoint.HandlerFunc) endpoint.HandlerFunc {\n        return func(ctx context.Context, req interface{}) (interface{}, error) {\n            for _, rule := range rules {\n                if err := rule(ctx, req); err != nil {\n                    return nil, err\n                }\n            }\n            return next(ctx, req)\n        }\n    }\n}\n```"]}, "kitex-client/context_middleware.go-WithContextMiddlewares": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n# Natural Language Annotations: // WithContextMiddlewares add middlewares into current ctx\n// Every client receive this ctx will execute the middlewares.\n// Note that ContextMiddleware is prior to the ClientMiddleware.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n    for i := len(mws) - 1; i >= 0; i-- {\n        ctx = mws[i](ctx)\n    }\n    return ctx\n}\n```", "```python\nfrom functools import wraps\nfrom typing import Any, Callable\n\ndef with_context_middlewares(ctx: Any, mws: Any) -> Any:\n    def decorator(func: Callable) -> Callable:\n        @wraps(func)\n        def wrapper(*args: Any, **kwargs: Any) -> Any:\n            for mw in mws:\n                ctx = mw(ctx)\n            return func(ctx, *args, **kwargs)\n        return wrapper\n    return decorator\n```", "```go\nfunc WithContextMiddlewares(ctx context.Context, mws ...endpoint.Middleware) context.Context {\n    for _, mw := range mws {\n        if mw != nil {\n            ctx = mw(ctx)\n        }\n    }\n    return ctx\n}\n```"]}, "kitex-client/stream.go-RecvMsg": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) RecvMsg(m interface{}) (err error) {\n# Natural Language Annotations: // RecvMsg receives a message from the server.\n// If an error is returned, stream.DoFinish() will be called to record the end of stream\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (s *stream) RecvMsg(m interface{}) (err error) {\n    // RecvMsg receives a message from the server.\n    // If an error is returned, stream.DoFinish() will be called to record the end of stream\n    if err := s.conn.ReadMsg(m); err != nil {\n        s.DoFinish()\n        return err\n    }\n    return nil\n}\n```", "```go\nfunc (s *stream) RecvMsg(m interface{}) (err error) {\n    // RecvMsg receives a message from the server.\n    // If an error is returned, stream.DoFinish() will be called to record the end of stream\n    // Assuming s.conn is the underlying connection to the server\n    err = s.conn.Read(m)\n    if err != nil {\n        s.DoFinish()\n        return err\n    }\n    return nil\n}\n```", "```go\nfunc (s *stream) RecvMsg(m interface{}) (err error) {\n    if err := s.conn.SetDeadline(time.Now().Add(5 * time.Second)); err != nil {\n        return err\n    }\n    if err := s.conn.SetReadDeadline(time.Now().Add(5 * time.Second)); err != nil {\n        s.DoFinish()\n        return err\n    }\n    if err := json.Unmarshal(s.conn.ReadMsg(), m); err != nil {\n        s.DoFinish()\n        return err\n    }\n    return nil\n}\n```"]}, "kitex-client/stream.go-SendMsg": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) SendMsg(m interface{}) (err error) {\n# Natural Language Annotations: // SendMsg sends a message to the server.\n// If an error is returned, stream.DoFinish() will be called to record the end of stream\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (s *stream) SendMsg(m interface{}) (err error) {\n    // Send the message to the server\n    err = s.send(m)\n    \n    // If an error is returned, call DoFinish to record the end of stream\n    if err != nil {\n        s.DoFinish()\n    }\n    \n    return\n}\n```", "```go\nfunc (s *Stream) SendMsg(m interface{}) (err error) {\n    // Send the message to the server\n    err = s.server.Send(m)\n    if err != nil {\n        // If an error occurs, record the end of stream\n        s.DoFinish()\n    }\n    return\n}\n```", "```go\nfunc (s *stream) SendMsg(m interface{}) (err error) {\n    // Send message to the server\n    err = s.writeMessage(m)\n    \n    // If an error is returned, call DoFinish to record the end of stream\n    if err != nil {\n        s.DoFinish()\n    }\n    \n    return\n}\n```"]}, "kitex-client/stream.go-DoFinish": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *stream) DoFinish(err error) {\n# Natural Language Annotations: // DoFinish implements the streaming.WithDoFinish interface, and it records the end of stream\n// It will release the connection.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Stream:\n    def __init__(self, connection):\n        self.connection = connection\n        self.finished = False\n\n    def DoFinish(self, err=None):\n        if not self.finished:\n            if err is not None:\n                print(f\"Error: {err}\")\n            self.connection.release()\n            self.finished = True\n```", "```python\nclass StreamingInterface:\n    def __init__(self):\n        pass\n\n    def DoFinish(self, err):\n        # Implement the streaming.WithDoFinish interface, and it records the end of stream\n        # It will release the connection.\n        print(\"Recording the end of stream\")\n        print(f\"Error: {err}\")\n        # You can add your implementation to release the connection here\n        # For example, you can close a database connection or a network socket\n        # self.stream_connection.close()\n```", "```python\nclass StreamingInterface:\n    def do_finish(self, err):\n        # DoFinish implements the streaming.WithDoFinish interface, and it records the end of stream\n        # It will release the connection.\n        print(f\"Streaming finished with error: {err}\")\n        # Release the connection here\n        # For example:\n        # self.connection.close()\n        pass\n```"]}, "kitex-client/client.go-NewClient": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...Option) (Client, error) {\n# Natural Language Annotations: // NewClient creates a kitex.Client with the given ServiceInfo, it is from generated code.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...Option) (kitex.Client, error) {\n    // Create a new client with the given ServiceInfo\n    client := kitex.NewClient(svcInfo, opts...)\n    \n    return client, nil\n}\n```", "```go\nfunc NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...kitex.Option) (kitex.Client, error) {\n    return kitex.NewClient(svcInfo, opts...)\n}\n```", "```go\nfunc NewClient(svcInfo *serviceinfo.ServiceInfo, opts ...kitex.Option) (kitex.Client, error) {\n    return kitex.NewClient(svcInfo, opts...)\n}\n```"]}, "kitex-client/middlewares.go-newResolveMWBuilder": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.MiddlewareBuilder {\n# Natural Language Annotations: // newResolveMWBuilder creates a middleware for service discovery.\n// This middleware selects an appropriate instance based on the resolver and loadbalancer given.\n// If retryable error is encountered, it will retry until timeout or an unretryable error is returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"time\"\n\n\t\"google.golang.org/grpc\"\n\t\"google.golang.org/grpc/balancer/roundrobin\"\n\t\"google.golang.org/grpc/credentials/insecure\"\n\n\t\"google.golang.org/grpc/resolver\"\n\n\t\"github.com/yourproject/lbcache\"\n\t\"github.com/yourproject/endpoint\"\n)\n\nfunc newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.MiddlewareBuilder {\n\treturn func(next endpoint.Handler) endpoint.Handler {\n\t\treturn func(ctx context.Context, req interface{}) (interface{}, error) {\n\t\t\tconn, err := grpc.DialContext(ctx,\n\t\t\t\t\"grpc\",\n\t\t\t\tgrpc.WithInsecure(),\n\t\t\t\tgrpc.WithBalancerName(roundrobin.Name),\n\t\t\t\tgrpc.WithResolvers(lbf.NewResolver()),\n\t\t\t\tgrpc.WithDefaultServiceConfig(lbf.GetConfig()),\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdefer conn.Close()\n\n\t\t\tclient := NewMyServiceClient(conn)\n\n\t\t\tvar (\n\t\t\t\tretryableErr = errors.New(\"retryable error\")\n\t\t\t\tmaxRetries   = 3\n\t\t\t\ttimeout      = 5 * time.Second\n\t\t\t)\n\n\t\t\tfor i := 0; i <= maxRetries; i++ {\n\t\t\t\tif i > 0 {\n\t\t\t\t\ttime.Sleep(100 * time.Millisecond)\n\t\t\t\t}\n\n\t\t\t\tresp, err := client.MyServiceMethod(ctx, req)\n\t\t\t\tif err != nil {\n\t\t\t\t\tif errors.Is(err, retryableErr) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t\treturn nil, err\n\t\t\t\t}\n\n\t\t\t\treturn resp, nil\n\t\t\t}\n\n\t\t\treturn nil, fmt.Errorf(\"max retries exceeded\")\n\t\t}\n\t}\n}\n```", "```python\nfrom typing import Optional\n\nclass MiddlewareBuilder:\n    def __init__(self, lbf: 'lbcache.BalancerFactory'):\n        self.lbf = lbf\n\n    def resolve(self, resolver: 'endpoint.Resolver', timeout: int = 5) -> 'endpoint.Middleware':\n        def middleware(next: 'endpoint.Endpoint') -> 'endpoint.Endpoint':\n            async def inner(*args, **kwargs):\n                for i in range(timeout):\n                    try:\n                        instance = self.lbf.get_instance(resolver)\n                        return await next(instance, *args, **kwargs)\n                    except Exception as e:\n                        if isinstance(e, endpoint.RetryableError):\n                            continue\n                        else:\n                            raise\n            return inner\n        return middleware\n```", "```go\npackage endpoint\n\nimport (\n    \"context\"\n    \"errors\"\n    \"time\"\n\n    \"github.com/go-kit/kit/endpoint\"\n    \"github.com/go-kit/kit/transport\"\n    \"github.com/go-kit/kit/transport/http\"\n    \"github.com/lbcache/lbcache\"\n)\n\nfunc newResolveMWBuilder(lbf *lbcache.BalancerFactory) endpoint.Middleware {\n    return func(next endpoint.Endpoint) endpoint.Endpoint {\n        return http.NewClientMiddleware(\n            transport.NewClient(lbf, func(ctx context.Context, request interface{}) (interface{}, error) {\n                // Select an appropriate instance based on the resolver and loadbalancer given\n                instance, err := lbf.Select(ctx)\n                if err != nil {\n                    return nil, err\n                }\n\n                // Send the request to the selected instance\n                return instance.Request(ctx, request)\n            }, func(ctx context.Context, request interface{}) (interface{}, error) {\n                // If retryable error is encountered, retry until timeout or an unretryable error is returned\n                var (\n                    err    error\n                    attempt int\n                )\n                for attempt = 0; attempt < 3; attempt++ {\n                    res, err := next(ctx, request)\n                    if err != nil {\n                        if err != nil && !IsRetryableError(err) {\n                            return nil, err\n                        }\n                        time.Sleep(100 * time.Millisecond)\n                        continue\n                    }\n                    return res, nil\n                }\n                return nil, err\n            }),\n        )\n    }\n}\n\nfunc IsRetryableError(err error) bool {\n    // implement your custom logic to check if the error is retryable\n    // for example:\n    return errors.Is(err, context.DeadlineExceeded) || errors.Is(err, context.Canceled)\n}\n```"]}, "kitex-client/middlewares.go-DefaultClientErrorHandler": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DefaultClientErrorHandler(ctx context.Context, err error) error {\n# Natural Language Annotations: // DefaultClientErrorHandler is Default ErrorHandler for client\n// when no ErrorHandler is specified with Option `client.WithErrorHandler`, this ErrorHandler will be injected.\n// for thrift\u3001KitexProtobuf, >= v0.4.0 wrap protocol error to TransError, which will be more friendly.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage kitex\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// DefaultClientErrorHandler is Default ErrorHandler for client\n// when no ErrorHandler is specified with Option `client.WithErrorHandler`, this ErrorHandler will be injected.\n// for thrift\u3001KitexProtobuf, >= v0.4.0 wrap protocol error to TransError, which will be more friendly.\nfunc DefaultClientErrorHandler(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif IsTransError(err) {\n\t\treturn err\n\t}\n\treturn WrapTransError(err)\n}\n\nfunc IsTransError(err error) bool {\n\tvar tErr *TransError\n\treturn errors.As(err, &tErr)\n}\n\nfunc WrapTransError(err error) error {\n\treturn &TransError{Err: err}\n}\n\ntype TransError struct {\n\tErr error\n}\n```", "```go\npackage kitex\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"kitex/internal/kitex_gen/trans\"\n\t\"kitex/kitex_gen/trans/transerror\"\n)\n\n// DefaultClientErrorHandler is the default error handler for client.\n// when no ErrorHandler is specified with Option `client.WithErrorHandler`, this ErrorHandler will be injected.\nfunc DefaultClientErrorHandler(ctx context.Context, err error) error {\n\tif err != nil {\n\t\tif t, ok := err.(trans.TransError); ok {\n\t\t\treturn t\n\t\t}\n\t\tif cause, ok := err.Cause(); ok {\n\t\t\treturn errors.Unwrap(cause)\n\t\t}\n\t\treturn errors.Wrap(err, \"default client error handler\")\n\t}\n\treturn nil\n}\n```", "```go\npackage kitex\n\nimport (\n\t\"context\"\n\t\"kitex/internal/errcode\"\n\t\"kitex/kitex_gen/kitextypes\"\n)\n\nfunc DefaultClientErrorHandler(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif protoErr, ok := err.(*kitextypes.Error); ok {\n\t\treturn errcode.NewTransError(protoErr)\n\t}\n\treturn err\n}\n```"]}, "kitex-client/middlewares.go-ClientErrorHandlerWithAddr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ClientErrorHandlerWithAddr(ctx context.Context, err error) error {\n# Natural Language Annotations: // ClientErrorHandlerWithAddr is ErrorHandler for client, which will add remote addr info into error\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\ndef ClientErrorHandlerWithAddr(ctx: dict, err: Exception) -> Optional[Exception]:\n    \"\"\"\n    ClientErrorHandlerWithAddr is ErrorHandler for client, which will add remote addr info into error\n    \"\"\"\n    # Get the remote addr from the context\n    remote_addr = ctx.get('remote_addr')\n    \n    # If remote_addr is available, add it to the error message\n    if remote_addr:\n        err_message = f\"Error occurred at remote address {remote_addr}: {str(err)}\"\n    else:\n        err_message = str(err)\n    \n    # Return the updated error\n    return Exception(err_message)\n```", "```python\nfrom contextlib import contextmanager\nfrom typing import Optional\n\ndef ClientErrorHandlerWithAddr(ctx: context.Context, err: error) -> Optional[error]:\n    \"\"\"\n    ClientErrorHandlerWithAddr is ErrorHandler for client, which will add remote addr info into error\n    \"\"\"\n    @contextmanager\n    def add_remote_addr_info(func):\n        try:\n            yield func\n        except Exception as e:\n            # Add remote addr info to the error\n            if hasattr(ctx, 'RemoteAddr'):\n                err_with_addr = f\"{str(e)} - Remote Addr: {ctx.RemoteAddr}\"\n                raise err_with_addr\n            else:\n                raise e\n\n    return add_remote_addr_info\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n)\n\n// ClientErrorHandlerWithAddr is ErrorHandler for client, which will add remote addr info into error\nfunc ClientErrorHandlerWithAddr(ctx context.Context, err error) error {\n\tif err == nil {\n\t\treturn nil\n\t}\n\tif ctx.Err() != nil {\n\t\treturn fmt.Errorf(\"context error: %w\", ctx.Err())\n\t}\n\tif errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) {\n\t\treturn fmt.Errorf(\"client error: %w\", err)\n\t}\n\treturn fmt.Errorf(\"client error: %w: remote addr: %v\", err, getRemoteAddr(ctx))\n}\n\nfunc getRemoteAddr(ctx context.Context) string {\n\t// This function should be implemented based on the actual way to get remote address in your application\n\t// For example, using http.Request.RemoteAddr\n\treturn \"example.com:8080\"\n}\n```"]}, "kitex-client/option.go-WithInstanceMW": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithInstanceMW(mw endpoint.Middleware) Option {\n# Natural Language Annotations: // WithInstanceMW adds middleware for client to handle request after service discovery and loadbalance process.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass Endpoint:\n    def __init__(self):\n        self.middleware = []\n\ndef WithInstanceMW(mw: Optional['Endpoint']) -> Optional['Endpoint']:\n    \"\"\"\n    Adds middleware for client to handle request after service discovery and loadbalance process.\n    \n    Args:\n    mw: The middleware to be added.\n    \n    Returns:\n    The updated middleware list.\n    \"\"\"\n    mw.middleware.append(\"InstanceMW\")\n    return mw\n```", "```python\nfrom typing import Optional\n\nclass Client:\n    def __init__(self, mw: Optional):\n        self.mw = mw\n\n    def with_instance_mw(self, mw: 'endpoint.Middleware') -> Optional:\n        self.mw = mw\n        return self\n\nclass endpoint:\n    class Middleware:\n        pass\n```", "```python\nfrom typing import Optional\n\nclass Endpoint:\n    def __init__(self, middleware: Optional['Middleware']):\n        self.middleware = middleware\n\nclass Middleware:\n    def handle_request(self, request):\n        pass\n\ndef WithInstanceMW(mw: Middleware) -> Optional[Endpoint]:\n    \"\"\"\n    Adds middleware for client to handle request after service discovery and loadbalance process.\n    \n    Args:\n    mw (Middleware): The middleware to be added.\n    \n    Returns:\n    Optional[Endpoint]: The endpoint with the added middleware.\n    \"\"\"\n    return Endpoint(mw)\n```"]}, "kitex-client/option.go-WithHostPorts": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithHostPorts(hostports ...string) Option {\n# Natural Language Annotations: // WithHostPorts specifies the target instance addresses when doing service discovery.\n// It overwrites the results from the Resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\ninterface Option {\n  hostports: string[];\n}\n\nfunction withHostPorts(...hostports: string[]): Option {\n  return { hostports };\n}\n```", "```python\nfrom typing import Optional\n\nclass Resolver:\n    def __init__(self):\n        self.hostports = {}\n\n    def with_host_ports(self, *hostports: str) -> Optional[dict]:\n        \"\"\"\n        WithHostPorts specifies the target instance addresses when doing service discovery.\n        It overwrites the results from the Resolver.\n        \n        Args:\n        hostports (str): A variable number of host-port pairs.\n        \n        Returns:\n        dict: The updated hostports dictionary.\n        \"\"\"\n        self.hostports = {hostport: None for hostport in hostports}\n        return self.hostports\n```", "```python\nfrom typing import Optional\n\ndef with_host_ports(*hostports: str) -> Optional[dict]:\n    \"\"\"\n    WithHostPorts specifies the target instance addresses when doing service discovery.\n    It overwrites the results from the Resolver.\n    \"\"\"\n    return {'hostports': hostports}\n```"]}, "kitex-client/option.go-WithShortConnection": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithShortConnection() Option {\n# Natural Language Annotations: // WithShortConnection forces kitex to close connection after each call is finished.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom kitex.core import client\n\nclass ShortConnectionClient(client.Client):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def with_short_connection(self, handler):\n        return self._with_short_connection(handler)\n\n    def _with_short_connection(self, handler):\n        # Forces kitex to close connection after each call is finished.\n        # This is the actual implementation of the WithShortConnection function\n        # It uses a context manager to close the connection after the call\n        try:\n            yield self\n            yield from handler(self)\n        finally:\n            self.close()\n```", "```python\nfrom kitex.core import grpc_connection\n\ndef with_short_connection(func):\n    def wrapper(*args, **kwargs):\n        conn = grpc_connection()\n        try:\n            return func(conn, *args, **kwargs)\n        finally:\n            conn.close()\n    return wrapper\n```", "```python\nfrom kitex.core import Client\n\nclass MyClient(Client):\n    def __init__(self):\n        super().__init__()\n        self._is_closed = False\n\n    def WithShortConnection(self):\n        self._is_closed = True\n```"]}, "kitex-client/option.go-WithLongConnection": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithLongConnection(cfg connpool.IdleConfig) Option {\n# Natural Language Annotations: // WithLongConnection enables long connection with kitex's built-in pooling implementation.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom kitex.core import ConnectionPool\n\ndef with_long_connection(config: dict) -> dict:\n    \"\"\"\n    Enables long connection with kitex's built-in pooling implementation.\n\n    Args:\n        config (dict): Configuration for the connection pool.\n\n    Returns:\n        dict: A dictionary representing the long connection configuration.\n    \"\"\"\n    return ConnectionPool(config)\n```", "```python\nfrom typing import Optional\n\ndef with_long_connection(conn_pool: dict) -> Optional[dict]:\n    \"\"\"\n    Enables long connection with kitex's built-in pooling implementation.\n\n    Args:\n        conn_pool (dict): idle config for connection pooling\n\n    Returns:\n        Optional[dict]: the updated connection pool config with long connection enabled\n    \"\"\"\n    conn_pool['max_idle_connections'] = 100\n    conn_pool['max_idle_time'] = 300  # 5 minutes\n    return conn_pool\n```", "```python\nfrom typing import Optional\n\nclass IdleConfig:\n    def __init__(self, max_idle_connections: int, idle_timeout: int):\n        self.max_idle_connections = max_idle_connections\n        self.idle_timeout = idle_timeout\n\nclass ConnectionPool:\n    def __init__(self, idle_config: IdleConfig):\n        self.idle_config = idle_config\n        self.connections = []\n\n    def get_connection(self) -> Optional[object]:\n        # implementation to get a connection from the pool\n        pass\n\n    def return_connection(self, connection: object):\n        # implementation to return a connection to the pool\n        pass\n\ndef with_long_connection(idle_config: IdleConfig) -> Optional[object]:\n    return ConnectionPool(idle_config).get_connection()\n```"]}, "kitex-client/option.go-WithMuxConnection": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMuxConnection(connNum int) Option {\n# Natural Language Annotations: // WithMuxConnection specifies the transport type to be mux.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\ndef with_mux_connection(conn_num: int) -> Optional[int]:\n    return conn_num\n```", "```python\nfrom typing import Optional\n\ndef with_mux_connection(conn_num: int) -> Optional[int]:\n    return conn_num\n```", "```python\nfrom typing import Optional\n\ndef with_mux_connection(conn_num: int) -> Optional[int]:\n    \"\"\"\n    Specifies the transport type to be mux.\n\n    Args:\n    conn_num (int): The connection number.\n\n    Returns:\n    Optional[int]: The connection number if successful, otherwise None.\n    \"\"\"\n    # Your implementation here\n    return conn_num\n```"]}, "kitex-client/option.go-WithTimeoutProvider": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithTimeoutProvider(p rpcinfo.TimeoutProvider) Option {\n# Natural Language Annotations: // WithTimeoutProvider adds a TimeoutProvider to the client.\n// Note that the timeout settings provided by the TimeoutProvider\n// will be applied before the other timeout options in this package\n// and those in the callopt package. Thus it can not modify the\n// timeouts set by WithRPCTimeout or WithConnectTimeout.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\ninterface TimeoutProvider {\n  getTimeout(): number;\n}\n\nclass TimeoutProviderImpl implements TimeoutProvider {\n  private timeout: number;\n\n  constructor(timeout: number) {\n    this.timeout = timeout;\n  }\n\n  getTimeout(): number {\n    return this.timeout;\n  }\n}\n\nfunction WithTimeoutProvider(p: TimeoutProvider): () => void {\n  return function wrapper(client: any) {\n    return function () {\n      const timeout = p.getTimeout();\n      client.timeout = timeout;\n      return client;\n    }\n  }\n}\n\n// Example usage:\nconst timeoutProvider = new TimeoutProviderImpl(1000);\nconst client = { timeout: 5000 };\nconst wrappedClient = WithTimeoutProvider(timeoutProvider)(client);\nconsole.log(wrappedClient.timeout);  // prints 1000\n```", "```rust\n/// WithTimeoutProvider adds a TimeoutProvider to the client.\n/// Note that the timeout settings provided by the TimeoutProvider\n/// will be applied before the other timeout options in this package\n/// and those in the callopt package. Thus it can not modify the\n/// timeouts set by WithRPCTimeout or WithConnectTimeout.\npub fn with_timeout_provider<R>(timeout_provider: impl TimeoutProvider) -> impl FnOnce(&mut R) -> R + '_\nwhere\n    R: RpcInfo,\n{\n    move |client: &mut R| {\n        client.timeout_provider.clone_from(timeout_provider);\n        client\n    }\n}\n```", "```go\nfunc WithTimeoutProvider(p rpcinfo.TimeoutProvider) Option {\n    return func(o *Option) *Option {\n        return &Option{\n            timeoutProvider: p,\n            timeout:        o.timeout,\n            connectTimeout:  o.connectTimeout,\n            readTimeout:     o.readTimeout,\n            writeTimeout:    o.writeTimeout,\n        }\n    }\n}\n```"]}, "kitex-client/option.go-WithCodec": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithCodec(c remote.Codec) Option {\n# Natural Language Annotations: // WithCodec to set a codec that handle other protocols which not support by kitex\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass remote:\n    class Codec:\n        pass\n\ndef WithCodec(codec: Optional[remote.Codec]) -> None:\n    \"\"\"\n    WithCodec to set a codec that handle other protocols which not support by kitex\n    \"\"\"\n    # Your implementation here\n    pass\n```", "```python\nfrom typing import Optional\n\nclass Codec:\n    pass\n\nclass Kitex:\n    def __init__(self):\n        self.codec = None\n\n    def WithCodec(self, c: Codec) -> Optional['Kitex']:\n        self.codec = c\n        return self\n```", "```python\nfrom typing import Optional\n\nclass Codec:\n    def __init__(self):\n        pass\n\nclass Kitex:\n    def __init__(self):\n        self.codec: Optional[Codec] = None\n\n    def with_codec(self, c: Codec) -> None:\n        self.codec = c\n```"]}, "kitex-client/option.go-WithPayloadCodec": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithPayloadCodec(c remote.PayloadCodec) Option {\n# Natural Language Annotations: // WithPayloadCodec to set a payloadCodec that handle other payload which not support by kitex\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass PayloadCodec:\n    def encode(self, payload: bytes) -> bytes:\n        pass\n\n    def decode(self, payload: bytes) -> bytes:\n        pass\n\nclass Kitex:\n    def __init__(self):\n        self.payload_codec: Optional[PayloadCodec] = None\n\n    def WithPayloadCodec(self, payload_codec: PayloadCodec) -> None:\n        \"\"\"\n        Set a payloadCodec that handle other payload which not support by kitex\n        \"\"\"\n        self.payload_codec = payload_codec\n```", "```python\nclass RemotePayloadCodec:\n    def __init__(self, payload_codec):\n        self.payload_codec = payload_codec\n\n    def handle_payload(self, payload):\n        return self.payload_codec.decode(payload)\n\ndef with_payload_codec(payload_codec):\n    return RemotePayloadCodec(payload_codec)\n```", "```python\nclass RemotePayloadCodec:\n    def __init__(self, payload_codec):\n        self.payload_codec = payload_codec\n\ndef with_payload_codec(remote_payload_codec):\n    \"\"\"\n    Set a payloadCodec that handles other payload which is not supported by kitex.\n    \n    Args:\n        remote_payload_codec (PayloadCodec): The payload codec to be set.\n    \n    Returns:\n        Option: The payload codec.\n    \"\"\"\n    return remote_payload_codec\n```"]}, "kitex-client/option.go-WithConnReporterEnabled": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithConnReporterEnabled() Option {\n# Natural Language Annotations: // WithConnReporterEnabled to enable reporting connection pool stats.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef WithConnReporterEnabled():\n    \"\"\"\n    WithConnReporterEnabled to enable reporting connection pool stats.\n    \"\"\"\n    # Enable connection pool statistics reporting\n    # This is a placeholder for the actual implementation which can vary based on the database driver being used\n    # For example, in Python's sqlite3, you can use the 'check_same_thread=False' argument when creating a connection to enable connection pool stats\n    # For other drivers, the implementation may differ\n    pass\n```", "```python\ndef with_conn_reporter_enabled():\n    \"\"\"\n    Enables reporting connection pool stats.\n    \"\"\"\n    # Assuming you are using a connection pool library like sqlalchemy or aiomysql\n    # For this example, we'll use aiomysql\n    import aiomysql\n    \n    # Create a connection pool\n    pool = aiomysql.connect(\n        host='your_host',\n        user='your_user',\n        password='your_password',\n        db='your_database'\n    )\n    \n    # Set the connection pool to report stats\n    pool.report_stats = True\n    \n    return pool\n```", "```python\nfrom sqlalchemy import create_engine\n\ndef with_conn_reporter_enabled():\n    engine = create_engine('sqlite:///example.db')\n    engine.pool.dialect.pool_logger.setLevel('DEBUG')\n    return engine\n```"]}, "kitex-client/option.go-WithFailureRetry": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithFailureRetry(p *retry.FailurePolicy) Option {\n# Natural Language Annotations: // WithFailureRetry sets the failure retry policy for client, it will take effect for all methods.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass FailurePolicy:\n    def __init__(self, max_attempts: int, backoff_factor: float):\n        \"\"\"\n        FailurePolicy holds the retry policy settings.\n\n        :param max_attempts: The maximum number of attempts to make before giving up.\n        :param backoff_factor: The factor to multiply the delay by after each attempt.\n        \"\"\"\n        self.max_attempts = max_attempts\n        self.backoff_factor = backoff_factor\n        self.attempts = 0\n\n    def __repr__(self):\n        return f\"FailurePolicy(max_attempts={self.max_attempts}, backoff_factor={self.backoff_factor}, attempts={self.attempts})\"\n\nclass Client:\n    def __init__(self):\n        self.failure_policy = None\n\n    def with_failure_retry(self, policy: FailurePolicy) -> Optional['Client']:\n        \"\"\"\n        WithFailureRetry sets the failure retry policy for client, it will take effect for all methods.\n        \n        :param policy: The failure policy to use.\n        :return: The Client instance with the failure retry policy set.\n        \"\"\"\n        self.failure_policy = policy\n        return self\n\n    def _retryable_method(self, func):\n        \"\"\"\n        A decorator that will retry the decorated method with the configured failure policy.\n        \n        :param func: The method to decorate.\n        :return: A wrapper around the method that will retry it if it fails.\n        \"\"\"\n        def wrapper(*args, **kwargs):\n            attempt = 0\n            while attempt < self.failure_policy.max_attempts:\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    if attempt < self.failure_policy.max_attempts - 1:\n                        import time\n                        time.sleep(self.failure_policy.backoff_factor * (2 ** attempt))\n                        attempt += 1\n                    else:\n                        raise e\n        return wrapper\n\n    def method1(self):\n        # This method will be retryable\n        pass\n\n    def method2(self):\n        # This method will be retryable\n        pass\n\nclient = Client()\npolicy = FailurePolicy(3, 1)\nclient = client.with_failure_retry(policy)\n```", "```python\nclass RetryPolicy:\n    def __init__(self, max_attempts: int, backoff_factor: float):\n        self.max_attempts = max_attempts\n        self.backoff_factor = backoff_factor\n        self.attempts = 0\n\n    def is_retryable(self):\n        return self.attempts < self.max_attempts\n\n    def increment_attempts(self):\n        self.attempts += 1\n\n\nclass FailurePolicy:\n    def __init__(self, retry_policy: RetryPolicy):\n        self.retry_policy = retry_policy\n\n    def is_retry(self):\n        return self.retry_policy.is_retryable()\n\n    def increment_attempts(self):\n        self.retry_policy.increment_attempts()\n\n\nclass Option:\n    def __init__(self, value):\n        self.value = value\n\n\ndef with_failure_retry(max_attempts: int = 3, backoff_factor: float = 1.0):\n    return Option(RetryPolicy(max_attempts, backoff_factor))\n\n\ndef set_failure_retry(policy: Option):\n    return policy.value if policy.value else None\n```", "```python\nclass FailurePolicy:\n    def __init__(self, max_retries, retry_delay):\n        self.max_retries = max_retries\n        self.retry_delay = retry_delay\n\nclass Client:\n    def __init__(self, failure_policy=None):\n        self.failure_policy = failure_policy\n\n    def set_failure_retry(self, policy):\n        self.failure_policy = policy\n\ndef with_failure_retry(policy):\n    client = Client(policy)\n    return client\n```"]}, "kitex-client/option.go-WithBackupRequest": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithBackupRequest(p *retry.BackupPolicy) Option {\n# Natural Language Annotations: // WithBackupRequest sets the backup request policy for client, it will take effect for all methods.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithBackupRequest(p *retry.BackupPolicy) Option {\n    return func(next func() error) func() error {\n        return func() error {\n            err := next()\n            if p != nil {\n                // implement backup request logic here\n                fmt.Println(\"Backup request is enabled\")\n            }\n            return err\n        }\n    }\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\n\t\"github.com/your/retry\"\n)\n\nfunc WithBackupRequest(p *retry.BackupPolicy) func() {\n\treturn func() {\n\t\tretry.SetBackupPolicy(p)\n\t}\n}\n```", "```go\nfunc WithBackupRequest(p *retry.BackupPolicy) Option {\n    return func(client *Client) *Client {\n        client.backupRequest = p\n        return client\n    }\n}\n```"]}, "kitex-client/option.go-WithSpecifiedResultRetry": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithSpecifiedResultRetry(rr *retry.ShouldResultRetry) Option {\n# Natural Language Annotations: // WithSpecifiedResultRetry is used with FailureRetry.\n// When you enable FailureRetry and want to retry with the specified error or response, you can configure this Option.\n// ShouldResultRetry is defined inside retry.FailurePolicy, so WithFailureRetry also can set ShouldResultRetry.\n// But if your retry policy is enabled by remote config, WithSpecifiedResultRetry is useful.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\nenum RetryResult {\n  Retry,\n  Continue,\n  Stop,\n}\n\ninterface ShouldResultRetry {\n  (result: any): RetryResult;\n}\n\nclass Retry {\n  static WithSpecifiedResultRetry(rr: ShouldResultRetry): (func: Function) => Function {\n    return function (func: Function) {\n      return function (...args: any[]) {\n        const result = func(...args);\n        const shouldRetry = rr(result);\n        if (shouldRetry === RetryResult.Retry) {\n          return this.retry();\n        } else if (shouldRetry === RetryResult.Continue) {\n          return result;\n        } else {\n          throw result;\n        }\n      };\n    };\n  }\n}\n```", "```typescript\ninterface ShouldResultRetry {\n  // Add properties and methods as needed\n}\n\nclass RetryOption {\n  private shouldResultRetry: ShouldResultRetry;\n\n  constructor(shouldResultRetry: ShouldResultRetry) {\n    this.shouldResultRetry = shouldResultRetry;\n  }\n\n  get WithSpecifiedResultRetry(): boolean {\n    return true;\n  }\n}\n\nclass FailureRetry {\n  private shouldResultRetry: ShouldResultRetry;\n\n  constructor(shouldResultRetry: ShouldResultRetry) {\n    this.shouldResultRetry = shouldResultRetry;\n  }\n\n  get WithSpecifiedResultRetry(): RetryOption {\n    return new RetryOption(this.shouldResultRetry);\n  }\n}\n\n// Example usage:\nconst shouldResultRetry: ShouldResultRetry = {\n  // implement properties and methods as needed\n};\nconst failureRetry = new FailureRetry(shouldResultRetry);\nconst retryOption = failureRetry.WithSpecifiedResultRetry;\n```", "```typescript\ninterface ShouldResultRetry {\n  isRetryable(error: any, response: any): boolean;\n}\n\nclass WithSpecifiedResultRetry {\n  private shouldResultRetry: ShouldResultRetry;\n\n  constructor(shouldResultRetry: ShouldResultRetry) {\n    this.shouldResultRetry = shouldResultRetry;\n  }\n\n  public option(): boolean {\n    return true;\n  }\n}\n```"]}, "kitex-client/option.go-WithGRPCInitialConnWindowSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialConnWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialConnWindowSize sets the value for initial window size on a connection of grpc.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the WithInitialConnWindowSize DialOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nfunc WithGRPCInitialConnWindowSize(s uint32) Option {\n    if s < 64*1024 {\n        return nil\n    }\n    return grpc.WithInitialConnWindowSize(s)\n}\n```", "```go\nfunc WithGRPCInitialConnWindowSize(s uint32) Option {\n    if s < 64*1024 {\n        return nil\n    }\n    return func(conn *grpc.ClientConn) error {\n        return conn.SetOption(grpc.WithInitialConnWindowSize(s))\n    }\n}\n```", "```go\nfunc WithGRPCInitialConnWindowSize(s uint32) (interface{}, error) {\n    if s < 64*1024 {\n        return nil, errors.New(\"window size must be at least 64K\")\n    }\n    return s, nil\n}\n```"]}, "kitex-client/option.go-WithGRPCMaxHeaderListSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxHeaderListSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxHeaderListSize returns a DialOption that specifies the maximum\n// (uncompressed) size of header list that the client is prepared to accept.\n// It corresponds to the WithMaxHeaderListSize DialOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithGRPCMaxHeaderListSize(s uint32) grpc.DialOption {\n    return grpc.WithMaxHeaderListSize(int(s))\n}\n```", "```go\nfunc WithGRPCMaxHeaderListSize(s uint32) grpc.DialOption {\n    return grpc.WithMaxHeaderListSize(int(s))\n}\n```", "```go\n// WithGRPCMaxHeaderListSize returns a DialOption that specifies the maximum\n// (uncompressed) size of header list that the client is prepared to accept.\n// It corresponds to the WithMaxHeaderListSize DialOption of gRPC.\nfunc WithGRPCMaxHeaderListSize(s uint32) net.Option {\n    return func(connDialer net.Dialer, c *net.DialConfig) (net.Dialer, error) {\n        c.MaxHeaderListSize = s\n        return connDialer, nil\n    }\n}\n```"]}, "kitex-client/option.go-WithGRPCKeepaliveParams": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveParams returns a DialOption that specifies keepalive parameters for the client transport.\n// It corresponds to the WithKeepaliveParams DialOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) grpc.DialOption {\n    return grpc.WithKeepaliveParams(kp)\n}\n```", "```\nfunc WithGRPCKeepaliveParams(kp grpc.ClientKeepalive) Option {\n    return func(dialOption func(*grpc.DialOption) *grpc.DialOption) *grpc.DialOption {\n        return func(opt *grpc.DialOption) *grpc.DialOption {\n            return dialOption(opt.WithKeepaliveParams(kp))\n        }\n    }\n}\n```", "```go\npackage grpc\n\nimport (\n\t\"context\"\n\t\"net\"\n\n\t\"google.golang.org/grpc/keepalive\"\n)\n\n// WithGRPCKeepaliveParams returns a DialOption that specifies keepalive parameters for the client transport.\n// It corresponds to the WithKeepaliveParams DialOption of gRPC.\nfunc WithGRPCKeepaliveParams(kp keepalive.ClientParameters) Option {\n\treturn func(opt opts) (opts, error) {\n\t\topt.KeepaliveParams = kp\n\t\treturn opts, nil\n\t}\n}\n```"]}, "kitex-client/option.go-WithWarmingUp": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithWarmingUp(wuo *warmup.ClientOption) Option {\n# Natural Language Annotations: // WithWarmingUp forces the client to do some warm-ups at the end of the initialization.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass warmup:\n    class ClientOption:\n        pass\n\ndef WithWarmingUp(wuo: warmup.ClientOption) -> Optional[warmup.ClientOption]:\n    # do some warm-ups\n    # for example:\n    wuo.warm_up()\n    return wuo\n```", "```typescript\nclass WarmupClientOption {\n    warmUp: boolean;\n}\n\nfunction withWarmingUp(wuo: WarmupClientOption): Option {\n    wuo.warmUp = true;\n    return new Option(wuo);\n}\n\nclass Option {\n    private value: any;\n\n    constructor(value: any) {\n        this.value = value;\n    }\n\n    get(): any {\n        return this.value;\n    }\n}\n```", "```python\nfrom typing import Optional\n\nclass Warmup:\n    def __init__(self, client_option: 'warmup.ClientOption'):\n        self.client_option = client_option\n\n    def __enter__(self):\n        # Perform warm-ups here\n        print(\"Performing warm-ups...\")\n        return self\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        # Clean up after warm-ups\n        print(\"Warm-ups completed.\")\n\ndef WithWarmingUp(wuo: 'warmup.ClientOption') -> Optional['Warmup']:\n    return Warmup(wuo)\n```"]}, "kitex-client/callopt/options.go-WithHostPort": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithHostPort(hostport string) Option {\n# Natural Language Annotations: // WithHostPort specifies the target address for a RPC call.\n// The given address will overwrite the result from Resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass RPC:\n    def __init__(self):\n        self.resolver = None\n\n    def with_host_port(self, hostport: str) -> Optional[str]:\n        \"\"\"\n        WithHostPort specifies the target address for a RPC call.\n        The given address will overwrite the result from Resolver.\n        \n        Args:\n            hostport (str): The target address for the RPC call.\n        \n        Returns:\n            Optional[str]: The target address for the RPC call.\n        \"\"\"\n        self.resolver = hostport\n        return hostport\n```", "```python\nfrom typing import Optional\n\nclass Config:\n    def __init__(self):\n        self.resolver_address = None\n\ndef with_host_port(hostport: str) -> Optional[str]:\n    \"\"\"\n    WithHostPort specifies the target address for a RPC call.\n    The given address will overwrite the result from Resolver.\n    \"\"\"\n    self = Config()\n    self.resolver_address = hostport\n    return self.resolver_address\n```", "```python\nclass Resolver:\n    def __init__(self):\n        self.hostport = None\n\n    def with_host_port(self, hostport: str) -> 'Resolver':\n        self.hostport = hostport\n        return self\n\ndef with_host_port(hostport: str) -> 'Resolver':\n    return Resolver().with_host_port(hostport)\n```"]}, "kitex-client/callopt/options.go-WithURL": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithURL(url string) Option {\n# Natural Language Annotations: // WithURL specifies the target for a RPC call with url.\n// The given url will be resolved to hostport and overwrites the result from Resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass Resolver:\n    def __init__(self):\n        self.hostport = None\n\n    def resolve(self, url: str) -> Optional[str]:\n        # implement url resolution logic here\n        # for simplicity, let's assume we're just returning the url as is\n        return url\n\nclass RPC:\n    def __init__(self):\n        self.resolver = Resolver()\n\n    def WithURL(self, url: str) -> Optional[str]:\n        \"\"\"WithURL specifies the target for a RPC call with url.\n        The given url will be resolved to hostport and overwrites the result from Resolver.\"\"\"\n        self.resolver.hostport = url\n        return self.resolver.resolve(url)\n\n# usage\nrpc = RPC()\nprint(rpc.WithURL(\"http://example.com\"))\n```", "```python\nfrom typing import Optional\n\nclass Resolver:\n    def __init__(self):\n        self.hostport = None\n\nclass RPC:\n    def __init__(self):\n        self.resolver = Resolver()\n\n    def WithURL(self, url: str) -> Optional[str]:\n        # Resolve the given url to hostport and overwrite the result from Resolver\n        hostport = url\n        self.resolver.hostport = hostport\n        return hostport\n```", "```python\nclass Resolver:\n    def __init__(self):\n        self.hostport = None\n\nclass Option:\n    def __init__(self, hostport=None):\n        self.hostport = hostport\n\ndef WithURL(url: str) -> Option:\n    \"\"\"\n    Specifies the target for a RPC call with url.\n    The given url will be resolved to hostport and overwrites the result from Resolver.\n    \"\"\"\n    # Resolve the url to hostport\n    from urllib.parse import urlparse\n    parsed_url = urlparse(url)\n    hostport = f\"{parsed_url.netloc}\"\n\n    # Create a new Option instance with the resolved hostport\n    return Option(hostport=hostport)\n```"]}, "kitex-client/callopt/options.go-WithRPCTimeout": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithRPCTimeout(d time.Duration) Option {\n# Natural Language Annotations: // WithRPCTimeout specifies the RPC timeout for a RPC call.\n// FIXME: callopt.WithRPCTimeout works only when client.WithRPCTimeout or\n// client.WithTimeoutProvider is specified.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithRPCTimeout(d time.Duration) Option {\n    return func(opts *Options) {\n        opts.RPCTimeout = d\n    }\n}\n```", "```go\nfunc WithRPCTimeout(d time.Duration) Option {\n    return func(next func(*Option) error) func(*Option) error {\n        return func(o *Option) error {\n            o.rpcTimeout = d\n            return next(o)\n        }\n    }\n}\n```", "```javascript\nfunction WithRPCTimeout(d) {\n    return {\n        withRPCTimeout: (func) => {\n            return function (...args) {\n                return new Promise((resolve, reject) => {\n                    const timeoutId = setTimeout(() => {\n                        reject(new Error('Timeout'));\n                    }, d * 1000);\n                    func(...args).then((result) => {\n                        clearTimeout(timeoutId);\n                        resolve(result);\n                    }).catch((err) => {\n                        clearTimeout(timeoutId);\n                        reject(err);\n                    });\n                });\n            }\n        }\n    }\n}\n```"]}, "kitex-client/callopt/options.go-WithConnectTimeout": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithConnectTimeout(d time.Duration) Option {\n# Natural Language Annotations: // WithConnectTimeout specifies the connection timeout for a RPC call.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass TimeoutError(Exception):\n    pass\n\nclass Option:\n    def __init__(self, value: Optional[int]):\n        self.value = value\n\ndef with_connect_timeout(d: int) -> Option:\n    return Option(d)\n```", "```python\nfrom typing import Optional\n\nclass RPCClient:\n    def __init__(self):\n        self.timeout = None\n\n    def WithConnectTimeout(self, d: int) -> Optional[int]:\n        self.timeout = d\n        return self.timeout\n```", "```python\nfrom typing import Optional\n\nclass RpcConfig:\n    def __init__(self):\n        self.connect_timeout = None\n\n    def WithConnectTimeout(self, d: int) -> 'RpcConfig':\n        self.connect_timeout = d\n        return self\n```"]}, "kitex-client/callopt/options.go-WithFallback": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithFallback(fb *fallback.Policy) Option {\n# Natural Language Annotations: // WithFallback is used to set the fallback policy for a RPC call.\n// Demos are provided below:\n//\n//\tdemo1. call with fallback for error\n//\t\t`resp, err := cli.Mock(ctx, req, callopt.WithFallback(fallback.ErrorFallback(yourFBFunc))`\n//\tdemo2. call with fallback for error and enable reportAsFallback, which sets reportAsFallback to be true and will do report(metric) as Fallback result\n//\t\t`resp, err := cli.Mock(ctx, req, callopt.WithFallback(fallback.ErrorFallback(yourFBFunc).EnableReportAsFallback())`\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithFallback(fb *fallback.Policy) callopt.Option {\n    return callopt.WithFallback(func(err error) (bool, string) {\n        return fb.Fallback(err)\n    })\n}\n\nfunc ErrorFallback(fbFunc func(error) (bool, string)) *fallback.Policy {\n    return &fallback.Policy{\n        Fallback: fbFunc,\n    }\n}\n\nfunc (p *fallback.Policy) EnableReportAsFallback() *fallback.Policy {\n    p.ReportAsFallback = true\n    return p\n}\n```", "```go\nfunc WithFallback(fb *fallback.Policy) Option {\n    return func(opt *options.Options) *options.Options {\n        opt.Fallback = fb\n        return opt\n    }\n}\n```", "```go\nfunc WithFallback(fb *fallback.Policy) Option {\n\treturn func(opt *Option) (*Option, error) {\n\t\tif opt == nil {\n\t\t\topt = &Option{}\n\t\t}\n\t\topt.Fallback = fb\n\t\treturn opt, nil\n\t}\n}\n```"]}, "kitex-server/option_advanced.go-WithServerBasicInfo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithServerBasicInfo(ebi *rpcinfo.EndpointBasicInfo) Option {\n# Natural Language Annotations: // WithServerBasicInfo provides initial information for client endpoint in RPCInfo.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass RPCInfo:\n    def __init__(self):\n        self.endpoint_basic_info = None\n\n    def with_server_basic_info(self, ebi: 'RPCInfo.EndpointBasicInfo') -> Optional['RPCInfo']:\n        self.endpoint_basic_info = ebi\n        return self\n\nclass EndpointBasicInfo:\n    def __init__(self):\n        self.host = None\n        self.port = None\n\n# Example usage:\nrpc_info = RPCInfo()\nebi = EndpointBasicInfo()\nebi.host = \"localhost\"\nebi.port = 8080\nrpc_info.with_server_basic_info(ebi)\n```", "```python\nfrom typing import Optional\n\nclass RPCInfo:\n    def __init__(self, endpoint: str, port: int):\n        self.endpoint = endpoint\n        self.port = port\n        self.server_info = None\n\nclass EndpointBasicInfo:\n    def __init__(self, endpoint: str, port: int):\n        self.endpoint = endpoint\n        self.port = port\n\nclass ServerInfo:\n    def __init__(self, host: str, version: str):\n        self.host = host\n        self.version = version\n\ndef with_server_basic_info(ebi: EndpointBasicInfo) -> Optional[RPCInfo]:\n    rpc_info = RPCInfo(ebi.endpoint, ebi.port)\n    rpc_info.server_info = ServerInfo('default_host', 'default_version')\n    return rpc_info\n```", "```python\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Optional, Dict\n\nclass ServerStatus(Enum):\n    ONLINE = \"online\"\n    OFFLINE = \"offline\"\n\n@dataclass\nclass ServerBasicInfo:\n    id: str\n    name: str\n    status: ServerStatus\n    address: str\n    port: int\n\nclass RPCInfo:\n    def __init__(self, endpoint_basic_info: ServerBasicInfo):\n        self.endpoint_basic_info = endpoint_basic_info\n\ndef with_server_basic_info(ebi: ServerBasicInfo) -> Optional[RPCInfo]:\n    return RPCInfo(ebi)\n```"]}, "kitex-server/option_advanced.go-WithSupportedTransportsFunc": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithSupportedTransportsFunc(f func(option remote.ServerOption) []string) Option {\n# Natural Language Annotations: // WithSupportedTransportsFunc sets a function which converts supported transports from server option.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Callable, List\n\nclass Option:\n    def __init__(self, server_option: str):\n        self.server_option = server_option\n\ndef with_supported_transports_func(f: Callable[[Option], List[str]]) -> Option:\n    def wrapper(option: Option) -> List[str]:\n        return f(option)\n    return wrapper\n```", "```python\nfrom typing import Callable, List\n\nclass Option:\n    def __init__(self, value: str):\n        self.value = value\n\nclass remote:\n    class ServerOption:\n        def __init__(self):\n            pass\n\ndef WithSupportedTransportsFunc(f: Callable[[Option], List[str]]) -> Option:\n    return Option(f(Option(\"\")))\n```", "```python\nfrom typing import Callable, List\n\nclass Option:\n    def __init__(self, value: str):\n        self.value = value\n\nclass ServerOption:\n    def __init__(self, transports: List[str]):\n        self.transports = transports\n\ndef with_supported_transports_func(f: Callable[[ServerOption], List[str]]) -> Option:\n    def wrapper(option: ServerOption) -> List[str]:\n        return f(option)\n    return Option(wrapper)\n```"]}, "kitex-server/option.go-WithMiddleware": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMiddleware(mw endpoint.Middleware) Option {\n# Natural Language Annotations: // WithMiddleware adds middleware for server to handle request.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef with_middleware(middleware: callable) -> callable:\n    \"\"\"\n    Adds middleware for server to handle request.\n    \n    Args:\n    middleware: A callable middleware function.\n    \n    Returns:\n    A decorator that wraps the original function with the given middleware.\n    \"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            return middleware(func(*args, **kwargs))\n        return wrapper\n    return decorator\n```", "```python\nfrom typing import Optional\n\nclass Middleware:\n    def __init__(self, func):\n        self.func = func\n\ndef WithMiddleware(mw: Middleware) -> Optional[Middleware]:\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            return mw.func(func)(*args, **kwargs)\n        return wrapper\n    return decorator\n```", "```python\nfrom typing import Optional\n\nclass Middleware:\n    def __init__(self, handler):\n        self.handler = handler\n\n    def __call__(self, request):\n        return self.handler(request)\n\ndef WithMiddleware(middleware: Middleware) -> Optional['WithMiddleware']:\n    def decorator(func):\n        def wrapper(request):\n            return middleware(request, func)\n        return wrapper\n    return decorator\n\nclass Endpoint:\n    def __init__(self, handler):\n        self.handler = handler\n\n    def __call__(self, request):\n        return self.handler(request)\n\ndef main():\n    # Example usage:\n    def hello_world(request):\n        return \"Hello, World!\"\n\n    endpoint = Endpoint(hello_world)\n    middleware = Middleware(endpoint)\n    decorated_endpoint = WithMiddleware(middleware)(endpoint)\n    print(decorated_endpoint(request=\"GET /\"))\n\nif __name__ == \"__main__\":\n    main()\n```"]}, "kitex-server/option.go-WithMiddlewareBuilder": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMiddlewareBuilder(mwb endpoint.MiddlewareBuilder, funcName ...string) Option {\n# Natural Language Annotations: // WithMiddlewareBuilder adds middleware that depend on context for server to handle request\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n    \"context\"\n    \"net/http\"\n\n    \"github.com/gin-gonic/gin\"\n    \"github.com/google/uuid\"\n)\n\n// WithMiddlewareBuilder is a function that adds middleware that depend on context for server to handle request\nfunc WithMiddlewareBuilder(mwb gin.HandlerFunc, funcName ...string) gin.HandlerFunc {\n    return func(c *gin.Context) {\n        // Generate a unique ID for the request\n        requestId := uuid.New().String()\n\n        // Add middleware to the context\n        c.Set(\"request_id\", requestId)\n\n        // Call the next handler in the chain\n        c.Next()\n\n        // Custom logic here if needed\n        if len(funcName) > 0 {\n            // Call the function with the provided name\n            mwb(c)\n        }\n    }\n}\n```", "```python\nfrom typing import Optional\n\nclass MiddlewareBuilder:\n    def __init__(self, func):\n        self.func = func\n\nclass Option:\n    def __init__(self, value):\n        self.value = value\n\ndef WithMiddlewareBuilder(mwb: MiddlewareBuilder, func_name: str) -> Optional[MiddlewareBuilder]:\n    def decorator(func):\n        mwb.func = func\n        mwb.func_name = func_name\n        return mwb\n    return decorator\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n)\n\ntype Option struct{}\n\nfunc WithMiddlewareBuilder(mwb endpoint.MiddlewareBuilder, funcName ...string) Option {\n\treturn Option{}\n}\n\ntype MiddlewareBuilder struct{}\n\nfunc (m *MiddlewareBuilder) Build(ctx context.Context) {\n\tfmt.Println(\"Building middleware for function:\", funcName)\n\t// Add middleware logic here\n}\n\ntype endpoint struct{}\n\nfunc main() {\n\tmwb := &MiddlewareBuilder{}\n\tWithMiddlewareBuilder(mwb, \"exampleFunc\")\n\tmwb.Build(context.Background())\n}\n```"]}, "kitex-server/option.go-WithExitWaitTime": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithExitWaitTime(timeout time.Duration) Option {\n# Natural Language Annotations: // WithExitWaitTime sets the wait duration for graceful shutdown.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithExitWaitTime(timeout time.Duration) Option {\n    return func(c *Context) {\n        c.withExitWaitTime = timeout\n    }\n}\n```", "```python\nimport time\nfrom typing import Optional\n\nclass Process:\n    def __init__(self):\n        self._process = None\n\n    def WithExitWaitTime(self, timeout: int) -> Optional[int]:\n        \"\"\"\n        Sets the wait duration for graceful shutdown.\n        \n        Args:\n        timeout (time.Duration): The duration to wait before exiting.\n        \n        Returns:\n        int: The return code of the process.\n        \"\"\"\n        # Set the timeout for the process\n        self._process = self.run_process()\n        time.sleep(timeout)\n        # Return the return code of the process\n        return self._process.returncode\n\n    def run_process(self):\n        # Simulate a process\n        return self\n```", "```python\nfrom typing import Optional\n\nclass Server:\n    def __init__(self):\n        self.exit_wait_time = None\n\n    def with_exit_wait_time(self, timeout: int) -> Optional[int]:\n        \"\"\"\n        Sets the wait duration for graceful shutdown.\n        \n        Args:\n        timeout (int): The duration to wait before shutting down the server.\n        \n        Returns:\n        int: The set timeout value or None if the timeout is invalid.\n        \"\"\"\n        if timeout < 0:\n            return None\n        self.exit_wait_time = timeout\n        return self.exit_wait_time\n```"]}, "kitex-server/option.go-WithMaxConnIdleTime": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithMaxConnIdleTime(timeout time.Duration) Option {\n# Natural Language Annotations: // WithMaxConnIdleTime sets the max idle time on connection from clients.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass ServerConfig:\n    def __init__(self):\n        self.max_conn_idle_time = None\n\n    def with_max_conn_idle_time(self, timeout: int) -> Optional[int]:\n        self.max_conn_idle_time = timeout\n        return self.max_conn_idle_time\n```", "```python\nfrom typing import Optional\n\nclass Connection:\n    def __init__(self, max_conn_idle_time: int):\n        self.max_conn_idle_time = max_conn_idle_time\n\ndef with_max_conn_idle_time(timeout: int) -> Optional['Connection']:\n    return Connection(timeout)\n```", "```python\nfrom typing import Optional\n\nclass Connection:\n    def __init__(self, max_conn_idle_time: int):\n        self.max_conn_idle_time = max_conn_idle_time\n        self.last_activity_time = None\n\n    def update_last_activity(self):\n        self.last_activity_time = time.time()\n\n    @classmethod\n    def with_max_conn_idle_time(cls, timeout: int) -> Optional['Connection']:\n        return cls(timeout)\n\ndef get_connection(max_conn_idle_time: int) -> Optional[Connection]:\n    return Connection.with_max_conn_idle_time(max_conn_idle_time)\n```"]}, "kitex-server/option.go-WithPayloadCodec": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithPayloadCodec(c remote.PayloadCodec) Option {\n# Natural Language Annotations: // WithPayloadCodec to set a payloadCodec that handle other payload which not support by kitex\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass PayloadCodec:\n    def encode(self, payload: bytes) -> bytes:\n        raise NotImplementedError\n\n    def decode(self, data: bytes) -> bytes:\n        raise NotImplementedError\n\nclass KitexPayloadCodec:\n    def __init__(self, payload_codec: PayloadCodec):\n        self.payload_codec = payload_codec\n\ndef with_payload_codec(payload_codec: PayloadCodec) -> Optional[KitexPayloadCodec]:\n    return KitexPayloadCodec(payload_codec)\n```", "```python\nfrom typing import Optional\n\nclass PayloadCodec:\n    def encode(self, payload: any) -> any:\n        pass\n\n    def decode(self, data: any) -> any:\n        pass\n\nclass RemotePayloadCodec(PayloadCodec):\n    def __init__(self, codec: PayloadCodec):\n        self.codec = codec\n\n    def encode(self, payload: any) -> any:\n        if isinstance(payload, str):\n            return self.codec.encode(payload)\n        else:\n            return payload\n\n    def decode(self, data: any) -> any:\n        if isinstance(data, str):\n            return self.codec.decode(data)\n        else:\n            return data\n\ndef with_payload_codec(codec: PayloadCodec) -> Optional[PayloadCodec]:\n    return RemotePayloadCodec(codec)\n```", "```typescript\ninterface RemotePayloadCodec {\n  encode(data: any): Uint8Array;\n  decode(data: Uint8Array): any;\n}\n\nclass Option<T> {\n  private value: T | null;\n\n  constructor(value: T | null) {\n    this.value = value;\n  }\n\n  isSome(): boolean {\n    return this.value !== null;\n  }\n\n  get(): T {\n    if (!this.isSome()) {\n      throw new Error(\"Option is empty\");\n    }\n    return this.value;\n  }\n}\n\nclass PayloadCodec {\n  encode(data: any): Uint8Array {\n    // default implementation\n    return new TextEncoder().encode(JSON.stringify(data));\n  }\n\n  decode(data: Uint8Array): any {\n    // default implementation\n    return JSON.parse(new TextDecoder().decode(data));\n  }\n}\n\nclass CustomPayloadCodec implements RemotePayloadCodec {\n  encode(data: any): Uint8Array {\n    // custom implementation for encoding\n    return new TextEncoder().encode(JSON.stringify(data));\n  }\n\n  decode(data: Uint8Array): any {\n    // custom implementation for decoding\n    return JSON.parse(new TextDecoder().decode(data));\n  }\n}\n\nfunction WithPayloadCodec(c: RemotePayloadCodec): Option<RemotePayloadCodec> {\n  return new Option(c);\n}\n\n// example usage\nconst customCodec = new CustomPayloadCodec();\nconst option = WithPayloadCodec(customCodec);\nif (option.isSome()) {\n  console.log(option.get().encode({ foo: \"bar\" });\n}\n```"]}, "kitex-server/option.go-WithGRPCInitialWindowSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialWindowSize returns a Option that sets window size for stream.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the InitialWindowSize ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\nfunction WithGRPCInitialWindowSize(s: number): number | null {\n    if (s < 64 * 1024) return null;\n    return s;\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"google.golang.org/grpc\"\n)\n\ntype Option struct{}\n\nfunc WithGRPCInitialWindowSize(s uint32) Option {\n\tif s < 64*1024 {\n\t\treturn Option{}\n\t}\n\treturn Option{}\n}\n\nfunc main() {\n\t// Example usage\n\tconn, err := grpc.Dial(\"localhost:50051\", grpc.WithInitialWindowSize(100000))\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer conn.Close()\n\n\t// Use the connection\n\tclient := NewMyServiceClient(conn)\n\t// ...\n}\n```", "```python\ndef with_grpc_initial_window_size(s: int) -> int:\n    \"\"\"\n    Returns a value that sets window size for stream.\n    \n    The lower bound for window size is 64K and any value smaller than that will be ignored.\n    It corresponds to the InitialWindowSize ServerOption of gRPC.\n    \n    Args:\n        s (int): The initial window size.\n    \n    Returns:\n        int: The initial window size if it's greater than or equal to 64K, otherwise returns 0.\n    \"\"\"\n    if s < 64 * 1024:\n        return 0\n    else:\n        return s\n```"]}, "kitex-server/option.go-WithGRPCInitialConnWindowSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCInitialConnWindowSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCInitialConnWindowSize returns an Option that sets window size for a connection.\n// The lower bound for window size is 64K and any value smaller than that will be ignored.\n// It corresponds to the InitialConnWindowSize ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\ndef with_grpc_initial_conn_window_size(s: int) -> Optional[int]:\n    if s < 64 * 1024:\n        return None\n    return s\n```", "```go\nfunc WithGRPCInitialConnWindowSize(s uint32) *Option {\n    if s < 64*1024 {\n        return nil\n    }\n    return &Option{InitialConnWindowSize: s}\n}\n\ntype Option struct {\n    InitialConnWindowSize uint32\n}\n```", "```typescript\nfunction withGRPCInitialConnWindowSize(s: number): { initialConnWindowSize: number } | null {\n    if (s < 64 * 1024) {\n        return null;\n    }\n    return { initialConnWindowSize: s };\n}\n```"]}, "kitex-server/option.go-WithGRPCKeepaliveParams": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveParams(kp grpc.ServerKeepalive) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveParams returns an Option that sets keepalive and max-age parameters for the server.\n// It corresponds to the KeepaliveParams ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\nclass ServerOption:\n    def __init__(self):\n        self.keepalive = None\n        self.max_age = None\n\ndef with_grpc_keepalive_params(kp: Optional[ServerOption]) -> Optional[ServerOption]:\n    \"\"\"\n    Returns an Option that sets keepalive and max-age parameters for the server.\n    It corresponds to the KeepaliveParams ServerOption of gRPC.\n    \"\"\"\n    return kp\n```", "```python\nfrom grpc import ServerOptions, KeepaliveParams\n\ndef with_grpc_keepalive_params(kp: KeepaliveParams) -> ServerOptions:\n    \"\"\"\n    Returns an Option that sets keepalive and max-age parameters for the server.\n    \n    It corresponds to the KeepaliveParams ServerOption of gRPC.\n    \n    Args:\n        kp (KeepaliveParams): An instance of KeepaliveParams\n    \n    Returns:\n        ServerOptions: An instance of ServerOptions with keepalive and max-age parameters set\n    \"\"\"\n    return ServerOptions(initial_bind_time=0, keepalive_time=0, keepalive_timeout=0, keepalive_permit_without_calls=kp.keepalive_permit_without_calls, \n                       max_pending=0, max_requests=0, max_response_header_size=0, max_recieve_size=0, keepalive_max_pings_without_data=kp.keepalive_max_pings_without_data, \n                       keepalive_time_ms=kp.keepalive_time_ms, keepalive_timeout_ms=kp.keepalive_timeout_ms, \n                       max_connection_idle=0, max_connection_age=0, max_connection_ageGrace=0, \n                       max_concurrent_streams=0, max_inbound_metadata=0, max_outbound_metadata=0, \n                       initial_connection_idle=0, initial_connection_window=0, initial_connection_max_pings_without_data=0, \n                       initial_connection_keepalive_time=0, initial_connection_keepalive_timeout=0, \n                       initial_connection_max_age=0, initial_connection_age_grace=0, \n                       http2_max_pings_without_data=0, http2_max_ping_timeout=0, http2_max_header_list_size=0, http2_max_frame_size=0, \n                       http2_max_concurrent_pushes=0, http2_max_header_list_size=0, http2_max_header_size=0, \n                       initial_stream_window=0, initial_connection_window_per_stream=0, \n                       keepalive_min_time=0, keepalive_max_time=0, \n                       keepalive_timeout=0, keepalive_permit_without_calls=kp.keepalive_permit_without_calls, \n                       keepalive_max_pings_without_data=kp.keepalive_max_pings_without_data, \n                       keepalive_time_ms=kp.keepalive_time_ms, keepalive_timeout_ms=kp.keepalive_timeout_ms, \n                       max_connection_idle=0, max_connection_age=0, max_connection_age_grace=0, \n                       max_concurrent_streams=0, max_inbound_metadata=0, max_outbound_metadata=0)\n```", "```python\nfrom grpc import Server, ServerOptions\n\ndef with_grpc_keepalive_params(max_age: int, time: int, timeout: int, permit_without_calls: bool) -> ServerOptions:\n    \"\"\"\n    Returns a ServerOptions object with keepalive and max-age parameters set.\n    \n    Args:\n        max_age (int): The maximum time a connection may remain idle before it is considered dead.\n        time (int): The time in seconds that the server will wait before sending a keepalive ping.\n        timeout (int): The time in seconds that the server will wait for a response to a keepalive ping.\n        permit_without_calls (bool): Whether to send keepalive pings even if there are no active calls.\n        \n    Returns:\n        ServerOptions: A ServerOptions object with keepalive and max-age parameters set.\n    \"\"\"\n    return ServerOptions(\n        keepalive_time=time,\n        keepalive_timeout=timeout,\n        keepalive_permit_without_calls=permit_without_calls,\n        keepalive_max_session_lifetime=max_age\n    )\n```"]}, "kitex-server/option.go-WithGRPCKeepaliveEnforcementPolicy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCKeepaliveEnforcementPolicy(kep grpc.EnforcementPolicy) Option {\n# Natural Language Annotations: // WithGRPCKeepaliveEnforcementPolicy returns an Option that sets keepalive enforcement policy for the server.\n// It corresponds to the KeepaliveEnforcementPolicy ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\n\ndef with_grpc_keepalive_enforcement_policy(kep: object) -> Optional[object]:\n    \"\"\"\n    WithGRPCKeepaliveEnforcementPolicy returns an Option that sets keepalive enforcement policy for the server.\n    It corresponds to the KeepaliveEnforcementPolicy ServerOption of gRPC.\n    \n    Args:\n        kep (object): grpc.EnforcementPolicy\n    \n    Returns:\n        Optional[object]: \n    \"\"\"\n    return kep\n```", "```typescript\ninterface grpc {\n  ServerOption: {\n    keepaliveEnforcementPolicy: (kep: EnforcementPolicy) => Option;\n  };\n}\n\ninterface EnforcementPolicy {\n  // add properties as needed\n}\n\ninterface Option {\n  // add properties as needed\n}\n\nfunction WithGRPCKeepaliveEnforcementPolicy(kep: EnforcementPolicy): Option {\n  return grpc.ServerOption.keepaliveEnforcementPolicy(kep);\n}\n```", "```go\nfunc WithGRPCKeepaliveEnforcementPolicy(kep grpc.EnforcementPolicy) grpc.ServerOption {\n    return func(s *grpc.Server) error {\n        s.SetKeepaliveEnforcementPolicy(kep)\n        return nil\n    }\n}\n```"]}, "kitex-server/option.go-WithGRPCMaxConcurrentStreams": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxConcurrentStreams(n uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxConcurrentStreams returns an Option that will apply a limit on the number\n// of concurrent streams to each ServerTransport.\n// It corresponds to the MaxConcurrentStreams ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"google.golang.org/grpc\"\n)\n\ntype WithGRPCMaxConcurrentStreams uint32\n\nfunc WithGRPCMaxConcurrentStreams(n uint32) grpc.DialOption {\n\treturn grpc.WithMaxConcurrentStreams(n)\n}\n```", "```go\npackage grpc\n\nimport (\n    \"context\"\n    \"google.golang.org/grpc\"\n)\n\nfunc WithGRPCMaxConcurrentStreams(n uint32) func(*grpc.Server) grpc.Server {\n    return func(s *grpc.Server) grpc.Server {\n        return s.WithMaxConcurrentStreams(n)\n    }\n}\n```", "```python\nfrom typing import Optional\n\ndef with_grpc_max_concurrent_streams(n: int) -> Optional[int]:\n    return n\n```\n\n```java\nimport java.util.Optional;\n\npublic class WithGRPCMaxConcurrentStreams {\n    public static Optional<Integer> withGRPCMaxConcurrentStreams(int n) {\n        return Optional.of(n);\n    }\n}\n```\n\n```javascript\nfunction withGRPCMaxConcurrentStreams(n: number): number | null {\n    return n;\n}\n```"]}, "kitex-server/option.go-WithGRPCMaxHeaderListSize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func WithGRPCMaxHeaderListSize(s uint32) Option {\n# Natural Language Annotations: // WithGRPCMaxHeaderListSize returns a ServerOption that sets the max (uncompressed) size\n// of header list that the server is prepared to accept.\n// It corresponds to the MaxHeaderListSize ServerOption of gRPC.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc WithGRPCMaxHeaderListSize(s uint32) ServerOption {\n    return func(srv *Server) error {\n        srv.maxHeaderListSize = s\n        return nil\n    }\n}\n```", "```go\nfunc WithGRPCMaxHeaderListSize(s uint32) grpc.ServerOption {\n    return grpc.MaxHeaderListSize(s)\n}\n```", "```go\ntype ServerOption func(*grpc.Server)\n\nfunc WithGRPCMaxHeaderListSize(s uint32) ServerOption {\n    return func(server *grpc.Server) {\n        server.MaxHeaderListSize = int(s)\n    }\n}\n```"]}, "kitex-server/genericserver/server.go-NewServerWithServiceInfo": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewServerWithServiceInfo(handler generic.Service, g generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n# Natural Language Annotations: // NewServerWithServiceInfo creates a generic server with the given handler, serviceInfo and options.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewServerWithServiceInfo(handler generic.Service, generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n    return server.NewServer(handler, generic.Generic{}, svcInfo, opts...)\n}\n```", "```go\nfunc NewServerWithServiceInfo(handler generic.Service, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n    return server.NewServer(handler, svcInfo, opts...)\n}\n```", "```go\nfunc NewServerWithServiceInfo(handler generic.Service, g generic.Generic, svcInfo *serviceinfo.ServiceInfo, opts ...server.Option) server.Server {\n    return server.NewServer(handler, g, svcInfo, opts...)\n}\n```"]}, "weaver-validate.go-validateRegistrations": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func validateRegistrations(regs []*codegen.Registration) error {\n# Natural Language Annotations: // validateRegistrations validates the provided registrations, returning an\n// diagnostic error if they are invalid. Note that some validation is performed\n// by 'weaver generate', but because users can run a Service Weaver app after\n// forgetting to run 'weaver generate', some checks have to be done at runtime.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef validateRegistrations(regs):\n    \"\"\"\n    Validates the provided registrations, returning an error if they are invalid.\n\n    Args:\n        regs (list[codegen.Registration]): A list of registrations to validate.\n\n    Returns:\n        error: A diagnostic error if the registrations are invalid, otherwise None.\n    \"\"\"\n    for reg in regs:\n        if not reg.name or not reg.description:\n            return \"Registration name and description are required\"\n        if not reg.tags:\n            return \"Registration tags are required\"\n        if not reg.service:\n            return \"Service is required\"\n        if not reg.version:\n            return \"Version is required\"\n        if not reg.dependencies:\n            return \"Dependencies are required\"\n    return None\n```", "```go\npackage weaver\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n)\n\nfunc validateRegistrations(regs []*Registration) error {\n\tfor _, reg := range regs {\n\t\tif err := validateRegistration(reg); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc validateRegistration(reg *Registration) error {\n\tif reg == nil {\n\t\treturn errors.New(\"registration is nil\")\n\t}\n\n\t// Check if the registration has a valid name\n\tif reg.Name == \"\" {\n\t\treturn errors.New(\"registration name is empty\")\n\t}\n\n\t// Check if the registration has a valid namespace\n\tif reg.Namespace == \"\" {\n\t\treturn errors.New(\"registration namespace is empty\")\n\t}\n\n\t// Check if the registration has a valid URL\n\tif !regexp.MustCompile(`^https?://`).MatchString(reg.URL) {\n\t\treturn fmt.Errorf(\"invalid URL: %s\", reg.URL)\n\t}\n\n\t// Check if the registration has a valid handler\n\tif reg.Handler == nil {\n\t\treturn errors.New(\"registration handler is nil\")\n\t}\n\n\t// Check if the registration has a valid method\n\tif reg.Method != \"GET\" && reg.Method != \"POST\" && reg.Method != \"PUT\" && reg.Method != \"DELETE\" {\n\t\treturn fmt.Errorf(\"invalid method: %s\", reg.Method)\n\t}\n\n\treturn nil\n}\n```", "```python\ndef validateRegistrations(regs):\n    \"\"\"\n    Validates the provided registrations, returning a diagnostic error if they are invalid.\n    \n    :param regs: A list of Registration objects\n    :return: An error if the registrations are invalid, None otherwise\n    \"\"\"\n    for reg in regs:\n        if not reg.name:\n            return \"Registration name is required\"\n        if not reg.service:\n            return \"Service name is required\"\n        if not reg.handler:\n            return \"Handler function is required\"\n        if not reg.methods:\n            return \"At least one method must be specified\"\n        for method in reg.methods:\n            if not method.name:\n                return f\"Method name is required for {method.handler}\"\n            if method.input_type and method.output_type:\n                return f\"Method cannot have both input and output types for {method.handler}\"\n    return None\n```"]}, "weaver-sim/generators.go-Range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Range(low, high int) Generator[int] {\n# Natural Language Annotations: // Range returns a [Generator] that returns integers equiprobably in the range\n// [low, high). Range panics if low >= high.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport random\n\ndef range(low, high):\n    if low >= high:\n        raise ValueError(\"low must be less than high\")\n    while True:\n        yield random.randint(low, high - 1)\n```", "```python\nimport random\n\ndef range(low, high):\n    \"\"\"\n    Returns a generator that returns integers equiprobably in the range [low, high).\n    Panics if low >= high.\n    \"\"\"\n    if low >= high:\n        raise ValueError(\"low must be less than high\")\n    while True:\n        yield random.randint(low, high - 1)\n```", "```python\nimport random\n\ndef range(low, high):\n    \"\"\"\n    Returns a generator that returns integers equiprobably in the range [low, high).\n    \n    Args:\n        low (int): The lower bound of the range (inclusive).\n        high (int): The upper bound of the range (exclusive).\n    \n    Yields:\n        int: A random integer in the range [low, high).\n    \n    Raises:\n        ValueError: If low >= high.\n    \"\"\"\n    if low >= high:\n        raise ValueError(\"low >= high\")\n    \n    while low < high:\n        yield random.randint(low, high - 1)\n```"]}, "weaver-sim/generators.go-String": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func String() Generator[string] {\n# Natural Language Annotations: // Strings\n// String returns a [Generator] that returns moderately sized readable strings,\n// with a bias towards smaller strings.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport random\nimport string\n\ndef string():\n    \"\"\"\n    Returns a generator that returns moderately sized readable strings,\n    with a bias towards smaller strings.\n    \"\"\"\n    while True:\n        length = random.randint(1, 20)\n        if length < 5:\n            yield ''.join(random.choice(string.ascii_lowercase) for _ in range(length))\n        elif length < 10:\n            yield ''.join(random.choice(string.ascii_lowercase + ' ') for _ in range(length))\n        else:\n            yield ''.join(random.choice(string.ascii_lowercase + ' ') for _ in range(length // 2)) + ''.join(random.choice(string.ascii_lowercase) for _ in range(length // 2))\n```", "```python\nimport random\nimport string\n\ndef string():\n    \"\"\"\n    Returns a generator that generates moderately sized readable strings,\n    with a bias towards smaller strings.\n    \"\"\"\n    # Define the possible characters\n    chars = string.ascii_letters + string.digits + string.punctuation\n    \n    # Define the possible string lengths\n    lengths = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \n    while True:\n        # Randomly select a string length\n        length = random.choice(lengths)\n        \n        # Generate the string\n        s = ''.join(random.choice(chars) for _ in range(length))\n        \n        # Yield the string\n        yield s\n```", "```python\nimport random\nimport string\n\ndef string():\n    \"\"\"\n    Returns a generator that yields moderately sized readable strings, \n    with a bias towards smaller strings.\n    \"\"\"\n    words = [\"the\", \"be\", \"to\", \"of\", \"and\", \"a\", \"in\", \"that\", \"is\", \"for\", \"it\", \"with\", \"as\", \"on\", \"at\", \"by\", \"from\"]\n    punctuation = ['.', ',', '?', '!', ';', ':']\n    while True:\n        word = random.choice(words)\n        length = random.randint(1, 10)\n        sentence = ' '.join([word] * length)\n        if random.random() < 0.5:  # 50% chance to add a punctuation\n            sentence += random.choice(punctuation)\n        yield sentence\n```"]}, "weaver-sim/generators.go-OneOf": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OneOf[T any](xs ...T) Generator[T] {\n# Natural Language Annotations: // Combinators\n// OneOf returns a [Generator] that returns one of the provided values\n// equiprobably. OneOf panics if no values are provided.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport random\n\ndef one_of(*args):\n    \"\"\"\n    Returns a generator that returns one of the provided values equiprobably.\n    Panics if no values are provided.\n    \"\"\"\n    if not args:\n        raise ValueError(\"At least one value is required\")\n    return (random.choice(args) for _ in range(2**63))  # We use a large number to represent infinity\n```", "```python\nimport random\n\ndef one_of(*xs):\n    \"\"\"\n    Returns a generator that returns one of the provided values equiprobably.\n    Raises ValueError if no values are provided.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"At least one value is required\")\n    return (random.choice(xs) for _ in range(100000))  # using a large number to avoid repeating the same value\n```", "```python\nimport random\nfrom typing import Generator, Any\n\ndef one_of(*xs: Any) -> Generator[Any, None, None]:\n    if not xs:\n        raise ValueError(\"OneOf panics if no values are provided.\")\n    while True:\n        yield random.choice(xs)\n```"]}, "weaver-sim/generators.go-Weight": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Weight[T any](choices []Weighted[T]) Generator[T] {\n# Natural Language Annotations: // Weight returns a [Generator] that generates values using the provided\n// generators. A generator is chosen with probability proportional to its\n// weight. For example, given the following choices:\n//\n//   - Weighted{1.0, OneOf(\"a\")}\n//   - Weighted{2.0, OneOf(\"b\")}\n//\n// Weight returns \"b\" twice as often as it returns \"a\". Note that the provided\n// weights do not have to sum to 1.\n//\n// Weight panics if no choices are provided, if any weight is negative, or if\n// the sum of all weight is 0.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"sync\"\n)\n\ntype Weighted[T any] struct {\n\tweight float64\n\tgenerator func() T\n}\n\nfunc Weight[T any](choices []Weighted[T]) func() T {\n\tif len(choices) == 0 {\n\t\tpanic(\"no choices provided\")\n\t}\n\tvar totalWeight float64\n\tfor _, choice := range choices {\n\t\tif choice.weight < 0 {\n\t\t\tpanic(\"weight cannot be negative\")\n\t\t}\n\t\ttotalWeight += choice.weight\n\t}\n\tif totalWeight == 0 {\n\t\tpanic(\"sum of weights is 0\")\n\t}\n\n\trand.Seed(0)\n\tvar mu sync.Mutex\n\tvar lock sync.Mutex\n\treturn func() T {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\trandNum := rand.Float64() * totalWeight\n\t\tvar sum float64\n\t\tfor _, choice := range choices {\n\t\t\tsum += choice.weight\n\t\t\tif randNum <= sum {\n\t\t\t\treturn choice.generator()\n\t\t\t}\n\t\t}\n\t\tpanic(\"unreachable\")\n\t}\n}\n\nfunc OneOf[T any](choices ...T) func() T {\n\treturn func() T {\n\t\treturn choices[rand.Intn(len(choices))]\n\t}\n}\n\nfunc main() {\n\tweightedA := Weighted{1.0, func() string { return \"a\" }}\n\tweightedB := Weighted{2.0, func() string { return \"b\" }}\n\tweighted := Weight[string]([]Weighted[string]{weightedA, weightedB})\n\tfor i := 0; i < 10; i++ {\n\t\tprintln(weighted())\n\t}\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Weighted[T any] struct {\n\tweight float64\n\tgenerator func() T\n}\n\nfunc Weight[T any](choices []Weighted[T]) func() T {\n\tif len(choices) == 0 {\n\t\tpanic(\"no choices provided\")\n\t}\n\tvar totalWeight float64\n\tfor _, choice := range choices {\n\t\tif choice.weight < 0 {\n\t\t\tpanic(\"weight cannot be negative\")\n\t\t}\n\t\ttotalWeight += choice.weight\n\t}\n\tif totalWeight == 0 {\n\t\tpanic(\"weights sum to 0\")\n\t}\n\trand.Seed(time.Now().UnixNano())\n\treturn func() T {\n\t\trandNum := rand.Float64() * totalWeight\n\t\tfor _, choice := range choices {\n\t\t\trandNum -= choice.weight\n\t\t\tif randNum <= 0 {\n\t\t\t\treturn choice.generator()\n\t\t\t}\n\t\t}\n\t\tpanic(\"impossible to reach this point\")\n\t}\n}\n\nfunc OneOf[T any](values []T) func() T {\n\treturn func() T {\n\t\treturn values[rand.Intn(len(values))]\n\t}\n}\n\nfunc main() {\n\tchoices := []Weighted[string]{\n\t\t{weight: 1.0, generator: OneOf([]string{\"a\", \"b\"})},\n\t\t{weight: 2.0, generator: OneOf([]string{\"a\", \"b\"})},\n\t}\n\tg := Weight[string](choices)\n\tfmt.Println(g()) // prints \"a\" or \"b\"\n\tfmt.Println(g()) // prints \"a\" or \"b\"\n\tfmt.Println(g()) // prints \"a\" or \"b\"\n}\n```", "```go\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"time\"\n)\n\nfunc Weight[T any](choices []Weighted[T]) Generator[T] {\n\tif len(choices) == 0 {\n\t\tpanic(\"no choices provided\")\n\t}\n\tvar totalWeight float64\n\tfor _, choice := range choices {\n\t\tif choice.Weight < 0 {\n\t\t\tpanic(\"weight cannot be negative\")\n\t\t}\n\t\ttotalWeight += choice.Weight\n\t}\n\tif totalWeight == 0 {\n\t\tpanic(\"sum of weights is 0\")\n\t}\n\tr := rand.New(rand.NewSource(time.Now().UnixNano()))\n\treturn func() T {\n\t\trandNum := r.Float64() * totalWeight\n\t\tfor _, choice := range choices {\n\t\t\tif randNum <= choice.Weight {\n\t\t\t\treturn choice.Value()\n\t\t\t}\n\t\t\trandNum -= choice.Weight\n\t\t}\n\t\tpanic(\"unreachable\")\n\t}\n}\n\ntype Weighted[T any] struct {\n\tWeight float64\n\tValue  func() T\n}\n\ntype Generator[T any] func() T\n```"]}, "weaver-sim/rand.go-pick": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func pick[T any](r *rand.Rand, xs []T) T {\n# Natural Language Annotations: // pick returns a randomly selected element from the provided slice. pick\n// panics if the provided slice is empty.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc pick[T any](r *rand.Rand, xs []T) T {\n    if len(xs) == 0 {\n        panic(\"cannot pick from an empty slice\")\n    }\n    return xs[r.Intn(len(xs))]\n}\n```", "```go\nfunc pick[T any](r *rand.Rand, xs []T) T {\n    if len(xs) == 0 {\n        panic(\"cannot pick from an empty slice\")\n    }\n    return xs[r.Intn(len(xs))]\n}\n```", "```python\nimport random\n\ndef pick(r, xs):\n    \"\"\"\n    Returns a randomly selected element from the provided list.\n    \n    Args:\n        r: A random number generator.\n        xs: The list from which to select a random element.\n    \n    Returns:\n        A randomly selected element from the provided list.\n    \n    Raises:\n        ValueError: If the provided list is empty.\n    \"\"\"\n    if not xs:\n        raise ValueError(\"Cannot pick from an empty list\")\n    return random.choice(xs)\n```"]}, "weaver-sim/rand.go-remove": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (i *ints) remove(x int) {\n# Natural Language Annotations: // remove removes the provided element from the set. remove is a noop if the\n// provided element is not in the set.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef remove(i, x):\n    if x in i:\n        i.remove(x)\n```", "```python\ndef remove(i, x):\n    if x in i:\n        i.remove(x)\n```", "```python\ndef remove(i, x):\n    if x in i:\n        i.remove(x)\n```"]}, "weaver-runtime/config.go-ParseConfig": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseConfig(file string, input string, sectionValidator func(string, string) error) (*protos.AppConfig, error) {\n# Natural Language Annotations: // ParseConfig parses the specified configuration input, which should\n// hold a set of sections in TOML format from the specified file.\n// The section corresponding to the common Service Weaver application\n// configuration is parsed and returned as a *AppConfig.\n//\n// sectionValidator(key, val) is used to validate every section config entry.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/BurntSushi/toml\"\n)\n\ntype AppConfig struct {\n\t// Add fields for your config here\n}\n\nfunc ParseConfig(file string, input string, sectionValidator func(key string, val string) error) (*AppConfig, error) {\n\t// Read the file\n\tdata, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the TOML\n\tvar config map[string]map[string]interface{}\n\t_, err = toml.Decode(string(data), &config)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Find the service weaver section\n\tserviceWeaverSection, ok := config[\"service-weaver\"]\n\tif !ok {\n\t\treturn nil, fmt.Errorf(\"service-weaver section not found in config\")\n\t}\n\n\t// Create a new AppConfig\n\tappConfig := &AppConfig{}\n\n\t// Iterate over the service weaver section\n\tfor key, val := range serviceWeaverSection {\n\t\t// Validate the key and value using the section validator\n\t\tif err := sectionValidator(key, val.(string)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\t// Add the validated key and value to the app config\n\t\tswitch key {\n\t\tcase \"key1\":\n\t\t\tappConfig.Key1 = val.(string)\n\t\tcase \"key2\":\n\t\t\tappConfig.Key2 = val.(string)\n\t\t// Add more cases for other keys as needed\n\t\tdefault:\n\t\t\t// If the key is not handled, log a warning\n\t\t\tlog.Printf(\"Unknown key '%s' in service-weaver section\", key)\n\t\t}\n\t}\n\n\treturn appConfig, nil\n}\n```", "```go\npackage protos\n\nimport (\n\t\"encoding/toml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n)\n\ntype AppConfig struct {\n\t// Add fields to AppConfig as needed\n}\n\nfunc ParseConfig(file string, input string, sectionValidator func(string, string) error) (*AppConfig, error) {\n\t// Create a new AppConfig instance\n\tappConfig := &AppConfig{}\n\n\t// Check if input is a file path\n\tif _, err := os.Stat(input); os.IsNotExist(err) {\n\t\t// If input is a string, use it as the TOML string\n\t\ttomlStr := input\n\t} else {\n\t\t// If input is a file path, read the file\n\t\tdata, err := ioutil.ReadFile(input)\n\t\tif err != nil {\n\t\t\treturn nil, fmt.Errorf(\"failed to read file: %w\", err)\n\t\t}\n\t\ttomlStr := string(data)\n\t}\n\n\t// Unmarshal TOML string to AppConfig\n\tif err := toml.Unmarshal([]byte(tomlStr), appConfig); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal TOML: %w\", err)\n\t}\n\n\t// Iterate over each section in the TOML\n\tfor section, values := range appConfig {\n\t\t// Validate each key-value pair in the section\n\t\tfor key, val := range values {\n\t\t\tif err := sectionValidator(section, key); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"section %q, key %q failed validation: %w\", section, key, err)\n\t\t\t}\n\t\t\t// Validate the value\n\t\t\tif err := sectionValidator(section, val); err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"section %q, key %q failed validation: %w\", section, key, err)\n\t\t\t}\n\t\t}\n\t}\n\n\treturn appConfig, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/toml\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\n// AppConfig represents the common Service Weaver application configuration.\ntype AppConfig struct {\n\t// Add your fields here as needed\n}\n\nfunc ParseConfig(file string, input string, sectionValidator func(string, string) error) (*AppConfig, error) {\n\t// Create a new AppConfig instance\n\tconfig := &AppConfig{}\n\n\t// Unmarshal the TOML input into the AppConfig instance\n\tif err := toml.Unmarshal([]byte(input), config); err != nil {\n\t\treturn nil, fmt.Errorf(\"failed to unmarshal TOML input: %w\", err)\n\t}\n\n\t// Validate each section in the config\n\tif err := validateConfig(config, sectionValidator); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn config, nil\n}\n\nfunc validateConfig(config interface{}, sectionValidator func(string, string) error) error {\n\tswitch config := config.(type) {\n\tcase map[string]interface{}:\n\t\tfor key, value := range config {\n\t\t\tif err := sectionValidator(key, fmt.Sprintf(\"%v\", value)); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif valueMap, ok := value.(map[string]interface{}); ok {\n\t\t\t\tif err := validateConfig(valueMap, sectionValidator); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tdefault:\n\t\treturn fmt.Errorf(\"unexpected config type: %T\", config)\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\t// Example usage:\n\tfilePath := \"path/to/config.toml\"\n\tinput, err := ioutil.ReadFile(filePath)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tconfig, err := ParseConfig(filePath, string(input), func(key, value string) error {\n\t\t// Implement your section validation logic here\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(config)\n}\n```"]}, "weaver-runtime/traces/db.go-OpenDB": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OpenDB(ctx context.Context, fname string) (*DB, error) {\n# Natural Language Annotations: // OpenDB opens the trace database persisted in the provided file. If the\n// file doesn't exist, this call creates it.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/samber/lo\"\n\t\"github.com/timescale/pgx/v4\"\n)\n\ntype DB struct {\n\t*pgx.Conn\n}\n\nfunc OpenDB(ctx context.Context, fname string) (*DB, error) {\n\t// Generate a unique database name if the file name is empty\n\tif fname == \"\" {\n\t\tfname = uuid.NewString() + \".db\"\n\t}\n\n\t// Check if the file exists, if not create it\n\tif _, err := os.Stat(fname); os.IsNotExist(err) {\n\t\t_, err := os.Create(fname)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Connect to the database\n\tconn, err := pgx.Connect(ctx, \"user=postgres dbname=\" + fname + \" sslmode=disable\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &DB{Conn: conn}, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/opentracing/opentracing-go\"\n\t\"github.com/opentracing/opentracing-go/log\"\n)\n\ntype DB struct {\n\tTracer opentracing.Tracer\n}\n\nfunc OpenDB(ctx context.Context, fname string) (*DB, error) {\n\t// Create a new tracer if the file doesn't exist\n\tif _, err := os.Stat(fname); os.IsNotExist(err) {\n\t\t// Create a new tracer\n\t\ttracer, _, err := NewTracer()\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t// Save the tracer to the file\n\t\terr = SaveTracer(tracer, fname)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t} else {\n\t\t// Load the existing tracer from the file\n\t\ttracer, err := LoadTracer(fname)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Return the tracer as a DB object\n\treturn &DB{Tracer: tracer}, nil\n}\n\nfunc NewTracer() (opentracing.Tracer, io.Reader, error) {\n\t// Implementation of NewTracer function\n\treturn opentracing.GlobalTracer(), nil, nil\n}\n\nfunc SaveTracer(tracer opentracing.Tracer, fname string) error {\n\t// Implementation of SaveTracer function\n\treturn nil\n}\n\nfunc LoadTracer(fname string) (opentracing.Tracer, error) {\n\t// Implementation of LoadTracer function\n\treturn opentracing.GlobalTracer(), nil\n}\n```", "```go\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/uuid\"\n\t\"github.com/jmoiron/sqlx\"\n)\n\nfunc OpenDB(ctx context.Context, fname string) (*DB, error) {\n\tif fname == \"\" {\n\t\tfname = fmt.Sprintf(\"%s.db\", uuid.New().String())\n\t}\n\tdbDir := filepath.Dir(fname)\n\tif err := os.MkdirAll(dbDir, 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdb, err := sqlx.Connect(\"sqlite3\", fname)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &DB{db: db}, nil\n}\n\ntype DB struct {\n\tdb *sqlx.DB\n}\n```"]}, "weaver-runtime/traces/db.go-QueryTraces": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n# Natural Language Annotations: // QueryTraces returns the summaries of the traces that match the given\n// query arguments, namely:\n//   - That have been generated by the given application version.\n//   - That fit entirely in the given [startTime, endTime] time interval.\n//   - Whose duration is in the given [durationLower, durationUpper) range.\n//   - Who have an error status.\n//   - Who are in the most recent limit of trace spans.\n//\n// Any query argument that has a zero value (e.g., empty app or version,\n// zero endTime) is ignored, i.e., it matches all spans.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n    // Ignore any query arguments with zero value\n    if app == \"\" || version == \"\" || endTime.IsZero() || durationUpper <= 0 || limit <= 0 {\n        return d.QueryAllTraces(ctx, startTime, durationLower, onlyErrors, limit)\n    }\n\n    // Create a query filter for the application\n    var appFilter = fmt.Sprintf(\"app = '%s'\", app)\n\n    // Create a query filter for the application version\n    var versionFilter = fmt.Sprintf(\"version = '%s'\", version)\n\n    // Create a query filter for the time interval\n    var timeFilter = fmt.Sprintf(\"time >= '%s' AND time <= '%s'\", startTime.Format(time.RFC3339), endTime.Format(time.RFC3339))\n\n    // Create a query filter for the duration range\n    var durationFilter = fmt.Sprintf(\"duration >= %d AND duration < %d\", durationLower.Nanoseconds(), durationUpper.Nanoseconds())\n\n    // Create a query filter for the error status\n    var errorFilter = \"error = true\"\n\n    // Create the query string\n    query := fmt.Sprintf(\"%s AND %s AND %s AND %s AND %s\", appFilter, versionFilter, timeFilter, durationFilter, errorFilter)\n\n    // Execute the query and return the results\n    return d.QueryTracesBySQL(ctx, query, limit)\n}\n```", "```go\nfunc (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n    // Create a query that filters the traces based on the given arguments\n    query := \"SELECT * FROM traces WHERE 1=1\"\n\n    // Add filter for application name\n    if app != \"\" {\n        query += \" AND application_name = $1\"\n    }\n\n    // Add filter for application version\n    if version != \"\" {\n        query += \" AND application_version = $2\"\n    }\n\n    // Add filter for start time\n    if !startTime.IsZero() {\n        query += \" AND start_time >= $3\"\n    }\n\n    // Add filter for end time\n    if !endTime.IsZero() {\n        query += \" AND end_time <= $4\"\n    }\n\n    // Add filter for duration\n    if !durationLower.IsZero() {\n        query += \" AND duration >= $5\"\n    }\n    if !durationUpper.IsZero() {\n        query += \" AND duration < $6\"\n    }\n\n    // Add filter for error status\n    if onlyErrors {\n        query += \" AND error_status IS TRUE\"\n    }\n\n    // Add limit to the query\n    query += \" LIMIT $7\"\n\n    // Execute the query and fetch the results\n    rows, err := d.DB.QueryContext(ctx, query, app, version, startTime, endTime, durationLower, durationUpper, limit)\n    if err != nil {\n        return nil, err\n    }\n\n    // Create a slice to store the results\n    var traces []TraceSummary\n\n    // Scan the rows and append the results to the slice\n    for rows.Next() {\n        var trace TraceSummary\n        err := rows.Scan(&trace)\n        if err != nil {\n            return nil, err\n        }\n        traces = append(traces, trace)\n    }\n\n    // Close the rows\n    err = rows.Close()\n    if err != nil {\n        return nil, err\n    }\n\n    // Return the results\n    return traces, nil\n}\n```", "```sql\nfunc (d *DB) QueryTraces(ctx context.Context, app, version string, startTime, endTime time.Time, durationLower, durationUpper time.Duration, onlyErrors bool, limit int64) ([]TraceSummary, error) {\n    // Convert the input parameters to the correct types\n    app = strings.TrimSpace(app)\n    version = strings.TrimSpace(version)\n\n    // Construct the query conditions\n    var conditions []string\n    if app != \"\" {\n        conditions = append(conditions, fmt.Sprintf(\"app = '%s'\", app))\n    }\n    if version != \"\" {\n        conditions = append(conditions, fmt.Sprintf(\"version = '%s'\", version))\n    }\n    if !startTime.IsZero() {\n        conditions = append(conditions, fmt.Sprintf(\"start_time >= '%s'\", startTime.Format(time.RFC3339)))\n    }\n    if !endTime.IsZero() {\n        conditions = append(conditions, fmt.Sprintf(\"start_time <= '%s'\", endTime.Format(time.RFC3339)))\n    }\n    if durationLower > 0 {\n        conditions = append(conditions, fmt.Sprintf(\"duration >= %d\", durationLower))\n    }\n    if durationUpper > 0 {\n        conditions = append(conditions, fmt.Sprintf(\"duration < %d\", durationUpper))\n    }\n    if onlyErrors {\n        conditions = append(conditions, \"status = 'error'\")\n    }\n\n    // Construct the query\n    query := fmt.Sprintf(\"SELECT * FROM traces WHERE %s ORDER BY start_time DESC LIMIT %d\", strings.Join(conditions, \" AND \"), limit)\n\n    // Execute the query and return the results\n    rows, err := d.QueryContext(ctx, query)\n    if err != nil {\n        return nil, err\n    }\n    defer rows.Close()\n\n    // Parse the results into TraceSummary objects\n    summaries := make([]TraceSummary, 0, limit)\n    for rows.Next() {\n        var summary TraceSummary\n        err := rows.Scan(&summary)\n        if err != nil {\n            return nil, err\n        }\n        summaries = append(summaries, summary)\n    }\n    return summaries, nil\n}\n```"]}, "weaver-runtime/retry/retry.go-Continue": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r *Retry) Continue(ctx context.Context) bool {\n# Natural Language Annotations: // Continue sleeps for an exponentially increasing interval (with jitter). It\n// stops its sleep early and returns false if context becomes done. If the\n// return value is false, ctx.Err() is guaranteed to be non-nil. The first\n// call does not sleep.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n    \"context\"\n    \"math/rand\"\n    \"sync\"\n    \"time\"\n)\n\ntype Retry struct {\n    mu sync.Mutex\n    dur time.Duration\n    j  float64\n}\n\nfunc (r *Retry) Continue(ctx context.Context) bool {\n    r.mu.Lock()\n    defer r.mu.Unlock()\n\n    if ctx.Err() != nil {\n        return false\n    }\n\n    if r.dur == 0 {\n        return true\n    }\n\n    jitter := float64(r.dur) * r.j\n    jitter = math.Max(0, jitter)\n    jitter = math.Min(jitter, r.dur)\n\n    sleepDur := r.dur + time.Duration(rand.Int63n(int64(jitter)))\n    select {\n    case <-ctx.Done():\n        return false\n    case <-time.After(sleepDur):\n        r.dur *= 2\n        return true\n    }\n}\n\n```", "```go\nimport (\n\t\"context\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Retry struct{}\n\nfunc (r *Retry) Continue(ctx context.Context) bool {\n\tif ctx.Err() != nil {\n\t\treturn false\n\t}\n\tif !ctx.Done() {\n\t\tinterval := time.Duration(rand.Intn(100)) * time.Millisecond\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn false\n\t\tcase <-time.After(interval):\n\t\t\treturn r.Continue(ctx)\n\t\t}\n\t}\n\treturn true\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"math/rand\"\n\t\"time\"\n)\n\ntype Retry struct {\n}\n\nfunc (r *Retry) Continue(ctx context.Context) bool {\n\tvar sleepTime time.Duration\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn false\n\t\tdefault:\n\t\t\tsleepTime = time.Duration(rand.Intn(100)*int64(time.Millisecond)) + 100*time.Millisecond\n\t\t\ttime.Sleep(sleepTime)\n\t\t\tif sleepTime < 1*time.Second {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n```"]}, "weaver-runtime/colors/tabularizer.go-Row": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *Tabularizer) Row(values ...any) {\n# Natural Language Annotations: // Row buffers a new Row to be tabularized. The Row isn't written until Flush\n// is called. Note that every Row reported to a tabularizer must be the same\n// length. A value can be a text, atom, string, or fmt.Stringer.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (t *Tabularizer) Row(values ...any) {\n    if len(values) == 0 {\n        t.rows = append(t.rows, make([]any, 0))\n    } else {\n        if len(values) != len(t.rows[len(t.rows)-1]) {\n            panic(\"all rows must be the same length\")\n        }\n        t.rows = append(t.rows, values)\n    }\n}\n```", "```go\nfunc (t *Tabularizer) Row(values ...any) {\n    // Check if the number of values matches the expected length\n    if len(values) != t.expectedLength {\n        panic(\"expected \" + strconv.Itoa(t.expectedLength) + \" values, got \" + strconv.Itoa(len(values)))\n    }\n    \n    // Create a new Row\n    row := make([]any, len(values))\n    \n    // Copy values to the row\n    for i, value := range values {\n        row[i] = value\n    }\n    \n    // Add the row to the queue\n    t.rows = append(t.rows, row)\n}\n```", "```go\nfunc (t *Tabularizer) Row(values ...any) {\n    // Check if the number of values is the same as the current row length\n    if len(values) != t.rowLength {\n        panic(\"all rows must have the same number of values\")\n    }\n\n    // Create a new row\n    row := make([]any, len(values))\n\n    // Copy the values to the row\n    for i, value := range values {\n        row[i] = value\n    }\n\n    // Add the row to the buffer\n    t.rows = append(t.rows, row)\n}\n```"]}, "weaver-runtime/colors/tabularizer.go-Flush": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (t *Tabularizer) Flush() {\n# Natural Language Annotations: // Flush writes all buffered rows. Flush should only be called once, after all\n// rows have been written.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Tabularizer:\n    def __init__(self):\n        self.buffer = []\n\n    def flush(self):\n        if self.buffer:\n            # assuming write_row is a method that writes a row\n            for row in self.buffer:\n                self.write_row(row)\n            self.buffer = []\n        else:\n            print(\"Error: Flush called without writing any rows.\")\n```", "```python\nclass Tabularizer:\n    def __init__(self):\n        self.buffer = []\n        self.written = False\n\n    def add_row(self, row):\n        self.buffer.append(row)\n\n    def flush(self):\n        if self.written:\n            raise ValueError(\"Flush has already been called once\")\n        self.written = True\n        # implement write logic here\n        # for example:\n        print(self.buffer)\n        self.buffer = []\n```", "```python\nclass Tabularizer:\n    def __init__(self):\n        self.buffer = []\n        self.flushed = False\n\n    def write(self, row):\n        self.buffer.append(row)\n\n    def flush(self):\n        if self.flushed:\n            raise ValueError(\"Flush has already been called\")\n        self.flushed = True\n        # Here you would put the actual code to write the rows to the output\n        # For demonstration purposes, we'll just print the rows\n        for row in self.buffer:\n            print(row)\n        self.buffer = []\n```"]}, "weaver-runtime/protomsg/io.go-Write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Write(dst io.Writer, msg proto.Message) error {\n# Natural Language Annotations: // Write writes a length prefixed protobuf to dst. Use Read to read it.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"errors\"\n\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc Write(dst io.Writer, msg proto.Message) error {\n\tdata, err := proto.Marshal(msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar length uint32\n\tbinary.BigEndian.PutUint32([]byte{0, 0, 0, 0}, length)\n\tdst.Write([]byte{0, 0, 0, 0})\n\tdst.Write(data)\n\treturn nil\n}\n```", "```python\nimport io\nimport struct\nfrom google.protobuf import message\n\ndef Write(dst, msg):\n    # Create a bytes buffer to write to\n    buf = io.BytesIO()\n\n    # Write the length of the message as a 32-bit int\n    buf.write(struct.pack('>I', len(msg.SerializeToString())))\n\n    # Write the message itself\n    buf.write(msg.SerializeToString())\n\n    # Seek back to the beginning of the buffer and write it to the destination\n    buf.seek(0)\n    dst.write(buf.read())\n\n    return None\n```", "```go\nimport (\n\t\"encoding/binary\"\n\t\"io\"\n\t\"log\"\n\n\t\"google.golang.org/protobuf/proto\"\n)\n\nfunc Write(dst io.Writer, msg proto.Message) error {\n\tb, err := proto.Marshal(msg)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tvar size uint32\n\tsize = uint32(len(b))\n\n\terr = binary.Write(dst, binary.BigEndian, size)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t_, err = dst.Write(b)\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn nil\n}\n```"]}, "weaver-runtime/bin/bin.go-ReadComponentGraph": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadComponentGraph(file string) ([]string, graph.Graph, error) {\n# Natural Language Annotations: // ReadComponentGraph reads component graph information from the specified\n// binary. It returns a slice of components and a component graph whose nodes\n// are indices into that slice.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom graph import Graph\n\ndef read_component_graph(file):\n    try:\n        # Read the file contents\n        with open(file, 'r') as f:\n            contents = f.read()\n        \n        # Split the contents into a list of components\n        components = contents.splitlines()\n        \n        # Create a new Graph object\n        graph = Graph()\n        \n        # Iterate over each component\n        for i, component in enumerate(components):\n            # Add the component to the graph\n            graph.add_node(i)\n        \n        # Return the list of components and the graph\n        return components, graph, None\n    \n    except Exception as e:\n        # Return an error if there was a problem reading the file\n        return None, None, e\n```", "```go\npackage main\n\nimport (\n\t\"encoding/binary\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/your/graph/graph\"\n)\n\nfunc ReadComponentGraph(file string) ([]string, graph.Graph, error) {\n\t// Open the file\n\tf, err := os.Open(file)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tdefer f.Close()\n\n\t// Read the number of components\n\tvar numComponents uint32\n\terr = binary.Read(f, binary.LittleEndian, &numComponents)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\t// Read the components\n\tcomponents := make([]string, numComponents)\n\tfor i := range components {\n\t\terr = binary.Read(f, binary.LittleEndian, &components[i])\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t}\n\n\t// Create a new graph\n\tg := graph.New()\n\n\t// Read the edges\n\tfor i := 0; i < int(numComponents); i++ {\n\t\tvar numEdges uint32\n\t\terr = binary.Read(f, binary.LittleEndian, &numEdges)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\n\t\tfor j := 0; j < int(numEdges); j++ {\n\t\t\tvar dest uint32\n\t\t\terr = binary.Read(f, binary.LittleEndian, &dest)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\n\t\t\tg.AddEdge(i, dest)\n\t\t}\n\t}\n\n\treturn components, g, nil\n}\n```", "```python\nimport networkx as nx\nimport xml.etree.ElementTree as ET\n\ndef read_component_graph(file_path):\n    \"\"\"\n    Reads component graph information from the specified XML file.\n\n    Args:\n        file_path (str): Path to the XML file containing the component graph.\n\n    Returns:\n        list: A list of components.\n        graph: A NetworkX graph object whose nodes are indices into the list of components.\n        error: An error message if the file cannot be parsed, otherwise None.\n    \"\"\"\n    try:\n        tree = ET.parse(file_path)\n        root = tree.getroot()\n        components = []\n        graph = nx.DiGraph()\n\n        for component in root.findall('component'):\n            name = component.get('name')\n            components.append(name)\n            graph.add_node(len(components) - 1)\n\n        for component in root.findall('component'):\n            for port in component.findall('port'):\n                name = port.get('name')\n                for parent in component.findall('parent'):\n                    parent_name = parent.get('name')\n                    graph.add_edge(components.index(parent_name), components.index(name))\n\n        return components, graph, None\n    except Exception as e:\n        return [], None, str(e)\n```"]}, "weaver-runtime/bin/bin.go-ReadListeners": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadListeners(file string) ([]codegen.ComponentListeners, error) {\n# Natural Language Annotations: // ReadListeners reads the sets of listeners associated with each component\n// in the specified binary.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```javascript\nfunction ReadListeners(file) {\n    // Read the binary file\n    const fs = require('fs');\n    const data = fs.readFileSync(file, 'utf8');\n\n    // Parse the binary data into a JSON object\n    const json = JSON.parse(data);\n\n    // Initialize an empty array to store the listeners\n    let listeners = [];\n\n    // Iterate over each component in the JSON object\n    for (let component in json) {\n        // Check if the component has a 'listeners' key\n        if (json[component].hasOwnProperty('listeners')) {\n            // Add the listeners to the listeners array\n            listeners = listeners.concat(json[component].listeners);\n        }\n    }\n\n    // Return the listeners array and no error\n    return [listeners, null];\n}\n```", "```go\npackage codegen\n\nimport (\n\t\"encoding/json\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc ReadListeners(file string) ([]ComponentListeners, error) {\n\t// Check if the file exists\n\tif _, err := os.Stat(file); os.IsNotExist(err) {\n\t\treturn nil, err\n\t}\n\n\t// Read the file\n\tdata, err := ioutil.ReadFile(file)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the JSON data\n\tvar listeners map[string][]ComponentListeners\n\terr = json.Unmarshal(data, &listeners)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Flatten the map into a slice\n\tlistenersSlice := make([]ComponentListeners, 0, len(listeners))\n\tfor _, v := range listeners {\n\t\tlistenersSlice = append(listenersSlice, v...)\n\t}\n\n\t// Return the listeners slice and nil error\n\treturn listenersSlice, nil\n}\n```", "```javascript\nconst fs = require('fs');\nconst path = require('path');\n\nfunction ReadListeners(file) {\n    try {\n        const data = fs.readFileSync(file, 'utf8');\n        const components = JSON.parse(data);\n        const listeners = {};\n        for (const component in components) {\n            listeners[component] = components[component].listeners;\n        }\n        return Object.keys(listeners).map(key => ({ component: key, listeners: listeners[key] }));\n    } catch (err) {\n        if (err.code === 'ENOENT') {\n            return [];\n        }\n        return [null, err];\n    }\n}\n```"]}, "weaver-runtime/bin/bin.go-ReadVersions": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReadVersions(filename string) (Versions, error) {\n# Natural Language Annotations: // ReadVersions reads the module version and deployer API version from the\n// specified binary.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport re\n\ndef read_versions(filename):\n    \"\"\"\n    Read the module version and deployer API version from the specified binary.\n\n    Args:\n        filename (str): The path to the binary file.\n\n    Returns:\n        tuple: A tuple containing the module version and deployer API version, or an error message.\n    \"\"\"\n    try:\n        with open(filename, 'r') as f:\n            content = f.read()\n    except FileNotFoundError:\n        return \"Error: File not found\", None\n\n    module_version_match = re.search(r\"__version__ = '(.*)'\", content)\n    deployer_version_match = re.search(r\"deployer_api_version = '(.*)'\", content)\n\n    if module_version_match and deployer_version_match:\n        return module_version_match.group(1), deployer_version_match.group(1)\n    else:\n        return \"Error: Unable to find version information\", None\n```", "```python\nimport re\n\ndef read_versions(filename):\n    \"\"\"\n    Reads the module version and deployer API version from the specified binary.\n\n    Args:\n        filename (str): The path to the binary file.\n\n    Returns:\n        tuple: A tuple containing the module version and deployer API version, and an error message if any.\n    \"\"\"\n    try:\n        with open(filename, 'r') as file:\n            content = file.read()\n            module_version_match = re.search(r'module_version\\s*=\\s*\"([^\"]+)\"', content)\n            deployer_api_version_match = re.search(r'deployer_api_version\\s*=\\s*\"([^\"]+)\"', content)\n            if module_version_match and deployer_api_version_match:\n                return module_version_match.group(1), deployer_api_version_match.group(1), None\n            else:\n                return None, None, \"Failed to find module or deployer API version\"\n    except FileNotFoundError:\n        return None, None, f\"File {filename} not found\"\n    except Exception as e:\n        return None, None, str(e)\n```", "```python\nimport os\nimport re\n\ndef ReadVersions(filename):\n    \"\"\"\n    Read the module version and deployer API version from the specified binary.\n\n    Args:\n        filename (str): The path to the binary file.\n\n    Returns:\n        tuple: A tuple containing the module version and deployer API version, or an error message if the file cannot be read.\n    \"\"\"\n    try:\n        with open(filename, 'r') as f:\n            content = f.read()\n            module_version_match = re.search(r'__version__ = \"(\\d+\\.\\d+\\.\\d+)\"', content)\n            deployer_api_version_match = re.search(r'deployer_api_version = \"(\\d+\\.\\d+\\.\\d+)\"', content)\n            \n            if module_version_match and deployer_api_version_match:\n                return module_version_match.group(1), deployer_api_version_match.group(1)\n            else:\n                return None, \"Error: Unable to find version information in the file.\"\n    except FileNotFoundError:\n        return None, f\"Error: File '{filename}' not found.\"\n    except Exception as e:\n        return None, str(e)\n```"]}, "weaver-runtime/prometheus/prometheus.go-TranslateMetricsToPrometheusTextFormat": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*metrics.MetricSnapshot, lisAddr, path string) {\n# Natural Language Annotations: // TranslateMetricsToPrometheusTextFormat translates Service Weaver\n// metrics (keyed by weavelet id) to a text format that can be\n// scraped by Prometheus [1].\n//\n// [1] https://prometheus.io/\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage metrics\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*MetricSnapshot, lisAddr, path string) {\n\tfor _, ms := range ms {\n\t\tfor _, metric := range ms.Metrics {\n\t\t\tweaveletID := metric.WeaveletID\n\t\t\tfor _, m := range metric.Metric {\n\t\t\t\tif m.Labels == nil {\n\t\t\t\t\tm.Labels = make(map[string]string)\n\t\t\t\t}\n\t\t\t\tm.Labels[\"weavelet_id\"] = weaveletID\n\t\t\t\tm.Labels[\"lis_addr\"] = lisAddr\n\t\t\t\tm.Labels[\"path\"] = path\n\t\t\t\tw.WriteString(fmt.Sprintf(\"%s %s %d\\n\", metric.Type, strings.Join(m.Labels, \",\"), m.Value))\n\t\t\t}\n\t\t}\n\t}\n}\n```", "```python\ndef translate_metrics_to_prometheus_text_format(w, metrics_snapshots, lis_addr, path):\n    \"\"\"\n    Translate Service Weaver metrics (keyed by weavelet id) to a text format that can be scraped by Prometheus.\n\n    Args:\n        w (bytes.Buffer): A bytes buffer to write the output to.\n        metrics_snapshots (list of metrics.MetricSnapshot): A list of metric snapshots.\n        lis_addr (str): The lis address.\n        path (str): The path.\n\n    Returns:\n        None\n    \"\"\"\n\n    # Write the header to the output buffer\n    w.write(\"# HELP weavelet_metrics Weavelet metrics\\n\")\n    w.write(\"# TYPE weavelet_metrics gauge\\n\")\n    w.write(\"# HELP lis_addr The lis address\\n\")\n    w.write(\"# TYPE lis_addr gauge\\n\")\n    w.write(\"# HELP path The path\\n\")\n    w.write(\"# TYPE path gauge\\n\")\n\n    # Iterate over the metrics snapshots\n    for metric_snapshot in metrics_snapshots:\n        # Write the metric name and value to the output buffer\n        w.write(f\"{metric_snapshot.name} {metric_snapshot.value}\\n\")\n\n    # Write the lis address and path to the output buffer\n    w.write(f\"lis_addr {lis_addr}\\n\")\n    w.write(f\"path {path}\\n\")\n```", "```go\npackage service\n\nimport (\n\t\"bytes\"\n\t\"fmt\"\n\t\"strings\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\n\nfunc TranslateMetricsToPrometheusTextFormat(w *bytes.Buffer, ms []*metrics.MetricSnapshot, lisAddr, path string) {\n\tfor _, ms := range ms {\n\t\tfor _, metric := range ms.WeaveletMetrics {\n\t\t\tfor _, gauge := range metric.Gauges {\n\t\t\t\tw.WriteString(fmt.Sprintf(\"# HELP %s %s\\n\", metric.Name, gauge.Desc.String()))\n\t\t\t\tw.WriteString(fmt.Sprintf(\"# TYPE %s %s\\n\", metric.Name, gauge.Desc.Type.String()))\n\t\t\t\tfor _, label := range metric.Labels {\n\t\t\t\t\tw.WriteString(fmt.Sprintf(\"%s{\", label.Key))\n\t\t\t\t\tfor i, value := range label.Values {\n\t\t\t\t\t\tw.WriteString(fmt.Sprintf(\"%s=\\\"%s\\\"\", value.Key, value.Value))\n\t\t\t\t\t\tif i < len(label.Values)-1 {\n\t\t\t\t\t\t\tw.WriteString(\",\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tw.WriteString(\"} \")\n\t\t\t\t}\n\t\t\t\tw.WriteString(gauge.Desc.String())\n\t\t\t\tw.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tfor _, counter := range metric.Counters {\n\t\t\t\tw.WriteString(fmt.Sprintf(\"# HELP %s %s\\n\", metric.Name, counter.Desc.String()))\n\t\t\t\tw.WriteString(fmt.Sprintf(\"# TYPE %s %s\\n\", metric.Name, counter.Desc.Type.String()))\n\t\t\t\tfor _, label := range metric.Labels {\n\t\t\t\t\tw.WriteString(fmt.Sprintf(\"%s{\", label.Key))\n\t\t\t\t\tfor i, value := range label.Values {\n\t\t\t\t\t\tw.WriteString(fmt.Sprintf(\"%s=\\\"%s\\\"\", value.Key, value.Value))\n\t\t\t\t\t\tif i < len(label.Values)-1 {\n\t\t\t\t\t\t\tw.WriteString(\",\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tw.WriteString(\"} \")\n\t\t\t\t}\n\t\t\t\tw.WriteString(counter.Desc.String())\n\t\t\t\tw.WriteString(\"\\n\")\n\t\t\t}\n\t\t\tfor _, histogram := range metric.Histograms {\n\t\t\t\tw.WriteString(fmt.Sprintf(\"# HELP %s %s\\n\", metric.Name, histogram.Desc.String()))\n\t\t\t\tw.WriteString(fmt.Sprintf(\"# TYPE %s %s\\n\", metric.Name, histogram.Desc.Type.String()))\n\t\t\t\tfor _, label := range metric.Labels {\n\t\t\t\t\tw.WriteString(fmt.Sprintf(\"%s{\", label.Key))\n\t\t\t\t\tfor i, value := range label.Values {\n\t\t\t\t\t\tw.WriteString(fmt.Sprintf(\"%s=\\\"%s\\\"\", value.Key, value.Value))\n\t\t\t\t\t\tif i < len(label.Values)-1 {\n\t\t\t\t\t\t\tw.WriteString(\",\")\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tw.WriteString(\"} \")\n\t\t\t\t}\n\t\t\t\tw.WriteString(histogram.Desc.String())\n\t\t\t\tw.WriteString(\"\\n\")\n\t\t\t}\n\t\t}\n\t}\n}\n```"]}, "weaver-runtime/codegen/graph.go-ExtractEdges": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ExtractEdges(data []byte) [][2]string {\n# Natural Language Annotations: // ExtractEdges returns the edges corresponding to MakeEdgeString() results\n// that occur in data.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef ExtractEdges(data):\n    import re\n    edges = []\n    pattern = r'\\(\\[(\\d+),(\\d+)\\]'\n    matches = re.findall(pattern, data.decode('utf-8'))\n    for match in matches:\n        edges.append([match[0], match[1]])\n    return edges\n```", "```python\ndef extract_edges(data):\n    # Define a regular expression pattern to match MakeEdgeString() results\n    pattern = r'\\(\\[(\\w+),(\\w+)\\]\\)'\n    \n    # Use the findall function from the re module to find all matches\n    import re\n    edges = re.findall(pattern, str(data))\n    \n    # Convert the list of tuples to a list of lists\n    edges = [[edge[0], edge[1]] for edge in edges]\n    \n    return edges\n```", "```python\nimport re\n\ndef ExtractEdges(data):\n    pattern = r'\\[([^\\]]+)\\]'\n    matches = re.findall(pattern, str(data))\n    edges = []\n    for match in matches:\n        edge = match.replace(\"'\", \"\").replace(\" \", \"\").split(',')\n        if len(edge) == 2:\n            edges.append([edge[0], edge[1]])\n    return edges\n```"]}, "weaver-runtime/codegen/registry.go-ComponentConfigValidator": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ComponentConfigValidator(path, cfg string) error {\n# Natural Language Annotations: // ComponentConfigValidator checks that cfg is a valid configuration\n// for the component type whose fully qualified name is given by path.\n//\n// TODO(mwhittaker): Move out of codegen package? It's not used by the\n// generated code.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage config\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"path/filepath\"\n    \"strings\"\n\n    \"github.com/google/exposure-notifications-privacy/goists/config\"\n)\n\nfunc ComponentConfigValidator(path string, cfg string) error {\n    // Parse the configuration string into a Config object\n    configObj, err := config.ParseConfig(cfg)\n    if err != nil {\n        return err\n    }\n\n    // Get the component type from the path\n    componentType := strings.TrimSuffix(filepath.Base(path), \".go\")\n\n    // Validate the configuration for the component type\n    if err := configObj.Validate(componentType); err != nil {\n        return err\n    }\n\n    return nil\n}\n```", "```go\npackage config\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\n\t\"github.com/go-yaml/yaml\"\n)\n\nfunc ComponentConfigValidator(path string, cfg string) error {\n\tvar config map[string]interface{}\n\n\t// Try to parse the config as JSON\n\tif err := json.Unmarshal([]byte(cfg), &config); err == nil {\n\t\treturn nil\n\t}\n\n\t// If JSON parsing fails, try to parse as YAML\n\tif err := yaml.Unmarshal([]byte(cfg), &config); err != nil {\n\t\treturn fmt.Errorf(\"invalid configuration for %s: %w\", path, err)\n\t}\n\n\treturn nil\n}\n```", "```go\npackage config\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"path/filepath\"\n\n\t\"github.com/spf13/viper\"\n)\n\nfunc ComponentConfigValidator(path string, cfg string) error {\n\t// Check if the configuration file exists\n\tif _, err := filepath.Abs(path); err != nil {\n\t\treturn err\n\t}\n\n\t// Unmarshal the JSON configuration\n\tvar config map[string]interface{}\n\tif err := json.Unmarshal([]byte(cfg), &config); err != nil {\n\t\treturn err\n\t}\n\n\t// Validate the configuration\n\tif err := viper.ValidateConfig(config); err != nil {\n\t\treturn fmt.Errorf(\"invalid configuration: %w\", err)\n\t}\n\n\treturn nil\n}\n```"]}, "weaver-runtime/codegen/registry.go-CallGraph": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CallGraph() []CallEdge {\n# Natural Language Annotations: // CallGraph returns the component call graph (as a list of CallEdge values).\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass CallEdge:\n    def __init__(self, caller, callee):\n        self.caller = caller\n        self.callee = callee\n\ndef CallGraph():\n    # For simplicity, let's assume we have a predefined list of call edges\n    call_edges = [\n        CallEdge('A', 'B'),\n        CallEdge('A', 'C'),\n        CallEdge('B', 'D'),\n        CallEdge('C', 'D'),\n        CallEdge('D', 'E'),\n    ]\n    return call_edges\n```", "```python\nclass CallEdge:\n    def __init__(self, from_node, to_node):\n        self.from_node = from_node\n        self.to_node = to_node\n\ndef CallGraph():\n    # For simplicity, let's assume we have the following nodes and their edges\n    nodes = ['A', 'B', 'C', 'D']\n    edges = [('A', 'B'), ('A', 'C'), ('B', 'D'), ('C', 'D')]\n\n    # Create a list to store the call edges\n    call_edges = []\n\n    # Iterate over each edge and create a CallEdge object\n    for edge in edges:\n        call_edges.append(CallEdge(edge[0], edge[1]))\n\n    return call_edges\n```", "```python\nclass CallEdge:\n    def __init__(self, source, target):\n        self.source = source\n        self.target = target\n\ndef CallGraph():\n    # Assuming we have a list of functions and their dependencies\n    functions = {\n        'A': ['B', 'C'],\n        'B': ['D'],\n        'C': ['D'],\n        'D': []\n    }\n\n    # Initialize the call graph as an empty list\n    call_graph = []\n\n    # Iterate over each function and its dependencies\n    for func, dependencies in functions.items():\n        # For each dependency, create a CallEdge and add it to the call graph\n        for dependency in dependencies:\n            call_graph.append(CallEdge(func, dependency))\n\n    return call_graph\n```"]}, "weaver-runtime/codegen/listeners.go-MakeListenersString": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MakeListenersString(component string, listeners []string) string {\n# Natural Language Annotations: // All listeners used by a given component are embedded in the generated\n// binary as specially formatted strings. These strings can be extracted from\n// the binary to get the list of listeners associated with each component\n// without having to execute the binary.\n//\n// The set of listeners used by a given component is represented by a string\n// fragment that looks like:\n// \u27e6checksum:wEaVeRlIsTeNeRs:component\u2192listeners\u27e7\n//\n// checksum is the first 8 bytes of the hex encoding of the SHA-256 of\n// the string \"wEaVeRlIsTeNeRs:component\u2192listeners\"; component is the fully\n// qualified component type name; listeners is a comma-separated list of\n// all listener names associated with a given component.\n// MakeListenersString returns a string that should be emitted into generated\n// code to represent the set of listeners associated with a given component.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport hashlib\nimport binascii\n\ndef make_listeners_string(component: str, listeners: list) -> str:\n    \"\"\"\n    Generate a string representing the list of listeners associated with a given component.\n    \n    Args:\n    component (str): The fully qualified component type name.\n    listeners (list): A list of listener names associated with the component.\n    \n    Returns:\n    str: A string representing the list of listeners associated with the component.\n    \"\"\"\n    # Calculate the checksum by hashing the string \"wEaVeRlIsTeNeRs:component\u2192listeners\"\n    # and taking the first 8 bytes of the result.\n    string_to_hash = f\"wEaVeRlIsTeNeRs:{component}\u2192{','.join(listeners)}\"\n    checksum = hashlib.sha256(string_to_hash.encode()).digest()[:8]\n    \n    # Convert the checksum to a hexadecimal string.\n    checksum_hex = binascii.hexlify(checksum).decode()\n    \n    # Return the formatted string.\n    return f\"\u27e6{checksum_hex}:{component}\u2192{','.join(listeners)}\u27e7\"\n```", "```python\nimport hashlib\n\ndef make_listeners_string(component, listeners):\n    \"\"\"\n    Generate a string that represents the set of listeners associated with a given component.\n    \n    Args:\n        component (str): The fully qualified component type name.\n        listeners (list): A list of listener names associated with the component.\n    \n    Returns:\n        str: A string that represents the set of listeners associated with the component.\n    \"\"\"\n    # Create a string with the listener names\n    listeners_str = \",\".join(listeners)\n    \n    # Create the string to be hashed\n    to_hash = f\"wEaVeRlIsTeNeRs:{component}\u2192{listeners_str}\"\n    \n    # Calculate the SHA-256 checksum\n    checksum = hashlib.sha256(to_hash.encode()).hexdigest()[:8]\n    \n    # Return the formatted string\n    return f\"\u27e6{checksum}:{to_hash}\u27e7\"\n```", "```javascript\nfunction makeListenersString(component, listeners) {\n  const listenerString = `wEaVeRlIsTeNeRs:${component}\u2192${listeners.join(',')}`;\n  const hash = crypto.createHash('sha256');\n  hash.update(listenerString);\n  const checksum = hash.digest('hex').slice(0, 8);\n  return `\u27e6${checksum}:${listenerString}\u27e7`;\n}\n\nconsole.log(makeListenersString(\"MyComponent\", [\"listener1\", \"listener2\", \"listener3\"]));\n```"]}, "weaver-runtime/codegen/listeners.go-ExtractListeners": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ExtractListeners(data []byte) []ComponentListeners {\n# Natural Language Annotations: // ExtractListeners returns the components and their listeners encoded using\n// MakeListenersString() in data.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import List\n\ndef ExtractListeners(data: bytes) -> List['ComponentListeners']:\n    # Assuming ComponentListeners is a class\n    class ComponentListeners:\n        def __init__(self, name: str, listeners: int):\n            self.name = name\n            self.listeners = listeners\n\n    # Assuming MakeListenersString() is a function\n    def MakeListenersString(component: str) -> str:\n        return f\"{component}_listeners\"\n\n    # Assuming data is a string of comma separated components\n    components = data.decode('utf-8').split(',')\n\n    # Initialize an empty list to store the ComponentListeners\n    listeners_list = []\n\n    for component in components:\n        # Assuming the component name is the first part of the string\n        name = component.split('_listeners')[0]\n        listeners = int(component.split('_listeners')[1])\n        listeners_list.append(ComponentListeners(name, listeners))\n\n    return listeners_list\n```", "```python\ndef extract_listeners(data):\n    \"\"\"\n    Extracts components and their listeners from the given data.\n\n    Args:\n        data (str): A string containing components and their listeners encoded using MakeListenersString().\n\n    Returns:\n        list: A list of dictionaries where each dictionary represents a component and its listeners.\n    \"\"\"\n    listeners = []\n    current_component = None\n    current_listeners = []\n\n    for line in data.split('\\n'):\n        if line.startswith('Component:'):\n            if current_component:\n                listeners.append({'component': current_component, 'listeners': current_listeners})\n            current_component = line.split(': ')[1]\n            current_listeners = []\n        elif line.startswith('Listener:'):\n            current_listeners.append(line.split(': ')[1])\n    \n    if current_component:\n        listeners.append({'component': current_component, 'listeners': current_listeners})\n\n    return listeners\n```", "```python\ndef ExtractListeners(data):\n    import xml.etree.ElementTree as ET\n    root = ET.fromstring(data)\n    listeners = root.findall('.//listeners')\n    components = []\n    for listener in listeners:\n        component = {}\n        component['name'] = listener.get('name')\n        component['listeners'] = listener.findall('listener')\n        components.append(component)\n    return components\n```"]}, "weaver-runtime/codegen/hash.go-Sum64": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (h *Hasher) Sum64() uint64 {\n# Natural Language Annotations: // Sum64 returns the 64-bit hash of the sequence of values added so far.\n// The resulting is in the range [1,2^64-2], i.e., it is never 0 or math.MaxUint64.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (h *Hasher) Sum64() uint64 {\n    return (h.x ^ h.x<<15) >> 15\n}\n```", "```sql\nfunc (h *Hasher) Sum64() uint64 {\n    // Using the MurmurHash3 algorithm to generate a 64-bit hash value\n    // The hash is in the range [1, 2^64-2]\n    return uint64((h.sum & 0x7FFFFFFF) + 1)\n}\n```", "```python\nimport mmh3\nimport hashlib\n\nclass Hasher:\n    def __init__(self):\n        self.hasher = mmh3.hash64()\n\n    def Sum64(self, value):\n        self.hasher.update(str(value).encode('utf-8'))\n        return self.hasher.digest()[0]\n```\n\nNote: This code uses the MurmurHash3 library for hashing, which is a fast and non-cryptographic hash function. The `hash64` function is used to get a 64-bit hash value. \n\nHowever, since Python does not have a direct equivalent to the Go `math.MaxUint64` constant, the range check is not included in the code. It's assumed that the caller will handle this."]}, "weaver-runtime/graph/adjacency.go-NewAdjacencyGraph": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n# Natural Language Annotations: // NewAdjacencyGraph returns a Graph represented using adjacency lists.\n//\n// It panics if it specified edge nodes aren't in nodes.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\ntype Node struct {\n    Value string\n}\n\ntype Edge struct {\n    From  int\n    To    int\n}\n\ntype Graph map[int][]int\n\nfunc NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n    graph := make(map[int][]int)\n    for i, node := range nodes {\n        graph[i] = []int{}\n    }\n    for _, edge := range edges {\n        if _, ok := nodes[edge.From].Value; !ok {\n            panic(\"Edge's from node is not in the nodes list\")\n        }\n        if _, ok := nodes[edge.To].Value; !ok {\n            panic(\"Edge's to node is not in the nodes list\")\n        }\n        graph[edge.From] = append(graph[edge.From], edge.To)\n    }\n    return graph\n}\n```", "```go\ntype Node string\ntype Edge struct {\n    From, To Node\n}\n\ntype Graph map[Node][]Node\n\nfunc NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n    graph := make(map[Node][]Node)\n    for _, node := range nodes {\n        graph[node] = []Node{}\n    }\n    for _, edge := range edges {\n        if _, ok := graph[edge.From]; !ok {\n            panic(\"specified edge node '\" + string(edge.From) + \"' is not in nodes\")\n        }\n        if _, ok := graph[edge.To]; !ok {\n            panic(\"specified edge node '\" + string(edge.To) + \"' is not in nodes\")\n        }\n        graph[edge.From] = append(graph[edge.From], edge.To)\n    }\n    return graph\n}\n```", "```go\ntype Node struct {\n    Value string\n}\n\ntype Edge struct {\n    Source Node\n    Target Node\n}\n\ntype Graph map[Node][]Node\n\nfunc NewAdjacencyGraph(nodes []Node, edges []Edge) Graph {\n    graph := make(Graph)\n    for _, node := range nodes {\n        graph[node] = []Node{}\n    }\n    for _, edge := range edges {\n        if _, ok := graph[edge.Source]; !ok {\n            panic(\"specified edge source node isn't in nodes\")\n        }\n        if _, ok := graph[edge.Target]; !ok {\n            panic(\"specified edge target node isn't in nodes\")\n        }\n        graph[edge.Source] = append(graph[edge.Source], edge.Target)\n    }\n    return graph\n}\n```"]}, "weaver-runtime/graph/dfs.go-DFSAll": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DFSAll(g Graph, enter, exit func(Node)) {\n# Natural Language Annotations: // DFSAll performs a depth first search of all nodes in g.\n// If enter is non-nil, it is called on entry to a node.\n// If exit is non-nil, it is called on exit from a node.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef DFSAll(g, enter=None, exit=None):\n    \"\"\"\n    Performs a depth first search of all nodes in g.\n    \n    If enter is non-nil, it is called on entry to a node.\n    If exit is non-nil, it is called on exit from a node.\n    \n    :param g: The graph to search.\n    :type g: dict\n    :param enter: Function called on entry to a node.\n    :type enter: callable\n    :param exit: Function called on exit from a node.\n    :type exit: callable\n    \"\"\"\n    visited = set()\n    for node in g:\n        if node not in visited:\n            _dfs(g, node, visited, enter, exit)\n    return\n\ndef _dfs(g, node, visited, enter, exit):\n    visited.add(node)\n    if enter:\n        enter(node)\n    for neighbor in g[node]:\n        if neighbor not in visited:\n            _dfs(g, neighbor, visited, enter, exit)\n    if exit:\n        exit(node)\n```", "```python\nclass Node:\n    def __init__(self, value):\n        self.value = value\n        self.children = []\n\ndef DFSAll(g, enter=None, exit=None):\n    \"\"\"\n    Performs a depth first search of all nodes in the graph g.\n    If enter is non-nil, it is called on entry to a node.\n    If exit is non-nil, it is called on exit from a node.\n    \"\"\"\n    def dfs(node):\n        if enter is not None:\n            enter(node)\n        for child in node.children:\n            dfs(child)\n        if exit is not None:\n            exit(node)\n\n    for node in g:\n        dfs(node)\n```", "```python\ndef DFSAll(graph, enter=None, exit=None):\n    \"\"\"\n    Performs a depth first search of all nodes in the graph.\n\n    Args:\n        graph: The graph to search.\n        enter: A function to call on entry to each node.\n        exit: A function to call on exit from each node.\n\n    Returns:\n        None\n    \"\"\"\n\n    def dfs(node):\n        if enter is not None:\n            enter(node)\n        for neighbor in graph[node]:\n            if exit is not None:\n                exit(node)\n            dfs(neighbor)\n        if exit is not None:\n            exit(node)\n\n    for node in graph:\n        dfs(node)\n```"]}, "weaver-runtime/metrics/labels.go-newLabelExtractor": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func newLabelExtractor[L comparable]() *labelExtractor[L] {\n# Natural Language Annotations: // newLabelExtractor returns a new labelExtractor that can extract the labels\n// from a label struct of type L. L must be a valid label struct type.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom abc import ABC, abstractmethod\n\nclass LabelExtractor(ABC):\n    @abstractmethod\n    def extract_labels(self, label: any) -> list:\n        pass\n\ndef newLabelExtractor[L](label_type: type[L]) -> LabelExtractor[L]:\n    return LabelExtractorImpl[label_type]()\n    \nclass LabelExtractorImpl[L](LabelExtractor[L]):\n    def __init__(self):\n        self.label_type = L\n    \n    def extract_labels(self, label: L) -> list:\n        return [label]\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom typing import TypeVar\n\nL = TypeVar('L')\n\nclass LabelExtractor(ABC):\n    @abstractmethod\n    def extract(self, label: L) -> list:\n        pass\n\ndef newLabelExtractor[L](label_type: type[L]) -> LabelExtractor[L]:\n    return LabelExtractorImpl(label_type)\n\nclass LabelExtractorImpl(LabelExtractor[L]):\n    def __init__(self, label_type: type[L]):\n        self.label_type = label_type\n\n    def extract(self, label: L) -> list:\n        # Implement the logic to extract labels here\n        # For example, if the label is a string, you can split it by a delimiter\n        return [label]\n```", "```python\nfrom abc import ABC, abstractmethod\n\nclass LabelExtractor(ABC):\n    @abstractmethod\n    def extract_labels(self, label_struct):\n        pass\n\ndef newLabelExtractor[L](label_struct: L) -> LabelExtractor:\n    return LabelExtractor()\n```"]}, "weaver-runtime/metrics/metrics.go-Snapshot": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Metric) Snapshot() *MetricSnapshot {\n# Natural Language Annotations: // Snapshot returns a snapshot of the metric. You must call Init at least once\n// before calling Snapshot.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\ntype Metric struct {\n    // metric data\n}\n\ntype MetricSnapshot struct {\n    // snapshot data\n}\n\nfunc (m *Metric) Snapshot() *MetricSnapshot {\n    if m == nil {\n        panic(\"Metric is not initialized\")\n    }\n    // create a new snapshot\n    snapshot := &MetricSnapshot{}\n    // copy metric data to snapshot\n    // ...\n    return snapshot\n}\n```", "```go\ntype Metric struct {\n    // Add fields as necessary\n}\n\ntype MetricSnapshot struct {\n    // Add fields as necessary\n}\n\nfunc (m *Metric) Snapshot() *MetricSnapshot {\n    // Check if Init has been called at least once\n    if m == nil || m.InitCalled == 0 {\n        panic(\"Must call Init at least once before calling Snapshot\")\n    }\n    \n    // Create a new MetricSnapshot instance\n    snapshot := &MetricSnapshot{}\n    \n    // Copy the necessary fields from Metric to MetricSnapshot\n    snapshot.Value = m.Value\n    snapshot.Timestamp = m.Timestamp\n    \n    return snapshot\n}\n\nfunc (m *Metric) Init() {\n    m.InitCalled++\n}\n```", "```python\nclass Metric:\n    def __init__(self):\n        self.values = []\n\n    def init(self):\n        self.values = []\n\n    def add(self, value):\n        self.values.append(value)\n\n    def snapshot(self):\n        if not self.values:\n            raise ValueError(\"Must call init at least once before calling snapshot\")\n        return MetricSnapshot(self.values)\n\n\nclass MetricSnapshot:\n    def __init__(self, values):\n        self.values = values\n```"]}, "weaver-internal/tool/generate/types.go-sizeOfType": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (tset *typeSet) sizeOfType(t types.Type) int {\n# Natural Language Annotations: // sizeOfType returns the size of the serialization of t if t is fixed size, or\n// returns -1 otherwise.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef size_of_type(tset, t):\n    \"\"\"\n    Returns the size of the serialization of t if t is fixed size, or -1 otherwise.\n    \n    Args:\n    tset (set): A set of types\n    t (types.Type): The type to get the size of\n    \n    Returns:\n    int: The size of the serialization of t if t is fixed size, or -1 otherwise\n    \"\"\"\n    if t in tset:\n        return t.size  # assuming t.size is the size of the type\n    else:\n        return -1\n```", "```python\ndef size_of_type(tset, t):\n    \"\"\"\n    Returns the size of the serialization of t if t is fixed size, or\n    returns -1 otherwise.\n    \"\"\"\n    if t == int or t == float or t == bool or t == str:\n        return 8  # Assuming 64-bit system\n    elif t == bytes or t == bytearray:\n        return -1  # Dynamic size\n    elif t == list or t == tuple or t == dict:\n        return -1  # Dynamic size\n    elif t == complex:\n        return 16  # Assuming 64-bit system\n    else:\n        return -1  # Unknown type\n```", "```python\ndef size_of_type(tset, t):\n    \"\"\"\n    sizeOfType returns the size of the serialization of t if t is fixed size, or\n    returns -1 otherwise.\n\n    :param tset: A set of known types\n    :param t: A type to check\n    :return: The size of the serialization of t if t is fixed size, or -1 otherwise\n    \"\"\"\n    if t in tset:\n        # Assuming tset is a dictionary where keys are types and values are their sizes\n        return tset[t]\n    else:\n        return -1\n```"]}, "weaver-internal/tool/generate/types.go-isMeasurable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (tset *typeSet) isMeasurable(t types.Type) bool {\n# Natural Language Annotations: // isMeasurable returns whether the provided type is measurable.\n//\n// Informally, we say a type is measurable if we can cheaply compute the size\n// of its serialization at runtime. Some examples:\n//\n//   - Every fixed size type (e.g., int, bool, [3]int, struct{x, y int}) is\n//     measurable (with some restrictions on package locality; see below).\n//   - Strings are not fixed size, but they are measurable because we can\n//     cheaply compute the length of a string at runtime.\n//   - []string is not measurable because computing the size of the\n//     serialization of a []string would require us to compute the length of\n//     every string in the slice. This is a potentially expensive operation\n//     if the slice contains a large number of strings, so we consider\n//     []string to be not measurable.\n//   - For simplicity, we only consider a type measurable if the type and all\n//     its nested types are package local. For example, a struct { x\n//     otherpackage.T } is not measurable, even if otherpackage.T is\n//     measurable. We make an exception for weaver.AutoMarshal.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\ntype TypeSet struct {\n\ttypes map[reflect.Type]bool\n}\n\nfunc (tset *TypeSet) isMeasurable(t reflect.Type) bool {\n\t// Check if the type is a fixed size type\n\tif t.Kind() == reflect.Struct {\n\t\t// Check if all fields are fixed size types and are package local\n\t\tfor i := 0; i < t.NumField(); i++ {\n\t\t\tfield := t.Field(i)\n\t\t\tif !tset.isMeasurable(field.Type) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif !isPackageLocal(t, field) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t\treturn true\n\t} else if t.Kind() == reflect.Slice {\n\t\t// Check if the element type is measurable and is package local\n\t\tif t.Elem().Kind() == reflect.String {\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t} else if t.Kind() == reflect.Ptr {\n\t\treturn tset.isMeasurable(t.Elem())\n\t} else if t.Kind() == reflect.Chan {\n\t\treturn false\n\t} else if t.Kind() == reflect.Func {\n\t\treturn false\n\t} else if t.Kind() == reflect.Interface {\n\t\treturn false\n\t} else if t.Kind() == reflect.Map {\n\t\treturn false\n\t} else if t.Kind() == reflect.Invalid {\n\t\treturn false\n\t} else {\n\t\treturn true\n\t}\n}\n\nfunc isPackageLocal(t reflect.Type, field reflect.StructField) bool {\n\t// For simplicity, we assume that package local types are in the same package\n\treturn t.PkgPath() == field.Type.PkgPath()\n}\n\nfunc main() {\n\t// Create a type set\n\ttset := &TypeSet{types: make(map[reflect.Type]bool)}\n\n\t// Register some types as measurable\n\ttset.types[reflect.TypeOf(10)] = true\n\ttset.types[reflect.TypeOf(true)] = true\n\ttset.types[reflect.TypeOf(struct{x int; y int}{})] = true\n\ttset.types[reflect.TypeOf(\"hello\")] = true\n\n\t// Check if some types are measurable\n\tfmt.Println(tset.isMeasurable(reflect.TypeOf(10)))  // true\n\tfmt.Println(tset.isMeasurable(reflect.TypeOf(true)))  // true\n\tfmt.Println(tset.isMeasurable(reflect.TypeOf(struct{x int; y int}{}))  // true\n\tfmt.Println(tset.isMeasurable(reflect.TypeOf(\"hello\")))  // true\n\tfmt.Println(tset.isMeasurable(reflect.TypeOf([]int{})))  // false\n\tfmt.Println(tset.isMeasurable(reflect.TypeOf(struct{x otherpackage.T}{})))  // false\n} \n```", "```go\nfunc (tset *typeSet) isMeasurable(t types.Type) bool {\n    // Check if the type is a primitive type or a fixed-size type\n    if t.Kind() == types.Bool || t.Kind() == types.Int || t.Kind() == types.Uint || t.Kind() == types.Float || t.Kind() == types.String || t.Kind() == types.Complex128 {\n        return true\n    }\n\n    // Check if the type is a fixed-size array or struct\n    if t.Kind() == types.Array || t.Kind() == types.Struct {\n        // Check if all fields are measurable\n        for i := 0; i < t.NumField(); i++ {\n            field := t.Field(i)\n            if !tset.isMeasurable(field.Type()) {\n                return false\n            }\n        }\n        return true\n    }\n\n    // Check if the type is a slice\n    if t.Kind() == types.Slice {\n        // If the element type is not measurable, the slice is not measurable\n        if !tset.isMeasurable(t.Elem()) {\n            return false\n        }\n        return true\n    }\n\n    // If the type is a pointer, check if the underlying type is measurable\n    if t.Kind() == types.Ptr {\n        return tset.isMeasurable(t.Elem())\n    }\n\n    // If the type is a map, check if the key and value types are measurable\n    if t.Kind() == types.Map {\n        if !tset.isMeasurable(t.Key()) || !tset.isMeasurable(t.Elem()) {\n            return false\n        }\n        return true\n    }\n\n    // If the type is a channel, it is not measurable\n    if t.Kind() == types.Chan {\n        return false\n    }\n\n    // If the type is a function, it is not measurable\n    if t.Kind() == types.Func {\n        return false\n    }\n\n    // If the type is an interface, it is not measurable\n    if t.Kind() == types.Interface {\n        return false\n    }\n\n    // If the type is a type parameter, it is not measurable\n    if t.Kind() == types.Named && t.Name() == \"weaver.AutoMarshal\" {\n        return true\n    }\n\n    // If none of the above conditions are met, the type is not measurable\n    return false\n}\n```", "```go\nfunc (tset *typeSet) isMeasurable(t types.Type) bool {\n    // If the type is a primitive type, it is measurable\n    if t == types.Bool || t == types.Int || t == types.Uint || t == types.String || t == types.Float || t == types.Complex || t == types.Uint8 || t == types.Uint16 || t == types.Uint32 || t == types.Uint64 || t == types.Int8 || t == types.Int16 || t == types.Int32 || t == types.Int64 || t == types.Byte || t == types.Rune || t == types.Uintptr || t == types.Float32 || t == types.Float64 {\n        return true\n    }\n\n    // If the type is a fixed-size array, it is measurable\n    if t.Kind() == types.Array {\n        return true\n    }\n\n    // If the type is a string, it is measurable\n    if t == types.String {\n        return true\n    }\n\n    // If the type is a struct, check if all its fields are measurable\n    if t.Kind() == types.Struct {\n        for i := 0; i < t.NumField(); i++ {\n            if !tset.isMeasurable(t.Field(i).Type()) {\n                return false\n            }\n        }\n        return true\n    }\n\n    // If the type is a slice, it is not measurable\n    if t.Kind() == types.Slice {\n        return false\n    }\n\n    // If the type is a map, it is not measurable\n    if t.Kind() == types.Map {\n        return false\n    }\n\n    // If the type is a channel, it is not measurable\n    if t.Kind() == types.Chan {\n        return false\n    }\n\n    // If the type is a pointer, it is measurable if the underlying type is measurable\n    if t.Kind() == types.Ptr {\n        return tset.isMeasurable(t.Elem())\n    }\n\n    // If the type is an interface, it is measurable if all its methods are measurable\n    if t.Kind() == types.Interface {\n        for i := 0; i < t.NumMethod(); i++ {\n            if !tset.isMeasurable(t.Method(i).Type()) {\n                return false\n            }\n        }\n        return true\n    }\n\n    // If the type is a function, it is not measurable\n    if t.Kind() == types.Func {\n        return false\n    }\n\n    // If the type is a package-local type, it is not measurable\n    if !tset.isPackageLocal(t) {\n        return false\n    }\n\n    return true\n}\n\nfunc (tset *typeSet) isPackageLocal(t types.Type) bool {\n    // For simplicity, we assume a type is package-local if its package is the same as the package of the typeSet\n    return t.Pkg().Path() == tset.pkg.Path()\n}\n```"]}, "weaver-internal/tool/generate/types.go-isValidRouterType": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func isValidRouterType(t types.Type) bool {\n# Natural Language Annotations: // isValidRouterType returns whether the provided type is a valid router type.\n// A router type can be one of the following: an integer (signed or unsigned),\n// a float, or a string. Alternatively, it can be a struct that may optioanly\n// embed the weaver.AutoMarshal struct and rest of the fields must be either\n// integers, floats, or strings.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Type, Optional\n\nclass AutoMarshal:\n    def __init__(self):\n        pass\n\ndef isValidRouterType(t: Type) -> bool:\n    \"\"\"\n    Returns whether the provided type is a valid router type.\n    \n    A router type can be one of the following: an integer (signed or unsigned),\n    a float, or a string. Alternatively, it can be a struct that optionally embeds\n    the weaver.AutoMarshal struct and the rest of the fields must be either integers,\n    floats, or strings.\n    \"\"\"\n    if t == int or t == float or t == str:\n        return True\n    elif t == AutoMarshal:\n        return True\n    elif issubclass(t, (int, float, str)):\n        return True\n    else:\n        return False\n```", "```go\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\n\t\"github.com/WeaverWorks/go-weaver\"\n)\n\nfunc isValidRouterType(t reflect.Type) bool {\n\t// Check if the type is an integer (signed or unsigned)\n\tif t.Kind() == reflect.Int || t.Kind() == reflect.Uint {\n\t\treturn true\n\t}\n\n\t// Check if the type is a float\n\tif t.Kind() == reflect.Float64 {\n\t\treturn true\n\t}\n\n\t// Check if the type is a string\n\tif t.Kind() == reflect.String {\n\t\treturn true\n\t}\n\n\t// Check if the type is a struct\n\tif t.Kind() != reflect.Struct {\n\t\treturn false\n\t}\n\n\t// Check if the struct embeds weaver.AutoMarshal\n\tautoMarshalField := t.FieldByName(\"AutoMarshal\")\n\tif autoMarshalField != (reflect.StructField{}) {\n\t\treturn true\n\t}\n\n\t// Check if all fields in the struct are valid\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tif !isValidRouterType(field.Type) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n)\n\nfunc isValidRouterType(t reflect.Type) bool {\n\t// Check if the type is a primitive type\n\tif t.Kind() == reflect.Int || t.Kind() == reflect.Int8 || t.Kind() == reflect.Int16 || t.Kind() == reflect.Int32 || t.Kind() == reflect.Int64 || \n\t\tt.Kind() == reflect.Uint || t.Kind() == reflect.Uint8 || t.Kind() == reflect.Uint16 || t.Kind() == reflect.Uint32 || t.Kind() == reflect.Uint64 || \n\t\tt.Kind() == reflect.Float32 || t.Kind() == reflect.Float64 || t.Kind() == reflect.String {\n\t\treturn true\n\t}\n\n\t// Check if the type is a struct\n\tif t.Kind() != reflect.Struct {\n\t\treturn false\n\t}\n\n\t// Check if the struct embeds AutoMarshal\n\tautoMarshalField := t.FieldByName(\"AutoMarshal\")\n\tif autoMarshalField.IsValid() {\n\t\treturn true\n\t}\n\n\t// Check if all fields are valid types\n\tfor i := 0; i < t.NumField(); i++ {\n\t\tfield := t.Field(i)\n\t\tif !isValidRouterType(field.Type) {\n\t\t\treturn false\n\t\t}\n\t}\n\n\treturn true\n}\n\nfunc main() {\n\tfmt.Println(isValidRouterType(reflect.TypeOf(1)))  // true\n\tfmt.Println(isValidRouterType(reflect.TypeOf(1.0))) // true\n\tfmt.Println(isValidRouterType(reflect.TypeOf(\"hello\"))) // true\n\tfmt.Println(isValidRouterType(reflect.TypeOf(struct{ AutoMarshal bool }{})) ) // true\n\tfmt.Println(isValidRouterType(reflect.TypeOf(struct{ AutoMarshal bool; foo int }{})) ) // true\n\tfmt.Println(isValidRouterType(reflect.TypeOf(struct{}{})) ) // false\n\tfmt.Println(isValidRouterType(reflect.TypeOf(struct{ foo string }{})) ) // false\n} \n```"]}, "weaver-internal/tool/generate/generator.go-sanitize": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func sanitize(t types.Type) string {\n# Natural Language Annotations: // sanitize generates a (somewhat pretty printed) name for the provided type\n// that is a valid go identifier [1]. sanitize also produces unique names. That\n// is, if u != t, then sanitize(u) != sanitize(t).\n//\n// Some examples:\n//\n//   - map[int]string -> map_int_string_589aebd1\n//   - map[int][]X    -> map_int_slice_X_ac498abc\n//   - []int          -> slice_int_1048ebf9\n//   - [][]string     -> slice_slice_string_13efa8aa\n//   - [20]int        -> array_20_int_00ae9a0a\n//   - *int           -> ptr_int_916711b2\n//\n// [1]: https://go.dev/ref/spec#Identifiers\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nfunc sanitize(t reflect.Type) string {\n\tswitch t.Kind() {\n\tcase reflect.Chan:\n\t\treturn sanitize(t.Elem()). + \"_\" + sanitize(t.Out(0))\n\tcase reflect.Slice:\n\t\treturn \"slice_\" + sanitize(t.Elem())\n\tcase reflect.Ptr:\n\t\treturn \"ptr_\" + sanitize(t.Elem())\n\tcase reflect.Array:\n\t\treturn \"array_\" + fmt.Sprintf(\"%d\", t.Len()) + \"_\" + sanitize(t.Elem())\n\tcase reflect.Map:\n\t\treturn \"map_\" + sanitize(t.Key()) + \"_\" + sanitize(t.Elem())\n\tdefault:\n\t\tvar sb strings.Builder\n\t\tsb.Grow(32)\n\t\tfor _, r := range t.Name() {\n\t\t\tif unicode.IsLetter(r) {\n\t\t\t\tsb.WriteRune(r)\n\t\t\t} else {\n\t\t\t\tsb.WriteRune('_')\n\t\t\t}\n\t\t}\n\t\tif sb.Len() == 0 {\n\t\t\tsb.WriteString(\"anonymous\")\n\t\t}\n\t\tuid := fmt.Sprintf(\"%x\", utf8.RuneCountInString(sb.String()))\n\t\treturn sb.String() + \"_\" + uid\n\t}\n}\n\nfunc main() {\n\tfmt.Println(sanitize(reflect.TypeOf(map[int]string{}))\n\tfmt.Println(sanitize(reflect.TypeOf([]int{})))\n\tfmt.Println(sanitize(reflect.TypeOf([20]int{}))\n\tfmt.Println(sanitize(reflect.TypeOf((*int)(nil)))\n\tfmt.Println(sanitize(reflect.TypeOf(map[int][]string{})))\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nfunc sanitize(t reflect.Type) string {\n\tname := t.Name()\n\tif name == \"\" {\n\t\treturn \"unknown\"\n\t}\n\n\tsanitized := strings.Builder{}\n\tsanitized.WriteString(name)\n\tsanitized.WriteByte('_')\n\n\tswitch t.Kind() {\n\tcase reflect.Array:\n\t\tsanitized.WriteString(\"array_\")\n\t\tsanitized.WriteString(fmt.Sprintf(\"%d\", t.Len()))\n\tcase reflect.Chan, reflect.Slice:\n\t\tsanitized.WriteString(\"slice_\")\n\tcase reflect.Ptr:\n\t\tsanitized.WriteString(\"ptr_\")\n\tcase reflect.Map:\n\t\tsanitized.WriteString(\"map_\")\n\tcase reflect.Struct:\n\t\tsanitized.WriteString(\"struct_\")\n\tcase reflect.Interface:\n\t\tsanitized.WriteString(\"interface_\")\n\tcase reflect.Func:\n\t\tsanitized.WriteString(\"func_\")\n\tcase reflect.Invalid:\n\t\tsanitized.WriteString(\"unknown_\")\n\tdefault:\n\t\tif unicode.IsLetter(rune(t.Kind())) {\n\t\t\tsanitized.WriteString(string(t.Kind()))\n\t\t} else {\n\t\t\tsanitized.WriteString(\"unknown_\")\n\t\t}\n\t}\n\n\t// Add a unique suffix to ensure uniqueness\n\tsanitized.WriteString(fmt.Sprintf(\"_%s\", strings.TrimPrefix(t.String(), \"struct \")))\n\tfor _, field := range t.Field(0).Type.Fields() {\n\t\tsanitized.WriteString(strings.TrimPrefix(field.Name, \"Field\"))\n\t}\n\tsanitized.WriteString(\"_\" + strings.ToLower(fmt.Sprintf(\"%x\", t.PkgPath())))\n\n\treturn sanitized.String()\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\nfunc sanitize(t reflect.Type) string {\n\tvar name string\n\tswitch t.Kind() {\n\tcase reflect.Map:\n\t\tname = \"map\"\n\t\tfallthrough\n\tcase reflect.Slice:\n\t\tname = \"slice\"\n\tcase reflect.Array:\n\t\tname = \"array\"\n\tcase reflect.Ptr:\n\t\tname = \"ptr\"\n\tdefault:\n\t\treturn fmt.Sprintf(\"%s_%s\", t.Name(), t.Kind())\n\t}\n\n\tvar prefix string\n\tif t.Elem().Kind() == reflect.Slice {\n\t\tprefix = \"slice_\"\n\t} else if t.Elem().Kind() == reflect.Array {\n\t\tprefix = fmt.Sprintf(\"array_%d_\", t.Elem().Len())\n\t}\n\n\tvar sb strings.Builder\n\tsb.WriteString(name)\n\tsb.WriteString(\"_\")\n\tsb.WriteString(strings.ToLower(t.Elem().Name()))\n\tsb.WriteString(\"_\")\n\tsb.WriteString(strings.ReplaceAll(fmt.Sprintf(\"%x\", cryptorand.getRandomBytes(8)), \"-\", \"_\"))\n\n\treturn sb.String()\n}\n\nimport (\n\t\"crypto/rand\"\n\t\"fmt\"\n\t\"math/big\"\n)\n\nfunc main() {\n\ttype T struct{}\n\tfmt.Println(sanitize(reflect.TypeOf(map[int]string{})))\n\tfmt.Println(sanitize(reflect.TypeOf([]int{})))\n\tfmt.Println(sanitize(reflect.TypeOf([20]int{})))\n\tfmt.Println(sanitize(reflect.TypeOf((*int)(nil)))\n\tfmt.Println(sanitize(reflect.TypeOf(T{})))\n}\n```"]}, "weaver-internal/tool/generate/generator.go-uniqueName": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func uniqueName(t types.Type) string {\n# Natural Language Annotations: // uniqueName returns a unique pretty printed representation of the provided\n// type (e.g., \"int\", \"map[int]bool\"). The key property is that if u != t, then\n// uniqueName(u) != uniqueName(t).\n//\n// Note that types.TypeString returns a pretty printed representation of a\n// string, but it is not guaranteed to be unique. For example, if have `type\n// int bool`, then TypeString returns \"int\" for both the named type int and the\n// primitive type int.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"unicode\"\n    \"unicode/utf8\"\n\n    \"go/ast\"\n)\n\nfunc uniqueName(t types.Type) string {\n    // If the type is a named type, return the name\n    if named, ok := t.(*ast.Ident); ok {\n        return named.Name\n    }\n\n    // If the type is a composite type, recursively generate unique names for its components\n    if comp, ok := t.(*ast.StarExpr); ok {\n        return \"*\" + uniqueName(comp.X)\n    }\n    if comp, ok := t.(*ast.SelectorExpr); ok {\n        return uniqueName(comp.Sel) + \".\" + uniqueName(comp.X)\n    }\n    if comp, ok := t.(*ast.ArrayType); ok {\n        return \"[\" + uniqueName(comp.Elt) + \"]\"\n    }\n    if comp, ok := t.(*ast.MapType); ok {\n        return \"map[\" + uniqueName(comp.Key) + \"]\" + uniqueName(comp.Value)\n    }\n    if comp, ok := t.(*ast.StructType); ok {\n        var sb strings.Builder\n        for _, field := range comp.Fields.List {\n            if field.Type != nil {\n                sb.WriteString(uniqueName(field.Type))\n            } else {\n                sb.WriteString(\"nil\")\n            }\n        }\n        return \"struct {\" + sb.String() + \"}\"\n    }\n    if comp, ok := t.(*ast.ChanType); ok {\n        return \"chan \" + uniqueName(comp.Value)\n    }\n\n    // If the type is a primitive type, return its string representation\n    return t.TypeString()\n}\n\nfunc main() {\n    fmt.Println(uniqueName(types.NewIdent(\"int\"))) // prints: int\n    fmt.Println(uniqueName(types.NewStarExpr(types.NewIdent(\"int\")))) // prints: *int\n    fmt.Println(uniqueName(types.NewSelectorExpr(types.NewIdent(\"map\"), types.NewIdent(\"int\")))) // prints: map.int\n    fmt.Println(uniqueName(types.NewArrayType(types.NewIdent(\"int\")))) // prints: [int]\n    fmt.Println(uniqueName(types.NewMapType(types.NewIdent(\"int\"), types.NewIdent(\"bool\")))) // prints: map[int]bool\n    fmt.Println(uniqueName(types.NewStructType([]*ast.Field{{Type: types.NewIdent(\"int\")}}))) // prints: struct { int }\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n\n\t\"github.com/google/go-cmp/cmp\"\n)\n\nfunc uniqueName(t types.Type) string {\n\t// Get the type string representation\n\tts := types.TypeString(t)\n\n\t// If the type is a primitive type, return it as is\n\tif unicode.IsLower(rune(ts[0])) {\n\t\treturn ts\n\t}\n\n\t// If the type is a named type, add the type name to the string\n\tif strings.Contains(ts, \".\") {\n\t\tparts := strings.Split(ts, \".\")\n\t\treturn fmt.Sprintf(\"%s.%s\", parts[len(parts)-1], ts)\n\t}\n\n\t// If the type is a map type, format it as \"map[KeyType]ValueType\"\n\tif strings.HasPrefix(ts, \"map[\") {\n\t\tcloseBracketPos := strings.Index(ts, \"]\")\n\t\treturn fmt.Sprintf(\"map[%s]%s\", ts[4:closeBracketPos], ts[closeBracketPos+1:])\n\t}\n\n\t// If the type is an array type, format it as \"ArrayType[Length]\"\n\tif strings.HasPrefix(ts, \"[]\") {\n\t\tcloseBracketPos := strings.Index(ts, \"]\")\n\t\treturn fmt.Sprintf(\"%s%s\", ts[2:closeBracketPos], ts[closeBracketPos+1:])\n\t}\n\n\t// If none of the above cases match, return the type string as is\n\treturn ts\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc uniqueName(t string) string {\n\t// Create a set to store the names we've seen so far\n\tseen := make(map[string]bool)\n\n\t// Define a recursive function to generate a unique name\n\tvar uniqueNameHelper func(t string) string\n\tuniqueNameHelper = func(t string) string {\n\t\t// If we've seen this type before, append a number to it\n\t\tif seen[t] {\n\t\t\tcount := 1\n\t\t\tfor seen[t+fmt.Sprintf(\"[%d]\", count)] {\n\t\t\t\tcount++\n\t\t\t}\n\t\t\treturn t + fmt.Sprintf(\"[%d]\", count)\n\t\t}\n\n\t\t// Otherwise, add it to our set and return it\n\t\tseen[t] = true\n\t\treturn t\n\t}\n\n\t// Remove any brackets from the type string\n\tt = strings.ReplaceAll(t, \"[]\", \"\")\n\n\t// If the type is a primitive type, return it as is\n\tif t == \"int\" || t == \"bool\" || t == \"string\" || t == \"float64\" || t == \"uint\" || t == \"uint8\" || t == \"uint16\" || t == \"uint32\" || t == \"uint64\" || t == \"int8\" || t == \"int16\" || t == \"int32\" || t == \"int64\" {\n\t\treturn t\n\t}\n\n\t// Otherwise, recursively generate a unique name for the type\n\treturn uniqueNameHelper(t)\n}\n\nfunc main() {\n\tfmt.Println(uniqueName(\"int\"))  // prints: int\n\tfmt.Println(uniqueName(\"int\"))  // prints: int[1]\n\tfmt.Println(uniqueName(\"bool\")) // prints: bool\n\tfmt.Println(uniqueName(\"int bool\")) // prints: int bool\n\tfmt.Println(uniqueName(\"map[int]bool\")) // prints: map[int]bool\n\tfmt.Println(uniqueName(\"map[int]bool\")) // prints: map[int]bool[1]\n} \n```"]}, "weaver-internal/tool/certs/certs.go-GenerateSignedCert": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n# Natural Language Annotations: // GenerateSignedCert generates a certificate for the given DNS names, signed\n// by the given Certificate Authority, and a corresponding private key.\n//\n// The returned certificate has a one-year validity and should only ever\n// be used on a temporary basis.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n\tserialNumber, err := rand.Int(rand.Reader, big.NewInt(0xffffffffffffffffffffffffffffffff))\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to generate serial number\")\n\t}\n\n\ttemplate := &x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Example\"},\n\t\t\tCountry:      []string{\"US\"},\n\t\t},\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().AddDate(0, 1, 0),\n\t\tIsCA:                  false,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageDigitalSignature},\n\t\tDNSNames:              names,\n\t\tSignatureAlgorithm:      x509.SHA256WithRSA,\n\t\tSignature:              nil,\n\t\tBasicConstraintsValid:   true,\n\t\tDNSNames:               names,\n\t}\n\n\tderBytes, err := x509.CreateCertificate(rand.Reader, template, ca, &template.Subject, caKey)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to create certificate\")\n\t}\n\n\tcert, err := x509.ParseCertificate(derBytes)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to parse certificate\")\n\t}\n\n\tprivateKey, err := x509.MarshalPKCS1PrivateKey(caKey)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to marshal private key\")\n\t}\n\n\treturn cert, privateKey, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n\tserialNumber, err := rand.Int(rand.Reader, big.NewInt(0xffffffffffffffffffffffffffffffff))\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to generate serial number\")\n\t}\n\n\ttemplate := &x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"example.com\"},\n\t\t},\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().AddDate(0, 1, 0),\n\t\tIsCA:                  false,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageDigitalSignature},\n\t\tDNSNames:              names,\n\t\tSignatureAlgorithm:      x509.SHA256WithRSA,\n\t\tSignature:              nil,\n\t}\n\n\tpub, err := x509.CreateCertificate(rand.Reader, template, ca, &template.Subject, caKey)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to create certificate\")\n\t}\n\n\tcert, err := x509.ParseCertificate(pub)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to parse certificate\")\n\t}\n\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, nil, errors.Wrap(err, \"failed to generate private key\")\n\t}\n\n\treturn cert, privateKey, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"crypto/x509/pkix\"\n\t\"encoding/pem\"\n\t\"fmt\"\n\t\"math/big\"\n\t\"time\"\n)\n\nfunc GenerateSignedCert(ca *x509.Certificate, caKey crypto.PrivateKey, names ...string) (*x509.Certificate, crypto.PrivateKey, error) {\n\tserialNumber, err := rand.Int(rand.Reader, new(big.Int).Lsh(big.NewInt(1), 128))\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\ttemplate := &x509.Certificate{\n\t\tSerialNumber: serialNumber,\n\t\tSubject: pkix.Name{\n\t\t\tOrganization: []string{\"Generated Certificate\"},\n\t\t},\n\t\tNotBefore:             time.Now(),\n\t\tNotAfter:              time.Now().AddDate(0, 0, 365),\n\t\tIsCA:                  false,\n\t\tExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageDigitalSignature},\n\t\tKeyUsage:              x509.KeyUsageDigitalSignature,\n\t\tDNSNames:              names,\n\t\tBasicConstraintsValid:  true,\n\t}\n\n\tcertBytes, err := x509.CreateCertificate(rand.Reader, template, ca, &template.Subject, caKey)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tcert, err := x509.ParseCertificate(certBytes)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\tprivateKey, err := rsa.GenerateKey(rand.Reader, 2048)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\n\treturn cert, privateKey, nil\n}\n```"]}, "weaver-internal/weaver/load.go-updateAssignment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (lc *loadCollector) updateAssignment(assignment *protos.Assignment) {\n# Natural Language Annotations: // updateAssignment updates a load collector with the latest assignment. The\n// load reported by a load collector is always scoped to a single assignment.\n// A load report never spans more than one assignment. Thus, UpdateAssignment\n// also clears the load collector's accumulated load.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass LoadCollector:\n    def __init__(self):\n        self.accumulated_load = 0\n        self.assignment = None\n\n    def update_assignment(self, assignment):\n        \"\"\"\n        Updates a load collector with the latest assignment.\n        \n        The load reported by a load collector is always scoped to a single assignment.\n        A load report never spans more than one assignment. Thus, UpdateAssignment\n        also clears the load collector's accumulated load.\n        \n        Args:\n            assignment (protos.Assignment): The latest assignment.\n        \"\"\"\n        self.accumulated_load = 0\n        self.assignment = assignment\n```", "```go\nfunc (lc *loadCollector) updateAssignment(assignment *protos.Assignment) {\n    lc.accumulatedLoad = nil\n    lc.assignment = assignment\n}\n```", "```python\nclass LoadCollector:\n    def __init__(self):\n        self.accumulated_load = 0\n        self.assignment = None\n\n    def update_assignment(self, assignment):\n        \"\"\"\n        updateAssignment updates a load collector with the latest assignment. \n        The load reported by a load collector is always scoped to a single assignment.\n        A load report never spans more than one assignment. Thus, UpdateAssignment \n        also clears the load collector's accumulated load.\n        \"\"\"\n        self.accumulated_load = 0\n        self.assignment = assignment\n```"]}, "weaver-internal/weaver/load.go-report": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (lc *loadCollector) report() *protos.LoadReport_ComponentLoad {\n# Natural Language Annotations: // report returns a report of the collected load. If the load collector\n// doesn't have any collected load---this is possible if the load collector\n// doesn't have an assignment yet---then Report returns nil.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass LoadCollector:\n    def __init__(self):\n        self.load = None\n\n    def report(self):\n        \"\"\"\n        Returns a report of the collected load. If the load collector doesn't have any collected load,\n        this is possible if the load collector doesn't have an assignment yet---then Report returns None.\n        \"\"\"\n        return self.load\n```", "```python\nclass LoadCollector:\n    def __init__(self):\n        self.load = None\n\n    def assign_load(self, load):\n        self.load = load\n\n    def report(self) -> 'protos.LoadReport_ComponentLoad':\n        return self.load\n```", "```python\nclass LoadCollector:\n    def __init__(self):\n        self.load = None\n\n    def report(self):\n        \"\"\"\n        Returns a report of the collected load. \n        If the load collector doesn't have any collected load---this is possible if the load collector\n        doesn't have an assignment yet---then Report returns None.\n        \"\"\"\n        return self.load\n```"]}, "weaver-internal/weaver/load.go-subslices": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func subslices(load float64, xs []uint64, n int) []*protos.LoadReport_SubsliceLoad {\n# Natural Language Annotations: // subslices returns n splits of the provided points with roughly the same\n// load. For example, given xs = []uint64{10, 20, 30, 40, 50, 60, 70, 80}, n =\n// 4, and a load of 10.0, subslices will return the following four splits:\n//\n//   - {Start: 10, Load: 2.5} // [10, 30)\n//   - {Start: 30, Load: 2.5} // [30, 50)\n//   - {Start: 50, Load: 2.5} // [50, 70)\n//   - {Start: 70, Load: 2.5} // [70, infinity)\n//\n// The returned splits are as even as possible on a best effort basis.\n// subslices only guarantees that the returned splits are contiguous and\n// sorted.\n//\n// REQUIRES xs is sorted in increasing order\n// REQUIRES n > 0\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype LoadReport_SubsliceLoad struct {\n\tStart uint64\n\tLoad  float64\n}\n\nfunc subslices(load float64, xs []uint64, n int) []*LoadReport_SubsliceLoad {\n\tvar report []*LoadReport_SubsliceLoad\n\tvar currentStart uint64 = 0\n\tvar currentLoad float64 = 0.0\n\n\tfor i := 0; i < len(xs); i++ {\n\t\tcurrentLoad += float64(xs[i] - xs[i-1]) / float64(len(xs))\n\t\tif float64(i+1) == len(xs) || currentLoad >= load {\n\t\t\tif currentLoad >= load {\n\t\t\t\t// last slice, just add the remaining load\n\t\t\t\treport = append(report, &LoadReport_SubsliceLoad{\n\t\t\t\t\tStart: xs[i],\n\t\t\t\t\tLoad:  load,\n\t\t\t\t})\n\t\t\t} else {\n\t\t\t\t// calculate the load for the current slice\n\t\t\t\treport = append(report, &LoadReport_SubsliceLoad{\n\t\t\t\t\tStart: xs[i],\n\t\t\t\t\tLoad:  currentLoad,\n\t\t\t\t})\n\t\t\t}\n\t\t\tcurrentStart = xs[i]\n\t\t\tcurrentLoad = 0\n\t\t\tn--\n\t\t\tif n == 0 {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\treturn report\n}\n\nfunc main() {\n\txs := []uint64{10, 20, 30, 40, 50, 60, 70, 80}\n\tn := 4\n\tload := 10.0\n\tfmt.Println(subslices(load, xs, n))\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\ntype LoadReport_SubsliceLoad struct {\n    Start uint64\n    Load float64\n}\n\nfunc subslices(load float64, xs []uint64, n int) []*LoadReport_SubsliceLoad {\n    if n == 0 || len(xs) == 0 {\n        return []*LoadReport_SubsliceLoad{}\n    }\n\n    var result []*LoadReport_SubsliceLoad\n    var start uint64 = xs[0]\n    var end uint64\n    var totalLoad float64\n    for _, x := range xs {\n        totalLoad += float64(x)\n    }\n\n    for i := 0; i < n; i++ {\n        var loadPerSubslice float64\n        if n == 1 {\n            loadPerSubslice = totalLoad\n        } else {\n            loadPerSubslice = totalLoad / float64(n)\n        }\n\n        end = start\n        for _, x := range xs {\n            if totalLoad-float64(end-start) < loadPerSubslice {\n                end = x\n                break\n            }\n            totalLoad -= float64(x)\n        }\n\n        result = append(result, &LoadReport_SubsliceLoad{\n            Start: start,\n            Load:  loadPerSubslice,\n        })\n\n        if end < xs[len(xs)-1] {\n            start = end\n        } else {\n            start = end\n            break\n        }\n    }\n\n    return result\n}\n\nfunc main() {\n    xs := []uint64{10, 20, 30, 40, 50, 60, 70, 80}\n    n := 4\n    load := 10.0\n    result := subslices(load, xs, n)\n    for _, report := range result {\n        fmt.Printf(\"Start: %d, Load: %f\\n\", report.Start, report.Load)\n    }\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\ntype LoadReport_SubsliceLoad struct {\n\tStart uint64\n\tLoad  float64\n}\n\nfunc subslices(load float64, xs []uint64, n int) []*LoadReport_SubsliceLoad {\n\tif n == 1 {\n\t\treturn []*LoadReport_SubsliceLoad{\n\t\t\t{Start: xs[0], Load: load},\n\t\t}\n\t}\n\n\tvar total uint64\n\tfor _, x := range xs {\n\t\ttotal += x\n\t}\n\tavgLoad := load * float64(n)\n\tsplits := make([]*LoadReport_SubsliceLoad, n)\n\tsplits[0] = &LoadReport_SubsliceLoad{\n\t\tStart: xs[0],\n\t\tLoad:  load,\n\t}\n\n\tfor i := 1; i < n; i++ {\n\t\tstart := xs[i-1]\n\t\tend := uint64(math.Ceil(float64(total) / float64(n-i+1)))\n\t\tsplits[i] = &LoadReport_SubsliceLoad{\n\t\t\tStart: start,\n\t\t\tLoad:  load,\n\t\t}\n\t\ttotal -= end - start\n\t}\n\n\tsplits[n-1].Load = float64(total) / float64(n)\n\tsplits[n-1].Start = xs[len(xs)-1]\n\n\treturn splits\n}\n\nfunc main() {\n\txs := []uint64{10, 20, 30, 40, 50, 60, 70, 80}\n\tn := 4\n\tload := 10.0\n\tsplits := subslices(load, xs, n)\n\tfor _, split := range splits {\n\t\tfmt.Printf(\"Start: %d, Load: %.2f\\n\", split.Start, split.Load)\n\t}\n}\n```"]}, "weaver-internal/weaver/routing.go-update": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (rb *routingBalancer) update(assignment *protos.Assignment) {\n# Natural Language Annotations: // update updates the balancer with the provided assignment\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass RoutingBalancer:\n    def update(self, assignment: 'protos.Assignment'):\n        # update updates the balancer with the provided assignment\n        self.assignment = assignment\n```", "```python\nclass RoutingBalancer:\n    def __init__(self):\n        self.assignments = {}\n\n    def update(self, assignment: 'protos.Assignment') -> None:\n        self.assignments[assignment.id] = assignment\n```", "```python\nclass RoutingBalancer:\n    def __init__(self):\n        self.assignments = {}\n\n    def update(self, assignment: 'protos.Assignment'):\n        if assignment.id in self.assignments:\n            self.assignments[assignment.id] = assignment\n        else:\n            self.assignments[assignment.id] = assignment\n```"]}, "weaver-internal/status/registry.go-NewRegistry": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewRegistry(_ context.Context, dir string) (*Registry, error) {\n# Natural Language Annotations: // NewRegistry returns a registry that persists data to the provided directory.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewRegistry(ctx context.Context, dir string) (*Registry, error) {\n    // Create a new registry object\n    registry := &Registry{\n        dir: dir,\n    }\n\n    // Initialize the registry\n    if err := registry.init(); err != nil {\n        return nil, err\n    }\n\n    return registry, nil\n}\n\ntype Registry struct {\n    dir string\n    // Add other fields as needed\n}\n\nfunc (r *Registry) init() error {\n    // Create the directory if it doesn't exist\n    if err := os.MkdirAll(r.dir, 0755); err != nil {\n        return err\n    }\n\n    // Initialize the internal data structures\n    // This can be a database, a file, or any other data storage\n    // For simplicity, let's assume it's a file\n    file, err := os.Create(r.dir + \"/data.json\")\n    if err != nil {\n        return err\n    }\n    defer file.Close()\n\n    // Initialize the data\n    data := []byte(`{}`)\n\n    if _, err := file.Write(data); err != nil {\n        return err\n    }\n\n    return nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"sync\"\n)\n\n// Registry represents a registry that persists data to a directory.\ntype Registry struct {\n\tdir string\n\tmu  sync.RWMutex\n\tdata map[string]string\n}\n\n// NewRegistry returns a registry that persists data to the provided directory.\nfunc NewRegistry(ctx context.Context, dir string) (*Registry, error) {\n\tif err := os.MkdirAll(dir, 0755); err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata, err := readDataFromFile(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &Registry{\n\t\tdir: dir,\n\t\tdata: make(map[string]string),\n\t}, nil\n}\n\nfunc readDataFromFile(dir string) (map[string]string, error) {\n\tfiles, err := os.ReadDir(dir)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdata := make(map[string]string)\n\tfor _, file := range files {\n\t\tif file.IsDir() {\n\t\t\tcontinue\n\t\t}\n\n\t\tdata[file.Name()], err = os.ReadFile(filepath.Join(dir, file.Name()))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn data, nil\n}\n\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"os\"\n)\n\ntype Registry struct {\n    dir string\n}\n\nfunc NewRegistry(ctx context.Context, dir string) (*Registry, error) {\n    if err := os.MkdirAll(dir, 0755); err != nil {\n        return nil, err\n    }\n    return &Registry{dir: dir}, nil\n}\n\nfunc (r *Registry) SaveData(ctx context.Context, data string) error {\n    filename := \"data.txt\"\n    filepath := fmt.Sprintf(\"%s/%s\", r.dir, filename)\n    if err := ioutil.WriteFile(filepath, []byte(data), 0644); err != nil {\n        return err\n    }\n    return nil\n}\n\nfunc main() {\n    ctx := context.Background()\n    dir := \"./registry\"\n    registry, err := NewRegistry(ctx, dir)\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err := registry.SaveData(ctx, \"Hello, World!\"); err != nil {\n        log.Fatal(err)\n    }\n}\n```"]}, "weaver-internal/routing/routing.go-FormatAssignment": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FormatAssignment(a *protos.Assignment) string {\n# Natural Language Annotations: // FormatAssignment pretty formats the provided assignment.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef format_assignment(a):\n    \"\"\"\n    FormatAssignment pretty formats the provided assignment.\n    \n    Args:\n        a (protos.Assignment): Assignment object to be formatted.\n    \n    Returns:\n        str: The formatted assignment string.\n    \"\"\"\n    return f\"{a.name}: {a.value}\"\n```", "```python\ndef format_assignment(a):\n    \"\"\"\n    FormatAssignment pretty formats the provided assignment.\n\n    Args:\n        a (protos.Assignment): The assignment to be formatted.\n\n    Returns:\n        string: The formatted assignment.\n    \"\"\"\n    return f\"{a.name} = {a.value}\"\n```", "```python\ndef format_assignment(a):\n    \"\"\"\n    FormatAssignment pretty formats the provided assignment.\n\n    Args:\n        a (protos.Assignment): The assignment to be formatted.\n\n    Returns:\n        str: The formatted assignment.\n    \"\"\"\n    return f\"Assignment {a.id}: {a.name} - {a.description}\"\n```"]}, "weaver-internal/routing/routing.go-EqualSlices": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EqualSlices(replicas []string) *protos.Assignment {\n# Natural Language Annotations: // EqualSlices returns an assignment with slices of roughly equal size.\n// Replicas are assigned to slices in a round robin fashion. The returned\n// assignment has a version of 0.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"sort\"\n\t\"fmt\"\n)\n\ntype Assignment struct {\n\tSlices [][]string\n\tVersion int\n}\n\nfunc EqualSlices(replicas []string) *Assignment {\n\tassignment := &Assignment{\n\t\tSlices: make([][]string, len(replicas)),\n\t\tVersion: 0,\n\t}\n\n\tsort.Strings(replicas)\n\n\t// Calculate the size of each slice\n\tsliceSize := len(replicas) / len(assignment.Slices)\n\tremainder := len(replicas) % len(assignment.Slices)\n\n\t// Assign replicas to slices in a round robin fashion\n\tfor i := 0; i < len(replicas); i++ {\n\t\tsliceIndex := i % len(assignment.Slices)\n\t\tif sliceIndex >= len(assignment.Slices) {\n\t\t\tsliceIndex = len(assignment.Slices) - 1\n\t\t}\n\t\tassignment.Slices[sliceIndex] = append(assignment.Slices[sliceIndex], replicas[i])\n\t}\n\n\treturn assignment\n}\n\nfunc main() {\n\treplicas := []string{\"replica1\", \"replica2\", \"replica3\", \"replica4\", \"replica5\"}\n\tassignment := EqualSlices(replicas)\n\tfmt.Println(assignment)\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype Assignment struct {\n\tSlices [][]string\n\tVersion int\n}\n\nfunc EqualSlices(replicas []string) *Assignment {\n\tsort.Strings(replicas)\n\tn := len(replicas)\n\tsliceSize := n / len(replicas)\n\tremaining := n % len(replicas)\n\tslices := make([][]string, len(replicas))\n\tfor i := 0; i < len(replicas); i++ {\n\t\tsliceSizeWithRemaining := sliceSize + 1\n\t\tif remaining > 0 {\n\t\t\tsliceSizeWithRemaining++\n\t\t\tremaining--\n\t\t}\n\t\tslices[i] = replicas[i * sliceSizeWithRemaining : (i+1) * sliceSizeWithRemaining]\n\t}\n\treturn &Assignment{\n\t\tSlices: slices,\n\t\tVersion: 0,\n\t}\n}\n\nfunc main() {\n\treplicas := []string{\"a\", \"b\", \"c\", \"d\", \"e\", \"f\"}\n\tassignment := EqualSlices(replicas)\n\tfmt.Println(assignment)\n}\n```", "```python\nfrom collections import deque\n\nclass Assignment:\n    def __init__(self, version):\n        self.version = version\n        self.slices = []\n\ndef EqualSlices(replicas):\n    assignment = Assignment(0)\n    queue = deque(replicas)\n    while queue:\n        assignment.slices.append(list(queue)[:len(queue)//len(replicas)+1])\n        queue = deque([item for sublist in assignment.slices for item in sublist] - list(queue))\n    return assignment\n```"]}, "weaver-internal/queue/queue.go-Pop": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (q *Queue[T]) Pop(ctx context.Context) (elem T, err error) {\n# Natural Language Annotations: // Pop removes the element from the front of the queue and returns it.\n// It blocks if the queue is empty.\n// It returns an error if the passed-in context is canceled.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom queue import Queue\nfrom typing import TypeVar, Generic\nfrom contextlib import contextmanager\n\nT = TypeVar('T')\n\nclass Queue(Generic[T]):\n    def __init__(self):\n        self.queue = []\n\n    def put(self, item: T):\n        self.queue.append(item)\n\n    def pop(self) -> T:\n        if not self.queue:\n            raise Exception(\"Queue is empty\")\n        return self.queue.pop(0)\n\n@contextmanager\ndef get_context():\n    try:\n        yield\n    except Exception as e:\n        raise e\n\ndef pop(q: Queue[T], ctx=None) -> (T, Exception):\n    if ctx is not None:\n        with get_context():\n            return q.pop(), None\n    else:\n        return q.pop(), None\n```", "```python\nfrom queue import Queue\nfrom typing import TypeVar, Generic\nfrom contextlib import contextmanager\nfrom concurrent.futures import ThreadPoolExecutor\n\nT = TypeVar('T')\n\nclass Queue(Generic[T]):\n    def __init__(self):\n        self.queue = []\n\n    def put(self, item: T):\n        self.queue.append(item)\n\n    def pop(self):\n        return self.queue.pop(0)\n\nclass Context:\n    def __init__(self):\n        self.done = False\n\n    def cancel(self):\n        self.done = True\n\ndef pop(q: Queue[T], ctx: Context) -> (T, Exception):\n    with contextmanager(ThreadPoolExecutor()):\n        while True:\n            try:\n                return q.pop(), None\n            except IndexError:\n                if ctx.done:\n                    return None, Exception(\"Context canceled\")\n                pass\n```", "```sql\nfunc (q *Queue[T]) Pop(ctx context.Context) (elem T, err error) {\n    select {\n    case elem, ok := <-q Chan:\n        if !ok {\n            return elem, errors.New(\"queue is empty\")\n        }\n        return elem, nil\n    case <-ctx.Done():\n        return elem, ctx.Err()\n    }\n}\n```"]}, "weaver-internal/pipe/pipe.go-MakePipePair": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Cmd) MakePipePair() (PipePair, error) {\n# Natural Language Annotations: // MakePipePair makes a pair of pipes that can be used for bi-directional\n// communication with the child process.\n//\n// Cmd.ExtraFiles should not be modified directly if MakePipePair is called.\n//\n// Wait will close ParentWriter automatically after seeing the command exit. A\n// caller need only close ParentWriter to force the pipe to close sooner. For\n// example, if the command being run will not exit until standard input is\n// closed, the caller must close ParentWriter.\n//\n// Wait will close ParentReader automatically after seeing the command exit, so\n// most callers need not close ParentReader themselves. It is thus incorrect to\n// call Wait before all reads from ParentReader have completed. For the same\n// reason, it is incorrect to use Run when using MakePipePair. See the\n// exec.Cmd.StdoutPipe example [1] for idiomatic usage.\n//\n// [1]: https://pkg.go.dev/os/exec#example-Cmd.StdoutPipe\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (c *Cmd) MakePipePair() (PipePair, error) {\n    parentReader, err := c.StdoutPipe()\n    if err != nil {\n        return nil, err\n    }\n\n    parentWriter, err := c.StdinPipe()\n    if err != nil {\n        return nil, err\n    }\n\n    return PipePair{Reader: parentReader, Writer: parentWriter}, nil\n}\n\ntype PipePair struct {\n    Reader  io.Reader\n    Writer  io.Writer\n}\n```", "```go\nfunc (c *Cmd) MakePipePair() (PipePair, error) {\n    var (\n        parentReader, parentWriter, childReader, childWriter = os.Pipe()\n    )\n    c.ExtraFiles = append(c.ExtraFiles, parentWriter)\n    c.ExtraFiles = append(c.ExtraFiles, childWriter)\n    return PipePair{parentReader, childWriter, childReader}, nil\n}\n\ntype PipePair struct {\n    ParentReader  io.Reader\n    ParentWriter  io.Writer\n    ChildReader   io.Reader\n    ChildWriter   io.Writer\n}\n```", "```go\nfunc (c *Cmd) MakePipePair() (PipePair, error) {\n    parentReader, parentWriter, childReader, childWriter := os.Pipe()\n    c.ExtraFiles = append(c.ExtraFiles, parentWriter, childReader)\n    return PipePair{parentReader, childWriter}, nil\n}\n\ntype PipePair struct {\n    ParentReader  *os.File\n    ChildWriter   *os.File\n}\n```"]}, "weaver-internal/register/writeonce.go-Write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) Write(val T) {\n# Natural Language Annotations: // Write writes to the register, or panics if the register was already written.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass WriteOnce:\n    def __init__(self):\n        self.written = False\n\n    def write(self, val):\n        if self.written:\n            raise Exception(\"Register was already written\")\n        self.written = True\n        return val\n```", "```python\nclass WriteOnce:\n    def __init__(self):\n        self.written = False\n\n    def write(self, val):\n        if self.written:\n            raise ValueError(\"Register was already written\")\n        self.written = True\n        print(val)\n```", "```python\nclass WriteOnce:\n    def __init__(self):\n        self.written = False\n        self.value = None\n\n    def write(self, val):\n        if self.written:\n            raise Exception(\"Register was already written\")\n        self.value = val\n        self.written = True\n```"]}, "weaver-internal/register/writeonce.go-TryWrite": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) TryWrite(val T) bool {\n# Natural Language Annotations: // TryWrite tries to write to the register and returns if the write succeeds.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass WriteOnce:\n    def __init__(self):\n        self.value = None\n\n    def TryWrite(self, val):\n        if self.value is None:\n            self.value = val\n            return True\n        return False\n```", "```python\nclass WriteOnce:\n    def __init__(self):\n        self.value = None\n\n    def TryWrite(self, val):\n        if self.value is None:\n            self.value = val\n            return True\n        return False\n```", "```python\nclass WriteOnce:\n    def __init__(self):\n        self.written = False\n\n    def TryWrite(self, val):\n        if not self.written:\n            self.write(val)\n            self.written = True\n            return True\n        return False\n\n    def write(self, val):\n        # implementation of the write operation\n        pass\n```"]}, "weaver-internal/register/writeonce.go-Read": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (w *WriteOnce[T]) Read() T {\n# Natural Language Annotations: // Read returns the value of the register, blocking until it is written.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass WriteOnce:\n    def __init__(self, initial_value=None):\n        self._value = initial_value\n        self._written = False\n\n    def write(self, value):\n        if not self._written:\n            self._value = value\n            self._written = True\n\n    def read(self):\n        while not self._written:\n            pass\n        return self._value\n```", "```python\nfrom threading import Condition\n\nclass WriteOnce:\n    def __init__(self):\n        self.value = None\n        self.lock = Condition()\n\n    def write(self, value):\n        with self.lock:\n            if self.value is not None:\n                raise ValueError(\"Cannot write to a WriteOnce after it has been written\")\n            self.value = value\n            self.lock.notify_all()\n\n    def read(self):\n        with self.lock:\n            while self.value is None:\n                self.lock.wait()\n            return self.value\n```", "```python\nfrom threading import Lock\nfrom typing import TypeVar\n\nT = TypeVar('T')\n\nclass WriteOnce:\n    def __init__(self):\n        self.value = None\n        self.lock = Lock()\n\n    def write(self, val: T):\n        with self.lock:\n            if self.value is not None:\n                raise ValueError(\"Cannot write to a WriteOnce object after it has been written to.\")\n            self.value = val\n\n    def read(self) -> T:\n        with self.lock:\n            if self.value is None:\n                raise ValueError(\"Cannot read from a WriteOnce object before it has been written to.\")\n            return self.value\n```"]}, "weaver-internal/versioned/versioned.go-RLock": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (v *Versioned[T]) RLock(version string) string {\n# Natural Language Annotations: // RLock waits until the current version is different than the passed-in\n// version, and then acquires the read lock and returns the new\n// version.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Versioned:\n    def __init__(self, version):\n        self.version = version\n        self.lock = False\n\n    def RLock(self, version):\n        while self.version == version:\n            if self.lock:\n                pass  # busy wait\n        self.lock = True\n        return self.version\n```", "```python\nclass Versioned:\n    def __init__(self, initial_version):\n        self.version = initial_version\n        self.lock = threading.Lock()\n        self.read_lock = threading.Lock()\n\n    def RLock(self, version):\n        while self.version == version:\n            with self.read_lock:\n                if self.version == version:\n                    time.sleep(0.01)  # sleep for a short time to avoid busy waiting\n        with self.read_lock:\n            new_version = self.version\n            return new_version\n```", "```go\nfunc (v *Versioned[T]) RLock(version string) (string, error) {\n    if v.version != version {\n        v.mu.RLock()\n        defer v.mu.RUnlock()\n        return v.version, nil\n    }\n    return \"\", errors.New(\"version has not changed\")\n}\n```"]}, "weaver-internal/net/call/stub.go-makeStubMethods": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func makeStubMethods(fullName string, reg *codegen.Registration) []stubMethod {\n# Natural Language Annotations: // makeStubMethods returns a slice of stub methods for the component methods of reg.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef makeStubMethods(fullName: str, reg: 'codegen.Registration') -> list:\n    \"\"\"\n    Returns a slice of stub methods for the component methods of reg.\n    \n    :param fullName: The full name of the component.\n    :param reg: The registration object containing the component methods.\n    :return: A list of stub methods.\n    \"\"\"\n    stubs = []\n    for method in reg.methods:\n        stub = f\"\"\"\ndef {method.name}({', '.join([param.name for param in method.params])}):\n    pass\n\"\"\"\n        stubs.append(stub)\n    return stubs\n```", "```python\ndef makeStubMethods(fullName: str, reg) -> list:\n    # Initialize an empty list to store the stub methods\n    stubMethods = []\n    \n    # Iterate over each method in the registration\n    for method in reg.methods:\n        # Extract the method name\n        methodName = method.name\n        \n        # Create a stub method function\n        def stubMethod(*args, **kwargs):\n            # Print a message indicating that the method is not implemented\n            print(f\"{fullName}.{methodName} is not implemented\")\n        \n        # Add the stub method to the list\n        stubMethods.append(stubMethod)\n    \n    # Return the list of stub methods\n    return stubMethods\n```", "```python\ndef make_stub_methods(full_name: str, reg) -> list:\n    \"\"\"\n    Returns a list of stub methods for the component methods of reg.\n\n    Args:\n        full_name (str): The full name of the component.\n        reg (codegen.Registration): The registration object containing component methods.\n\n    Returns:\n        list: A list of stub methods.\n    \"\"\"\n    # Initialize an empty list to store the stub methods\n    stub_methods = []\n\n    # Iterate over the component methods in the registration object\n    for method in reg.component_methods:\n        # Create a stub method with the method name and full name as attributes\n        stub_method = {\n            'name': method.name,\n            'full_name': full_name,\n            'return_type': method.return_type,\n            'params': method.params,\n            'description': method.description\n        }\n        \n        # Add the stub method to the list\n        stub_methods.append(stub_method)\n\n    # Return the list of stub methods\n    return stub_methods\n```"]}, "weaver-internal/net/call/call.go-Serve": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Serve(ctx context.Context, l Listener, opts ServerOptions) error {\n# Natural Language Annotations: // Serve starts listening for connections and requests on l. It always returns a\n// non-nil error and closes l.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc Serve(ctx context.Context, l net.Listener, opts ServerOptions) error {\n    defer func() {\n        if err := l.Close(); err != nil {\n            log.Println(\"error closing listener:\", err)\n        }\n    }()\n\n    for {\n        conn, err := l.Accept()\n        if err != nil {\n            return err\n        }\n        go func(conn net.Conn) {\n            defer conn.Close()\n            // handle the connection here\n        }(conn)\n    }\n}\n```", "```python\ndef serve(ctx, listener, opts):\n    # Serve starts listening for connections and requests on l. It always returns a non-nil error and closes l.\n    # For simplicity, we'll assume that the listener is a socket object and opts is a dictionary of server options\n    try:\n        listener.listen(opts.get('port', 8080))\n        while True:\n            conn, addr = listener.accept()\n            # Handle incoming connection\n            handle_connection(ctx, conn, opts)\n    except Exception as e:\n        return e\n    finally:\n        listener.close()\n```", "```go\nfunc Serve(ctx context.Context, l Listener, opts ServerOptions) error {\n    defer l.Close() // close the listener when Serve returns\n    if err := l.ListenAndServe(ctx, opts); err != nil {\n        return err\n    }\n    return errors.New(\"listener is closed\") // always return a non-nil error\n}\n```"]}, "weaver-internal/net/call/call.go-Connect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Connect(ctx context.Context, resolver Resolver, opts ClientOptions) (Connection, error) {\n# Natural Language Annotations: // Connect creates a connection to the servers at the endpoints returned by the\n// resolver.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Context, Resolver, ClientOptions, Connection\n\ndef Connect(ctx: Context, resolver: Resolver, opts: ClientOptions) -> (Connection, error):\n    # Connect creates a connection to the servers at the endpoints returned by the resolver.\n    # For simplicity, we'll assume Connection and ClientOptions are custom classes\n    # and error is a built-in exception\n    try:\n        endpoints = resolver.get_endpoints()\n        connection = Connection(endpoints, opts)\n        return connection, None\n    except Exception as e:\n        return None, e\n```", "```python\nfrom typing import Context, Resolver, ClientOptions, Connection\n\ndef Connect(ctx: Context, resolver: Resolver, opts: ClientOptions) -> tuple[Connection, Exception]:\n    # Create a connection to the servers at the endpoints returned by the resolver.\n    connection = resolver.resolve(opts)\n    return connection, None  # Assuming resolver.resolve() returns a Connection object and doesn't raise any exceptions\n```", "```python\nfrom typing import Context, Resolver, ClientOptions, Connection\n\ndef connect(ctx: Context, resolver: Resolver, opts: ClientOptions) -> Connection:\n    # Create a connection to the servers at the endpoints returned by the resolver.\n    # For simplicity, let's assume the resolver returns a list of endpoints\n    endpoints = resolver.get_endpoints()\n    \n    # Initialize an empty connection\n    connection = None\n    \n    try:\n        # Attempt to connect to each endpoint in the list\n        for endpoint in endpoints:\n            # Assuming a connection function is available\n            connection = connect_to_endpoint(endpoint, opts)\n            if connection:\n                break  # If a connection is established, stop trying other endpoints\n        if not connection:\n            return None, \"Failed to connect to any endpoint\"\n    except Exception as e:\n        return None, str(e)\n    \n    return connection, None\n```"]}, "weaver-internal/net/call/msg.go-writeMessage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n# Natural Language Annotations: // # Message formats\n//\n// All messages have the following format:\n//    id        [8]byte       -- identifier used to track the message\n//    type      [1]byte       -- messageType\n//    length    [7]byte       -- length of the remainder of the message\n//    payload   [length]byte  -- message-type-specific data\n//\n// The format of payload depends on the message type.\n//\n// versionMessage: this is the first message sent on a connection by both sides.\n//    version  [4]byte\n//\n// requestMessage:\n//    headerLen         [4]byte         -- length of the encoded header\n//    header            [headerLen]byte -- encoded header information\n//    payload                           -- call argument serialization\n//\n// The header is encoded using Service Weaver's encoding format for a type that\n// looks like:\n//\n// struct header {\n//   MethodKey       [16]byte\n//   Deadline        int64\n//   TraceContext    [25]byte\n//   MetadataContext map[string]string\n// }\n//\n// responseMessage:\n//    payload holds call result serialization\n//\n// responseError:\n//    payload holds error serialization\n//\n// cancelMessage:\n//    payload is empty\n// writeMessage formats and sends a message over w.\n//\n// The message payload is formed by concatenating extraHdr and payload.\n// (Allowing two arguments to form the payload avoids unnecessary allocation\n// and copying when we want to prepend some data to application supplied data).\n//\n// The write is guarded by wlock, which must not be locked when passed in.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"errors\"\n    \"sync\"\n)\n\nfunc writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n    // Write the id\n    if err := binary.Write(w, binary.BigEndian, id); err != nil {\n        return err\n    }\n\n    // Write the message type\n    if err := binary.Write(w, binary.BigEndian, mt); err != nil {\n        return err\n    }\n\n    // Calculate the length of the message\n    length := len(extraHdr) + len(payload)\n    if err := binary.Write(w, binary.BigEndian, uint64(length)); err != nil {\n        return err\n    }\n\n    // Write the payload\n    if err := binary.Write(w, binary.BigEndian, extraHdr); err != nil {\n        return err\n    }\n    if err := binary.Write(w, binary.BigEndian, payload); err != nil {\n        return err\n    }\n\n    // Acquire the lock to ensure exclusive access to the writer\n    wlock.Lock()\n    defer wlock.Unlock()\n\n    // Write to the writer\n    if _, err := w.Write([]byte{}); err != nil {\n        return err\n    }\n\n    return nil\n}\n```", "```go\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"sync\"\n)\n\nfunc writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n    // Lock the writer to prevent concurrent access\n    wlock.Lock()\n    defer wlock.Unlock()\n\n    // Create the message header\n    var header [9]byte\n    binary.BigEndian.PutUint64(header[:8], id)\n    header[8] = mt\n\n    // Determine the length of the payload\n    payloadLength := len(extraHdr) + len(payload)\n    if payloadLength > flattenLimit {\n        return errors.New(\"payload exceeds the maximum allowed size\")\n    }\n\n    // Write the payload length to the header\n    binary.BigEndian.PutUint64(header[8+1:], uint64(payloadLength))\n\n    // Create the full message\n    message := append(header[:], extraHdr...)\n    message = append(message, payload...)\n\n    // Write the message to the writer\n    _, err := w.Write(message)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```", "```go\npackage main\n\nimport (\n    \"encoding/binary\"\n    \"errors\"\n    \"sync\"\n)\n\nfunc writeMessage(w io.Writer, wlock *sync.Mutex, mt messageType, id uint64, extraHdr []byte, payload []byte, flattenLimit int) error {\n    // First, we need to lock the writer to prevent concurrent writes\n    wlock.Lock()\n    defer wlock.Unlock()\n\n    // Create a byte slice to hold the message\n    msg := make([]byte, 8+1+7+len(extraHdr)+len(payload))\n\n    // Write the id\n    binary.LittleEndian.PutUint64(msg[0:8], id)\n\n    // Write the message type\n    msg[8] = byte(mt)\n\n    // Calculate the length of the message\n    length := 7 + len(extraHdr) + len(payload)\n    binary.LittleEndian.PutUint64(msg[9:16], uint64(length))\n\n    // Write the extra header\n    copy(msg[16:16+len(extraHdr)], extraHdr)\n\n    // Write the payload\n    copy(msg[16+len(extraHdr):], payload)\n\n    // Write the message\n    _, err := w.Write(msg)\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```"]}, "weaver-internal/net/call/trace.go-writeTraceContext": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func writeTraceContext(ctx context.Context, enc *codegen.Encoder) {\n# Natural Language Annotations: // writeTraceContext serializes the trace context (if any) contained in ctx\n// into enc.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef write_trace_context(ctx):\n    \"\"\"\n    Serialize the trace context (if any) contained in ctx into the encoder.\n    \n    :param ctx: The context containing the trace context to be serialized.\n    :return: None\n    \"\"\"\n    # Check if the context is not None\n    if ctx is not None:\n        # Extract the trace context from the context\n        trace_context = ctx.get(\"trace_context\")\n        \n        # Check if the trace context is not None\n        if trace_context is not None:\n            # Serialize the trace context into the encoder\n            # Assuming the encoder has a method to serialize the trace context\n            # For example, let's assume it's a dictionary\n            enc = ctx.get(\"encoder\")\n            if enc is not None:\n                enc.serialize(trace_context)\n```", "```python\ndef write_trace_context(ctx, enc):\n    \"\"\"\n    Serializes the trace context (if any) contained in ctx into enc.\n    \n    :param ctx: The context to serialize\n    :param enc: The encoder to use for serialization\n    \"\"\"\n    if hasattr(ctx, 'TraceContext') and ctx.TraceContext:\n        # Assuming TraceContext is a custom struct with a method to serialize itself\n        enc.Write(ctx.TraceContext.SerializeToString())\n    else:\n        enc.Write(b'')\n```", "```go\nfunc writeTraceContext(ctx context.Context, enc *codegen.Encoder) {\n    traceId := ctx.Value(contextKeyTraceID)\n    if traceId != nil {\n        err := enc.WriteInt64(\"trace_id\", traceId.(int64))\n        if err != nil {\n            // handle error\n        }\n    }\n\n    spanId := ctx.Value(contextKeySpanID)\n    if spanId != nil {\n        err := enc.WriteInt64(\"span_id\", spanId.(int64))\n        if err != nil {\n            // handle error\n        }\n    }\n\n    if parentSpanID := ctx.Value(contextKeyParentSpanID); parentSpanID != nil {\n        err := enc.WriteInt64(\"parent_span_id\", parentSpanID.(int64))\n        if err != nil {\n            // handle error\n        }\n    }\n\n    if traceFlags := ctx.Value(contextKeyTraceFlags); traceFlags != nil {\n        err := enc.WriteInt64(\"trace_flags\", traceFlags.(int64))\n        if err != nil {\n            // handle error\n        }\n    }\n\n    if baggage := ctx.Value(contextKeyBaggage); baggage != nil {\n        err := enc.WriteObject(\"baggage\", baggage.(map[string]string))\n        if err != nil {\n            // handle error\n        }\n    }\n}\n```"]}, "weaver-internal/net/call/trace.go-readTraceContext": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func readTraceContext(dec *codegen.Decoder) *trace.SpanContext {\n# Natural Language Annotations: // readTraceContext returns a span context with tracing information stored in dec.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef read_trace_context(dec):\n    \"\"\"\n    readTraceContext returns a span context with tracing information stored in dec.\n    \n    :param dec: The decoder containing tracing information\n    :return: A span context\n    \"\"\"\n    # Assuming the decoder has a method to get the span context\n    # For example, let's assume it's called 'get_span_context'\n    return dec.get_span_context()\n```", "```python\ndef read_trace_context(dec):\n    # Return a span context with tracing information stored in dec\n    return dec\n```", "```python\ndef read_trace_context(dec):\n    \"\"\"readTraceContext returns a span context with tracing information stored in dec.\"\"\"\n    return dec.decode()\n```"]}, "ollama-types/model/name.go-ParseNameBare": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseNameBare(s string) Name {\n# Natural Language Annotations: // ParseNameBare parses s as a name string and returns a Name. No merge with\n// [DefaultName] is performed.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Name:\n    def __init__(self, first, last):\n        self.first = first\n        self.last = last\n\ndef ParseNameBare(s):\n    \"\"\"\n    ParseNameBare parses s as a name string and returns a Name.\n    No merge with [DefaultName] is performed.\n    \"\"\"\n    words = s.split()\n    if len(words) < 2:\n        raise ValueError(\"Invalid name format\")\n    return Name(words[0], ' '.join(words[1:]))\n```", "```python\nclass Name:\n    def __init__(self, first, middle=None, last=None):\n        self.first = first\n        self.middle = middle\n        self.last = last\n\ndef ParseNameBare(s):\n    \"\"\"\n    ParseNameBare parses s as a name string and returns a Name.\n    No merge with [DefaultName] is performed.\n    \n    Args:\n        s (str): The name string to be parsed.\n    \n    Returns:\n        Name: A Name object representing the parsed name.\n    \"\"\"\n    parts = s.split()\n    if len(parts) == 2:  # First name and last name\n        return Name(parts[0], None, parts[1])\n    elif len(parts) == 3:  # First name, middle name, and last name\n        return Name(parts[0], parts[1], parts[2])\n    else:\n        raise ValueError(\"Invalid name format\")\n```", "```typescript\nclass Name {\n  constructor(\n    public first: string,\n    public middle: string,\n    public last: string,\n    public suffix?: string,\n    public title?: string\n  ) {}\n}\n\ntype Name = {\n  first: string;\n  middle: string;\n  last: string;\n  suffix?: string;\n  title?: string;\n};\n\nfunction ParseNameBare(s: string): Name {\n  const parts = s.split(' ');\n  const name = {\n    first: parts[0],\n    last: parts[parts.length - 1],\n  };\n  if (parts.length > 2) {\n    name.middle = parts.slice(1, -1).join(' ');\n  }\n  return name;\n}\n```"]}, "ollama-types/model/name.go-ParseNameFromFilepath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseNameFromFilepath(s string) (n Name) {\n# Natural Language Annotations: // ParseNameFromFilepath parses a 4-part filepath as a Name. The parts are\n// expected to be in the form:\n//\n// { host } \"/\" { namespace } \"/\" { model } \"/\" { tag }\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef ParseNameFromFilepath(s: str) -> str:\n    \"\"\"\n    Parse a 4-part filepath as a Name.\n    \n    The parts are expected to be in the form:\n    { host } \"/\" { namespace } \"/\" { model } \"/\" { tag }\n    \n    Args:\n        s (str): The filepath to be parsed.\n    \n    Returns:\n        str: The parsed name in the form \"host/namespace/model/tag\".\n    \"\"\"\n    parts = s.split(\"/\")\n    if len(parts) != 4:\n        raise ValueError(\"Invalid filepath format\")\n    \n    host, namespace, model, tag = parts\n    return f\"{host}/{namespace}/{model}/{tag}\"\n```", "```python\ndef parse_name_from_filepath(filepath: str) -> str:\n    \"\"\"\n    Parse a 4-part filepath as a Name.\n    \n    The parts are expected to be in the form:\n    { host } \"/\" { namespace } \"/\" { model } \"/\" { tag }\n    \n    Args:\n        filepath (str): A 4-part filepath.\n    \n    Returns:\n        str: A Name parsed from the filepath.\n    \"\"\"\n    parts = filepath.split(\"/\")\n    if len(parts) != 4:\n        raise ValueError(\"Invalid filepath format\")\n    \n    host, namespace, model, tag = parts\n    \n    return f\"{host}/{namespace}/{model}/{tag}\"\n```", "```python\ndef parse_name_from_filepath(s):\n    \"\"\"\n    Parse a 4-part filepath as a Name.\n\n    Args:\n        s (str): The filepath to parse.\n\n    Returns:\n        tuple: A tuple containing the host, namespace, model, and tag.\n\n    Raises:\n        ValueError: If the filepath does not match the expected format.\n    \"\"\"\n    parts = s.split(\"/\")\n    if len(parts) != 4:\n        raise ValueError(\"Invalid filepath format\")\n    host, namespace, model, tag = parts\n    return host, namespace, model, tag\n```"]}, "ollama-types/model/name.go-DisplayShortest": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n Name) DisplayShortest() string {\n# Natural Language Annotations: // DisplayShort returns a short string version of the name.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef display_short_name(n: str) -> str:\n    \"\"\"\n    DisplayShort returns a short string version of the name.\n    \"\"\"\n    return n.split()[0]\n```", "```python\ndef display_short(n: str) -> str:\n    \"\"\"DisplayShort returns a short string version of the name.\"\"\"\n    return n.split()[0]\n```", "```python\ndef display_short_name(n):\n    \"\"\"DisplayShort returns a short string version of the name.\"\"\"\n    return n[:3]\n```"]}, "ollama-types/model/name.go-Filepath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (n Name) Filepath() string {\n# Natural Language Annotations: // Filepath returns a canonical filepath that represents the name with each part from\n// host to tag as a directory in the form:\n//\n//\t{host}/{namespace}/{model}/{tag}\n//\n// It uses the system's filepath separator and ensures the path is clean.\n//\n// It panics if the name is not fully qualified. Use [Name.IsFullyQualified]\n// to check if the name is fully qualified.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport os\n\nclass Name:\n    def __init__(self, host, namespace, model, tag):\n        self.host = host\n        self.namespace = namespace\n        self.model = model\n        self.tag = tag\n\n    def is_fully_qualified(self):\n        return all([self.host, self.namespace, self.model, self.tag])\n\ndef Filepath(name: 'Name') -> str:\n    if not name.is_fully_qualified():\n        raise ValueError(\"Name is not fully qualified\")\n\n    path = os.path.join(name.host, name.namespace, name.model, name.tag)\n    return os.path.normpath(path)\n```", "```go\nfunc (n Name) Filepath() string {\n    if !n.IsFullyQualified() {\n        panic(\"name is not fully qualified\")\n    }\n    return filepath.Join(\n        n.Host,\n        n.Namespace,\n        n.Model,\n        n.Tag,\n    )\n}\n```", "```go\npackage main\n\nimport (\n\t\"path/filepath\"\n\t\"strings\"\n)\n\ntype Name struct {\n\tHost     string\n\tNamespace string\n\tModel    string\n\tTag      string\n}\n\nfunc (n Name) Filepath() string {\n\tif !n.IsFullyQualified() {\n\t\tpanic(\"name is not fully qualified\")\n\t}\n\n\tparts := []string{n.Host, n.Namespace, n.Model, n.Tag}\n\treturn filepath.Join(parts...)\n}\n\nfunc (n Name) IsFullyQualified() bool {\n\treturn n.Host != \"\" && n.Namespace != \"\" && n.Model != \"\" && n.Tag != \"\"\n}\n```"]}, "ollama-server/prompt.go-Prompt": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Prompt(tmpl *template.Template, system, prompt, response string, generate bool) (string, error) {\n# Natural Language Annotations: // Prompt renders a prompt from a template. If generate is set to true,\n// the response and parts of the template following it are not rendered\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom jinja2 import Template\n\ndef prompt(tmpl: Template, system: str, prompt: str, response: str, generate: bool) -> (str, str):\n    if generate:\n        return tmpl.render(system=system, prompt=prompt), \"\"\n    else:\n        return tmpl.render(system=system, prompt=prompt, response=response), \"\"\n```", "```python\nfrom jinja2 import Template\n\ndef prompt(tmpl: Template, system: str, prompt: str, response: str, generate: bool) -> (str, str):\n    if generate:\n        return tmpl.render(system=system, prompt=prompt), \"\"\n    else:\n        return tmpl.render(system=system, prompt=prompt, response=response), \"\"\n```", "```python\nfrom jinja2 import Template\n\ndef prompt(tmpl: Template, system, prompt: str, response: str, generate: bool) -> (str, str):\n    rendered = tmpl.render(system=system, prompt=prompt)\n    if generate:\n        return rendered, \"\"\n    else:\n        return rendered, response\n```"]}, "ollama-server/sched.go-unload": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (runner *runnerRef) unload() {\n# Natural Language Annotations: // The refMu must already be held when calling unload\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef unload(self):\n    \"\"\"\n    Unload the runner.\n    \n    The refMu must already be held when calling unload.\n    \"\"\"\n    # Check if refMu is held\n    if not hasattr(self, 'refMu') or self.refMu is None:\n        raise Exception(\"refMu must be held before calling unload\")\n    \n    # Unload the runner\n    # Add your unloading logic here\n    # For example:\n    self.refMu.release()\n    self.refMu = None\n```", "```python\nclass Runner:\n    def __init__(self):\n        self.refMu = None\n\n    def unload(self):\n        # The refMu must already be held when calling unload\n        if self.refMu is None:\n            raise ValueError(\"refMu is not held\")\n        # Add your unload logic here\n        self.refMu = None\n```", "```python\nclass Runner:\n    def __init__(self):\n        self.refMu = None\n\n    def unload(self):\n        \"\"\"Unload the runner.\n        \n        The refMu must already be held when calling unload.\n        \n        Raises:\n            RuntimeError: If refMu is None.\n        \"\"\"\n        if self.refMu is None:\n            raise RuntimeError(\"refMu must be held when calling unload\")\n        # Add your unload logic here\n        self.refMu = None\n```"]}, "lo-retry.go-NewDebounce": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n# Natural Language Annotations: // NewDebounce creates a debounced instance that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/mz32VMK2nqe\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\nfunc NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n    var wg sync.WaitGroup\n    var mu sync.Mutex\n    var done bool\n    var result interface{}\n\n    debounced := func() {\n        wg.Wait()\n        mu.Lock()\n        if !done {\n            done = true\n            result = f[0]()\n            for _, fn := range f[1:] {\n                go func() {\n                    fn()\n                }()\n            }\n        }\n        mu.Unlock()\n    }\n\n    cancel := func() {\n        mu.Lock()\n        done = true\n        wg.Done()\n        mu.Unlock()\n    }\n\n    wg.Add(len(f))\n    go func() {\n        time.Sleep(duration)\n        wg.Done()\n    }()\n\n    return debounced, cancel\n}\n\nfunc main() {\n    debounced, cancel := NewDebounce(1000, func() {\n        println(\"Function 1 executed\")\n    }, func() {\n        println(\"Function 2 executed\")\n    })\n\n    debounced()\n    cancel()\n}\n```", "```go\npackage main\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\ntype debounced struct {\n    mu   sync.Mutex\n    ready bool\n    fns  []func()\n    timer *time.Timer\n}\n\nfunc NewDebounce(duration time.Duration, fns ...func()) (func(), func()) {\n    d := &debounced{\n        fns:  fns,\n    }\n\n    return func() {\n        d.mu.Lock()\n        if !d.ready {\n            d.mu.Unlock()\n            return\n        }\n        d.mu.Lock()\n        for _, fn := range d.fns {\n            fn()\n        }\n        d.mu.Unlock()\n    }, func() {\n        d.mu.Lock()\n        d.ready = false\n        d.mu.Unlock()\n        if d.timer != nil {\n            d.timer.Stop()\n        }\n        d.timer = time.AfterFunc(duration, func() {\n            d.mu.Lock()\n            d.ready = true\n            d.mu.Unlock()\n        })\n    }\n}\n\nfunc main() {\n    // Example usage:\n    fn := func() {\n        println(\"Hello, World!\")\n    }\n\n    play, reset := NewDebounce(2*time.Second, fn)\n    play() // Does nothing\n    time.Sleep(1 * time.Second)\n    play() // Prints \"Hello, World!\"\n    reset()\n    play() // Prints \"Hello, World!\"\n}\n```", "```go\npackage main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\nfunc NewDebounce(duration time.Duration, f ...func()) (func(), func()) {\n\tvar wg sync.WaitGroup\n\tvar mu sync.Mutex\n\tvar run bool\n\n\treturn func() {\n\t\twg.Done()\n\t}, func() {\n\t\tmu.Lock()\n\t\tdefer mu.Unlock()\n\t\tif !run {\n\t\t\trun = true\n\t\t\twg.Add(1)\n\t\t\tgo func() {\n\t\t\t\ttime.Sleep(duration)\n\t\t\t\tmu.Lock()\n\t\t\t\tdefer mu.Unlock()\n\t\t\t\trun = false\n\t\t\t\twg.Done()\n\t\t\t}()\n\t\t}\n\t\twg.Wait()\n\t\tfor _, fn := range f {\n\t\t\tfn()\n\t\t}\n\t}\n}\n```"]}, "lo-retry.go-NewDebounceBy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n# Natural Language Annotations: // NewDebounceBy creates a debounced instance for each distinct key, that delays invoking functions given until after wait milliseconds have elapsed.\n// Play: https://go.dev/play/p/d3Vpt6pxhY8\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype Debouncer[T comparable] struct {\n\tmu    sync.RWMutex\n\tm     map[T]*debouncer\n\ttimer *time.Timer\n}\n\ntype debouncer struct {\n\tcount int\n\tf     func(key T, count int)\n}\n\nfunc (d *Debouncer[T]) add(key T, f func(key T, count int)) {\n\td.mu.Lock()\n\tdefer d.mu.Unlock()\n\tif d.m == nil {\n\t\td.m = make(map[T]*debouncer)\n\t}\n\tif _, ok := d.m[key]; !ok {\n\t\td.m[key] = &debouncer{f: f}\n\t}\n}\n\nfunc (d *Debouncer[T]) run(key T) {\n\td.mu.Lock()\n\tif f, ok := d.m[key]; ok {\n\t\td.mu.Unlock()\n\t\tf(key, 1)\n\t\tdelete(d.m, key)\n\t} else {\n\t\td.mu.Unlock()\n\t}\n}\n\nfunc (d *Debouncer[T]) start() {\n\td.timer = time.AfterFunc(d.duration, func() {\n\t\td.mu.Lock()\n\t\tfor k, f := range d.m {\n\t\t\td.mu.Unlock()\n\t\t\tf(k, 1)\n\t\t\tdelete(d.m, k)\n\t\t}\n\t\td.mu.Lock()\n\t\td.m = nil\n\t\td.timer = nil\n\t\td.mu.Unlock()\n\t})\n}\n\nfunc NewDebounceBy[T comparable](duration time.Duration, fs ...func(key T, count int)) (play func(key T), stop func(key T)) {\n\td := &Debouncer[T]{duration: duration}\n\tfor _, f := range fs {\n\t\td.add(T{}, f)\n\t}\n\td.start()\n\treturn d.run, func(key T) { d.mu.Lock(); delete(d.m, key); d.mu.Unlock() }\n}\n\nfunc main() {\n\tplay, stop := NewDebounceBy[int](time.Second, func(key int, count int) { println(key, count) })\n\tplay(1)\n\tplay(1)\n\tstop(1)\n\ttime.Sleep(2 * time.Second)\n\tplay(1)\n}\n```", "```go\npackage main\n\nimport (\n    \"sync\"\n    \"time\"\n)\n\ntype Debouncer[T any] struct {\n    mutex  sync.Mutex\n    delays map[T]time.Time\n}\n\nfunc NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n    debouncer := &Debouncer[T]{delays: make(map[T]time.Time)}\n    cancel := func(key T) {\n        debouncer.mutex.Lock()\n        defer debouncer.mutex.Unlock()\n        delete(debouncer.delays, key)\n    }\n\n    call := func(key T) {\n        debouncer.mutex.Lock()\n        defer debouncer.mutex.Unlock()\n        delay, ok := debouncer.delays[key]\n        if ok && time.Since(delay) < duration {\n            return\n        }\n        delete(debouncer.delays, key)\n        debouncer.delays[key] = time.Now().Add(duration)\n        for _, fn := range f {\n            fn(key, 1)\n        }\n    }\n\n    return call, cancel\n}\n\nfunc main() {\n    // Example usage:\n    // call, cancel := NewDebounceBy(500*time.Millisecond, func(key int, count int) { println(key, count) })\n    // call(1)\n    // call(1)\n    // time.Sleep(200 * time.Millisecond)\n    // call(1)\n    // cancel(1)\n}\n```", "```go\npackage main\n\nimport (\n\t\"sync\"\n\t\"time\"\n)\n\ntype Debouncer[T comparable] struct {\n\tmu   sync.Mutex\n\tdur  time.Duration\n\tmaps map[T]time.Time\n}\n\nfunc NewDebounceBy[T comparable](duration time.Duration, f ...func(key T, count int)) (func(key T), func(key T)) {\n\td := &Debouncer[T]{\n\t\tdur:  duration,\n\t\tmaps: make(map[T]time.Time),\n\t}\n\n\treturn func(key T) {\n\t\td.mu.Lock()\n\t\tif _, ok := d.maps[key]; !ok {\n\t\t\td.maps[key] = time.Now()\n\t\t} else {\n\t\t\tif time.Since(d.maps[key]) >= d.dur {\n\t\t\t\td.maps[key] = time.Now()\n\t\t\t} else {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\td.mu.Unlock()\n\n\t\tfor _, f := range f {\n\t\t\tf(key, 1)\n\t\t}\n\t}, func(key T) {\n\t\td.mu.Lock()\n\t\tdelete(d.maps, key)\n\t\td.mu.Unlock()\n\t}\n}\n```"]}, "lo-errors.go-Try6": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n# Natural Language Annotations: // Try6 has the same behavior as Try, but callback returns 6 variables.\n// Play: https://go.dev/play/p/mTyyWUvn9u4\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef Try6(callback):\n    \"\"\"\n    Try6 has the same behavior as Try, but callback returns 6 variables.\n    \n    Args:\n        callback (function): A function that returns 6 variables.\n        \n    Returns:\n        bool: Whether the callback function executed successfully.\n    \"\"\"\n    try:\n        _, _, _, _, _, _ = callback()\n        return True\n    except Exception as e:\n        return False\n```", "```go\nfunc Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error)) bool {\n    _, _, _, _, _, err := callback()\n    return err == nil\n}\n```", "```go\nfunc Try6[T, R, S, Q, U any](callback func() (T, R, S, Q, U, error) bool) bool {\n    defer func() {\n        if r := recover(); r != nil {\n            return false\n        }\n    }()\n    return callback()\n}\n```"]}, "lo-errors.go-TryOr6": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n# Natural Language Annotations: // TryOr6 has the same behavior as Must, but returns a default value in case of error.\n// Play: https://go.dev/play/p/B4F7Wg2Zh9X\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n    result, err := callback()\n    if err != nil {\n        return fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF, false\n    }\n    return result[0], result[1], result[2], result[3], result[4], result[5], true\n}\n```", "```go\nfunc TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n    result, err := callback()\n    if err != nil {\n        return fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF, false\n    }\n    return result[0], result[1], result[2], result[3], result[4], result[5], true\n}\n```", "```go\nfunc TryOr6[A, B, C, D, E, F any](callback func() (A, B, C, D, E, F, error), \n    fallbackA A, fallbackB B, fallbackC C, fallbackD D, fallbackE E, fallbackF F) (A, B, C, D, E, F, bool) {\n    result, err := callback()\n    if err != nil {\n        return fallbackA, fallbackB, fallbackC, fallbackD, fallbackE, fallbackF, false\n    }\n    return result[0], result[1], result[2], result[3], result[4], result[5], true\n}\n```"]}, "lo-string.go-Substring": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Substring[T ~string](str T, offset int, length uint) T {\n# Natural Language Annotations: // Substring return part of a string.\n// Play: https://go.dev/play/p/TQlxQi82Lu1\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc Substring[T any](str T, offset int, length uint) T {\n    // Check if the offset and length are valid\n    if offset < 0 || length < 0 {\n        return \"\"\n    }\n\n    // Convert str to string\n    str := fmt.Sprintf(\"%v\", str)\n\n    // Get the substring\n    substring := str[offset : offset+int(length)]\n\n    // Convert the substring back to the original type\n    var result T\n    switch str.(type) {\n    case string:\n        result = substring\n    case []byte:\n        result = substring\n    default:\n        // Handle other types\n        return \"\"\n    }\n\n    return result\n}\n```", "```go\nfunc Substring[T string](s T, offset int, length uint) T {\n    if offset >= len(s) {\n        return \"\"\n    }\n    if offset+length > len(s) {\n        return s[offset:]\n    }\n    return s[offset : offset+length]\n}\n```", "```go\nfunc Substring[T any](s string, offset int, length uint) T {\n    if offset > len(s) {\n        return \"\"\n    }\n    if offset+length > len(s) {\n        return s[offset:]\n    }\n    return s[offset : offset+length]\n}\n```"]}, "lo-string.go-PascalCase": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func PascalCase(str string) string {\n# Natural Language Annotations: // PascalCase converts string to pascal case.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef pascal_case(str):\n    result = ''\n    for i, char in enumerate(str):\n        if char == ' ':\n            result += char.upper()\n        else:\n            if i == 0 or str[i - 1] == ' ':\n                result += char.upper()\n            else:\n                result += char.lower()\n    return result\n```", "```python\ndef pascal_case(str):\n    return ''.join(word.capitalize() for word in str.split())\n```", "```python\ndef pascal_case(str):\n    return ''.join(word.capitalize() for word in str.split())\n```"]}, "lo-map.go-PickByValues": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func PickByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n# Natural Language Annotations: // PickByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/1zdzSvbfsJc\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc PickByValues[K comparable, V comparable](in map[K]V, values []V) map[K]V {\n    var result map[K]V = make(map[K]V)\n    for k, v := range in {\n        for _, value := range values {\n            if v == value {\n                result[k] = v\n            }\n        }\n    }\n    return result\n}\n```", "```go\nfunc PickByValues[K comparable, V comparable](in map[K]V, values []V) map[K]V {\n    var result map[K]V = make(map[K]V)\n    for k, v := range in {\n        for _, val := range values {\n            if v == val {\n                result[k] = v\n            }\n        }\n    }\n    return result\n}\n```", "```go\nfunc PickByValues[K comparable, V comparable](in map[K]V, values []V) map[K]V {\n    var result map[K]V\n    for k, v := range in {\n        if contains(values, v) {\n            result[k] = v\n        }\n    }\n    return result\n}\n\nfunc contains[V comparable](slice []V, val V) bool {\n    for _, v := range slice {\n        if v == val {\n            return true\n        }\n    }\n    return false\n}\n```"]}, "lo-map.go-OmitByValues": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func OmitByValues[K comparable, V comparable, Map ~map[K]V](in Map, values []V) Map {\n# Natural Language Annotations: // OmitByValues returns same map type filtered by given values.\n// Play: https://go.dev/play/p/9UYZi-hrs8j\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc OmitByValues[K comparable, V comparable](m map[K]V, values []V) map[K]V {\n    var result map[K]V\n    for k, v := range m {\n        if !contains(values, v) {\n            result[k] = v\n        }\n    }\n    return result\n}\n\nfunc contains[V comparable](s []V, x V) bool {\n    for _, v := range s {\n        if v == x {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\nfunc OmitByValues[K comparable, V comparable](in map[K]V, values []V) map[K]V {\n    out := make(map[K]V)\n    for k, v := range in {\n        if !contains(values, v) {\n            out[k] = v\n        }\n    }\n    return out\n}\n\nfunc contains[K comparable](slice []K, val K) bool {\n    for _, v := range slice {\n        if reflect.DeepEqual(v, val) {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\nfunc OmitByValues[K comparable, V comparable](m map[K]V, values []V) map[K]V {\n    var res map[K]V\n    for k, v := range m {\n        if !contains(values, v) {\n            res[k] = v\n        }\n    }\n    return res\n}\n\nfunc contains[T comparable](slice []T, val T) bool {\n    for _, v := range slice {\n        if v == val {\n            return true\n        }\n    }\n    return false\n}\n```"]}, "lo-tuples.go-Zip9": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Zip9[A, B, C, D, E, F, G, H, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n# Natural Language Annotations: // Zip9 creates a slice of grouped elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\n// Play: https://go.dev/play/p/jujaA6GaJTp\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc Zip9[A any, B any, C any, D any, E any, F any, G any, H any, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []Tuple9[A, B, C, D, E, F, G, H, I] {\n    var result []Tuple9[A, B, C, D, E, F, G, H, I]\n    maxLength := max(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n    for i := 0; i < maxLength; i++ {\n        var tuple Tuple9[A, B, C, D, E, F, G, H, I]\n        if i < len(a) {\n            tuple.A = a[i]\n        }\n        if i < len(b) {\n            tuple.B = b[i]\n        }\n        if i < len(c) {\n            tuple.C = c[i]\n        }\n        if i < len(d) {\n            tuple.D = d[i]\n        }\n        if i < len(e) {\n            tuple.E = e[i]\n        }\n        if i < len(f) {\n            tuple.F = f[i]\n        }\n        if i < len(g) {\n            tuple.G = g[i]\n        }\n        if i < len(h) {\n            tuple.H = h[i]\n        }\n        if i < len(i) {\n            tuple.I = i[i]\n        }\n        result = append(result, tuple)\n    }\n    return result\n}\n\ntype Tuple9[A, B, C, D, E, F, G, H, I any] struct {\n    A A\n    B B\n    C C\n    D D\n    E E\n    F F\n    G G\n    H H\n    I I\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```", "```go\nfunc Zip9[A any, B any, C any, D any, E any, F any, G any, H any, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []struct {\n    A\n    B\n    C\n    D\n    E\n    F\n    G\n    H\n    I\n} {\n    maxLength := max(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n    result := make([]struct {\n        A\n        B\n        C\n        D\n        E\n        F\n        G\n        H\n        I\n    }, maxLength)\n\n    for i := 0; i < maxLength; i++ {\n        result[i] = struct {\n            A\n            B\n            C\n            D\n            E\n            F\n            G\n            H\n            I\n        }{\n            A:  a[i%len(a)],\n            B:  b[i%len(b)],\n            C:  c[i%len(c)],\n            D:  d[i%len(d)],\n            E:  e[i%len(e)],\n            F:  f[i%len(f)],\n            G:  g[i%len(g)],\n            H:  h[i%len(h)],\n            I:  i[i%len(i)],\n        }\n    }\n\n    return result\n}\n\nfunc max(a, b int) int {\n    if a > b {\n        return a\n    }\n    return b\n}\n```", "```go\nfunc Zip9[A any, B any, C any, D any, E any, F any, G any, H any, I any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I) []struct {\n\tA A\n\tB B\n\tC C\n\tD D\n\tE E\n\tF F\n\tG G\n\tH H\n\tI I\n} {\n    minLength := min(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n    result := make([]struct {\n        A A\n        B B\n        C C\n        D D\n        E E\n        F F\n        G G\n        H H\n        I I\n    }, minLength)\n    for i := range result {\n        result[i].A = a[i]\n        result[i].B = b[i]\n        result[i].C = c[i]\n        result[i].D = d[i]\n        result[i].E = e[i]\n        result[i].F = f[i]\n        result[i].G = g[i]\n        result[i].H = h[i]\n        result[i].I = i[i]\n    }\n    return result\n}\n\nfunc min(args ...int) int {\n    minVal := args[0]\n    for _, arg := range args[1:] {\n        if arg < minVal {\n            minVal = arg\n        }\n    }\n    return minVal\n}\n```"]}, "lo-tuples.go-ZipBy9": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n# Natural Language Annotations: // ZipBy9 creates a slice of transformed elements, the first of which contains the first elements\n// of the given arrays, the second of which contains the second elements of the given arrays, and so on.\n// When collections have different size, the Tuple attributes are filled with zero value.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n\tvar out []Out\n\tfor len(a) == len(b) && len(c) == len(d) && len(e) == len(f) && len(g) == len(h) && len(i) {\n\t\tout = append(out, iteratee(a[0], b[0], c[0], d[0], e[0], f[0], g[0], h[0], i[0]))\n\t\ta = a[1:]\n\t\tb = b[1:]\n\t\tc = c[1:]\n\t\td = d[1:]\n\t\te = e[1:]\n\t\tf = f[1:]\n\t\tg = g[1:]\n\t\th = h[1:]\n\t\ti = i[1:]\n\t}\n\treturn out\n}\n\nfunc main() {\n\tvar a = []int{1, 2, 3}\n\tvar b = []int{4, 5, 6}\n\tvar c = []int{7, 8, 9}\n\tvar d = []int{10, 11, 12}\n\tvar e = []int{13, 14, 15}\n\tvar f = []int{16, 17, 18}\n\tvar g = []int{19, 20, 21}\n\tvar h = []int{22, 23, 24}\n\tvar i = []int{25, 26, 27}\n\n\tadd := func(x int, y int, z int, w int, v int, u int, t int, s int, r int) int {\n\t\treturn x + y + z + w + v + u + t + s + r\n\t}\n\n\tfmt.Println(ZipBy9(a, b, c, d, e, f, g, h, i, add))\n}\n```", "```go\nfunc ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n    maxLength := min(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n    result := make([]Out, maxLength)\n    for i := 0; i < maxLength; i++ {\n        result[i] = iteratee(\n            a[i],\n            b[i],\n            c[i],\n            d[i],\n            e[i],\n            f[i],\n            g[i],\n            h[i],\n            i[i],\n        )\n    }\n    return result\n}\n\nfunc min(a, b, c, d, e, f, g, h, i int) int {\n    minVal := a\n    if b < minVal {\n        minVal = b\n    }\n    if c < minVal {\n        minVal = c\n    }\n    if d < minVal {\n        minVal = d\n    }\n    if e < minVal {\n        minVal = e\n    }\n    if f < minVal {\n        minVal = f\n    }\n    if g < minVal {\n        minVal = g\n    }\n    if h < minVal {\n        minVal = h\n    }\n    if i < minVal {\n        minVal = i\n    }\n    return minVal\n}\n```", "```go\nfunc ZipBy9[A any, B any, C any, D any, E any, F any, G any, H any, I any, Out any](a []A, b []B, c []C, d []D, e []E, f []F, g []G, h []H, i []I, iteratee func(a A, b B, c C, d D, e E, f F, g G, h H, i I) Out) []Out {\n    minLen := min(len(a), len(b), len(c), len(d), len(e), len(f), len(g), len(h), len(i))\n    result := make([]Out, minLen)\n    for i := range result {\n        result[i] = iteratee(\n            a[i],\n            b[i],\n            c[i],\n            d[i],\n            e[i],\n            f[i],\n            g[i],\n            h[i],\n            i[i],\n        )\n    }\n    return result\n}\n\nfunc min(values ...int) int {\n    minVal := values[0]\n    for _, val := range values[1:] {\n        if val < minVal {\n            minVal = val\n        }\n    }\n    return minVal\n}\n```"]}, "lo-channel.go-ChannelDispatcher": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n# Natural Language Annotations: // ChannelDispatcher distributes messages from input channels into N child channels.\n// Close events are propagated to children.\n// Underlying channels can have a fixed buffer capacity or be unbuffered when cap is 0.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype DispatchingStrategy[T any] interface {\n\tDispatch(ch <-chan T, child chan<- T, wg *sync.WaitGroup, count int)\n}\n\nfunc ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n\tchannels := make([]<-chan T, count)\n\tvar wg sync.WaitGroup\n\twg.Add(count)\n\tfor i := range channels {\n\t\tchild := make(chan T, channelBufferCap)\n\t\tgo func(child chan T) {\n\t\t\tdefer wg.Done()\n\t\t\tstrategy.Dispatch(stream, child, &wg, count)\n\t\t\tclose(child)\n\t\t}(child)\n\t\tchannels[i] = child\n\t}\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(stream)\n\t}()\n\treturn channels\n}\n\ntype ExampleDispatchingStrategy[T any] struct{}\n\nfunc (ExampleDispatchingStrategy[T]) Dispatch[T any](ch <-chan T, child chan<- T, wg *sync.WaitGroup, count int) {\n\tfor {\n\t\tselect {\n\t\tcase msg, ok := <-ch:\n\t\t\tif !ok {\n\t\t\t\treturn\n\t\t\t}\n\t\t\tchild <- msg\n\t\t}\n\t}\n}\n\nfunc main() {\n\tstream := make(chan int, 1)\n\tchannels := ChannelDispatcher[int](stream, 3, 10, ExampleDispatchingStrategy[int]{})\n\tfor _, channel := range channels {\n\t\tgo func(ch <-chan int) {\n\t\t\tfor msg := range ch {\n\t\t\t\tfmt.Println(msg)\n\t\t\t}\n\t\t}(channel)\n\t}\n\tstream <- 1\n\tstream <- 2\n\tclose(stream)\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\ntype DispatchingStrategy[T any] interface {\n\tDispatch(in <-chan T, out chan<- T) <-chan T\n}\n\nfunc ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n\tchannels := make([]<-chan T, count)\n\tvar wg sync.WaitGroup\n\n\tfor i := 0; i < count; i++ {\n\t\twg.Add(1)\n\t\tgo func(index int) {\n\t\t\tdefer wg.Done()\n\t\t\tchannels[index] = strategy.Dispatch(stream, make(chan T, channelBufferCap))\n\t\t}(i)\n\t}\n\n\tgo func() {\n\t\tdefer func() {\n\t\t\tfor _, ch := range channels {\n\t\t\t\tclose(ch)\n\t\t\t}\n\t\t}()\n\t\twg.Wait()\n\t\tclose(stream)\n\t}()\n\n\treturn channels\n}\n\ntype MyDispatchingStrategy[T any] struct{}\n\nfunc (m MyDispatchingStrategy[T]) Dispatch(in <-chan T, out chan<- T) <-chan T {\n\tfor {\n\t\tselect {\n\t\tcase v, ok := <-in:\n\t\t\tif !ok {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\tout <- v\n\t\t}\n\t}\n}\n\nfunc main() {\n\tchannels := ChannelDispatcher[int](make(chan int, 0), 5, 10, MyDispatchingStrategy[int]{})\n\tfor _, ch := range channels {\n\t\tfor v := range ch {\n\t\t\tfmt.Println(v)\n\t\t}\n\t}\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n)\n\n// DispatchingStrategy is a strategy for distributing messages from the input channel into child channels.\ntype DispatchingStrategy[T any] interface {\n\tDistribute(msg T, children <-chan T) <-chan T\n}\n\nfunc ChannelDispatcher[T any](stream <-chan T, count int, channelBufferCap int, strategy DispatchingStrategy[T]) []<-chan T {\n\tchildren := make([]<-chan T, count)\n\tvar wg sync.WaitGroup\n\tfor i := 0; i < count; i++ {\n\t\twg.Add(1)\n\t\tgo func(childIndex int) {\n\t\t\tdefer wg.Done()\n\t\t\tchild := make(chan T, channelBufferCap)\n\t\t\tchildren[childIndex] = child\n\t\t\tstrategy.Distribute(<-stream, child)\n\t\t\tclose(child)\n\t\t}(i)\n\t}\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(stream)\n\t}()\n\treturn children\n}\n\nfunc main() {\n\t// Example usage:\n\t// Define a simple strategy that distributes all messages to all children\n\ttype exampleStrategy struct{}\n\tfunc (s exampleStrategy) Distribute(msg any, children <-chan any) <-chan any {\n\t\tfor _, child := range children {\n\t\t\tchild <- msg\n\t\t}\n\t\treturn nil\n\t}\n\n\t// Create a channel dispatcher with 5 children, each with a buffer capacity of 10\n\tchildren := ChannelDispatcher(10, 5, 10, exampleStrategy{})\n\n\t// Send messages to the input channel\n\tfor i := 0; i < 20; i++ {\n\t\tchildren[0] <- i\n\t}\n\n\t// Receive messages from the child channels\n\tfor _, child := range children {\n\t\tfor msg := range child {\n\t\t\tfmt.Println(msg)\n\t\t}\n\t}\n}\n```"]}, "lo-channel.go-DispatchingStrategyRoundRobin": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n# Natural Language Annotations: // DispatchingStrategyRoundRobin distributes messages in a rotating sequential manner.\n// If the channel capacity is exceeded, the next channel will be selected and so on.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n    if index >= uint64(len(channels)) {\n        return -1\n    }\n\n    channel := channels[index % uint64(len(channels))]\n    select {\n    case channel <- msg:\n        return 0\n    default:\n        return 1\n    }\n}\n```", "```go\nfunc DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n    // Calculate the index of the channel to send the message to\n    channelIndex := index % uint64(len(channels))\n    \n    // Check if the calculated channel index is within the bounds of the channels slice\n    if channelIndex >= uint64(len(channels)) {\n        channelIndex = 0\n    }\n    \n    // Send the message to the selected channel\n    channels[channelIndex] <- msg\n    \n    // Return the index of the channel where the message was sent\n    return int(channelIndex)\n}\n```", "```go\nfunc DispatchingStrategyRoundRobin[T any](msg T, index uint64, channels []<-chan T) int {\n    // Calculate the index modulo the number of channels to select the next channel\n    nextIndex := index % uint64(len(channels))\n    \n    // Select the next channel\n    nextChannel := channels[nextIndex]\n    \n    // If the channel capacity is exceeded, return -1\n    if cap(nextChannel) == 0 {\n        return -1\n    }\n    \n    // Send the message to the selected channel\n    nextChannel <- msg\n    \n    // Return the index of the selected channel\n    return int(nextIndex)\n}\n```"]}, "lo-channel.go-FanOut": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n# Natural Language Annotations: // FanOut broadcasts all the upstream messages to multiple downstream channels.\n// When upstream channel reach EOF, downstream channels close. If any downstream\n// channels is full, broadcasting is paused.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom concurrent.futures import ThreadPoolExecutor\nfrom queue import Queue\nfrom typing import Any\n\ndef fan_out(count: int, channels_buffer_cap: int, upstream: iter) -> list:\n    \"\"\"\n    FanOut broadcasts all the upstream messages to multiple downstream channels.\n    When upstream channel reach EOF, downstream channels close. If any downstream\n    channels is full, broadcasting is paused.\n\n    Args:\n        count (int): The number of downstream channels.\n        channels_buffer_cap (int): The buffer capacity of each downstream channel.\n        upstream (iter): The upstream channel.\n\n    Returns:\n        list: A list of downstream channels.\n    \"\"\"\n    def downstream_channel(buffer_cap: int):\n        q = Queue(buffer_cap)\n        for item in upstream:\n            q.put(item)\n        return q\n\n    with ThreadPoolExecutor() as executor:\n        channels = [executor.submit(downstream_channel, channels_buffer_cap) for _ in range(count)]\n        return channels\n```", "```go\npackage main\n\nimport (\n    \"context\"\n    \"sync\"\n)\n\nfunc FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n    var (\n        channels = make([]chan T, count)\n        closed   = make(chan struct{})\n        mutex    = &sync.Mutex{}\n    )\n\n    for i := range channels {\n        channels[i] = make(chan T, channelsBufferCap)\n        go func(i int) {\n            for {\n                select {\n                case t, ok := <-upstream:\n                    if !ok {\n                        close(channels[i])\n                        return\n                    }\n                    channels[i] <- t\n                case <-closed:\n                    return\n                }\n            }\n        }(i)\n    }\n\n    return channels\n}\n```", "```go\nfunc FanOut[T any](count int, channelsBufferCap int, upstream <-chan T) []<-chan T {\n    channels := make([]chan T, count)\n    for i := range channels {\n        channels[i] = make(chan T, channelsBufferCap)\n    }\n\n    go func() {\n        for msg := range upstream {\n            for _, channel := range channels {\n                select {\n                case channel <- msg:\n                default:\n                    // if channel is full, skip this message\n                }\n            }\n        }\n        for _, channel := range channels {\n            close(channel)\n        }\n    }()\n\n    return channels\n}\n```"]}, "lo-slice.go-Shuffle": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Shuffle[T any, Slice ~[]T](collection Slice) Slice {\n# Natural Language Annotations: // Shuffle returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.\n// Play: https://go.dev/play/p/Qp73bnTDnc7\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"sort\"\n)\n\nfunc Shuffle[T any](collection []T) []T {\n\trand.Seed(time.Now().UnixNano())\n\tsort.Slice(collection, func(i, j int) bool {\n\t\trand.Intn(2) == 0\n\t})\n\treturn collection\n}\n\nfunc main() {\n\tarr := []int{1, 2, 3, 4, 5}\n\tfmt.Println(Shuffle(arr))\n}\n```", "```go\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"fmt\"\n)\n\nfunc Shuffle[T any](collection []T) []T {\n\trand.Seed(1)\n\tfor i := len(collection) - 1; i > 0; i-- {\n\t\tj := rand.Intn(i + 1)\n\t\tcollection[i], collection[j] = collection[j], collection[i]\n\t}\n\treturn collection\n}\n\nfunc main() {\n\tarr := []int{1, 2, 3, 4, 5}\n\tfmt.Println(Shuffle(arr))\n}\n```", "```python\nimport random\n\ndef shuffle(collection):\n    \"\"\"\n    Shuffle returns an array of shuffled values. Uses the Fisher-Yates shuffle algorithm.\n    \"\"\"\n    collection[:] = random.sample(collection, len(collection))\n    return collection\n\n# Example usage:\nmy_list = [1, 2, 3, 4, 5]\nprint(shuffle(my_list))\nprint(my_list)\n```"]}, "lo-slice.go-Fill": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Fill[T Clonable[T]](collection []T, initial T) []T {\n# Natural Language Annotations: // Fill fills elements of array with `initial` value.\n// Play: https://go.dev/play/p/VwR34GzqEub\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc Fill[T any](collection []T, initial T) []T {\n    result := make([]T, len(collection))\n    for i := range collection {\n        result[i] = initial\n    }\n    return result\n}\n```", "```go\nfunc Fill[T any](collection []T, initial T) []T {\n    result := make([]T, len(collection))\n    for i := range result {\n        result[i] = initial\n    }\n    return result\n}\n```", "```go\nfunc Fill[T any](collection []T, initial T) []T {\n    copy := make([]T, len(collection))\n    for i := range collection {\n        copy[i] = initial\n    }\n    return copy\n}\n```"]}, "lo-slice.go-Repeat": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Repeat[T Clonable[T]](count int, initial T) []T {\n# Natural Language Annotations: // Repeat builds a slice with N copies of initial value.\n// Play: https://go.dev/play/p/g3uHXbmc3b6\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc Repeat[T any](count int, initial T) []T {\n    result := make([]T, count)\n    for i := range result {\n        result[i] = initial\n    }\n    return result\n}\n```", "```go\nfunc Repeat[T any](count int, initial T) []T {\n    result := make([]T, count)\n    for i := range result {\n        result[i] = initial\n    }\n    return result\n}\n```", "```go\nfunc Repeat[T any](count int, initial T) []T {\n    result := make([]T, count)\n    for i := range result {\n        result[i] = initial\n    }\n    return result\n}\n```"]}, "lo-slice.go-DropByIndex": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DropByIndex[T any](collection []T, indexes ...int) []T {\n# Natural Language Annotations: // DropByIndex drops elements from a slice or array by the index.\n// A negative index will drop elements from the end of the slice.\n// Play: https://go.dev/play/p/bPIH4npZRxS\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc DropByIndex[T any](collection []T, indexes ...int) []T {\n    var result []T\n    for i, v := range collection {\n        found := false\n        for _, index := range indexes {\n            if i == index {\n                found = true\n                break\n            }\n        }\n        if !found {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n```", "```go\nfunc DropByIndex[T any](collection []T, indexes ...int) []T {\n    var result []T\n    for i, v := range collection {\n        if !contains(indexes, i) {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n\nfunc contains(s []int, e int) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\nfunc DropByIndex[T any](collection []T, indexes ...int) []T {\n    var result []T\n    for i, v := range collection {\n        found := false\n        for _, index := range indexes {\n            if i == index {\n                found = true\n                break\n            }\n        }\n        if !found {\n            result = append(result, v)\n        }\n    }\n    return result\n}\n```"]}, "lo-intersect.go-Some": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Some[T comparable](collection []T, subset []T) bool {\n# Natural Language Annotations: // Some returns true if at least 1 element of a subset is contained into a collection.\n// If the subset is empty Some returns false.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef some(collection, subset):\n    return any(element in collection for element in subset)\n```", "```python\ndef some(collection, subset):\n    for element in subset:\n        if element in collection:\n            return True\n    return False\n```", "```python\ndef some(collection, subset):\n    \"\"\"\n    Returns true if at least 1 element of a subset is contained into a collection.\n    If the subset is empty Some returns false.\n    \n    Args:\n        collection (list): The main collection to check.\n        subset (list): The subset to check for presence in the collection.\n    \n    Returns:\n        bool: True if the subset contains at least one element from the collection, False otherwise.\n    \"\"\"\n    return any(element in collection for element in subset)\n```"]}, "lo-find.go-FindKeyBy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FindKeyBy[K comparable, V any](object map[K]V, predicate func(key K, value V) bool) (K, bool) {\n# Natural Language Annotations: // FindKeyBy returns the key of the first element predicate returns truthy for.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef find_key_by[K, V](map: dict[K, V], predicate) -> tuple[K, bool]:\n    \"\"\"\n    FindKeyBy returns the key of the first element predicate returns truthy for.\n\n    Args:\n        map (dict[K, V]): The input map to search in.\n        predicate (function): A function that takes a key and a value and returns a boolean.\n\n    Returns:\n        tuple[K, bool]: A tuple containing the key of the first element that satisfies the predicate and a boolean indicating whether the key was found.\n    \"\"\"\n    for key, value in map.items():\n        if predicate(key, value):\n            return key, True\n    return None, False\n```", "```python\ndef find_key_by[K, V](map_: dict[K, V], predicate) -> tuple[K, bool]:\n    \"\"\"\n    FindKeyBy returns the key of the first element predicate returns truthy for.\n\n    Args:\n        map_ (dict[K, V]): The dictionary to search in.\n        predicate (function): A function that takes a key and a value and returns a boolean.\n\n    Returns:\n        tuple[K, bool]: A tuple containing the key and a boolean indicating whether the key was found.\n    \"\"\"\n    for key, value in map_.items():\n        if predicate(key, value):\n            return key, True\n    return None, False\n```", "```python\ndef find_key_by(map_: dict, predicate):\n    \"\"\"\n    FindKeyBy returns the key of the first element predicate returns truthy for.\n\n    Args:\n        map_ (dict): The dictionary to search in.\n        predicate (function): A function that takes a key-value pair and returns a boolean.\n\n    Returns:\n        tuple: A tuple containing the key and a boolean indicating whether the key was found.\n    \"\"\"\n    for key, value in map_.items():\n        if predicate(key, value):\n            return key, True\n    return None, False\n```"]}, "lo-find.go-FirstOr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FirstOr[T any](collection []T, fallback T) T {\n# Natural Language Annotations: // FirstOr returns the first element of a collection or the fallback value if empty.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef first_or(collection, fallback):\n    \"\"\"\n    Returns the first element of a collection or the fallback value if empty.\n    \n    Args:\n        collection: The collection to retrieve the first element from.\n        fallback: The value to return if the collection is empty.\n    \n    Returns:\n        The first element of the collection or the fallback value.\n    \"\"\"\n    return collection[0] if collection else fallback\n```", "```python\ndef first_or(collection, fallback):\n    \"\"\"\n    Returns the first element of a collection or the fallback value if empty.\n    \n    Args:\n        collection (list): The collection to retrieve the first element from.\n        fallback (any): The value to return if the collection is empty.\n    \n    Returns:\n        any: The first element of the collection or the fallback value.\n    \"\"\"\n    return collection[0] if collection else fallback\n```", "```python\ndef first_or(collection, fallback):\n    \"\"\"\n    Returns the first element of a collection or the fallback value if empty.\n    \n    Args:\n        collection (list): The list to retrieve the first element from.\n        fallback: The value to return if the collection is empty.\n    \n    Returns:\n        The first element of the collection or the fallback value.\n    \"\"\"\n    if collection:\n        return collection[0]\n    else:\n        return fallback\n```"]}, "lo-find.go-LastOr": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func LastOr[T any](collection []T, fallback T) T {\n# Natural Language Annotations: // LastOr returns the last element of a collection or the fallback value if empty.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef last_or(collection, fallback):\n    \"\"\"\n    Returns the last element of a collection or the fallback value if empty.\n    \n    Args:\n        collection (list): The list to get the last element from.\n        fallback (any): The value to return if the collection is empty.\n    \n    Returns:\n        any: The last element of the collection or the fallback value.\n    \"\"\"\n    return collection[-1] if collection else fallback\n```", "```python\ndef last_or(collection, fallback):\n    \"\"\"\n    Returns the last element of a collection or the fallback value if empty.\n    \n    Args:\n        collection: The collection to retrieve the last element from.\n        fallback: The value to return if the collection is empty.\n    \n    Returns:\n        The last element of the collection or the fallback value.\n    \"\"\"\n    if collection:\n        return collection[-1]\n    else:\n        return fallback\n```", "```python\ndef last_or(collection, fallback):\n    \"\"\"\n    Returns the last element of a collection or the fallback value if empty.\n    \n    Args:\n        collection (list): The collection to retrieve the last element from.\n        fallback: The value to return if the collection is empty.\n    \n    Returns:\n        The last element of the collection, or the fallback value.\n    \"\"\"\n    return collection[-1] if collection else fallback\n```"]}, "lo-math.go-Range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Range(elementNum int) []int {\n# Natural Language Annotations: // Range creates an array of numbers (positive and/or negative) with given length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport \"fmt\"\n\nfunc Range(elementNum int) []int {\n    result := make([]int, elementNum)\n    for i := 0; i < elementNum; i++ {\n        result[i] = i\n    }\n    return result\n}\n\nfunc main() {\n    fmt.Println(Range(5))  // Output: [0 1 2 3 4]\n    fmt.Println(Range(-5)) // Output: [-5 -4 -3 -2 -1]\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc Range(elementNum int) []int {\n    var result []int\n    for i := 0; i < elementNum; i++ {\n        result = append(result, i)\n    }\n    return result\n}\n\nfunc main() {\n    fmt.Println(Range(5))\n}\n```", "```go\npackage main\n\nimport \"fmt\"\n\nfunc Range(elementNum int) []int {\n    var result []int\n    for i := -elementNum; i <= elementNum; i++ {\n        result = append(result, i)\n    }\n    return result\n}\n\nfunc main() {\n    fmt.Println(Range(5))\n}\n```"]}, "lo-math.go-RangeFrom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RangeFrom[T constraints.Integer | constraints.Float](start T, elementNum int) []T {\n# Natural Language Annotations: // RangeFrom creates an array of numbers from start with specified length.\n// Play: https://go.dev/play/p/0r6VimXAi9H\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc RangeFrom[T any](start T, elementNum int) []T {\n    var result []T\n    for i := 0; i < elementNum; i++ {\n        result = append(result, start)\n    }\n    return result\n}\n```", "```go\nfunc RangeFrom[T any](start T, elementNum int) []T {\n    result := make([]T, elementNum)\n    for i := range result {\n        result[i] = start\n    }\n    return result\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc RangeFrom[T any](start T, elementNum int) []T {\n    result := make([]T, elementNum)\n    for i := range result {\n        result[i] = start\n    }\n    return result\n}\n\nfunc main() {\n    fmt.Println(RangeFrom(5, 5))  // [5 5 5 5 5]\n    fmt.Println(RangeFrom(3.14, 3))  // [3.14 3.14 3.14]\n}\n```"]}, "lo-math.go-Mean": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Mean[T constraints.Float | constraints.Integer](collection []T) T {\n# Natural Language Annotations: // Mean calculates the mean of a collection of numbers.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import TypeVar, List\n\nT = TypeVar('T')\n\ndef mean(collection: List[T]) -> T:\n    \"\"\"\n    Calculates the mean of a collection of numbers.\n\n    Args:\n    collection (List[T]): A list of numbers.\n\n    Returns:\n    T: The mean of the collection.\n    \"\"\"\n    if not collection:\n        raise ValueError(\"Cannot calculate mean of an empty collection\")\n    return sum(collection) / len(collection)\n```", "```python\ndef Mean[T](collection: list[T]) -> T:\n    \"\"\"\n    Calculates the mean of a collection of numbers.\n\n    Args:\n        collection (list[T]): A list of numbers.\n\n    Returns:\n        T: The mean of the collection.\n    \"\"\"\n    if not collection:\n        raise ValueError(\"Collection cannot be empty\")\n    return sum(collection) / len(collection)\n```", "```python\ndef mean(collection):\n    \"\"\"\n    Calculates the mean of a collection of numbers.\n\n    Args:\n        collection (list): A list of numbers.\n\n    Returns:\n        float: The mean of the collection.\n\n    Raises:\n        ValueError: If the collection is empty.\n    \"\"\"\n    if len(collection) == 0:\n        raise ValueError(\"Cannot calculate mean of an empty collection\")\n    return sum(collection) / len(collection)\n```"]}, "lo-math.go-MeanBy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MeanBy[T any, R constraints.Float | constraints.Integer](collection []T, iteratee func(item T) R) R {\n# Natural Language Annotations: // MeanBy calculates the mean of a collection of numbers using the given return value from the iteration function.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Callable, Union\n\ndef mean_by[T, R](collection: list[T], iteratee: Callable[[T], Union[float, int]]) -> R:\n    \"\"\"\n    Calculates the mean of a collection of numbers using the given return value from the iteration function.\n\n    Args:\n    collection (list): A list of numbers\n    iteratee (function): A function that takes one argument and returns a number\n\n    Returns:\n    R: The mean of the collection\n    \"\"\"\n    return sum(iteratee(item) for item in collection) / len(collection)\n\n# Example usage:\nnumbers = [1, 2, 3, 4, 5]\nmean = mean_by(numbers, lambda x: x)\nprint(mean)  # Output: 3.0\n\nnumbers = [1.5, 2.5, 3.5, 4.5, 5.5]\nmean = mean_by(numbers, lambda x: x)\nprint(mean)  # Output: 3.5\n```", "```python\nfrom typing import Callable, Any, Union\n\ndef mean_by(collection: list[Any], iteratee: Callable[[Any], Union[float, int]]) -> float:\n    \"\"\"\n    Calculates the mean of a collection of numbers using the given return value from the iteration function.\n\n    Args:\n        collection: A list of items to calculate the mean from.\n        iteratee: A function that takes an item from the collection and returns a number.\n\n    Returns:\n        The mean of the collection.\n    \"\"\"\n    return sum(iteratee(item) for item in collection) / len(collection)\n```", "```python\nfrom typing import Any, Callable, Union\n\ndef mean_by[T, R](collection: list[T], iteratee: Callable[[T], Union[float, int]]) -> R:\n    \"\"\"\n    Calculates the mean of a collection of numbers using the given return value from the iteration function.\n\n    Args:\n    collection (list[T]): A list of elements of type T.\n    iteratee (Callable[[T], Union[float, int]]): A function that takes an item of type T and returns a float or an integer.\n\n    Returns:\n    R: The mean of the collection of numbers.\n    \"\"\"\n    return sum(iteratee(item) for item in collection) / len(collection)\n```"]}, "conc-waitgroup.go-WaitAndRecover": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (h *WaitGroup) WaitAndRecover() *panics.Recovered {\n# Natural Language Annotations: // WaitAndRecover will block until all goroutines spawned with Go exit and\n// will return a *panics.Recovered if one of the child goroutines panics.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (h *WaitGroup) WaitAndRecover() *panic.Recovered {\n    var recovered *panic.Recovered\n    defer func() {\n        if r := recover(); r != nil {\n            recovered = &panic.Recovered{Value: r}\n        }\n    }()\n    h.Wait()\n    return recovered\n}\n```", "```go\nfunc (h *WaitGroup) WaitAndRecover() *panic.Recovered {\n    var recovered *panic.Recovered\n    defer func() {\n        if r := recover(); r != nil {\n            recovered = &panic.Recovered{Value: r}\n        }\n    }()\n    h.Wait()\n    return recovered\n}\n```", "```go\nfunc (h *WaitGroup) WaitAndRecover() *panic.Recovered {\n    var recovered *panic.Recovered\n    defer func() {\n        if r := recover(); r != nil {\n            recovered = &panic.Recovered{Value: r}\n        }\n    }()\n    h.Wait()\n    return recovered\n}\n```"]}, "conc-stream/stream.go-Wait": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Stream) Wait() {\n# Natural Language Annotations: // Wait signals to the stream that all tasks have been submitted. Wait will\n// not return until all tasks and callbacks have been run.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Stream:\n    def __init__(self):\n        self.tasks = []\n        self.callbacks = []\n        self.lock = threading.Lock()\n\n    def submit_task(self, task):\n        with self.lock:\n            self.tasks.append(task)\n\n    def submit_callback(self, callback):\n        with self.lock:\n            self.callbacks.append(callback)\n\n    def wait(self):\n        with self.lock:\n            while self.tasks or self.callbacks:\n                for task in self.tasks[:]:\n                    task.run()\n                    self.tasks.remove(task)\n                for callback in self.callbacks[:]:\n                    callback()\n                    self.callbacks.remove(callback)\n```", "```python\nclass Stream:\n    def __init__(self):\n        self.tasks = []\n        self.callbacks = []\n        self.lock = threading.Lock()\n        self.condition = threading.Condition(self.lock)\n\n    def Wait(self):\n        with self.condition:\n            while len(self.tasks) > 0 or len(self.callbacks) > 0:\n                self.condition.wait()\n```", "```python\nfrom threading import Event\n\nclass Stream:\n    def __init__(self):\n        self.tasks_submitted = False\n        self.tasks_completed = Event()\n\n    def submit_task(self):\n        # simulate task submission\n        self.tasks_submitted = True\n\n    def wait(self):\n        while not self.tasks_submitted:\n            pass\n        self.tasks_completed.wait()\n```"]}, "OpenGFW-analyzer/udp/internal/quic/packet_protector.go-UnProtect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (pp *PacketProtector) UnProtect(packet []byte, pnOffset, pnMax int64) ([]byte, error) {\n# Natural Language Annotations: // UnProtect decrypts a QUIC packet.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport crypto\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.backends import default_backend\n\ndef UnProtect(self, packet, pnOffset, pnMax):\n    # Load the private key from the file\n    with open('private_key.pem', 'rb') as f:\n        private_key = serialization.load_pem_private_key(\n            f.read(),\n            password=None,\n            backend=default_backend()\n        )\n\n    # Decrypt the packet\n    decrypted_packet = private_key.decrypt(\n        packet[pnOffset:pnMax],\n        padding.OAEP(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            algorithm=hashes.SHA256(),\n            label=None\n        )\n    )\n\n    return decrypted_packet, None\n```", "```python\nfrom cryptography.fernet import Fernet\n\ndef unprotect(packet, pn_offset, pn_max):\n    # Generate a Fernet key (you should replace this with your own key)\n    key = Fernet.generate_key()\n    cipher_suite = Fernet(key)\n\n    # Unprotect the packet\n    try:\n        unencrypted_packet = cipher_suite.decrypt(packet)\n        return unencrypted_packet[pn_offset:pn_max], None\n    except Exception as e:\n        return None, str(e)\n```", "```python\nimport base64\nimport hashlib\n\nclass PacketProtector:\n    def UnProtect(self, packet, pnOffset, pnMax):\n        # UnProtect decrypts a QUIC packet.\n        \n        # Check if packet is empty\n        if not packet:\n            return None, \"Packet is empty\"\n        \n        # Calculate the expected packet length\n        expected_len = pnMax - pnOffset\n        \n        # Check if the packet length matches the expected length\n        if len(packet) != expected_len:\n            return None, \"Packet length mismatch\"\n        \n        # Decrypt the packet using AES-256-CBC\n        key = hashlib.sha256(b\"secret_key\").digest()\n        cipher = AES.new(key, AES.MODE_CBC, b'\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0')\n        decrypted_packet = cipher.decrypt(packet)\n        \n        # Remove padding\n        padding_len = decrypted_packet[-1]\n        decrypted_packet = decrypted_packet[:-padding_len]\n        \n        # Decode the packet\n        try:\n            decrypted_packet = base64.b64decode(decrypted_packet)\n        except Exception as e:\n            return None, str(e)\n        \n        return decrypted_packet, None\n```"]}, "hatchet-pkg/encryption/local.go-NewLocalEncryption": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*localEncryptionService, error) {\n# Natural Language Annotations: // NewLocalEncryption creates a new local encryption service. keysetBytes is the raw keyset in\n// base64-encoded JSON format. This can be generated by calling hatchet-admin keyset create-local.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage hatchet\n\nimport (\n    \"encoding/json\"\n    \"errors\"\n    \"fmt\"\n    \"io\"\n    \"log\"\n    \"os\"\n    \"crypto/ecdsa\"\n    \"crypto/elliptic\"\n    \"crypto/rand\"\n)\n\ntype LocalEncryptionService struct {\n    privateEc256 *ecdsa.PrivateKey\n    publicEc256  *ecdsa.PublicKey\n}\n\nfunc NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*LocalEncryptionService, error) {\n    // Decode the private key from base64-encoded JSON\n    var privateKey struct {\n        Key []byte `json:\"key\"`\n    }\n    if err := json.Unmarshal(privateEc256, &privateKey); err != nil {\n        return nil, fmt.Errorf(\"failed to unmarshal private key: %w\", err)\n    }\n    privateEc256, err := ecdsa.ParseECPrivateKey(privateKey.Key)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to parse private key: %w\", err)\n    }\n\n    // Decode the public key from base64-encoded JSON\n    var publicKey struct {\n        Key []byte `json:\"key\"`\n    }\n    if err := json.Unmarshal(publicEc256, &publicKey); err != nil {\n        return nil, fmt.Errorf(\"failed to unmarshal public key: %w\", err)\n    }\n    publicEc256, err = ecdsa.ParseECPrivateKey(publicKey.Key)\n    if err != nil {\n        return nil, fmt.Errorf(\"failed to parse public key: %w\", err)\n    }\n\n    // Generate a new local encryption service\n    return &LocalEncryptionService{\n        privateEc256: privateEc256,\n        publicEc256:  publicEc256,\n    }, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\n\t\"github.com/ethereum/go-ethereum/crypto\"\n)\n\ntype localEncryptionService struct {\n\tprivateKey *ecdsa.PrivateKey\n\tpublicKey  *ecdsa.PublicKey\n}\n\nfunc NewLocalEncryption(masterKey []byte, privateEc256 []byte, publicEc256 []byte) (*localEncryptionService, error) {\n\tvar keyset map[string]interface{}\n\terr := json.Unmarshal(masterKey, &keyset)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tprivateKey, err := ecdsa.GenerateKey(elliptic.P256(), nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif len(privateEc256) > 0 {\n\t\tprivateKey, err = crypto.UnmarshalECDSA(privateEc256)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\tpublicKey := privateKey.Public()\n\n\tif len(publicEc256) > 0 {\n\t\tpublicKey, err = crypto.UnmarshalECDSAPub(publicEc256)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn &localEncryptionService{\n\t\tprivateKey: privateKey,\n\t\tpublicKey:  publicKey,\n\t}, nil\n}\n```", "```go\npackage hatchet\n\nimport (\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"encoding/json\"\n\t\"errors\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/ethereum/go-ethereum/crypto\"\n)\n\ntype LocalEncryptionService struct {\n\tprivateKey *ecdsa.PrivateKey\n\tpublicKey  *ecdsa.PublicKey\n}\n\nfunc NewLocalEncryption(masterKey []byte, privateEc256, publicEc256 []byte) (*LocalEncryptionService, error) {\n\t// Unmarshal keyset from base64-encoded JSON\n\tvar keyset map[string]interface{}\n\terr := json.Unmarshal(masterKey, &keyset)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get private and public keys from keyset\n\tprivateBytes, ok := keyset[\"privateKey\"].([]byte)\n\tif !ok {\n\t\treturn nil, errors.New(\"missing private key in keyset\")\n\t}\n\tpublicBytes, ok := keyset[\"publicKey\"].([]byte)\n\tif !ok {\n\t\treturn nil, errors.New(\"missing public key in keyset\")\n\t}\n\n\t// Decode private and public keys\n\tprivateKey, err := ecdsa.ParseECPrivateKey(privateBytes, nil)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tpublicKey, err := crypto.UnmarshalECDSA(publicBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new LocalEncryptionService instance\n\tlocalEncryptionService := &LocalEncryptionService{\n\t\tprivateKey: privateKey,\n\t\tpublicKey:  publicKey,\n\t}\n\n\treturn localEncryptionService, nil\n}\n```"]}, "hatchet-pkg/encryption/cloudkms.go-NewCloudKMSEncryption": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewCloudKMSEncryption(keyUri string, credentialsJSON, privateEc256, publicEc256 []byte) (*cloudkmsEncryptionService, error) {\n# Natural Language Annotations: // NewCloudKMSEncryption creates a GCP CloudKMS-backed encryption service.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage cloudkms\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"cloud.google.com/go/cloudkms/apiv1\"\n\t\"google.golang.org/api/option\"\n)\n\n// NewCloudKMSEncryption creates a GCP CloudKMS-backed encryption service.\nfunc NewCloudKMSEncryption(keyUri string, credentialsJSON []byte, privateEc256 *ecdsa.PrivateKey, publicEc256 []byte) (*cloudkmsEncryptionService, error) {\n\t// Load credentials from JSON\n\tcredentials, err := ioutil.ReadDir(\"credentials\")\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tvar credentialsMap map[string]interface{}\n\terr = json.Unmarshal(credentialsJSON, &credentialsMap)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new client\n\tclient, err := apiv1.NewKeyManagementClient(context.Background(), option.WithCredentials(credentialsMap))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new encryption service\n\tservice := &cloudkmsEncryptionService{\n\t\tkeyUri:     keyUri,\n\t\tprivateKey: privateEc256,\n\t\tpublicKey:  publicEc256,\n\t\tclient:     client,\n\t}\n\n\treturn service, nil\n}\n\ntype cloudkmsEncryptionService struct {\n\tkeyUri     string\n\tprivateKey *ecdsa.PrivateKey\n\tpublicKey  []byte\n\tclient     *apiv1.KeyManagementClient\n}\n\nfunc (s *cloudkmsEncryptionService) Encrypt(ctx context.Context, plaintext []byte) ([]byte, error) {\n\t// Encrypt plaintext using the private key\n\t// (Implementation of Encrypt method is omitted for brevity)\n\treturn nil, nil\n}\n\nfunc (s *cloudkmsEncryptionService) Decrypt(ctx context.Context, ciphertext []byte) ([]byte, error) {\n\t// Decrypt ciphertext using the private key\n\t// (Implementation of Decrypt method is omitted for brevity)\n\treturn nil, nil\n}\n```", "```go\npackage cloudkms\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"crypto/rand\"\n\t\"crypto/rsa\"\n\t\"crypto/x509\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\n\t\"cloud.google.com/go/cloudkms/apiv1\"\n\t\"google.golang.org/api/option\"\n)\n\n// NewCloudKMSEncryption creates a GCP CloudKMS-backed encryption service.\nfunc NewCloudKMSEncryption(keyUri string, credentialsJSON []byte, privateEc256 *ecdsa.PrivateKey, publicEc256 []byte) (*apiv1.KeyManagementServiceClient, error) {\n\t// Load credentials from JSON\n\tcredentials, err := ioutil.ReadMsgpack(bytes.NewReader(credentialsJSON))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a client\n\tclient, err := apiv1.NewKeyManagementServiceClient(context.Background(), option.WithCredentials(credentials))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new key\n\tkey := &apiv1.CreateKeyRequest{\n\t\tParent: fmt.Sprintf(\"projects/-/locations/-/keyRings/-/cryptoKeys\"),\n\t\tKey: &apiv1.CryptoKey{\n\t\t\tCryptoKey: &apiv1.CryptoKey_AesGcm: {\n\t\t\t\tAesGcm: &apiv1.AesGcmConfig{\n\t\t\t\t\tAesEncryptionAlgorithm: apiv1.AesGcmConfig_Aes_256,\n\t\t\t\t\t// Add other config fields as needed\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Create the key\n\tresp, err := client.CreateKey(context.Background(), key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new key ring\n\tkeyRing := &apiv1.ListKeyRingsRequest{\n\t\tParent: \"projects/-/locations/-\",\n\t}\n\n\t// Get the key ring\n\tkeyRings, err := client.ListKeyRings(context.Background(), keyRing)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the first key ring\n\tkeyRing = keyRings.KeyRings[0]\n\n\t// Create a new key\n\tkey = &apiv1.CreateKeyRequest{\n\t\tParent: fmt.Sprintf(\"%s/%s\", keyRing.Name, \"/cryptoKeys\"),\n\t\tKey: &apiv1.CryptoKey{\n\t\t\tCryptoKey: &apiv1.CryptoKey_Ec: {\n\t\t\t\tEc: &apiv1.EcConfig{\n\t\t\t\t\tEc: &apiv1.EcConfig_Ec256: {\n\t\t\t\t\t\tEc256: &apiv1.Ec256Config{\n\t\t\t\t\t\t\tPublicKey: &apiv1.PublicKey{\n\t\t\t\t\t\t\t\tEcPublicKey: &apiv1.EcPublicKey{\n\t\t\t\t\t\t\t\t\tX: publicEc256,\n\t\t\t\t\t\t\t\t\tY: publicEc256,\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Create the key\n\tresp, err = client.CreateKey(context.Background(), key)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the private key\n\tprivateKey, err := x509.ParseECPrivateKey(privateEc256)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new encryption service\n\treturn &apiv1.KeyManagementServiceClient{\n\t\tPrivateKey: privateKey,\n\t}, nil\n}\n```", "```go\npackage googlecloud\n\nimport (\n\t\"context\"\n\t\"crypto/ecdsa\"\n\t\"crypto/elliptic\"\n\t\"google.golang.org/api/option\"\n\t\"google.golang.org/api/transport/http\"\n\t\"google.golang.org/api/transport/transport\"\n\t\"google.golang.org/api/transport/transport/dial\"\n\t\"google.golang.org/cloud/credential\"\n\t\"google.golang.org/cloud/credential/credentials\"\n\t\"google.golang.org/cloud/credential/providers/google\"\n\t\"google.golang.org/cloud/kms/apiv1\"\n\t\"google.golang.org/grpc\"\n\t\"io/ioutil\"\n\t\"log\"\n)\n\nfunc NewCloudKMSEncryption(keyUri string, credentialsJSON string, privateEc256 *ecdsa.PrivateKey, publicEc256 []byte) (*apiv1.KeyManagementServiceClient, error) {\n\t// Load credentials from JSON\n\tcred, err := credential.NewServiceAccountFromJSON([]byte(credentialsJSON))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new transport\n\tt := &transport.HTTPTransport{\n\t\tDial: dial.Dial,\n\t}\n\n\t// Create a new client\n\tclient, err := apiv1.NewKeyManagementServiceClient(\n\t\tt,\n\t\toption.WithCredentials(cred),\n\t\toption.WithEndpoint(keyUri),\n\t)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Create a new gRPC client\n\tconn, err := grpc.DialContext(context.Background(), keyUri, grpc.WithInsecure())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer conn.Close()\n\n\t// Create a new key management service client\n\tkmsClient := apiv1.NewKeyManagementServiceClient(conn)\n\n\t// Create a new encryption service\n\tencryptionService := &cloudkmsEncryptionService{\n\t\tkmsClient: kmsClient,\n\t\tprivateKey: privateEc256,\n\t\tpublicKey:  publicEc256,\n\t}\n\n\treturn encryptionService, nil\n}\n\ntype cloudkmsEncryptionService struct {\n\tkmsClient *apiv1.KeyManagementServiceClient\n\tprivateKey *ecdsa.PrivateKey\n\tpublicKey  []byte\n}\n```"]}, "hatchet-internal/datautils/render.go-RenderTemplateFields": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n# Natural Language Annotations: // RenderTemplateFields recursively processes the input map, rendering any string fields using the data map.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n\t\"strings\"\n)\n\nfunc RenderTemplateFields(data, input map[string]interface{}) (map[string]interface{}, error) {\n\tfor k, v := range input {\n\t\tif vStr, ok := v.(string); ok {\n\t\t\tif rendered, ok := data[vStr]; ok {\n\t\t\t\tinput[k] = rendered\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"key %s not found in data\", vStr)\n\t\t\t}\n\t\t} else if vMap, ok := v.(map[string]interface{}); ok {\n\t\t\tif rendered, err := RenderTemplateFields(data, vMap); err != nil {\n\t\t\t\treturn nil, err\n\t\t\t} else {\n\t\t\t\tinput[k] = rendered\n\t\t\t}\n\t\t} else if vStr, ok := v.(string) && strings.HasPrefix(vStr, \"{{\") && strings.HasSuffix(vStr, \"}}\") {\n\t\t\tkey := vStr[2 : len(vStr)-2]\n\t\t\tif rendered, ok := data[key]; ok {\n\t\t\t\tinput[k] = rendered\n\t\t\t} else {\n\t\t\t\treturn nil, fmt.Errorf(\"key %s not found in data\", key)\n\t\t\t}\n\t\t} else {\n\t\t\tinput[k] = v\n\t\t}\n\t}\n\treturn input, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strconv\"\n)\n\nfunc RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n\tfor key, value := range input {\n\t\tif reflect.ValueOf(value).Kind() == reflect.Map {\n\t\t\tinput[key], err := RenderTemplateFields(data, value.(map[string]interface{}))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else if reflect.ValueOf(value).Kind() == reflect.String {\n\t\t\tinput[key] = renderStringField(data, value.(string))\n\t\t}\n\t}\n\treturn input, nil\n}\n\nfunc renderStringField(data map[string]interface{}, field string) interface{} {\n\tif val, ok := data[field]; ok {\n\t\tswitch reflect.ValueOf(val).Kind() {\n\t\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n\t\t\treturn strconv.Itoa(int(val.(int)))\n\t\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:\n\t\t\treturn strconv.FormatUint(uint64(val.(uint)), 10)\n\t\tcase reflect.Float32, reflect.Float64:\n\t\t\treturn strconv.FormatFloat(float64(val.(float64)), 'f', -1, 64)\n\t\tdefault:\n\t\t\treturn val\n\t\t}\n\t}\n\treturn field\n}\n\nfunc main() {\n\tdata := map[string]interface{}{\n\t\t\"name\": \"John\",\n\t\t\"age\":  30,\n\t}\n\tinput := map[string]interface{}{\n\t\t\"hello\":  \"Hello {{name}}\",\n\t\t\"ageStr\": \"{{age}}\",\n\t}\n\trendered, err := RenderTemplateFields(data, input)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(rendered)\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"reflect\"\n\t\"strings\"\n)\n\nfunc RenderTemplateFields(data map[string]interface{}, input map[string]interface{}) (map[string]interface{}, error) {\n\tfor key, value := range input {\n\t\tif reflect.TypeOf(value).Kind() == reflect.Map {\n\t\t\tinput[key], err := RenderTemplateFields(data, value.(map[string]interface{}))\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t} else if reflect.TypeOf(value).Kind() == reflect.String {\n\t\t\tinput[key] = RenderStringField(data, value.(string))\n\t\t}\n\t}\n\treturn input, nil\n}\n\nfunc RenderStringField(data map[string]interface{}, str string) string {\n\tfor key, value := range data {\n\t\tstr = strings.ReplaceAll(str, \"{{ \"+key+\" }}\", fmt.Sprintf(\"%v\", value))\n\t}\n\treturn str\n}\n\nfunc main() {\n\tdata := map[string]interface{}{\n\t\t\"name\":    \"John\",\n\t\t\"age\":     30,\n\t\t\"address\": map[string]interface{}{\"street\": \"123 Main St\", \"city\": \"Anytown\"},\n\t}\n\tinput := map[string]interface{}{\n\t\t\"Hello, my name is {{ name }} and I am {{ age }} years old. I live at {{ address.street }}, {{ address.city }}.\",\n\t}\n\tresult, err := RenderTemplateFields(data, input)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(result)\n}\n```"]}, "mox-ratelimit/ratelimit.go-Reset": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (l *Limiter) Reset(ip net.IP, tm time.Time) {\n# Natural Language Annotations: // Reset sets the counter to 0 for key and ip, and subtracts from the ipmasked counts.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (l *Limiter) Reset(ip net.IP, tm time.Time) {\n    // Reset sets the counter to 0 for key and ip, and subtracts from the ipmasked counts.\n    l.key[ip] = 0\n    for k, v := range l.ipmasked {\n        if v.Contains(ip) {\n            l.ipmasked[k] -= 1\n        }\n    }\n}\n```", "```python\nclass Limiter:\n    def __init__(self):\n        self.key_counts = {}\n        self.ipmasked_counts = {}\n\n    def reset(self, ip, tm):\n        if ip not in self.ipmasked_counts:\n            self.ipmasked_counts[ip] = {}\n        self.ipmasked_counts[ip][tm] = 0\n        if tm not in self.key_counts:\n            self.key_counts[tm] = 0\n        self.key_counts[tm] = 0\n```", "```go\nfunc (l *Limiter) Reset(ip net.IP, tm time.Time) {\n    l.key = ip\n    l.count = 0\n    l.lastReset = tm\n    l.ipmaskedCount = l.ipmaskedCounts[ip]\n    for k, v := range l.ipmaskedCounts {\n        l.ipmaskedCounts[k] = v - l.ipmaskedCounts[ip]\n    }\n}\n```"]}, "mox-dns/dns.go-ParseDomainLax": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseDomainLax(s string) (Domain, error) {\n# Natural Language Annotations: // ParseDomainLax parses a domain like ParseDomain, but allows labels with\n// underscores if the entire domain name is ASCII-only non-IDNA and Pedantic mode\n// is not enabled. Used for interoperability, e.g. domains may specify MX\n// targets with underscores.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport idna\nimport re\n\ndef ParseDomainLax(s):\n    try:\n        # Check if the domain is ASCII-only non-IDNA\n        if not re.match('^[a-zA-Z0-9.-]+$', s):\n            raise ValueError('Invalid domain')\n        \n        # Parse the domain\n        domain = idna.decode(s)\n        return domain, None\n    except idna.IDNAError as e:\n        # If IDNA decoding fails, return the original string\n        return s, e\n    except ValueError as e:\n        # If the domain is not ASCII-only non-IDNA, return an error\n        return None, e\n```", "```python\nimport idna\nimport re\n\ndef ParseDomainLax(s: str) -> (str, str):\n    try:\n        try:\n            # Try to parse the domain as an IDNA string\n            idna.decode(s)\n        except idna.IDNAError:\n            # If parsing fails, try to parse it as an ASCII-only domain\n            if re.match(r'^[a-zA-Z0-9.-]+$', s):\n                return s, None\n            else:\n                return None, \"Invalid domain\"\n\n        # Split the domain into labels\n        labels = s.split('.')\n\n        # Check if all labels are valid (ASCII-only or IDNA)\n        for label in labels:\n            try:\n                idna.decode(label)\n            except idna.IDNAError:\n                # If any label is not IDNA, check if it's ASCII-only\n                if not re.match(r'^[a-zA-Z0-9.-]+$', label):\n                    return None, \"Invalid domain\"\n\n        # Join the labels back into a domain string\n        domain = '.'.join(labels)\n\n        return domain, None\n\n    except Exception as e:\n        return None, f\"Error parsing domain: {str(e)}\"\n```", "```python\nfrom idna import encode, decode\nfrom urllib.parse import urlparse\n\ndef ParseDomainLax(s):\n    try:\n        # First, check if the domain is ASCII-only and does not require IDNA encoding\n        if s.isascii():\n            # If the domain is ASCII-only, split it into labels\n            labels = s.split('.')\n            return '.'.join(labels), None\n        # If the domain requires IDNA encoding, encode it\n        else:\n            encoded = encode(s).decode('ascii')\n            # Split the encoded domain into labels\n            labels = encoded.split('.')\n            return '.'.join(labels), None\n    except Exception as e:\n        # If any error occurs during the parsing process, return None and the error\n        return None, e\n\ndef is_ascii_domain(s):\n    try:\n        # Try to encode the domain to ASCII\n        encode(s)\n        return True\n    except UnicodeError:\n        return False\n\ndef ParseDomainLaxPedantic(s):\n    # Check if the domain is ASCII-only\n    if is_ascii_domain(s):\n        # If the domain is ASCII-only, split it into labels\n        labels = s.split('.')\n        return '.'.join(labels), None\n    else:\n        # If the domain is not ASCII-only, try to parse it with IDNA\n        try:\n            encoded = encode(s).decode('ascii')\n            # Split the encoded domain into labels\n            labels = encoded.split('.')\n            return '.'.join(labels), None\n        except Exception as e:\n            # If any error occurs during the parsing process, return None and the error\n            return None, e\n```"]}, "mox-dmarcdb/eval.go-AddEvaluation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n# Natural Language Annotations: // AddEvaluation adds the result of a DMARC evaluation for an incoming message\n// to the database.\n//\n// AddEvaluation sets Evaluation.IntervalHours based on\n// aggregateReportingIntervalSeconds.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nfunc AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n    // Calculate the IntervalHours based on aggregateReportingIntervalSeconds\n    e.IntervalHours = aggregateReportingIntervalSeconds / 3600\n    \n    // Add the result of the DMARC evaluation to the database\n    // Assuming a database connection is established through the context\n    db := ctx.Value(\"db\").(*database.Database)\n    _, err := db.Exec(\"INSERT INTO evaluations (result, interval_hours) VALUES (?, ?)\", e.Result, e.IntervalHours)\n    \n    return err\n}\n```", "```go\nfunc AddEvaluation(ctx context.Context, aggregateReportingIntervalSeconds int, e *Evaluation) error {\n    // Calculate the interval in hours based on aggregateReportingIntervalSeconds\n    e.IntervalHours = aggregateReportingIntervalSeconds / 3600\n    \n    // Add the evaluation to the database\n    // For simplicity, assume db is the database object and Eval is the table in the database\n    // This is a placeholder and actual database operations would depend on the database library being used\n    _, err := db.Exec(\"INSERT INTO Eval (interval, result) VALUES ($1, $2)\", e.IntervalHours, e.Result)\n    \n    // Check for any database errors\n    return err\n}\n```", "```python\nfrom typing import Optional\n\nfrom google.cloud import datacatalog_v1\nfrom google.cloud import storage\nfrom google.cloud import aiplatform\nfrom google.cloud import pubsub_v1\nfrom google.cloud import logging_v2\nfrom google.cloud import bigquery_datatransfer_v1\nfrom google.cloud import bigquery\n\ndef AddEvaluation(ctx, aggregateReportingIntervalSeconds: int, e: 'Evaluation') -> Optional[Exception]:\n    \"\"\"\n    Add the result of a DMARC evaluation for an incoming message to the database.\n    \n    Args:\n        ctx (context.Context): The context of the function.\n        aggregateReportingIntervalSeconds (int): The aggregate reporting interval in seconds.\n        e (Evaluation): The evaluation to be added.\n        \n    Returns:\n        Optional[Exception]: The error if any, otherwise None.\n    \"\"\"\n    # Convert aggregateReportingIntervalSeconds to hours\n    e.IntervalHours = aggregateReportingIntervalSeconds / 3600\n    \n    # Add the evaluation to the database\n    client = bigquery.Client()\n    table_ref = client.dataset('your_dataset').table('your_table')\n    table = client.get_table(table_ref)\n    \n    errors = client.insert_rows(table, [e.__dict__])\n    if errors != []:\n        return errors\n    \n    # Publish the evaluation to Pub/Sub\n    publisher = pubsub_v1.PublisherClient()\n    topic_path = 'your-project-id/topics/your-topic'\n    publisher.publish(topic_path, e.__dict__)\n    \n    # Log the evaluation\n    client = logging_v2.Client()\n    client.logger('your_logger').log_text(str(e))\n    \n    return None\n```"]}, "mox-dmarcdb/eval.go-EvaluationStats": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EvaluationStats(ctx context.Context) (map[string]EvaluationStat, error) {\n# Natural Language Annotations: // EvaluationStats returns evaluation counts and report-sending status per domain.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom contextlib import contextmanager\nfrom typing import Dict\n\nclass EvaluationStat:\n    def __init__(self, passed: int, failed: int, sent: bool):\n        \"\"\"\n        EvaluationStat represents the evaluation count and report-sending status per domain.\n        \n        Args:\n        passed (int): The number of passed evaluations.\n        failed (int): The number of failed evaluations.\n        sent (bool): Whether the report has been sent.\n        \"\"\"\n        self.passed = passed\n        self.failed = failed\n        self.sent = sent\n\ndef EvaluationStats(ctx: 'context.Context') -> Dict[str, EvaluationStat]:\n    \"\"\"\n    EvaluationStats returns evaluation counts and report-sending status per domain.\n\n    Args:\n    ctx (context.Context): The context object.\n\n    Returns:\n    Dict[str, EvaluationStat]: A dictionary containing evaluation counts and report-sending status per domain.\n    \"\"\"\n    # For demonstration purposes, assume the following data\n    evaluation_data = {\n        'domain1': EvaluationStat(10, 2, True),\n        'domain2': EvaluationStat(8, 4, False),\n        'domain3': EvaluationStat(12, 1, True),\n    }\n    return evaluation_data\n```", "```python\nfrom typing import Dict, Any\n\nclass EvaluationStat:\n    def __init__(self, domain: str, success_count: int, failure_count: int, report_sent: bool):\n        self.domain = domain\n        self.success_count = success_count\n        self.failure_count = failure_count\n        self.report_sent = report_sent\n\ndef EvaluationStats(ctx: Dict[str, Any]) -> Dict[str, EvaluationStat]:\n    evaluation_stats = {}\n    \n    # Assuming ctx is a dictionary with domain names as keys and evaluation results as values\n    for domain, result in ctx.items():\n        success_count = result['success_count']\n        failure_count = result['failure_count']\n        report_sent = result['report_sent']\n        \n        evaluation_stats[domain] = EvaluationStat(domain, success_count, failure_count, report_sent)\n    \n    return evaluation_stats\n```", "```python\nfrom typing import Dict, List\nfrom dataclasses import dataclass\nfrom typing import Dict\n\n@dataclass\nclass EvaluationStat:\n    name: str\n    count: int\n    sent: bool\n\ndef EvaluationStats(ctx: Dict) -> Dict[str, EvaluationStat]:\n    evaluation_stats: Dict[str, EvaluationStat] = {}\n    \n    # Sample data (replace with actual logic to fetch data from ctx)\n    domains = [\"domain1\", \"domain2\", \"domain3\"]\n    for domain in domains:\n        stat = EvaluationStat(domain, 10, False)\n        evaluation_stats[domain] = stat\n    \n    return evaluation_stats\n```"]}, "mox-dmarcdb/eval.go-EvaluationsDomain": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EvaluationsDomain(ctx context.Context, domain dns.Domain) ([]Evaluation, error) {\n# Natural Language Annotations: // EvaluationsDomain returns all evaluations for a domain.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nfunc EvaluationsDomain(ctx context.Context, domain dns.Domain) ([]Evaluation, error) {\n    // Implement logic to retrieve evaluations for the given domain\n    // This could involve querying a database or API\n    // For the sake of this example, let's assume we have a function called 'getEvaluations' that does this\n    evaluations, err := getEvaluations(ctx, domain)\n    if err != nil {\n        return nil, err\n    }\n    return evaluations, nil\n}\n```", "```python\nfrom typing import List\nfrom contextlib import contextmanager\nfrom typing import Generator\n\nclass Evaluation:\n    def __init__(self, id: int, domain: str, score: int):\n        self.id = id\n        self.domain = domain\n        self.score = score\n\nclass dns:\n    def __init__(self, domain: str):\n        self.domain = domain\n\n@contextmanager\ndef ctx():\n    # This context manager does nothing, it's a placeholder for context\n    yield\n\ndef EvaluationsDomain(ctx: Generator, domain: dns) -> List[Evaluation]:\n    # This is a placeholder for the actual logic to get evaluations for a domain\n    # It should be replaced with the actual database query or API call\n    evaluations = [\n        Evaluation(1, domain.domain, 80),\n        Evaluation(2, domain.domain, 90),\n        Evaluation(3, domain.domain, 70),\n    ]\n    return evaluations\n```", "```python\nfrom typing import List\nfrom contextlib import contextmanager\nfrom typing import Generator\n\n@contextmanager\ndef ctx() -> Generator:\n    # This function is a context manager that simulates a context\n    # You can replace it with your actual context implementation\n    yield\n\nclass dns:\n    class Domain:\n        def __init__(self, name: str):\n            self.name = name\n\nclass Evaluation:\n    def __init__(self, id: int, result: str):\n        self.id = id\n        self.result = result\n\ndef EvaluationsDomain(ctx, domain: dns.Domain) -> List[Evaluation]:\n    # For demonstration purposes, let's assume we have a function that retrieves evaluations\n    # In a real-world scenario, you would replace this with your actual logic\n    def get_evaluations(domain: dns.Domain) -> List[Evaluation]:\n        # This is a placeholder function to simulate retrieving evaluations\n        return [Evaluation(1, 'passed'), Evaluation(2, 'failed')]\n\n    return get_evaluations(domain)\n```"]}, "mox-dmarcdb/eval.go-RemoveEvaluationsDomain": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func RemoveEvaluationsDomain(ctx context.Context, domain dns.Domain) error {\n# Natural Language Annotations: // RemoveEvaluationsDomain removes evaluations for domain so they won't be sent in\n// an aggregate report.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom google.cloud import aiplatform\nfrom google.cloud import storage\nfrom google.cloud import logging\n\ndef RemoveEvaluationsDomain(ctx, domain):\n    \"\"\"\n    Removes evaluations for domain so they won't be sent in an aggregate report.\n    \n    Args:\n        ctx (context.Context): The context of the function call.\n        domain (dns.Domain): The domain to remove evaluations for.\n    \n    Returns:\n        error: An error if the operation fails.\n    \"\"\"\n    \n    # Create a client for the Aiplatform API\n    aiplatform_client = aiplatform.TabularModelServiceClient()\n    \n    # Create a client for the Cloud Storage API\n    storage_client = storage.Client()\n    \n    # Create a client for the Cloud Logging API\n    logging_client = logging.Client()\n    \n    # Get the project ID from the context\n    project = ctx.project\n    \n    # Get the location of the aiplatform client\n    location = aiplatform_client.location_path(project, 'us-central1')\n    \n    # Get the domain's evaluations\n    evaluations = aiplatform_client.list_model_evaluations(parent=location, filter=f\"model.display_name = '{domain.name}'\")\n    \n    # Remove the evaluations\n    for evaluation in evaluations:\n        aiplatform_client.delete_model_evaluation(name=evaluation.name)\n        \n    # Log the operation\n    logging_client.logger('aiplatform.googleapis.com/remove_evaluations').log_struct('domain', domain.name)\n    \n    return None\n```", "```python\nimport contextlib\n\ndef remove_evaluations_domain(ctx contextlib.Context, domain str) -> None:\n    # Remove evaluations for domain so they won't be sent in an aggregate report.\n    # This function is not implemented in Python as the original function signature is in Go.\n    # However, a possible implementation in Python could be:\n    # 1. Get the evaluations for the domain\n    # 2. Delete the evaluations\n    # 3. Return None\n\n    # For demonstration purposes, let's assume we have a function to get evaluations and delete them\n    def get_evaluations(domain str) -> list:\n        # This function is not implemented as it's out of the scope of this problem\n        pass\n\n    def delete_evaluations(evaluations list) -> None:\n        # This function is not implemented as it's out of the scope of this problem\n        pass\n\n    evaluations = get_evaluations(domain)\n    delete_evaluations(evaluations)\n    return None\n```", "```go\nfunc RemoveEvaluationsDomain(ctx context.Context, domain dns.Domain) error {\n    // Get the database connection from the context\n    db, err := dbFromContext(ctx)\n    if err != nil {\n        return err\n    }\n    defer db.Close()\n\n    // Remove evaluations for the given domain from the database\n    _, err = db.Exec(\"DELETE FROM evaluations WHERE domain = $1\", domain)\n    if err != nil {\n        return err\n    }\n\n    // Remove evaluations for the given domain from the cache\n    cache.RemoveEvaluations(domain)\n\n    return nil\n}\n```"]}, "mox-dmarcdb/reports.go-AddReport": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func AddReport(ctx context.Context, f *dmarcrpt.Feedback, fromDomain dns.Domain) error {\n# Natural Language Annotations: // AddReport adds a DMARC aggregate feedback report from an email to the database,\n// and updates prometheus metrics.\n//\n// fromDomain is the domain in the report message From header.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage dmarc\n\nimport (\n\t\"context\"\n\t\"dns\"\n\t\"errors\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/prometheus/client_golang/prometheus\"\n)\n\n// AddReport adds a DMARC aggregate feedback report from an email to the database, \n// and updates prometheus metrics.\nfunc AddReport(ctx context.Context, f *Feedback, fromDomain dns.Domain) error {\n\t// Check if the fromDomain is valid\n\tif fromDomain == \"\" {\n\t\treturn errors.New(\"fromDomain is required\")\n\t}\n\n\t// Update prometheus metrics\n\t// Assuming we have a prometheus metric named \"dmarc_reports_total\" to track the total number of reports\n\tdmarcReportsTotal := prometheus.NewCounter(prometheus.CounterOpts{\n\t\tNamespace: \"dmarc\",\n\t\tSubsystem: \"reports\",\n\t\tName:      \"total\",\n\t\tHelp:      \"Total number of DMARC reports\",\n\t})\n\tdmarcReportsTotal.Inc()\n\n\t// Add the report to the database\n\t// Assuming we have a function named \"AddFeedback\" to add a feedback report to the database\n\tif err := AddFeedback(ctx, f); err != nil {\n\t\tlog.Printf(\"Error adding report to database: %v\", err)\n\t\treturn err\n\t}\n\n\treturn nil\n}\n```", "```python\nfrom contextlib import contextmanager\nfrom prometheus_client import Counter\nfrom database import db\nfrom dmarc_report import Feedback\n\n# Create a prometheus counter to track the number of reports added\nreport_added = Counter('dmarc_reports_added', 'Number of DMARC reports added')\n\n@contextmanager\ndef add_report(ctx, feedback: Feedback, from_domain: str) -> None:\n    try:\n        # Add the report to the database\n        db.add_report(feedback)\n        \n        # Update prometheus metrics\n        report_added.inc(1)\n        \n        yield None\n    except Exception as e:\n        # Log any errors that occur during the process\n        ctx.log.error(f\"Error adding report: {e}\")\n        raise\n\ndef add_report_to_db(ctx, feedback: Feedback, from_domain: str) -> None:\n    with add_report(ctx, feedback, from_domain):\n        pass\n```", "```python\nfrom contextlib import contextmanager\nfrom prometheus_client import Counter\nfrom typing import Optional\n\n# Create a Prometheus Counter for tracking the number of reports added\nreport_added_counter = Counter('dmarc_reports_added', 'Number of DMARC reports added')\n\n@contextmanager\ndef add_report(ctx: context.Context, f: dmarc_report.Feedback, from_domain: dns.Domain) -> Optional[error]:\n    try:\n        # Add the report to the database\n        db.add_report(f)\n        \n        # Update Prometheus metrics\n        report_added_counter.inc()\n        \n        # Return None to indicate success\n        yield None\n    except Exception as e:\n        # Log the error and return it to the caller\n        ctx.log.error(f\"Error adding report: {e}\")\n        yield e\n\n```"]}, "mox-junk/bloom.go-NewBloom": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewBloom(data []byte, k int) (*Bloom, error) {\n# Natural Language Annotations: // NewBloom returns a bloom filter with given initial data.\n//\n// The number of bits in data must be a power of 2.\n// K is the number of \"hashes\" (bits) to store/lookup for each value stored.\n// Width is calculated as the number of bits needed to represent a single bit/hash\n// position in the data.\n//\n// For each value stored/looked up, a hash over the value is calculated. The hash\n// is split into \"k\" values that are \"width\" bits wide, each used to lookup a bit.\n// K * width must not exceed 256.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\tmath/bits\n)\n\ntype Bloom struct {\n\tdata []byte\n\twidth int\n}\n\nfunc NewBloom(data []byte, k int) (*Bloom, error) {\n\tif len(data)%8 != 0 {\n\t\treturn nil, fmt.Errorf(\"the number of bits in data must be a power of 2\")\n\t}\n\twidth := bits.Len(uint(len(data)) + 1)\n\tif k * width > 256 {\n\t\treturn nil, fmt.Errorf(\"k * width must not exceed 256\")\n\t}\n\tbloom := &Bloom{\n\t\tdata: make([]byte, len(data)),\n\t\twidth: width,\n\t}\n\tfor _, byte := range data {\n\t\thash := md5.Sum([]byte{byte})\n\t\tfor i := 0; i < k; i++ {\n\t\t\tindex := (int(hash[0]) + i) % len(bloom.data)\n\t\t\tbloom.data[index] |= 1 << (bloom.width - 1 - i)\n\t\t}\n\t}\n\treturn bloom, nil\n}\n\nfunc (b *Bloom) Lookup(value []byte) bool {\n\thash := md5.Sum(value)\n\tfor i := 0; i < 5; i++ {\n\t\tindex := (int(hash[0] + i) % len(b.data))\n\t\tif b.data[index]&(1<<(b.width-1-i)) == 0 {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```", "```go\npackage main\n\nimport (\n\t\"crypto/md5\"\n\t\"fmt\"\n\t\"math/bits\"\n)\n\ntype Bloom struct {\n\tdata []byte\n\twidth int\n\tk int\n}\n\nfunc NewBloom(data []byte, k int) (*Bloom, error) {\n\tif len(data)%8 != 0 {\n\t\treturn nil, fmt.Errorf(\"data length must be a power of 2\")\n\t}\n\tif k > 256 / bits.Len(uint(len(data))) {\n\t\treturn nil, fmt.Errorf(\"k exceeds the maximum allowed value\")\n\t}\n\tbloom := &Bloom{\n\t\tdata: data,\n\t\twidth: bits.Len(uint(len(data))),\n\t\tk: k,\n\t}\n\tfor _, byte := range data {\n\t\tfor i := 0; i < k; i++ {\n\t\t\thash := md5.Sum([]byte(fmt.Sprintf(\"%s%x\", data, i)))\n\t\t\tb := hash[0] >> (8 - bloom.width)\n\t\t\tbloom.data[bloom.width*i + b] = 1\n\t\t}\n\t}\n\treturn bloom, nil\n}\n\nfunc (b *Bloom) Contains(data []byte) bool {\n\tfor _, byte := range data {\n\t\tfor i := 0; i < b.k; i++ {\n\t\t\thash := md5.Sum([]byte(fmt.Sprintf(\"%s%x\", data, i)))\n\t\t\tb := hash[0] >> (8 - b.width)\n\t\t\tif b.data[b.width*i + b] != 1 {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\t}\n\treturn true\n}\n```", "```go\npackage main\n\nimport (\n\t\"crypto/md5\"\n\t\"encoding/hex\"\n\t\"fmt\"\n)\n\nconst (\n\tbitSize = 8\n)\n\ntype Bloom struct {\n\tdata []bool\n\twidth int\n\tk     int\n}\n\nfunc NewBloom(data []byte, k int) (*Bloom, error) {\n\tif len(data) == 0 {\n\t\treturn nil, fmt.Errorf(\"data cannot be empty\")\n\t}\n\n\t// Calculate the width as the number of bits needed to represent a single bit position\n\twidth := bitSize * k\n\n\t// Check if k * width does not exceed 256\n\tif k*width > 256 {\n\t\treturn nil, fmt.Errorf(\"k * width must not exceed 256\")\n\t}\n\n\t// Calculate the number of bits needed for the bloom filter\n\tnumBits := (len(data) * 8 + 7) / 8\n\n\t// Ensure the number of bits is a power of 2\n\tif (numBits & (numBits - 1)) != 0 {\n\t\tnumBits = 1 << uint(numBits-1)\n\t}\n\n\t// Initialize the bloom filter with all bits set to false\n\tbloom := make([]bool, numBits)\n\n\t// Create a new bloom filter\n\tb := &Bloom{\n\t\tdata: bloom,\n\t\twidth: width,\n\t\tk:     k,\n\t}\n\n\t// Insert the initial data into the bloom filter\n\tfor _, byteVal := range data {\n\t\tb.Insert(byteVal)\n\t}\n\n\treturn b, nil\n}\n\nfunc (b *Bloom) Insert(val byte) {\n\thash := md5.Sum([]byte(fmt.Sprintf(\"%d%s\", val, val)))\n\tfor i := 0; i < b.k; i++ {\n\t\tindex := int(hash[uint(i)%b.width] & 0xFF)\n\t\tb.data[index] = true\n\t}\n}\n\nfunc (b *Bloom) Contains(val byte) bool {\n\thash := md5.Sum([]byte(fmt.Sprintf(\"%d%s\", val, val)))\n\tfor i := 0; i < b.k; i++ {\n\t\tindex := int(hash[uint(i)%b.width] & 0xFF)\n\t\tif !b.data[index] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n```"]}, "mox-junk/filter.go-NewFilter": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n# Natural Language Annotations: // NewFilter creates a new filter with empty bloom filter and database files. The\n// filter is marked as new until the first save, will be done automatically if\n// TrainDirs is called. If the bloom and/or database files exist, an error is\n// returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n    // Check if the database and bloom filter files already exist\n    if _, err := os.Stat(dbPath); err == nil {\n        return nil, errors.New(\"database file already exists\")\n    }\n    if _, err := os.Stat(bloomPath); err == nil {\n        return nil, errors.New(\"bloom filter file already exists\")\n    }\n\n    // Create a new filter\n    filter := &Filter{\n        new: true,\n        db:  db.NewDB(dbPath),\n        bf:  bloom.NewBloomFilter(bloomPath),\n    }\n\n    return filter, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/your-project/mlog\"\n\t\"github.com/your-project/params\"\n)\n\ntype Filter struct {\n\tdbPath  string\n\tbloomPath string\n\tnew      bool\n}\n\nfunc NewFilter(ctx context.Context, log *mlog.Log, params *params.Params, dbPath, bloomPath string) (*Filter, error) {\n\t// Check if bloom and/or database files exist\n\tif _, err := os.Stat(dbPath); !os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"database file %s already exists\", dbPath)\n\t}\n\tif _, err := os.Stat(bloomPath); !os.IsNotExist(err) {\n\t\treturn nil, fmt.Errorf(\"bloom filter file %s already exists\", bloomPath)\n\t}\n\n\t// Create a new filter\n\tfilter := &Filter{\n\t\tdbPath:  dbPath,\n\t\tbloomPath: bloomPath,\n\t\tnew:      true,\n\t}\n\n\treturn filter, nil\n}\n```", "```go\nfunc NewFilter(ctx context.Context, log mlog.Log, params Params, dbPath, bloomPath string) (*Filter, error) {\n    // Check if the database and bloom files already exist\n    if _, err := os.Stat(dbPath); err == nil {\n        return nil, errors.New(\"database file already exists\")\n    }\n    if _, err := os.Stat(bloomPath); err == nil {\n        return nil, errors.New(\"bloom file already exists\")\n    }\n\n    // Create a new filter\n    filter := &Filter{\n        ctx:      ctx,\n        log:      log,\n        params:   params,\n        dbPath:   dbPath,\n        bloomPath: bloomPath,\n        new:      true,\n    }\n\n    return filter, nil\n}\n```"]}, "mox-junk/filter.go-ClassifyMessagePath": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham, nspam int, rerr error) {\n# Natural Language Annotations: // ClassifyMessagePath is a convenience wrapper for calling ClassifyMessage on a file.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham int, nspam int, rerr error) {\n    // Open the file at the given path\n    file, err := os.Open(path)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n    defer file.Close()\n\n    // Read the entire file into a byte slice\n    contents, err := ioutil.ReadAll(file)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n\n    // Create a map to store unique words\n    words := make(map[string]struct{})\n\n    // Split the contents into words\n    words = splitWords(string(contents), words)\n\n    // Classify the message\n    probability, nham, nspam, err := f.ClassifyMessage(ctx, contents)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n\n    return probability, words, nham, nspam, nil\n}\n\n// Helper function to split a string into words and add unique words to a map\nfunc splitWords(s, words map[string]struct{}) map[string]struct{} {\n    wordsSplit := strings.Fields(s)\n    for _, word := range wordsSplit {\n        words[word] = struct{}{}\n    }\n    return words\n}\n```", "```go\nfunc (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham int, nspam int, err error) {\n    // Open the file at the given path\n    f, err := os.Open(path)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n    defer f.Close()\n\n    // Read the entire file into a string\n    contents, err := ioutil.ReadAll(f)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n\n    // Split the file into a slice of words\n    words := strings.Fields(string(contents))\n\n    // Classify the text\n    probability, classifiedWords := f.ClassifyText(ctx, strings.Join(words, \" \"))\n\n    // Count the number of ham and spam words\n    nham = 0\n    nspam = 0\n    for _, word := range classifiedWords {\n        if word.Class == \"ham\" {\n            nham++\n        } else {\n            nspam++\n        }\n    }\n\n    return probability, map[string]struct{}(classifiedWords), nham, nspam, nil\n}\n```", "```go\nfunc (f *Filter) ClassifyMessagePath(ctx context.Context, path string) (probability float64, words map[string]struct{}, nham int, nspam int, err error) {\n    // Open the file at the given path\n    file, err := os.Open(path)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n    defer file.Close()\n\n    // Read the contents of the file\n    var content string\n    _, err = io.ReadAll(file)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n\n    // Split the content into words\n    words := strings.Split(strings.ToLower(string(content)), \" \")\n\n    // Classify the message\n    probability, nham, nspam, err = f.ClassifyMessage(ctx, words)\n    if err != nil {\n        return 0, nil, 0, 0, err\n    }\n\n    return probability, words, nham, nspam, nil\n}\n```"]}, "mox-junk/filter.go-TrainDirs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n# Natural Language Annotations: // TrainDirs trains and saves a filter with mail messages from different types\n// of directories.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/emersion/mbox-parser/v2\"\n\t\"github.com/emersion/mbox-parser/v2/mail\"\n)\n\ntype Filter struct {\n\tham bool\n\tsent bool\n\tspam bool\n}\n\nfunc (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n\t// Initialize the filter\n\tf.ham = false\n\tf.sent = false\n\tf.spam = false\n\n\t// Open the ham directory\n\terr := filepath.Walk(hamDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif contains(hamFiles, filepath.Base(path)) {\n\t\t\t// Open the email file\n\t\t\tf, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer f.Close()\n\n\t\t\t// Parse the email\n\t\t\tm, err := mail.Load(f)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif m.Subject != \"\" {\n\t\t\t\tf.ham = true\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Open the sent directory\n\terr = filepath.Walk(sentDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif contains(sentFiles, filepath.Base(path)) {\n\t\t\t// Open the email file\n\t\t\tf, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer f.Close()\n\n\t\t\t// Parse the email\n\t\t\tm, err := mail.Load(f)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif m.Subject != \"\" {\n\t\t\t\tf.sent = true\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Open the spam directory\n\terr = filepath.Walk(spamDir, func(path string, info os.FileInfo, err error) error {\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif info.IsDir() {\n\t\t\treturn nil\n\t\t}\n\t\tif contains(spamFiles, filepath.Base(path)) {\n\t\t\t// Open the email file\n\t\t\tf, err := os.Open(path)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer f.Close()\n\n\t\t\t// Parse the email\n\t\t\tm, err := mail.Load(f)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif m.Subject != \"\" {\n\t\t\t\tf.spam = true\n\t\t\t}\n\t\t}\n\t\treturn nil\n\t})\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// Save the filter\n\treturn f.saveFilter()\n}\n\nfunc contains(s []string, e string) bool {\n\tfor _, a := range s {\n\t\tif a == e {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/emlightheart/naivebayes\"\n)\n\ntype Filter struct {\n\ttrainData *naivebayes.TrainData\n}\n\nfunc (f *Filter) TrainDirs(hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n\t// Create a new train data object\n\tf.trainData = naivebayes.NewTrainData()\n\n\t// Add ham files to the train data\n\tfor _, file := range hamFiles {\n\t\t// Read the file\n\t\tdata, err := os.ReadFile(filepath.Join(hamDir, file))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Add the data to the train data\n\t\tf.trainData.AddDoc(data, \"ham\")\n\t}\n\n\t// Add sent files to the train data\n\tfor _, file := range sentFiles {\n\t\t// Read the file\n\t\tdata, err := os.ReadFile(filepath.Join(sentDir, file))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Add the data to the train data\n\t\tf.trainData.AddDoc(data, \"sent\")\n\t}\n\n\t// Add spam files to the train data\n\tfor _, file := range spamFiles {\n\t\t// Read the file\n\t\tdata, err := os.ReadFile(filepath.Join(spamDir, file))\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// Add the data to the train data\n\t\tf.trainData.AddDoc(data, \"spam\")\n\t}\n\n\t// Train the filter\n\tif err := f.trainData.Train(); err != nil {\n\t\treturn err\n\t}\n\n\t// Save the trained filter to a file\n\tif err := f.trainData.Save(\"filter.json\"); err != nil {\n\t\treturn err\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tfilter := &Filter{}\n\terr := filter.TrainDirs(\"ham\", \"sent\", \"spam\", []string{\"file1.txt\", \"file2.txt\"}, []string{\"file3.txt\"}, []string{\"file4.txt\"})\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(\"Filter trained and saved successfully.\")\n}\n```", "```go\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"os\"\n    \"path/filepath\"\n\n    \"github.com/emretezcan/gomailfilter\"\n)\n\nfunc TrainDirs(f *gomailfilter.Filter, hamDir, sentDir, spamDir string, hamFiles, sentFiles, spamFiles []string) error {\n    // Read ham files\n    hamMessages := make([]*gomailfilter.Message, 0)\n    for _, file := range hamFiles {\n        filePath := filepath.Join(hamDir, file)\n        if _, err := os.Stat(filePath); os.IsNotExist(err) {\n            log.Printf(\"File %s does not exist. Skipping...\\n\", filePath)\n            continue\n        }\n        message, err := gomailfilter.LoadMessage(filePath)\n        if err != nil {\n            log.Printf(\"Error loading message from file %s: %v\\n\", filePath, err)\n            continue\n        }\n        hamMessages = append(hamMessages, message)\n    }\n\n    // Read sent files\n    sentMessages := make([]*gomailfilter.Message, 0)\n    for _, file := range sentFiles {\n        filePath := filepath.Join(sentDir, file)\n        if _, err := os.Stat(filePath); os.IsNotExist(err) {\n            log.Printf(\"File %s does not exist. Skipping...\\n\", filePath)\n            continue\n        }\n        message, err := gomailfilter.LoadMessage(filePath)\n        if err != nil {\n            log.Printf(\"Error loading message from file %s: %v\\n\", filePath, err)\n            continue\n        }\n        sentMessages = append(sentMessages, message)\n    }\n\n    // Read spam files\n    spamMessages := make([]*gomailfilter.Message, 0)\n    for _, file := range spamFiles {\n        filePath := filepath.Join(spamDir, file)\n        if _, err := os.Stat(filePath); os.IsNotExist(err) {\n            log.Printf(\"File %s does not exist. Skipping...\\n\", filePath)\n            continue\n        }\n        message, err := gomailfilter.LoadMessage(filePath)\n        if err != nil {\n            log.Printf(\"Error loading message from file %s: %v\\n\", filePath, err)\n            continue\n        }\n        spamMessages = append(spamMessages, message)\n    }\n\n    // Train the filter\n    f.Train(hamMessages, sentMessages, spamMessages)\n\n    // Save the filter\n    err := f.Save()\n    if err != nil {\n        return err\n    }\n\n    return nil\n}\n```"]}, "mox-webmail/message.go-parseListPostAddress": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func parseListPostAddress(s string) *MessageAddress {\n# Natural Language Annotations: // parses List-Post header, returning an address if it could be found, and nil otherwise.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n    \"errors\"\n    \"strings\"\n)\n\ntype MessageAddress struct {\n    Address string\n}\n\nfunc parseListPostAddress(s string) *MessageAddress {\n    // Split the string into lines\n    lines := strings.Split(s, \"\\n\")\n    \n    // Iterate over each line\n    for _, line := range lines {\n        // Check if the line starts with \"List-Post:\", which indicates the start of the header\n        if strings.HasPrefix(line, \"List-Post:\") {\n            // Extract the address from the line\n            address := strings.TrimSpace(strings.TrimPrefix(line, \"List-Post: \"))\n            \n            // Return the address wrapped in a MessageAddress struct\n            return &MessageAddress{Address: address}\n        }\n    }\n    \n    // If no address was found, return nil\n    return nil\n}\n```", "```python\nclass MessageAddress:\n    def __init__(self, address):\n        self.address = address\n\ndef parseListPostAddress(s: str) -> 'MessageAddress':\n    \"\"\"\n    parses List-Post header, returning an address if it could be found, and None otherwise.\n    \"\"\"\n    lines = s.splitlines()\n    for line in lines:\n        if line.startswith('List-Post:'):\n            address = line.split(':', 1)[1].strip()\n            return MessageAddress(address)\n    return None\n```", "```python\nclass MessageAddress:\n    def __init__(self, name, address):\n        self.name = name\n        self.address = address\n\ndef parseListPostAddress(s: str) -> MessageAddress:\n    \"\"\"\n    Parses List-Post header, returning an address if it could be found, and None otherwise.\n    \n    Args:\n        s (str): The List-Post header string\n    \n    Returns:\n        MessageAddress: The parsed address, or None if not found\n    \"\"\"\n    lines = s.split('\\n')\n    for line in lines:\n        if line.startswith('List-Post:'):\n            address = line.split(': ', 1)[1].strip()\n            return MessageAddress('List-Post', address)\n    return None\n```"]}, "mox-webmail/webmail.go-sanitizeNode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func sanitizeNode(node *html.Node) {\n# Natural Language Annotations: // sanitizeNode removes script elements, on* attributes, javascript: href\n// attributes, adds target=\"_blank\" to all links and to a base tag.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"log\"\n\t\"net/html\"\n)\n\ntype Sanitizer struct {\n\t*html.Node\n}\n\nfunc (s *Sanitizer) sanitizeNode(node *html.Node) {\n\tif node.Type == html.ElementNode {\n\t\tswitch node.Data {\n\t\tcase \"script\":\n\t\t\ts.RemoveChild(node)\n\t\t\treturn\n\t\tcase \"a\":\n\t\t\tfor _, attr := range node.Attr {\n\t\t\t\tif attr.Key == \"on*\" || attr.Key == \"href\" && attr.Val == \"javascript:\" {\n\t\t\t\t\ts.RemoveAttr(attr.Key)\n\t\t\t\t}\n\t\t\t}\n\t\t\tif node.Attr == nil || node.Attr[0].Val == \"\" {\n\t\t\t\ts.Attr = append(s.Attr, &html.Attribute{\n\t\t\t\t\tKey:  \"href\",\n\t\t\t\t\tVal:  \"#\",\n\t\t\t\t\tSrc:  nil,\n\t\t\t\t\tSrcSet: nil,\n\t\t\t\t})\n\t\t\t}\n\t\t\ts.Attr = append(s.Attr, &html.Attribute{\n\t\t\t\tKey:  \"target\",\n\t\t\t\tVal:  \"_blank\",\n\t\t\t\tSrc:  nil,\n\t\t\t\tSrcSet: nil,\n\t\t\t})\n\t\tcase \"base\":\n\t\t\ts.Attr = append(s.Attr, &html.Attribute{\n\t\t\t\tKey:  \"target\",\n\t\t\t\tVal:  \"_blank\",\n\t\t\t\tSrc:  nil,\n\t\t\t\tSrcSet: nil,\n\t\t\t})\n\t\t}\n\t}\n\tfor _, child := range node.Children {\n\t\ts.sanitizeNode(child)\n\t}\n}\n\nfunc main() {\n\tdoc, err := html.Parse(strings.NewReader(\"<html><body><script>alert('Hello World!');</script><a href='javascript:alert(1)'>Click me!</a><a href='#'>Link</a><base href='https://example.com'><p>Hello World!</p></body></html>\"))\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tvar sanitizer Sanitizer\n\tsanitizer.Node = doc\n\tsanitizer.sanitizeNode(doc)\n\tout, err := html.MarshalIndent(doc, \"\", \"  \")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(out))\n}\n```", "```python\nfrom bs4 import BeautifulSoup\n\ndef sanitizeNode(node):\n    soup = BeautifulSoup(node, 'html.parser')\n    \n    # Remove script elements\n    for script in soup.find_all('script'):\n        script.decompose()\n        \n    # Remove on* attributes\n    for tag in soup.find_all(True):\n        for attr in list(tag.attrs.keys()):\n            if attr.startswith('on'):\n                del tag[attr]\n                \n    # Remove javascript: href attributes\n    for tag in soup.find_all(True):\n        if 'href' in tag.attrs:\n            if tag.attrs['href'].startswith('javascript:'):\n                del tag['href']\n                \n    # Add target=\"_blank\" to all links\n    for tag in soup.find_all('a'):\n        if 'target' not in tag.attrs:\n            tag['target'] = '_blank'\n            \n    # Add target=\"_blank\" to base tag\n    for tag in soup.find_all('base'):\n        if 'target' not in tag.attrs:\n            tag['target'] = '_blank'\n            \n    return str(soup)\n```", "```python\nfrom bs4 import BeautifulSoup\n\ndef sanitizeNode(node):\n    soup = BeautifulSoup(node, 'html.parser')\n    \n    # Remove script elements\n    for script in soup.find_all('script'):\n        script.decompose()\n        \n    # Remove on* attributes\n    for tag in soup.find_all(True):\n        for attr in list(tag.attrs.keys()):\n            if attr.startswith('on'):\n                del tag.attrs[attr]\n                \n    # Remove javascript: href attributes\n    for tag in soup.find_all(True):\n        if 'href' in tag.attrs:\n            if tag.attrs['href'].startswith('javascript:'):\n                del tag.attrs['href']\n                \n    # Add target=\"_blank\" to all links\n    for link in soup.find_all('a'):\n        if 'href' in link.attrs:\n            link.attrs['target'] = '_blank'\n            \n    # Add target=\"_blank\" to a base tag\n    base_tag = soup.find('base')\n    if base_tag:\n        base_tag.attrs['target'] = '_blank'\n        \n    return str(soup)\n```"]}, "mox-dnsbl/dnsbl.go-Lookup": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Lookup(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain, ip net.IP) (rstatus Status, rexplanation string, rerr error) {\n# Natural Language Annotations: // Lookup checks if \"ip\" occurs in the DNS block list \"zone\" (e.g. dnsbl.example.org).\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Optional\nimport dns.resolver\n\ndef lookup(ctx, elog, resolver, zone, ip):\n    try:\n        answers, _ = resolver.resolve(zone, 'TXT')\n        for rdata in answers:\n            for item in rdata.strings:\n                if ip in item.decode('utf-8'):\n                    return \"BLOCKED\", f\"{ip} is blocked in {zone}\", None\n        return \"ALLOWED\", f\"{ip} is not blocked in {zone}\", None\n    except dns.resolver.NoAnswer:\n        return \"UNKNOWN\", f\"DNS query for {zone} failed\", None\n    except Exception as e:\n        elog.Error(f\"Error looking up {zone}: {str(e)}\")\n        return \"ERROR\", f\"Error looking up {zone}: {str(e)}\", e\n```", "```python\nimport dns.resolver\nimport net\n\ndef Lookup(ctx, elog, resolver, zone, ip):\n    try:\n        answers = resolver.resolve(zone, 'A', ip)\n        if answers.rrset:\n            return Status.SUCCESS, f\"{ip} is listed in {zone}.\", None\n        else:\n            return Status.SUCCESS, f\"{ip} is not listed in {zone}.\", None\n    except dns.resolver.NoAnswer:\n        elog.Warn(\"No answer for %s in %s\", ip, zone)\n        return Status.ERROR, f\"No answer for {ip} in {zone}\", None\n    except dns.resolver.NXDOMAIN:\n        elog.Warn(\"NXDOMAIN for %s in %s\", ip, zone)\n        return Status.ERROR, f\"NXDOMAIN for {ip} in {zone}\", None\n    except Exception as e:\n        elog.Error(\"Error looking up %s in %s: %s\", ip, zone, e)\n        return Status.ERROR, f\"Error looking up {ip} in {zone}: {str(e)}\", e\n```", "```python\nimport dns.resolver\nimport net\nimport contextlib\n\n@contextlib.contextmanager\ndef dnsbl_lookup(ctx, elog, zone, ip):\n    try:\n        with dns.resolver.Resolver() as resolver:\n            resolver.nameservers = [resolver.nameservers[0]]\n            answer = resolver.resolve(zone, 'TXT', ip)\n            for rdata in answer:\n                if str(rdata).startswith('127.0.0.2'):\n                    return True\n        return False\n    except dns.resolver.NoAnswer:\n        elog.Info(\"No answer for DNSBL lookup\")\n        return False\n    except dns.resolver.NXDOMAIN:\n        elog.Info(\"DNSBL zone not found\")\n        return False\n    except Exception as e:\n        elog.Error(f\"Error during DNSBL lookup: {e}\")\n        return False\n\ndef Lookup(ctx, elog, resolver, zone, ip):\n    result = dnsbl_lookup(ctx, elog, zone, ip)\n    status = Status(result)\n    if result:\n        explanation = \"IP is listed in the DNS block list\"\n    else:\n        explanation = \"IP is not listed in the DNS block list\"\n    return status, explanation, None\n```"]}, "mox-dnsbl/dnsbl.go-CheckHealth": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func CheckHealth(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone dns.Domain) (rerr error) {\n# Natural Language Annotations: // CheckHealth checks whether the DNSBL \"zone\" is operating correctly by\n// querying for 127.0.0.2 (must be present) and 127.0.0.1 (must not be present).\n// Users of a DNSBL should periodically check if the DNSBL is still operating\n// properly.\n// For temporary errors, ErrDNS is returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\n\t\"github.com/miekg/dns\"\n)\n\nfunc CheckHealth(ctx context.Context, elog *log.Logger, resolver dns.Resolver, zone dns.Domain) (err error) {\n\t// Query for 127.0.0.2 (must be present)\n\tq1 := dns.NewQuery(zone, \"127.0.0.2\", dns.TypeA)\n\tif err := resolver.AnswerWithContext(ctx, q1); err != nil {\n\t\tif dns.IsErrTemporary(err) {\n\t\t\treturn fmt.Errorf(\"temporary error querying DNSBL zone %s: %w\", zone, err)\n\t\t}\n\t\treturn fmt.Errorf(\"failed to query DNSBL zone %s: %w\", zone, err)\n\t}\n\n\t// Query for 127.0.0.1 (must not be present)\n\tq2 := dns.NewQuery(zone, \"127.0.0.1\", dns.TypeA)\n\tif err := resolver.AnswerWithContext(ctx, q2); err != nil {\n\t\tif dns.IsErrNoAnswer(err) {\n\t\t\treturn nil\n\t\t}\n\t\tif dns.IsErrTemporary(err) {\n\t\t\treturn fmt.Errorf(\"temporary error querying DNSBL zone %s: %w\", zone, err)\n\t\t}\n\t\treturn fmt.Errorf(\"failed to query DNSBL zone %s: %w\", zone, err)\n\t}\n\n\t// If both queries succeed, the DNSBL is healthy\n\treturn nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"log\"\n\n\t\"github.com/miekg/dns\"\n)\n\n// ErrDNS is an error returned when there is a temporary DNS error\nvar ErrDNS = errors.New(\"temporary DNS error\")\n\nfunc CheckHealth(ctx context.Context, elog *log.Logger, resolver dns.Resolver, zone string) error {\n\t// Query for 127.0.0.2 (must be present)\n\tq1 := dns.NewQuery(\"A\", zone, \"127.0.0.2\")\n\tif _, err := resolver.AnswerContext(ctx, q1); err != nil {\n\t\treturn ErrDNS\n\t}\n\n\t// Query for 127.0.0.1 (must not be present)\n\tq2 := dns.NewQuery(\"A\", zone, \"127.0.0.1\")\n\tif _, err := resolver.AnswerContext(ctx, q2); err == nil {\n\t\treturn errors.New(\"unexpected DNS record found\")\n\t}\n\n\treturn nil\n}\n```", "```go\npackage dnsbl\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"time\"\n\n\t\"github.com/sirupsic/slog\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\t\"github.com/miekg/dns\"\n)\n\nfunc CheckHealth(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, zone string) (rerr error) {\n\tp := dns.Fqdn(zone)\n\tanswers, err := resolver.Query(ctx, p, \"A\", \"127.0.0.2\")\n\tif err != nil {\n\t\treturn status.Errorf(codes.Internal, \"Failed to query %s: %v\", p, err)\n\t}\n\tif len(answers) == 0 {\n\t\treturn status.Errorf(codes.Unavailable, \"DNSBL %s does not contain 127.0.0.2\", p)\n\t}\n\n\tanswers, err = resolver.Query(ctx, p, \"A\", \"127.0.0.1\")\n\tif err != nil {\n\t\treturn status.Errorf(codes.Internal, \"Failed to query %s: %v\", p, err)\n\t}\n\tif len(answers) > 0 {\n\t\treturn status.Errorf(codes.Unavailable, \"DNSBL %s contains 127.0.0.1\", p)\n\t}\n\treturn nil\n}\n```"]}, "mox-dmarcrpt/parse.go-ParseMessageReport": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseMessageReport(elog *slog.Logger, r io.ReaderAt) (*Feedback, error) {\n# Natural Language Annotations: // ParseMessageReport parses an aggregate feedback report from a mail message. The\n// maximum message size is 15MB, the maximum report size after decompression is\n// 20MB.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/json\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/mail\"\n\t\"strings\"\n\n\t\"github.com/golang/glog\"\n)\n\ntype Feedback struct {\n\t// Add fields as needed\n}\n\nfunc ParseMessageReport(elog *slog.Logger, r io.ReaderAt) (*Feedback, error) {\n\t// Set the maximum message size to 15MB and the maximum report size to 20MB\n\tconst maxMessageSize = 15 * 1024 * 1024\n\tconst maxReportSize = 20 * 1024 * 1024\n\n\t// Read the message from the reader\n\tbuf := make([]byte, maxMessageSize)\n\t_, err := r.ReadAt(buf, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Decode the message\n\tmsg, err := mail.ReadMessage(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Initialize the feedback struct\n\tvar feedback Feedback\n\n\t// Iterate over the parts of the message\n\tfor _, part := range msg.Alternative {\n\t\t// Check if the part is a text part\n\t\tif part.ContentType == \"text/plain\" {\n\t\t\t// Read the text part\n\t\t\tbody, err := ioutil.ReadAll(part.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\n\t\t\t// Unmarshal the JSON body into the feedback struct\n\t\t\terr = json.Unmarshal(body, &feedback)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check if the feedback struct is empty\n\tif feedback == (Feedback{}) {\n\t\telog.Info(\"No feedback found in the message\")\n\t\treturn nil, nil\n\t}\n\n\treturn &feedback, nil\n}\n```", "```python\nimport gzip\nimport io\nimport logging\nfrom email.parser import BytesParser\nfrom typing import Tuple\n\nclass Feedback:\n    def __init__(self, subject: str, body: str, attachments: list):\n        self.subject = subject\n        self.body = body\n        self.attachments = attachments\n\ndef parse_message_report(elog: logging.Logger, r: io.BufferedReader) -> Tuple[Feedback, Exception]:\n    # Initialize the feedback object\n    feedback = Feedback(\"\", \"\", [])\n\n    # Set the maximum message size to 15MB and the maximum report size after decompression to 20MB\n    max_message_size = 15 * 1024 * 1024\n    max_report_size = 20 * 1024 * 1024\n\n    # Initialize the decompressor\n    decompressor = gzip.GzipFile(fileobj=r, mode='rb')\n\n    # Read the message from the reader\n    message_bytes = r.read(max_message_size)\n\n    # Check if the message is compressed\n    if message_bytes.startswith(b'\\x1f\\x8b\\x08'):\n        # Decompress the message\n        decompressed_bytes = decompressor.read(max_report_size)\n    else:\n        # If the message is not compressed, just use the original bytes\n        decompressed_bytes = message_bytes\n\n    # Parse the message using email parser\n    parser = BytesParser()\n    message = parser.parsebytes(decompressed_bytes)\n\n    # Extract the subject and body from the message\n    feedback.subject = message['subject']\n    feedback.body = message.get_payload(decode=True).decode('utf-8')\n\n    # Extract the attachments from the message\n    for part in message.walk():\n        if part.get_content_maintype() == 'multipart':\n            continue\n        if part.get('Content-Disposition') is not None and 'attachment' in part.get('Content-Disposition'):\n            feedback.attachments.append(part.get_payload(decode=True))\n\n    return feedback, None\n```", "```python\nimport io\nimport gzip\nimport logging\nfrom email.parser import BytesParser\nfrom io import BytesIO\n\nclass Feedback:\n    def __init__(self):\n        self.summary = None\n        self.details = None\n\nclass Slog:\n    def __init__(self, logger):\n        self.logger = logger\n\ndef parse_message_report(elog, r):\n    # Set maximum message size to 15MB and maximum report size to 20MB\n    max_message_size = 15 * 1024 * 1024\n    max_report_size = 20 * 1024 * 1024\n\n    # Read the message from the reader\n    message_bytes = r.read(max_message_size)\n    if len(message_bytes) == 0:\n        return Feedback(), None\n\n    # Check if the message is a gzip compressed message\n    if message_bytes.startswith(b'\\x1f\\x8b\\x08'):\n        # Decompress the message\n        try:\n            message_bytes = gzip.decompress(message_bytes)\n        except Exception as e:\n            elog.logger.error(f\"Error decompressing message: {e}\")\n            return Feedback(), e\n\n    # Parse the message using email parser\n    parser = BytesParser()\n    message = parser.parsebytes(message_bytes)\n\n    # Extract the summary and details from the message\n    summary = ''\n    details = ''\n    for part in message.walk():\n        if part.get_content_type() == 'text/plain':\n            if not summary:\n                summary = part.get_payload()\n            else:\n                details += part.get_payload()\n\n    # Set the summary and details in the feedback object\n    feedback = Feedback()\n    feedback.summary = summary\n    feedback.details = details\n\n    return feedback, None\n```"]}, "mox-mox-/lifecycle.go-Register": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *connections) Register(nc net.Conn, protocol, listener string) {\n# Natural Language Annotations: // Register adds a connection for receiving an immediate i/o deadline on shutdown.\n// When the connection is closed, Remove must be called to cancel the registration.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\ntype connections struct {\n    registered map[string]net.Conn\n}\n\nfunc (c *connections) Register(nc net.Conn, protocol, listener string) {\n    c.registered[protocol+listener] = nc\n    go func() {\n        <-nc.CloseNotify()\n        delete(c.registered, protocol+listener)\n    }()\n}\n```", "```go\ntype Connections struct {\n    registrations map[net.Conn]struct{}\n}\n\nfunc (c *Connections) Register(nc net.Conn, protocol, listener string) {\n    // Register adds a connection for receiving an immediate i/o deadline on shutdown.\n    // When the connection is closed, Remove must be called to cancel the registration.\n    c.registrations[nc] = struct{}{}\n}\n\nfunc (c *Connections) Remove(nc net.Conn) {\n    delete(c.registrations, nc)\n}\n```", "```go\ntype connections struct {\n    registrations map[string]chan struct{}\n}\n\nfunc (c *connections) Register(nc net.Conn, protocol, listener string) {\n    if c.registrations == nil {\n        c.registrations = make(map[string]chan struct{})\n    }\n    c.registrations[listener] = make(chan struct{})\n    go func() {\n        <-nc.CloseNotify()\n        close(c.registrations[listener])\n    }()\n}\n```"]}, "mox-smtpclient/dial.go-Dial": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n# Natural Language Annotations: // Dial connects to host by dialing ips, taking previous attempts in dialedIPs into\n// accounts (for greylisting, blocklisting and ipv4/ipv6).\n//\n// If the previous attempt used IPv4, this attempt will use IPv6 (useful in case\n// one of the IPs is in a DNSBL).\n//\n// The second attempt for an address family we prefer the same IP as earlier, to\n// increase our chances if remote is doing greylisting.\n//\n// Dial updates dialedIPs, callers may want to save it so it can be taken into\n// account for future delivery attempts.\n//\n// The first matching protocol family from localIPs is set for the local side\n// of the TCP connection.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n    // Check if the host has an IPv4 and IPv6 address\n    ip4 := host.IP4()\n    ip6 := host.IP6()\n    \n    // If the host has both IPv4 and IPv6 addresses, use IPv6 first\n    if ip6 != nil {\n        // Check if we have already dialed this host with IPv6\n        if _, ok := dialedIPs[host.String()]; ok {\n            // If we have already dialed this host with IPv6, try to use the same IP\n            for _, ip := range dialedIPs[host.String()] {\n                if ip.Equal(ip6) {\n                    // Try to dial the host with the same IPv6 address\n                    return dialer.DialContext(ctx, ip6, port)\n                }\n            }\n        }\n        // If not, try to dial the host with IPv6\n        return dialer.DialContext(ctx, ip6, port)\n    } else if ip4 != nil {\n        // If the host only has an IPv4 address, try to dial it\n        for _, ip := range ips {\n            if ip.Equal(ip4) {\n                // Try to dial the host with the IPv4 address\n                return dialer.DialContext(ctx, ip, port)\n            }\n        }\n    }\n    \n    // If we have not found a matching IP, return an error\n    return nil, nil, errors.New(\"no matching IP found\")\n}\n\n```", "```go\nfunc Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host dns.IPDomain, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n    // Check if there are any IP addresses to dial\n    if len(ips) == 0 {\n        return nil, nil, errors.New(\"no IPs to dial\")\n    }\n\n    // Try to dial with the first IP address\n    for _, ip := range ips {\n        // Check if this IP address has been previously dialed\n        if _, ok := dialedIPs[ip.String()]; ok {\n            // If it has, try the next IP address in the list\n            continue\n        }\n\n        // Try to dial the IP address\n        conn, rerr := dialer.DialContext(ctx, ip, port)\n        if rerr != nil {\n            // If the dial fails, move on to the next IP address\n            continue\n        }\n\n        // Update the dialedIPs map\n        dialedIPs[ip.String()] = ips\n\n        // Try to set the local IP address\n        for _, localIP := range localIPs {\n            if localIP.To4() != nil && ip.To4() != nil {\n                // Try to set the IPv4 local IP address\n                conn.SetDeadline(time.Now().Add(5 * time.Second))\n                if err := conn.SetLocalAddr(localIP); err != nil {\n                    elog.Errorw(\"failed to set local IPv4 address\", \"err\", err)\n                }\n                break\n            } else if localIP.To16() != nil && ip.To16() != nil {\n                // Try to set the IPv6 local IP address\n                conn.SetDeadline(time.Now().Add(5 * time.Second))\n                if err := conn.SetLocalAddr(localIP); err != nil {\n                    elog.Errorw(\"failed to set local IPv6 address\", \"err\", err)\n                }\n                break\n            }\n        }\n\n        return conn, ip, nil\n    }\n\n    // If no IP address can be dialed, return an error\n    return nil, nil, errors.New(\"no IP address can be dialed\")\n}\n```", "```go\nfunc Dial(ctx context.Context, elog *slog.Logger, dialer Dialer, host string, ips []net.IP, port int, dialedIPs map[string][]net.IP, localIPs []net.IP) (conn net.Conn, ip net.IP, rerr error) {\n    // Try to dial with the given IPs\n    for _, ip := range ips {\n        // Check if the IP is in the dialedIPs map\n        if existingIPs, ok := dialedIPs[ip.String()]; ok {\n            // If the IP is in the map, check if it's from the same address family as the host\n            if ipToUse := net.ParseIP(host); ipToUse != nil {\n                if ipToUse.IsLoopback() || ipToUse.Equal(ip) {\n                    // If the IP is from the same address family, try to dial with it\n                    conn, rerr := dialer.DialContext(ctx, ip, port)\n                    if rerr == nil {\n                        // Update the dialedIPs map\n                        dialedIPs[ip.String()] = append(existingIPs, ip)\n                        return conn, ip, nil\n                    }\n                } else {\n                    // If the IP is not from the same address family, try to dial with the other family\n                    var dialIP net.IP\n                    if ip.To4() != nil {\n                        dialIP = ip.To16()\n                    } else {\n                        dialIP = ip.To4()\n                    }\n                    conn, rerr := dialer.DialContext(ctx, dialIP, port)\n                    if rerr == nil {\n                        // Update the dialedIPs map\n                        dialedIPs[dialIP.String()] = append(existingIPs, dialIP)\n                        return conn, dialIP, nil\n                    }\n                }\n            }\n        } else {\n            // If the IP is not in the map, try to dial with it\n            conn, rerr := dialer.DialContext(ctx, ip, port)\n            if rerr == nil {\n                // Update the dialedIPs map\n                dialedIPs[ip.String()] = []net.IP{ip}\n                return conn, ip, nil\n            }\n        }\n    }\n\n    // If no IP works, try to dial with the first local IP\n    if len(localIPs) > 0 {\n        ipToUse := localIPs[0]\n        conn, rerr := dialer.DialContext(ctx, ipToUse, port)\n        if rerr == nil {\n            // Update the dialedIPs map\n            dialedIPs[ipToUse.String()] = []net.IP{ipToUse}\n            return conn, ipToUse, nil\n        }\n    }\n\n    // If all attempts fail, return an error\n    return nil, nil, errors.New(\"failed to dial host\")\n}\n```"]}, "mox-smtpclient/gather.go-GatherIPs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func GatherIPs(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, network string, host dns.IPDomain, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n# Natural Language Annotations: // GatherIPs looks up the IPs to try for connecting to host, with the IPs ordered\n// to take previous attempts into account. For use with DANE, the CNAME-expanded\n// name is returned, and whether the DNS responses were authentic.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nfunc GatherIPs(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, network string, host dns.IPDomain, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n    var (\n        ipsToTry []net.IP\n        dnsErr error\n        dnsCache = map[string]dns.Result{}\n    )\n\n    // Get the IP addresses that were previously dialed\n    prevIPs := dialedIPs[network]\n    // Check if the network has any previous attempts\n    if prevIPs != nil {\n        // If there were previous attempts, add them to the list of IPs to try\n        ipsToTry = append(ipsToTry, prevIPs...)\n    }\n\n    // Get the A records for the host\n    var aRecords dns.Result\n    aRecords, dnsErr = resolver.LookupIP(ctx, dns.Fqdn(host), dns.Type(\"A\"))\n    if dnsErr != nil {\n        // If there was an error getting the A records, return the error\n        return false, false, \"\", nil, false, dnsErr\n    }\n\n    // Add the A records to the list of IPs to try\n    ipsToTry = append(ipsToTry, aRecords.Packets...)\n\n    // Get the AAAA records for the host\n    var aaaaRecords dns.Result\n    aaaaRecords, dnsErr = resolver.LookupIP(ctx, dns.Fqdn(host), dns.Type(\"AAAA\"))\n    if dnsErr != nil {\n        // If there was an error getting the AAAA records, return the error\n        return false, false, \"\", nil, false, dnsErr\n    }\n\n    // Add the AAAA records to the list of IPs to try\n    ipsToTry = append(ipsToTry, aaaaRecords.Packets...)\n\n    // Check if the host is a CNAME\n    var cnameRecords dns.Result\n    cnameRecords, dnsErr = resolver.LookupCNAME(ctx, dns.Fqdn(host))\n    if dnsErr != nil {\n        // If there was an error getting the CNAME records, return the error\n        return false, false, \"\", nil, false, dnsErr\n    }\n\n    // If the host is a CNAME, get the CNAME-expanded name\n    if len(cnameRecords.Packets) > 0 {\n        expandedHost = cnameRecords.Packets[0].Header.Name\n        expandedAuthentic = true\n    } else {\n        expandedHost = host\n        expandedAuthentic = false\n    }\n\n    // Sort the list of IPs to try based on previous attempts\n    sort.Slice(ipsToTry, func(i, j int) bool {\n        return len(dialedIPs[network][i]) > len(dialedIPs[network][j])\n    })\n\n    // Remove duplicate IPs\n    ips := make([]net.IP, 0, len(ipsToTry))\n    for _, ip := range ipsToTry {\n        if !contains(ips, ip) {\n            ips = append(ips, ip)\n        }\n    }\n\n    // Check if the host has both A and AAAA records\n    dualstack = len(aRecords.Packets) > 0 && len(aaaaRecords.Packets) > 0\n\n    return true, expandedAuthentic, expandedHost, ips, dualstack, nil\n}\n\nfunc contains(s []net.IP, e net.IP) bool {\n    for _, a := range s {\n        if reflect.DeepEqual(a, e) {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\n\t\"github.com/miekg/dns\"\n)\n\nfunc GatherIPs(ctx context.Context, elog *log.Logger, resolver *dns.Resolver, network string, host string, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost string, ips []net.IP, dualstack bool, err error) {\n\t// Check if the host is already in the dialedIPs map\n\tif ips, ok := dialedIPs[host]; ok {\n\t\treturn true, true, host, ips, false, nil\n\t}\n\n\t// Resolve the host to IPs\n\tmx, err := resolver.Exchange(ctx, host, dns.Fqdn)\n\tif err != nil {\n\t\terr = fmt.Errorf(\"failed to resolve %s: %w\", host, err)\n\t\treturn\n\t}\n\n\t// Create a new map to store the resolved IPs\n\tdialedIPs[host] = make([]net.IP, 0, len(mx.Answer))\n\n\t// Iterate over the DNS responses\n\tfor _, rr := range mx.Answer {\n\t\tif a, ok := rr.(*dns.A); ok {\n\t\t\tips = append(ips, a.A)\n\t\t\tdialedIPs[host] = append(dialedIPs[host], a.A)\n\t\t} else if aaaa, ok := rr.(*dns.AAAA); ok {\n\t\t\tips = append(ips, aaaa.AAAA)\n\t\t\tdialedIPs[host] = append(dialedIPs[host], aaaa.AAAA)\n\t\t}\n\t}\n\n\t// Check for dual-stack support\n\tdualstack = len(dialedIPs[host]) > 1\n\n\treturn false, false, \"\", ips, dualstack, nil\n}\n```", "```go\nfunc GatherIPs(ctx context.Context, elog *slog.Logger, resolver dns.Resolver, network string, host dns.IPDomain, dialedIPs map[string][]net.IP) (authentic bool, expandedAuthentic bool, expandedHost dns.Domain, ips []net.IP, dualstack bool, rerr error) {\n    // Initialize variables\n    authentic = false\n    expandedAuthentic = false\n    expandedHost = \"\"\n    dualstack = false\n    \n    // Try to get the expanded host\n    expandedHost, rerr = dns.NewResolver().LookupCname(ctx, host)\n    if rerr != nil {\n        return\n    }\n    \n    // Try to get the IP addresses for the expanded host\n    ips, rerr = resolver.LookupIPAddr(ctx, expandedHost)\n    if rerr != nil {\n        return\n    }\n    \n    // Check for dual stack\n    dualstack = len(ips) > 1\n    \n    // Sort the IPs based on previous attempts\n    ips = sort.Slice(ips, func(i, j int) bool {\n        for k, v := range dialedIPs {\n            for _, ip := range v {\n                if ip.Equal(ips[i]) {\n                    return true\n                }\n                if ip.Equal(ips[j]) {\n                    return false\n                }\n            }\n        }\n        return false\n    })\n    \n    // Set the authentic flag\n    authentic = true\n    \n    // Check if the DNS response is authentic\n    for _, ip := range ips {\n        _, rerr = resolver.LookupCname(ctx, net.JoinHostPort(expandedHost, ip.String()))\n        if rerr != nil {\n            authentic = false\n            break\n        }\n    }\n    \n    // Set the expanded authentic flag\n    if expandedHost == host {\n        expandedAuthentic = true\n    }\n    \n    return\n}\n```"]}, "mox-tlsrpt/report.go-TLSFailureDetails": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func TLSFailureDetails(err error) (ResultType, string) {\n# Natural Language Annotations: // TLSFailureDetails turns errors encountered during TLS handshakes into a result\n// type and failure reason code for use with FailureDetails.\n//\n// Errors from crypto/tls, including local and remote alerts, from crypto/x509,\n// and generic i/o and timeout errors are recognized.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom enum import Enum\nfrom typing import Tuple\n\nclass FailureType(Enum):\n    UNKNOWN = 0\n    BAD_CERTIFICATE = 1\n    UNSUPPORTED_CERTIFICATE = 2\n    CERTIFICATE_REVOKED = 3\n    CERTIFICATE_EXPIRED = 4\n    CERTIFICATE_UNTRUSTED = 5\n    CERTIFICATE_CHAIN_TOO_LONG = 6\n    NO_CERTIFICATE = 7\n    CERTIFICATE_UNAVAILABLE = 8\n    IO_ERROR = 9\n    TIMEOUT = 10\n    HANDSHAKE_FAILURE = 11\n    ALERT_RECEIVED = 12\n\ndef TLSFailureDetails(err):\n    \"\"\"\n    Turns errors encountered during TLS handshakes into a result type and failure reason code for use with FailureDetails.\n\n    Args:\n        err: The error that occurred during the TLS handshake.\n\n    Returns:\n        A tuple containing the failure type and a string describing the failure reason.\n    \"\"\"\n    failure_types = {\n        ValueError: (FailureType.UNKNOWN, \"Unknown error\"),\n        ValueError: (FailureType.BAD_CERTIFICATE, \"Bad certificate\"),\n        ValueError: (FailureType.UNSUPPORTED_CERTIFICATE, \"Unsupported certificate\"),\n        ValueError: (FailureType.CERTIFICATE_REVOKED, \"Certificate revoked\"),\n        ValueError: (FailureType.CERTIFICATE_EXPIRED, \"Certificate expired\"),\n        ValueError: (FailureType.CERTIFICATE_UNTRUSTED, \"Certificate untrusted\"),\n        ValueError: (FailureType.CERTIFICATE_CHAIN_TOO_LONG, \"Certificate chain too long\"),\n        ValueError: (FailureType.NO_CERTIFICATE, \"No certificate\"),\n        ValueError: (FailureType.CERTIFICATE_UNAVAILABLE, \"Certificate unavailable\"),\n        IOError: (FailureType.IO_ERROR, \"IO error\"),\n        TimeoutError: (FailureType.TIMEOUT, \"Timeout\"),\n        OSError: (FailureType.HANDSHAKE_FAILURE, \"Handshake failure\"),\n        ConnectionResetError: (FailureType.ALERT_RECEIVED, \"Alert received\"),\n    }\n    \n    if isinstance(err, Exception):\n        for exc, (failure_type, reason) in failure_types.items():\n            if isinstance(err, exc):\n                return failure_type, reason\n    return FailureType.UNKNOWN, \"Unknown error\"\n```", "```sql\nfunc TLSFailureDetails(err error) (ResultType, string) {\n    var resultType ResultType\n    var reasonCode string\n\n    if errors.Is(err, tls.AlertBadCertificate) || errors.Is(err, tls.AlertCertificateExpired) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate error\"\n    } else if errors.Is(err, tls.AlertCertificateUnknown) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Unknown certificate\"\n    } else if errors.Is(err, tls.AlertCertificateRevoked) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate revoked\"\n    } else if errors.Is(err, tls.AlertCertificateRequired) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate required\"\n    } else if errors.Is(err, tls.AlertCertificateUntrusted) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate untrusted\"\n    } else if errors.Is(err, tls.AlertUnsupportedCertificate) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Unsupported certificate\"\n    } else if errors.Is(err, tls.AlertHandshakeFailure) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Handshake failure\"\n    } else if errors.Is(err, tls.AlertBadCertificateWithCA) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate error with CA\"\n    } else if errors.Is(err, tls.AlertCertificateUnparse) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate unparsing error\"\n    } else if errors.Is(err, crypto/x509.CertificateInvalidError) {\n        resultType = \"TLSHandshakeFailure\"\n        reasonCode = \"Certificate invalid\"\n    } else if errors.Is(err, net.Error) {\n        resultType = \"GenericError\"\n        reasonCode = \"Generic I/O error\"\n    } else if errors.Is(err, context.DeadlineExceeded) {\n        resultType = \"TimeoutError\"\n        reasonCode = \"Timeout error\"\n    } else {\n        resultType = \"UnknownError\"\n        reasonCode = \"Unknown error\"\n    }\n\n    return resultType, reasonCode\n}\n```", "```python\nfrom enum import Enum\nimport ssl\n\nclass TLSFailureReason(Enum):\n    UNSUPPORTED_PROTOCOL = \"unsupported protocol\"\n    UNSUPPORTED_VERSION = \"unsupported version\"\n    CERTIFICATE_VERIFY_FAILED = \"certificate verify failed\"\n    CERTIFICATE_REVOKED = \"certificate revoked\"\n    CERTIFICATE_EXPIRED = \"certificate expired\"\n    CERTIFICATE_INVALID = \"certificate invalid\"\n    CERTIFICATE_UNTRUSTED = \"certificate untrusted\"\n    IO_ERROR = \"io error\"\n    TIMEOUT = \"timeout\"\n    ALERT = \"alert\"\n    UNKNOWN_ERROR = \"unknown error\"\n\ndef TLSFailureDetails(err):\n    \"\"\"\n    Turns errors encountered during TLS handshakes into a result type and failure reason code.\n    \n    Args:\n        err (Exception): Error encountered during TLS handshake.\n    \n    Returns:\n        tuple: A tuple containing the result type and failure reason code.\n    \"\"\"\n    if isinstance(err, ssl.SSLError):\n        if err.args[0] == ssl.SSL_ERROR_SSL:\n            if err.args[1] == 48:  # 48 is the value for \"unsupported protocol\"\n                return \"failure\", TLSFailureReason.UNSUPPORTED_PROTOCOL.value\n            elif err.args[1] == 46:  # 46 is the value for \"unsupported version\"\n                return \"failure\", TLSFailureReason.UNSUPPORTED_VERSION.value\n        elif err.args[0] == ssl.SSL_ERROR_SSL:\n            if err.args[1] == 47:  # 47 is the value for \"certificate verify failed\"\n                return \"failure\", TLSFailureReason.CERTIFICATE_VERIFY_FAILED.value\n            elif err.args[1] == 42:  # 42 is the value for \"certificate revoked\"\n                return \"failure\", TLSFailureReason.CERTIFICATE_REVOKED.value\n            elif err.args[1] == 42:  # 42 is the value for \"certificate expired\"\n                return \"failure\", TLSFailureReason.CERTIFICATE_EXPIRED.value\n            elif err.args[1] == 42:  # 42 is the value for \"certificate invalid\"\n                return \"failure\", TLSFailureReason.CERTIFICATE_INVALID.value\n            elif err.args[1] == 46:  # 46 is the value for \"certificate untrusted\"\n                return \"failure\", TLSFailureReason.CERTIFICATE_UNTRUSTED.value\n        elif err.args[0] == ssl.SSL_ERROR_WANT_READ:\n            return \"failure\", TLSFailureReason.IO_ERROR.value\n        elif err.args[0] == ssl.SSL_ERROR_WANT_WRITE:\n            return \"failure\", TLSFailureReason.IO_ERROR.value\n        elif err.args[0] == ssl.SSL_ERROR_TIMEOUT:\n            return \"failure\", TLSFailureReason.TIMEOUT.value\n        else:\n            return \"failure\", TLSFailureReason.UNKNOWN_ERROR.value\n    else:\n        return \"failure\", TLSFailureReason.UNKNOWN_ERROR.value\n```"]}, "mox-tlsrpt/report.go-ParseMessage": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n# Natural Language Annotations: // ParseMessage parses a Report from a mail message.\n// The maximum size of the message is 15MB, the maximum size of the\n// decompressed report is 20MB.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"log\"\n\t\"net/mail\"\n\n\t\"github.com/slog-go/slog\"\n)\n\n// ReportJSON is the JSON representation of a Report.\ntype ReportJSON struct {\n\t// Add fields as needed\n}\n\nfunc ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n\t// Create a new mail message\n\tmsg, err := mail.ReadMessage(r)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Parse the message body\n\tvar reportJSON ReportJSON\n\tif err := json.Unmarshal(msg.Body, &reportJSON); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &reportJSON, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\n\t\"github.com/go-ini/ini\"\n\t\"github.com/slog-go/slog\"\n)\n\ntype ReportJSON struct {\n\tReport string `json:\"report\"`\n}\n\nfunc ParseMessage(elog *slog.Logger, r io.ReaderAt) (*ReportJSON, error) {\n\t// Check if the message is corrupted\n\tif err := r.Close(); err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Read the message from the reader\n\tbuf := make([]byte, 15*1024*1024)\n\tn, err := r.ReadAt(buf, 0)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Check if the message is too large\n\tif n > 15*1024*1024 {\n\t\treturn nil, err\n\t}\n\n\t// Create a new ini file\n\tcfg, err := ini.LoadBytes(buf)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Get the report from the ini file\n\tvar reportJSON ReportJSON\n\tif err := cfg.Section(\"\").MapTo(&reportJSON); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &reportJSON, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\n\t\"github.com/natefinch/lumberjack\"\n)\n\n// ReportJSON is a JSON representation of a Report.\ntype ReportJSON struct {\n\tID       string `json:\"id\"`\n\tSubject  string `json:\"subject\"`\n\tContent  string `json:\"content\"`\n\tAttachments []struct {\n\t\tFileName string `json:\"file_name\"`\n\t\tFileData string `json:\"file_data\"`\n\t} `json:\"attachments\"`\n}\n\nfunc ParseMessage(elog *lumberjack.Logger, r io.ReaderAt) (*ReportJSON, error) {\n\t// Read the message from the reader\n\tbuf, err := ioutil.ReadAll(io.LimitReader(r, 15*1024*1024))\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Decompress the message\n\t// For simplicity, assume the message is compressed with gzip\n\tvar compressedMessage []byte\n\tif err := json.Unmarshal(buf, &compressedMessage); err != nil {\n\t\treturn nil, err\n\t}\n\tdecompressedMessage, err := decompress(compressedMessage)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// Unmarshal the decompressed message into a ReportJSON\n\tvar report ReportJSON\n\tif err := json.Unmarshal(decompressedMessage, &report); err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &report, nil\n}\n\nfunc decompress(compressed []byte) ([]byte, error) {\n\t// Implement decompression logic here\n\t// For simplicity, assume the message is compressed with gzip\n\tvar decompressed []byte\n\t// ...\n\treturn decompressed, nil\n}\n```"]}, "mox-spf/received.go-Header": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r Received) Header() string {\n# Natural Language Annotations: // Header returns a Received-SPF header including trailing crlf that can be\n// prepended to an incoming message.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nfunc Header(r *http.Request) string {\n    return fmt.Sprintf(\"Received: %s\\r\\n\", r.RemoteAddr)\n}\n```", "```python\ndef header(r):\n    \"\"\"\n    Returns a Received-SPF header including trailing crlf that can be\n    prepended to an incoming message.\n    \"\"\"\n    return f\"Received-SPF: pass\\n\"\n```", "```python\ndef header(r):\n    return f\"Received: {r}\\r\\n\"\n```"]}, "mox-spf/spf.go-Evaluate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Evaluate(ctx context.Context, elog *slog.Logger, record *Record, resolver dns.Resolver, args Args) (rstatus Status, mechanism, rexplanation string, rauthentic bool, rerr error) {\n# Natural Language Annotations: // Evaluate evaluates the IP and names from args against the SPF DNS record for the domain.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Dict\n\nfrom google.protobuf import descriptor\nfrom google.protobuf import message\nfrom google.protobuf import reflection\n\nclass Record:\n    def __init__(self):\n        self.ip = \"\"\n        self.name = \"\"\n\nclass Status:\n    pass\n\nclass Args:\n    def __init__(self):\n        self.ip = \"\"\n        self.name = \"\"\n\nclass slog:\n    def __init__(self, level):\n        self.level = level\n\nclass dns:\n    class Resolver:\n        def __init__(self):\n            self.records = {}\n\n        def lookup(self, domain):\n            return self.records.get(domain)\n\nclass context:\n    pass\n\ndef Evaluate(ctx context.Context, elog slog.Logger, record Record, resolver dns.Resolver, args Args) -> (Status, str, str, bool, str):\n    \"\"\"\n    Evaluate evaluates the IP and names from args against the SPF DNS record for the domain.\n    \"\"\"\n    # Get the IP and name from the Args object\n    ip = args.ip\n    name = args.name\n\n    # Get the SPF DNS record for the domain\n    dns_record = resolver.lookup(name)\n\n    # Check if the IP is in the SPF record\n    if ip in dns_record:\n        # If the IP is in the SPF record, return a success status\n        return Status(), \"Success\", \"The IP is in the SPF record\", True, \"\"\n\n    # If the IP is not in the SPF record, return a failure status\n    return Status(), \"Failure\", \"The IP is not in the SPF record\", False, \"\"\n```", "```python\nfrom typing import Context, Args\n\nclass Status:\n    PASS = \"pass\"\n    FAIL = \"fail\"\n    NEUTRAL = \"neutral\"\n    TEMPERROR = \"temperror\"\n    PERMERROR = \"permerror\"\n\nclass Record:\n    def __init__(self, ip, name):\n        self.ip = ip\n        self.name = name\n\nclass Args:\n    def __init__(self, ip, name):\n        self.ip = ip\n        self.name = name\n\nclass Logger:\n    def debug(self, message):\n        print(f\"DEBUG: {message}\")\n\ndef Evaluate(ctx, elog, record, resolver, args):\n    \"\"\"\n    Evaluates the IP and names from args against the SPF DNS record for the domain.\n    \n    Args:\n        ctx (Context): The context object.\n        elog (Logger): The logger object.\n        record (Record): The record object.\n        resolver (dns.Resolver): The DNS resolver.\n        args (Args): The arguments object.\n    \n    Returns:\n        rstatus (Status): The result status.\n        mechanism (str): The mechanism.\n        rexplanation (str): The explanation.\n        rauthentic (bool): Whether the record is authentic.\n        rerr (error): The error.\n    \"\"\"\n    # Resolve the SPF DNS record for the domain\n    try:\n        spf_record = resolver.resolve(args.name, 'TXT')\n    except Exception as e:\n        elog.debug(f\"Error resolving SPF record: {e}\")\n        return Status.TEMPERROR, None, f\"Temporary error resolving SPF record: {e}\", False, None\n\n    # Check if the SPF record exists\n    if not spf_record:\n        elog.debug(\"No SPF record found\")\n        return Status.NEUTRAL, None, \"No SPF record found\", False, None\n\n    # Extract the mechanism from the SPF record\n    mechanism = None\n    for txt in spf_record:\n        if txt.startswith(\"v=spf1\"):\n            mechanism = txt.split()[1]\n            break\n\n    # Evaluate the IP and names against the SPF record\n    # This is a simplified example and actual implementation may vary based on the SPF record mechanism\n    if mechanism == \"all\":\n        rstatus = Status.PASS if record.ip in [ip for ip in args.ip] else Status.FAIL\n    else:\n        rstatus = Status.PASS\n\n    # Determine if the record is authentic\n    rauthentic = rstatus == Status.PASS\n\n    # Return the result\n    return rstatus, mechanism, f\"SPF mechanism: {mechanism}\", rauthentic, None\n```", "```sql\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"log\"\n\t\"net\"\n\t\"strings\"\n\n\t\"github.com/miekg/dns\"\n)\n\ntype Args struct {\n\tIPs  []string\n\tDomains []string\n}\n\ntype Status string\ntype Record struct {\n\tRecords []string\n}\n\ntype slog struct {\n\t*log.Logger\n}\n\nfunc Evaluate(ctx context.Context, elog *slog.Logger, record *Record, resolver dns.Resolver, args Args) (rstatus Status, mechanism, rexplanation string, rauthentic bool, rerr error) {\n\tfor _, domain := range args.Domains {\n\t\tfor _, ip := range args.IPs {\n\t\t\tmechanism = \"unknown\"\n\t\t\trexplanation = \"\"\n\t\t\trauthentic = false\n\t\t\trerr = nil\n\t\t\tmxRecords, err := resolver.LookupIP(\"A\", domain)\n\t\t\tif err != nil {\n\t\t\t\treturn \"error\", \"\", \"\", false, err\n\t\t\t}\n\t\t\tfor _, mxRecord := range mxRecords {\n\t\t\t\tif ip == mxRecord.IP {\n\t\t\t\t\tmechanism = \"match\"\n\t\t\t\t\trexplanation = fmt.Sprintf(\"IP %s matches SPF record for domain %s\", ip, domain)\n\t\t\t\t\trauthentic = true\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tif rauthentic {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif rauthentic {\n\t\t\tbreak\n\t\t}\n\t}\n\treturn rstatus, mechanism, rexplanation, rauthentic, rerr\n}\n```"]}, "mox-spf/parse.go-Record": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r Record) Record() (string, error) {\n# Natural Language Annotations: // Record returns an DNS record, to be configured as a TXT record for a domain,\n// e.g. a TXT record for example.com.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Dict, List\n\nclass Record:\n    def __init__(self, domain: str, record_type: str, value: str):\n        self.domain = domain\n        self.record_type = record_type\n        self.value = value\n\n    def __str__(self):\n        return f\"{self.record_type}.{self.domain} = \\\"{self.value}\\\"\"\n\ndef TXT_record(record: Record) -> (str, None):\n    \"\"\"\n    Returns a DNS record, to be configured as a TXT record for a domain,\n    e.g. a TXT record for example.com.\n    \n    Args:\n    record (Record): A Record object containing the domain and the TXT record value.\n    \n    Returns:\n    tuple: A tuple containing the TXT record as a string and no error.\n    \"\"\"\n    if isinstance(record, Record) and record.record_type == \"TXT\":\n        return str(record), None\n    else:\n        return \"\", \"Invalid record type\"\n```", "```python\nfrom typing import Tuple\n\nclass Record:\n    def __init__(self, domain: str, txt_record: str):\n        \"\"\"\n        Initialize a DNS record.\n\n        Args:\n        domain (str): The domain to be configured.\n        txt_record (str): The TXT record to be configured.\n        \"\"\"\n        self.domain = domain\n        self.txt_record = txt_record\n\n    def __str__(self) -> Tuple[str, None]:\n        \"\"\"\n        Return the DNS record as a string.\n\n        Returns:\n        Tuple[str, None]: A tuple containing the DNS record and None.\n        \"\"\"\n        return f\"{self.domain}.TXT = {self.txt_record}\", None\n\n# Example usage:\nrecord = Record(\"example.com\", \"Hello, World!\")\nprint(record.__str__())  # Output: ('example.com.TXT = Hello, World!', None)\n```", "```python\ndef record(r: dict) -> (str, str):\n    \"\"\"\n    Returns a DNS record, to be configured as a TXT record for a domain,\n    e.g. a TXT record for example.com.\n    \n    Args:\n        r (dict): A dictionary containing the record details.\n        \n    Returns:\n        tuple: A tuple containing the TXT record and an error message.\n    \"\"\"\n    \n    # Check if the input is a dictionary\n    if not isinstance(r, dict):\n        return \"\", \"Error: Input must be a dictionary\"\n    \n    # Check if the dictionary contains the required keys\n    required_keys = [\"domain\", \"value\"]\n    if not all(key in r for key in required_keys):\n        return \"\", \"Error: Dictionary must contain 'domain' and 'value' keys\"\n    \n    # Construct the TXT record\n    record = f\"\\\"{r['value']}\\\"\"\n    \n    # Check if the domain is a string\n    if not isinstance(r['domain'], str):\n        return \"\", \"Error: Domain must be a string\"\n    \n    # Return the TXT record and an empty error message\n    return f\"{r['domain']}. IN TXT {record}\", \"\"\n```"]}, "mox-message/part.go-EnsurePart": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func EnsurePart(elog *slog.Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n# Natural Language Annotations: // EnsurePart parses a part as with Parse, but ensures a usable part is always\n// returned, even if error is non-nil. If a parse error occurs, the message is\n// returned as application/octet-stream, and headers can still be read if they\n// were valid.\n//\n// If strict is set, fewer attempts are made to continue parsing when errors are\n// encountered, such as with invalid content-type headers or bare carriage returns.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"bytes\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/textproto\"\n)\n\ntype Part struct {\n\tHeaders http.Header\n\tContent io.Reader\n}\n\nfunc EnsurePart(elog *log.Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n\tpart, err := Parse(r, size)\n\tif err != nil {\n\t\telog.Println(err)\n\t\tif !strict {\n\t\t\t// If not strict, try to recover from errors\n\t\t\tif err == io.EOF {\n\t\t\t\t// Handle EOF\n\t\t\t\treturn Part{}, nil\n\t\t\t} else if err == io.ErrUnexpectedEOF {\n\t\t\t\t// Handle unexpected EOF\n\t\t\t\treturn Part{}, nil\n\t\t\t} else if err == http.ErrNotContentLength {\n\t\t\t\t// Handle non-Content-Length headers\n\t\t\t\theaders := make(http.Header)\n\t\t\t\treturn Part{Headers: headers, Content: r}, nil\n\t\t\t}\n\t\t\t// If content-type header is invalid, return it as application/octet-stream\n\t\t\tct := r.Header().Get(\"Content-Type\")\n\t\t\tif ct != \"\" {\n\t\t\t\tif !strings.HasPrefix(ct, \"application/octet-stream\") {\n\t\t\t\t\tct = \"application/octet-stream\"\n\t\t\t\t}\n\t\t\t\treturn Part{Headers: http.Header{\"Content-Type\": {ct}}, Content: r}, nil\n\t\t\t}\n\t\t\t// If strict is false and a bare carriage return is encountered, return the part as application/octet-stream\n\t\t\tif !strict && bytes.Contains([]byte(\"MIME-Version\"), []byte(\"\\r\\n\")) {\n\t\t\t\treturn Part{Headers: http.Header{\"Content-Type\": {\"application/octet-stream\"}}, Content: r}, nil\n\t\t\t}\n\t\t}\n\t\t// If strict is true or an error occurred, return an empty part\n\t\treturn Part{}, err\n\t}\n\treturn part, nil\n}\n```", "```go\npackage slog\n\nimport (\n\t\"io\"\n\t\"net/http\"\n\n\t\"github.com/your/project/yourpkg\"\n)\n\nfunc EnsurePart(elog *Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n\tpart, err := Parse(elog, r, size)\n\tif err != nil {\n\t\tif strict {\n\t\t\treturn part, err\n\t\t}\n\n\t\tif err == ErrInvalidContentType {\n\t\t\telog.Error(\"Invalid content-type header\")\n\t\t} else if err == ErrBareCarriageReturn {\n\t\t\telog.Error(\"Bare carriage return encountered\")\n\t\t}\n\n\t\t// Try to read headers\n\t\theaders, err := readHeaders(r)\n\t\tif err != nil {\n\t\t\treturn part, err\n\t\t}\n\n\t\t// Try to read body\n\t\tbody, err := readBody(r, size)\n\t\tif err != nil {\n\t\t\treturn part, err\n\t\t}\n\n\t\t// Create a new part with the headers and body\n\t\tpart = &Part{\n\t\t\tHeaders: headers,\n\t\t\tBody:   body,\n\t\t}\n\n\t\treturn part, nil\n\t}\n\n\treturn part, nil\n}\n\n// readHeaders reads the headers from the reader.\nfunc readHeaders(r io.ReaderAt) (http.Header, error) {\n\t// implement reading headers logic here\n}\n\n// readBody reads the body from the reader.\nfunc readBody(r io.ReaderAt, size int64) ([]byte, error) {\n\t// implement reading body logic here\n}\n```", "```go\npackage slog\n\nimport (\n\t\"encoding/json\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"net/http\"\n\t\"strings\"\n\n\t\"github.com/go-log/slog\"\n)\n\ntype Part struct {\n\tContentLength int64\n\tContentType  string\n\tBody        io.ReaderAt\n}\n\nfunc EnsurePart(elog *Logger, strict bool, r io.ReaderAt, size int64) (Part, error) {\n\tpart := Part{\n\t\tContentLength: size,\n\t\tContentType:  http.DetectContentType([]byte{}),\n\t\tBody:        r,\n\t}\n\n\tif !strict {\n\t\treturn part, nil\n\t}\n\n\tdefer func() {\n\t\tif rerr := recover(); rerr != nil {\n\t\t\tif elog != nil {\n\t\t\t\telog.Error(\"Recovered from panic in EnsurePart: \", rerr)\n\t\t\t}\n\t\t}\n\t}()\n\n\tif size < 0 {\n\t\treturn part, errors.New(\"invalid content length\")\n\t}\n\n\tif !strings.HasPrefix(part.ContentType, \"application/octet-stream\") {\n\t\treturn part, errors.New(\"invalid content type\")\n\t}\n\n\tif size == 0 {\n\t\treturn part, nil\n\t}\n\n\tbuf, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn part, err\n\t}\n\n\tif strings.Contains(string(buf), \"\\r\\n\\r\\n\") {\n\t\treturn part, errors.New(\"invalid content\")\n\t}\n\n\treturn part, nil\n}\n```"]}, "mox-message/part.go-ParseNextPart": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n# Natural Language Annotations: // ParseNextPart parses the next (sub)part of this multipart message.\n// ParseNextPart returns io.EOF and a nil part when there are no more parts.\n// Only used for initial parsing of message. Once parsed, use p.Parts.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n    // Check if there are more parts to parse\n    if p.index >= len(p.parts) {\n        // If not, return io.EOF and a nil part\n        return nil, io.EOF\n    }\n\n    // Initialize the current part\n    var nextPart *Part\n    // Get the next part\n    nextPart = &p.parts[p.index]\n    // Increment the index\n    p.index++\n    // Return the next part and no error\n    return nextPart, nil\n}\n```", "```go\nfunc (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n    // Check if there are no more parts\n    if p.Index >= len(p.parts) {\n        return nil, io.EOF\n    }\n\n    // Get the next part\n    nextPart := p.parts[p.Index]\n\n    // Increment the index\n    p.Index++\n\n    // Log the parsing of the next part\n    elog.Debugf(\"Parsed next part: %s\", nextPart.Name)\n\n    return nextPart, nil\n}\n```", "```go\nfunc (p *Part) ParseNextPart(elog *slog.Logger) (*Part, error) {\n    // Check if there are more parts to parse\n    if len(p.parts) == 0 {\n        // If not, return io.EOF and nil part\n        return nil, io.EOF\n    }\n    \n    // Get the next part from the parts slice\n    nextPart := p.parts[0]\n    \n    // Remove the next part from the parts slice\n    p.parts = p.parts[1:]\n    \n    // Return the next part and no error\n    return nextPart, nil\n}\n```"]}, "mox-message/messageid.go-MessageIDCanonical": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MessageIDCanonical(s string) (string, bool, error) {\n# Natural Language Annotations: // MessageIDCanonical parses the Message-ID, returning a canonical value that is\n// lower-cased, without <>, and no unneeded quoting. For matching in threading,\n// with References/In-Reply-To. If the message-id is invalid (e.g. no <>), an error\n// is returned. If the message-id could not be parsed as address (localpart \"@\"\n// domain), the raw value and the bool return parameter true is returned. It is\n// quite common that message-id's don't adhere to the localpart @ domain\n// syntax.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage email\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\nfunc MessageIDCanonical(s string) (string, bool, error) {\n\t// Remove <> and unneeded quoting\n\ts = strings.Trim(s, \"<>\")\n\ts = strings.Trim(s, `\"`)\n\ts = strings.Trim(s, \"'\")\n\n\t// If the message-id is invalid (e.g. no <>), return an error\n\tif s == \"\" {\n\t\treturn \"\", false, errors.New(\"invalid message-id\")\n\t}\n\n\t// Split the message-id into localpart and domain\n\tparts := strings.SplitN(s, \"@\", 2)\n\tif len(parts) != 2 {\n\t\treturn s, true, nil\n\t}\n\tlocalpart, domain := parts[0], parts[1]\n\n\t// If the localpart contains any non-word characters (except for hyphens and dots)\n\t// or the domain contains any non-word characters, return the raw value and true\n\tif !unicode.IsLetter(localpart[0]) && !unicode.IsLetter(localpart[len(localpart)-1]) {\n\t\tfor _, r := range localpart {\n\t\t\tif !unicode.IsLetter(r) && r != '-' && r != '.' {\n\t\t\t\treturn s, true, nil\n\t\t\t}\n\t\t}\n\t}\n\tif !unicode.IsLetter(domain[0]) && !unicode.IsLetter(domain[len(domain)-1]) {\n\t\tfor _, r := range domain {\n\t\t\tif !unicode.IsLetter(r) && r != '-' && r != '.' {\n\t\t\t\treturn s, true, nil\n\t\t\t}\n\t\t}\n\t}\n\n\t// Lower-case the localpart and domain\n\tlocalpart = strings.ToLower(localpart)\n\tdomain = strings.ToLower(domain)\n\n\t// Reconstruct the canonical message-id\n\tcanonical := fmt.Sprintf(\"%s@%s\", localpart, domain)\n\treturn canonical, false, nil\n}\n```", "```python\ndef MessageIDCanonical(s: str) -> (str, bool, str):\n    s = s.strip()\n    if not s or s[0] != '<' or s[-1] != '>':\n        return s, True, \"Invalid message-id format\"\n    \n    s = s[1:-1].lower()\n    if '@' not in s:\n        return s, True, \"Message-id does not contain '@' domain\"\n    \n    localpart, domain = s.split('@')\n    if not localpart or not domain:\n        return s, True, \"Invalid localpart or domain\"\n    \n    return s, False, \"\"\n```", "```sql\nfunc MessageIDCanonical(s string) (string, bool, error) {\n    // Remove leading and trailing <> quotes\n    s = strings.Trim(s, \"<>\")\n    \n    // Remove any remaining quotes\n    s = strings.ReplaceAll(s, \"\\\"\", \"\")\n    \n    // Split the string into localpart and domain\n    parts := strings.SplitN(s, \"@\", 2)\n    \n    // If the message-id doesn't contain '@', return the raw value and true\n    if len(parts) == 1 {\n        return s, true, nil\n    }\n    \n    // Check if localpart is valid\n    if !isValidLocalpart(parts[0]) {\n        return s, true, errors.New(\"invalid localpart\")\n    }\n    \n    // Check if domain is valid\n    if !isValidDomain(parts[1]) {\n        return s, true, errors.New(\"invalid domain\")\n    }\n    \n    // Return the canonical value\n    return strings.ToLower(s), false, nil\n}\n\nfunc isValidLocalpart(localpart string) bool {\n    // A localpart is valid if it contains only letters, digits, and '-'\n    for _, r := range localpart {\n        if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '-' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc isValidDomain(domain string) bool {\n    // A domain is valid if it starts with a letter or digit and contains only letters, digits, and '.'\n    if len(domain) == 0 || (domain[0] != '.' && !unicode.IsLetter(domain[0]) && !unicode.IsDigit(domain[0])) {\n        return false\n    }\n    for _, r := range domain {\n        if !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '.' {\n            return false\n        }\n    }\n    return true\n}\n```"]}, "mox-message/decode.go-DecodeReader": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DecodeReader(charset string, r io.Reader) io.Reader {\n# Natural Language Annotations: // DecodeReader returns a reader that reads from r, decoding as charset. If\n// charset is empty, us-ascii, utf-8 or unknown, the original reader is\n// returned and no decoding takes place.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport io\nimport chardet\n\ndef decode_reader(charset: str, r: io.IOBase) -> io.IOBase:\n    if not charset or charset in ['us-ascii', 'utf-8', 'unknown']:\n        return r\n    try:\n        if not hasattr(r, 'read'):\n            r = io.BufferedReader(r)\n        return io.TextIOWrapper(r, encoding=charset, errors='replace')\n    except LookupError:\n        detection = chardet.detect(r.read())\n        r.seek(0)\n        return io.TextIOWrapper(r, encoding=detection['encoding'], errors='replace')\n```", "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"code.google.com/p/go-charset/charset\"\n\t\"io\"\n\t\"strings\"\n)\n\nfunc DecodeReader(charset string, r io.Reader) io.Reader {\n\tif strings.ToLower(charset) == \"us-ascii\" || strings.ToLower(charset) == \"utf-8\" || strings.ToLower(charset) == \"unknown\" || charset == \"\" {\n\t\treturn r\n\t}\n\treturn charset.NewReader(r, charset)\n}\n\nfunc main() {\n\t// Test the function\n\treader := strings.NewReader(\"Hello, World!\")\n\tdecodedReader := DecodeReader(\"utf-8\", reader)\n\tscanner := bufio.NewScanner(decodedReader)\n\tscanner.Scan()\n\tprintln(scanner.Text())\n}\n```", "```python\nfrom io import TextIOWrapper\nimport chardet\n\ndef DecodeReader(charset: str, r: TextIOWrapper) -> TextIOWrapper:\n    if not charset or charset in ['us-ascii', 'utf-8', 'unknown']:\n        return r\n    try:\n        decoder = chardet.detect(r.read(1024))\n        r.seek(0)\n        return TextIOWrapper(r, encoding=decoder['encoding'])\n    except Exception as e:\n        return r\n```"]}, "mox-message/referencedids.go-ReferencedIDs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ReferencedIDs(references []string, inReplyTo []string) ([]string, error) {\n# Natural Language Annotations: // ReferencedIDs returns the Message-IDs referenced from the References header(s),\n// with a fallback to the In-Reply-To header(s). The ids are canonicalized for\n// thread-matching, like with MessageIDCanonical. Empty message-id's are skipped.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef ReferencedIDs(references, inReplyTo):\n    \"\"\"\n    Returns the Message-IDs referenced from the References header(s),\n    with a fallback to the In-Reply-To header(s). The ids are canonicalized for\n    thread-matching, like with MessageIDCanonical. Empty message-id's are skipped.\n\n    :param references: A list of References headers\n    :type references: list[str]\n    :param inReplyTo: A list of In-Reply-To headers\n    :type inReplyTo: list[str]\n    :return: A list of canonicalized Message-IDs\n    :rtype: list[str]\n    :return: An error if any of the input lists contain non-string values\n    :rtype: error\n    \"\"\"\n    if not all(isinstance(x, str) for x in references):\n        return [], ValueError(\"References must be a list of strings\")\n    if not all(isinstance(x, str) for x in inReplyTo):\n        return [], ValueError(\"In-Reply-To must be a list of strings\")\n\n    referenced_ids = []\n    for ref in references:\n        for id in ref.split(\",\"):\n            id = id.strip()\n            if id:\n                referenced_ids.append(id)\n    for id in inReplyTo:\n        id = id.strip()\n        if id:\n            referenced_ids.append(id)\n\n    return referenced_ids, None\n```", "```python\ndef ReferencedIDs(references, inReplyTo):\n    \"\"\"\n    ReferencedIDs returns the Message-IDs referenced from the References header(s),\n    with a fallback to the In-Reply-To header(s). The ids are canonicalized for\n    thread-matching, like with MessageIDCanonical. Empty message-id's are skipped.\n    \n    Args:\n        references (list): The References header(s)\n        inReplyTo (list): The In-Reply-To header(s)\n    \n    Returns:\n        list: The list of canonicalized Message-IDs\n        error: None if successful, otherwise the error message\n    \"\"\"\n    def canonicalize_id(id):\n        # This function should implement the MessageIDCanonical logic\n        # For simplicity, we assume it just removes any whitespace\n        return id.strip()\n\n    referenced_ids = []\n    for ref in references:\n        for id in ref.split(','):\n            id = id.strip()\n            if id:\n                referenced_ids.append(canonicalize_id(id))\n    \n    for id in inReplyTo:\n        referenced_ids.append(canonicalize_id(id))\n    \n    return referenced_ids, None\n```", "```python\ndef ReferencedIDs(references, inReplyTo):\n    \"\"\"\n    Returns the Message-IDs referenced from the References header(s),\n    with a fallback to the In-Reply-To header(s). The ids are canonicalized for\n    thread-matching, like with MessageIDCanonical. Empty message-id's are skipped.\n\n    Args:\n        references (list): List of references\n        inReplyTo (list): List of in-reply-to\n\n    Returns:\n        list: A list of canonicalized message ids, or an error if any id is invalid\n    \"\"\"\n\n    def canonicalize_id(id):\n        # This is a placeholder for MessageIDCanonical function\n        # You need to implement this function based on your actual logic\n        return id\n\n    def is_valid_id(id):\n        # This is a placeholder for your id validation logic\n        # You need to implement this function based on your actual logic\n        return True\n\n    referenced_ids = []\n    for ref in references:\n        for id in ref.split(','):\n            id = id.strip()\n            if id and is_valid_id(id):\n                referenced_ids.append(canonicalize_id(id))\n    for id in inReplyTo:\n        id = id.strip()\n        if id and is_valid_id(id):\n            referenced_ids.append(canonicalize_id(id))\n    return referenced_ids\n```"]}, "mox-message/authresults.go-ParseAuthResults": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseAuthResults(s string) (ar AuthResults, err error) {\n# Natural Language Annotations: // ParseAuthResults parses a Authentication-Results header value.\n//\n// Comments are not populated in the returned AuthResults.\n// Both crlf and lf line-endings are accepted. The input string must end with\n// either crlf or lf.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage auth\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"strings\"\n\t\"unicode\"\n)\n\ntype AuthResults struct {\n\tPolicy  string\n\tService string\n\tEmail   string\n\tScope   string\n}\n\nfunc ParseAuthResults(s string) (AuthResults, error) {\n\t// Remove leading and trailing whitespace\n\ts = strings.TrimSpace(s)\n\n\t// Check if string ends with crlf or lf\n\tif !strings.HasSuffix(s, \"\\r\\n\") && !strings.HasSuffix(s, \"\\n\") {\n\t\treturn AuthResults{}, errors.New(\"input string must end with crlf or lf\")\n\t}\n\n\t// Split into key-value pairs\n\tparts := strings.SplitN(s, \"\\r\\n\", 2)\n\tif len(parts) != 2 {\n\t\tparts = strings.SplitN(s, \"\\n\", 2)\n\t}\n\tif len(parts) != 2 {\n\t\treturn AuthResults{}, errors.New(\"invalid format\")\n\t}\n\n\t// Extract policy and rest of the string\n\tpolicy := parts[0]\n\tpolicy = strings.TrimSpace(policy)\n\tparts[1] = strings.TrimSpace(parts[1])\n\n\t// Split policy into individual parts\n\tpolicyParts := strings.SplitN(policy, \" \", 3)\n\tif len(policyParts) != 3 {\n\t\treturn AuthResults{}, errors.New(\"invalid policy format\")\n\t}\n\n\t// Extract auth-service and auth-results\n\tauthService := policyParts[0]\n\tauthResults := policyParts[2]\n\n\t// Split auth-results into individual results\n\tresultParts := strings.Split(authResults, \";\")\n\tif len(resultParts) == 1 {\n\t\treturn AuthResults{}, errors.New(\"no results found\")\n\t}\n\n\tar := AuthResults{\n\t\tPolicy:  authService,\n\t\tService: strings.Join(resultParts[0:1], \";\"),\n\t}\n\n\t// Parse email and scope\n\tfor _, r := range resultParts[1:] {\n\t\tr = strings.TrimSpace(r)\n\t\tif strings.HasPrefix(r, \"email=\") {\n\t\t\tar.Email = r[6:]\n\t\t} else if strings.HasPrefix(r, \"policy-scope=\") {\n\t\t\tar.Scope = r[12:]\n\t\t} else {\n\t\t\treturn AuthResults{}, fmt.Errorf(\"unknown result: %q\", r)\n\t\t}\n\t}\n\n\treturn ar, nil\n}\n```", "```go\npackage auth\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\ntype AuthResults struct {\n\tServices map[string]string\n\tMethods  map[string][]string\n}\n\nfunc ParseAuthResults(s string) (ar AuthResults, err error) {\n\t// Remove leading and trailing whitespace\n\ts = strings.TrimSpace(s)\n\n\t// Replace lf with crlf for consistency\n\ts = strings.ReplaceAll(s, \"\\n\", \"\\r\\n\")\n\n\t// Split into individual results\n\tresults := strings.Split(s, \"\\r\\n\")\n\n\t// Initialize AuthResults\n\tar = AuthResults{\n\t\tServices: make(map[string]string),\n\t\tMethods:  make(map[string][]string),\n\t}\n\n\tfor _, result := range results {\n\t\tif strings.HasPrefix(result, \"auth\") {\n\t\t\tparts := strings.SplitN(result, \" \", 3)\n\t\t\tif len(parts) != 3 {\n\t\t\t\treturn ar, fmt.Errorf(\"invalid auth result: %s\", result)\n\t\t\t}\n\t\t\tar.Services[parts[1]] = parts[2]\n\t\t} else if strings.HasPrefix(result, \"methods\") {\n\t\t\tparts := strings.SplitN(result, \" \", 2)\n\t\t\tif len(parts) != 2 {\n\t\t\t\treturn ar, fmt.Errorf(\"invalid methods result: %s\", result)\n\t\t\t}\n\t\t\tmethods := strings.Split(parts[1], \",\")\n\t\t\tar.Methods[parts[0]] = methods\n\t\t}\n\t}\n\n\treturn ar, nil\n}\n```", "```go\npackage auth\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc ParseAuthResults(s string) (ar AuthResults, err error) {\n\t// Remove any leading/trailing whitespace\n\ts = strings.TrimSpace(s)\n\n\t// Check for crlf and lf line-endings\n\tif !strings.HasSuffix(s, \"\\r\\n\") && !strings.HasSuffix(s, \"\\n\") {\n\t\treturn ar, fmt.Errorf(\"input string must end with crlf or lf\")\n\t}\n\n\t// Split the input string into lines\n\tlines := strings.Split(s, \"\\r\\n\")\n\tif len(lines) == 1 {\n\t\tlines = strings.Split(s, \"\\n\")\n\t}\n\n\tar = AuthResults{}\n\tfor _, line := range lines {\n\t\t// Ignore empty lines\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\t// Split the line into key and value\n\t\tparts := strings.SplitN(line, \":\", 2)\n\t\tif len(parts) != 2 {\n\t\t\treturn ar, fmt.Errorf(\"invalid line format: %s\", line)\n\t\t}\n\n\t\tkey := strings.TrimSpace(parts[0])\n\t\tvalue := strings.TrimSpace(parts[1])\n\n\t\tswitch key {\n\t\tcase \"result\":\n\t\t\tar.Result = value\n\t\tcase \"auth-service\":\n\t\t\tar.AuthService = value\n\t\tcase \"cache-result\":\n\t\t\tar.CacheResult = value\n\t\tcase \"cache-uri\":\n\t\t\tar.CacheURI = value\n\t\tcase \"policy-uri\":\n\t\t\tar.PolicyURI = value\n\t\tcase \"method\":\n\t\t\tar.Method = value\n\t\tcase \"response\":\n\t\t\tar.Response = value\n\t\tcase \"version\":\n\t\t\tar.Version = value\n\t\tdefault:\n\t\t\t// Ignore unknown keys\n\t\t}\n\t}\n\n\treturn ar, nil\n}\n```"]}, "mox-store/msgreader.go-FileMsgReader": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func FileMsgReader(prefix []byte, msgFile *os.File) *MsgReader {\n# Natural Language Annotations: // FileMsgReader makes a MsgReader for an open file.\n// If initialization fails, reads will return the error.\n// Only call close on the returned MsgReader if you want to close msgFile.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype MsgReader struct {\n\tmsgFile *os.File\n}\n\nfunc (mr *MsgReader) Read(p []byte) (int, error) {\n\treturn mr.msgFile.Read(p)\n}\n\nfunc (mr *MsgReader) Close() error {\n\treturn mr.msgFile.Close()\n}\n\nfunc FileMsgReader(prefix []byte, msgFile *os.File) (*MsgReader, error) {\n\tif msgFile == nil {\n\t\treturn nil, errors.New(\"msgFile cannot be nil\")\n\t}\n\tif err := os.Lseek(msgFile.Fd(), int64(len(prefix)), 0); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &MsgReader{msgFile: msgFile}, nil\n}\n```", "```go\npackage main\n\nimport (\n    \"bufio\"\n    \"os\"\n)\n\ntype MsgReader struct {\n    reader *bufio.Reader\n    file   *os.File\n}\n\nfunc (mr *MsgReader) Read(p []byte) (n int, err error) {\n    return mr.reader.Read(p)\n}\n\nfunc (mr *MsgReader) Close() error {\n    return mr.file.Close()\n}\n\nfunc FileMsgReader(prefix []byte, msgFile *os.File) (*MsgReader, error) {\n    if len(prefix) > 0 && prefix[len(prefix)-1] == '\\n' {\n        prefix = prefix[:len(prefix)-1]\n    }\n    if _, err := msgFile.Seek(int64(len(prefix)), 0); err != nil {\n        return nil, err\n    }\n    reader := bufio.NewReader(msgFile)\n    return &MsgReader{reader: reader, file: msgFile}, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"io\"\n\t\"os\"\n)\n\ntype MsgReader struct {\n\tfile *os.File\n}\n\nfunc (r *MsgReader) Read(p []byte) (n int, err error) {\n\treturn r.file.Read(p)\n}\n\nfunc (r *MsgReader) Close() error {\n\treturn r.file.Close()\n}\n\nfunc FileMsgReader(prefix []byte, msgFile *os.File) (*MsgReader, error) {\n\tif msgFile == nil {\n\t\treturn nil, os.ErrInvalid\n\t}\n\tif err := msgFile.Seek(0, os.SeekStart); err != nil {\n\t\treturn nil, err\n\t}\n\treturn &MsgReader{file: msgFile}, nil\n}\n```"]}, "mox-store/import.go-ParseDovecotKeywordsFlags": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseDovecotKeywordsFlags(r io.Reader, log mlog.Log) ([]string, error) {\n# Natural Language Annotations: // ParseDovecotKeywordsFlags attempts to parse a dovecot-keywords file. It only\n// returns valid flags/keywords, as lower-case. If an error is encountered and\n// returned, any keywords that were found are still returned. The returned list has\n// both system/well-known flags and custom keywords.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"regexp\"\n\t\"strings\"\n)\n\ntype Log struct{}\n\nfunc ParseDovecotKeywordsFlags(r io.Reader, log Log) ([]string, error) {\n\tvar flags []string\n\tvar err error\n\n\tscanner := bufio.NewScanner(r)\n\tfor scanner.Scan() {\n\t\tline, err := scanner.ReadString('\\n')\n\t\tif err != nil {\n\t\t\treturn flags, err\n\t\t}\n\n\t\tline = strings.TrimSpace(line)\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\n\t\tmatch := regexp.MustCompile(`\\A([a-zA-Z0-9_]+):`).FindStringSubmatch(line)\n\t\tif match != nil {\n\t\t\tflag := strings.ToLower(match[1])\n\t\t\tflags = append(flags, flag)\n\t\t}\n\t}\n\n\tif err := scanner.Err(); err != nil {\n\t\treturn flags, err\n\t}\n\n\treturn flags, nil\n}\n\nfunc main() {\n\tfile, err := os.Open(\"dovecot-keywords\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tlog := Log{}\n\tflags, err := ParseDovecotKeywordsFlags(file, log)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tfmt.Println(flags)\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Log struct{}\n\nfunc ParseDovecotKeywordsFlags(r io.Reader, log Log) ([]string, error) {\n\tvar flags, customFlags []string\n\tcsvReader := csv.NewReader(r)\n\trecords, err := csvReader.ReadAll()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn flags, err\n\t}\n\tfor _, record := range records {\n\t\tflag := strings.ToLower(record[0])\n\t\tif flag == \"system\" {\n\t\t\tcontinue\n\t\t}\n\t\tif flag != \"\" {\n\t\t\tflags = append(flags, flag)\n\t\t}\n\t}\n\treturn flags, nil\n}\n\nfunc main() {\n\tfile, err := os.Open(\"dovecot-keywords\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\tlog := Log{}\n\tflags, err := ParseDovecotKeywordsFlags(file, log)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(flags)\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/csv\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Log struct {\n\tWriter *log.Logger\n}\n\nfunc ParseDovecotKeywordsFlags(r io.Reader, log mlog.Log) ([]string, error) {\n\tvar keywords []string\n\tscanner := csv.NewReader(r)\n\trecords, err := scanner.ReadAll()\n\tif err != nil {\n\t\tlog.Println(err)\n\t\treturn keywords, err\n\t}\n\n\tfor _, record := range records {\n\t\tfor _, keyword := range record {\n\t\t\tkeyword = strings.TrimSpace(keyword)\n\t\t\tif keyword != \"\" {\n\t\t\t\tkeywords = append(keywords, strings.ToLower(keyword))\n\t\t\t}\n\t\t}\n\t}\n\n\treturn keywords, nil\n}\n\nfunc main() {\n\tfile, err := os.Open(\"dovecot-keywords\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tdefer file.Close()\n\n\tlog := mlog.Log{Writer: log.New(os.Stdout, \"\", 0)}\n\tresult, err := ParseDovecotKeywordsFlags(file, log)\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n\n\tfmt.Println(result)\n}\n```"]}, "mox-store/account.go-MessageRuleset": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func MessageRuleset(log mlog.Log, dest config.Destination, m *Message, msgPrefix []byte, msgFile *os.File) *config.Ruleset {\n# Natural Language Annotations: // MessageRuleset returns the first ruleset (if any) that matches the message\n// represented by msgPrefix and msgFile, with smtp and validation fields from m.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\nfunction MessageRuleset(log: any, dest: any, m: any, msgPrefix: Buffer, msgFile: any): any {\n    // Read the ruleset configuration from the destination\n    const rulesets = dest.Rulesets;\n\n    // Check if the rulesets are loaded\n    if (!rulesets || rulesets.length === 0) {\n        return null;\n    }\n\n    // Iterate over each ruleset\n    for (const ruleset of rulesets) {\n        // Check if the ruleset matches the message prefix\n        if (ruleset.Matcher.Match(msgPrefix)) {\n            // Check if the ruleset matches the message file\n            if (ruleset.Matcher.Match(msgFile)) {\n                // Return the matching ruleset\n                return ruleset;\n            }\n        }\n    }\n\n    // If no matching ruleset is found, return null\n    return null;\n}\n```", "```python\nfrom typing import Dict, Optional\n\nclass Ruleset:\n    def __init__(self, name: str, smtp: Dict, validation: Dict):\n        self.name = name\n        self.smtp = smtp\n        self.validation = validation\n\nclass Message:\n    def __init__(self, smtp: Dict, validation: Dict):\n        self.smtp = smtp\n        self.validation = validation\n\nclass Destination:\n    def __init__(self, name: str):\n        self.name = name\n\nclass Log:\n    def __init__(self, message: Message):\n        self.message = message\n\ndef MessageRuleset(log: Log, dest: Destination, msgPrefix: bytes, msgFile: str) -> Optional[Ruleset]:\n    rulesets = [\n        Ruleset('ruleset1', {'smtp': 'smtp1', 'validation': 'validation1'}, {'field1': 'value1', 'field2': 'value2'}),\n        Ruleset('ruleset2', {'smtp': 'smtp2', 'validation': 'validation2'}, {'field3': 'value3', 'field4': 'value4'}),\n    ]\n\n    for ruleset in rulesets:\n        if msgPrefix == ruleset.name.encode() and msgFile == ruleset.smtp:\n            return ruleset\n    return None\n```", "```sql\nfunc MessageRuleset(log mlog.Log, dest config.Destination, m *Message, msgPrefix []byte, msgFile *os.File) *config.Ruleset {\n    // Get the rulesets from the destination\n    rulesets := dest.Rulesets\n\n    // Iterate over the rulesets\n    for _, ruleset := range rulesets {\n        // Check if the ruleset matches the message\n        if ruleset.IsMatch(msgPrefix, msgFile) {\n            // Return the first matching ruleset\n            return &ruleset\n        }\n    }\n\n    // If no ruleset matches, return nil\n    return nil\n}\n```"]}, "mox-smtp/address.go-ParseAddress": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseAddress(s string) (address Address, err error) {\n# Natural Language Annotations: // ParseAddress parses an email address. UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n)\n\ntype Address struct {\n\tUsername string\n\tDomain   string\n}\n\nfunc ParseAddress(s string) (Address, error) {\n\tregex := regexp.MustCompile(`^([a-zA-Z0-9_.+-]+)@([a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+)$`)\n\tparts := regex.FindStringSubmatch(s)\n\tif len(parts) == 0 {\n\t\treturn Address{}, errors.New(\"invalid email address\")\n\t}\n\tif len(parts[1]) == 0 || len(parts[2]) == 0 {\n\t\treturn Address{}, errors.New(\"invalid email address\")\n\t}\n\treturn Address{Username: parts[1], Domain: parts[2]}, nil\n}\n\nfunc main() {\n\taddress, err := ParseAddress(\"john.doe@example.com\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(address)\n}\n```", "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"fmt\"\n\t\"regexp\"\n)\n\ntype Address struct {\n\tUsername string\n\tDomain   string\n}\n\nfunc ParseAddress(s string) (Address, error) {\n\taddressRegex := regexp.MustCompile(`([a-zA-Z0-9._%+-]+)@([a-zA-Z0-9.-]+\\.[a-zA-Z]{2,})`)\n\tparts := addressRegex.FindStringSubmatch(s)\n\tif len(parts) != 3 {\n\t\treturn Address{}, errors.New(\"invalid address\")\n\t}\n\n\tusername := parts[1]\n\tdomain := parts[2]\n\n\treturn Address{Username: username, Domain: domain}, nil\n}\n\nfunc main() {\n\taddress, err := ParseAddress(\"test@example.com\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t} else {\n\t\tfmt.Printf(\"Username: %s, Domain: %s\\n\", address.Username, address.Domain)\n\t}\n}\n```", "```javascript\nclass Address {\n  constructor() {}\n}\n\nclass Error {\n  constructor(message) {\n    this.message = message;\n  }\n}\n\nclass ErrBadAddress extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ErrBadAddress';\n  }\n}\n\nfunction parseAddress(s) {\n  const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$/;\n  if (emailRegex.test(s)) {\n    return { address: s, err: null };\n  } else {\n    return { address: null, err: new ErrBadAddress('Invalid email address') };\n  }\n}\n```"]}, "mox-smtp/address.go-ParseLocalpart": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func ParseLocalpart(s string) (localpart Localpart, err error) {\n# Natural Language Annotations: // ParseLocalpart parses the local part.\n// UTF-8 is allowed.\n// Returns ErrBadAddress for invalid addresses.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\ntype Localpart string\n\nfunc ParseLocalpart(s string) (localpart Localpart, err error) {\n\tif len(s) == 0 {\n\t\treturn \"\", errors.New(\"invalid address\")\n\t}\n\n\tif !utf8.ValidString(s) {\n\t\treturn \"\", errors.New(\"invalid UTF-8\")\n\t}\n\n\tfor _, r := range s {\n\t\tif !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '-' && r != '.' {\n\t\t\treturn \"\", errors.New(\"invalid address\")\n\t\t}\n\t}\n\n\treturn Localpart(s), nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"unicode\"\n\t\"unicode/utf8\"\n)\n\ntype Localpart string\n\nfunc ParseLocalpart(s string) (localpart Localpart, err error) {\n\tif len(s) == 0 {\n\t\treturn \"\", errors.New(\"empty local part\")\n\t}\n\n\tif !unicode.IsLetter(rune(s[0])) {\n\t\treturn \"\", errors.New(\"local part must start with a letter\")\n\t}\n\n\tfor _, r := range s {\n\t\tif !unicode.IsLetter(r) && !unicode.IsDigit(r) && r != '-' && r != '.' && r != '_' {\n\t\t\treturn \"\", errors.New(\"invalid character in local part\")\n\t\t}\n\t}\n\n\tif utf8.RuneCountInString(s) > 64 {\n\t\treturn \"\", errors.New(\"local part too long\")\n\t}\n\n\treturn Localpart(s), nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"errors\"\n\t\"strings\"\n\t\"unicode/utf8\"\n\n\t\"github.com/emersion/go-imap/utf8util\"\n)\n\ntype Localpart string\n\nfunc ParseLocalpart(s string) (Localpart, error) {\n\tif utf8.ValidString(s) {\n\t\t// Remove leading and trailing whitespace\n\t\ts = strings.TrimSpace(s)\n\t\tif !strings.ContainsRune(s, '@') {\n\t\t\treturn Localpart(s), nil\n\t\t}\n\t} else {\n\t\treturn \"\", errors.New(\"invalid UTF-8\")\n\t}\n\treturn \"\", errors.New(\"invalid address\")\n}\n```"]}, "mox-smtp/data.go-DataWrite": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func DataWrite(w io.Writer, r io.Reader) error {\n# Natural Language Annotations: // DataWrite reads data (a mail message) from r, and writes it to smtp\n// connection w with dot stuffing, as required by the SMTP data command.\n//\n// Messages with bare carriage returns or bare newlines result in an error.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc DataWrite(w io.Writer, r io.Reader) error {\n\tscanner := bufio.NewScanner(r)\n\tscanner.Split(bufio.ScanLines)\n\n\tvar buffer bytes.Buffer\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.ContainsAny(line, \"\\r\\n\") {\n\t\t\treturn errors.New(\"bare carriage return or newline\")\n\t\t}\n\t\tbuffer.WriteString(line + \".\")\n\t}\n\n\t_, err := io.Copy(w, &buffer)\n\treturn err\n}\n```", "```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n\n\t\"github.com/emersion/go-imap/imap\"\n)\n\nfunc DataWrite(w io.Writer, r io.Reader) error {\n\tscanner := bufio.NewScanner(r)\n\tscanner.Split(bufio.ScanLines)\n\n\tfor scanner.Scan() {\n\t\tline := scanner.Text()\n\t\tif strings.Contains(line, \"\\n\") || strings.Contains(line, \"\\r\") {\n\t\t\treturn fmt.Errorf(\"message contains bare newline or carriage return\")\n\t\t}\n\n\t\tif strings.Contains(line, \".\") {\n\t\t\tline += \".\"\n\t\t}\n\n\t\t_, err := io.WriteString(w, line+\"\\r\\n\")\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n```", "```go\npackage main\n\nimport (\n    \"bufio\"\n    \"errors\"\n    \"io\"\n    \"strings\"\n)\n\nfunc DataWrite(w io.Writer, r io.Reader) error {\n    scanner := bufio.NewScanner(r)\n    scanner.Split(bufio.ScanLines)\n\n    for scanner.Scan() {\n        line := scanner.Text()\n        if strings.Contains(line, \"\\r\") || strings.Contains(line, \"\\n\") {\n            return errors.New(\"invalid message: bare carriage return or newline\")\n        }\n        line = strings.Trim(line, \" \\t\")\n        if len(line) > 0 {\n            line += \".\"\n        }\n        _, err := w.Write([]byte(line + \"\\r\\n\"))\n        if err != nil {\n            return err\n        }\n    }\n\n    return nil\n}\n```"]}, "mox-scram/scram.go-NewServer": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (server *Server, rerr error) {\n# Natural Language Annotations: // NewServer returns a server given the first SCRAM message from a client.\n//\n// If cs is set, the PLUS variant can be negotiated, binding the authentication\n// exchange to the TLS channel (preventing MitM attempts). If a client\n// indicates it supports the PLUS variant, but thinks the server does not, the\n// authentication attempt will fail.\n//\n// If channelBindingRequired is set, the client has indicated it will do channel\n// binding and not doing so will cause the authentication to fail.\n//\n// The sequence for data and calls on a server:\n//\n//   - Read initial data from client, call NewServer (this call), then ServerFirst and write to the client.\n//   - Read response from client, call Finish or FinishFinal and write the resulting string.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"net\"\n\n\t\"golang.org/x/crypto/scram\"\n)\n\ntype Server struct {\n\th      func() hash.Hash\n\tclient []byte\n\tcs     *tls.ConnectionState\n}\n\nfunc NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (*Server, error) {\n\ts := &Server{\n\t\th:      h,\n\t\tclient:  clientFirst,\n\t\tcs:     cs,\n\t}\n\n\tif cs != nil && cs.NegotiatedProtocol == \"scram-sha-1-plus\" {\n\t\treturn nil, fmt.Errorf(\"PLUS variant negotiation failed\")\n\t}\n\n\tif channelBindingRequired && !cs.NegotiatedProtocol == \"scram-sha-1-plus\" {\n\t\treturn nil, fmt.Errorf(\"channel binding required but not negotiated\")\n\t}\n\n\treturn s, nil\n}\n\nfunc (s *Server) ServerFirst() error {\n\t// logic for server first message\n\treturn nil\n}\n\nfunc (s *Server) Finish() error {\n\t// logic for finish message\n\treturn nil\n}\n\nfunc (s *Server) FinishFinal() error {\n\t// logic for finish final message\n\treturn nil\n}\n```", "```go\npackage main\n\nimport (\n    \"crypto/tls\"\n    \"errors\"\n    \"fmt\"\n)\n\ntype Server struct {\n    // Add server fields here as needed\n}\n\nfunc NewServer(h func() hash.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (*Server, error) {\n    // Check if the client's first message is valid\n    if len(clientFirst) == 0 {\n        return nil, errors.New(\"client's first message is empty\")\n    }\n\n    // Check if channel binding is required and the client supports it\n    if channelBindingRequired && !cs.SupportsChannelBinding() {\n        return nil, errors.New(\"client requires channel binding but server does not support it\")\n    }\n\n    // Create a new server instance\n    server := &Server{}\n\n    // Initialize the hash function\n    hashFunc := h()\n\n    // ... (rest of the server initialization and authentication logic)\n\n    return server, nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/tls\"\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\n\t\"github.com/PuerkitoBio/scram\"\n)\n\ntype Server struct {\n\tHash func() scram.Hash\n}\n\nfunc NewServer(h func() scram.Hash, clientFirst []byte, cs *tls.ConnectionState, channelBindingRequired bool) (*Server, error) {\n\thash := h()\n\tscramServer := &Server{Hash: hash}\n\n\tif cs != nil && cs.NegotiatedProtocol == \"PLUS\" {\n\t\t// If TLS channel binding is negotiated, bind the authentication exchange to the TLS channel\n\t\tscramServer.Hash = hash.NewTLSChannelBinding(cs)\n\t}\n\n\tif channelBindingRequired && !scramServer.Hash.SupportsChannelBinding() {\n\t\treturn nil, fmt.Errorf(\"client requires channel binding, but server does not support it\")\n\t}\n\n\treturn scramServer, nil\n}\n\nfunc (s *Server) ServerFirst(data []byte) ([]byte, error) {\n\t// Implement ServerFirst logic here\n\treturn nil, nil\n}\n\nfunc (s *Server) Finish(data []byte) ([]byte, error) {\n\t// Implement Finish logic here\n\treturn nil, nil\n}\n\nfunc (s *Server) FinishFinal(data []byte) ([]byte, error) {\n\t// Implement FinishFinal logic here\n\treturn nil, nil\n}\n\nfunc main() {\n\thash := scram.NewSHA256()\n\tclientFirst := make([]byte, 0)\n\tcs := &tls.ConnectionState{}\n\tchannelBindingRequired := true\n\n\tserver, err := NewServer(hash.Hash, clientFirst, cs, channelBindingRequired)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\tdata := server.ServerFirst(clientFirst)\n\t_, err = server.Finish(data)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n```"]}, "mox-scram/scram.go-ServerFirst": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Server) ServerFirst(iterations int, salt []byte) (string, error) {\n# Natural Language Annotations: // ServerFirst returns the string to send back to the client. To be called after NewServer.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"crypto/sha256\"\n\t\"encoding/hex\"\n\t\"fmt\"\n\t\"io\"\n\t\"sync\"\n)\n\ntype Server struct {\n\tmu sync.Mutex\n\tid string\n}\n\nfunc NewServer() *Server {\n\treturn &Server{\n\t\tid: generateId(),\n\t}\n}\n\nfunc generateId() string {\n\tb := make([]byte, 32)\n\t_, err := io.ReadFull(rand.Reader, b)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn hex.EncodeToString(b)\n}\n\nfunc (s *Server) ServerFirst(iterations int, salt []byte) (string, error) {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\thash := sha256.New()\n\thash.Write(salt)\n\tfor i := 0; i < iterations; i++ {\n\t\thash.Write([]byte(strconv.Itoa(i)))\n\t}\n\thash.Write(s.id)\n\n\treturn hex.EncodeToString(hash.Sum(nil)), nil\n}\n\nfunc main() {\n\ts := NewServer()\n\tid, err := s.ServerFirst(10, []byte(\"my_salt\"))\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tfmt.Println(id)\n}\n```", "```python\ndef server_first(self, iterations: int, salt: bytes) -> tuple[str, str]:\n    \"\"\"ServerFirst returns the string to send back to the client. To be called after NewServer.\"\"\"\n    # Generate a random string for the server\n    server_string = \"Server Response\"\n    \n    # Return the string and an error message\n    return server_string, \"Success\"\n```", "```python\ndef server_first(self, iterations: int, salt: bytes) -> (str, str):\n    \"\"\"ServerFirst returns the string to send back to the client. To be called after NewServer.\"\"\"\n    # For now, just return a hardcoded string\n    return \"Server is up and running\", \"Success\"\n\n# Example usage:\nclass Server:\n    def __init__(self):\n        pass\n\n    def server_first(self, iterations: int, salt: bytes) -> (str, str):\n        \"\"\"ServerFirst returns the string to send back to the client. To be called after NewServer.\"\"\"\n        # For now, just return a hardcoded string\n        return \"Server is up and running\", \"Success\"\n\nserver = Server()\nprint(server.server_first(10, b\"salt\"))\n```"]}, "mox-scram/scram.go-Finish": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n# Natural Language Annotations: // Finish takes the final client message, and the salted password (probably\n// from server storage), verifies the client, and returns a message to return\n// to the client. If err is nil, authentication was successful. If the\n// authorization requested is not acceptable, the server should call\n// FinishError instead.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n    // Verify the client's message using the salted password\n    hashedPassword := s.hashPassword(saltedPassword)\n    \n    // Compare the client's message with the hashed password\n    if bytes.Compare(clientFinal, hashedPassword) == 0 {\n        // Authentication successful\n        serverFinal = \"Authentication successful\"\n    } else {\n        // Authentication failed\n        return \"\", errors.New(\"Authentication failed\")\n    }\n    \n    // Return the result\n    return serverFinal, nil\n}\n```", "```go\nfunc (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n    // Verify the client using the salted password\n    if !s.verifyClient(clientFinal, saltedPassword) {\n        return \"\", errors.New(\"invalid client\")\n    }\n    \n    // If verification is successful, return a success message\n    return \"Authentication successful\", nil\n}\n\n// Assuming verifyClient is a method on the Server type that checks the client's authenticity\nfunc (s *Server) verifyClient(clientFinal []byte, saltedPassword []byte) bool {\n    // This function should implement the actual verification logic\n    // For example:\n    hashedPassword := s.getHashedPassword(saltedPassword)\n    return crypto.CompareHashAndPassword(clientFinal, hashedPassword) == nil\n}\n\n// Assuming getHashedPassword is a method on the Server type that retrieves the hashed password\nfunc (s *Server) getHashedPassword(saltedPassword []byte) []byte {\n    // This function should implement the logic to retrieve the hashed password\n    // For example:\n    return crypto.HMACSHA256(saltedPassword, s.getSalt())\n}\n\n// Assuming getSalt is a method on the Server type that retrieves the salt\nfunc (s *Server) getSalt() []byte {\n    // This function should implement the logic to retrieve the salt\n    // For example:\n    return []byte(\"some-salt\")\n}\n```", "```go\nfunc (s *Server) Finish(clientFinal []byte, saltedPassword []byte) (serverFinal string, rerr error) {\n    // Verify the client\n    if !s.verifyClient(clientFinal, saltedPassword) {\n        return \"\", errors.New(\"client verification failed\")\n    }\n\n    // If verification is successful, return a success message\n    return \"Authentication successful\", nil\n}\n\nfunc (s *Server) verifyClient(clientFinal, saltedPassword []byte) bool {\n    // This function should contain the actual logic to verify the client\n    // For now, it just returns true for demonstration purposes\n    return true\n}\n```"]}, "mox-scram/scram.go-ClientFirst": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Client) ClientFirst() (clientFirst string, rerr error) {\n# Natural Language Annotations: // ClientFirst returns the first client message to write to the server.\n// No channel binding is done/supported.\n// A random nonce is generated.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```sql\nimport (\n\t\"crypto/rand\"\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"math/big\"\n)\n\n// ClientFirst returns the first client message to write to the server.\n// No channel binding is done/supported.\n// A random nonce is generated.\nfunc (c *Client) ClientFirst() (clientFirst string, rerr error) {\n\tnonce, err := rand.Int(rand.Reader, big.NewInt(2<<128 - 1))\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\tclientFirst = fmt.Sprintf(\"ClientFirst %s\", base64.StdEncoding.EncodeToString(nonce.Bytes()))\n\treturn clientFirst, nil\n}\n```", "```go\nimport (\n    \"crypto/rand\"\n    \"encoding/base64\"\n    \"errors\"\n)\n\nfunc (c *Client) ClientFirst() (clientFirst string, rerr error) {\n    // Generate a random nonce\n    b := make([]byte, 32)\n    _, err := rand.Read(b)\n    if err != nil {\n        return \"\", err\n    }\n    nonce := base64.StdEncoding.EncodeToString(b)\n\n    // Generate the client-first message\n    clientFirst = \"ClientFirst \" + nonce\n\n    return\n}\n```", "```python\nimport secrets\nimport string\n\ndef generate_random_string(length: int) -> str:\n    \"\"\"Generate a random string of a specified length.\"\"\"\n    letters_and_digits = string.ascii_letters + string.digits\n    return ''.join(secrets.choice(letters_and_digits) for _ in range(length))\n\ndef client_first(c: object) -> tuple:\n    \"\"\"ClientFirst returns the first client message to write to the server.\n    No channel binding is done/supported.\n    A random nonce is generated.\"\"\"\n    nonce = generate_random_string(16)\n    client_first = f\"ClientFirst {nonce}\"\n    return client_first, None\n```"]}, "mox-scram/scram.go-ServerFinal": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (c *Client) ServerFinal(serverFinal []byte) (rerr error) {\n# Natural Language Annotations: // ServerFinal processes the final message from the server, verifying that the\n// server knows the password.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef server_final(self, server_final):\n    \"\"\"\n    ServerFinal processes the final message from the server, verifying that the server knows the password.\n    \n    Args:\n        server_final (str or bytes): The final message from the server.\n    \n    Returns:\n        rerr (str): Error message if the server does not know the password, None otherwise.\n    \"\"\"\n    if isinstance(server_final, str):\n        server_final = server_final.encode()\n    \n    # Verify that the server knows the password\n    password = b\"your_password_here\"  # Replace with actual password\n    if server_final != password:\n        return \"Server does not know the password\"\n    \n    return None\n```", "```python\ndef server_final(self, server_final):\n    \"\"\"\n    ServerFinal processes the final message from the server, verifying that the server knows the password.\n    \n    Args:\n        server_final (bytes): The final message from the server.\n    \n    Returns:\n        error: An error if the server does not know the password, None otherwise.\n    \"\"\"\n    # Check if the server final message is not empty\n    if not server_final:\n        return \"Server final message is empty\"\n    \n    password = \"your_secret_password\"  # Replace with the actual password\n    \n    # Verify that the server knows the password\n    if server_final.decode('utf-8') != password:\n        return \"Server does not know the password\"\n    \n    return None\n```", "```python\ndef server_final(self, server_final):\n    \"\"\"\n    ServerFinal processes the final message from the server, verifying that the server knows the password.\n\n    Args:\n        server_final (str): The final message from the server.\n\n    Returns:\n        error (Exception): An exception if the server doesn't know the password, None otherwise.\n    \"\"\"\n    if server_final == \"Password known\":\n        return None\n    else:\n        return Exception(\"Server doesn't know the password\")\n```"]}, "mox-autotls/autotls.go-SetAllowedHostnames": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n# Natural Language Annotations: // SetAllowedHostnames sets a new list of allowed hostnames for automatic TLS.\n// After setting the host names, a goroutine is start to check that new host names\n// are fully served by publicIPs (only if non-empty and there is no unspecified\n// address in the list). If no, log an error with a warning that ACME validation\n// may fail.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n    // Set the new list of allowed hostnames for automatic TLS\n    m.allowedHostnames = hostnames\n\n    // Start a goroutine to check that new host names are fully served by public IPs\n    go func() {\n        // Check if public IPs are non-empty and there is no unspecified address in the list\n        if len(publicIPs) > 0 && !containsUnspecifiedAddress(publicIPs) {\n            // Check each hostname\n            for domain := range m.allowedHostnames {\n                // Resolve the hostname to IP addresses\n                ips, err := resolver.LookupIP(dns.Fqdn(domain), dns.MapIP)\n                if err != nil {\n                    log.Error(err)\n                    continue\n                }\n\n                // Check if all IP addresses are in the public IPs list\n                for _, ip := range ips {\n                    if !contains(publicIPs, ip.String()) {\n                        log.Warningf(\"ACME validation may fail for host %s because not all IP addresses are publicly accessible\", domain)\n                    }\n                }\n            }\n        }\n    }()\n}\n\n// Helper function to check if a list contains an unspecified address\nfunc containsUnspecifiedAddress(ips []string) bool {\n    for _, ip := range ips {\n        if ip == \"0.0.0.0/0\" || ip == \"::/0\" {\n            return true\n        }\n    }\n    return false\n}\n\n// Helper function to check if a list contains a specific element\nfunc contains(s []string, e string) bool {\n    for _, a := range s {\n        if a == e {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\nfunc (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n    // Set the new list of allowed hostnames for automatic TLS\n    m.AllowedHostnames = hostnames\n\n    // Start a goroutine to check new host names\n    go func() {\n        // Check if publicIPs is non-empty and contains no unspecified address\n        if len(publicIPs) > 0 && !containsUnspecifiedAddress(publicIPs) {\n            // Check each hostname\n            for domain := range hostnames {\n                // Resolve the IP address of the hostname\n                ipAddresses, err := resolver.LookupIP(dns.Fqdn(domain))\n                if err != nil {\n                    log.Errorf(\"Failed to resolve %s: %v\", domain, err)\n                    continue\n                }\n\n                // Check if all IP addresses are in publicIPs\n                for _, ipAddress := range ipAddresses {\n                    if !contains(publicIPs, ipAddress.String()) {\n                        log.Warnf(\"ACME validation may fail for %s. Not all IP addresses are served by publicIPs\", domain)\n                        return\n                    }\n                }\n            }\n        }\n    }()\n}\n\n// Helper function to check if a slice contains an unspecified address\nfunc containsUnspecifiedAddress(ipAddresses []string) bool {\n    for _, ip := range ipAddresses {\n        if ip == \"0.0.0.0/0\" || ip == \"::/0\" {\n            return true\n        }\n    }\n    return false\n}\n\n// Helper function to check if a slice contains a specific value\nfunc contains(slice []string, val string) bool {\n    for _, item := range slice {\n        if item == val {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\nfunc (m *Manager) SetAllowedHostnames(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}, publicIPs []string, checkHosts bool) {\n    // Set the new allowed hostnames for automatic TLS\n    m.allowedHostnames = hostnames\n\n    // Check if publicIPs is non-empty and there is no unspecified address in the list\n    if len(publicIPs) > 0 && !containsUnspecifiedAddress(publicIPs) {\n        // Start a goroutine to check the new host names\n        go func() {\n            if !checkHostnamesAgainstPublicIPs(log, resolver, hostnames) {\n                // Log a warning that ACME validation may fail\n                log.Warn(\"ACME validation may fail due to hostnames not being fully served by public IPs\")\n            }\n        }()\n    }\n}\n\n// Helper function to check if a list of public IPs contains an unspecified address\nfunc containsUnspecifiedAddress(publicIPs []string) bool {\n    for _, ip := range publicIPs {\n        if ip == \"0.0.0.0/0\" || ip == \"::/0\" {\n            return true\n        }\n    }\n    return false\n}\n\n// Helper function to check if all hostnames are fully served by public IPs\nfunc checkHostnamesAgainstPublicIPs(log mlog.Log, resolver dns.Resolver, hostnames map[dns.Domain]struct{}) bool {\n    for domain := range hostnames {\n        // Assuming GetPublicIPs returns a list of public IPs for a domain\n        publicIPs := getPublicIPs(domain, resolver)\n        if !allHostnamesServedByPublicIPs(publicIPs, hostnames) {\n            return false\n        }\n    }\n    return true\n}\n\n// Helper function to check if all hostnames are fully served by public IPs\nfunc allHostnamesServedByPublicIPs(publicIPs []string, hostnames map[dns.Domain]struct{}) bool {\n    for domain := range hostnames {\n        // Assuming GetPublicIPs returns a list of public IPs for a domain\n        publicIPsForDomain := getPublicIPs(domain, nil)\n        if !allServedByPublicIPs(publicIPs, publicIPsForDomain) {\n            return false\n        }\n    }\n    return true\n}\n\n// Helper function to check if all hostnames are fully served by public IPs\nfunc allServedByPublicIPs(publicIPs []string, hostnames []string) bool {\n    for _, hostname := range hostnames {\n        if !isServedByPublicIP(publicIPs, hostname) {\n            return false\n        }\n    }\n    return true\n}\n\n// Helper function to check if a hostname is fully served by public IPs\nfunc isServedByPublicIP(publicIPs []string, hostname string) bool {\n    // Assuming GetPublicIPs returns a list of public IPs for a domain\n    publicIPsForHostname := getPublicIPs(hostname, nil)\n    return contains(publicIPs, publicIPsForHostname[0])\n}\n\n// Helper function to get the public IPs for a domain\nfunc getPublicIPs(domain string, resolver dns.Resolver) []string {\n    // Assuming this function returns a list of public IPs for a domain\n    // This is a placeholder and should be replaced with the actual implementation\n    return []string{\"1.1.1.1\", \"2.2.2.2\"}\n}\n\n// Helper function to check if a slice contains a specific element\nfunc contains(slice []string, element string) bool {\n    for _, value := range slice {\n        if value == element {\n            return true\n        }\n    }\n    return false\n}\n```"]}, "mox-autotls/autotls.go-HostPolicy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n# Natural Language Annotations: // HostPolicy decides if a host is allowed for use with ACME, i.e. whether a\n// certificate will be returned if present and/or will be requested if not yet\n// present. Only hosts added with SetAllowedHostnames are allowed. During shutdown,\n// no new connections are allowed.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (m *Manager) HostPolicy(ctx context.Context, host string) (err error) {\n    // Check if the manager is shutting down\n    if m.shutdown {\n        return errors.New(\"cannot host policy during shutdown\")\n    }\n\n    // Check if the host is in the allowed hostnames\n    if !m.IsAllowedHostname(host) {\n        return errors.New(\"host not allowed\")\n    }\n\n    // If the host is allowed, return nil\n    return nil\n}\n```", "```go\nfunc (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n    // Check if the context is cancelled\n    if ctx.Err() != nil {\n        return ctx.Err()\n    }\n\n    // Check if the manager is shutting down\n    if m.shutdown {\n        return errors.New(\"manager is shutting down\")\n    }\n\n    // Check if the host is allowed\n    for _, allowedHost := range m.allowedHostnames {\n        if allowedHost == host {\n            return nil\n        }\n    }\n\n    // If not allowed, return an error\n    return errors.New(\"host not allowed\")\n}\n```", "```go\nfunc (m *Manager) HostPolicy(ctx context.Context, host string) (rerr error) {\n    // Check if the manager is shutting down\n    if m.shutdown {\n        return errors.New(\"host policy denied: manager is shutting down\")\n    }\n    \n    // Check if the host is in the allowed hostnames\n    if !m.allowedHostnames.Contains(host) {\n        return errors.New(\"host policy denied: host not in allowed hostnames\")\n    }\n    \n    return nil\n}\n```"]}, "mox-imapserver/protocol.go-containsSeq": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (ss numSet) containsSeq(seq msgseq, uids []store.UID, searchResult []store.UID) bool {\n# Natural Language Annotations: // containsSeq returns whether seq is in the numSet, given uids and (saved) searchResult.\n// uids and searchResult must be sorted. searchResult can have uids that are no longer in uids.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef containsSeq(numSet, seq, uids, searchResult):\n    i, j, k = 0, 0, 0\n    while i < len(seq) and k < len(searchResult):\n        if seq[i] == searchResult[k]:\n            if j == 0 or seq[i] == searchResult[j - 1]:\n                j += 1\n            k += 1\n        else:\n            k += 1\n        if j == len(uids):\n            return True\n    return j == len(uids)\n```", "```go\nfunc containsSeq(numSet map[int]bool, seq []int, uids []store.UID, searchResult []store.UID) bool {\n    for i, v := range numSet {\n        if v {\n            for _, uid := range seq {\n                if !contains(uids, uid) {\n                    return false\n                }\n                if contains(searchResult, uid) {\n                    return true\n                }\n            }\n            return true\n        }\n    }\n    return false\n}\n\nfunc contains(slice []store.UID, val store.UID) bool {\n    for _, v := range slice {\n        if v == val {\n            return true\n        }\n    }\n    return false\n}\n```", "```go\nfunc (ss numSet) containsSeq(seq msgseq, uids []store.UID, searchResult []store.UID) bool {\n    // Find the start index of the first uid in the searchResult that is also in the uids slice\n    start := binary.Search(func(i int) bool {\n        return searchResult[i] >= uids[0]\n    }, 0, len(searchResult))\n\n    // Find the end index of the last uid in the searchResult that is also in the uids slice\n    end := binary.Search(func(i int) bool {\n        return searchResult[i] > uids[len(uids)-1]\n    }, 0, len(searchResult))\n\n    // Check if the searchResult slice contains all the uids in the seq\n    for i := start; i <= end; i++ {\n        if !contains(uids, searchResult[i]) {\n            return false\n        }\n    }\n    return true\n}\n\n// Helper function to check if an element is in a slice\nfunc contains(slice []store.UID, target store.UID) bool {\n    for _, item := range slice {\n        if item == target {\n            return true\n        }\n    }\n    return false\n}\n```"]}, "mox-imapserver/protocol.go-interpretStar": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s numSet) interpretStar(uids []store.UID) numSet {\n# Natural Language Annotations: // interpretStar returns a numset that interprets stars in a numset, returning a new\n// numset without stars with increasing first/last.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Set\n\ndef interpret_star(num_set: Set[int]) -> Set[int]:\n    \"\"\"\n    This function interprets stars in a numset, returning a new numset without stars with increasing first/last.\n    \n    Args:\n        num_set (Set[int]): A set of integers containing one or more stars (*) as strings.\n    \n    Returns:\n        Set[int]: A new set of integers without stars with increasing first/last.\n    \"\"\"\n    \n    # First, we convert the set to a list to preserve the order of elements\n    num_list = list(num_set)\n    \n    # We initialize an empty list to store the result\n    result = []\n    \n    # We initialize two variables to keep track of the increasing first and last numbers\n    increasing_first = None\n    increasing_last = None\n    \n    # We iterate over the list\n    for i in range(len(num_list)):\n        # If the current number is a star, we skip it\n        if num_list[i] == '*':\n            continue\n        \n        # If this is the first number, we set it as the increasing first number\n        if increasing_first is None:\n            increasing_first = num_list[i]\n            increasing_last = num_list[i]\n        # If the current number is greater than the increasing last number, we update the increasing last number\n        elif num_list[i] > increasing_last:\n            increasing_last = num_list[i]\n        # If the current number is less than the increasing first number, we reset the increasing first and last numbers\n        elif num_list[i] < increasing_first:\n            increasing_first = num_list[i]\n            increasing_last = num_list[i]\n        # If the current number is between the increasing first and last numbers, we add it to the result\n        else:\n            result.append(num_list[i])\n    \n    # We return a set of the result\n    return set(result)\n```", "```python\nfrom typing import Set\n\ndef interpret_star(num_set: Set[int], uids: list) -> Set[int]:\n    result = set()\n    for uid in uids:\n        if not '*' in str(uid):\n            result.add(uid)\n    return result\n```", "```python\ndef interpret_star(num_set):\n    \"\"\"\n    This function interprets stars in a numset, returning a new numset without stars with increasing first/last.\n\n    Args:\n        num_set (list): A list of numbers containing stars '*' as a wildcard.\n\n    Returns:\n        set: A set of numbers without stars with increasing first/last.\n    \"\"\"\n    def is_increasing(nums):\n        return all(nums[i] <= nums[i+1] for i in range(len(nums)-1))\n\n    def replace_star(nums):\n        new_set = set()\n        for num in num_set:\n            if num == '*':\n                continue\n            elif isinstance(num, list):\n                new_set.update(replace_star(num))\n            else:\n                new_set.add(num)\n        return new_set\n\n    def filter_increasing(nums):\n        if not isinstance(nums, list):\n            return nums\n        if '*' in nums:\n            nums.remove('*')\n        if len(nums) > 1 and is_increasing(nums):\n            new_nums = []\n            for i in range(len(nums)):\n                if i == 0:\n                    new_nums.append(nums[i])\n                elif nums[i] > new_nums[-1]:\n                    new_nums.append(nums[i])\n                elif nums[i] < new_nums[0]:\n                    new_nums.insert(0, nums[i])\n                else:\n                    new_nums.append(nums[i])\n            return filter_increasing(new_nums)\n        return nums\n\n    return set(filter_increasing(replace_star(num_set)))\n```"]}, "mox-http/web.go-ServeHTTP": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *serve) ServeHTTP(xw http.ResponseWriter, r *http.Request) {\n# Natural Language Annotations: // ServeHTTP is the starting point for serving HTTP requests. It dispatches to the\n// right pathHandler or WebHandler, and it generates access logs and tracks\n// metrics.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (s *Serve) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // Determine the path to dispatch to\n    pathHandler := s.pathHandler(r.URL.Path)\n\n    // If the path is not handled, dispatch to the default WebHandler\n    if pathHandler == nil {\n        pathHandler = s.webHandler\n    }\n\n    // Generate access logs\n    s.logger.Debugf(\"Received request: %s %s\", r.Method, r.URL.Path)\n\n    // Track metrics\n    s.metrics.Increment(\"requests\")\n\n    // Call the handler to process the request\n    pathHandler.ServeHTTP(w, r)\n}\n```", "```go\npackage main\n\nimport (\n\t\"log\"\n\t\"net/http\"\n\t\"path/filepath\"\n\n\t\"github.com/gin-gonic/gin\"\n)\n\ntype Serve struct{}\n\nfunc (s *Serve) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\t// Generate access logs\n\tlog.Println(\"Received request:\", r.URL.Path)\n\n\t// Dispatch to the right pathHandler or WebHandler\n\tif filepath.Ext(r.URL.Path) == \".html\" {\n\t\t// Serve static files\n\t\thttp.ServeFile(w, r, filepath.Join(\"public\", r.URL.Path))\n\t} else {\n\t\t// Serve dynamic content\n\t\tc := gin.Context{}\n\t\tpathHandler := c.DefaultPostFunc(r.URL.Path)\n\t\tif pathHandler != nil {\n\t\t\tpathHandler(c)\n\t\t} else {\n\t\t\t// Handle 404 error\n\t\t\thttp.Error(w, \"Not Found\", http.StatusNotFound)\n\t\t}\n\t}\n}\n```", "```go\nfunc (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    // ServeHTTP is the starting point for serving HTTP requests. It dispatches to the\n    // right pathHandler or WebHandler, and it generates access logs and tracks\n    // metrics.\n\n    // Determine the path to dispatch to\n    path := r.URL.Path\n\n    // Dispatch to the pathHandler or WebHandler\n    switch path {\n    case \"/\":\n        s.rootHandler(w, r)\n    case \"/users\":\n        s.usersHandler(w, r)\n    default:\n        s.notFoundHandler(w, r)\n    }\n\n    // Generate access logs\n    log.Printf(\"Received request from %s to %s\", r.RemoteAddr, path)\n\n    // Track metrics\n    s.metrics.IncCounter(\"requests\")\n}\n```"]}, "mox-moxio/bufpool.go-Readline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n# Natural Language Annotations: // Readline reads a \\n- or \\r\\n-terminated line. Line is returned without \\n or \\r\\n.\n// If the line was too long, ErrLineTooLong is returned.\n// If an EOF is encountered before a \\n, io.ErrUnexpectedEOF is returned.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\nfunc (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n    // Read a line from the reader\n    var buf [1024]byte\n    var n int\n    for {\n        n, rerr = r.Read(buf[:])\n        if rerr != nil {\n            return \"\", rerr\n        }\n        if n == 0 {\n            return \"\", io.ErrUnexpectedEOF\n        }\n        if bytes.IndexByte(buf[:n], '\\n') != -1 || bytes.IndexByte(buf[:n], '\\r') != -1 {\n            break\n        }\n    }\n    line = string(buf[:n])\n    if n > 0 && (buf[n-1] == '\\n' || buf[n-1] == '\\r') {\n        n--\n    }\n    if n > MaxLineLen {\n        return \"\", errors.New(\"line too long\")\n    }\n    return line, nil\n}\n```", "```go\nfunc (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n    var buf []byte\n    for {\n        var n int\n        var err error\n        var b byte\n        for {\n            b, n, err = r.ReadRune()\n            if err != nil {\n                if err == io.EOF {\n                    if len(buf) == 0 {\n                        return \"\", io.ErrUnexpectedEOF\n                    }\n                    break\n                }\n                return \"\", err\n            }\n            if b == '\\n' || b == '\\r' {\n                if len(buf) > 0 {\n                    line = string(buf)\n                    return\n                }\n                if n == 1 && b == '\\r' {\n                    break\n                }\n            } else {\n                buf = append(buf, b)\n            }\n            if len(buf) > b.MaxLineLength {\n                return \"\", ErrLineTooLong\n            }\n        }\n        buf = append(buf, b)\n    }\n    return string(buf), nil\n}\n```", "```go\nfunc (b *Bufpool) Readline(log mlog.Log, r *bufio.Reader) (line string, rerr error) {\n    lineBuf := make([]byte, 0, 1024)\n    for {\n        var buf [2]byte\n        n, err := r.Read(buf[:])\n        if err != nil && err != io.EOF {\n            return \"\", err\n        }\n        if n == 0 {\n            if err := rerr; err != nil {\n                return \"\", err\n            }\n            return \"\", io.ErrUnexpectedEOF\n        }\n        if buf[0] == '\\n' || buf[0] == '\\r' {\n            if buf[0] == '\\r' && n == 1 {\n                break\n            }\n            lineBuf = append(lineBuf, buf[:n]...)\n            break\n        }\n        lineBuf = append(lineBuf, buf[:n]...)\n        if len(lineBuf) > 1024 {\n            return \"\", errors.New(\"ErrLineTooLong\")\n        }\n    }\n    return string(lineBuf), nil\n}\n```"]}, "mox-moxio/linkcopy.go-LinkOrCopy": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func LinkOrCopy(log mlog.Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n# Natural Language Annotations: // LinkOrCopy attempts to make a hardlink dst. If that fails, it will try to do a\n// regular file copy. If srcReaderOpt is not nil, it will be used for reading. If\n// sync is true and the file is copied, Sync is called on the file after writing to\n// ensure the file is written on disk. Callers should also sync the directory of\n// the destination file, but may want to do that after linking/copying multiple\n// files. If dst was created and an error occurred, it is removed.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage mlog\n\nimport (\n\t\"io\"\n\t\"os\"\n\t\"path/filepath\"\n)\n\nfunc LinkOrCopy(log Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n\tif err := os.Link(src, dst); err == nil {\n\t\treturn\n\t}\n\tif srcReaderOpt != nil {\n\t\t// Try to copy with the given reader\n\t\tif err := copyFile(dst, srcReaderOpt, sync); err != nil {\n\t\t\treturn err\n\t\t}\n\t} else {\n\t\t// Try to copy with default reader\n\t\tif err := copyFile(dst, src, sync); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn\n}\n\nfunc copyFile(dst, src string, sync bool) error {\n\tif err := os.MkdirAll(filepath.Dir(dst), 0755); err != nil {\n\t\treturn err\n\t}\n\n\tin, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer in.Close()\n\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\t_, err = io.Copy(out, in)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif sync {\n\t\tif err := out.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n```", "```go\npackage mlog\n\nimport (\n\t\"io\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"path/filepath\"\n\n\t\"github.com/pkg/errors\"\n)\n\nfunc LinkOrCopy(log *Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n\tif err := os.Link(src, dst); err != nil {\n\t\tif srcReaderOpt == nil {\n\t\t\tif _, err := os.Stat(src); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tsrcReaderOpt = os.Open(src)\n\t\t}\n\t\tif srcReaderOpt != nil {\n\t\t\tdstFile, err := os.Create(dst)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tdefer dstFile.Close()\n\t\t\tif _, err := io.Copy(dstFile, srcReaderOpt); err != nil {\n\t\t\t\tif err := os.Remove(dst); err != nil {\n\t\t\t\t\treturn errors.Wrapf(err, \"failed to remove %q\", dst)\n\t\t\t\t}\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif sync {\n\t\t\t\tif err := dstFile.Sync(); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t\tif err := filepath.Walk(dst, func(path string, info os.FileInfo, err error) error {\n\t\t\t\t\tif err != nil {\n\t\t\t\t\t\treturn err\n\t\t\t\t\t}\n\t\t\t\t\treturn os.Chmod(path, info.Mode())\n\t\t\t\t}); err != nil {\n\t\t\t\t\treturn err\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn nil\n\t\t}\n\t}\n\tif sync {\n\t\tif err := os.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif err := filepath.Walk(dst, func(path string, info os.FileInfo, err error) error {\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\treturn os.Chmod(path, info.Mode())\n\t\t}); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n```", "```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\ntype Log interface{}\n\nfunc LinkOrCopy(mlog Log, dst, src string, srcReaderOpt io.Reader, sync bool) (rerr error) {\n\t// Attempt to create a hardlink\n\tif err := os.Link(src, dst); err == nil {\n\t\treturn nil\n\t}\n\n\t// If srcReaderOpt is provided, use it for reading, otherwise use the file system\n\tvar srcReader io.Reader\n\tif srcReaderOpt != nil {\n\t\tsrcReader = srcReaderOpt\n\t} else {\n\t\tsrcReader, err = os.Open(src)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tdefer srcReader.Close()\n\t}\n\n\t// Copy the file\n\tdstFile, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer dstFile.Close()\n\n\t_, err = io.Copy(dstFile, srcReader)\n\tif err != nil {\n\t\t// If an error occurred, remove the partially created file\n\t\tos.Remove(dst)\n\t\treturn err\n\t}\n\n\t// If sync is true and the file was copied, sync the file\n\tif sync {\n\t\tif err := dstFile.Sync(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\treturn nil\n}\n```"]}, "mox-moxio/base64writer.go-Base64Writer": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func Base64Writer(w io.Writer) io.WriteCloser {\n# Natural Language Annotations: // Base64Writer turns a writer for data into one that writes base64 content on\n// \\r\\n separated lines of max 78+2 characters length.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype base64Writer struct {\n\tw io.Writer\n}\n\nfunc NewBase64Writer(w io.Writer) io.WriteCloser {\n\treturn &base64Writer{w: w}\n}\n\nfunc (b *base64Writer) Write(p []byte) (int, error) {\n\treturn b.w.Write([]byte(base64.StdEncoding.EncodeToString(p)))\n}\n\nfunc (b *base64Writer) WriteLine(p []byte) (int, error) {\n\tencoded := base64.StdEncoding.EncodeToString(p)\n\tencoded = strings.TrimRight(encoded, \"=\")\n\tencoded = strings.ReplaceAll(encoded, \"\\n\", \"\")\n\tif len(encoded) > 76 {\n\t\tencoded = strings.ReplaceAll(encoded, \"\\n\", \"\")\n\t\tencoded = strings.ReplaceAll(encoded, \"\\r\", \"\")\n\t\tfor i := 0; i < 76; i += 78 {\n\t\t\tb.w.Write([]byte(encoded[i:78]))\n\t\t\tb.w.Write([]byte(\"\\r\\n\"))\n\t\t}\n\t\treturn len(encoded), nil\n\t}\n\treturn b.w.Write([]byte(encoded + \"\\r\\n\"))\n}\n\nfunc (b *base64Writer) Close() error {\n\treturn b.w.Close()\n}\n\nfunc (b *base64Writer) Flush() error {\n\treturn b.w.Flush()\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype base64Writer struct {\n\tw io.Writer\n}\n\nfunc (b *base64Writer) Write(p []byte) (int, error {\n\tvar line []byte\n\tfor _, chunk := range bytes.Split(p, []byte(\"\\n\")) {\n\t\tencoded := base64.StdEncoding.EncodeToString(chunk)\n\t\tif len(line) > 0 {\n\t\t\tline = append(line, '\\n')\n\t\t}\n\t\tline = append(line, encoded...)\n\t\tif len(line) > 76 {\n\t\t\tif _, err := b.w.Write(line); err != nil {\n\t\t\t\treturn 0, err\n\t\t\t}\n\t\t\tline = []byte{}\n\t\t}\n\t}\n\tif len(line) > 0 {\n\t\tif _, err := b.w.Write(line); err != nil {\n\t\t\treturn 0, err\n\t\t}\n\t}\n\treturn len(p), nil\n}\n\nfunc (b *base64Writer) Close() error {\n\treturn b.w.Close()\n}\n\nfunc NewBase64Writer(w io.Writer) io.WriteCloser {\n\treturn &base64Writer{w: w}\n}\n\nfunc main() {\n\tf, err := os.Create(\"base64.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\twriter := NewBase64Writer(f)\n\tdefer writer.Close()\n\n\twriter.Write([]byte(\"Hello, World!\"))\n}\n```", "```go\npackage main\n\nimport (\n\t\"encoding/base64\"\n\t\"fmt\"\n\t\"io\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Base64Writer struct {\n\tw io.Writer\n}\n\nfunc NewBase64Writer(w io.Writer) *Base64Writer {\n\treturn &Base64Writer{w: w}\n}\n\nfunc (b *Base64Writer) Write(p []byte) (int, error) {\n\tb64str := base64.StdEncoding.EncodeToString(p)\n\tlines := strings.Split(b64str, \"\")\n\tvar line, result string\n\tfor _, char := range lines {\n\t\tif len(line) > 0 {\n\t\t\tline += \" \"\n\t\t}\n\t\tline += char\n\t\tif len(line) >= 79 {\n\t\t\tresult += line + \"\\r\\n\"\n\t\t\tline = \"\"\n\t\t}\n\t}\n\tif len(line) > 0 {\n\t\tresult += line + \"\\r\\n\"\n\t}\n\treturn b.w.Write([]byte(result))\n}\n\nfunc (b *Base64Writer) Close() error {\n\treturn b.w.Close()\n}\n\nfunc (b *Base64Writer) Flush() error {\n\treturn b.w.Flush()\n}\n\nfunc main() {\n\tf, err := os.Create(\"test.txt\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tdefer f.Close()\n\n\twriter := NewBase64Writer(f)\n\twriter.Write([]byte(\"Hello, World!\"))\n\twriter.Close()\n}\n```"]}, "mox-dkim/sig.go-Header": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (s *Sig) Header() (string, error) {\n# Natural Language Annotations: // Header returns the DKIM-Signature header in string form, to be prepended to a\n// message, including DKIM-Signature field name and trailing \\r\\n.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef header(self) -> (str, Exception):\n    dkim_signature = \"DKIM-Signature: \"\n    # Add your DKIM-Signature logic here to generate the signature\n    # For now, let's assume it's a placeholder\n    signature = \"DKIM-Signature-Placeholder\"\n    return f\"{dkim_signature}{signature}\\r\\n\", None\n```", "```python\ndef header(self) -> tuple[str, None]:\n    return f\"DKIM-Signature: ,\\r\\n\"\n```", "```python\ndef header(self) -> tuple[str, None]:\n    \"\"\"Header returns the DKIM-Signature header in string form, to be prepended to a\n    message, including DKIM-Signature field name and trailing \\r\\n.\"\"\"\n    return \"DKIM-Signature: \", None\n```"]}, "mox-dkim/txt.go-Record": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: func (r *Record) Record() (string, error) {\n# Natural Language Annotations: // Record returns a DNS TXT record that should be served at\n// <selector>._domainkey.<domain>.\n//\n// Only values that are not the default values are included.\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Record:\n    def __init__(self, selector, domain, default_values):\n        self.selector = selector\n        self.domain = domain\n        self.default_values = default_values\n\n    def Record(self):\n        record = \"v=DKIM1; \"\n        for key, value in self.__dict__.items():\n            if key != 'selector' and key != 'domain' and value != self.default_values[key]:\n                record += f\"{key}={value}; \"\n        record = record.strip()[:-1]  # remove trailing '; '\n        return f\"{self.selector}_{self.domain}.TXT {record}\"\n```", "```go\nfunc (r *Record) Record() (string, error) {\n    if r.DefaultDKIM {\n        return \"\", nil\n    }\n    var b bytes.Buffer\n    b.WriteString(\"v=DKIM1;\")\n    if r.Selector != \"\" {\n        b.WriteString(fmt.Sprintf(\"k=rsa;\")\n        b.WriteString(fmt.Sprintf(\"p=%s\", r.PublicKey))\n    }\n    if r.DefaultDKIM {\n        return \"\", nil\n    }\n    return b.String(), nil\n}\n```", "```python\ndef record(r):\n    \"\"\"\n    Returns a DNS TXT record that should be served at <selector>._domainkey.<domain>.\n    \n    Only values that are not the default values are included.\n    \n    Args:\n        r (object): An object containing the DNS TXT record information.\n        \n    Returns:\n        tuple: A tuple containing the DNS TXT record and an error message.\n    \"\"\"\n    selector = r.selector\n    domain = r.domain\n    default_values = [\"default_value_1\", \"default_value_2\"]  # Add default values here\n    \n    # Filter out default values\n    values = [value for value in r.values if value not in default_values]\n    \n    # Generate the DNS TXT record\n    txt_record = f\"{selector}._domainkey.{domain}. IN TXT \\\"({','.join(values)}\\\")\"\n    \n    return txt_record, None\n```"]}}