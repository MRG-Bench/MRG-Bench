{"litestar-litestar/file_system.py-info": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n# Natural Language Annotations: \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom pathlib import Path\nimport os\n\nclass FileSystem:\n    async def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n        \"\"\"\n        Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\n        if not isinstance(path, Path):\n            path = Path(path)\n\n        file_info = {\n            'exists': path.exists(),\n            'is_file': path.is_file(),\n            'is_dir': path.is_dir(),\n            'size': path.stat().st_size,\n            'modified': path.stat().st_mtime,\n            'created': path.stat().st_ctime,\n            'permissions': oct(path.stat().st_mode)\n        }\n\n        return file_info\n```", "```python\nfrom typing import Any, Dict\nfrom pathlib import Path\n\nclass FileInfo:\n    def __init__(self, path: Path, **kwargs: Any):\n        self.path = path\n        self.kwargs = kwargs\n        self.info: Dict[str, Any] = {}\n\n    def get_info(self, path: Path, **kwargs: Any) -> 'FileInfo':\n        \"\"\"Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\n        self.info['path'] = str(path)\n        for key, value in kwargs.items():\n            self.info[key] = value\n        return self.info\n\nclass FileHandler:\n    def info(self, path: Path, **kwargs: Any) -> FileInfo:\n        return FileInfo(path, **kwargs).get_info(path, **kwargs)\n```", "```python\nfrom typing import Any, Dict\nfrom pathlib import Path\n\nclass FileInfo:\n    def __init__(self, name: str, size: int, modified: str, created: str, accessed: str):\n        self.name = name\n        self.size = size\n        self.modified = modified\n        self.created = created\n        self.accessed = accessed\n\n    def __dict__(self):\n        return {\n            'name': self.name,\n            'size': self.size,\n            'modified': self.modified,\n            'created': self.created,\n            'accessed': self.accessed\n        }\n\nclass File:\n    async def info(self, path: PathType, **kwargs: Any) -> Dict[str, Any]:\n        \"\"\"\n        Retrieve information about a given file path.\n\n        Args:\n            path: A file path.\n            **kwargs: Any additional kwargs.\n\n        Returns:\n            A dictionary of file info.\n        \"\"\"\n        import os\n        import stat\n        import datetime\n\n        file_path = Path(path)\n        if not file_path.exists():\n            return {'error': 'File does not exist'}\n\n        stats = os.stat(file_path)\n        file_info = FileInfo(\n            name=file_path.name,\n            size=stats.st_size,\n            modified=datetime.datetime.fromtimestamp(stats.st_mtime).isoformat(),\n            created=datetime.datetime.fromtimestamp(stats.st_ctime).isoformat(),\n            accessed=datetime.datetime.fromtimestamp(stats.st_atime).isoformat()\n        )\n\n        return file_info.__dict__\n```"]}, "litestar-litestar/typing.py-has_inner_subclass_of": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n# Natural Language Annotations: \"\"\"Whether any generic args are a subclass of the given type.\n\n        Args:\n            cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n        Returns:\n            Whether any of the type's generic args are a subclass of the given type.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, type\n\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    return any(issubclass(inner, cl) for inner in self.__orig_bases__)\n```", "```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"\n    Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    return any(issubclass(self.__orig_bases__[i].__origin__, cl) for i in range(len(self.__orig_bases__)))\n```", "```\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"\n    Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    if isinstance(cl, tuple):\n        return any(issubclass(arg, cl) for arg in self.__orig_bases__)\n    else:\n        return issubclass(self, cl)\n```"]}, "litestar-litestar/typing.py-get_type_hints": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the type hints for the annotation.\n\n        Args:\n            include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n            resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n        Returns:\n            The type hints.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nfrom typing import Any, Dict, TypeVar\nfrom typing_extensions import get_type_hints, Annotated\n\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> Dict[str, Any]:\n    type_hints = get_type_hints(self.__annotations__)\n    if include_extras:\n        type_hints = {key: Annotated(value, *value.__annotations__) for key, value in type_hints.items()}\n    if resolve_generics:\n        # This is a simplified implementation, actual implementation may vary based on the specific use case\n        type_hints = {key: str(value) for key, value in type_hints.items() if isinstance(value, type)}\n    return type_hints\n```", "```python\nfrom typing import Dict, Any, Annotated, get_type_hints, get_origin, get_args, TypeVar, Generic\n\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> Dict[str, Any]:\n    \"\"\"\n    Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    type_hints = get_type_hints(self.__annotations__)\n    \n    if include_extras:\n        for name, hint in type_hints.items():\n            if isinstance(hint, Annotated):\n                type_hints[name] = get_args(hint.annotation)\n    \n    if resolve_generics:\n        for name, hint in type_hints.items():\n            if isinstance(hint, TypeVar):\n                type_hints[name] = hint.__bound__\n    \n    return type_hints\n```", "```\nfrom typing import Any, Dict\n\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> Dict[str, Any]:\n    type_hints = {}\n    # implement logic to get type hints\n    return type_hints\n```"]}, "litestar-litestar/typing.py-from_kwarg": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_kwarg(\n# Natural Language Annotations: \"\"\"Create a new FieldDefinition instance.\n\n        Args:\n            annotation: The type of the kwarg.\n            name: Field name.\n            default: A default value.\n            inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n            kwarg_definition: Kwarg Parameter.\n            extra: A mapping of extra values.\n\n        Returns:\n            FieldDefinition instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass FieldDefinition:\n    def __init__(self, annotation, name, default, inner_types=None, kwarg_definition=None, extra=None):\n        self.annotation = annotation\n        self.name = name\n        self.default = default\n        self.inner_types = inner_types if inner_types else []\n        self.kwarg_definition = kwarg_definition\n        self.extra = extra if extra else {}\n\ndef from_kwarg(annotation, name, default, inner_types=None, kwarg_definition=None, extra=None):\n    return FieldDefinition(annotation, name, default, inner_types, kwarg_definition, extra)\n```", "```\ndef from_kwarg(annotation, name, default, inner_types=None, kwarg_definition=None, extra=None):\n    return FieldDefinition(annotation, name, default, inner_types, kwarg_definition, extra)\n```", "```python\nfrom typing import Any, Dict, Tuple, Optional\n\nclass FieldDefinition:\n    def __init__(self, annotation: type, name: str, default: Any, inner_types: Tuple['FieldDefinition', ...], kwarg_definition: Any, extra: Dict[str, Any]):\n        self.annotation = annotation\n        self.name = name\n        self.default = default\n        self.inner_types = inner_types\n        self.kwarg_definition = kwarg_definition\n        self.extra = extra\n\ndef from_kwarg(annotation: type, name: str, default: Any, inner_types: Tuple['FieldDefinition', ...], kwarg_definition: Any, extra: Dict[str, Any]) -> 'FieldDefinition':\n    return FieldDefinition(annotation, name, default, inner_types, kwarg_definition, extra)\n```"]}, "litestar-litestar/typing.py-from_parameter": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n# Natural Language Annotations: \"\"\"Initialize ParsedSignatureParameter.\n\n        Args:\n            parameter: inspect.Parameter\n            fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n                :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n        Returns:\n            ParsedSignatureParameter.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom inspect import Parameter\nfrom typing import Any, Dict\n\nclass ParsedSignatureParameter:\n    def __init__(self, name: str, annotation: Any):\n        self.name = name\n        self.annotation = annotation\n\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: Dict[str, Any]) -> ParsedSignatureParameter:\n    name = parameter.name\n    if parameter.annotation == Parameter.empty:\n        annotation = None\n    elif isinstance(parameter.annotation, str):\n        annotation = fn_type_hints.get(parameter.annotation)\n    else:\n        annotation = parameter.annotation\n    return cls(name, annotation)\n```", "```\nfrom typing import Any, Dict\n\nclass ParsedSignatureParameter:\n    def __init__(self, name: str, annotation: Any, default: Any, kind: str):\n        self.name = name\n        self.annotation = annotation\n        self.default = default\n        self.kind = kind\n\ndef from_parameter(cls, parameter: inspect.Parameter, fn_type_hints: Dict[str, Any]) -> ParsedSignatureParameter:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n\n    \"\"\"\n    name = parameter.name\n    annotation = fn_type_hints.get(name, parameter.annotation)\n    default = parameter.default\n    kind = parameter.kind\n\n    return cls(name, annotation, default, kind)\n```", "```python\nfrom typing import Any\n\nclass ParsedSignatureParameter:\n    def __init__(self, parameter: 'inspect.Parameter', fn_type_hints: dict[str, Any]):\n        self.parameter = parameter\n        self.fn_type_hints = fn_type_hints\n\ndef from_parameter(cls, parameter: 'inspect.Parameter', fn_type_hints: dict[str, Any]) -> 'ParsedSignatureParameter':\n    return cls(parameter=parameter, fn_type_hints=fn_type_hints)\n```"]}, "litestar-litestar/_openapi/responses.py-create_success_response": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_success_response(self) -> OpenAPIResponse:\n# Natural Language Annotations: \"\"\"Create the schema for a success response.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nfrom fastapi import Response\nfrom pydantic import BaseModel\n\nclass SuccessResponse(BaseModel):\n    status: int\n    message: str\n\ndef create_success_response(self) -> Response:\n    return Response(content={\"status\": 200, \"message\": \"OK\"}, media_type=\"application/json\")\n```", "```python\nfrom fastapi import Response, HTTPException\n\ndef create_success_response(self) -> Response:\n    \"\"\"\n    Create the schema for a success response.\n    \"\"\"\n    return Response(\n        content={\"message\": \"Success\", \"status_code\": 200},\n        media_type=\"application/json\",\n        status_code=200,\n    )\n```", "```python\nfrom fastapi import Response\nfrom pydantic import BaseModel\n\nclass SuccessResponse(BaseModel):\n    message: str\n    status: int = 200\n\ndef create_success_response(self) -> Response:\n    return Response(content=SuccessResponse(message=\"Request was successful\").dict(), media_type=\"application/json\", status_code=200)\n```"]}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n# Natural Language Annotations: \"\"\"Create the schema for additional responses, if any.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Iterator, Tuple\n\nclass OpenAPIResponse:\n    def __init__(self, description: str, content: dict):\n        self.description = description\n        self.content = content\n\ndef create_additional_responses(self) -> Iterator[Tuple[str, OpenAPIResponse]]:\n    additional_responses = {\n        '200': OpenAPIResponse('Successful response', {'application/json': {'schema': {'type': 'object'}})},\n        '400': OpenAPIResponse('Bad request', {'application/json': {'schema': {'type': 'object'}}),\n                              'text/plain': {'example': 'Bad request'}},\n                              'text/html': {'example': '<h1>Bad request</h1>'}),\n        '500': OpenAPIResponse('Internal server error', {'application/json': {'schema': {'type': 'object'}}),\n                              'text/plain': {'example': 'Internal server error'},\n                              'text/html': {'example': '<h1>Internal server error</h1>'})\n    }\n    \n    for status_code, response in additional_responses.items():\n        yield status_code, response\n```", "```python\nfrom typing import Iterator, Tuple, Dict\nfrom fastapi import Response\n\nclass OpenAPIResponse:\n    pass\n\nclass MyAPI:\n    def create_additional_responses(self) -> Iterator[Tuple[str, OpenAPIResponse]]:\n        # Define additional responses\n        additional_responses = {\n            \"200\": {\n                \"description\": \"The item was successfully created\",\n                \"content\": {\n                    \"application/json\": {\n                        \"schema\": {\n                            \"$ref\": \"#/components/schemas/Item\"\n                        }\n                    }\n                }\n            },\n            \"400\": {\n                \"description\": \"Invalid request\",\n                \"content\": {\n                    \"application/json\": {\n                        \"schema\": {\n                            \"$ref\": \"#/components/schemas/Error\"\n                        }\n                    }\n                }\n            },\n            \"404\": {\n                \"description\": \"Item not found\",\n                \"content\": {\n                    \"application/json\": {\n                        \"schema\": {\n                            \"$ref\": \"#/components/schemas/Error\"\n                        }\n                    }\n                }\n            }\n        }\n\n        # Iterate over additional responses and yield each one\n        for status_code, response in additional_responses.items():\n            yield status_code, response\n```", "```python\nfrom typing import Iterator, Tuple, Dict\nfrom pydantic import BaseModel\nfrom fastapi.responses import JSONResponse\n\nclass OpenAPIResponse(BaseModel):\n    description: str\n    content: Dict[str, JSONResponse]\n\ndef create_additional_responses(self) -> Iterator[Tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    additional_responses = {\n        \"200\": OpenAPIResponse(\n            description=\"Successful response\",\n            content={\n                \"application/json\": JSONResponse(\n                    media_type=\"application/json\",\n                    content={\"message\": \"Operation successful\"}\n                )\n            }\n        ),\n        \"400\": OpenAPIResponse(\n            description=\"Invalid request\",\n            content={\n                \"application/json\": JSONResponse(\n                    media_type=\"application/json\",\n                    content={\"message\": \"Invalid request\"}\n                )\n            }\n        ),\n        \"404\": OpenAPIResponse(\n            description=\"Resource not found\",\n            content={\n                \"application/json\": JSONResponse(\n                    media_type=\"application/json\",\n                    content={\"message\": \"Resource not found\"}\n                )\n            }\n        ),\n        \"500\": OpenAPIResponse(\n            description=\"Internal server error\",\n            content={\n                \"application/json\": JSONResponse(\n                    media_type=\"application/json\",\n                    content={\"message\": \"Internal server error\"}\n                )\n            }\n        )\n    }\n    for status_code, response in additional_responses.items():\n        yield status_code, response\n```"]}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_path_item(self) -> PathItem:\n# Natural Language Annotations: \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n        Returns:\n            A PathItem instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom pydantic import BaseModel\nfrom enum import Enum\nfrom typing import List\n\nclass HTTPMethod(str, Enum):\n    GET = 'GET'\n    POST = 'POST'\n    PUT = 'PUT'\n    DELETE = 'DELETE'\n\nclass Operation(BaseModel):\n    description: str\n    responses: dict\n    request_body: dict\n\nclass PathItem(BaseModel):\n    summary: str\n    description: str\n    operation_id: str\n    parameters: List\n    responses: dict\n    request_body: dict\n    get: Operation\n    post: Operation\n    put: Operation\n    delete: Operation\n    head: Operation\n    options: Operation\n    patch: Operation\n\ndef create_path_item(self) -> 'PathItem':\n    path_item = PathItem(\n        summary='Path Item',\n        description='Path Item description',\n        operation_id='path_item',\n        parameters=[],\n        responses={},\n        request_body={},\n        get=Operation(\n            description='Get operation',\n            responses={},\n            request_body={}\n        ),\n        post=Operation(\n            description='Post operation',\n            responses={},\n            request_body={}\n        ),\n        put=Operation(\n            description='Put operation',\n            responses={},\n            request_body={}\n        ),\n        delete=Operation(\n            description='Delete operation',\n            responses={},\n            request_body={}\n        ),\n        head=Operation(\n            description='Head operation',\n            responses={},\n            request_body={}\n        ),\n        options=Operation(\n            description='Options operation',\n            responses={},\n            request_body={}\n        ),\n        patch=Operation(\n            description='Patch operation',\n            responses={},\n            request_body={}\n        )\n    )\n    return path_item\n```", "```python\nfrom fastapi import Path, HTTPException\nfrom pydantic import BaseModel\nfrom typing import List\n\nclass Operation(BaseModel):\n    description: str\n    responses: dict\n\nclass PathItem(BaseModel):\n    description: str\n    summary: str\n    parameters: List = []\n    operations: List[Operation] = []\n\ndef create_path_item(self) -> PathItem:\n    \"\"\"\n    Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem(\n        description='A path item',\n        summary='Path item summary',\n        parameters=[],\n        operations=[\n            Operation(\n                description='Get operation',\n                responses={\n                    200: {\n                        'description': 'Successful Response'\n                    },\n                    404: {\n                        'description': 'Not found'\n                    }\n                }\n            ),\n            Operation(\n                description='Post operation',\n                responses={\n                    201: {\n                        'description': 'Created'\n                    },\n                    400: {\n                        'description': 'Bad request'\n                    }\n                }\n            )\n        ]\n    )\n    return path_item\n```", "```\nfrom fastapi import Path, HTTPException\nfrom pydantic import BaseModel\n\nclass Operation(BaseModel):\n    \"\"\"Represents an HTTP operation.\"\"\"\n    method: str\n    description: str\n\nclass PathItem(BaseModel):\n    \"\"\"Represents a path item.\"\"\"\n    summary: str\n    description: str\n    operations: list[Operation]\n\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    path_item = PathItem(\n        summary=\"Example Path Item\",\n        description=\"This is a path item.\",\n        operations=[\n            Operation(method=\"GET\", description=\"Get operation\"),\n            Operation(method=\"POST\", description=\"Post operation\"),\n            Operation(method=\"PUT\", description=\"Put operation\"),\n            Operation(method=\"DELETE\", description=\"Delete operation\"),\n        ]\n    )\n    return path_item\n```"]}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n# Natural Language Annotations: \"\"\"Create a Schema for a given FieldDefinition.\n\n        Args:\n            field_definition: A signature field instance.\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom marshmallow import Schema, fields\nfrom marshmallow_sqlalchemy import SQLAlchemySchema\n\nclass FieldDefinition:\n    def __init__(self, name: str, data_type: str):\n        self.name = name\n        self.data_type = data_type\n\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    if field_definition.data_type == 'reference':\n        return Reference(field_definition.name)\n    else:\n        return SQLAlchemySchema().load({'name': field_definition.name, 'data_type': field_definition.data_type})\n```", "```python\nfrom dataclasses import dataclass\nfrom typing import Union\n\n@dataclass\nclass Schema:\n    pass\n\nclass FieldDefinition:\n    def __init__(self, name: str, type: str):\n        self.name = name\n        self.type = type\n\ndef for_field_definition(self, field_definition: FieldDefinition) -> Union[Schema, 'Reference']:\n    if field_definition.type == 'reference':\n        return Reference(field_definition)\n    else:\n        return Schema()\n\n@dataclass\nclass Reference:\n    field_definition: FieldDefinition\n```", "```python\nfrom pydantic import BaseModel, Field\nfrom pydantic.schema import Schema\n\nclass FieldDefinition(BaseModel):\n    name: str\n    type: str\n\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    schema = Schema(\n        {\n            \"type\": \"object\",\n            \"properties\": {\n                field_definition.name: {\n                    \"type\": field_definition.type\n                }\n            }\n        }\n    )\n    return schema\n```"]}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n# Natural Language Annotations: \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\nimport { OpenAPI } from 'openapi-types';\nimport { TypeScriptNamespace } from 'typescript-namespace';\n\nfunction convertOpenapiToTypescript(openapiSchema: OpenAPI, namespace: string = \"API\"): string {\n    const typescriptNamespace = new TypeScriptNamespace(namespace);\n    for (const path in openapiSchema.paths) {\n        for (const method in openapiSchema.paths[path]) {\n            const operation = openapiSchema.paths[path][method];\n            if (operation.responses) {\n                for (const statusCode in operation.responses) {\n                    if (operation.responses[statusCode].schema) {\n                        typescriptNamespace.addType(operation.responses[statusCode].schema, `Response${statusCode}`);\n                    }\n                }\n            }\n            typescriptNamespace.addFunction(`${path}${method}`, openapiSchema.paths[path][method].tags || '');\n        }\n    }\n    return typescriptNamespace.toString();\n}\n```", "```python\nimport json\nfrom typing import Dict\n\nclass TypeScriptNamespace:\n    def __init__(self, name: str):\n        self.name = name\n        self.types = {}\n\n    def add_type(self, name: str, type: str):\n        self.types[name] = type\n\ndef convert_openapi_to_typescript(openapi_schema: Dict, namespace: str = \"API\") -> str:\n    \"\"\"\n    Convert an OpenAPI Schema instance to a TypeScript namespace.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\n    typescript_namespace = TypeScriptNamespace(namespace)\n\n    for path, path_item in openapi_schema.get(\"paths\", {}).items():\n        for method, operation in path_item.items():\n            if operation.get(\"responses\") and operation[\"responses\"].get(\"200\"):\n                response = operation[\"responses\"][\"200\"]\n                if \"content\" in response:\n                    content = response[\"content\"]\n                    for media_type, media in content.items():\n                        if \"schema\" in media:\n                            schema = media[\"schema\"]\n                            if isinstance(schema, dict):\n                                if \"type\" in schema:\n                                    type_name = f\"{path.replace('/', '_')}.{method.upper()}{media_type.replace('/', '_')}\"\n                                    typescript_namespace.add_type(type_name, schema[\"type\"])\n                                elif \"allOf\" in schema:\n                                    for item in schema[\"allOf\"]:\n                                        if \"type\" in item:\n                                            type_name = f\"{path.replace('/', '_')}.{method.upper()}{media_type.replace('/', '_')}\"\n                                            typescript_namespace.add_type(type_name, item[\"type\"])\n\n    typescript = f\"namespace {typescript_namespace.name} {{\\n\"\n    for name, type in typescript_namespace.types.items():\n        typescript += f\"    export type {name} = {type};\\n\"\n    typescript += \"}\"\n    return typescript\n```", "```python\nfrom typing import Dict, List\nfrom pydantic import BaseModel\n\nclass TypeScriptNamespace(str):\n    def __new__(cls, value: str, *args, **kwargs):\n        return super().__new__(cls, value)\n\nclass OpenAPI(BaseModel):\n    info: Dict[str, str]\n    paths: Dict[str, Dict[str, Dict[str, Dict[str, Dict[str, str]]]]]\n\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    \"\"\"\n    Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A string representing the generated types.\n    \"\"\"\n    typescript_namespace = f\"declare namespace {namespace} {\\n\"\n    for path, path_item in openapi_schema.paths.items():\n        typescript_namespace += f\"  export interface {path} {{\\n\"\n        for method, method_item in path_item.items():\n            typescript_namespace += f\"    {method}: (request: any) => Promise<{\"\n            for parameter in method_item['parameters']:\n                typescript_namespace += f\"{parameter['name']}: {parameter['schema']['type']}, \"\n            typescript_namespace = typescript_namespace.rstrip(', ') + \"};\"\n            typescript_namespace += \">\\n\"\n        typescript_namespace += \"  };\\n\"\n    typescript_namespace += \"}\"\n    return TypeScriptNamespace(typescript_namespace)\n```"]}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def write(self) -> str:\n# Natural Language Annotations: \"\"\"Write a typescript interface object, without a name.\n\n        Example:\n            {\n                key: string;\n                optional?: number;\n            }\n\n        Returns:\n            A typescript string\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```typescript\ndef write(self) -> str:\n    \"\"\"\n    Write a typescript interface object, without a name.\n\n    Example:\n        {\n            key: string;\n            optional?: number;\n        }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    return \"{key: string; optional?: number;}\"\n```", "```typescript\ndef write(self) -> str:\n    \"\"\"\n    Write a typescript interface object, without a name.\n\n    Example:\n        {\n            key: string;\n            optional?: number;\n        }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    return '{\\n  key: string;\\n  optional?: number;\\n}'\n```", "```typescript\ndef write(self) -> str:\n    \"\"\"\n    Write a typescript interface object, without a name.\n\n    Example:\n        {\n            key: string;\n            optional?: number;\n        }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    return '{\\n    key: string;\\n    optional?: number;\\n}'\n```"]}, "litestar-litestar/testing/helpers.py-create_test_client": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_test_client(\n# Natural Language Annotations: \"\"\"Create a Litestar app instance and initializes it.\n\n    :class:`TestClient <litestar.testing.TestClient>` with it.\n\n    Notes:\n        - This function should be called as a context manager to ensure async startup and shutdown are\n            handled correctly.\n\n    Examples:\n        .. code-block:: python\n\n            from litestar import get\n            from litestar.testing import create_test_client\n\n\n            @get(\"/some-path\")\n            def my_handler() -> dict[str, str]:\n                return {\"hello\": \"world\"}\n\n\n            def test_my_handler() -> None:\n                with create_test_client(my_handler) as client:\n                    response = client.get(\"/some-path\")\n                    assert response.json() == {\"hello\": \"world\"}\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            :class:`Router <litestar.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or\n            any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: ``anyio`` options.\n        base_url: URL scheme and domain for test request paths, e.g. ``http://testserver``.\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of :class:`exception hook handlers <.types.AfterExceptionHookHandler>`. This\n            hook is called after an exception occurs. In difference to exception handlers, it is not meant to\n            return a response - only to process the exception (e.g. log it, send it to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response\n            object has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the\n            :class:`Request <.connection.Request>` object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an\n            :class:`AllowedHostsConfig <.config.allowed_hosts.AllowedHostsConfig>` instance. Enables the builtin\n            allowed hosts middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the\n            :class:`Request <.connection.Request>` instance and any non-``None`` return value is used for the\n            response, bypassing the route handler.\n        before_send: A sequence of :class:`before send hook handlers <.types.BeforeMessageSendHookHandler>`. Called\n            when the ASGI send function is called.\n        cache_control: A ``cache-control`` header of type\n            :class:`CacheControlHeader <litestar.datastructures.CacheControlHeader>` to add to route handlers of\n            this app. Can be overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user\n            defined Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures :class:`CSRFMiddleware <.middleware.csrf.CSRFMiddleware>`.\n        debug: If ``True``, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency :class:`Providers <.di.Provide>`.\n        dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for (de)serializing and\n            validation of request data.\n        etag: An ``etag`` header of type :class:`ETag <.datastructures.ETag>` to add to route handlers of this app.\n            Can be overridden by route handlers.\n        event_emitter_backend: A subclass of\n            :class:`BaseEventEmitterBackend <.events.emitter.BaseEventEmitterBackend>`.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of :class:`Guard <.types.Guard>` callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of :class:`EventListener <.events.listener.EventListener>`.\n        logging_config: A subclass of :class:`BaseLoggingConfig <.logging.config.BaseLoggingConfig>`.\n        middleware: A sequence of :class:`Middleware <.types.Middleware>`.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit\n            is intended to protect from DoS attacks.\n        on_app_init: A sequence of :class:`OnAppInitHandler <.types.OnAppInitHandler>` instances. Handlers receive\n            an instance of :class:`AppConfig <.config.app.AppConfig>` that will have been initially populated with\n            the parameters passed to :class:`Litestar <litestar.app.Litestar>`, and must return an instance of same.\n            If more than one handler is registered they are called in the order they are provided.\n        on_shutdown: A sequence of :class:`LifespanHook <.types.LifespanHook>` called during application\n            shutdown.\n        on_startup: A sequence of :class:`LifespanHook <litestar.types.LifespanHook>` called during\n            application startup.\n        openapi_config: Defaults to :attr:`DEFAULT_OPENAPI_CONFIG`\n        opt: A string keyed mapping of arbitrary values that can be accessed in :class:`Guards <.types.Guard>` or\n            wherever you have access to :class:`Request <litestar.connection.request.Request>` or\n            :class:`ASGI Scope <.types.Scope>`.\n        parameters: A mapping of :class:`Parameter <.params.Parameter>` definitions available to all application\n            paths.\n        path: A path fragment that is prefixed to all route handlers, controllers and routers associated\n            with the application instance.\n\n            .. versionadded:: 2.8.0\n        pdb_on_exception: Drop into the PDB when an exception occurs.\n        plugins: Sequence of plugins.\n        request_class: An optional subclass of :class:`Request <.connection.Request>` to use for http connections.\n        response_class: A custom subclass of :class:`Response <.response.Response>` to be used as the app's default\n            response.\n        response_cookies: A sequence of :class:`Cookie <.datastructures.Cookie>`.\n        response_headers: A string keyed mapping of :class:`ResponseHeader <.datastructures.ResponseHeader>`\n        response_cache_config: Configures caching behavior of the application.\n        return_dto: :class:`AbstractDTO <.dto.base_dto.AbstractDTO>` to use for serializing\n            outbound response data.\n        route_handlers: A sequence of route handlers, which can include instances of\n            :class:`Router <.router.Router>`, subclasses of :class:`Controller <.controller.Controller>` or any\n            callable decorated by the route handler decorators.\n        security: A sequence of dicts that will be added to the schema of all route handlers in the application.\n            See\n            :data:`SecurityRequirement <.openapi.spec.SecurityRequirement>` for details.\n        signature_namespace: A mapping of names to types for use in forward reference resolution during signature modeling.\n        signature_types: A sequence of types for use in forward reference resolution during signature modeling.\n            These types will be added to the signature namespace using their ``__name__`` attribute.\n        state: An optional :class:`State <.datastructures.State>` for application state.\n        static_files_config: A sequence of :class:`StaticFilesConfig <.static_files.StaticFilesConfig>`\n        stores: Central registry of :class:`Store <.stores.base.Store>` that will be available throughout the\n            application. If this is a dictionary to it will be passed to a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`. If it is a\n            :class:`StoreRegistry <.stores.registry.StoreRegistry>`, this instance will be used directly.\n        tags: A sequence of string tags that will be appended to the schema of all route handlers under the\n            application.\n        template_config: An instance of :class:`TemplateConfig <.template.TemplateConfig>`\n        timeout: Request timeout\n        type_encoders: A mapping of types to callables that transform them into types supported for serialization.\n        websocket_class: An optional subclass of :class:`WebSocket <.connection.WebSocket>` to use for websocket\n            connections.\n        experimental_features: An iterable of experimental features to enable\n\n\n    Returns:\n        An instance of :class:`TestClient <.testing.TestClient>` with a created app instance.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom litestar import get\nfrom litestar.app import Litestar\nfrom litestar.testing import TestClient\nfrom litestar.testing import create_lifespan\nfrom typing import Any, Union\n\nasync def create_test_client(\n    route_handlers: Any,\n    backend: str = \"asyncio\",\n    backend_options: Any = None,\n    base_url: str = \"http://testserver\",\n    raise_server_exceptions: bool = False,\n    root_path: str = \"\",\n    session_config: Any = None,\n    after_exception: Any = None,\n    after_request: Any = None,\n    after_response: Any = None,\n    allowed_hosts: Any = None,\n    before_request: Any = None,\n    before_send: Any = None,\n    cache_control: Any = None,\n    compression_config: Any = None,\n    cors_config: Any = None,\n    csrf_config: Any = None,\n    debug: bool = False,\n    dependencies: Any = None,\n    dto: Any = None,\n    etag: Any = None,\n    event_emitter_backend: Any = None,\n    exception_handlers: Any = None,\n    guards: Any = None,\n    include_in_schema: bool = True,\n    lifespan: Any = None,\n    listeners: Any = None,\n    logging_config: Any = None,\n    middleware: Any = None,\n    multipart_form_part_limit: int = 100,\n    on_app_init: Any = None,\n    on_shutdown: Any = None,\n    on_startup: Any = None,\n    openapi_config: Any = None,\n    opt: Any = None,\n    parameters: Any = None,\n    path: str = \"\",\n    pdb_on_exception: bool = False,\n    plugins: Any = None,\n    request_class: Any = None,\n    response_class: Any = None,\n    response_cookies: Any = None,\n    response_headers: Any = None,\n    response_cache_config: Any = None,\n    return_dto: Any = None,\n    security: Any = None,\n    signature_namespace: Any = None,\n    signature_types: Any = None,\n    state: Any = None,\n    static_files_config: Any = None,\n    stores: Any = None,\n    tags: Any = None,\n    template_config: Any = None,\n    timeout: int = 30,\n    type_encoders: Any = None,\n    websocket_class: Any = None,\n    experimental_features: Any = None,\n) -> TestClient:\n    app = Litestar(\n        route_handlers,\n        backend,\n        backend_options,\n        base_url,\n        raise_server_exceptions,\n        root_path,\n        session_config,\n        after_exception,\n        after_request,\n        after_response,\n        allowed_hosts,\n        before_request,\n        before_send,\n        cache_control,\n        compression_config,\n        cors_config,\n        csrf_config,\n        debug,\n        dependencies,\n        dto,\n        etag,\n        event_emitter_backend,\n        exception_handlers,\n        guards,\n        include_in_schema,\n        lifespan,\n        listeners,\n        logging_config,\n        middleware,\n        multipart_form_part_limit,\n        on_app_init,\n        on_shutdown,\n        on_startup,\n        openapi_config,\n        opt,\n        parameters,\n        path,\n        pdb_on_exception,\n        plugins,\n        request_class,\n        response_class,\n        response_cookies,\n        response_headers,\n        response_cache_config,\n        return_dto,\n        security,\n        signature_namespace,\n        signature_types,\n        state,\n        static_files_config,\n        stores,\n        tags,\n        template_config,\n        timeout,\n        type_encoders,\n        websocket_class,\n        experimental_features,\n    )\n    return TestClient(app, lifespan=create_lifespan(app))\n```", "```python\nimport asyncio\nfrom litestar import Litestar, get\nfrom litestar.testing import TestClient\n\nasync def create_test_client(\n    route_handlers,\n    backend=\"asyncio\",\n    backend_options=None,\n    base_url=\"http://testserver\",\n    raise_server_exceptions=False,\n    root_path=\"\",\n    session_config=None,\n    after_exception=None,\n    after_request=None,\n    after_response=None,\n    allowed_hosts=None,\n    before_request=None,\n    before_send=None,\n    cache_control=None,\n    compression_config=None,\n    cors_config=None,\n    csrf_config=None,\n    debug=False,\n    dependencies=None,\n    dto=None,\n    etag=None,\n    event_emitter_backend=None,\n    exception_handlers=None,\n    guards=None,\n    include_in_schema=True,\n    lifespan=None,\n    listeners=None,\n    logging_config=None,\n    middleware=None,\n    multipart_form_part_limit=100,\n    on_app_init=None,\n    on_shutdown=None,\n    on_startup=None,\n    openapi_config=None,\n    opt=None,\n    parameters=None,\n    path=\"\",\n    pdb_on_exception=False,\n    plugins=None,\n    request_class=None,\n    response_class=None,\n    response_cookies=None,\n    response_headers=None,\n    response_cache_config=None,\n    return_dto=None,\n    security=None,\n    signature_namespace=None,\n    signature_types=None,\n    state=None,\n    static_files_config=None,\n    stores=None,\n    tags=None,\n    template_config=None,\n    timeout=None,\n    type_encoders=None,\n    websocket_class=None,\n    experimental_features=None,\n) -> TestClient:\n    \"\"\"Create a Litestar app instance and initializes it.\n\n    This function should be called as a context manager to ensure async startup and shutdown are\n    handled correctly.\n\n    Args:\n        route_handlers: A single handler or a sequence of route handlers, which can include instances of\n            Router, subclasses of Controller or any function decorated by the route handler decorators.\n        backend: The async backend to use, options are \"asyncio\" or \"trio\".\n        backend_options: anyio options.\n        base_url: URL scheme and domain for test request paths, e.g. \"http://testserver\".\n        raise_server_exceptions: Flag for underlying the test client to raise server exceptions instead of wrapping them\n            in an HTTP response.\n        root_path: Path prefix for requests.\n        session_config: Configuration for Session Middleware class to create raw session cookies for request to the\n            route handlers.\n        after_exception: A sequence of exception hook handlers. This hook is called after an exception occurs. In difference\n            to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it\n            to Sentry etc.).\n        after_request: A sync or async function executed after the route handler function returned and the response object\n            has been resolved. Receives the response object.\n        after_response: A sync or async function called after the response has been awaited. It receives the Request\n            object and should not return any values.\n        allowed_hosts: A sequence of allowed hosts, or an AllowedHostsConfig instance. Enables the builtin allowed hosts\n            middleware.\n        before_request: A sync or async function called immediately before calling the route handler. Receives the Request\n            instance and any non-None return value is used for the response, bypassing the route handler.\n        before_send: A sequence of before send hook handlers. Called when the ASGI send function is called.\n        cache_control: A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be\n            overridden by route handlers.\n        compression_config: Configures compression behaviour of the application, this enabled a builtin or user defined\n            Compression middleware.\n        cors_config: If set, configures CORS handling for the application.\n        csrf_config: If set, configures CSRFMiddleware.\n        debug: If True, app errors rendered as HTML with a stack trace.\n        dependencies: A string keyed mapping of dependency Providers.\n        dto: AbstractDTO to use for (de)serializing and validation of request data.\n        etag: An etag header of type ETag to add to route handlers of this app. Can be overridden by route handlers.\n        event_emitter_backend: A subclass of BaseEventEmitterBackend.\n        exception_handlers: A mapping of status codes and/or exception types to handler functions.\n        guards: A sequence of Guard callables.\n        include_in_schema: A boolean flag dictating whether  the route handler should be documented in the OpenAPI schema.\n        lifespan: A list of callables returning async context managers, wrapping the lifespan of the ASGI application\n        listeners: A sequence of EventListener.\n        logging_config: A subclass of BaseLoggingConfig.\n        middleware: A sequence of Middleware.\n        multipart_form_part_limit: The maximal number of allowed parts in a multipart/formdata request. This limit is\n            intended to protect from DoS attacks.\n        on_app_init: A", "```python\nfrom litestar import get\nfrom litestar.app import Litestar\nfrom litestar.testing import TestClient\nfrom litestar.types import Scope\nfrom litestar.datastructures import CacheControlHeader\nfrom litestar.exceptions import HTTPException\nfrom litestar.middleware import Middleware\nfrom litestar.middleware.csrf import CSRFMiddleware\nfrom litestar.middleware.logging import LoggingMiddleware\nfrom litestar.middleware.security import SecurityMiddleware\nfrom litestar.middleware.heartbeat import HeartbeatMiddleware\nfrom litestar.middleware.response_cookies import ResponseCookiesMiddleware\nfrom litestar.middleware.response_headers import ResponseHeadersMiddleware\nfrom litestar.middleware.session import SessionMiddleware\nfrom litestar.middleware.static_files import StaticFilesMiddleware\nfrom litestar.middleware.tracing import TracingMiddleware\nfrom litestar.middleware.cors import CORSMiddleware\nfrom litestar.middleware.compression import CompressionMiddleware\nfrom litestar.middleware.etag import ETagMiddleware\nfrom litestar.middleware.auth import AuthMiddleware\nfrom litestar.middleware.jwt import JWTMiddleware\nfrom litestar.middleware.websocket import WebSocketMiddleware\nfrom litestar.middleware.allowed_hosts import AllowedHostsMiddleware\nfrom litestar.middleware.heartbeat import HeartbeatMiddleware\nfrom litestar.middleware.logging import LoggingMiddleware\nfrom litestar.middleware.csrf import CSRFMiddleware\nfrom litestar.middleware.security import SecurityMiddleware\nfrom litestar.middleware.tracing import TracingMiddleware\nfrom litestar.middleware.cors import CORSMiddleware\nfrom litestar.middleware.compression import CompressionMiddleware\nfrom litestar.middleware.etag import ETagMiddleware\nfrom litestar.middleware.auth import AuthMiddleware\nfrom litestar.middleware.jwt import JWTMiddleware\nfrom litestar.middleware.websocket import WebSocketMiddleware\nfrom litestar.middleware.allowed_hosts import AllowedHostsMiddleware\nfrom litestar.middleware.heartbeat import HeartbeatMiddleware\nfrom litestar.middleware.logging import LoggingMiddleware\nfrom litestar.middleware.csrf import CSRFMiddleware\nfrom litestar.middleware.security import SecurityMiddleware\nfrom litestar.middleware.tracing import TracingMiddleware\nfrom litestar.middleware.cors import CORSMiddleware\nfrom litestar.middleware.compression import CompressionMiddleware\nfrom litestar.middleware.etag import ETagMiddleware\nfrom litestar.middleware.auth import AuthMiddleware\nfrom litestar.middleware.jwt import JWTMiddleware\nfrom litestar.middleware.websocket import WebSocketMiddleware\nfrom litestar.middleware.allowed_hosts import AllowedHostsMiddleware\n\nclass TestClientManager:\n    def __init__(\n        self,\n        route_handlers,\n        backend=\"asyncio\",\n        backend_options=None,\n        base_url=\"http://testserver\",\n        raise_server_exceptions=False,\n        root_path=\"\",\n        session_config=None,\n        after_exception=None,\n        after_request=None,\n        after_response=None,\n        allowed_hosts=None,\n        before_request=None,\n        before_send=None,\n        cache_control=None,\n        compression_config=None,\n        cors_config=None,\n        csrf_config=None,\n        debug=False,\n        dependencies=None,\n        dto=None,\n        etag=None,\n        event_emitter_backend=None,\n        exception_handlers=None,\n        guards=None,\n        include_in_schema=True,\n        lifespan=None,\n        listeners=None,\n        logging_config=None,\n        middleware=None,\n        multipart_form_part_limit=None,\n        on_app_init=None,\n        on_shutdown=None,\n        on_startup=None,\n        openapi_config=None,\n        opt=None,\n        parameters=None,\n        path=\"\",\n        pdb_on_exception=False,\n        plugins=None,\n        request_class=None,\n        response_class=None,\n        response_cookies=None,\n        response_headers=None,\n        response_cache_config=None,\n        return_dto=None,\n        security=None,\n        signature_namespace=None,\n        signature_types=None,\n        state=None,\n        static_files_config=None,\n        stores=None,\n        tags=None,\n        template_config=None,\n        timeout=None,\n        type_encoders=None,\n        websocket_class=None,\n        experimental_features=None,\n    ):\n        self.app = Litestar(\n            route_handlers=route_handlers,\n            backend=backend,\n            backend_options=backend_options,\n            base_url=base_url,\n            raise_server_exceptions=raise_server_exceptions,\n            root_path=root_path,\n            session_config=session_config,\n            after_exception=after_exception,\n            after_request=after_request,\n            after_response=after_response,\n            allowed_hosts=allowed_hosts,\n            before_request=before_request,\n            before_send=before_send,\n            cache_control=cache_control,\n            compression_config=compression_config,\n            cors_config=cors_config,\n            csrf_config=csrf_config,\n            debug=debug,\n            dependencies=dependencies,\n            dto=dto,\n            etag=etag,\n            event_emitter_backend=event_emitter_backend,\n            exception_handlers=exception_handlers,\n            guards=guards,\n            include_in_schema=include_in_schema,\n            lifespan=lifespan,\n            listeners=listeners,\n            logging_config=logging_config,\n            middleware=middleware,\n            multipart_form_part_limit=multipart_form_part_limit,\n            on_app_init=on_app_init,\n            on_shutdown=on_shutdown,\n            on_startup=on_startup,\n            openapi_config=openapi_config,\n            opt=opt,\n            parameters=parameters,\n            path=path,\n            pdb_on_exception=pdb_on_exception,\n            plugins=plugins"]}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def websocket_connect(\n# Natural Language Annotations: \"\"\"Sends a GET request to establish a websocket connection.\n\n        Args:\n            url: Request URL.\n            subprotocols: Websocket subprotocols.\n            params: Query parameters.\n            headers: Request headers.\n            cookies: Request cookies.\n            auth: Auth headers.\n            follow_redirects: Whether to follow redirects.\n            timeout: Request timeout.\n            extensions: Dictionary of ASGI extensions.\n\n        Returns:\n            A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom litestar.testing import WebSocketTestSession\nfrom aiohttp import ClientSession\nfrom aiohttp.client_exceptions import ClientResponseError\nfrom typing import Dict, List, Optional\n\nasync def websocket_connect(\n    url: str,\n    subprotocols: Optional[List[str]] = None,\n    params: Dict[str, str] = None,\n    headers: Dict[str, str] = None,\n    cookies: Dict[str, str] = None,\n    auth: Dict[str, str] = None,\n    follow_redirects: bool = True,\n    timeout: float = 10.0,\n    extensions: Dict[str, str] = None\n) -> WebSocketTestSession:\n    \"\"\"\n    Sends a GET request to establish a websocket connection.\n    \n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n    \n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    async with ClientSession() as session:\n        try:\n            async with session.ws_connect(\n                url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                auth=auth,\n                follow_redirects=follow_redirects,\n                timeout=timeout,\n                ssl=True,\n                auto_connect=False,\n                auto_upgrade=True,\n                heartbeat=10,\n                max_msg_size=10 ** 8,\n                max_queue=10,\n                extensions=extensions\n            ) as ws:\n                return WebSocketTestSession(ws)\n        except ClientResponseError as e:\n            raise Exception(f\"Failed to establish websocket connection: {e}\")\n```", "```python\nimport websocket\nimport requests\nfrom litestar.testing import WebSocketTestSession\n\ndef websocket_connect(\n    url: str,\n    subprotocols: list[str] = None,\n    params: dict[str, str] = None,\n    headers: dict[str, str] = None,\n    cookies: dict[str, str] = None,\n    auth: tuple[str, str] = None,\n    follow_redirects: bool = False,\n    timeout: float = 10,\n    extensions: dict[str, str] = None,\n):\n    ws = websocket.create_connection(\n        url,\n        http_proxy_host=None,\n        http_proxy_port=None,\n        https_proxy_host=None,\n        https_proxy_port=None,\n        socket_options=None,\n        subprotocols=subprotocols,\n        headers=headers,\n        origin=None,\n        class_=None,\n        infolayer=None,\n        extensions=extensions,\n    )\n    return WebSocketTestSession(ws)\n```", "```python\nimport websocket\nimport requests\nfrom litestar.testing import WebSocketTestSession\n\ndef websocket_connect(\n    url: str,\n    subprotocols: list[str] = None,\n    params: dict[str, str] = None,\n    headers: dict[str, str] = None,\n    cookies: dict[str, str] = None,\n    auth: tuple[str, str] = None,\n    follow_redirects: bool = True,\n    timeout: float = 5.0,\n    extensions: dict[str, str] = None\n) -> WebSocketTestSession:\n    \"\"\"\n    Sends a GET request to establish a websocket connection.\n\n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n\n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    ws = websocket.create_connection(\n        url,\n        header=headers,\n        cookie=cookies,\n        http_proxy_host=None,\n        http_proxy_port=None,\n        http_proxy_auth=None,\n        origin=None,\n        subprotocols=subprotocols,\n        extensions=extensions,\n        timeout=timeout,\n    )\n    return WebSocketTestSession(ws)\n```"]}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n# Natural Language Annotations: \"\"\"Create a schema object for a given pydantic model class.\n\n        Args:\n            field_definition: FieldDefinition instance.\n            schema_creator: An instance of the schema creator class\n\n        Returns:\n            A schema instance.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom pydantic import BaseModel\nfrom typing import Type, TypeVar\nfrom pydantic.fields import FieldDefinition\nfrom schema import Schema, SchemaCreator\n\nT = TypeVar('T', bound=BaseModel)\n\ndef for_pydantic_model(cls: Type[T], field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    \"\"\"\n    Create a schema object for a given pydantic model class.\n\n    Args:\n        cls: The pydantic model class.\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    return schema_creator.create_schema(cls, field_definition)\n```", "```python\nfrom pydantic import BaseModel\nfrom typing import Type, Any\n\nclass FieldDefinition:\n    pass\n\nclass SchemaCreator:\n    def create_schema(self, field_definition: FieldDefinition) -> Any:\n        pass\n\nclass Schema:\n    pass\n\ndef for_pydantic_model(cls: Type[BaseModel], field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    \"\"\"\n    Create a schema object for a given pydantic model class.\n\n    Args:\n        cls: A pydantic model class.\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    return schema_creator.create_schema(field_definition)\n```", "```\nfrom pydantic import BaseModel\nfrom typing import Any\n\nclass FieldDefinition:\n    def __init__(self, name: str, type: type, default: Any = None):\n        self.name = name\n        self.type = type\n        self.default = default\n\nclass SchemaCreator:\n    def create_schema(self, field_definition: FieldDefinition) -> Any:\n        raise NotImplementedError\n\nclass Schema:\n    def __init__(self, field_definitions: list):\n        self.field_definitions = field_definitions\n\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:\n    \"\"\"\n    Create a schema object for a given pydantic model class.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    schema = schema_creator.create_schema(field_definition)\n    return Schema([schema])\n```"]}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def cleanup(self) -> None:\n# Natural Language Annotations: \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n        If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def cleanup(self) -> None:\n    \"\"\"\n    Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    generators = [gen for gen in self.generators if gen]\n    if not generators:\n        return\n\n    task_group = anyio.TaskGroup()\n    for gen in generators:\n        task_group.start_soon(gen.__anext__)\n    await task_group.join()\n```", "```python\nimport anyio\n\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    generators = [gen for gen in self.generators if gen is not None]\n    if generators:\n        await anyio.to_thread.run_sync(lambda: anyio.create_task_group(g for g in generators).cancel_scope.cancel())\n```", "```python\nasync def cleanup(self) -> None:\n    \"\"\"\n    Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    tasks = []\n    for gen in self.generators:\n        if not gen.sentinel.done:\n            if gen.a_sentinel is not None:\n                task = anyio.to_thread.run_sync(gen.anext)\n            else:\n                task = anyio.to_thread.run_sync(next, gen)\n            tasks.append(task)\n    if tasks:\n        await anyio.to_thread.run_sync(asyncio.gather, *tasks)\n```"]}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_route_middleware_stack(\n# Natural Language Annotations: \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom litestar import Litestar, ASGIApp\n\ndef build_route_middleware_stack(app: Litestar, route: str, route_handler):\n    def middleware_stack(environ, receive, send):\n        # Add route middleware here\n        # For example, you can add a logger middleware\n        print(f\"Handling route: {route}\")\n        \n        # Call the next middleware in the stack\n        return route_handler(environ, receive, send)\n\n    return middleware_stack\n```", "```python\nfrom litestar import ASGIApp, Route\n\ndef build_route_middleware_stack(app: ASGIApp, route: Route, route_handler):\n    def middleware_stack():\n        async def _middleware_stack(scope, receive, send):\n            try:\n                await route_handler(scope, receive, send)\n            except Exception as e:\n                await send({\"type\": \"http.response.start\", \"status\": 500}, None)\n                await send({\"type\": \"http.response.body\", \"body\": str(e).encode()})\n        return _middleware_stack\n    return middleware_stack\n```", "```python\nfrom litestar import Litestar, ASGIApp\n\ndef build_route_middleware_stack(\n    app: Litestar, route: str, route_handler: callable\n) -> ASGIApp:\n    \"\"\"\n    Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\n    def middleware_stack(app: ASGIApp, receive: callable, send: callable, close: callable) -> None:\n        # YOUR CUSTOM MIDDLEWARE LOGIC HERE\n        # For example, you can add a middleware that logs the route being accessed\n        print(f\"Route {route} accessed\")\n\n        # Call the next middleware in the stack\n        return app(receive, send, close)\n\n    return middleware_stack\n```"]}, "litestar-litestar/utils/signature.py-from_fn": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n# Natural Language Annotations: \"\"\"Parse a function signature.\n\n        Args:\n            fn: Any callable.\n            signature_namespace: mapping of names to types for forward reference resolution\n\n        Returns:\n            ParsedSignature\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Callable, Dict, TypeVar\n\nT = TypeVar('T')  # type: ignore\n\nclass ParsedSignature:\n    def __init__(self, name: str, args: list, return_type: T):\n        self.name = name\n        self.args = args\n        self.return_type = return_type\n\ndef from_fn(cls, fn: Callable, signature_namespace: Dict[str, Any]) -> 'ParsedSignature':\n    import inspect\n    from functools import wraps\n    from typing import get_origin, get_args\n\n    def resolve_forward_references(arg: str) -> Any:\n        return signature_namespace.get(arg, arg)\n\n    signature = inspect.signature(fn)\n    name = fn.__name__\n    args = []\n    for param in signature.parameters.values():\n        if param.kind == param.POSITIONAL_ONLY or param.kind == param.KEYWORD_ONLY:\n            arg_name = param.name\n            arg_type = get_origin(param.annotation)\n            arg_type_args = get_args(param.annotation)\n            if arg_type_args:\n                arg_type = arg_type if arg_type else Any\n                arg_type = arg_type(*arg_type_args)\n            arg = resolve_forward_references(arg_name)\n            args.append((arg_name, arg_type))\n    return_type = get_origin(fn.__annotations__.get('return'))\n    if return_type:\n        return_type = return_type if return_type else Any\n        return_type = return_type(*get_args(return_type))\n    return ParsedSignature(name, args, return_type)\n```", "```python\nfrom typing import Any, Callable, Dict\n\nclass ParsedSignature:\n    def __init__(self, name: str, parameters: Dict[str, 'ParsedSignatureParameter'], return_type: 'ParsedSignatureType'):\n        self.name = name\n        self.parameters = parameters\n        self.return_type = return_type\n\nclass ParsedSignatureParameter:\n    def __init__(self, name: str, type: 'ParsedSignatureType'):\n        self.name = name\n        self.type = type\n\nclass ParsedSignatureType:\n    def __init__(self, name: str, forward_reference: bool = False):\n        self.name = name\n        self.forward_reference = forward_reference\n\ndef from_fn(cls, fn: Callable, signature_namespace: Dict[str, Any]) -> 'ParsedSignature':\n    import inspect\n    import ast\n\n    # Parse the function's source code\n    tree = ast.parse(inspect.getsource(fn))\n\n    # Extract the function definition\n    func_def = tree.body[0]\n\n    # Extract the function's name\n    name = func_def.name\n\n    # Extract the function's parameters\n    parameters = []\n    for param in func_def.args.args:\n        param_name = param.arg\n        param_type = ParsedSignatureType(param.annotation.id)\n        if param.annotation.id in signature_namespace:\n            param_type.forward_reference = True\n        parameters.append(ParsedSignatureParameter(param_name, param_type))\n\n    # Extract the function's return type\n    return_type = ParsedSignatureType(func_def.returns.id)\n    if func_def.returns.id in signature_namespace:\n        return_type.forward_reference = True\n\n    # Create a ParsedSignature object\n    parsed_signature = ParsedSignature(name, parameters, return_type)\n\n    return parsed_signature\n```", "```python\nfrom typing import Any, Callable, Dict\n\nclass ParsedSignature:\n    def __init__(self, name: str, parameters: Dict[str, Any], return_type: Any):\n        self.name = name\n        self.parameters = parameters\n        self.return_type = return_type\n\ndef from_fn(cls, fn: Callable, signature_namespace: Dict[str, Any]) -> 'ParsedSignature':\n    import inspect\n    import ast\n    import typing\n    \n    # Get the function signature from the function\n    sig = inspect.signature(fn)\n    \n    # Parse the function signature into an abstract syntax tree\n    tree = ast.parse(inspect.getsource(fn))\n    \n    # Get the function node from the abstract syntax tree\n    func_node = tree.body[0]\n    \n    # Get the function name as a string\n    name = func_node.name\n    \n    # Get the parameter names and types from the function signature\n    params = sig.parameters\n    \n    # Get the return type from the function signature\n    return_type = typing.get_origin(sig.return_annotation)\n    \n    # Resolve forward references in the return type\n    if return_type is typing.ForwardRef:\n        return_type = signature_namespace[return_type.__forward_arg__]\n    \n    # Create and return a ParsedSignature object\n    return ParsedSignature(name, params, return_type)\n```"]}, "litestar-litestar/utils/deprecation.py-deprecated": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def deprecated(\n# Natural Language Annotations: \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport warnings\nimport inspect\n\ndef deprecated(\n    version,\n    removal_in,\n    alternative,\n    info,\n    pending=False,\n    kind=None\n):\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            warning_message = f\"{func.__name__} is deprecated and will be removed in Litestar {removal_in}. Please use {alternative} instead. {info}\"\n            if pending:\n                warnings.warn(warning_message, PendingDeprecationWarning, stacklevel=2)\n            else:\n                warnings.warn(warning_message, DeprecationWarning, stacklevel=2)\n            return func(*args, **kwargs)\n        return wrapper\n\n    if kind is None:\n        if inspect.isfunction(func):\n            kind = 'function'\n        elif inspect.ismethod(func):\n            kind = 'method'\n        else:\n            raise ValueError(\"kind must be a function or method\")\n\n    if kind == 'function':\n        return decorator(func)\n    elif kind == 'method':\n        return classmethod(decorator(func))\n    else:\n        raise ValueError(\"kind must be a function or method\")\n```", "```python\nimport warnings\nimport inspect\nfrom functools import wraps\n\ndef deprecated(version, removal_in, alternative, info, pending=False, kind=None):\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            warning_message = f\"{func.__name__} is deprecated since Litestar {version} and will be removed in Litestar {removal_in}. Please use {alternative} instead. {info}\"\n            if pending:\n                warnings.warn(warning_message, PendingDeprecationWarning, stacklevel=2)\n            else:\n                warnings.warn(warning_message, DeprecationWarning, stacklevel=2)\n            return func(*args, **kwargs)\n        return wrapper\n    if kind is None:\n        return decorator\n    elif inspect.isfunction(func) or inspect.ismethod(func):\n        return decorator(func)\n    else:\n        raise TypeError(f\"{func} is not a function or method\")\n```", "```python\nimport warnings\nimport inspect\nimport functools\n\ndef deprecated(version, removal_in, alternative, info, pending=False, kind=None):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args, **kwargs):\n            warning_message = f\"{func.__name__} is deprecated since Litestar {version}. It will be removed in Litestar {removal_in}. Please use {alternative} instead. {info}\"\n            if pending:\n                warnings.warn(warning_message, PendingDeprecationWarning, stacklevel=2)\n            else:\n                warnings.warn(warning_message, DeprecationWarning, stacklevel=2)\n            return func(*args, **kwargs)\n        return wrapper\n    if kind is None:\n        return decorator\n    elif kind == 'function':\n        return decorator\n    elif kind == 'method':\n        return class_decorator(decorator)\n    else:\n        raise ValueError(\"Invalid kind. It should be 'function' or 'method'\")\n\nclass class_decorator:\n    def __init__(self, decorator):\n        self.decorator = decorator\n\n    def __call__(self, cls):\n        for name in dir(cls):\n            if inspect.isfunction(getattr(cls, name)):\n                setattr(cls, name, self.decorator(getattr(cls, name)))\n        return cls\n```"]}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n# Natural Language Annotations: \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Callable, Awaitable, ParamSpec\n\nP = ParamSpec('P')\nT = type('T', (), {})\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"\n    Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```", "```\nfrom typing import Callable, Awaitable, ParamSpec\n\nP = ParamSpec('P')\nT = type('T', (), {})\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```", "```python\nfrom typing import Callable, Awaitable, ParamSpec\n\nP = ParamSpec('P')\nT = type('T', (), {})\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"\n    Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an ``AsyncCallable``\n    \"\"\"\n    if asyncio.iscoroutinefunction(fn):\n        return fn\n    else:\n        return AsyncCallable(fn)\n```"]}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n# Natural Language Annotations: \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Dict, TypeVar, get_type_hints\n\ndef expand_type_var_in_type_hint(type_hint: Dict[str, Any], namespace: Dict[str, Any] | None) -> Dict[str, Any]:\n    \"\"\"\n    Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\n    if namespace is None:\n        namespace = {}\n\n    def expand_type(type):\n        if isinstance(type, type):\n            return type\n        elif isinstance(type, str) and type.startswith('typing.'):\n            # Check if type is TypeVar\n            if type == 'typing.TypeVar':\n                # Extract the name of the TypeVar\n                name = type.split('.')[-1].split('(')[0]\n                # Replace TypeVar with the concrete type from the namespace\n                return namespace.get(name, type)\n            else:\n                # Recursively expand the type\n                return {k: expand_type(v) for k, v in get_type_hints(type).items()}\n        else:\n            return type\n\n    return {k: expand_type(v) for k, v in type_hint.items()}\n```", "```python\nfrom typing import Any, Dict, Optional\n\ndef expand_type_var_in_type_hint(type_hint: Dict[str, Any], namespace: Dict[str, Any] | None) -> Dict[str, Any]:\n    \"\"\"\n    Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\n    if namespace is None:\n        return type_hint\n    \n    expanded_type_hint = {}\n    for param, type_ in type_hint.items():\n        if isinstance(type_, str) and type_ in namespace:\n            expanded_type_hint[param] = namespace[type_]\n        elif isinstance(type_, dict):\n            expanded_type_hint[param] = expand_type_var_in_type_hint(type_, namespace)\n        else:\n            expanded_type_hint[param] = type_\n    \n    return expanded_type_hint\n```", "```python\nfrom typing import Any, Dict\n\ndef expand_type_var_in_type_hint(type_hint: Dict[str, Any], namespace: Dict[str, Any] | None) -> Dict[str, Any]:\n    if namespace is None:\n        return type_hint\n\n    expanded_type_hint = {}\n    for param, param_type in type_hint.items():\n        if isinstance(param_type, str) and param_type.startswith('TypeVar('):\n            var_name = param_type[7:-1]  # remove 'TypeVar(' and ')'\n            concrete_type = namespace.get(var_name)\n            if concrete_type is not None:\n                expanded_type_hint[param] = concrete_type\n            else:\n                expanded_type_hint[param] = param_type\n        else:\n            expanded_type_hint[param] = param_type\n\n    return expanded_type_hint\n```"]}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def simple_asdict(\n# Natural Language Annotations: \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom dataclasses import asdict, fields\n\ndef simple_asdict(\n    obj,\n    exclude_none=False,\n    exclude_empty=False,\n    convert_nested=False,\n    exclude=None,\n):\n    \"\"\"\n    Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    result = {}\n    for f in fields(obj):\n        value = getattr(obj, f.name)\n        if exclude and f.name in exclude:\n            continue\n        if value is None and exclude_none:\n            continue\n        if (not convert_nested and isinstance(value, (list, tuple, dict))\n                and not value):\n            if exclude_empty:\n                continue\n        result[f.name] = value\n    return result\n```", "```python\nfrom dataclasses import asdict, fields\n\ndef simple_asdict(\n    obj,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: tuple = (),\n) -> dict:\n    \"\"\"\n    Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    result = {}\n    for f in fields(obj):\n        value = getattr(obj, f.name)\n        if value is None and exclude_none:\n            continue\n        if value == \"\" and exclude_empty and f.type == str:\n            continue\n        if convert_nested and hasattr(value, \"__dataclass_fields__\"):\n            result[f.name] = simple_asdict(value)\n        else:\n            result[f.name] = value\n    for key in exclude:\n        result.pop(key, None)\n    return result\n```", "```python\nfrom dataclasses import asdict as std_asdict\nfrom typing import Any, Dict, Iterable, Optional\n\ndef simple_asdict(\n    obj: Any,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: Optional[Iterable[str]] = None\n) -> Dict[str, Any]:\n    def _asdict(\n        obj: Any,\n        exclude_none: bool = False,\n        exclude_empty: bool = False,\n        exclude: Optional[Iterable[str]] = None\n    ) -> Dict[str, Any]:\n        if not isinstance(obj, dict):\n            if isinstance(obj, (list, tuple)):\n                return [d for d in map(_asdict, obj) if d]\n            else:\n                if exclude is None:\n                    exclude = set()\n                elif not isinstance(exclude, set):\n                    exclude = set(exclude)\n                exclude = exclude.union({'__dict__'})\n                attrs = vars(obj)\n                if exclude_none and any(attr in attrs for attr in exclude):\n                    return {}\n                elif exclude_empty and any(attr in attrs and not attrs[attr] for attr in exclude):\n                    return {}\n                return {attr: _asdict(v, exclude_none, exclude_empty, exclude) for attr, v in attrs.items() if attr not in exclude}\n        return obj\n\n    return _asdict(obj, exclude_none, exclude_empty, exclude)\n```"]}, "litestar-litestar/utils/path.py-join_paths": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def join_paths(paths: Iterable[str]) -> str:\n# Natural Language Annotations: \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom pathlib import Path\n\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return str(Path(*paths).resolve())\n```", "```python\nfrom pathlib import Path\nfrom typing import Iterable\n\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"\n    Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return '/'.join(Path(p).resolve().as_posix() for p in paths)\n```", "```python\nfrom pathlib import Path\nfrom typing import Iterable\n\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    path = Path('/').joinpath(*paths)\n    return str(path.resolve().as_posix())\n```"]}, "litestar-litestar/utils/helpers.py-get_name": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_name(value: object) -> str:\n# Natural Language Annotations: \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef get_name(value: object) -> str:\n    \"\"\"\n    Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return str(value.__name__)\n```", "```python\ndef get_name(value: object) -> str:\n    \"\"\"\n    Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return str(value.__name__)\n```", "```python\ndef get_name(value: object) -> str:\n    \"\"\"\n    Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return str(value.__name__)\n```"]}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n# Natural Language Annotations: \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, TypeGuard, Type, get_origin, get_args\nfrom dataclasses import dataclass, is_dataclass\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[dataclass]]:\n    return is_dataclass(annotation)\n```", "```python\nfrom dataclasses import dataclass\nfrom typing import Any, TypeGuard, Type, get_origin, get_args\nfrom typing_extensions import TypeGuard\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[dataclass]]:\n    return issubclass(annotation, dataclass)\n```", "```python\nfrom dataclasses import dataclass\nfrom typing import Any, TypeGuard, TypeVar, get_origin, get_args\n\nT = TypeVar('T')\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[T] if get_origin(annotation) == dataclass else bool]:\n    return issubclass(annotation, dataclass)\n```"]}, "litestar-litestar/utils/predicates.py-is_class_var": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_class_var(annotation: Any) -> bool:\n# Natural Language Annotations: \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any\n\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"\n    Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, type) and annotation.__module__ == 'typing' and annotation.__name__ == 'ClassVar'\n```", "```python\nfrom typing import Any, get_origin, get_args\n\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"\n    Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return get_origin(annotation) == type and get_args(annotation) == (...)\n```", "```python\nfrom typing import Any\n\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"\n    Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return isinstance(annotation, type) and annotation.__module__ == 'typing' and annotation.__name__ == 'ClassVar'\n```"]}, "litestar-litestar/utils/module_loader.py-import_string": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def import_string(dotted_path: str) -> Any:\n# Natural Language Annotations: \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom importlib import import_module\n\ndef import_string(dotted_path: str) -> any:\n    \"\"\"\n    Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    module_path, obj_name = dotted_path.rsplit('.', 1)\n    module = import_module(module_path)\n    return getattr(module, obj_name)\n```", "```python\nimport importlib.util\nfrom typing import Any\n\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"\n    Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    module_path, obj_name = dotted_path.rsplit('.', 1)\n    spec = importlib.util.find_spec(module_path)\n    if spec is None:\n        raise ImportError(f\"Could not find module {module_path}\")\n    module = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(module)\n    return getattr(module, obj_name)\n```", "```python\nfrom importlib import import_module\nfrom typing import Any\n\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"\n    Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    module_name, obj_name = dotted_path.rsplit('.', 1)\n    module = import_module(module_name)\n    return getattr(module, obj_name)\n```"]}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def unsubscribe(self, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Unsubscribe from ``channels``\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    for channel in channels:\n        # Implement logic to unsubscribe from the channel here\n        # For example, if using a Redis pub/sub system:\n        # await self.redis.unsubscribe(channel)\n        # or if using a RabbitMQ connection:\n        # await self.channel.basic_cancel(queue=channel)\n        pass\n```", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    for channel in channels:\n        # Add your code here to unsubscribe from the channel\n        # For example, you might use a database or API to remove the subscription\n        # For simplicity, let's assume we have a method called `remove_subscription`\n        await self.remove_subscription(channel)\n```", "```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    for channel in channels:\n        # Assuming you have a database or a data structure to store subscriptions\n        # Remove the channel from the subscriptions list\n        self.subscriptions.discard(channel)\n```"]}, "litestar-litestar/channels/backends/redis.py-publish": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def publish(self, data: bytes, channels: Iterable[str]) -> None:\n# Natural Language Annotations: \"\"\"Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport asyncio\nimport aioredis\n\nclass Publisher:\n    def __init__(self, redis_url: str):\n        self.redis = aioredis.from_url(redis_url)\n\n    async def publish(self, data: bytes, channels: list[str]) -> None:\n        \"\"\"\n        Publish ``data`` to ``channels``.\n\n        .. note::\n            This operation is performed atomically, using a Lua script\n        \"\"\"\n        lua_script = \"\"\"\n            local data = redis.call('publish', KEYS[1], ARGV[1])\n            return data\n        \"\"\"\n        result = await self.redis.execute_script(lua_script, channels[0], data)\n```", "```\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"\n    Publish ``data`` to ``channels``.\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    # Connect to the Redis server\n    redis = self.redis_client\n    \n    # Create a Lua script to publish data to channels atomically\n    lua_script = \"\"\"\n        local data = cjson.decode(data)\n        for _, channel in pairs(data.channels) do\n            redis.publish(channel, data.message)\n        end\n    \"\"\"\n    \n    # Execute the Lua script\n    redis.evalsha(lua_script, 1, cjson.encode({\"channels\": channels, \"message\": data.decode()}))\n```", "```python\nfrom typing import AsyncGenerator, Iterable\n\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"\n    Publish ``data`` to ``channels``.\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    # Connect to the Lua script\n    lua_script = self.get_lua_script()\n\n    # Create a transaction to ensure atomicity\n    async with lua_script.transaction() as transaction:\n        # Publish the data to all channels\n        for channel in channels:\n            await transaction.publish(data, channel)\n```"]}, "litestar-litestar/channels/backends/redis.py-stream_events": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n# Natural Language Annotations: \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n        If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n        milliseconds.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport asyncio\nfrom typing import AsyncGenerator, Any\n\nclass Stream:\n    def __init__(self, stream_sleep_no_subscriptions: int):\n        self.stream_sleep_no_subscriptions = stream_sleep_no_subscriptions\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        if not self.subscribed_channels:\n            await asyncio.sleep(self.stream_sleep_no_subscriptions / 1000)\n            return\n\n        while True:\n            for channel in self.subscribed_channels:\n                yield channel, await channel.get_event()\n            await asyncio.sleep(self.stream_sleep_no_subscriptions / 1000)\n\n    @property\n    def subscribed_channels(self):\n        # This should be implemented to return a list of channels that have been subscribed to\n        pass\n```", "```python\nimport asyncio\nimport time\nfrom typing import AsyncGenerator, Any\n\nclass EventStream:\n    def __init__(self, stream_sleep_no_subscriptions: int):\n        self.stream_sleep_no_subscriptions = stream_sleep_no_subscriptions\n        self.subscribed_channels = set()\n\n    async def subscribe(self, channel: str):\n        self.subscribed_channels.add(channel)\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        if not self.subscribed_channels:\n            await asyncio.sleep(self.stream_sleep_no_subscriptions / 1000)\n            return\n\n        while True:\n            # Simulate receiving events from channels\n            for channel in self.subscribed_channels:\n                # Replace this with actual event receiving logic\n                event = f\"Event from {channel}\"\n                yield (channel, event)\n```", "```python\nimport asyncio\nimport time\nfrom typing import AsyncGenerator, Any\n\nclass EventStream:\n    def __init__(self, stream_sleep_no_subscriptions: int):\n        self.stream_sleep_no_subscriptions = stream_sleep_no_subscriptions\n        self.subscribed_channels = set()\n        self.last_sleep_time = 0\n\n    async def subscribe(self, channel: str):\n        self.subscribed_channels.add(channel)\n\n    async def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n        while True:\n            if not self.subscribed_channels:\n                if time.time() - self.last_sleep_time < self.stream_sleep_no_subscriptions / 1000:\n                    await asyncio.sleep(self.stream_sleep_no_subscriptions / 1000)\n                else:\n                    self.last_sleep_time = time.time()\n            else:\n                # Simulate receiving an event from a subscribed channel\n                for channel in self.subscribed_channels:\n                    yield (channel, \"Event data\")\n```"]}, "litestar-litestar/channels/backends/redis.py-get_history": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n# Natural Language Annotations: \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    # Assuming we have a database or a data storage system that stores channel history\n    # For simplicity, let's assume it's a dictionary where channel names are keys and lists of messages are values\n    channel_history = {\n        \"channel1\": [b\"Message 1\", b\"Message 2\", b\"Message 3\"],\n        \"channel2\": [b\"Message A\", b\"Message B\", b\"Message C\"],\n        # Add more channels as needed\n    }\n\n    # Get the history of the specified channel\n    history = channel_history.get(channel, [])\n\n    # If limit is specified, return at most limit messages\n    if limit is not None:\n        history = history[:limit]\n\n    return history\n```", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    # Assuming you have a database or a data storage system to store messages\n    # For simplicity, let's assume it's a list of messages\n    messages = [\n        b\"Message 1\",\n        b\"Message 2\",\n        b\"Message 3\",\n        b\"Message 4\",\n        b\"Message 5\",\n        b\"Message 6\",\n        b\"Message 7\",\n        b\"Message 8\",\n        b\"Message 9\",\n        b\"Message 10\"\n    ]\n    \n    # If limit is not specified, return all messages\n    if limit is None:\n        return messages\n    \n    # If limit is specified, return at most limit messages\n    else:\n        return messages[:limit]\n```", "```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    # Assume that self.client is a WebSocket client or a similar object that can handle WebSocket connections\n    history = []\n    if limit is None:\n        limit = float('inf')\n    async with self.client as client:\n        async for message in client.history(channel):\n            history.append(message)\n            if len(history) >= limit:\n                break\n    return history[:limit]\n```"]}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_transfer_model_type(\n# Natural Language Annotations: \"\"\"Create a model for data transfer.\n\n        Args:\n            model_name: name for the type that should be unique across all transfer types.\n            field_definitions: field definitions for the container type.\n\n        Returns:\n            A ``BackendT`` class.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nfrom abc import ABC, abstractmethod\n\nclass BackendT(ABC):\n    def __init__(self, model_name, field_definitions):\n        self.model_name = model_name\n        self.field_definitions = field_definitions\n\n    @abstractmethod\n    def transfer(self):\n        pass\n\nclass TransferModel(BackendT):\n    def __init__(self, model_name, field_definitions):\n        super().__init__(model_name, field_definitions)\n\n    def transfer(self):\n        return f\"Transferring {self.model_name} with fields: {self.field_definitions}\"\n\ndef create_transfer_model_type(model_name, field_definitions):\n    return TransferModel(model_name, field_definitions)\n```", "```\nfrom abc import ABC, abstractmethod\n\nclass BackendT(ABC):\n    def __init__(self, model_name, field_definitions):\n        self.model_name = model_name\n        self.field_definitions = field_definitions\n\n    @abstractmethod\n    def transfer(self):\n        pass\n\nclass TransferModelType(BackendT):\n    def __init__(self, model_name, field_definitions):\n        super().__init__(model_name, field_definitions)\n\n    def transfer(self):\n        return self.field_definitions\n\ndef create_transfer_model_type(model_name, field_definitions):\n    return TransferModelType(model_name, field_definitions)\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict\n\nclass Backend(ABC):\n    @abstractmethod\n    def transfer(self, data: Dict[str, Any]) -> Dict[str, Any]:\n        pass\n\nclass TransferModelType(Backend):\n    def __init__(self, model_name: str, field_definitions: Dict[str, Any]):\n        self.model_name = model_name\n        self.field_definitions = field_definitions\n\n    def transfer(self, data: Dict[str, Any]) -> Dict[str, Any]:\n        return {self.model_name: data}\n\ndef create_transfer_model_type(model_name: str, field_definitions: Dict[str, Any]) -> Backend:\n    return TransferModelType(model_name, field_definitions)\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Populate model instance from builtin types.\n\n        Args:\n            builtins: Builtin type.\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Type, TypeVar\nfrom asgi_types import ASGIConnection, ASGIReceive, ASGIScope, ASGIApp\nfrom typing_extensions import ParamSpec\n\nP = ParamSpec('P)\n\nclass Model:\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"\n    Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if hasattr(builtins, '__iter__'):\n        return [self._populate_single(builtin) for builtin in builtins]\n    else:\n        return self._populate_single(builtins)\n\ndef _populate_single(self, builtin: Any) -> Model:\n    model = Model(\n        request_body=builtin.get('request_body', ''),\n        request_path=builtin.get('request_path', ''),\n        request_method=builtin.get('request_method', ''),\n        request_query=builtin.get('request_query', ''),\n        request_headers=builtin.get('request_headers', {}),\n        request_cookies=builtin.get('request_cookies', {}),\n        request_params=builtin.get('request_params', {}),\n        request_data=builtin.get('request_data', {}),\n        request_files=builtin.get('request_files', {}),\n        request_multipart=builtin.get('request_multipart', {}),\n        scope=builtin.get('scope', {}),\n        receive=builtin.get('receive', ASGIReceive()),\n        app=builtin.get('app', ASGIApp()),\n    )\n    return model\n```", "```python\nfrom typing import Any, ASGIConnection\n\nclass Model:\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"\n    Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if isinstance(builtins, dict):\n        return [Model(**item) for item in builtins]\n    else:\n        return Model(**builtins)\n```", "```\nfrom typing import Any, ASGIConnection\n\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"\n    Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    # Assuming model_type is a class defined elsewhere\n    model_type = self.model_type  # Replace with actual model type\n    \n    if builtins is None:\n        return None\n    \n    if isinstance(builtins, list):\n        return [model_type(**item) for item in builtins]\n    \n    return model_type(**builtins)\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n# Natural Language Annotations: \"\"\"Parse raw bytes into instance of `model_type`.\n\n        Args:\n            raw: bytes\n            asgi_connection: The current ASGI Connection\n\n        Returns:\n            Instance or collection of ``model_type`` instances.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Union\nfrom asgi_tools import ASGIConnection\nfrom pydantic import BaseModel\n\nclass Model(BaseModel):\n    # Define your model properties here\n    pass\n\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Union[Model, list[Model]]:\n    \"\"\"\n    Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    # Parse the raw bytes into a Python object\n    data = json.loads(raw.decode('utf-8'))\n\n    # Initialize an empty list to store the model instances\n    models = []\n\n    # Check if the data is a list or a single object\n    if isinstance(data, list):\n        # If it's a list, create a model instance for each item in the list\n        for item in data:\n            model = Model(**item)\n            models.append(model)\n    else:\n        # If it's a single object, create a single model instance\n        model = Model(**data)\n\n    return models if len(models) > 1 else model\n```", "```python\nfrom typing import Any\n\nclass ASGIConnection:\n    # ASGI Connection class definition (assuming it's a custom class)\n    pass\n\nclass ModelType:\n    # ModelType class definition (assuming it's a custom class)\n    pass\n\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"\n    Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    # Assuming the model_type is a simple string\n    model_type = 'StringModel'\n\n    # Assuming the raw bytes are JSON encoded\n    import json\n    data = json.loads(raw.decode('utf-8'))\n\n    # Assuming the data is a list of model instances\n    instances = [StringModel(**item) for item in data]\n\n    return instances\n\nclass StringModel:\n    def __init__(self, **kwargs):\n        for key, value in kwargs.items():\n            setattr(self, key, value)\n```", "```\nimport json\nfrom asgi_tools import ASGIConnection\nfrom typing import Any\n\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"\n    Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    try:\n        data = json.loads(raw.decode('utf-8'))\n    except json.JSONDecodeError:\n        return []\n    if isinstance(data, list):\n        return [self.model_type(**item) for item in data]\n    else:\n        return self.model_type(**data)\n```"]}, "litestar-litestar/dto/_backend.py-encode_data": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def encode_data(self, data: Any) -> LitestarEncodableType:\n# Natural Language Annotations: \"\"\"Encode data into a ``LitestarEncodableType``.\n\n        Args:\n            data: Data to encode.\n\n        Returns:\n            Encoded data.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, TypeVar\nfrom litestar import LitestarEncodableType\n\nT = TypeVar('T')\n\ndef encode_data(self, data: Any) -> LitestarEncodableType[T]:\n    \"\"\"Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    # Code to encode the data goes here\n    # For example, let's assume we're encoding a string\n    encoded_data: LitestarEncodableType[T] = LitestarEncodableType(data)\n    return encoded_data\n```", "```python\nfrom typing import Any\nfrom litestar import LitestarEncodableType\n\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    \"\"\"\n    Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    # Implement your encoding logic here\n    # For example:\n    if isinstance(data, str):\n        return data.encode('utf-8')\n    elif isinstance(data, list):\n        return [self.encode_data(item) for item in data]\n    elif isinstance(data, dict):\n        return {key: self.encode_data(value) for key, value in data.items()}\n    else:\n        raise ValueError(\"Unsupported data type\")\n```", "```\nfrom typing import Any, TypeVar\nfrom litestar import LitestarEncodableType\n\nT = TypeVar('T', bound=Any)\n\ndef encode_data(self, data: T) -> LitestarEncodableType:\n    \"\"\"Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    # TO DO: implement the actual encoding logic here\n    raise NotImplementedError(\"encode_data method is not implemented\")"]}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n# Natural Language Annotations: \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Type, TypeVar\nfrom dataclasses import dataclass\n\n@dataclass\nclass TransferType:\n    name: str\n    fields: list\n\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"\n    Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    if transfer_type.name == 'Union':\n        return type('Union', (object,), {\n            '__annotations__': {\n                'value': _create_transfer_model_type_annotation(transfer_type.fields[0])\n            }\n        })\n    elif transfer_type.name == 'List':\n        return type('List', (object,), {\n            '__annotations__': {\n                'value': _create_transfer_model_type_annotation(transfer_type.fields[0])\n            }\n        })\n    elif transfer_type.name == 'Dict':\n        return type('Dict', (object,), {\n            '__annotations__': {\n                'key': _create_transfer_model_type_annotation(transfer_type.fields[0]),\n                'value': _create_transfer_model_type_annotation(transfer_type.fields[1])\n            }\n        })\n    else:\n        return type(transfer_type.name, (object,), {\n            '__annotations__': {}\n        })\n```", "```python\nfrom typing import Any, Type, TypeVar, get_type_hints\n\nT = TypeVar('T')\n\ndef create_transfer_model_type_annotation(transfer_type: Type[T]) -> Type[T]:\n    \"\"\"\n    Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    return transfer_type\n```", "```python\nfrom typing import Any, Type, TypeVar, get_origin, get_args\n\nclass TransferType:\n    pass\n\nT = TypeVar('T')\n\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"\n    Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    origin = get_origin(transfer_type)\n    args = get_args(transfer_type)\n    \n    if origin is list or origin is tuple:\n        return list[_create_transfer_model_type_annotation(args[0]) if args else Any]\n    elif origin is dict:\n        return dict[_create_transfer_model_type_annotation(args[0]), _create_transfer_model_type_annotation(args[1])]\n    else:\n        return transfer_type\n```"]}, "litestar-litestar/response/file.py-start_response": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def start_response(self, send: Send) -> None:\n# Natural Language Annotations: \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n        Args:\n            send: The ASGI send function.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    status_line = f\"HTTP/1.1 {self.status_code} {self.status_line_reason}\"\n    headers = [\n        (k, v)\n        for k, v in self.headers.items()\n        if k.lower() not in ['content-length', 'connection', 'keep-alive']\n    ]\n    headers.append(('Content-Length', str(self.body_length)))\n    await send({\n        'type': 'http.response.start',\n        'status': self.status_code,\n        'headers': headers\n    })\n```", "```\nasync def start_response(self, send: callable) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    status = \"200 OK\"\n    headers = [(\"Content-Type\", \"text/plain\")]\n    await send({\"type\": \"http.response.start\", \"status\": status, \"headers\": headers})\n```", "```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    status = \"200 OK\"\n    headers = [(\"Content-Type\", \"text/plain\")]\n    await send({\"type\": \"http.response.start\", \"status\": 200, \"headers\": headers})\n```"]}, "litestar-litestar/connection/request.py-json": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def json(self) -> Any:\n# Natural Language Annotations: \"\"\"Retrieve the json request body from the request.\n\n        Returns:\n            An arbitrary value\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def json(self) -> Any:\n    \"\"\"\n    Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    return await self.request.json()\n```", "```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    return await self.request.json()\n```", "```python\nasync def json(self) -> Any:\n    \"\"\"\n    Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    return await self.request.json()\n```"]}, "litestar-litestar/datastructures/multi_dicts.py-close": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def close(self) -> None:\n# Natural Language Annotations: \"\"\"Close all files in the multi-dict.\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def close(self) -> None:\n    \"\"\"\n    Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for file in self.file_dict.values():\n        file.close()\n```", "```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for file in self.files.values():\n        file.close()\n```", "```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for file in self.files.values():\n        await file.close()\n        del self.files[file.name]\n```"]}, "litestar-litestar/datastructures/url.py-from_scope": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def from_scope(cls, scope: Scope) -> Self:\n# Natural Language Annotations: \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n        Args:\n            scope: A scope\n\n        Returns:\n            A URL\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom urllib.parse import urljoin, urlparse\nfrom .types import Scope\n\nclass BaseURL:\n    def __init__(self, scope: Scope):\n        self.scope = scope\n\n    def __str__(self):\n        return self._url\n\nclass URL(BaseURL):\n    def __init__(self, scope: Scope):\n        super().__init__(scope)\n        self._url = self._construct_url(scope)\n\n    def _construct_url(self, scope: Scope):\n        base_url = scope.get('base_url')\n        path = scope.get('path')\n        query = scope.get('query', {})\n        fragment = scope.get('fragment')\n\n        url = base_url\n        if path:\n            url = urljoin(url, path)\n        if query:\n            url += '?' + '&'.join(f'{key}={value}' for key, value in query.items())\n        if fragment:\n            url += '#' + fragment\n\n        return url\n\ndef from_scope(cls, scope: Scope) -> 'URL':\n    return cls(scope)\n```", "```\ndef from_scope(cls, scope: 'Scope') -> 'Self':\n    \"\"\"\n    Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    # Assuming Scope has a method to get the URL\n    return scope.get_url()\n```", "```python\nfrom typing import Self\n\nclass URL:\n    def __init__(self, scope: 'Scope'):\n        self.scope = scope\n\n    def __str__(self):\n        return self.scope.to_url()\n\nclass Scope:\n    def to_url(self) -> str:\n        # implement to_url method in Scope class\n        pass\n\ndef from_scope(cls, scope: 'Scope') -> Self:\n    return cls(scope)\n```"]}, "litestar-litestar/datastructures/headers.py-to_header": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_header(self, include_header_name: bool = False) -> str:\n# Natural Language Annotations: \"\"\"Get the header as string.\n\n        Args:\n            include_header_name: should include the header name in the return value. If set to false\n                the return value will only include the header value. if set to true the return value\n                will be: ``<header name>: <header value>``. Defaults to false.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n\n    Returns:\n        str: The header as string.\n    \"\"\"\n    header_name = \"header\"  # Replace with actual header name\n    header_value = \"value\"  # Replace with actual header value\n    if include_header_name:\n        return f\"{header_name}: {header_value}\"\n    else:\n        return header_value\n```", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"\n    Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    header_value = \"header_value\"  # replace with actual header value\n    if include_header_name:\n        return f\"{self.header_name}: {header_value}\"\n    else:\n        return header_value\n```", "```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"\n    Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \n    Returns:\n        str: the header as string\n    \"\"\"\n    header_value = \"example_header_value\"  # replace with actual header value\n    if include_header_name:\n        return f\"{self.__class__.__name__}: {header_value}\"\n    else:\n        return header_value\n```"]}, "litestar-litestar/middleware/session/server_side.py-delete": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def delete(self, session_id: str, store: Store) -> None:\n# Natural Language Annotations: \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n        Args:\n            session_id: The session-ID\n            store: Store to delete the session data from\n\n        Returns:\n            None\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"\n    Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    if session_id in store:\n        del store[session_id]\n```", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    if session_id in store:\n        del store[session_id]\n```", "```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    if session_id in store:\n        del store[session_id]\n```"]}, "marimo-marimo/_islands/island_generator.py-add_code": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_code(\n# Natural Language Annotations: \"\"\"Add a code cell to the app.\n\n        *Args:*\n\n        - code (str): The code to add to the app.\n        - display_code (bool): Whether to display the code in the HTML.\n        - display_output (bool): Whether to display the output in the HTML.\n        - is_raw (bool): Whether to handled the code without formatting.\n        - is_reactive (bool): Whether this code block will run with pyodide.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef add_code(code: str, display_code: bool, display_output: bool, is_raw: bool, is_reactive: bool) -> str:\n    \"\"\"\n    Add a code cell to the app.\n\n    Args:\n        code (str): The code to add to the app.\n        display_code (bool): Whether to display the code in the HTML.\n        display_output (bool): Whether to display the output in the HTML.\n        is_raw (bool): Whether to handled the code without formatting.\n        is_reactive (bool): Whether this code block will run with pyodide.\n\n    Returns:\n        str: The formatted code cell.\n    \"\"\"\n    if is_raw:\n        return f\"<code>{code}</code>\"\n    else:\n        if is_reactive:\n            return f\"<pyodide code>{code}</pyodide>\"\n        else:\n            if display_code:\n                return f\"<code>{code}</code><br><br>\"\n            else:\n                return \"\"\n    if display_output:\n        return f\"<pre>{code}</pre>\"\n    else:\n        return \"\"\n```", "```python\ndef add_code(code: str, display_code: bool = False, display_output: bool = False, is_raw: bool = False, is_reactive: bool = False):\n    \"\"\"\n    Add a code cell to the app.\n\n    Args:\n        code (str): The code to add to the app.\n        display_code (bool): Whether to display the code in the HTML. Defaults to False.\n        display_output (bool): Whether to display the output in the HTML. Defaults to False.\n        is_raw (bool): Whether to handled the code without formatting. Defaults to False.\n        is_reactive (bool): Whether this code block will run with pyodide. Defaults to False.\n    \"\"\"\n    # Add your code logic here\n    pass\n```", "```python\ndef add_code(code: str, display_code: bool, display_output: bool, is_raw: bool, is_reactive: bool) -> str:\n    \"\"\"\n    Add a code cell to the app.\n\n    Args:\n        code (str): The code to add to the app.\n        display_code (bool): Whether to display the code in the HTML.\n        display_output (bool): Whether to display the output in the HTML.\n        is_raw (bool): Whether to handled the code without formatting.\n        is_reactive (bool): Whether this code block will run with pyodide.\n\n    Returns:\n        str: The HTML code for the added cell.\n    \"\"\"\n    html = \"<div class='code-cell'\"\n\n    if is_raw:\n        html += \" style='white-space: pre-wrap;'\"\n\n    if not is_reactive:\n        html += \" data-raw='false'\"\n\n    html += \">\"\n\n    if display_code:\n        html += \"<div class='code'>\"\n        html += \"<pre><code>\"\n        if is_raw:\n            html += code\n        else:\n            html += \"<span class='hljs'>\" + code + \"</span>\"\n        html += \"</code></pre>\"\n        html += \"</div>\"\n\n    if display_output:\n        html += \"<div class='output'></div>\"\n\n    html += \"</div>\"\n\n    return html\n```"]}, "marimo-marimo/_islands/island_generator.py-build": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def build(self) -> App:\n# Natural Language Annotations: \"\"\"\n        Build the app. This should be called after adding all the code cells.\n\n        *Returns:*\n\n        - App: The built app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n    # Your code to build the app goes here\n    # For example:\n    app = App()\n    app.setup()\n    app.compile()\n    return app\n```", "```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n    # TODO: Implement the build logic here\n    # For now, just return a mock App object\n    return App()\n```", "```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n    # Code to build the app goes here\n    # This is a placeholder, actual implementation depends on the App class\n    return App()\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom dataclasses import dataclass, asdict\nfrom typing import Type, Any, T\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\n    return cls(**values)\n```", "```python\nfrom typing import Any, Type, T\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"\n    Returns instance of dataclass [cls] instantiated from [values].\n    \n    Args:\n        values (dict[Any, Any]): A dictionary of values to be used for instantiation.\n        cls (Type[T]): The class type to be instantiated.\n    \n    Returns:\n        T: An instance of the given class type.\n    \"\"\"\n    return cls(**values)\n```", "```python\nfrom dataclasses import dataclass\nfrom typing import Any, Type, TypeVar\n\nT = TypeVar('T')\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"\n    Returns instance of dataclass [cls] instantiated from [values].\n    \n    Args:\n        values (dict[Any, Any]): Dictionary containing the data to be used for instantiation.\n        cls (Type[T]): The dataclass type to be instantiated.\n    \n    Returns:\n        T: An instance of the dataclass.\n    \"\"\"\n    return cls(**values)\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n# Natural Language Annotations: \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Union, Type, Any, Dict, List, Tuple, Set\nimport json\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[Any]) -> Any:\n    \"\"\"\n    Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n    if isinstance(message, bytes):\n        message = json.loads(message.decode('utf-8'))\n\n    if not isinstance(cls, type):\n        raise TypeError(\"cls must be a type\")\n\n    if not issubclass(cls, dataclasses.dataclass):\n        raise TypeError(\"cls must be a dataclass\")\n\n    if isinstance(message, dict):\n        for key, value in message.items():\n            if isinstance(value, str):\n                message[key] = to_snake_case(key) if key != \"id\" else key\n            elif isinstance(value, dict):\n                message[key] = parse_raw(value, type(value))\n            elif isinstance(value, list):\n                message[key] = [parse_raw(item, type(item)) for item in value]\n            elif isinstance(value, (set, tuple)):\n                message[key] = type(value)(parse_raw(item, type(item)) for item in value)\n    elif isinstance(message, list):\n        message = [parse_raw(item, type(item)) for item in message]\n    elif isinstance(message, (set, tuple)):\n        message = type(message)(parse_raw(item, type(item)) for item in message)\n\n    return cls(**message)\n\ndef to_snake_case(name: str) -> str:\n    \"\"\"\n    Convert camel case to snake case.\n    \"\"\"\n    result = ''\n    for i, char in enumerate(name):\n        if char.isupper():\n            if i > 0:\n                result += '_'\n            result += char.lower()\n        else:\n            result += char\n    return result\n```", "```python\nfrom typing import Union, Type, Any, TypeVar, cast\nfrom dataclasses import is_dataclass\nfrom collections.abc import Collection\nimport json\n\nT = TypeVar('T')\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    \"\"\"\n    Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n\n    if not is_dataclass(cls):\n        raise TypeError(\"cls must be a dataclass\")\n\n    if isinstance(message, bytes):\n        message = json.loads(message.decode('utf-8'))\n\n    # Convert camel case to snake case\n    def camel_to_snake(name: str) -> str:\n        result = ''\n        for i, char in enumerate(name):\n            if char.isupper() and i != 0:\n                result += '_' + char.lower()\n            else:\n                result += char.lower()\n        return result\n\n    # Create a new dataclass that has the same fields as cls, but with snake case\n    class SnakeCls(cls):\n        @classmethod\n        def __init_subclass__(cls, **kwargs):\n            cls.__annotations__ = {camel_to_snake(k): v for k, v in cls.__annotations__.items()}\n\n    # Create an instance of the new dataclass\n    return cast(T, SnakeCls(**message))\n```", "```python\nfrom dataclasses import asdict, is_dataclass\nfrom typing import Union, Any, Type, Dict, List, Tuple, Set\nimport json\nimport re\n\ndef parse_raw(message: Union[bytes, Dict[Any, Any]], cls: Type[Any]) -> Any:\n    \"\"\"\n    Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n    if isinstance(message, bytes):\n        message = json.loads(message.decode('utf-8'))\n    elif not isinstance(message, dict):\n        raise ValueError(\"message must be of type bytes or dict\")\n\n    if not is_dataclass(cls):\n        raise TypeError(\"cls must be a dataclass\")\n\n    # Convert camel case to snake case\n    def convert_to_snake_case(name: str) -> str:\n        return re.sub(r'(?<!^)(?=[A-Z])', '_', name).lower()\n\n    # Create a new class with snake case fields\n    class SnakeCaseCls(cls):\n        @classmethod\n        def __init_subclass_metaclass__(cls, **kwargs):\n            fields = {}\n            for name, field in cls.__annotations__.items():\n                if name in cls.__dataclass_fields__:\n                    snake_case_name = convert_to_snake_case(name)\n                    fields[snake_case_name] = field\n            cls.__annotations__ = fields\n\n    # Instantiate the new class\n    return SnakeCaseCls(**message)\n```"]}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def icon(\n# Natural Language Annotations: \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom rich.console import Console\nfrom rich.text import Text\nfrom rich.panel import Panel\n\ndef icon(icon_name, size=16, color=None, inline=False, flip=None, rotate=None, style=None):\n    \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    console = Console()\n    icon_html = f\"<i class='iconify' data-icon='{icon_name}' style='{style or ''}'></i>\"\n    if color:\n        icon_html = f\"<span style='color: {color}'>{icon_html}</span>\"\n    if size:\n        icon_html = f\"<span style='font-size: {size}px'>{icon_html}</span>\"\n    if flip:\n        if flip == 'horizontal':\n            icon_html = f\"<span style='transform: scaleX(-1)'>{icon_html}</span>\"\n        elif flip == 'vertical':\n            icon_html = f\"<span style='transform: scaleY(-1)'>{icon_html}</span>\"\n        elif flip == 'both':\n            icon_html = f\"<span style='transform: scale(-1,-1)'>{icon_html}</span>\"\n    if rotate:\n        if rotate == 90:\n            icon_html = f\"<span style='transform: rotate(90deg)'>{icon_html}</span>\"\n        elif rotate == 180:\n            icon_html = f\"<span style='transform: rotate(180deg)'>{icon_html}</span>\"\n        elif rotate == 270:\n            icon_html = f\"<span style='transform: rotate(270deg)'>{icon_html}</span>\"\n    if inline:\n        icon_html = f\"<span>{icon_html}</span>\"\n    return Text(icon_html)\n```", "```python\nfrom ipywidgets import HTML\n\nclass Mo:\n    @staticmethod\n    def icon(icon_name, size='24px', color=None, inline=True, flip=None, rotate=None, style=None):\n        \"\"\"\n        Displays an icon. These icons are referenced by name from the\n        [Iconify](https://iconify.design/) library.\n\n        They are named in the format `icon-set:icon-name`, e.g.\n        `lucide:leaf`.\n\n        Icons are lazily loaded from a CDN, so they will not be loaded when\n        not connected to the internet.\n\n        These can be used in buttons, tabs, and other UI elements.\n\n        **Examples.**\n\n        ```python\n        mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n        mo.ui.button(\n            label=f\"{mo.icon('lucide:rocket')} Submit\",\n        )\n        ```\n\n        **Args.**\n\n        - `icon_name`: the name of the icon to display\n        - `size`: the size of the icon in pixels\n        - `color`: the color of the icon\n        - `inline`: whether to display the icon inline or as a block element\n        - `flip`: whether to flip the icon horizontally, vertically, or both\n        - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n        - `style`: a dictionary of CSS styles to apply to the icon\n\n        **Returns.**\n\n        - An `Html` object.\n        \"\"\"\n        icon_url = f\"<i class='iconify' data-icon='{icon_name}' style='color: {color};' \"\n        \n        if size:\n            icon_url += f\"width: {size}; height: {size}; \"\n        if style:\n            icon_url += style\n        \n        if flip:\n            if 'horizontal' in flip:\n                icon_url += \"transform: scaleX(-1); \"\n            if 'vertical' in flip:\n                icon_url += \"transform: scaleY(-1); \"\n        \n        if rotate:\n            if rotate == 90:\n                icon_url += \"transform: rotate(90deg); \"\n            elif rotate == 180:\n                icon_url += \"transform: rotate(180deg); \"\n            elif rotate == 270:\n                icon_url += \"transform: rotate(270deg); \"\n        \n        if not inline:\n            icon_url += \"display: block; \"\n        \n        icon_url += \">\"\n        \n        return HTML(icon_url)\n```", "```python\nfrom IPython.display import HTML\nfrom IPython.display import display\n\ndef icon(icon_name, size=16, color='#000000', inline=False, flip=None, rotate=None, style=None):\n    \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    icon_html = f'<span class=\"iconify\" data-icon=\"{icon_name}\" style=\"font-size: {size}px; color: {color};'\n    if style:\n        for key, value in style.items():\n            icon_html += f'{key}: {value};'\n    if flip:\n        if flip == 'horizontal':\n            icon_html += ' transform: scaleX(-1);'\n        elif flip == 'vertical':\n            icon_html += ' transform: scaleY(-1);'\n        elif flip == 'both':\n            icon_html += ' transform: scale(-1, -1);'\n    if rotate:\n        if rotate == 90:\n            icon_html += ' transform: rotate(90deg);'\n        elif rotate == 180:\n            icon_html += ' transform: rotate(180deg);'\n        elif rotate == 270:\n            icon_html += ' transform: rotate(270deg);'\n    icon_html += '\" data-inline=\"{}\"></span>'.format('true' if inline else 'false')\n    return HTML(icon_html)\n```"]}, "marimo-marimo/_plugins/stateless/image.py-image": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def image(\n# Natural Language Annotations: \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    **Args.**\n\n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    **Returns.**\n\n    `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom markupsafe import Markup\nfrom urllib.request import urlopen\nimport io\n\ndef image(src, alt=\"\", width=0, height=0, rounded=False, style=None):\n    \"\"\"\n    Render an image as HTML.\n\n    Examples.\n    \n    ```python\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n    ```\n\n    Args.\n    \n    - `src`: a path or URL to an image, a file-like object\n        (opened in binary mode), or array-like object.\n    - `alt`: the alt text of the image\n    - `width`: the width of the image in pixels\n    - `height`: the height of the image in pixels\n    - `rounded`: whether to round the corners of the image\n    - `style`: a dictionary of CSS styles to apply to the image\n\n    Returns.\n    \n    `Html` object\n    \"\"\"\n    if not src:\n        return Markup(\"<img src=''>\")\n    \n    if isinstance(src, str) and src.startswith(\"http\"):\n        image_data = urlopen(src).read()\n        src = io.BytesIO(image_data)\n    elif not hasattr(src, \"read\"):\n        raise ValueError(\"Invalid image source\")\n    \n    url = src.name if hasattr(src, \"name\") else None\n    \n    styles = []\n    if rounded:\n        styles.append(\"border-radius: 50%\")\n    if width:\n        styles.append(f\"width: {width}px\")\n    if height:\n        styles.append(f\"height: {height}px\")\n    if style:\n        styles.extend(f\"{key}: {value}\" for key, value in style.items())\n    \n    style_str = \"; \".join(styles)\n    \n    return Markup(f\"<img src='{url or ''}' alt='{alt}' style='{style_str}'>\")\n```", "```python\nfrom markupsafe import Markup\nfrom jinja2 import Template\n\ndef image(src, alt=\"\", width=None, height=None, rounded=False, style=None):\n    template = Template('<img src=\"{{ src }}\" alt=\"{{ alt }}\"')\n    if width:\n        template += ' width=\"{{ width }}\"'\n    if height:\n        template += ' height=\"{{ height }}\"'\n    if rounded:\n        template += ' style=\"border-radius: 50%;\"'\n    if style:\n        for key, value in style.items():\n            template += f' style=\"{{ style.get(\"{key}\", \"\") }}; {value};\"'\n    template += '>'\n    return Markup(template.render(src=src, alt=alt, width=width, height=height, style=style))\n```", "```\nfrom marko import Html\n\ndef image(\n    src,\n    alt=\"\",\n    width=None,\n    height=None,\n    rounded=False,\n    style=None,\n):\n    if isinstance(src, str):\n        if src.startswith(\"http\"):\n            img = Html.image(src=src, alt=alt, width=width, height=height, rounded=rounded, style=style)\n        else:\n            img = Html.image(src=src, alt=alt, width=width, height=height, rounded=rounded, style=style)\n    elif hasattr(src, 'read'):\n        img = Html.image(src=src, alt=alt, width=width, height=height, rounded=rounded, style=style)\n    elif isinstance(src, (list, tuple)):\n        img = Html.image(src=src, alt=alt, width=width, height=height, rounded=rounded, style=style)\n    else:\n        raise ValueError(\"Invalid src type\")\n    return img\n```"]}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def hstack(\n# Natural Language Annotations: \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom dash import dcc, html\nfrom dash.exceptions import PreventUpdate\n\ndef hstack(items, justify='start', align='start', wrap=False, gap=1.0, widths=None):\n    \"\"\"\n    Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    Args:\n        items (list): A list of items.\n        justify (str, optional): Justify items horizontally: start, center, end, space-between, or space-around. Defaults to 'start'.\n        align (str, optional): Align items vertically: start, end, center, or stretch. Defaults to 'start'.\n        wrap (bool, optional): Wrap items or not. Defaults to False.\n        gap (float, optional): Gap between items as a float in rem. 1rem is 16px by default. Defaults to 1.0.\n        widths (list or str, optional): \"equal\" to give items equal width; or a list of relative widths with same length as `items`, eg, [1, 2] means the second item is twice as wide as the first; or `None` for a sensible default. Defaults to None.\n\n    Returns:\n        Html: An `Html` object.\n    \"\"\"\n    if len(items) == 0:\n        raise PreventUpdate(\"Items list is empty\")\n\n    if widths == 'equal':\n        widths = [1.0 / len(items) for _ in items]\n    elif widths is None:\n        # sensible default is to use equal width\n        widths = [1.0 / len(items) for _ in items]\n    elif len(widths) != len(items):\n        raise ValueError(\"Widths list must have the same length as items list\")\n\n    if wrap:\n        return html.Div(\n            items,\n            style={\n                'display': 'flex',\n                'flex-wrap': 'wrap',\n                'justifyContent': justify,\n                'alignItems': align,\n                'gap': f'{gap}rem'\n            }\n        )\n    else:\n        return html.Div(\n            items,\n            style={\n                'display': 'flex',\n                'justifyContent': justify,\n                'alignItems': align,\n                'gap': f'{gap}rem'\n            }\n        )\n```", "```python\nfrom dash import dcc, html\n\ndef hstack(items, justify='start', align='start', wrap=False, gap=1.0, widths=None):\n    \"\"\"\n    Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    Args:\n        items (list): A list of items.\n        justify (str): Justify items horizontally: start, center, end, space-between, or space-around.\n        align (str): Align items vertically: start, end, center, or stretch.\n        wrap (bool): Wrap items or not.\n        gap (float): Gap between items as a float in rem. 1rem is 16px by default.\n        widths (list or str): \"equal\" to give items equal width; or a list of relative widths with same length as `items`, eg, [1, 2] means the second item is twice as wide as the first; or `None` for a sensible default\n\n    Returns:\n        An `Html` object.\n    \"\"\"\n    if widths is None:\n        widths = [1.0] * len(items)\n    elif widths == 'equal':\n        widths = [1.0 / len(items)] * len(items)\n    elif len(widths) != len(items):\n        raise ValueError(\"Widths list must have the same length as items\")\n\n    children = []\n    for item, width in zip(items, widths):\n        if isinstance(width, str) and width == 'equal':\n            width = 1.0 / len(items)\n        children.append(dcc.Size(width=width, children=[item]))\n\n    if justify == 'start':\n        justify_class = ''\n    elif justify == 'center':\n        justify_class = 'justify-content-center'\n    elif justify == 'end':\n        justify_class = 'justify-content-end'\n    elif justify == 'space-between':\n        justify_class = 'justify-content-space-between'\n    elif justify == 'space-around':\n        justify_class = 'justify-content-space-around'\n    else:\n        raise ValueError(\"Invalid justify value\")\n\n    if align == 'start':\n        align_class = ''\n    elif align == 'end':\n        align_class = 'align-items-end'\n    elif align == 'center':\n        align_class = 'align-items-center'\n    elif align == 'stretch':\n        align_class = 'align-items-stretch'\n    else:\n        raise ValueError(\"Invalid align value\")\n\n    if wrap:\n        wrap_class = 'flex-wrap'\n    else:\n        wrap_class = ''\n\n    return html.Div(\n        className=f'display-flex flex-row {justify_class} {align_class} {wrap_class}',\n        style={'gap': f'{gap}rem'},\n        children=children\n    )\n```", "```python\nfrom dash import html\n\ndef hstack(items, justify=None, align=None, wrap=False, gap=1.0, widths=None):\n    \"\"\"\n    Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    Args:\n        items (list): A list of items.\n        justify (str, optional): Justify items horizontally: start, center, end, space-between, or space-around. Defaults to None.\n        align (str, optional): Align items vertically: start, end, center, or stretch. Defaults to None.\n        wrap (bool, optional): Wrap items or not. Defaults to False.\n        gap (float, optional): Gap between items as a float in rem. 1rem is 16px by default. Defaults to 1.0.\n        widths (str or list, optional): \"equal\" to give items equal width; or a list of relative widths with same length as `items`, eg, [1, 2] means the second item is twice as wide as the first; or None for a sensible default. Defaults to None.\n\n    Returns:\n        Html: An Html object.\n    \"\"\"\n    if widths is None:\n        widths = [1] * len(items)\n    elif widths == \"equal\":\n        widths = [1.0 / len(items)] * len(items)\n    if not isinstance(widths, list):\n        widths = [widths] * len(items)\n    if len(widths) != len(items):\n        raise ValueError(\"Number of widths must match number of items\")\n    if not all(isinstance(w, (int, float)) for w in widths):\n        raise ValueError(\"Widths must be numbers\")\n    if not all(w > 0 for w in widths):\n        raise ValueError(\"Widths must be positive\")\n    if sum(widths) != 1.0:\n        raise ValueError(\"Widths must sum to 1.0\")\n    return html.Div(\n        [\n            html.Div(item, style={\"flex\": f\"{width}\" if width != 1.0 else \"1 1 auto\"})\n            for item, width in zip(items, widths)\n        ],\n        style={\n            \"display\": \"flex\",\n            \"flexDirection\": \"row\",\n            \"justifyContent\": justify,\n            \"alignItems\": align,\n            \"gap\": f\"{gap}rem\",\n            \"flexWrap\": \"wrap\" if wrap else \"nowrap\",\n        },\n    )\n```"]}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def update_progress(\n# Natural Language Annotations: \"\"\"Update the progress indicator.\n\n        **Example.**\n\n        ```python\n        # Increment by 1\n        progress.update()\n\n        # Increment by 10 and update title and subtitle\n        progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n        ```\n\n        **Args.**\n\n        - increment: amount to increment by. Defaults to 1.\n        - title: new title. Defaults to None.\n        - subtitle: new subtitle. Defaults to None.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef update_progress(increment=1, title=None, subtitle=None):\n    # Simulate a progress bar\n    global progress\n    if not hasattr(update_progress, 'progress'):\n        progress = {'title': 'Progress', 'subtitle': '', 'value': 0}\n\n    progress['value'] += increment\n    if title:\n        progress['title'] = title\n    if subtitle:\n        progress['subtitle'] = subtitle\n    print(f\"{progress['title']}: {progress['value']}/{100} - {progress['subtitle']}\")\n```", "```python\nclass ProgressIndicator:\n    def __init__(self):\n        self.title = None\n        self.subtitle = None\n        self.progress = 0\n\n    def update(self, increment=1, title=None, subtitle=None):\n        self.progress += increment\n        if title:\n            self.title = title\n        if subtitle:\n            self.subtitle = subtitle\n\n# Usage\nprogress = ProgressIndicator()\nprogress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n```", "```python\nclass Progress:\n    def __init__(self, title=None, subtitle=None):\n        self.title = title\n        self.subtitle = subtitle\n        self.progress = 0\n\n    def update(self, increment=1, title=None, subtitle=None):\n        self.progress += increment\n        if title:\n            self.title = title\n        if subtitle:\n            self.subtitle = subtitle\n\ndef update_progress(increment=1, title=None, subtitle=None):\n    progress = Progress(title, subtitle)\n    progress.update(increment, title, subtitle)\n    return progress\n\n# Example usage:\nprogress = update_progress(10, \"Loading\", \"Still going...\")\nprint(progress.title)  # Output: Loading\nprint(progress.subtitle)  # Output: Still going...\nprint(progress.progress)  # Output: 10\n\nprogress.update(5)\nprint(progress.progress)  # Output: 15\n```"]}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def build_ui_plugin(\n# Natural Language Annotations: \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: dict,\n    label: str,\n    args: dict,\n    slotted_html: str\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    html = f\"<{component_name} id='{component_name}' data-initial-value='{str(initial_value)}'>\"\n    if label:\n        html += f\"<label>{label}</label>\"\n    for arg_name, arg_value in args.items():\n        html += f\"<input type='hidden' name='{arg_name}' value='{str(arg_value)}'>\"\n    html += f\"<div>{slotted_html}</div>\"\n    html += f\"</{component_name}>\"\n    return html\n```", "```python\ndef build_ui_plugin(component_name, initial_value, label, args, slotted_html):\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    html = f\"<{component_name}\"\n    if args:\n        html += \" \" + \" \".join([f\"{key}='{value}'\" for key, value in args.items()])\n    html += f\" initial_value='{initial_value}'\"\n    if label:\n        html += f\" label='{label}'\"\n    html += f\">{slotted_html}</{component_name}>\"\n    return html\n```", "```python\ndef build_ui_plugin(component_name, initial_value, label, args, slotted_html):\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    html = f\"<{component_name} id='{component_name}' value='{initial_value}' \"\n    for arg, value in args.items():\n        html += f\"{arg}='{value}' \"\n    html += f\"slotted-html='{slotted_html}'>{label}</{component_name}>\"\n    return html\n```"]}, "marimo-marimo/_output/formatting.py-as_html": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def as_html(value: object) -> Html:\n# Natural Language Annotations: \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom IPython.display import display, HTML\n\ndef as_html(value: object) -> str:\n    \"\"\"\n    Convert a value to HTML that can be embedded into markdown\n\n    This function returns an HTML string representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    print(f\"Here is a plot: {as_html(axis)}\")\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An HTML string\n    \"\"\"\n    if hasattr(value, 'to_html'):\n        return value.to_html()\n    elif hasattr(value, '__html__'):\n        return value.__html__\n    else:\n        return str(value)\n```", "```python\nfrom IPython.display import HTML\n\ndef as_html(value: object) -> HTML:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    if isinstance(value, str):\n        return HTML(value)\n    elif isinstance(value, list):\n        return HTML(', '.join(as_html(item) for item in value))\n    elif isinstance(value, dict):\n        return HTML(str(value))\n    elif hasattr(value, 'to_html'):\n        return value.to_html()\n    elif isinstance(value, type(None)):\n        return HTML('None')\n    else:\n        return HTML(str(value))\n```", "```python\nfrom IPython.display import display, HTML\nfrom IPython.core.display import display_html\n\ndef as_html(value: object) -> str:\n    \"\"\"\n    Convert a value to HTML that can be embedded into markdown\n\n    This function returns an HTML string representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    print(f\"\"\"\n    Here is a plot:\n\n    {as_html(axis)}\n    \"\"\")\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An HTML string\n    \"\"\"\n    try:\n        if hasattr(value, 'to_html'):\n            return value.to_html()\n        elif hasattr(value, 'to_string'):\n            return f\"<pre>{value.to_string()}</pre>\"\n        elif hasattr(value, 'to_latex'):\n            return f\"<pre>{value.to_latex()}</pre>\"\n        else:\n            return str(value)\n    except Exception as e:\n        return f\"<pre>{str(e)}</pre>\"\n```"]}, "marimo-marimo/_output/md.py-md": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def md(text: str) -> Html:\n# Natural Language Annotations: r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef md(text: str) -> Html:\n    \"\"\"\n    Write markdown.\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    **Args**:\n\n    - `text`: a string of markdown\n\n    **Returns**:\n\n    - An `Html` object.\n    \"\"\"\n    from IPython.display import Markdown as Html\n    return Html(text)\n```", "```python\nfrom IPython.display import Markdown as md\nfrom IPython.display import display\n\ndef md(text: str) -> None:\n    \"\"\"\n    Write markdown.\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    Interpolation.\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    LaTeX.\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    Args:\n\n    - `text`: a string of markdown\n\n    Returns:\n\n    - An `Html` object.\n    \"\"\"\n    display(md(text))\n```", "```python\nfrom IPython.display import Markdown, display\nimport matplotlib.pyplot as plt\n\ndef md(text: str) -> None:\n    \"\"\"\n    Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    Interpolation.\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    LaTeX.\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n    ```\n    renders:\n\n    The exponential function $f(x) = e^x$ can be represented as\n\n    $$\n    f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n    $$\n\n\n    Args:\n\n    - `text`: a string of markdown\n\n    Returns:\n\n    - An `Html` object.\n    \"\"\"\n    display(Markdown(text))\n```"]}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_formatters() -> None:\n# Natural Language Annotations: \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport importlib\nimport importlib.util\nimport sys\nfrom traitlets import default\nfrom traitlets.config import Config\nfrom traitlets import List, Dict\n\ndef register_formatters():\n    \"\"\"\n    Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n    # Get the list of modules that are currently being imported\n    for _, module in sys.modules.items():\n        # Check if the module is a marimo formatter module\n        if hasattr(module, 'register_formatters'):\n            # Register the formatters\n            module.register_formatters()\n    \n    # Get the list of modules that are being imported\n    for importer in sys.meta_path:\n        # Check if the importer is a marimo formatter importer\n        if hasattr(importer, 'find_spec'):\n            # Get the list of modules that the importer is importing\n            for spec in importer.find_spec('all'):\n                # Check if the module is a marimo formatter module\n                if hasattr(spec.loader, 'get_code'):\n                    # Register the formatters\n                    spec.loader.get_code().exec_module().register_formatters()\n\n    # Check if the 'importlib.util.find_spec' function is available\n    if hasattr(importlib.util, 'find_spec'):\n        # Get the list of modules that are being imported\n        for spec in importlib.util.find_spec('all'):\n            # Check if the module is a marimo formatter module\n            if hasattr(spec.loader, 'get_code'):\n                # Register the formatters\n                spec.loader.get_code().exec_module().register_formatters()\n```", "```python\nimport importlib\nimport sys\nfrom marimo.formatters import register_formatter\n\ndef register_formatters() -> None:\n    \"\"\"\n    Register formatters with marimo.\n    \n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n    \"\"\"\n    for module in sys.modules.values():\n        if hasattr(module, '__module__') and module.__module__.startswith('ipython'):\n            for name in dir(module):\n                obj = getattr(module, name)\n                if hasattr(obj, 'register_formatter'):\n                    obj.register_formatter()\n                    \n    # Add a hook to register formatters when a module is imported\n    def register_module(module):\n        if hasattr(module, '__module__') and module.__module__.startswith('ipython'):\n            for name in dir(module):\n                obj = getattr(module, name)\n                if hasattr(obj, 'register_formatter'):\n                    obj.register_formatter()\n                    \n    importlib.import_hook.register(register_module)\n```", "```python\nimport importlib\nimport importlib.util\nimport sys\nfrom traitlets.config import Config\nfrom traitlets import Traited\nfrom ipython.core.interactiveshell import InteractiveShell\nfrom IPython.core.formatters import fmt_out\n\ndef register_formatters() -> None:\n    \"\"\"\n    Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n    # Get the InteractiveShell instance\n    shell = InteractiveShell.instance()\n\n    # Get the kernel's configuration\n    config = shell.config\n\n    # Define a function to register a formatter\n    def register_formatter(module_name, formatter_class):\n        # Get the module\n        spec = importlib.util.find_spec(module_name)\n        if spec is None:\n            return\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n\n        # Get the formatter\n        formatter = getattr(module, formatter_class)\n\n        # Register the formatter\n        config.Formatters.register(formatter)\n\n    # Register formatters for supported libraries\n    register_formatter('numpy', 'NumpyFormatter')\n    register_formatter('pandas', 'PandasFormatter')\n    # Add more libraries as needed\n```"]}, "marimo-marimo/_data/series.py-get_category_series_info": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_category_series_info(series: Any) -> CategorySeriesInfo:\n# Natural Language Annotations: \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any\n\nclass CategorySeriesInfo:\n    def __init__(self, name: str, description: str, categories: list):\n        self.name = name\n        self.description = description\n        self.categories = categories\n\nclass Series:\n    def __init__(self, name: str, description: str):\n        self.name = name\n        self.description = description\n\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    if isinstance(series, Series):\n        return CategorySeriesInfo(series.name, series.description, [])\n    elif isinstance(series, dict):\n        return CategorySeriesInfo(series.get('name', ''), series.get('description', ''), series.get('categories', []))\n    else:\n        raise ValueError(\"Invalid series type\")\n```", "```python\nfrom typing import Any\n\nclass CategorySeriesInfo:\n    def __init__(self, name: str, description: str, count: int):\n        self.name = name\n        self.description = description\n        self.count = count\n\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n    # For simplicity, let's assume series is a list of categories\n    categories = series\n    \n    # Get the name of the series\n    name = \"Category Series\"\n    \n    # Get the description of the series\n    description = \"This is a categorical series\"\n    \n    # Get the count of categories\n    count = len(categories)\n    \n    return CategorySeriesInfo(name, description, count)\n```", "```python\nfrom typing import Any\n\nclass CategorySeriesInfo:\n    def __init__(self, name: str, description: str, categories: list):\n        self.name = name\n        self.description = description\n        self.categories = categories\n\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \n    Args:\n        series (Any): The series to get the summary for.\n    \n    Returns:\n        CategorySeriesInfo: A CategorySeriesInfo object containing the summary information.\n    \"\"\"\n    # Assuming series is a pandas Series object\n    if isinstance(series, pd.Series):\n        # Get the name of the series\n        name = series.name\n        \n        # Get the description of the series (assuming it's a string)\n        description = series.dtype.name\n        \n        # Get the categories of the series\n        categories = series.cat.categories.tolist()\n        \n        # Create a CategorySeriesInfo object\n        category_series_info = CategorySeriesInfo(name, description, categories)\n        \n        return category_series_info\n    else:\n        raise ValueError(\"Input series must be a pandas Series object\")\n```"]}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_column_preview(\n# Natural Language Annotations: \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef get_column_preview(df, column_name):\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n\n    Args:\n        df (pd.DataFrame): The DataFrame containing the column.\n        column_name (str): The name of the column to preview.\n\n    Returns:\n        tuple: A tuple containing a chart and an aggregation summary of the column.\n    \"\"\"\n    if column_name not in df.columns:\n        raise ValueError(\"Column does not exist in the DataFrame\")\n\n    chart = plt.figure(figsize=(10, 6))\n    plt.hist(df[column_name], bins=10)\n    plt.title(f\"Column: {column_name}\")\n    plt.xlabel(column_name)\n    plt.ylabel(\"Frequency\")\n    plt.show()\n\n    summary = df[column_name].describe()\n    return chart, summary\n```", "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef get_column_preview(df, column_name):\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n\n    Parameters:\n    df (DataFrame): The DataFrame containing the dataset.\n    column_name (str): The name of the column to preview.\n\n    Returns:\n    tuple: A tuple containing the chart and the aggregation summary.\n    \"\"\"\n\n    # Check if the column exists in the DataFrame\n    if column_name not in df.columns:\n        return None, \"Column not found in the DataFrame.\"\n\n    # Get the column data\n    column_data = df[column_name]\n\n    # Create a histogram chart\n    plt.figure(figsize=(10, 6))\n    plt.hist(column_data, bins=10, edgecolor='black')\n    plt.title(f\"Histogram of {column_name}\")\n    plt.xlabel(column_name)\n    plt.ylabel(\"Frequency\")\n    plt.show()\n\n    # Get the aggregation summary\n    summary = df[column_name].describe()\n\n    return plt, summary\n```", "```python\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\ndef get_column_preview(df, column_name):\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and a aggregation summary of the column.\n\n    Args:\n        df (pd.DataFrame): The dataset.\n        column_name (str): The name of the column to preview.\n\n    Returns:\n        tuple: A tuple containing a matplotlib figure and a dictionary with aggregation summary.\n    \"\"\"\n    if column_name not in df.columns:\n        return None, None\n\n    fig, ax = plt.subplots()\n    ax.hist(df[column_name], bins=10)\n    ax.set_title(f'Histogram of {column_name}')\n    ax.set_xlabel(column_name)\n    ax.set_ylabel('Frequency')\n\n    summary = {\n        'mean': df[column_name].mean(),\n        'median': df[column_name].median(),\n        'mode': df[column_name].mode()[0],\n        'std': df[column_name].std(),\n        'count': df[column_name].count()\n    }\n\n    return fig, summary\n```"]}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start_file_watcher(self) -> Disposable:\n# Natural Language Annotations: \"\"\"Starts the file watcher if it is not already started\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Disposable\n\nclass FileWatcher:\n    def __init__(self):\n        self.is_running = False\n\n    def start_file_watcher(self) -> Disposable:\n        \"\"\"Starts the file watcher if it is not already started\"\"\"\n        if not self.is_running:\n            self.is_running = True\n            # Implement file watching logic here, for example:\n            # self.file_watcher = threading.Thread(target=self.watch_files)\n            # self.file_watcher.start()\n            return Disposable()\n        else:\n            return Disposable()\n```", "```python\nimport threading\nimport time\nfrom typing import Disposable\n\nclass FileWatcher:\n    def __init__(self):\n        self._is_running = False\n        self._thread = None\n    \n    def start_file_watcher(self) -> Disposable:\n        \"\"\"Starts the file watcher if it is not already started\"\"\"\n        if not self._is_running:\n            self._is_running = True\n            self._thread = threading.Thread(target=self._watch_files)\n            self._thread.start()\n            return self\n        else:\n            raise Exception(\"File watcher is already running\")\n\n    def _watch_files(self):\n        while self._is_running:\n            # Add your file watching logic here\n            time.sleep(1)\n\n    def stop_file_watcher(self):\n        self._is_running = False\n        if self._thread:\n            self._thread.join()\n\nclass Disposable:\n    def dispose(self):\n        self.stop_file_watcher()\n```", "```python\nimport threading\nfrom typing import Disposable\n\nclass FileWatcher:\n    def __init__(self):\n        self._is_running = False\n        self._thread = None\n\n    def start_file_watcher(self) -> Disposable:\n        \"\"\"Starts the file watcher if it is not already started\"\"\"\n        if not self._is_running:\n            self._is_running = True\n            self._thread = threading.Thread(target=self._watch_files)\n            self._thread.start()\n\n            class Disposable:\n                def dispose(self):\n                    self._is_running = False\n                    if self._thread and self._thread.is_alive():\n                        self._thread.join()\n                    self._thread = None\n\n            return Disposable()\n        else:\n            raise Exception(\"File watcher is already running\")\n```"]}, "marimo-marimo/_server/file_manager.py-save_app_config": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def save_app_config(self, config: Dict[str, Any]) -> str:\n# Natural Language Annotations: \"\"\"Save the app configuration.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Dict, Any\n\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"\n    Save the app configuration.\n\n    Args:\n        config (Dict[str, Any]): A dictionary containing the app configuration.\n\n    Returns:\n        str: A message indicating whether the configuration was saved successfully.\n    \"\"\"\n    try:\n        # Assuming you have a database or a file to store the config\n        # Here, I'm using a simple dictionary to store the config\n        with open(\"app_config.json\", \"w\") as file:\n            import json\n            json.dump(config, file)\n        return \"Configuration saved successfully.\"\n    except Exception as e:\n        return f\"Failed to save configuration: {str(e)}\"\n```", "```python\nfrom typing import Dict, Any\n\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"\n    Save the app configuration.\n    \n    Args:\n    config (Dict[str, Any]): A dictionary containing the app configuration.\n    \n    Returns:\n    str: A success message if the configuration is saved successfully.\n    \"\"\"\n    try:\n        # Save the configuration to a file or database\n        with open('app_config.txt', 'w') as file:\n            file.write(str(config))\n        return \"Configuration saved successfully.\"\n    except Exception as e:\n        return f\"Error saving configuration: {str(e)}\"\n```", "```python\nfrom typing import Dict, Any\n\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"\n    Save the app configuration.\n\n    Args:\n        config (Dict[str, Any]): A dictionary containing the app configuration.\n\n    Returns:\n        str: A message indicating whether the configuration was saved successfully or not.\n    \"\"\"\n    try:\n        # Code to save the configuration to a file or database here\n        # For example:\n        with open('app_config.json', 'w') as f:\n            import json\n            json.dump(config, f)\n        return \"Configuration saved successfully.\"\n    except Exception as e:\n        return f\"Error saving configuration: {str(e)}\"\n```"]}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_stdin(self, stdin: str) -> None:\n# Natural Language Annotations: \"\"\"Add a stdin request to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"\n    Add a stdin request to the session view.\n\n    Args:\n        stdin (str): The stdin request to be added.\n\n    Returns:\n        None\n    \"\"\"\n    # Add the stdin request to the session view\n    self.session_view.append(stdin)\n```", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"\n    Add a stdin request to the session view.\n    \"\"\"\n    self.session_view.append(stdin)\n```", "```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"\n    Add a stdin request to the session view.\n\n    :param stdin: The input from the standard input.\n    :return: None\n    \"\"\"\n    # Check if the stdin is not empty\n    if stdin:\n        # Add the stdin to the session view\n        self.session_view.append(stdin)\n    else:\n        # If stdin is empty, print a message to the user\n        print(\"No input provided.\")\n```"]}, "marimo-marimo/_server/session/session_view.py-add_operation": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_operation(self, operation: MessageOperation) -> None:\n# Natural Language Annotations: \"\"\"Add an operation to the session view.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    self.session_view.append(operation)\n```", "```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"\n    Add an operation to the session view.\n    \n    :param operation: The operation to be added to the session view.\n    :type operation: MessageOperation\n    \"\"\"\n    if operation:\n        self.session_view.append(operation)\n    else:\n        raise ValueError(\"Operation cannot be None\")\n```", "```python\nclass SessionView:\n    def __init__(self):\n        self.operations = []\n\n    def add_operation(self, operation: 'MessageOperation') -> None:\n        \"\"\"Add an operation to the session view.\"\"\"\n        self.operations.append(operation)\n```"]}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_cell_console_outputs(\n# Natural Language Annotations: \"\"\"Get the console outputs for the given cell ids.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef get_cell_console_outputs(cell_ids):\n    \"\"\"\n    Get the console outputs for the given cell ids.\n\n    Args:\n        cell_ids (list): A list of cell ids.\n\n    Returns:\n        dict: A dictionary where keys are cell ids and values are console outputs.\n    \"\"\"\n    console_outputs = {}\n    for cell_id in cell_ids:\n        # Simulating fetching console output from database or API\n        # Replace this with actual implementation\n        console_output = f\"Console output for cell {cell_id}\"\n        console_outputs[cell_id] = console_output\n    return console_outputs\n```", "```python\ndef get_cell_console_outputs(cell_ids):\n    \"\"\"\n    Get the console outputs for the given cell ids.\n\n    Args:\n        cell_ids (list): A list of cell ids.\n\n    Returns:\n        dict: A dictionary where keys are cell ids and values are their corresponding console outputs.\n    \"\"\"\n    console_outputs = {}\n    for cell_id in cell_ids:\n        # Assuming you have a function to get the console output for a cell\n        # This function is not implemented here, you would need to implement it based on your actual data storage and retrieval mechanism\n        console_output = get_cell_output(cell_id)\n        console_outputs[cell_id] = console_output\n    return console_outputs\n\ndef get_cell_output(cell_id):\n    # This is a placeholder function, you would need to implement it based on your actual data storage and retrieval mechanism\n    pass\n```", "```python\ndef get_cell_console_outputs(cell_ids):\n    \"\"\"\n    Get the console outputs for the given cell ids.\n    \n    Args:\n        cell_ids (list): A list of cell ids.\n    \n    Returns:\n        dict: A dictionary mapping cell ids to their corresponding console outputs.\n    \"\"\"\n    # Initialize an empty dictionary to store the console outputs\n    console_outputs = {}\n    \n    # Iterate over each cell id\n    for cell_id in cell_ids:\n        # Replace this with your logic to get the console output for the cell id\n        # For demonstration purposes, assume we have a function called get_console_output\n        console_output = get_console_output(cell_id)\n        \n        # Store the console output in the dictionary\n        console_outputs[cell_id] = console_output\n    \n    # Return the dictionary of console outputs\n    return console_outputs\n\n# Replace this with your actual logic to get the console output for a cell id\ndef get_console_output(cell_id):\n    # This is a placeholder function, you need to implement the actual logic here\n    pass\n```"]}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n# Natural Language Annotations: \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import TypeVar\n\nCellId_t = TypeVar('CellId_t')\nCellImpl = TypeVar('CellImpl')\n\nclass Graph:\n    def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n        \"\"\"Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\n        with self.lock:\n            if cell_id in self.cells:\n                raise ValueError(f\"Cell with id {cell_id} already exists\")\n            self.cells[cell_id] = cell\n```", "```python\nfrom threading import RLock\n\nclass Graph:\n    def __init__(self):\n        self.lock = RLock()\n        self.cells = {}\n\n    def register_cell(self, cell_id: str, cell: object) -> None:\n        \"\"\"\n        Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\n        with self.lock:\n            if cell_id in self.cells:\n                raise ValueError(f\"Cell with ID '{cell_id}' already exists in the graph\")\n            self.cells[cell_id] = cell\n```", "```python\nfrom typing import TypeVar\nfrom threading import Lock\n\nCellId_t = TypeVar('CellId_t')\nCellImpl = TypeVar('CellImpl')\n\nclass Graph:\n    def __init__(self):\n        self.lock = Lock()\n        self.cells = {}\n\n    def register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n        \"\"\"\n        Add a cell to the graph.\n\n        Mutates the graph, acquiring `self.lock`.\n\n        Requires that `cell_id` is not already in the graph.\n        \"\"\"\n        with self.lock:\n            if cell_id in self.cells:\n                raise ValueError(f\"Cell with id {cell_id} already exists in the graph\")\n            self.cells[cell_id] = cell\n```"]}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check_for_errors(\n# Natural Language Annotations: \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    errors = {}\n    for cell in graph:\n        if cell['value'] == 'error':\n            errors[cell['id']] = 'Value is set to \"error\"'\n        if cell['value'] == 'undefined':\n            errors[cell['id']] = 'Value is undefined'\n        if cell['neighbors'] and not all(neighbor['value'] for neighbor in cell['neighbors']):\n            errors[cell['id']] = 'Neighbor values are inconsistent'\n    return errors\n```", "```python\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    errors = {}\n\n    # Check for self-loops\n    for node in graph:\n        if node in graph[node]:\n            errors[node] = \"Self-loop detected\"\n\n    # Check for multiple edges between two nodes\n    for node1 in graph:\n        for node2 in graph:\n            if node1 != node2 and node2 in graph[node1] and node1 in graph[node2]:\n                errors[node1] = \"Multiple edges detected between nodes\"\n                errors[node2] = \"Multiple edges detected between nodes\"\n\n    # Check for disconnected nodes\n    for node in graph:\n        if not graph[node]:\n            errors[node] = \"Disconnected node\"\n\n    # Check for unconnected graph\n    if not graph:\n        errors[\"graph\"] = \"Unconnected graph\"\n\n    return errors\n```", "```python\ndef check_for_errors(graph):\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    errors = {}\n\n    # Check for duplicate edges\n    for node in graph:\n        if len(graph[node]) != len(set(graph[node])):\n            errors[node] = \"Duplicate edge\"\n\n    # Check for self-loops\n    for node in graph:\n        if node in graph[node]:\n            errors[node] = \"Self-loop\"\n\n    # Check for nodes with no edges\n    for node in graph:\n        if not graph[node]:\n            errors[node] = \"No edges\"\n\n    # Check for nodes with more than 3 edges\n    for node in graph:\n        if len(graph[node]) > 3:\n            errors[node] = \"More than 3 edges\"\n\n    return errors\n```"]}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _maybe_register_cell(\n# Natural Language Annotations: \"\"\"Register a cell (given by id, code) if not already registered.\n\n        If a cell with id `cell_id` is already registered but with different\n        code, that cell is deleted from the graph and a new cell with the\n        same id but different code is registered.\n\n        Returns:\n        - a set of ids for cells that were previously children of `cell_id`;\n          only non-empty when `cell-id` was already registered but with\n          different code.\n        - an `Error` if the cell couldn't be registered, `None` otherwise\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _maybe_register_cell(graph, cell_id, code):\n    \"\"\"\n    Register a cell (given by id, code) if not already registered.\n\n    If a cell with id `cell_id` is already registered but with different\n    code, that cell is deleted from the graph and a new cell with the\n    same id but different code is registered.\n\n    Returns:\n    - a set of ids for cells that were previously children of `cell_id`;\n      only non-empty when `cell-id` was already registered but with\n      different code.\n    - an `Error` if the cell couldn't be registered, `None` otherwise\n    \"\"\"\n    if cell_id in graph:\n        if graph[cell_id] != code:\n            children = set(graph.get(cell_id, {}).get('children', []))\n            del graph[cell_id]\n            graph[cell_id] = {'code': code, 'children': children}\n            return children\n        else:\n            return None\n    else:\n        graph[cell_id] = {'code': code, 'children': set()}\n        return None\n```", "```python\ndef _maybe_register_cell(cell_id, code, graph):\n    \"\"\"\n    Register a cell (given by id, code) if not already registered.\n\n    If a cell with id `cell_id` is already registered but with different\n    code, that cell is deleted from the graph and a new cell with the\n    same id but different code is registered.\n\n    Returns:\n    - a set of ids for cells that were previously children of `cell_id`;\n      only non-empty when `cell-id` was already registered but with\n      different code.\n    - an `Error` if the cell couldn't be registered, `None` otherwise\n    \"\"\"\n    if cell_id in graph:\n        if graph[cell_id]['code'] == code:\n            return None\n        else:\n            children = graph[cell_id]['children']\n            del graph[cell_id]\n            graph[cell_id] = {'code': code, 'children': children}\n            return children\n    else:\n        graph[cell_id] = {'code': code, 'children': set()}\n        return set()\n```", "```python\ndef _maybe_register_cell(graph, cell_id, code):\n    if cell_id in graph:\n        if graph[cell_id] != code:\n            children = set(graph.keys()).difference({cell_id})\n            del graph[cell_id]\n            graph[cell_id] = code\n            return children\n        else:\n            return None\n    else:\n        graph[cell_id] = code\n        return None\n```"]}, "marimo-marimo/_runtime/runtime.py-run": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run(\n# Natural Language Annotations: \"\"\"Run cells and their descendants.\n\n\n        The cells may be cells already existing in the graph or new cells.\n        Adds the cells in `execution_requests` to the graph before running\n        them.\n\n        Cells may use top-level await, which is why this function is async.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def run(execution_requests, graph):\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    for request in execution_requests:\n        if request.id not in graph:\n            graph.add_cell(request)\n        await run_descendants(graph.get_cell(request.id))\n    await run_cells(graph)\n```", "```python\nasync def run(\n    graph: AnyGraph,\n    execution_requests: List[Cell],\n    cell_id_generator: Optional[CellIdGenerator] = None\n) -> None:\n    \"\"\"\n    Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    if cell_id_generator is None:\n        cell_id_generator = DefaultCellIdGenerator()\n    \n    # Add new cells to the graph\n    for request in execution_requests:\n        graph.add_cell(request, cell_id_generator)\n    \n    # Run cells and their descendants\n    for cell in graph.cells.values():\n        await cell.execute()\n```", "```python\nasync def run(execution_requests, graph):\n    \"\"\"\n    Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    for request in execution_requests:\n        if request not in graph:\n            graph.add_request(request)\n        await graph.run(request)\n```"]}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_python_isolated() -> bool:\n# Natural Language Annotations: \"\"\"Returns True if not using system Python\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nimport sys\ndef is_python_isolated() -> bool:\n    \"\"\"\n    Returns True if not using system Python\n    \"\"\"\n    return sys.base_prefix != sys.prefix\n```", "```\nimport sys\nimport os\n\ndef is_python_isolated() -> bool:\n    \"\"\"\n    Returns True if not using system Python\n    \"\"\"\n    return sys.prefix != sys.base_prefix\n```", "```python\nimport sys\nimport os\n\ndef is_python_isolated() -> bool:\n    \"\"\"\n    Returns True if not using system Python\n    \"\"\"\n    return os.path.dirname(sys.executable) != os.getcwd()\n```"]}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def missing_modules(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Modules that will fail to import.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"\n    Modules that will fail to import.\n    \"\"\"\n    return {\"module1\", \"module2\", \"module3\"}  # Replace with actual module names that fail to import\n```", "```python\nimport importlib.util\nimport sys\n\ndef missing_modules(self) -> set[str]:\n    \"\"\"\n    Modules that will fail to import.\n    \"\"\"\n    missing = set()\n    for module in sys.builtin_module_names:\n        try:\n            spec = importlib.util.find_spec(module)\n            if spec is None:\n                missing.add(module)\n        except ImportError:\n            missing.add(module)\n    return missing\n```", "```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"\n    Modules that will fail to import.\n    \n    Returns:\n        set[str]: A set of modules that will fail to import.\n    \"\"\"\n    # Define a set of modules that will fail to import\n    failed_modules = {\n        \"non_existent_module\",  # A module that doesn't exist\n        \"math\",  # The math module is a built-in module and will not fail to import\n        \"numpy\",  # The numpy module is a third-party module and will not fail to import\n        \"non_existent_package.module\",  # A module from a non-existent package\n        \"non_existent_submodule\",  # A submodule from a non-existent module\n    }\n    \n    # Return the set of modules that will fail to import\n    return failed_modules\n```"]}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def load_examples(\n# Natural Language Annotations: \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport os\nimport json\n\ndef load_examples(folder, role_set):\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder (str): the folder path.\n        role_set (list): the roles should be included in the examples.\n\n    Returns:\n        dict: a dictionary where the keys are the example names and the values are the examples.\n    \"\"\"\n    examples = {}\n    for filename in os.listdir(folder):\n        if filename.endswith(\".json\"):\n            with open(os.path.join(folder, filename), 'r') as f:\n                example = json.load(f)\n                if set(example['roles']) & set(role_set):\n                    examples[filename] = example\n    return examples\n```", "```python\nimport os\nimport json\n\ndef load_examples(folder, role_set):\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder (str): the folder path.\n        role_set (list): the roles should be included in the examples.\n\n    Returns:\n        list: a list of examples.\n    \"\"\"\n    examples = []\n    for file in os.listdir(folder):\n        if file.endswith('.json'):\n            with open(os.path.join(folder, file), 'r') as f:\n                data = json.load(f)\n                if set(data['roles']) & set(role_set):\n                    examples.append(data)\n    return examples\n```", "```python\nimport json\nimport os\n\ndef load_examples(folder, role_set):\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder (str): the folder path.\n        role_set (list): the roles should be included in the examples.\n\n    Returns:\n        list: a list of examples.\n    \"\"\"\n    examples = []\n    for filename in os.listdir(folder):\n        if filename.endswith(\".json\"):\n            with open(os.path.join(folder, filename), 'r') as file:\n                example = json.load(file)\n                if set(example['roles']) & set(role_set):\n                    examples.append(example)\n    return examples\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n# Natural Language Annotations: \"\"\"\n        Add selected plugins to the pool\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    for plugin in self.selected_plugins:\n        if plugin not in external_plugin_pool:\n            external_plugin_pool.append(plugin)\n```", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]) -> None:\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    for plugin in external_plugin_pool:\n        if plugin.is_selected:\n            self.plugin_pool.append(plugin)\n```", "```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]) -> None:\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    if not isinstance(external_plugin_pool, list):\n        raise TypeError(\"external_plugin_pool must be a list\")\n    for plugin in external_plugin_pool:\n        if not isinstance(plugin, PluginEntry):\n            raise ValueError(\"All elements in external_plugin_pool must be PluginEntry instances\")\n        # Add the plugin to the pool here\n        # For example, you might add it to a set or list of plugins\n        self.plugin_pool.add(plugin)\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def filter_unused_plugins(self, code: str):\n# Natural Language Annotations: \"\"\"\n        Filter out plugins that are not used in the code generated by LLM\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n    \"\"\"\n    plugins = {\n        \"plugin1\": \"from plugin1 import func1\",\n        \"plugin2\": \"from plugin2 import func2\",\n        \"plugin3\": \"from plugin3 import func3\"\n    }\n\n    used_plugins = set()\n\n    for line in code.split(\"\\n\"):\n        for plugin, import_statement in plugins.items():\n            if import_statement in line:\n                used_plugins.add(plugin)\n\n    return \"```\" + \"\\n\".join([plugin for plugin in plugins if plugin in used_plugins]) + \"```\"\n```", "```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n    \"\"\"\n    # Remove all comments from the code\n    code = ''.join(line for line in code.split('\\n') if not line.strip().startswith('#'))\n\n    # Split the code into individual lines\n    lines = code.split('\\n')\n\n    # Initialize a set to store the used plugins\n    used_plugins = set()\n\n    # Iterate over each line of code\n    for line in lines:\n        # Check if the line contains any import statements\n        if 'import' in line or 'from' in line:\n            # Extract the plugin name from the import statement\n            plugin = line.split(' ')[1].split('.')[0]\n            # Add the plugin to the set of used plugins\n            used_plugins.add(plugin)\n\n    # Initialize a list to store the filtered code\n    filtered_code = []\n\n    # Iterate over each line of code\n    for line in lines:\n        # Check if the line contains a plugin that is not used\n        if not any(plugin in line for plugin in used_plugins):\n            # Add the line to the filtered code\n            filtered_code.append(line)\n\n    # Join the filtered code into a string\n    filtered_code = '\\n'.join(filtered_code)\n\n    # Return the filtered code surrounded by triple quotes\n    return f\"```\\n{filtered_code}\\n```\"\n```", "```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n    \"\"\"\n    # Assuming plugin names are defined as strings in the format 'plugin_name'\n    plugin_names = set()\n    \n    # Initialize an empty list to store used plugins\n    used_plugins = []\n    \n    # Parse the code to find plugin names\n    for line in code.split('\\n'):\n        for word in line.split():\n            if word.startswith('plugin_'):\n                plugin_names.add(word)\n    \n    # Filter out unused plugins\n    for plugin in plugin_names:\n        if plugin in code:\n            used_plugins.append(plugin)\n    \n    return code.replace('\\n', '').replace('\\t', '').replace('\\r', '').replace(' ', '').replace(plugin_name, '').replace('plugin_', '') for plugin_name in plugin_names - set(used_plugins))```"]}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def remove_all_delimiters(text: str) -> str:\n# Natural Language Annotations: \"\"\"Remove all the delimiters from the text.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"\n    Remove all the delimiters from the text.\n    \n    This function takes a string as input, removes all the delimiters (such as punctuation marks, \n    whitespace characters, and special characters) and returns the resulting string.\n    \n    Parameters:\n    text (str): The input string from which delimiters are to be removed.\n    \n    Returns:\n    str: The input string with all delimiters removed.\n    \"\"\"\n    import re\n    return re.sub(r'[^\\w\\s]', '', text)\n```", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"\n    Remove all the delimiters from the text.\n    \n    Args:\n        text (str): The input text\n    \n    Returns:\n        str: The text with all delimiters removed\n    \"\"\"\n    return ''.join(c for c in text if c not in ['!', '.', '?', ',', ';', ':', '\"', \"'\", '(', ')', '[', ']', '{', '}'])\n```", "```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    return ''.join([char for char in text if not char in [' ', '\\n', '\\t', ',', '.', '?', '!', ':', ';', '\"', \"'\", '(', ')', '[', ']'])\n```"]}, "reflex-reflex/app.py-_enable_state": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _enable_state(self) -> None:\n# Natural Language Annotations: \"\"\"Enable state for the app.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    # Add your code here to enable the state for the app\n    # For example:\n    self._enabled = True\n    print(\"State enabled successfully.\")\n```", "```python\ndef _enable_state(self) -> None:\n    \"\"\"\n    Enable state for the app.\n    \"\"\"\n    # TO DO: implement state enabling logic here\n    pass\n```", "```python\ndef _enable_state(self) -> None:\n    \"\"\"\n    Enable state for the app.\n    \"\"\"\n    self.enabled = True\n```"]}, "reflex-reflex/app.py-_add_optional_endpoints": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_optional_endpoints(self):\n# Natural Language Annotations: \"\"\"Add optional api endpoints (_upload).\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _add_optional_endpoints(self):\n    \"\"\"\n    Add optional api endpoints (_upload).\n    \"\"\"\n    # Define a new endpoint for uploading files\n    self.app.add_api_route('/upload', self.upload_file, methods=['POST'])\n\n    # Define a new endpoint for uploading files with optional parameters\n    self.app.add_api_route('/upload/<string:file_name>', self.upload_file_optional, methods=['POST'])\n```", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"Add optional api endpoints (_upload).\"\"\"\n    self._api_endpoints['upload'] = {\n        'method': 'POST',\n        'endpoint': '/upload',\n        'description': 'Upload a file',\n        'parameters': {\n            'file': {\n                'type': 'file',\n                'required': True,\n                'description': 'The file to be uploaded'\n            }\n        }\n    }\n```", "```python\ndef _add_optional_endpoints(self):\n    \"\"\"\n    Add optional api endpoints (_upload).\n    \"\"\"\n    endpoint_url = \"/api/upload\"\n    endpoint_method = \"POST\"\n    endpoint_params = [\n        {\"param_name\": \"file\", \"param_type\": \"file\"},\n        {\"param_name\": \"description\", \"param_type\": \"string\"}\n    ]\n    endpoint_body = {\n        \"file\": \"The file to be uploaded\",\n        \"description\": \"A brief description of the file\"\n    }\n    \n    # Add endpoint to API\n    self.api.add_endpoint(endpoint_url, endpoint_method, endpoint_params, endpoint_body)\n```"]}, "reflex-reflex/app.py-add_page": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_page(\n# Natural Language Annotations: \"\"\"Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef add_page(component, route=None, title=None, description=None, image=None, on_load=None, meta=None):\n    \"\"\"\n    Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    # Check if the route exists\n    if hasattr(self, 'routes') and route in self.routes:\n        raise ValueError(f\"Route '{route}' already exists.\")\n\n    # If component is a callable, get its name as the route\n    if callable(component):\n        route = component.__name__\n\n    # Store the page in the app\n    self.routes[route] = {\n        'component': component,\n        'title': title,\n        'description': description,\n        'image': image,\n        'on_load': on_load,\n        'meta': meta\n    }\n```", "```python\nclass App:\n    def __init__(self):\n        self.pages = {}\n\n    def add_page(self, component, route=None, title=None, description=None, image=None, on_load=None, meta=None):\n        \"\"\"\n        Add a page to the app.\n\n        If the component is a callable, by default the route is the name of the\n        function. Otherwise, a route must be provided.\n\n        Args:\n            component: The component to display at the page.\n            route: The route to display the component at.\n            title: The title of the page.\n            description: The description of the page.\n            image: The image to display on the page.\n            on_load: The event handler(s) that will be called each time the page load.\n            meta: The metadata of the page.\n\n        Raises:\n            ValueError: When the specified route name already exists.\n        \"\"\"\n        if callable(component):\n            if route is None:\n                route = component.__name__\n            elif route in self.pages:\n                raise ValueError(\"Route already exists\")\n        else:\n            if route is None:\n                raise ValueError(\"Route must be provided for non-callable components\")\n            if route in self.pages:\n                raise ValueError(\"Route already exists\")\n\n        self.pages[route] = {\n            'component': component,\n            'title': title,\n            'description': description,\n            'image': image,\n            'on_load': on_load,\n            'meta': meta\n        }\n```", "```python\ndef add_page(component, route=None, title='', description='', image='', on_load=None, meta=None):\n    \"\"\"\n    Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    if hasattr(component, '__name__'):\n        route = component.__name__ if route is None else route\n    else:\n        if route is None:\n            raise ValueError(\"Route must be provided for non-callable components\")\n    \n    # Check if the route already exists\n    # (This part is not implemented as it depends on the actual data structure used to store routes)\n    # For demonstration purposes, let's assume we have a dictionary to store routes\n    if route in pages:\n        raise ValueError(f\"Route '{route}' already exists\")\n\n    # Create a new page\n    page = {\n        'component': component,\n        'route': route,\n        'title': title,\n        'description': description,\n        'image': image,\n        'on_load': on_load,\n        'meta': meta\n    }\n\n    # Add the page to the app\n    pages[route] = page\n```"]}, "reflex-reflex/app.py-_setup_overlay_component": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _setup_overlay_component(self):\n# Natural Language Annotations: \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _setup_overlay_component(self):\n    \"\"\"\n    If a State is not used and no overlay_component is specified, do not render the connection modal.\n    \"\"\"\n    if not self.state_used and not self.overlay_component:\n        return None\n    # Add your rendering logic here\n    # For example:\n    return self.render_overlay_component()\n```", "```python\ndef _setup_overlay_component(self):\n    \"\"\"\n    If a State is not used and no overlay_component is specified, do not render the connection modal.\n    \"\"\"\n    if not self.state and not hasattr(self, 'overlay_component'):\n        self.render_connection_modal = False\n    else:\n        self.render_connection_modal = True\n```", "```python\ndef _setup_overlay_component(self):\n    if not self.state.is_used and not self.overlay_component:\n        return None\n    # rest of the function implementation...\n```"]}, "reflex-reflex/app.py-_compile": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _compile(self, export: bool = False):\n# Natural Language Annotations: \"\"\"Compile the app and output it to the pages folder.\n\n        Args:\n            export: Whether to compile the app for export.\n\n        Raises:\n            ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _compile(self, export: bool = False):\n    \"\"\"\n    Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    if export:\n        self.compile_export()\n    else:\n        self.compile_dev()\n    self.write_pages()\n```", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"\n    Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    if export:\n        # Export compilation logic\n        self.pages = self.compile_pages()\n        self.export_pages()\n    else:\n        # Local compilation logic\n        self.pages = self.compile_pages()\n        self.write_pages()\n    \n    # Check for state usage\n    for page in self.pages:\n        if hasattr(page, 'state') and not issubclass(page.state, rx.State):\n            raise ReflexRuntimeError(\"Page {} uses state, but no rx.State subclass is defined\".format(page))\n```", "```python\ndef _compile(self, export: bool = False):\n    \"\"\"\n    Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    # Check if any page uses state but no rx.State subclass is defined\n    if self.pages and any(page.state and not isinstance(page.state, rx.State) for page in self.pages):\n        raise ReflexRuntimeError(\"Page uses state, but no rx.State subclass is defined\")\n\n    # Compile the app\n    self._compile_pages()\n\n    # If export is True, export the compiled app\n    if export:\n        self._export()\n\n    # Output the compiled app to the pages folder\n    self._output_to_pages_folder()\n```"]}, "reflex-reflex/app.py-modify_state": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n# Natural Language Annotations: \"\"\"Modify the state out of band.\n\n        Args:\n            token: The token to modify the state for.\n\n        Yields:\n            The state to modify.\n\n        Raises:\n            RuntimeError: If the app has not been initialized yet.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not hasattr(self, 'initialized'):\n        raise RuntimeError(\"App has not been initialized yet\")\n\n    # Initialize the state\n    state = BaseState(token)\n\n    # Perform the modification (example: add a new field to the state)\n    state.modified_field = \"modified_value\"\n\n    yield state\n```", "```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not hasattr(self, 'initialized'):\n        raise RuntimeError(\"App has not been initialized yet\")\n    \n    # Fetch the state from the database or cache\n    state = await self.get_state(token)\n    \n    # Modify the state\n    # For demonstration, let's assume we're modifying the state by adding a new key-value pair\n    state[token] = {'modified': True}\n    \n    # Yield the modified state\n    yield state\n```", "```python\nasync def modify_state(self, token: str) -> AsyncIterator['BaseState']:\n    \"\"\"\n    Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if not self.app_initialized:\n        raise RuntimeError(\"App has not been initialized yet\")\n    # Perform state modification logic here\n    # For demonstration purposes, yield a sample state\n    yield BaseState()\n```"]}, "reflex-reflex/vars.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create a var from a value.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n\n        Raises:\n            VarTypeError: If the value is JSON-unserializable.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport json\n\nclass VarTypeError(Exception):\n    pass\n\ndef create(value, _var_is_local, _var_is_string, _var_data):\n    try:\n        var = json.dumps(value) if _var_is_string else value\n        return var\n    except TypeError:\n        raise VarTypeError(\"Value is JSON-unserializable\")\n```", "```python\ndef create(value, _var_is_local, _var_is_string, _var_data):\n    \"\"\"\n    Create a var from a value.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n\n    Raises:\n        VarTypeError: If the value is JSON-unserializable.\n    \"\"\"\n    try:\n        import json\n        json.dumps(value)\n    except TypeError:\n        raise VarTypeError(\"Value is JSON-unserializable\")\n\n    if _var_is_string:\n        return f\"'{value}'\"\n    else:\n        return value\n```", "```python\nimport json\n\nclass VarTypeError(Exception):\n    pass\n\ndef create(value, _var_is_local, _var_is_string, _var_data):\n    try:\n        if _var_is_string:\n            return str(value)\n        elif _var_is_local:\n            return value\n        else:\n            return value\n    except TypeError:\n        raise VarTypeError(\"Value is JSON-unserializable\")\n```"]}, "reflex-reflex/vars.py-create_safe": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create_safe(\n# Natural Language Annotations: \"\"\"Create a var from a value, asserting that it is not None.\n\n        Args:\n            value: The value to create the var from.\n            _var_is_local: Whether the var is local.\n            _var_is_string: Whether the var is a string literal.\n            _var_data: Additional hooks and imports associated with the Var.\n\n        Returns:\n            The var.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef create_safe(value, _var_is_local, _var_is_string, _var_data):\n    \"\"\"\n    Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    assert value is not None, \"Value cannot be None\"\n    if _var_is_string:\n        return str(value)\n    else:\n        return value\n```", "```python\ndef create_safe(value, _var_is_local, _var_is_string, _var_data):\n    \"\"\"\n    Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    if value is None:\n        raise ValueError(\"Value cannot be None\")\n    if _var_is_string:\n        return str(value)\n    else:\n        return value\n```", "```python\ndef create_safe(value, _var_is_local, _var_is_string, _var_data):\n    \"\"\"\n    Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    if value is not None:\n        if _var_is_string:\n            return str(value)\n        else:\n            return value\n    else:\n        raise ValueError(\"Cannot create var from None\")\n```"]}, "reflex-reflex/vars.py-foreach": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def foreach(self, fn: Callable) -> Var:\n# Natural Language Annotations: \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Callable, TypeVar, List\n\nT = TypeVar('T')\n\nclass Var:\n    def __init__(self, value: List[T]):\n        self.value = value\n\n    def foreach(self, fn: Callable[[T], T]) -> 'Var[List[T]]':\n        \"\"\"Return a list of components. after doing a foreach on this var.\n\n        Args:\n            fn: The function to call on each component.\n\n        Returns:\n            A var representing foreach operation.\n\n        Raises:\n            VarTypeError: If the var is not a list.\n        \"\"\"\n        if not isinstance(self.value, list):\n            raise TypeError(\"Var is not a list\")\n        return Var([fn(item) for item in self.value])\n```", "```python\nfrom typing import Callable, TypeVar\n\nVar = TypeVar('Var')\nT = TypeVar('T')\n\ndef foreach(self, fn: Callable[[Var], T]) -> 'Var':\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not isinstance(self, list):\n        raise TypeError(\"VarTypeError: Var is not a list\")\n    return [fn(i) for i in self]\n```", "```python\nfrom typing import Callable, Var\n\ndef foreach(self, fn: Callable) -> 'Var':\n    \"\"\"\n    Return a list of components. after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    if not isinstance(self, list):\n        raise VarTypeError(\"Var is not a list\")\n    return [fn(i) for i in self]\n```"]}, "reflex-reflex/vars.py-get_default_value": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_default_value(self) -> Any:\n# Natural Language Annotations: \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any\nimport pandas as pd\n\nclass DefaultValueGetter:\n    def __init__(self, var):\n        self.var = var\n\n    def get_default_value(self) -> Any:\n        \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\n        if isinstance(self.var, pd.DataFrame):\n            try:\n                import pandas as pd\n            except ImportError:\n                raise ImportError(\"pandas is not installed to access default value of dataframe\")\n            return self.var\n        else:\n            return self.var.default_value\n```", "```python\nfrom typing import Any\nimport pandas as pd\n\nclass DefaultValueGetter:\n    def __init__(self, var):\n        self.var = var\n\n    def get_default_value(self) -> Any:\n        \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\n        if hasattr(self.var, 'shape') and not hasattr(self.var, 'to_numpy'):\n            raise ImportError(\"pandas is not installed\")\n        return self.var\n```", "```python\nfrom typing import Any\nimport pandas as pd\n\nclass DefaultValueGetter:\n    def __init__(self, var):\n        self.var = var\n\n    def get_default_value(self) -> Any:\n        \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\n        try:\n            return self.var.default_value\n        except AttributeError:\n            try:\n                if isinstance(self.var, pd.DataFrame):\n                    import pandas as pd\n                    raise ImportError(\"pandas is not installed\")\n                else:\n                    return self.var\n            except NameError:\n                return self.var\n```"]}, "reflex-reflex/state.py-get_skip_vars": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_skip_vars(cls) -> set[str]:\n# Natural Language Annotations: \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    return set(dir(cls)) - set(dir(object))\n```", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"\n    Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    return set(dir(cls)) - set(dir(object))\n```", "```python\ndef get_skip_vars(cls) -> set[str]:\n    \"\"\"\n    Get the vars to skip when serializing.\n\n    Returns:\n        The vars to skip when serializing.\n    \"\"\"\n    return set(dir(cls)) - set(dir(object))\n```"]}, "reflex-reflex/state.py-add_var": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_var(cls, name: str, type_: Any, default_value: Any = None):\n# Natural Language Annotations: \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass State:\n    def __init__(self):\n        self.variables = {}\n\n    def add_var(cls, name: str, type_, default_value: Any = None):\n        \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\n        if name in cls.variables:\n            raise NameError(f\"A variable with the name '{name}' already exists\")\n        cls.variables[name] = (type_, default_value)\n\n    def __getattr__(cls, name: str):\n        if name in cls.variables:\n            type_, default_value = cls.variables[name]\n            return default_value\n        raise AttributeError(f\"No attribute '{name}' exists\")\n\ndef main():\n    state = State()\n    state.add_var('x', int, 5)\n    print(state.x)  # prints: 5\n    state.add_var('y', str, 'hello')\n    print(state.y)  # prints: hello\n    try:\n        state.add_var('x', float, 3.14)  # raises NameError\n    except NameError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()\n```", "```python\nclass State:\n    def __init__(self):\n        self._vars = {}\n\n    def add_var(self, name: str, type_: type, default_value: any = None):\n        \"\"\"Add dynamically a variable to the State.\n\n        The variable added this way can be used in the same way as a variable\n        defined statically in the model.\n\n        Args:\n            name: The name of the variable\n            type_: The type of the variable\n            default_value: The default value of the variable\n\n        Raises:\n            NameError: if a variable of this name already exists\n        \"\"\"\n        if name in self._vars:\n            raise NameError(f\"Variable '{name}' already exists\")\n        self._vars[name] = (type_, default_value)\n\n    def __getattr__(self, name: str):\n        if name in self._vars:\n            type_, default_value = self._vars[name]\n            return default_value if default_value is not None else type_()\n        raise AttributeError(f\"Variable '{name}' does not exist\")\n\n    def __setattr__(self, name: str, value):\n        if name.startswith(\"_\"):\n            super().__setattr__(name, value)\n        elif name in self._vars:\n            type_, _ = self._vars[name]\n            if not isinstance(value, type_):\n                raise TypeError(f\"Expected type {type_} for variable '{name}', but got {type(value)}\")\n            self._vars[name] = (type_, value)\n        else:\n            super().__setattr__(name, value)\n\n# Example usage:\nstate = State()\nstate.add_var('x', int, 10)\nprint(state.x)  # prints: 10\nstate.x = 20\nprint(state.x)  # prints: 20\nstate.add_var('y', str)\nstate.y = 'hello'\nprint(state.y)  # prints: hello\n```", "```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if hasattr(cls, name):\n        raise NameError(f\"A variable with the name '{name}' already exists\")\n    setattr(cls, name, type_(default_value))\n```"]}, "reflex-reflex/state.py-reset": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def reset(self):\n# Natural Language Annotations: \"\"\"Reset all the base vars to their default values.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef reset(self):\n    \"\"\"\n    Reset all the base vars to their default values.\n    \"\"\"\n    # TO DO: implement resetting of base vars\n    pass\n```", "```python\ndef reset(self):\n    \"\"\"\n    Reset all the base vars to their default values.\n    \"\"\"\n    # TO DO: implement resetting of base vars\n    pass\n```", "```\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    self.base_var1 = None\n    self.base_var2 = None\n    self.base_var3 = None\n    # Add more base vars as needed\n```"]}, "reflex-reflex/state.py-get_state": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n# Natural Language Annotations: \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    client_token = self.client_token\n    state = await self.client.get_state(client_token, state_cls)\n    return state\n```", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"\n    Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    return await self.client.get_state(state_cls)\n```", "```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n        Allows for arbitrary access to sibling states from within an event handler.\n\n        Args:\n            state_cls: The class of the state.\n\n        Returns:\n            The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    client_token = self.client_token\n    return self.client.get_state(client_token, state_cls)\n```"]}, "reflex-reflex/state.py-_process": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n# Natural Language Annotations: \"\"\"Obtain event info and process event.\n\n        Args:\n            event: The event to process.\n\n        Yields:\n            The state update after processing the event.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Obtain event info\n    event_info = await self._obtain_event_info(event)\n    \n    # Process event\n    state_update = await self._process_event(event_info)\n    \n    # Yield state update\n    yield state_update\n```", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"\n    Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Get event info\n    event_info = await self._get_event_info(event)\n\n    # Process event\n    state_update = await self._process_event(event_info)\n\n    # Yield state update\n    yield state_update\n```", "```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Handle the event and process its information\n    # For example, let's assume we're updating a counter\n    counter = getattr(self, 'counter', 0)\n    counter += 1\n    # Yield the state update\n    yield StateUpdate(counter=counter)\n```"]}, "reflex-reflex/state.py-_dirty_computed_vars": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _dirty_computed_vars(\n# Natural Language Annotations: \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _dirty_computed_vars(dirty_vars=None, from_vars=None, include_backend=False):\n    \"\"\"\n    Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = dirty_vars\n    else:\n        dirty_vars = dirty_vars or set()\n    computed_vars = set()\n    for var in from_vars:\n        # assuming we have a function to get dependencies of a var\n        dependencies = get_dependencies(var)\n        if include_backend:\n            dependencies = dependencies.union(get_backend_dependencies(var))\n        computed_vars.update(dependencies)\n    return computed_vars\n```", "```python\ndef _dirty_computed_vars(dirty_vars=None, from_vars=None, include_backend=False):\n    \"\"\"\n    Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars (set): find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend (bool): whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = dirty_vars  # assuming dirty_vars is a set\n    computed_vars = set()\n    for var in from_vars:\n        # assuming we have a function get_dependencies that returns a set of vars a computed var depends on\n        dependencies = get_dependencies(var, include_backend)\n        computed_vars.update(get_computed_vars(dependencies))\n    return computed_vars\n\ndef get_dependencies(var, include_backend):\n    # assuming we have a dictionary of dependencies where each key is a var and its value is a set of vars it depends on\n    dependencies = get_dependency_dict()\n    return dependencies.get(var, set()) | (dependencies.get('backend', set()) if include_backend else set())\n\ndef get_computed_vars(vars):\n    # assuming we have a dictionary of computed vars where each key is a var and its value is a set of computed vars it depends on\n    computed_vars_dict = get_computed_vars_dict()\n    return {var for var in vars for computed_var in computed_vars_dict.get(var, set())}\n\ndef get_dependency_dict():\n    # this function should return a dictionary of dependencies where each key is a var and its value is a set of vars it depends on\n    # for example:\n    return {\n        'var1': {'var2', 'var3'},\n        'var2': {'var4'},\n        'var3': set(),\n        'var4': set(),\n        'backend': {'var1', 'var2'}\n    }\n\ndef get_computed_vars_dict():\n    # this function should return a dictionary of computed vars where each key is a var and its value is a set of computed vars it depends on\n    # for example:\n    return {\n        'var1': {'comp1', 'comp2'},\n        'var2': {'comp3'},\n        'var3': set(),\n        'var4': set(),\n        'comp1': set(),\n        'comp2': set(),\n        'comp3': set()\n    }\n```", "```python\ndef _dirty_computed_vars(dirty_vars=None, from_vars=None, include_backend=False):\n    \"\"\"\n    Determine ComputedVars that need to be recalculated based on the given vars.\n\n    Args:\n        from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n        include_backend: whether to include backend vars in the calculation.\n\n    Returns:\n        Set of computed vars to include in the delta.\n    \"\"\"\n    if from_vars is None:\n        from_vars = dirty_vars\n    if from_vars is None:\n        from_vars = set()\n    if include_backend:\n        # assuming backend_vars is a global variable or a class attribute\n        from_vars = from_vars.union(backend_vars)\n    computed_vars = set()\n    for var in from_vars:\n        # assuming get_dependencies is a method of the ComputedVar class\n        # that returns a set of variables that a ComputedVar depends on\n        computed_vars.update(var.get_dependencies())\n    return computed_vars\n```"]}, "reflex-reflex/state.py-_potentially_dirty_substates": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n# Natural Language Annotations: \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n        Returns:\n            Set of State classes that may need to be fetched to recalc computed vars.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Set, Type\n\nclass BaseState:\n    pass\n\ndef _potentially_dirty_substates(cls: Type[BaseState]) -> Set[Type[BaseState]]:\n    dirty_vars = cls.dirty_vars  # assuming cls has a class attribute 'dirty_vars'\n    substates = set()\n    for substate in cls.__subclasses__():\n        if hasattr(substate, 'dirty_vars'):\n            if any(var in dirty_vars for var in substate.dirty_vars):\n                substates.add(substate)\n        else:\n            substates.update(_potentially_dirty_substates(substate))\n    return substates\n```", "```python\nfrom typing import Set, Type\n\nclass BaseState:\n    pass\n\ndef _potentially_dirty_substates(cls) -> Set[Type[BaseState]]:\n    \"\"\"\n    Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    # Assuming we have a dictionary that maps a state class to its substates\n    state_dependencies = {\n        'StateA': {'SubStateA1', 'SubStateA2'},\n        'StateB': {'SubStateB1'},\n        'SubStateA1': {'SubStateA1SubState1'},\n        'SubStateA2': {'SubStateA2SubState1'},\n        'SubStateB1': {'SubStateB1SubState1'}\n    }\n\n    # Get the set of substates for the given class\n    substates = state_dependencies.get(cls.__name__, set())\n    \n    # Recursively add substates of substates\n    substates |= {substate for substates in (state_dependencies.get(substate, set()) for substate in substates) for substate in substates}\n    \n    return substates\n```", "```python\nfrom typing import Type, Set, TypeVar\n\nfrom . import BaseState\n\nT = TypeVar('T', bound=BaseState)\n\ndef _potentially_dirty_substates(cls: type[T]) -> Set[Type[T]]:\n    \"\"\"\n    Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    # For demonstration purposes, let's assume we have a function to get the substates\n    substates = get_substates(cls)\n    # We'll assume that a substate is potentially dirty if it has any variables in common with the current state\n    potentially_dirty = {substate for substate in substates if any(var in cls.__dict__ for var in substate.__dict__)}\n    return potentially_dirty\n```"]}, "reflex-reflex/state.py-get_delta": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_delta(self) -> Delta:\n# Natural Language Annotations: \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\ndef get_delta(self) -> Delta:\n    return self._delta\n```", "```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Delta:\n    value: float\n\nclass State:\n    def __init__(self, value: float):\n        self.value = value\n\n    def get_delta(self) -> Delta:\n        \"\"\"Get the delta for the state.\n\n        Returns:\n            The delta for the state.\n        \"\"\"\n        return Delta(self.value)\n```", "```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    return self._delta\n```"]}, "reflex-reflex/model.py-get_db_engine": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_db_engine():\n# Natural Language Annotations: \"\"\"Get the database engine.\n\n        Returns:\n            The database engine.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom sqlalchemy import create_engine\n\ndef get_db_engine():\n    \"\"\"\n    Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    return create_engine('sqlite:///example.db')\n```", "```python\nfrom sqlalchemy import create_engine\n\ndef get_db_engine():\n    \"\"\"\n    Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    db_url = \"sqlite:///example.db\"  # replace with your actual database URL\n    return create_engine(db_url)\n```", "```python\nfrom sqlalchemy import create_engine\n\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    engine = create_engine('sqlite:///example.db')\n    return engine\n```"]}, "reflex-reflex/model.py-alembic_autogenerate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def alembic_autogenerate(\n# Natural Language Annotations: \"\"\"Generate migration scripts for alembic-detectable changes.\n\n        Args:\n            connection: SQLAlchemy connection to use when detecting changes.\n            message: Human readable identifier describing the generated revision.\n            write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n        Returns:\n            True when changes have been detected.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom alembic import command\nfrom alembic.config import Config\nfrom sqlalchemy import engine_from_config\n\ndef alembic_autogenerate(connection, message, write_migration_scripts=True):\n    \"\"\"\n    Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    alembic_cfg = Config()\n    alembic_cfg.attributes['connection'] = connection\n    command.stamp(alembic_cfg, 'head', sql=True, message=message)\n    command.current(alembic_cfg)\n    command.revision(alembic_cfg, message=message, autogenerate=True, sql=True)\n    if write_migration_scripts:\n        command.upgrade(alembic_cfg, 'head')\n    return True\n```", "```\nfrom alembic import command\nfrom alembic import command as alembic_command\nfrom alembic import config\nfrom alembic import op\nfrom sqlalchemy import engine_from_config\n\ndef alembic_autogenerate(connection, message, write_migration_scripts=True):\n    \"\"\"\n    Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    config = config.Config()\n    config.set_main_option('sqlalchemy.url', str(connection.url))\n    command.stamp(config, 'head', sql=write_migration_scripts)\n    revision = op.get_current_revision()\n    alembic_command.rev_spec = f\"{revision}~\"\n    command.autogenerate(config, message=message, sql=write_migration_scripts)\n    return True\n```", "```\nfrom alembic import op\nfrom alembic import command\nfrom sqlalchemy import engine_from_config\n\ndef alembic_autogenerate(connection, message, write_migration_scripts=True):\n    command.stamp(connection, message, sql=write_migration_scripts)\n    command.revision(autogenerate=True, message=message, sql=write_migration_scripts)\n    return True\n```"]}, "reflex-reflex/model.py-migrate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def migrate(cls, autogenerate: bool = False) -> bool | None:\n# Natural Language Annotations: \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n        If alembic is not installed or has not been initialized for the project,\n        then no action is performed.\n\n        If there are no revisions currently tracked by alembic, then\n        an initial revision will be created based on sqlmodel metadata.\n\n        If models in the app have changed in incompatible ways that alembic\n        cannot automatically generate revisions for, the app may not be able to\n        start up until migration scripts have been corrected by hand.\n\n        Args:\n            autogenerate: If True, generate migration script and use it to upgrade schema\n                (otherwise, just bring the schema to current \"head\" revision).\n\n        Returns:\n            True - indicating the process was successful.\n            None - indicating the process was skipped.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom alembic import command, config\nfrom sqlmodel import SQLModel\nimport importlib.util\nimport importlib.util\nimport os\n\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"\n    Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    # Check if alembic is installed\n    try:\n        importlib.import_module('alembic')\n    except ModuleNotFoundError:\n        print(\"Alembic is not installed. Skipping migration.\")\n        return None\n\n    # Check if alembic is initialized for the project\n    alembic_cfg = config.Config()\n    alembic_cfg.set_main_option('script_location', 'alembic')\n    alembic_cfg.set_main_option('sqlalchemy.url', 'sqlite:///app.db')\n    if not os.path.exists('alembic/versions'):\n        print(\"Alembic is not initialized for the project. Skipping migration.\")\n        return None\n\n    # Check if there are any revisions to apply\n    command.stamp(alembic_cfg, 'head')\n    revisions = command.revision(alembic_cfg, '--sql', '--autogenerate', '--autogenerate-output', 'alembic/versions/alembic_revision.py')\n    if revisions:\n        command.upgrade(alembic_cfg, 'head')\n        return True\n    elif autogenerate:\n        # Generate an initial revision\n        command.stamp(alembic_cfg, 'head')\n        command.revision(alembic_cfg, '--autogenerate', '--autogenerate-output', 'alembic/versions/alembic_revision.py')\n        command.upgrade(alembic_cfg, 'head')\n        return True\n    else:\n        # No revisions to apply, just bring the schema to current \"head\" revision\n        command.stamp(alembic_cfg, 'head')\n        return True\n```", "```python\nfrom alembic import command, config\nfrom sqlmodel import SQLModel\nimport importlib.util\nimport os\n\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"\n    Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    # Check if alembic is installed and initialized\n    if not os.path.exists('alembic.ini'):\n        return None\n\n    # Import alembic config\n    spec = importlib.util.spec_from_file_location(\"alembic_config\", \"alembic.ini\")\n    alembic_config = importlib.util.module_from_spec(spec)\n    spec.loader.exec_module(alembic_config)\n\n    # Check if there are any revisions tracked by alembic\n    if not command.get_current_head(alembic_config):\n        # If not, create an initial revision based on sqlmodel metadata\n        command.stamp(alembic_config, \"head\")\n        command.rev_id(alembic_config, \"base\")\n\n    try:\n        # Run alembic migrations\n        if autogenerate:\n            command.upgrade(alembic_config, \"head\", sqlalchemy_url='sqlite:///test.db')\n        else:\n            command.upgrade(alembic_config, \"head\")\n        return True\n    except Exception as e:\n        print(f\"Error running migrations: {e}\")\n        return None\n```", "```python\nfrom sqlalchemy import create_engine\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom alembic import command, config\nfrom alembic.config import Config\nfrom sqlmodel import SQLModel\nimport importlib.util\nimport sys\n\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"\n    Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    # Check if alembic is installed\n    if not importlib.util.find_spec('alembic'):\n        print(\"Alembic is not installed.\")\n        return None\n\n    # Initialize alembic config\n    alembic_cfg = Config(\"alembic.ini\")\n    alembic_cfg.attributes['connection'] = create_engine('sqlite:///test.db')\n\n    # Check if alembic has been initialized for the project\n    if not alembic_cfg.attributes.get('script_location'):\n        print(\"Alembic has not been initialized for the project.\")\n        return None\n\n    # Check if there are any revisions tracked by alembic\n    if not command.get_current_revision(alembic_cfg):\n        # Create an initial revision based on sqlmodel metadata\n        command.stamp(alembic_cfg, 'head')\n        command.current(alembic_cfg)\n\n    # If autogenerate is True, generate migration script and use it to upgrade schema\n    if autogenerate:\n        command.upgrade(alembic_cfg, 'head', sql=True)\n    else:\n        command.current(alembic_cfg)\n\n    return True\n```"]}, "reflex-reflex/model.py-select": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def select(cls):\n# Natural Language Annotations: \"\"\"Select rows from the table.\n\n        Returns:\n            The select statement.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef select(cls):\n    return f\"SELECT * FROM {cls.__name__}\"\n```", "```python\ndef select(cls):\n    \"\"\"\n    Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    return f\"SELECT * FROM {cls.__table__}\"\n```", "```python\ndef select(cls):\n    \"\"\"\n    Select rows from the table.\n    \n    Returns:\n        The select statement.\n    \"\"\"\n    return f\"SELECT * FROM {cls.__name__}\"\n```"]}, "reflex-reflex/compiler/compiler.py-compile_components": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def compile_components(\n# Natural Language Annotations: \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef compile_components(components):\n    \"\"\"\n    Compile the custom components.\n\n    Args:\n        components (list): A list of dictionaries containing the component data.\n            Each dictionary should have the following keys:\n                - 'name': The name of the component.\n                - 'code': The code of the component.\n                - 'path': The path to the compiled component.\n\n    Returns:\n        dict: A dictionary with the path and code of the compiled components.\n    \"\"\"\n    compiled_components = []\n    for component in components:\n        path = component.get('path')\n        code = component.get('code')\n        if path and code:\n            compiled_components.append({'path': path, 'code': code})\n    return compiled_components\n```", "```python\ndef compile_components(components):\n    \"\"\"\n    Compile the custom components.\n\n    Args:\n        components (dict): A dictionary of custom components to compile.\n            Each key is the name of the component and each value is a string\n            containing the component's code.\n\n    Returns:\n        dict: A dictionary where each key is the name of a compiled component\n            and each value is a tuple containing the path and code of the compiled component.\n    \"\"\"\n    compiled_components = {}\n    for name, code in components.items():\n        # Assuming the compilation is done using the exec function\n        # This is a simplified example, in a real-world scenario you would use a more robust compilation method\n        compiled_code = compile(code, f\"<string>\", \"exec\")\n        # Assuming the path is the name of the component\n        compiled_components[name] = (name, compiled_code)\n    return compiled_components\n```", "```python\ndef compile_components(components):\n    \"\"\"\n    Compile the custom components.\n\n    Args:\n        components (list): The custom components to compile.\n\n    Returns:\n        dict: A dictionary containing the path and code of the compiled components.\n    \"\"\"\n    compiled_components = {}\n    for component in components:\n        if component['type'] == 'python':\n            compiled_components[component['name']] = compile(component['code'], component['path'], 'exec')\n        elif component['type'] == 'javascript':\n            compiled_components[component['name']] = compile(component['code'], component['path'], 'js')\n    return compiled_components\n```"]}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_or_set_last_reflex_version_check_datetime():\n# Natural Language Annotations: \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport datetime\nimport os\n\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"\n    Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    last_check_file = 'last_reflex_version_check.txt'\n    try:\n        with open(last_check_file, 'r') as file:\n            last_check_datetime = datetime.datetime.fromtimestamp(float(file.read()))\n    except FileNotFoundError:\n        last_check_datetime = datetime.datetime.now() - datetime.timedelta(days=30)\n        with open(last_check_file, 'w') as file:\n            file.write(str(int(last_check_datetime.timestamp())))\n    return last_check_datetime\n```", "```python\nimport datetime\nimport os\n\nlast_reflex_version_check_datetime = None\n\ndef get_or_set_last_reflex_version_check_datetime():\n    global last_reflex_version_check_datetime\n    \n    if last_reflex_version_check_datetime is None:\n        last_reflex_version_check_datetime = datetime.datetime.now()\n        return last_reflex_version_check_datetime\n    \n    try:\n        last_reflex_version_check_datetime = datetime.datetime.fromtimestamp(os.path.getmtime('last_reflex_version_check.txt'))\n        return last_reflex_version_check_datetime\n    except FileNotFoundError:\n        last_reflex_version_check_datetime = datetime.datetime.now()\n        return last_reflex_version_check_datetime\n    \n    last_reflex_version_check_datetime = datetime.datetime.now()\n    with open('last_reflex_version_check.txt', 'w') as file:\n        file.write(str(last_reflex_version_check_datetime))\n    return last_reflex_version_check_datetime\n```", "```python\nimport datetime\nimport os\n\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"\n    Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    last_check_datetime_file = 'last_reflex_version_check_datetime.txt'\n    try:\n        with open(last_check_datetime_file, 'r') as f:\n            last_check_datetime_str = f.read()\n            last_check_datetime = datetime.datetime.fromisoformat(last_check_datetime_str)\n    except (FileNotFoundError, ValueError):\n        last_check_datetime = None\n    if last_check_datetime is None:\n        last_check_datetime = datetime.datetime.now()\n        with open(last_check_datetime_file, 'w') as f:\n            f.write(last_check_datetime.isoformat())\n    return last_check_datetime\n```"]}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def preprocess(\n# Natural Language Annotations: \"\"\"Preprocess the event.\n\n        Args:\n            app: The app to apply the middleware to.\n            state: The client state.\n            event: The event to preprocess.\n\n        Returns:\n            An optional delta or list of state updates to return.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def preprocess(\n    app: dict, \n    state: dict, \n    event: dict\n) -> Optional[Union[dict, List[dict]]]:\n    # Your preprocessing logic here\n    # For example:\n    if event.get(\"type\") == \"new_user\":\n        state[\"new_user_id\"] = event[\"id\"]\n    elif event.get(\"type\") == \"update_user\":\n        state[\"users\"][event[\"id\"]] = event[\"data\"]\n    return None  # or return a list of state updates\n```", "```python\nasync def preprocess(\n    app: dict, \n    state: dict, \n    event: dict\n) -> dict or list:\n    \"\"\"\n    Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # Your preprocessing logic here\n    # For example:\n    if event['type'] == 'login':\n        state['user'] = event['user']\n        return {'user': state['user']}\n    elif event['type'] == 'logout':\n        state['user'] = None\n        return {'user': state['user']}\n    else:\n        return None\n```", "```python\nasync def preprocess(app, state, event):\n    \"\"\"\n    Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # TO DO: Implement the preprocessing logic here\n    # For now, just return None\n    return None\n```"]}, "reflex-reflex/components/component.py-get_event_triggers": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_event_triggers(self) -> Dict[str, Any]:\n# Natural Language Annotations: \"\"\"Get the event triggers for the component.\n\n        Returns:\n            The event triggers.\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Dict, Any\n\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"\n    Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n    \"\"\"\n    return {\n        \"click\": [\"click\", \"onclick\"],\n        \"hover\": [\"hover\", \"onhover\"],\n        \"submit\": [\"submit\", \"onsubmit\"],\n        # Add more event triggers as needed\n    }\n```", "```\nfrom typing import Dict, Any\n\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"\n    Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n    \"\"\"\n    return {\n        'click': ['on_click'],\n        'hover': ['on_hover'],\n        'submit': ['on_submit'],\n        'focus': ['on_focus'],\n        'blur': ['on_blur']\n    }\n```", "```python\nfrom typing import Dict, Any\n\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"\n    Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n    \"\"\"\n    event_triggers = {\n        \"click\": \"click\",\n        \"hover\": \"hover\",\n        \"submit\": \"submit\",\n        \"change\": \"change\",\n        \"focus\": \"focus\",\n        \"blur\": \"blur\"\n    }\n    return event_triggers\n```"]}, "reflex-reflex/components/component.py-get_props": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_props(cls) -> Set[str]:\n# Natural Language Annotations: \"\"\"Get the unique fields for the component.\n\n        Returns:\n            The unique fields.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Set\n\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set(dir(cls))\n```", "```python\nfrom typing import Set\n\ndef get_props(cls) -> Set[str]:\n    return set(dir(cls))\n```", "```python\nfrom typing import Set\n\ndef get_props(cls) -> Set[str]:\n    \"\"\"\n    Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set(dir(cls))\n```"]}, "reflex-reflex/components/component.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create the component.\n\n        Args:\n            *children: The children of the component.\n            **props: The props of the component.\n\n        Returns:\n            The component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Component:\n    def __init__(self, children=None, props=None):\n        self.children = children if children else []\n        self.props = props if props else {}\n\n    def __str__(self):\n        return f\"Component(children={self.children}, props={self.props})\"\n\ndef create(cls, *children, **props) -> Component:\n    \"\"\"\n    Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return Component(children, props)\n```", "```python\nclass Component:\n    def __init__(self, *children, **props):\n        self.children = children\n        self.props = props\n\ndef create(cls, *children, **props) -> 'Component':\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return cls(*children, **props)\n```", "```\nclass Component:\n    def __init__(self, props, children):\n        self.props = props\n        self.children = children\n\ndef create(cls, *children, **props):\n    \"\"\"\n    Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    return cls(props, children)\n```"]}, "reflex-reflex/components/component.py-_add_style_recursive": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _add_style_recursive(\n# Natural Language Annotations: \"\"\"Add additional style to the component and its children.\n\n        Apply order is as follows (with the latest overriding the earliest):\n        1. Default style from `_add_style`/`add_style`.\n        2. User-defined style from `App.style`.\n        3. User-defined style from `Component.style`.\n        4. style dict and css props passed to the component instance.\n\n        Args:\n            style: A dict from component to styling.\n            theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n        Raises:\n            UserWarning: If `_add_style` has been overridden.\n\n        Returns:\n            The component with the additional style.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _add_style_recursive(self, style, theme=None):\n    if hasattr(self, '_add_style'):\n        warnings.warn(\"_add_style has been deprecated, use add_style instead\", UserWarning)\n        style = self._add_style(style)\n    \n    style = self.add_style(style)\n    style.update(App.style)\n    style.update(self.style)\n    style.update(style_dict)\n    style.update(css_props)\n    \n    return self\n```", "```python\ndef _add_style_recursive(self, style, theme=None):\n    \"\"\"\n    Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n\n    Returns:\n        The component with the additional style.\n    \"\"\"\n    if hasattr(self, '_add_style') and hasattr(self, 'add_style') and self._add_style != self.add_style:\n        warnings.warn(\"_add_style has been overridden\", UserWarning)\n\n    # Apply default style\n    self.style = self._add_style(self.style or {})\n\n    # Apply user-defined style from App.style\n    app_style = self.app.style or {}\n    self.style = {**self.style, **app_style}\n\n    # Apply user-defined style from Component.style\n    component_style = self.style or {}\n    self.style = {**self.style, **component_style}\n\n    # Apply style dict and css props passed to the component instance\n    self.style = {**self.style, **style}\n\n    # Recursively apply style to children\n    for child in self.children:\n        child._add_style_recursive(style, theme)\n\n    return self\n```", "```python\ndef _add_style_recursive(self, style, theme=None):\n    \"\"\"\n    Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n\n    Returns:\n        The component with the additional style.\n    \"\"\"\n    from warnings import warn\n    from copy import deepcopy\n\n    # Check if _add_style has been overridden\n    if hasattr(self, '_add_style') and self._add_style != _add_style_recursive:\n        warn(\"Overriding _add_style is deprecated, use add_style instead\", UserWarning)\n\n    # Apply default style from _add_style/add_style\n    self._style = deepcopy(self._style or {})\n    self._style.update(self.add_style or {})\n\n    # Apply user-defined style from App.style\n    self._style.update(self.app.style or {})\n\n    # Apply user-defined style from Component.style\n    self._style.update(self.style or {})\n\n    # Apply style dict and css props passed to the component instance\n    self._style.update(style or {})\n\n    # Recursively add style to children\n    for child in self.children:\n        child._add_style_recursive(style, theme)\n\n    return self\n```"]}, "reflex-reflex/components/component.py-render": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self) -> Dict:\n# Natural Language Annotations: \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nfrom typing import Dict\n\ndef render(self) -> Dict:\n    \"\"\"\n    Render the component.\n\n    Returns:\n        The dictionary for template of component.\n    \"\"\"\n    template_dict = {\n        'title': 'Component Title',\n        'content': 'This is the component content',\n        'image': 'component_image.jpg',\n        'button': {\n            'text': 'Click me',\n            'link': 'https://www.example.com'\n        }\n    }\n    return template_dict\n```", "```python\nfrom typing import Dict\n\nclass Component:\n    def render(self) -> Dict:\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        return {\n            'html': '<div class=\"component\">This is a component</div>',\n            'css': '.component { background-color: #f2f2f2; }',\n            'js': 'console.log(\"Component rendered\");'\n        }\n```", "```python\nfrom typing import Dict\n\nclass Component:\n    def render(self) -> Dict:\n        \"\"\"Render the component.\n\n        Returns:\n            The dictionary for template of component.\n        \"\"\"\n        component_template = {\n            'header': 'Header Content',\n            'content': 'Main Content',\n            'footer': 'Footer Content'\n        }\n        return component_template\n```"]}, "reflex-reflex/components/component.py-_get_vars": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_vars(self, include_children: bool = False) -> list[Var]:\n# Natural Language Annotations: \"\"\"Walk all Vars used in this component.\n\n        Args:\n            include_children: Whether to include Vars from children.\n\n        Returns:\n            Each var referenced by the component (props, styles, event handlers).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list['Var']:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    result = []\n    if include_children:\n        for child in self.children:\n            result.extend(child._get_vars(include_children=True))\n    result.extend(self.props.values())\n    result.extend(self.styles.values())\n    result.extend(self.event_handlers.values())\n    return result\n```", "```python\ndef _get_vars(self, include_children: bool = False) -> list['Var']:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars = []\n    if include_children:\n        # Recursively get vars from children\n        for child in self.children:\n            vars.extend(child._get_vars(True))\n    # Get vars from this component\n    vars.extend(self.props)\n    vars.extend(self.styles)\n    vars.extend(self.event_handlers)\n    return vars\n```", "```python\ndef _get_vars(self, include_children: bool = False) -> list['Var']:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_ = []\n    if include_children:\n        for child in self.children:\n            vars_.extend(child._get_vars(include_children))\n    vars_.extend(self.props)\n    vars_.extend(self.styles)\n    vars_.extend(self.event_handlers)\n    return vars_\n```"]}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _has_stateful_event_triggers(self):\n# Natural Language Annotations: \"\"\"Check if component or children have any event triggers that use state.\n\n        Returns:\n            True if the component or children have any event triggers that uses state.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\ndef _has_stateful_event_triggers(self):\n    \"\"\"\n    Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    return any(\n        trigger for trigger in self.triggers\n        if isinstance(trigger, dict) and 'state' in trigger['args']\n    ) or any(\n        child._has_stateful_event_triggers() for child in self.children\n    )\n```", "```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"\n    Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    return any(\n        child._has_stateful_event_triggers() or \n        (hasattr(child, 'event_triggers') and any(trigger['uses_state'] for trigger in child.event_triggers)) \n        for child in self.children\n    )\n```", "```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"\n    Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    return any(trigger['uses_state'] for trigger in self.event_triggers) or any(\n        child._has_stateful_event_triggers() for child in self.children\n    )\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_code": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_code(self) -> set[str]:\n# Natural Language Annotations: \"\"\"Get custom code for the component and its children.\n\n        Returns:\n            The custom code.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = set()\n    if hasattr(self, 'custom_code'):\n        custom_code.add(self.custom_code)\n    if hasattr(self, 'children'):\n        for child in self.children:\n            custom_code.update(child._get_all_custom_code())\n    return custom_code\n```", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"\n    Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = set()\n    if hasattr(self, 'custom_code'):\n        custom_code.add(self.custom_code)\n    if hasattr(self, 'children'):\n        for child in self.children:\n            custom_code.update(child._get_all_custom_code())\n    return custom_code\n```", "```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"\n    Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    custom_code = set()\n    for child in self.children:\n        custom_code.update(child.get_custom_code())\n    if hasattr(self, 'custom_code'):\n        custom_code.add(self.custom_code)\n    return custom_code\n```"]}, "reflex-reflex/components/component.py-_get_all_imports": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n# Natural Language Annotations: \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n        Args:\n            collapse: Whether to collapse the imports by removing duplicates.\n\n        Returns:\n            The import dict with the required imports.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_all_imports(self, collapse: bool = False) -> dict:\n    \"\"\"\n    Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    # Initialize an empty dictionary to store imports\n    imports = {}\n\n    # Get the imports from the component\n    component_imports = self.component.imports\n\n    # Get the imports from the component's children\n    children_imports = [child._get_all_imports(collapse) for child in self.children]\n\n    # Combine the imports\n    for child_imports in children_imports:\n        imports.update(child_imports)\n\n    # Add the component's imports\n    imports.update(component_imports)\n\n    # If collapse is True, remove duplicates from the imports\n    if collapse:\n        imports = {k: v for k, v in imports.items() if k not in imports.values()}\n\n    return imports\n```", "```python\ndef _get_all_imports(self, collapse: bool = False) -> dict:\n    \"\"\"\n    Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    import_dict = {}\n    # Add code to populate the import_dict here\n    if collapse:\n        import_dict = self._collapse_imports(import_dict)\n    return import_dict\n\ndef _collapse_imports(self, imports: dict) -> dict:\n    \"\"\"\n    Collapse the imports by removing duplicates.\n\n    Args:\n        imports: The import dictionary.\n\n    Returns:\n        The collapsed import dictionary.\n    \"\"\"\n    collapsed_imports = {}\n    for key, value in imports.items():\n        if value not in collapsed_imports.values():\n            collapsed_imports[key] = value\n    return collapsed_imports\n```", "```python\ndef _get_all_imports(self, collapse: bool = False) -> dict:\n    \"\"\"\n    Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    # Return a sample dictionary\n    return {\n        \"import1\": \"library1\",\n        \"import2\": \"library2\",\n        # Add more imports as needed\n    }\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks_internal(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the reflex internal hooks for the component and its children.\n\n        Returns:\n            The code that should appear just before user-defined hooks.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"\n    Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {\n        'component': {\n            'before_init': None,\n            'after_init': None,\n            'before_render': None,\n            'after_render': None,\n            'before_destroy': None,\n            'after_destroy': None,\n            'before_mount': None,\n            'after_mount': None,\n            'before_update': None,\n            'after_update': None,\n            'before_unmount': None,\n            'after_unmount': None\n        },\n        'children': {\n            'before_init': None,\n            'after_init': None,\n            'before_render': None,\n            'after_render': None,\n            'before_destroy': None,\n            'after_destroy': None,\n            'before_mount': None,\n            'after_mount': None,\n            'before_update': None,\n            'after_update': None,\n            'before_unmount': None,\n            'after_unmount': None\n        }\n    }\n```", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"\n    Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {\n        \"before_render\": None,\n        \"after_render\": None,\n        \"on_mount\": None,\n        \"on_disconnect\": None,\n        \"on_update\": None,\n        \"on_error\": None,\n        \"on_pre_render\": None,\n        \"on_post_render\": None,\n        \"on_re_render\": None,\n        \"on_reconnect\": None,\n        \"on_destroy\": None,\n    }\n```", "```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"\n    Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    return {\n        'before_render': None,\n        'after_render': None,\n        'before_mount': None,\n        'after_mount': None,\n        'before_update': None,\n        'after_update': None,\n        'before_unmount': None,\n        'after_unmount': None,\n        'before_destroy': None,\n        'after_destroy': None\n    }\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_hooks(self) -> dict[str, None]:\n# Natural Language Annotations: \"\"\"Get the React hooks for this component and its children.\n\n        Returns:\n            The code that should appear just before returning the rendered component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"\n    Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    hooks = {}\n    for child in self.children:\n        if hasattr(child, '_get_all_hooks'):\n            hooks.update(child._get_all_hooks())\n    return hooks\n```", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"\n    Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    hooks = {}\n    for child in self.children:\n        child_hooks = child._get_all_hooks()\n        hooks.update(child_hooks)\n    if hasattr(self, 'use_effect'):\n        hooks['use_effect'] = None\n    if hasattr(self, 'useState'):\n        hooks['useState'] = None\n    if hasattr(self, 'useContext'):\n        hooks['useContext'] = None\n    if hasattr(self, 'useReducer'):\n        hooks['useReducer'] = None\n    if hasattr(self, 'useCallback'):\n        hooks['useCallback'] = None\n    if hasattr(self, 'useMemo'):\n        hooks['useMemo'] = None\n    if hasattr(self, 'useRef'):\n        hooks['useRef'] = None\n    return hooks\n```", "```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"\n    Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    hooks = {}\n    # Get hooks from the component\n    component_hooks = self.get_component_hooks()\n    hooks.update(component_hooks)\n    \n    # Get hooks from the children\n    children_hooks = self.get_children_hooks()\n    hooks.update(children_hooks)\n    \n    return hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_components": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_all_custom_components(\n# Natural Language Annotations: \"\"\"Get all the custom components used by the component.\n\n        Args:\n            seen: The tags of the components that have already been seen.\n\n        Returns:\n            The set of custom components.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_all_custom_components(seen):\n    \"\"\"\n    Get all the custom components used by the component.\n\n    Args:\n        seen (set): The tags of the components that have already been seen.\n\n    Returns:\n        set: The set of custom components.\n    \"\"\"\n    custom_components = set()\n    for component in seen:\n        if 'custom' in component:\n            custom_components.add(component)\n    return custom_components\n```", "```python\ndef _get_all_custom_components(seen):\n    \"\"\"\n    Get all the custom components used by the component.\n\n    Args:\n        seen (set): The tags of the components that have already been seen.\n\n    Returns:\n        set: The set of custom components.\n    \"\"\"\n    custom_components = set()\n    for component in seen:\n        if component.startswith('custom_'):\n            custom_components.add(component)\n    return custom_components\n```", "```python\ndef _get_all_custom_components(seen):\n    \"\"\"\n    Get all the custom components used by the component.\n\n    Args:\n        seen (set): The tags of the components that have already been seen.\n\n    Returns:\n        set: The set of custom components.\n    \"\"\"\n    custom_components = {\"component1\", \"component2\", \"component3\"}  # example of custom components\n    return custom_components - seen\n```"]}, "reflex-reflex/components/core/upload.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Create an upload component.\n\n        Args:\n            *children: The children of the component.\n            **props: The properties of the component.\n\n        Returns:\n            The upload component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Dict\n\nclass Component:\n    def __init__(self, **props):\n        self.props = props\n\nclass Upload(Component):\n    def __init__(self, *children: Any, **props: Dict[str, Any]):\n        super().__init__(**props)\n        self.children = children\n\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    return cls(*children, **props)\n```", "```python\nclass Component:\n    def __init__(self, props):\n        self.props = props\n\nclass Upload(Component):\n    def __init__(self, *children, **props):\n        super().__init__(props)\n        self.children = children\n\ndef create(cls, *children, **props):\n    \"\"\"\n    Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    return cls(*children, **props)\n```", "```python\nfrom typing import Any, Dict\n\nclass Component:\n    def __init__(self, props: Dict[str, Any] = None):\n        self.props = props or {}\n\nclass UploadComponent(Component):\n    def __init__(self, *children, **props):\n        super().__init__(props)\n        self.children = list(children)\n\n    def __str__(self):\n        return f'UploadComponent(props={self.props}, children={self.children})'\n\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    return cls(*children, **props)\n```"]}, "reflex-reflex/components/next/image.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(\n# Natural Language Annotations: \"\"\"Create an Image component from next/image.\n\n        Args:\n            *children: The children of the component.\n            width: The width of the image.\n            height: The height of the image.\n            **props:The props of the component.\n\n        Returns:\n            _type_: _description_\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom nextcord.ui import View, Button, Select, SelectOption\n\nasync def create(*children, width, height, **props):\n    return View(*children, width=width, height=height, **props)\n```", "```\nfrom nextjs import Image\n\ndef create(children, width, height, **props):\n    return Image(children=children, width=width, height=height, **props)\n```", "```python\nfrom next import Image\n\ndef create(*children, width, height, **props):\n    return Image(*children, width=width, height=height, **props)\n```"]}, "reflex-reflex/components/lucide/icon.py-create": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def create(cls, *children, **props) -> Component:\n# Natural Language Annotations: \"\"\"Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, Dict\n\nclass Component:\n    def __init__(self, **props: Dict[str, Any]):\n        self.props = props\n\n    def validate_icon_tag(self, tag: str) -> None:\n        valid_tags = ['fa', 'ion', 'material']\n        if tag not in valid_tags:\n            raise ValueError(f\"Invalid icon tag: {tag}\")\n\n    def validate_children(self, children: Any) -> None:\n        if not children:\n            raise AttributeError(\"Icon component requires at least one child\")\n\n    def create(self, *children: Any, **props: Dict[str, Any]) -> 'Component':\n        self.validate_icon_tag(props.get('tag', ''))\n        self.validate_children(children)\n        self.props.update(props)\n        self.props['children'] = children\n        return self\n```", "```python\nfrom typing import Any, Dict\n\nclass Component:\n    def __init__(self, **props):\n        self.props = props\n\n    def __str__(self):\n        return f\"Component(props={self.props})\"\n\nclass Icon(Component):\n    def __init__(self, *children: Any, **props: Dict[str, Any]):\n        \"\"\"\n        Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\n        if not children:\n            raise AttributeError(\"Icon component requires at least one child\")\n        \n        if 'icon' not in props:\n            raise ValueError(\"Icon component requires an 'icon' tag\")\n\n        super().__init__(**props)\n        self.children = children\n\n    def __str__(self):\n        return f\"Icon({self.children}, props={self.props})\"\n```", "```\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Dict\n\nclass Component(ABC):\n    @abstractmethod\n    def __init__(self, *children: Any, **props: Dict[str, Any]):\n        pass\n\nclass Icon(Component):\n    def __init__(self, *children: Any, **props: Dict[str, Any]) -> 'Component':\n        \"\"\"\n        Initialize the Icon component.\n\n        Run some additional checks on Icon component.\n\n        Args:\n            *children: The positional arguments\n            **props: The keyword arguments\n\n        Raises:\n            AttributeError: The errors tied to bad usage of the Icon component.\n            ValueError: If the icon tag is invalid.\n\n        Returns:\n            The created component.\n        \"\"\"\n        # Check for invalid icon tag\n        if 'icon' not in props or not isinstance(props['icon'], str):\n            raise ValueError(\"Invalid icon tag\")\n\n        # Check for required properties\n        required_props = ['size', 'color']\n        if not all(prop in props for prop in required_props):\n            raise AttributeError(\"Missing required properties\")\n\n        # Run additional checks on props\n        if props['size'] not in ['small', 'medium', 'large']:\n            raise AttributeError(\"Invalid size property\")\n\n        # Initialize the component\n        super().__init__(*children, **props)\n        self.children = children\n        self.props = props\n\n        return self\n```"]}, "reflex-reflex/components/tags/tag.py-format_props": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def format_props(self) -> List:\n# Natural Language Annotations: \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import List\n\nclass Tag:\n    def format_props(self) -> List:\n        \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\n        props = self.get_props()\n        formatted_props = []\n        for prop in props:\n            formatted_props.append(f\"{prop['key']}: {prop['value']}\")\n        return formatted_props\n```", "```python\nfrom typing import List\n\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    props = []\n    for prop in self.props:\n        key, value = prop.split('=')\n        props.append(f'{key.strip()}={value.strip()}')\n    return props\n```", "```python\nfrom typing import List\n\nclass Tag:\n    def __init__(self, props: List):\n        self.props = props\n\n    def format_props(self) -> List:\n        \"\"\"Format the tag's props.\n\n        Returns:\n            The formatted props list.\n        \"\"\"\n        return [f'{key}: {value}' for key, value in self.props.items()]\n```"]}, "textual-src/textual/screen.py-focus_next": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef focus_next(self, selector: str | type['QueryType'] = \"*\") -> 'Widget | None':\n    \"\"\"\n    Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    # Get all focusable widgets\n    focusable_widgets = self.get_focusable_widgets()\n    \n    # If no widget is currently focused, focus the first focusable widget\n    if not self.is_focused():\n        return focusable_widgets[0] if focusable_widgets else None\n    \n    # Filter focusable widgets by the given CSS selector\n    filtered_widgets = [widget for widget in focusable_widgets if self.matches_selector(widget, selector)]\n    \n    # If no focusable widget matches the given CSS selector, focus is set to `None`\n    if not filtered_widgets:\n        return None\n    \n    # Focus the next widget\n    next_widget = self.get_next_widget()\n    if next_widget in filtered_widgets:\n        return next_widget\n    \n    # If no next widget matches the selector, return the first matching widget\n    return filtered_widgets[0]\n```", "```python\nfrom selenium.webdriver.remote.webdriver import WebDriver\nfrom selenium.webdriver.common.by import By\n\nclass Widget:\n    def __init__(self, driver: WebDriver, element):\n        self.driver = driver\n        self.element = element\n\n    def focus(self):\n        self.driver.execute_script(\"arguments[0].focus()\", self.element)\n\nclass QueryType:\n    def __init__(self, selector):\n        self.selector = selector\n\ndef focus_next(self: WebDriver, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"\n    Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    if selector == \"*\":\n        try:\n            current_focus = self.find_element(By.TAG_NAME, \"body\")\n            current_focus.click()\n            current_focus = self.find_element(By.TAG_NAME, \"body\")\n        except Exception:\n            current_focus = self.find_element(By.TAG_NAME, \"body\")\n    else:\n        try:\n            current_focus = self.find_element(By.CSS_SELECTOR, selector)\n        except Exception:\n            return None\n    focusable_widgets = self.find_elements(By.CSS_SELECTOR, \"button, input, select, textarea\")\n    if current_focus in focusable_widgets:\n        focusable_widgets.remove(current_focus)\n    for widget in focusable_widgets:\n        try:\n            widget.click()\n            return widget\n        except Exception:\n            continue\n    return None\n```", "```python\nfrom selenium.webdriver.common.by import By\nfrom selenium.webdriver.support.ui import WebDriverWait\nfrom selenium.webdriver.support import expected_conditions as EC\nfrom selenium.webdriver import ActionChains\nfrom selenium.common.exceptions import TimeoutException\n\nclass Browser:\n    def focus_next(self, selector: str | type = \"*\") -> object:\n        try:\n            # Wait for the first focusable element\n            element = WebDriverWait(self.driver, 10).until(\n                EC.element_to_be_clickable((By.CSS_SELECTOR, selector))\n            )\n            # Focus the element\n            ActionChains(self.driver).move_to_element(element).perform()\n            return element\n        except TimeoutException:\n            # If no element is found, return None\n            return None\n```"]}, "textual-src/textual/screen.py-focus_previous": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n# Natural Language Annotations: \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"\n    Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    if not self.focused_widget:\n        # If no widget is currently focused, focus the first focusable widget\n        self.focused_widget = self.query(selector).first()\n    else:\n        # Get all focusable widgets\n        focusable_widgets = self.query(selector)\n        \n        # If the selector is \"*\", get all focusable widgets\n        if selector == \"*\":\n            focusable_widgets = self.query(\":focusable\")\n        \n        # If there are focusable widgets, focus the previous one\n        if focusable_widgets:\n            focused_widget = focusable_widgets.prev()\n            self.focused_widget = focused_widget\n            return focused_widget\n        else:\n            # If no focusable widget matches the given CSS selector, focus is set to None\n            self.focused_widget = None\n            return None\n```", "```python\nfrom typing import Union, TypeVar\n\nfrom selenium.webdriver import WebElement\nfrom selenium.webdriver.remote.webelement import By\n\nQueryType = TypeVar('QueryType')\n\nclass Widget:\n    def __init__(self, element: WebElement):\n        self.element = element\n\nclass WidgetManager:\n    def __init__(self, driver):\n        self.driver = driver\n        self.currently_focused = None\n\n    def focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n        \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        if self.currently_focused:\n            # Unfocus the currently focused widget\n            self.currently_focused.element.click()\n            self.currently_focused = None\n\n        if selector == \"*\":\n            # Focus the first focusable element\n            elements = self.driver.find_elements(By.TAG_NAME, \"*\")\n            for element in elements:\n                if element.is_enabled() and element.is_displayed():\n                    self.currently_focused = Widget(element)\n                    element.click()\n                    break\n        else:\n            # Focus the first focusable element matching the given selector\n            element = self.driver.find_element(By.CSS_SELECTOR, selector)\n            if element.is_enabled() and element.is_displayed():\n                self.currently_focused = Widget(element)\n                element.click()\n            else:\n                self.currently_focused = None\n\n        return self.currently_focused\n```", "```python\nfrom PyQt5.QtWidgets import QWidget, QApplication\n\nclass Widget:\n    def focus_previous(self, selector: str | type['QueryType'] = \"*\") -> 'Widget' | None:\n        \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n        If no widget is currently focused, this will focus the first focusable widget.\n        If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n        Args:\n            selector: CSS selector to filter\n                what nodes can be focused.\n\n        Returns:\n            Newly focused widget, or None for no focus. If the return\n                is not `None`, then it is guaranteed that the widget returned matches\n                the CSS selectors given in the argument.\n        \"\"\"\n        if not self.hasFocus():\n            # If no widget is currently focused, find the first focusable widget\n            # and focus it.\n            self.findChild(QWidget).setFocus()\n            return self.findChild(QWidget)\n        \n        focused_widget = QApplication.focusWidget()\n        if selector == \"*\":\n            return focused_widget\n        \n        # If a CSS selector is provided, find the next widget that matches the\n        # selector and focus it.\n        for child in focused_widget.findChildren(QWidget):\n            if child.cssSelector() == selector:\n                child.setFocus()\n                return child\n        \n        # If no widget matches the selector, return None.\n        return None\n```"]}, "textual-src/textual/screen.py-set_focus": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n# Natural Language Annotations: \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is None:\n        # Un-focus the current widget\n        self.widget = None\n    else:\n        # Focus the widget and scroll it into view\n        self.widget = widget\n        if scroll_visible:\n            # Scroll the widget into view\n            self.scroll_widget_into_view(widget)\n```", "```python\nclass Widget:\n    def __init__(self):\n        self.focused = False\n\nclass Window:\n    def __init__(self):\n        self.focused_widget = None\n\n    def set_focus(self, widget: 'Widget' | None, scroll_visible: bool = True) -> None:\n        \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n        Args:\n            widget: Widget to focus, or None to un-focus.\n            scroll_visible: Scroll widget in to view.\n        \"\"\"\n        if widget is not self.focused_widget:\n            if self.focused_widget:\n                self.focused_widget.focused = False\n            if widget:\n                widget.focused = True\n            self.focused_widget = widget\n            if scroll_visible and widget:\n                # Scroll the widget into view (this is a placeholder, actual implementation depends on the GUI framework being used)\n                pass\n```", "```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is not None:\n        widget.focus_set()\n        if scroll_visible:\n            widget.update_idletasks()\n            widget.update()\n    else:\n        self.focus_set(False)\n```"]}, "textual-src/textual/strip.py-index_to_cell_position": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def index_to_cell_position(self, index: int) -> int:\n# Natural Language Annotations: \"\"\"Given a character index, return the cell position of that character.\n        This is the sum of the cell lengths of all the characters *before* the character\n        at `index`.\n\n        Args:\n            index: The index to convert.\n\n        Returns:\n            The cell position of the character at `index`.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"\n    Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    return sum(len(row) for row in self._grid[:index // self._columns])\n```", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"\n    Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    return sum(len(cell) for cell in self.text.split('\\n')[:index])\n```", "```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"\n    Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    return index // (self.width + 1)"]}, "textual-src/textual/strip.py-render": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(self, console: Console) -> str:\n# Natural Language Annotations: \"\"\"Render the strip into terminal sequences.\n\n        Args:\n            console: Console instance.\n\n        Returns:\n            Rendered sequences.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    rendered_sequences = []\n    for line in console.strip:\n        rendered_sequences.append(f\"\\033[{line['style']}m{line['text']}\\033[0m\")\n    return \"\\n\".join(rendered_sequences)\n```", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"\n    Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    rendered_sequences = \"\"\n    for line in console.strip:\n        rendered_sequences += line.render() + \"\\n\"\n    return rendered_sequences\n```", "```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    return console.render_sequence()\n```"]}, "textual-src/textual/app.py-batch_update": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def batch_update(self) -> Generator[None, None, None]:\n# Natural Language Annotations: \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef batch_update():\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    try:\n        yield\n    finally:\n        # Simulate a repaint\n        print(\"Repaint\")\n```", "```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef batch_update():\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    try:\n        yield\n    finally:\n        # Simulating the repaint function, you may need to replace with actual repaint function\n        print(\"Repaints resumed\")\n```", "```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef batch_update():\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    try:\n        yield\n    finally:\n        # Assuming repaints are managed by a separate class, update it here\n        # For demonstration purposes, let's assume it's a function called 'suspend_repaints' and 'resume_repaints'\n        # In a real scenario, you would replace these with your actual repaint management logic\n        suspend_repaints()\n    # Resume repaints after the batch is done\n    resume_repaints()\n```"]}, "textual-src/textual/app.py-call_from_thread": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_from_thread(\n# Natural Language Annotations: \"\"\"Run a callable from another thread, and return the result.\n\n        Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n        or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n        This method will ensure that your code runs within the correct context.\n\n        !!! tip\n\n            Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n        Args:\n            callback: A callable to run.\n            *args: Arguments to the callback.\n            **kwargs: Keyword arguments for the callback.\n\n        Raises:\n            RuntimeError: If the app isn't running or if this method is called from the same\n                thread where the app is running.\n\n        Returns:\n            The result of the callback.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom textual.app import App\nfrom threading import Thread\nfrom functools import wraps\n\ndef call_from_thread(callback, *args, **kwargs):\n    \"\"\"\n    Run a callable from another thread, and return the result.\n\n    Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n    or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n    This method will ensure that your code runs within the correct context.\n\n    !!! tip\n\n        Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n    Args:\n        callback: A callable to run.\n        *args: Arguments to the callback.\n        **kwargs: Keyword arguments for the callback.\n\n    Raises:\n        RuntimeError: If the app isn't running or if this method is called from the same\n            thread where the app is running.\n\n    Returns:\n        The result of the callback.\n    \"\"\"\n    def wrapper(*args, **kwargs):\n        if not hasattr(callback, 'app'):\n            raise RuntimeError(\"App is not running\")\n        if Thread.current_thread().ident == App.get_running_app().thread_id:\n            raise RuntimeError(\"Cannot call from the same thread as the app\")\n        return callback(*args, **kwargs)\n    return wrapper\n```", "```\nfrom typing import Callable, Any\n\nclass TextualApp:\n    def call_from_thread(self, callback: Callable[..., Any], *args: Any, **kwargs: Any) -> Any:\n        if not self.is_running:\n            raise RuntimeError(\"App is not running\")\n        if threading.current_thread() == self._thread:\n            raise RuntimeError(\"Cannot call from the same thread where the app is running\")\n        \n        result = self._post_message(\n            \"call_from_thread\",\n            callback,\n            *args,\n            **kwargs,\n        )\n        return result\n```", "```python\nimport threading\nfrom textual.app import App, Compositor, CompositorView\n\nclass CallableRunner(App):\n    def __init__(self, callback, *args, **kwargs):\n        self.callback = callback\n        self.args = args\n        self.kwargs = kwargs\n        self.lock = threading.Lock()\n\n    async def on_load(self, event):\n        with self.lock:\n            if not self.is_running:\n                raise RuntimeError(\"App isn't running\")\n\n    async def on_mount(self):\n        self.thread = threading.Thread(target=self.run_callback)\n        self.thread.start()\n\n    def run_callback(self):\n        result = self.callback(*self.args, **self.kwargs)\n        with self.lock:\n            self.stop()\n        return result\n\ndef call_from_thread(callback, *args, **kwargs):\n    app = CallableRunner(callback, *args, **kwargs)\n    app.run()\n    return app.thread.join().result()\n```"]}, "textual-src/textual/app.py-run_test": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_test(\n# Natural Language Annotations: \"\"\"An asynchronous context manager for testing apps.\n\n        !!! tip\n\n            See the guide for [testing](/guide/testing) Textual apps.\n\n        Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n        Example:\n\n            ```python\n            async with app.run_test() as pilot:\n                await pilot.click(\"#Button.ok\")\n                assert ...\n            ```\n\n        Args:\n            headless: Run in headless mode (no output or input).\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            tooltips: Enable tooltips when testing.\n            notifications: Enable notifications when testing.\n            message_hook: An optional callback that will be called each time any message arrives at any\n                message pump in the app.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport asyncio\nfrom textual.app import App, Compositor, Container\nfrom textual.screen import Screen\nfrom textual.widgets import Button\nfrom textual.events import Message\n\nclass MyApp(App):\n    def __init__(self) -> None:\n        super().__init__()\n\n    async def compose(self) -> Compositor:\n        yield Container(content=Button(\"OK\"))\n\nclass Pilot:\n    def __init__(self, app: MyApp):\n        self.app = app\n\n    async def click(self, query: str) -> None:\n        \"\"\"Simulate a click on the element with the given query.\"\"\"\n        # This is a simplified version, you may need to implement the actual click logic\n        # based on the query\n        element = self.app.query_one(query)\n        if element:\n            await element.click()\n\nasync def run_test(headless: bool = False, size: tuple = None, tooltips: bool = False, notifications: bool = False, message_hook=None) -> Pilot:\n    app = MyApp()\n    app.run(headless=headless, size=size, tooltips=tooltips, notifications=notifications)\n    return Pilot(app)\n```", "```python\nasync def run_test(\n    headless: bool = False,\n    size: tuple = None,\n    tooltips: bool = False,\n    notifications: bool = False,\n    message_hook: callable = None,\n) -> \"AsyncContextManager[textual.pilot.Pilot]\":\n    import textual as txt\n    from textual.app import App\n\n    class _TestApp(App):\n        async def handle_post_init(self) -> None:\n            self.pilot = txt.pilot.Pilot(self)\n\n    async with _TestApp() as app:\n        app.log.enable_debug()\n        if size:\n            app.size = size\n        if not headless:\n            app.log.level = txt.LogLevel.INFO\n        if tooltips:\n            app.set_tooltip_enabled(True)\n        if notifications:\n            app.set_notification_enabled(True)\n        if message_hook:\n            app.message_hooks.append(message_hook)\n        yield app.pilot\n```", "```python\nasync def run_test(\n    headless: bool = False,\n    size: tuple[int, int] | None = None,\n    tooltips: bool = False,\n    notifications: bool = False,\n    message_hook: callable | None = None\n) -> \"Pilot\":\n    from textual.app import App\n    from textual.widgets import Button\n    from textual.pilot import Pilot\n\n    class _TestApp(App):\n        async def load(self) -> None:\n            self.bind(\"q\", \"quit\", \"Quit\", show=False)\n            self.bind(\"ok\", \"click\", \"Click OK\", show=False)\n            self.bind(\"cancel\", \"click\", \"Click Cancel\", show=False)\n\n        async def render(self) -> None:\n            yield f\"Test App\\n\"\n            yield f\"  Press 'q' to quit, 'ok' to click OK, 'cancel' to click Cancel\"\n\n        async def on_message(self, message: str) -> None:\n            if message_hook:\n                message_hook(message)\n\n    app = _TestApp()\n    if size:\n        app.width = size[0]\n        app.height = size[1]\n\n    if headless:\n        app.run()\n    else:\n        pilot = Pilot(app)\n        try:\n            yield pilot\n            await pilot.wait_for_press(\"q\")\n        finally:\n            app.stop()\n\n    if tooltips:\n        app.tooltips = True\n    if notifications:\n        app.notifications = True\n\n    return Pilot(app)\n```"]}, "textual-src/textual/app.py-run": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def run(\n# Natural Language Annotations: \"\"\"Run the app.\n\n        Args:\n            headless: Run in headless mode (no output).\n            inline: Run the app inline (under the prompt).\n            inline_no_clear: Don't clear the app output when exiting an inline app.\n            mouse: Enable mouse support.\n            size: Force terminal size to `(WIDTH, HEIGHT)`,\n                or None to auto-detect.\n            auto_pilot: An auto pilot coroutine.\n\n        Returns:\n            App return value.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\nimport asyncio\nimport sys\n\ndef run(headless=False, inline=False, inline_no_clear=False, mouse=False, size=None, auto_pilot=None):\n    if inline and not sys.stdin.isatty():\n        print(\"Error: Inline mode requires a TTY.\")\n        return None\n\n    if inline:\n        if inline_no_clear:\n            sys.stdout.write(\"\\r\")\n        else:\n            sys.stdout.write(\"\\033c\")\n            sys.stdout.flush()\n\n    if size is not None:\n        # Set terminal size to WIDTH, HEIGHT\n        # This is a simplified example, actual implementation may vary depending on the OS\n        print(f\"\\033[{size[1]};{size[0]}t\")\n\n    if auto_pilot:\n        loop = asyncio.get_event_loop()\n        return loop.run_until_complete(auto_pilot)\n\n    # Run the app in headless mode\n    # This is a simplified example, actual implementation may vary depending on the app\n    return \"App return value\"\n```", "```python\nimport sys\nimport os\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.text import Text\nfrom rich.markdown import Markdown\nfrom rich.layout import Layout\nfrom rich.panel import Panel\nfrom rich.markup import escape\nfrom rich.console import Console\nfrom rich.markup import escape\nfrom rich.text import Text\nfrom rich.panel import Panel\n\ndef run(headless=False, inline=False, inline_no_clear=False, mouse=False, size=None, auto_pilot=None):\n    console = Console()\n    \n    if headless:\n        console = Console(record=True)\n    \n    if inline:\n        console = Console()\n        console.clear()\n    \n    if inline_no_clear:\n        console = Console()\n    \n    if mouse:\n        console = Console()\n    \n    if size:\n        console.size = size\n    \n    if auto_pilot:\n        auto_pilot()\n    \n    return console\n```", "```python\nimport os\nimport sys\nimport threading\nimport tkinter as tk\nfrom tkinter import ttk\nfrom PIL import Image, ImageTk\nimport subprocess\n\nclass App:\n    def __init__(self, headless=False, inline=False, inline_no_clear=False, mouse=False, size=None, auto_pilot=None):\n        self.headless = headless\n        self.inline = inline\n        self.inline_no_clear = inline_no_clear\n        self.mouse = mouse\n        self.size = size\n        self.auto_pilot = auto_pilot\n        self.root = None\n        self.canvas = None\n        self.image = None\n\n    def run(self):\n        if self.inline:\n            if self.root is not None:\n                self.root.destroy()\n            self.root = tk.Tk()\n            self.root.withdraw()\n            self.canvas = tk.Canvas(self.root, width=1, height=1)\n            self.canvas.pack_forget()\n            self.root.update_idletasks()\n            self.root.update()\n            self.root.destroy()\n            self.root = tk.Tk()\n            self.root.geometry('1x1')\n            self.canvas = tk.Canvas(self.root, width=1, height=1)\n            self.canvas.pack()\n            self.root.geometry(self.size)\n            self.root.update_idletasks()\n            self.root.update()\n            self.root.deiconify()\n            self.root.geometry(self.size)\n            self.root.update_idletasks()\n            self.root.update()\n            self.root.after(100)\n            self.root.update_idletasks()\n            self.root.update()\n        else:\n            if self.size is not None:\n                self.root = tk.Tk()\n                self.root.geometry(self.size)\n            else:\n                self.root = tk.Tk()\n            self.canvas = tk.Canvas(self.root)\n            self.canvas.pack(fill='both', expand=True)\n        if not self.headless:\n            self.root.mainloop()\n        if self.auto_pilot:\n            threading.Thread(target=self.auto_pilot).start()\n        if not self.headless and not self.inline:\n            return self.root\n        else:\n            return None\n\n    def exit(self):\n        if not self.headless and not self.inline:\n            self.root.destroy()\n        if self.inline and not self.inline_no_clear:\n            self.canvas.delete('all')\n```"]}, "textual-src/textual/app.py-switch_mode": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_mode(self, mode: str) -> AwaitMount:\n# Natural Language Annotations: \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom abc import ABC, abstractmethod\nfrom typing import Awaitable, Optional\n\nclass UnknownModeError(Exception):\n    \"\"\"Raised when trying to switch to an unknown mode.\"\"\"\n    pass\n\nclass AwaitMount:\n    \"\"\"Represents an object which waits for the screen associated with the mode to be mounted.\"\"\"\n\nclass Mode(ABC):\n    \"\"\"Abstract base class for different modes.\"\"\"\n\n    @abstractmethod\n    def get_mount(self) -> AwaitMount:\n        \"\"\"Returns an object which waits for the screen associated with the mode to be mounted.\"\"\"\n\nclass Screen:\n    \"\"\"Represents a screen.\"\"\"\n\nclass ScreenManager:\n    \"\"\"Manages different screens.\"\"\"\n\n    def __init__(self):\n        self._modes = {}\n\n    def add_mode(self, mode: Mode) -> None:\n        \"\"\"Adds a mode to the screen manager.\"\"\"\n        self._modes[mode.__class__.__name__] = mode\n\n    def switch_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\n        if mode not in self._modes:\n            raise UnknownModeError(f\"Unknown mode: {mode}\")\n        return self._modes[mode].get_mount()\n\nclass Mode1(Mode):\n    \"\"\"A mode.\"\"\"\n    def get_mount(self) -> AwaitMount:\n        return Screen()\n\nclass Mode2(Mode):\n    \"\"\"Another mode.\"\"\"\n    def get_mount(self) -> AwaitMount:\n        return Screen()\n\n# Usage example:\nscreen_manager = ScreenManager()\nscreen_manager.add_mode(Mode1())\nscreen_manager.add_mode(Mode2())\n\n# Switch to Mode1 and wait for the screen to be mounted\nawaitable = screen_manager.switch_mode(\"Mode1\")\n# Switch to Mode2 and wait for the screen to be mounted\nawaitable = screen_manager.switch_mode(\"Mode2\")\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom typing import Awaitable, Optional\n\nclass UnknownModeError(Exception):\n    \"\"\"Raised when trying to switch to an unknown mode.\"\"\"\n    pass\n\nclass AwaitMount:\n    \"\"\"An optionally awaitable object which waits for the screen associated with the mode to be mounted.\"\"\"\n    @abstractmethod\n    async def wait(self):\n        \"\"\"Wait for the screen to be mounted.\"\"\"\n        pass\n\nclass ModeSwitcher(ABC):\n    \"\"\"Switches to a given mode.\"\"\"\n    \n    def switch_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\n        if mode not in self.supported_modes:\n            raise UnknownModeError(f\"Unknown mode: {mode}\")\n        \n        screen = self.get_screen(mode)\n        return screen\n\n    @abstractmethod\n    def get_screen(self, mode: str) -> AwaitMount:\n        \"\"\"Get the screen associated with the given mode.\"\"\"\n        pass\n\n    @property\n    @abstractmethod\n    def supported_modes(self) -> list:\n        \"\"\"Get a list of supported modes.\"\"\"\n        pass\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom typing import Awaitable\n\nclass UnknownModeError(Exception):\n    pass\n\nclass AwaitMount:\n    @abstractmethod\n    def __await__(self) -> None:\n        pass\n\nclass Screen:\n    @abstractmethod\n    def __await__(self) -> AwaitMount:\n        pass\n\nclass ModeSwitcher(ABC):\n    def switch_mode(self, mode: str) -> AwaitMount:\n        \"\"\"Switch to a given mode.\n\n        Args:\n            mode: The mode to switch to.\n\n        Returns:\n            An optionally awaitable object which waits for the screen associated\n                with the mode to be mounted.\n\n        Raises:\n            UnknownModeError: If trying to switch to an unknown mode.\n        \"\"\"\n        if mode not in self.supported_modes:\n            raise UnknownModeError(f\"Unknown mode: {mode}\")\n\n        return self._switch_mode(mode)\n\n    @abstractmethod\n    def _switch_mode(self, mode: str) -> AwaitMount:\n        pass\n\n    @property\n    @abstractmethod\n    def supported_modes(self) -> list:\n        pass\n```"]}, "textual-src/textual/app.py-push_screen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def push_screen(\n# Natural Language Annotations: \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n        Args:\n            screen: A Screen instance or the name of an installed screen.\n            callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n            wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n                this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n        Raises:\n            NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n        Returns:\n            An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n                to await the result of the screen.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport asyncio\nfrom textual.screen import Screen\nfrom textual.app import Compositor, App, CompositorKey\nfrom textual.widget import CompositorKey\nfrom textual.reactive import reactive\nfrom textual.screen import Screen, ScreenStack\n\nasync def push_screen(screen: Screen | str, callback=None, wait_for_dismiss=False):\n    \"\"\"Push a new screen on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is dismissed with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    if isinstance(screen, str):\n        screen = Screen.get(screen)\n    \n    if not hasattr(self, 'screen_stack'):\n        raise RuntimeError(\"No active screen stack\")\n\n    self.screen_stack.push(screen)\n    if callback:\n        screen.bind('dismiss', callback)\n    if wait_for_dismiss:\n        return screen.run_async()\n    else:\n        return asyncio.create_task(screen.mount())\n```", "```python\nimport asyncio\nfrom textual.app import Compositor\nfrom textual.screen import Screen\n\nclass ScreenApp(Compositor):\n    async def compose(self) -> Compositor:\n        await self.push_screen(screen=\"home\")\n\n    async def push_screen(self, screen: Screen | str, callback: callable=None, wait_for_dismiss: bool=False):\n        if wait_for_dismiss and not self.is_worker:\n            raise RuntimeError(\"Cannot use wait_for_dismiss outside of a worker\")\n\n        if isinstance(screen, str):\n            screen = self.screens.get(screen)\n\n        if screen not in self.screens:\n            raise ValueError(f\"Screen '{screen}' not found\")\n\n        await self.push_screen(screen, callback=callback, wait_for_dismiss=wait_for_dismiss)\n        if wait_for_dismiss:\n            return await screen.wait_for_dismiss()\n        else:\n            return asyncio.Future()\n```", "```python\nimport asyncio\nfrom textual.screen import Screen\nfrom textual.app import Compositor\n\nasync def push_screen(screen, callback=None, wait_for_dismiss=False):\n    \"\"\"\n    Push a new screen on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is dismissed with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    if wait_for_dismiss and not hasattr(asyncio, 'current_task'):\n        raise RuntimeError(\"No active worker\")\n\n    if isinstance(screen, str):\n        screen = Compositor.load(screen)\n\n    await self.push_screen(screen)\n\n    if callback:\n        await self.bind(\"q\", \"dismiss\", \"Dismiss the screen\", action=callback)\n\n    if wait_for_dismiss:\n        return await self.wait(\"dismiss\")\n    else:\n        return await self.wait(\"mounted\")\n```"]}, "textual-src/textual/app.py-switch_screen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def switch_screen(self, screen: Screen | str) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom abc import ABC, abstractmethod\nfrom typing import TypeVar, Union\n\nT = TypeVar('T')\n\nclass Screen(ABC):\n    @abstractmethod\n    def __init__(self, name: str):\n        pass\n\nclass AwaitComplete:\n    def __init__(self, callback):\n        self.callback = callback\n\n    def __await__(self):\n        return self.callback()\n\nclass ScreenManager:\n    def __init__(self):\n        self.screen_stack = []\n\n    def switch_screen(self, screen: Union[Screen, str]) -> AwaitComplete:\n        \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if isinstance(screen, str):\n            # Assuming screens are stored in a dictionary\n            screens = {'home': Screen('home'), 'settings': Screen('settings')}  # Replace with actual screen registry\n            screen = screens.get(screen)\n            if screen is None:\n                raise ValueError(f\"Screen '{screen}' not found\")\n        self.screen_stack.append(screen)\n        return AwaitComplete(lambda: screen.on_enter())\n```", "```python\nfrom typing import Union\n\nclass ScreenManager:\n    def __init__(self):\n        self.screen_stack = []\n\n    def switch_screen(self, screen: Union[object, str]) -> None:\n        \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if isinstance(screen, str):\n            # Assuming you have a dictionary of screens with names as keys\n            self.screen_stack = [self.screens[screen]] + self.screen_stack[:1]\n        else:\n            self.screen_stack = [screen] + self.screen_stack[:1]\n```", "```python\nfrom abc import ABC\nfrom typing import Union\n\nclass Screen:\n    def __init__(self, name: str):\n        self.name = name\n\nclass AwaitComplete(ABC):\n    pass\n\nclass ScreenManager:\n    def __init__(self):\n        self.screen_stack = []\n\n    def switch_screen(self, screen: Union[Screen, str]) -> AwaitComplete:\n        \"\"\"\n        Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n        Args:\n            screen: Either a Screen object or screen name (the `name` argument when installed).\n        \"\"\"\n        if isinstance(screen, str):\n            # Assuming you have a dictionary of screens with their names as keys\n            screens = {\n                'home': Screen('home'),\n                'settings': Screen('settings'),\n                # Add more screens here...\n            }\n            screen = screens.get(screen)\n            if screen is None:\n                raise ValueError(f\"Screen '{screen}' not found\")\n        self.screen_stack.append(screen)\n        return AwaitComplete()\n```"]}, "textual-src/textual/app.py-pop_screen": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def pop_screen(self) -> AwaitComplete:\n# Natural Language Annotations: \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom abc import ABC, abstractmethod\nfrom typing import Awaitable, Union\n\nclass ScreenManager(ABC):\n    @abstractmethod\n    def pop_screen(self) -> Awaitable['AwaitComplete']:\n        pass\n\nclass AwaitComplete:\n    pass\n\nclass ScreenManagerImpl(ScreenManager):\n    def __init__(self):\n        self.screen_stack = []\n\n    def pop_screen(self) -> Awaitable['AwaitComplete']:\n        if not self.screen_stack:\n            return None\n        screen = self.screen_stack.pop()\n        return AwaitComplete()\n```", "```python\nclass ScreenManager:\n    def __init__(self):\n        self.screen_stack = []\n\n    def push_screen(self, screen):\n        self.screen_stack.append(screen)\n\n    def pop_screen(self) -> object:\n        \"\"\"Pop the current screen from the stack, and switch to the previous screen.\n\n        Returns:\n            The screen that was replaced.\n        \"\"\"\n        if not self.screen_stack:\n            raise IndexError(\"No screens in the stack\")\n        return self.screen_stack.pop()\n```", "```python\nasync def pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    return await self._screen_stack.pop()\n```"]}, "textual-src/textual/app.py-run_action": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def run_action(\n# Natural Language Annotations: \"\"\"Perform an [action](/guide/actions).\n\n        Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n        Args:\n            action: Action encoded in a string.\n            default_namespace: Namespace to use if not provided in the action,\n                or None to use app.\n\n        Returns:\n            True if the event has been handled.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def run_action(action: str, default_namespace=None):\n    \"\"\"\n    Perform an action.\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    # Implement action handling logic here\n    # For example:\n    action_map = {\n        'action1': lambda: print(\"Action 1 executed\"),\n        'action2': lambda: print(\"Action 2 executed\")\n    }\n    \n    if default_namespace is None:\n        namespace = 'app'\n    else:\n        namespace = default_namespace\n    \n    if action in action_map:\n        await action_map[action]()\n        return True\n    else:\n        return False\n```", "```python\nasync def run_action(action: str, default_namespace=None):\n    \"\"\"\n    Perform an action.\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    # Your action logic here\n    # For example, let's assume we have a dictionary of actions\n    actions = {\n        'action1': lambda: print('Action 1 executed'),\n        'action2': lambda: print('Action 2 executed')\n    }\n\n    if default_namespace:\n        namespace = default_namespace\n    else:\n        namespace = 'app'\n\n    if action in actions:\n        return await actions[action]()\n    else:\n        return False\n```", "```python\nasync def run_action(action: str, default_namespace: str = None) -> bool:\n    \"\"\"\n    Perform an action.\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    # TO DO: implement action logic here\n    # For now, just return True to indicate the event has been handled\n    return True\n```"]}, "textual-src/textual/file_monitor.py-check": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def check(self) -> bool:\n# Natural Language Annotations: \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport os\nimport datetime\n\nclass FileMonitor:\n    def __init__(self, files):\n        self.files = files\n        self.last_modification_times = {}\n\n    def check(self):\n        \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n        for file in self.files:\n            try:\n                current_modification_time = os.path.getmtime(file)\n                if file not in self.last_modification_times or current_modification_time > self.last_modification_times[file]:\n                    self.last_modification_times[file] = current_modification_time\n                    return True\n            except OSError:\n                pass\n        return False\n```", "```python\nimport os\nfrom datetime import datetime\n\nclass FileMonitor:\n    def __init__(self, files):\n        self.files = files\n        self.last_modification_times = {}\n\n    def check(self):\n        \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n        current_time = datetime.now()\n        for file in self.files:\n            mod_time = os.path.getmtime(file)\n            if file not in self.last_modification_times or mod_time > self.last_modification_times[file]:\n                self.last_modification_times[file] = mod_time\n                return True\n        return False\n```", "```python\nimport os\nimport datetime\n\nclass MonitorFiles:\n    def __init__(self, monitored_files):\n        self.monitored_files = monitored_files\n        self.last_modification_times = {}\n\n    def check(self) -> bool:\n        \"\"\"\n        Check the monitored files. Return True if any were changed since the last modification time.\n        \"\"\"\n        for file in self.monitored_files:\n            if os.path.exists(file):\n                modification_time = datetime.datetime.fromtimestamp(os.path.getmtime(file))\n                if file not in self.last_modification_times or modification_time > self.last_modification_times[file]:\n                    self.last_modification_times[file] = modification_time\n                    return True\n        return False\n```"]}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n# Natural Language Annotations: \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"\n    Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    return line.replace('\\t', ' ' * tab_size)\n```", "```\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"\n    Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    return line.replace('\\t', ' ' * tab_size)\n```", "```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"\n    Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    return line.replace('\\t', ' ' * tab_size)\n```"]}, "textual-src/textual/_resolve.py-resolve": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def resolve(\n# Natural Language Annotations: \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef resolve(dimensions, total, gutter, size, viewport):\n    \"\"\"\n    Resolve a list of dimensions.\n\n    Args:\n        dimensions (int or list): Scalars for column / row sizes.\n        total (int): Total space to divide.\n        gutter (int): Gutter between rows / columns.\n        size (int): Size of container.\n        viewport (int): Size of viewport.\n\n    Returns:\n        List of (offset, length) tuples\n    \"\"\"\n    if isinstance(dimensions, int):\n        dimensions = [dimensions] * (total - 1)\n    elif len(dimensions) != total:\n        raise ValueError(\"Dimensions must be equal to total or a single integer\")\n\n    result = []\n    offset = 0\n    for i, dim in enumerate(dimensions):\n        length = dim + gutter\n        if offset + length > size:\n            raise ValueError(\"Dimensions exceed the size of the container\")\n        result.append((offset, length))\n        offset += length\n    if offset < viewport:\n        raise ValueError(\"Total dimensions exceed the size of the viewport\")\n    return result\n```", "```python\ndef resolve(dimensions, total, gutter, size, viewport):\n    \"\"\"\n    Resolve a list of dimensions.\n\n    Args:\n        dimensions (list): Scalars for column / row sizes.\n        total (int): Total space to divide.\n        gutter (int): Gutter between rows / columns.\n        size (int): Size of container.\n        viewport (int): Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    resolved = []\n    offset = 0\n    for i, dimension in enumerate(dimensions):\n        length = (total - (len(dimensions) - 1) * gutter) // len(dimensions)\n        if i + 1 == len(dimensions):\n            length += total - offset\n        resolved.append((offset, length))\n        offset += length + gutter\n    return resolved\n```", "```python\ndef resolve(dimensions, total, gutter, size, viewport):\n    \"\"\"\n    Resolve a list of dimensions.\n\n    Args:\n        dimensions (list): Scalars for column / row sizes.\n        total (int): Total space to divide.\n        gutter (int): Gutter between rows / columns.\n        size (int): Size of container.\n        viewport (int): Size of viewport.\n\n    Returns:\n        list: List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    result = []\n    remaining_space = total\n    for i, dimension in enumerate(dimensions):\n        if remaining_space > 0:\n            length = min(dimension, remaining_space)\n            offset = 0\n            if i > 0:\n                offset = result[i-1][0] + result[i-1][1] + gutter\n            if offset + length > size:\n                length = size - offset\n            result.append((offset, length))\n            remaining_space -= length\n    return result\n```"]}, "textual-src/textual/widget.py-mount": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def mount(\n# Natural Language Annotations: \"\"\"Mount widgets below this widget (making this widget a container).\n\n        Args:\n            *widgets: The widget(s) to mount.\n            before: Optional location to mount before. An `int` is the index\n                of the child to mount before, a `str` is a `query_one` query to\n                find the widget to mount before.\n            after: Optional location to mount after. An `int` is the index\n                of the child to mount after, a `str` is a `query_one` query to\n                find the widget to mount after.\n\n        Returns:\n            An awaitable object that waits for widgets to be mounted.\n\n        Raises:\n            MountError: If there is a problem with the mount request.\n\n        Note:\n            Only one of ``before`` or ``after`` can be provided. If both are\n            provided a ``MountError`` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def mount(*widgets, before=None, after=None):\n    \"\"\"\n    Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before and after:\n        raise MountError(\"Only one of 'before' or 'after' can be provided\")\n    if before:\n        # Find the widget to mount before\n        if isinstance(before, int):\n            # Mount before the widget at the specified index\n            for widget in widgets:\n                if before == len(widget.children):\n                    widget.children.append(widget)\n                    return\n                elif before == len(widget.children) - 1:\n                    widget.children.insert(before, widget)\n                    return\n                before -= 1\n        else:\n            # Mount before the first widget that matches the query\n            for widget in widgets:\n                if before in widget.query_one(before):\n                    widget.children.insert(0, widget)\n                    return\n    elif after:\n        # Find the widget to mount after\n        if isinstance(after, int):\n            # Mount after the widget at the specified index\n            for widget in widgets:\n                if after == len(widget.children):\n                    widget.children.append(widget)\n                    return\n                elif after == len(widget.children) - 1:\n                    widget.children.insert(after + 1, widget)\n                    return\n                after += 1\n        else:\n            # Mount after the first widget that matches the query\n            for widget in widgets:\n                if after in widget.query_one(after):\n                    widget.children.append(widget)\n                    return\n    # If no valid location is found, raise a MountError\n    raise MountError(\"No valid location found to mount the widget(s)\")\n```", "```python\nasync def mount(*widgets, before=None, after=None):\n    \"\"\"\n    Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before and after:\n        raise MountError(\"Only one of 'before' or 'after' can be provided\")\n    \n    if before:\n        # If before is an int, mount at the specified index\n        if isinstance(before, int):\n            for widget in widgets:\n                # Add code to mount widget at the specified index\n                pass\n        # If before is a str, find the widget to mount before\n        elif isinstance(before, str):\n            # Add code to find the widget to mount before\n            pass\n    elif after:\n        # If after is an int, mount after the specified index\n        if isinstance(after, int):\n            for widget in widgets:\n                # Add code to mount widget after the specified index\n                pass\n        # If after is a str, find the widget to mount after\n        elif isinstance(after, str):\n            # Add code to find the widget to mount after\n            pass\n    else:\n        # If neither before nor after is provided, raise a MountError\n        raise MountError(\"Neither 'before' nor 'after' is provided\")\n\n    # Return an awaitable object that waits for widgets to be mounted\n    return await asyncio.create_task(asyncio.sleep(0))  # Replace with actual mounting code\n```", "```python\nfrom typing import Awaitable, List\n\nclass MountError(Exception):\n    pass\n\nasync def mount(*widgets: List, before=None, after=None) -> Awaitable:\n    \"\"\"\n    Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before and after:\n        raise MountError(\"Only one of 'before' or 'after' can be provided\")\n\n    if before:\n        if isinstance(before, int):\n            # Mount widgets before the specified index\n            # Implementation details here\n            pass\n        elif isinstance(before, str):\n            # Use query_one to find the widget to mount before\n            # Implementation details here\n            pass\n        else:\n            raise MountError(\"Invalid 'before' value\")\n    elif after:\n        if isinstance(after, int):\n            # Mount widgets after the specified index\n            # Implementation details here\n            pass\n        elif isinstance(after, str):\n            # Use query_one to find the widget to mount after\n            # Implementation details here\n            pass\n        else:\n            raise MountError(\"Invalid 'after' value\")\n    else:\n        # Mount widgets at the end\n        # Implementation details here\n        pass\n\n    # Return an awaitable object that waits for widgets to be mounted\n    return await asyncio.sleep(0)  # Replace with actual implementation\n```"]}, "textual-src/textual/widget.py-move_child": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def move_child(\n# Natural Language Annotations: \"\"\"Move a child widget within its parent's list of children.\n\n        Args:\n            child: The child widget to move.\n            before: Child widget or location index to move before.\n            after: Child widget or location index to move after.\n\n        Raises:\n            WidgetError: If there is a problem with the child or target.\n\n        Note:\n            Only one of `before` or `after` can be provided. If neither\n            or both are provided a `WidgetError` will be raised.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass WidgetError(Exception):\n    pass\n\ndef move_child(child, before=None, after=None):\n    \"\"\"\n    Move a child widget within its parent's list of children.\n\n    Args:\n        child: The child widget to move.\n        before: Child widget or location index to move before.\n        after: Child widget or location index to move after.\n\n    Raises:\n        WidgetError: If there is a problem with the child or target.\n\n    Note:\n        Only one of `before` or `after` can be provided. If neither\n        or both are provided a `WidgetError` will be raised.\n    \"\"\"\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n    if before is None and after is None:\n        raise WidgetError(\"Either 'before' or 'after' must be provided.\")\n    \n    children = []  # Assuming children is a list of widgets\n    if isinstance(before, int):\n        index = before\n        children.insert(index, child)\n    elif isinstance(before, object):\n        index = children.index(before)\n        children.remove(before)\n        children.insert(index, child)\n    else:\n        raise WidgetError(\"Invalid target for 'before' or 'after'.\")\n    \n    # If 'after' is provided, insert the child after the target\n    if after is not None:\n        if isinstance(after, int):\n            index = after\n            children.insert(index, child)\n        elif isinstance(after, object):\n            index = children.index(after)\n            children.remove(after)\n            children.insert(index + 1, child)\n        else:\n            raise WidgetError(\"Invalid target for 'after'.\")\n    \n    return children\n```", "```python\nclass WidgetError(Exception):\n    pass\n\nclass Widget:\n    def __init__(self, name):\n        self.name = name\n        self.children = []\n\n    def add_child(self, child):\n        self.children.append(child)\n\n    def remove_child(self, child):\n        self.children.remove(child)\n\n    def move_child(self, child, before=None, after=None):\n        if not before and not after:\n            raise WidgetError(\"Either 'before' or 'after' must be provided\")\n        if before and after:\n            raise WidgetError(\"Only one of 'before' or 'after' can be provided\")\n\n        if not isinstance(child, Widget):\n            raise WidgetError(\"Invalid child provided\")\n\n        if before:\n            if not isinstance(before, Widget):\n                try:\n                    before_index = self.children.index(before)\n                except ValueError:\n                    raise WidgetError(\"Target location not found\")\n                self.children.remove(child)\n                self.children.insert(before_index, child)\n            else:\n                before_index = self.children.index(before)\n                self.children.remove(child)\n                self.children.insert(before_index + 1, child)\n        else:\n            if not isinstance(after, Widget):\n                try:\n                    after_index = self.children.index(after)\n                except ValueError:\n                    raise WidgetError(\"Target location not found\")\n            self.children.remove(child)\n            self.children.insert(after_index + 1, child)\n```", "```python\nfrom typing import Union\n\nclass WidgetError(Exception):\n    pass\n\ndef move_child(child, before: Union[object, int] = None, after: Union[object, int] = None) -> None:\n    \"\"\"\n    Move a child widget within its parent's list of children.\n\n    Args:\n        child: The child widget to move.\n        before: Child widget or location index to move before.\n        after: Child widget or location index to move after.\n\n    Raises:\n        WidgetError: If there is a problem with the child or target.\n\n    Note:\n        Only one of `before` or `after` can be provided. If neither\n        or both are provided a `WidgetError` will be raised.\n    \"\"\"\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of `before` or `after` can be provided.\")\n    if before is None and after is None:\n        raise WidgetError(\"Either `before` or `after` must be provided.\")\n    \n    parent = child.parent  # assuming child has a parent attribute\n    \n    if isinstance(before, int):\n        index = before\n    else:\n        index = parent.children.index(before)\n    \n    parent.children.remove(child)\n    if after is None:\n        parent.children.insert(index, child)\n    else:\n        if isinstance(after, int):\n            index = after\n        else:\n            index = parent.children.index(after)\n        parent.children.insert(index, child)\n```"]}, "textual-src/textual/widget.py-_get_box_model": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_box_model(\n# Natural Language Annotations: \"\"\"Process the box model for this widget.\n\n        Args:\n            container: The size of the container widget (with a layout)\n            viewport: The viewport size.\n            width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n            height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n        Returns:\n            The size and margin for this widget.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _get_box_model(container, viewport, width_fraction, height_fraction):\n    \"\"\"\n    Process the box model for this widget.\n\n    Args:\n        container (dict): The size of the container widget (with a layout)\n        viewport (dict): The viewport size.\n        width_fraction (float): A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction (float): A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        dict: The size and margin for this widget.\n    \"\"\"\n    container_width = container.get('width', 0)\n    container_height = container.get('height', 0)\n    viewport_width = viewport.get('width', 0)\n    viewport_height = viewport.get('height', 0)\n\n    available_width = viewport_width - container_width\n    available_height = viewport_height - container_height\n\n    widget_width = available_width * width_fraction\n    widget_height = available_height * height_fraction\n\n    margin_left = (container_width - widget_width) / 2\n    margin_right = (container_width - widget_width) / 2\n    margin_top = (container_height - widget_height) / 2\n    margin_bottom = (container_height - widget_height) / 2\n\n    return {\n        'width': widget_width,\n        'height': widget_height,\n        'margin_left': margin_left,\n        'margin_right': margin_right,\n        'margin_top': margin_top,\n        'margin_bottom': margin_bottom\n    }\n```", "```python\ndef _get_box_model(container, viewport, width_fraction, height_fraction):\n    \"\"\"\n    Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n    # Calculate the available width\n    available_width = (container.width - viewport.width) / width_fraction\n    \n    # Calculate the available height\n    available_height = (container.height - viewport.height) / height_fraction\n\n    # Calculate the widget size and margin\n    widget_size = min(available_width, available_height)\n    margin = max(0, available_width - widget_size) / 2\n\n    return widget_size, margin\n```", "```python\ndef _get_box_model(container, viewport, width_fraction, height_fraction):\n    \"\"\"\n    Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n    container_width, container_height = container\n    viewport_width, viewport_height = viewport\n\n    width = max(0, container_width - 2) * width_fraction\n    height = max(0, container_height - 2) * height_fraction\n\n    margin_top = 0\n    margin_bottom = 0\n    margin_left = 0\n    margin_right = 0\n\n    return width, height, margin_top, margin_bottom, margin_left, margin_right\n```"]}, "textual-src/textual/widget.py-get_content_width": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_width(self, container: Size, viewport: Size) -> int:\n# Natural Language Annotations: \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n\n        Returns:\n            The optimal width of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef get_content_width(self, container: 'Size', viewport: 'Size') -> int:\n    \"\"\"\n    Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    return min(container.width, viewport.width)\n```", "```python\ndef get_content_width(self, container: 'Size', viewport: 'Size') -> int:\n    \"\"\"\n    Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    return min(container.width, viewport.width)\n```", "```python\ndef get_content_width(self, container: 'Size', viewport: 'Size') -> int:\n    \"\"\"\n    Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    return container.width\n```"]}, "textual-src/textual/widget.py-get_content_height": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n# Natural Language Annotations: \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n        Args:\n            container: Size of the container (immediate parent) widget.\n            viewport: Size of the viewport.\n            width: Width of renderable.\n\n        Returns:\n            The height of the content.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"\n    Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    return container.height\n```", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    return container.height\n```", "```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"\n    Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    # Calculate the height of the content area\n    content_height = (width * viewport.height) // container.width\n    return content_height\n```"]}, "textual-src/textual/suggester.py-_get_suggestion": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: async def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n# Natural Language Annotations: \"\"\"Used by widgets to get completion suggestions.\n\n        Note:\n            When implementing custom suggesters, this method does not need to be\n            overridden.\n\n        Args:\n            requester: The message target that requested a suggestion.\n            value: The current value to complete.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nasync def _get_suggestion(self, requester: 'DOMNode', value: str) -> None:\n    pass\n```", "```python\nasync def _get_suggestion(self, requester: 'DOMNode', value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    # TO DO: This method should be implemented according to the specific requirements\n    # of the application. For example, it could fetch suggestions from a database,\n    # an API, or a predefined list.\n    pass\n```", "```python\nasync def _get_suggestion(self, requester: 'DOMNode', value: str) -> None:\n    # TODO: Implement the logic to get suggestions\n    pass\n```"]}, "textual-src/textual/dom.py-add_class": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def add_class(self, *class_names: str, update: bool = True) -> Self:\n# Natural Language Annotations: \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```\ndef add_class(self, *class_names: str, update: bool = True) -> 'Node':\n    \"\"\"\n    Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    for name in class_names:\n        self.classes.add(name)\n    if update:\n        self.update_styles()\n    return self\n```", "```python\nclass Node:\n    def __init__(self):\n        self.classes = []\n\n    def add_class(self, *class_names: str, update: bool = True) -> 'Node':\n        \"\"\"Add class names to this Node.\n\n        Args:\n            *class_names: CSS class names to add.\n            update: Also update styles.\n\n        Returns:\n            Self.\n        \"\"\"\n        self.classes.extend(class_names)\n        if update:\n            # Update styles logic goes here\n            pass\n        return self\n```", "```python\ndef add_class(self, *class_names: str, update: bool = True) -> 'Self':\n    \"\"\"\n    Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    for class_name in class_names:\n        self.class_names.append(class_name)\n        if update:\n            self.update_styles()\n    return self\n```"]}, "textual-src/textual/reactive.py-_initialize_object": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _initialize_object(cls, obj: Reactable) -> None:\n# Natural Language Annotations: \"\"\"Set defaults and call any watchers / computes for the first time.\n\n        Args:\n            obj: An object with Reactive descriptors\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef _initialize_object(cls, obj: 'Reactable') -> None:\n    \"\"\"\n    Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr_name in dir(obj):\n        attr = getattr(obj, attr_name)\n        if hasattr(attr, 'default'):\n            attr.default()\n        if hasattr(attr, 'watcher'):\n            attr.watcher()\n        if hasattr(attr, 'compute'):\n            attr.compute()\n```", "```python\ndef _initialize_object(cls, obj: 'Reactable') -> None:\n    \"\"\"\n    Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for descriptor in cls.__annotations__:\n        if hasattr(obj, descriptor):\n            prop = getattr(obj, descriptor)\n            if isinstance(prop, (list, set, tuple)):\n                prop.clear()\n            elif hasattr(prop, 'reset'):\n                prop.reset()\n            elif hasattr(prop, 'compute'):\n                prop.compute()\n```", "```python\ndef _initialize_object(cls, obj: 'Reactable') -> None:\n    \"\"\"\n    Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr_name in dir(obj):\n        attr = getattr(obj, attr_name)\n        if isinstance(attr, (property, types.MethodType) and hasattr(attr, '__reactive__')):\n            if isinstance(attr, property):\n                if not attr.fset:\n                    attr.fset(attr_name)\n            else:\n                attr.__reactive__.watch()\n```"]}, "textual-src/textual/message_pump.py-call_after_refresh": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_after_refresh(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass GUI:\n    def __init__(self):\n        self.callbacks = []\n        self.closed = False\n\n    def call_after_refresh(self, callback: callable, *args: Any, **kwargs: Any) -> bool:\n        \"\"\"Schedule a callback to run after all messages are processed and the screen\n        has been refreshed. Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\n        if self.closed:\n            return False\n        self.callbacks.append((callback, args, kwargs))\n        return True\n\n    def process_messages(self):\n        # Simulate message processing\n        print(\"Processing messages...\")\n        # Run callbacks\n        for callback, args, kwargs in self.callbacks:\n            callback(*args, **kwargs)\n        self.callbacks = []\n        self.closed = True\n        print(\"Screen refreshed.\")\n```", "```python\ndef call_after_refresh(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"\n    Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n    \"\"\"\n    if self.message_pump.is_alive():\n        self.message_pump.add_callback(callback, *args, **kwargs)\n        return True\n    return False\n```", "```python\nfrom typing import Callable, Any\n\nclass MessagePump:\n    def __init__(self):\n        self.callbacks = []\n\n    def call_after_refresh(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n        \"\"\"Schedule a callback to run after all messages are processed and the screen has been refreshed.\n        \n        Positional and keyword arguments are passed to the callable.\n\n        Args:\n            callback: A callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be scheduled\n                (may occur if the message pump was closed or closing).\n        \"\"\"\n        if self.is_closed:\n            return False\n        self.callbacks.append((callback, args, kwargs))\n        return True\n\n    def process_messages(self):\n        # Simulate message processing\n        pass\n\n    def refresh_screen(self):\n        # Simulate screen refresh\n        pass\n\n    @property\n    def is_closed(self):\n        # Simulate message pump state\n        return False\n```"]}, "textual-src/textual/message_pump.py-call_later": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n# Natural Language Annotations: \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Callable, Any\n\nclass MessagePump:\n    def __init__(self):\n        self.callbacks = []\n\n    def call_later(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n        \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n        \"\"\"\n        if not self.is_closed:\n            self.callbacks.append((callback, args, kwargs))\n            return True\n        return False\n\n    def is_closed(self):\n        # This method should be implemented based on the actual logic of your message pump\n        # For example, you can check if the message pump is closed or closing\n        return False  # Default implementation, you should replace this\n\n    def run_callbacks(self):\n        # Run all scheduled callbacks\n        for callback, args, kwargs in self.callbacks:\n            callback(*args, **kwargs)\n        self.callbacks = []  # Clear the list of callbacks\n```", "```python\nfrom typing import Callable, Any\n\nclass MessageProcessor:\n    def __init__(self):\n        self.callbacks = []\n\n    def call_later(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n        \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\n        if not hasattr(self, 'isclosed'):\n            self.callbacks.append((callback, args, kwargs))\n            return True\n        return False\n\n    def process_messages(self):\n        # simulate message processing\n        print(\"Processing messages...\")\n        self.callbacks.clear()\n        # call scheduled callbacks\n        for callback, args, kwargs in self.callbacks:\n            callback(*args, **kwargs)\n```", "```python\nfrom typing import Callable, Any\n\nclass MessagePump:\n    def __init__(self):\n        self._callback_queue = []\n        self._closed = False\n\n    def close(self):\n        self._closed = True\n\n    def call_later(self, callback: Callable, *args: Any, **kwargs: Any) -> bool:\n        \"\"\"Schedule a callback to run after all messages are processed in this object.\n        Positional and keywords arguments are passed to the callable.\n\n        Args:\n            callback: Callable to call next.\n            *args: Positional arguments to pass to the callable.\n            **kwargs: Keyword arguments to pass to the callable.\n\n        Returns:\n            `True` if the callback was scheduled, or `False` if the callback could not be\n                scheduled (may occur if the message pump was closed or closing).\n\n        \"\"\"\n        if self._closed:\n            return False\n        self._callback_queue.append((callback, args, kwargs))\n        return True\n```"]}, "textual-src/textual/message_pump.py-post_message": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def post_message(self, message: Message) -> bool:\n# Natural Language Annotations: \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"\n    Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    # Assuming Message is a class with a process method\n    if message is not None and hasattr(message, 'process'):\n        message.process()\n        return True\n    else:\n        return False\n```", "```python\nfrom typing import TypeVar, Generic\nfrom abc import ABC, abstractmethod\n\nclass Message:\n    def __init__(self, content: str):\n        self.content = content\n\nclass Widget(Generic[Message]):\n    def post_message(self, message: Message) -> bool:\n        \"\"\"Posts a message on to this widget's queue.\n\n        Args:\n            message: A message (including Event).\n\n        Returns:\n            `True` if the messages was processed, `False` if it wasn't.\n        \"\"\"\n        # Simulating a queue\n        self.queue = []\n        self.queue.append(message)\n        return True\n```", "```python\nclass Message:\n    def __init__(self, text, event=None):\n        self.text = text\n        self.event = event\n\ndef post_message(self, message: Message) -> bool:\n    \"\"\"\n    Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    # Assuming self.queue is a list to hold the messages\n    self.queue.append(message)\n    return True\n```"]}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def get_values_in_region(self, region: Region) -> list[ValueType]:\n# Natural Language Annotations: \"\"\"Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import List, TypeVar\n\nValueType = TypeVar('ValueType')\n\nclass Region:\n    def __init__(self, bounds: List[float]) -> None:\n        self.bounds = bounds\n\n    def intersects(self, other: 'Region') -> bool:\n        # implementation of region intersection logic\n\ndef get_values_in_region(self, region: Region) -> List[ValueType]:\n    \"\"\"\n    Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    # Assume we have a database of values and their corresponding regions\n    values = [\n        {'id': 1, 'value': 10, 'region': Region([0, 10])},\n        {'id': 2, 'value': 20, 'region': Region([5, 15])},\n        {'id': 3, 'value': 30, 'region': Region([15, 25])},\n    ]\n\n    intersecting_values = []\n    for value in values:\n        if region.intersects(value['region']):\n            intersecting_values.append(value['value'])\n\n    return intersecting_values\n```", "```python\nfrom typing import List\n\nclass Region:\n    def __init__(self, bounds: List[float]):\n        \"\"\"\n        Initialize a region with a set of bounds.\n        \n        Args:\n            bounds (List[float]): A list of float numbers representing the bounds of the region.\n        \"\"\"\n        self.bounds = bounds\n\n    def intersects(self, other) -> bool:\n        \"\"\"\n        Check if this region intersects with another region.\n\n        Args:\n            other (Region): Another region.\n\n        Returns:\n            bool: True if the regions intersect, False otherwise.\n        \"\"\"\n        # Assuming the bounds are 1D for simplicity\n        return (self.bounds[0] <= other.bounds[1] and other.bounds[0] <= self.bounds[1])\n\nclass ValueType:\n    def __init__(self, value: float):\n        \"\"\"\n        Initialize a value type with a float value.\n\n        Args:\n            value (float): The value of the value type.\n        \"\"\"\n        self.value = value\n\nclass Value:\n    def __init__(self, value_type: ValueType, region: Region):\n        \"\"\"\n        Initialize a value with a value type and a region.\n\n        Args:\n            value_type (ValueType): The type of the value.\n            region (Region): The region the value is in.\n        \"\"\"\n        self.value_type = value_type\n        self.region = region\n\nclass ValueStore:\n    def __init__(self):\n        \"\"\"\n        Initialize a value store.\n        \"\"\"\n        self.values = []\n\n    def add_value(self, value: Value):\n        \"\"\"\n        Add a value to the store.\n\n        Args:\n            value (Value): The value to add.\n        \"\"\"\n        self.values.append(value)\n\n    def get_values_in_region(self, region: Region) -> List[ValueType]:\n        \"\"\"\n        Get a superset of all the values that intersect with a given region.\n\n        Note that this may return false positives.\n\n        Args:\n            region: A region.\n\n        Returns:\n            Values under the region.\n        \"\"\"\n        return [value.value_type for value in self.values if region.intersects(value.region)]\n```", "```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"\n    Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    return [value for value in self.values if region.intersects(value.bounding_box)]\n```"]}, "textual-src/textual/validation.py-validate": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def validate(self, value: str) -> ValidationResult:\n# Natural Language Annotations: \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n        Args:\n            value: The value to validate.\n\n        Returns:\n            The result of the validation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom urllib.parse import urlparse\n\nclass ValidationResult:\n    def __init__(self, is_valid: bool, message: str):\n        self.is_valid = is_valid\n        self.message = message\n\ndef validate(self, value: str) -> 'ValidationResult':\n    \"\"\"\n    Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    try:\n        result = urlparse(value)\n        if not result.scheme:\n            return ValidationResult(False, \"Invalid URL: missing scheme\")\n        return ValidationResult(True, \"Valid URL\")\n    except ValueError:\n        return ValidationResult(False, \"Invalid URL: invalid syntax\")\n```", "```python\nfrom urllib.parse import urlparse\n\nclass ValidationResult:\n    def __init__(self, is_valid: bool, message: str):\n        self.is_valid = is_valid\n        self.message = message\n\n    def __str__(self):\n        return f\"ValidationResult(is_valid={self.is_valid}, message='{self.message}')\"\n\nclass URLValidator:\n    def validate(self, value: str) -> 'ValidationResult':\n        try:\n            result = urlparse(value)\n            if not result.scheme:\n                return ValidationResult(False, \"URL must contain a scheme\")\n            return ValidationResult(True, \"URL is valid\")\n        except ValueError:\n            return ValidationResult(False, \"Invalid URL\")\n```", "```python\nfrom urllib.parse import urlparse\n\nclass ValidationResult:\n    def __init__(self, is_valid: bool, message: str = None):\n        self.is_valid = is_valid\n        self.message = message\n\ndef validate(self, value: str) -> 'ValidationResult':\n    try:\n        result = urlparse(value)\n        if not result.scheme:\n            return ValidationResult(False, \"Value does not contain a scheme.\")\n        return ValidationResult(True, None)\n    except ValueError:\n        return ValidationResult(False, \"Value is not a valid URL.\")\n```"]}, "textual-src/textual/geometry.py-clamp": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def clamp(self, width: int, height: int) -> Offset:\n# Natural Language Annotations: \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Offset:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def clamp(self, width: int, height: int) -> 'Offset':\n        return Offset(max(0, min(self.x, width)), max(0, min(self.y, height)))\n```", "```python\nclass Offset:\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n\n    def clamp(self, width: int, height: int) -> 'Offset':\n        \"\"\"\n        Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\n        # Calculate the new x coordinate, clamping it to the range [0, width]\n        new_x = max(0, min(self.x, width))\n        \n        # Calculate the new y coordinate, clamping it to the range [0, height]\n        new_y = max(0, min(self.y, height))\n        \n        # Return a new Offset object with the clamped coordinates\n        return Offset(new_x, new_y)\n```", "```python\nclass Offset:\n    def __init__(self, x=0, y=0):\n        self.x = x\n        self.y = y\n\n    def clamp(self, width: int, height: int) -> 'Offset':\n        \"\"\"\n        Clamp the offset to fit within a rectangle of width x height.\n\n        Args:\n            width: Width to clamp.\n            height: Height to clamp.\n\n        Returns:\n            A new offset.\n        \"\"\"\n        new_x = max(0, min(self.x, width))\n        new_y = max(0, min(self.y, height))\n        return Offset(new_x, new_y)\n```"]}, "textual-src/textual/constants.py-_get_textual_animations": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _get_textual_animations() -> AnimationLevel:\n# Natural Language Annotations: \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom textual.constants import AnimationLevel\n\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    animation_level = os.environ.get('TEXTUAL_ANIMATIONS')\n    if animation_level is None:\n        return AnimationLevel.ALL\n    try:\n        return AnimationLevel[animation_level.upper()]\n    except KeyError:\n        return AnimationLevel.ALL\n```", "```python\nimport os\nfrom textual.constants import AnimationLevel\n\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    animation_level = os.environ.get('TEXTUAL_ANIMATIONS')\n    if animation_level not in AnimationLevel.__members__:\n        animation_level = AnimationLevel.ALL\n    return AnimationLevel[animation_level]\n```", "```python\nimport os\nfrom textual.constants import AnimationLevel\n\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    animation_level = os.environ.get('TEXTUAL_ANIMATION_LEVEL')\n    if animation_level is None:\n        return AnimationLevel.ALL\n    elif animation_level == 'none':\n        return AnimationLevel.NONE\n    elif animation_level == 'minimal':\n        return AnimationLevel.MINIMAL\n    elif animation_level == 'fancy':\n        return AnimationLevel.FANCY\n    else:\n        return AnimationLevel.ALL\n```"]}, "textual-src/textual/color.py-parse": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(cls, color_text: str | Color) -> Color:\n# Natural Language Annotations: \"\"\"Parse a string containing a named color or CSS-style color.\n\n        Colors may be parsed from the following formats:\n\n        - Text beginning with a `#` is parsed as a hexadecimal color code,\n         where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n            - `#RGB`\n            - `#RGBA`\n            - `#RRGGBB`\n            - `#RRGGBBAA`\n\n        - Alternatively, RGB colors can also be specified in the format\n         that follows, where R, G, and B must be numbers between 0 and 255\n         and A must be a value between 0 and 1:\n\n            - `rgb(R,G,B)`\n            - `rgb(R,G,B,A)`\n\n        - The HSL model can also be used, with a syntax similar to the above,\n         if H is a value between 0 and 360, S and L are percentages, and A\n         is a value between 0 and 1:\n\n            - `hsl(H,S,L)`\n            - `hsla(H,S,L,A)`\n\n        Any other formats will raise a `ColorParseError`.\n\n        Args:\n            color_text: Text with a valid color format. Color objects will\n                be returned unmodified.\n\n        Raises:\n            ColorParseError: If the color is not encoded correctly.\n\n        Returns:\n            Instance encoding the color specified by the argument.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Union\nfrom dataclasses import dataclass\n\n@dataclass\nclass Color:\n    r: float\n    g: float\n    b: float\n    a: float\n\nclass ColorParseError(Exception):\n    pass\n\ndef parse(cls, color_text: str | Color) -> Color:\n    \"\"\"\n    Parse a string containing a named color or CSS-style color.\n\n    Colors may be parsed from the following formats:\n\n    - Text beginning with a `#` is parsed as a hexadecimal color code,\n     where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n        - `#RGB`\n        - `#RGBA`\n        - `#RRGGBB`\n        - `#RRGGBBAA`\n\n    - Alternatively, RGB colors can also be specified in the format\n     that follows, where R, G, and B must be numbers between 0 and 255\n     and A must be a value between 0 and 1:\n\n        - `rgb(R,G,B)`\n        - `rgb(R,G,B,A)`\n\n    - The HSL model can also be used, with a syntax similar to the above,\n     if H is a value between 0 and 360, S and L are percentages, and A\n     is a value between 0 and 1:\n\n        - `hsl(H,S,L)`\n        - `hsla(H,S,L,A)`\n\n    Any other formats will raise a `ColorParseError`.\n\n    Args:\n        color_text: Text with a valid color format. Color objects will\n            be returned unmodified.\n\n    Raises:\n        ColorParseError: If the color is not encoded correctly.\n\n    Returns:\n        Instance encoding the color specified by the argument.\n    \"\"\"\n    if isinstance(color_text, Color):\n        return color_text\n\n    if color_text.startswith('#'):\n        if len(color_text) == 4:\n            r = int(color_text[1:2], 16)\n            g = int(color_text[2:3], 16)\n            b = int(color_text[3:4], 16)\n            a = 1.0\n        elif len(color_text) == 5:\n            r = int(color_text[1:2], 16)\n            g = int(color_text[2:3], 16)\n            b = int(color_text[3:4], 16)\n            a = 1.0\n        elif len(color_text) == 7:\n            r = int(color_text[1:3], 16)\n            g = int(color_text[3:5], 16)\n            b = int(color_text[5:7], 16)\n            a = 1.0\n        elif len(color_text) == 9:\n            r = int(color_text[1:3], 16)\n            g = int(color_text[3:5], 16)\n            b = int(color_text[5:7], 16)\n            a = float(color_text[7:9], 16)\n        else:\n            raise ColorParseError(\"Invalid hexadecimal color code\")\n    elif color_text.startswith('rgb'):\n        parts = color_text[4:-1].split(',')\n        if len(parts) == 3:\n            r, g, b = map(int, parts)\n            a = 1.0\n        elif len(parts) == 4:\n            r, g, b, a = map(float, parts)\n            if a < 0 or a > 1:\n                raise ColorParseError(\"Invalid alpha value\")\n        else:\n            raise ColorParseError(\"Invalid RGB color format\")\n    elif color_text.startswith('hsl'):\n        parts = color_text[4:-1].split(',')\n        if len(parts) == 3:\n            h, s, l = map(float, parts)\n            a = 1.0\n        elif len(parts) == 4:\n            h, s, l, a = map(float, parts)\n            if a < 0 or a > 1:\n                raise ColorParseError(\"Invalid alpha value\")\n        else:\n            raise ColorParseError(\"Invalid HSL color format\")\n    else:\n        raise ColorParseError(\"Invalid color format\")\n\n    return Color(r, g, b, a)\n```", "```python\nfrom dataclasses import dataclass\nfrom enum import Enum\nfrom typing import Union\n\nclass ColorError(Exception):\n    pass\n\nclass ColorParseError(ColorError):\n    pass\n\nclass Color(Enum):\n    def __init__(self, r, g, b, a=1.0):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.a = a\n\n@dataclass\nclass ColorRGB(Color):\n    r: int\n    g: int\n    b: int\n\n@dataclass\nclass ColorHSL(Color):\n    h: int\n    s: float\n    l: float\n\nclass ColorRGBAlpha(Color):\n    def __init__(self, r: int, g: int, b: int, a: float):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.a = a\n\nclass ColorHSLA(Color):\n    def __init__(self, h: int, s: float, l: float, a: float):\n        self.h = h\n        self.s = s\n        self.l = l\n        self.a = a\n\ndef parse(cls, color_text: Union[str, 'Color']) -> 'Color':\n    if isinstance(color_text, Color):\n        return color_text\n    \n    if color_text.startswith('#'):\n        if len(color_text) == 7:\n            return ColorRGB(\n                int(color_text[1:3], 16),\n                int(color_text[3:5], 16),\n                int(color_text[5:7], 16)\n            )\n        elif len(color_text) == 9:\n            return ColorRGBAlpha(\n                int(color_text[1:3], 16),\n                int(color_text[3:5], 16),\n                int(color_text[5:7], 16),\n                int(color_text[7:9], 16) / 255\n            )\n        else:\n            raise ColorParseError('Invalid hexadecimal color code')\n    elif color_text.startswith('rgb'):\n        parts = color_text[4:-1].split(',')\n        if len(parts) == 3:\n            return ColorRGB(\n                int(parts[0].strip()),\n                int(parts[1].strip()),\n                int(parts[2].strip())\n            )\n        elif len(parts) == 4:\n            return ColorRGBAlpha(\n                int(parts[0].strip()),\n                int(parts[1].strip()),\n                int(parts[2].strip()),\n                float(parts[3].strip()) / 100\n            )\n        else:\n            raise ColorParseError('Invalid RGB color')\n    elif color_text.startswith('hsl'):\n        parts = color_text[4:-1].split(',')\n        if len(parts) == 3:\n            return ColorHSL(\n                int(parts[0].strip()),\n                float(parts[1].strip().replace('%', '')) / 100,\n                float(parts[2].strip().replace('%', '')) / 100\n            )\n        elif len(parts) == 4:\n            return ColorHSLA(\n                int(parts[0].strip()),\n                float(parts[1].strip().replace('%', '')) / 100,\n                float(parts[2].strip().replace('%', '')) / 100,\n                float(parts[3].strip().replace('%', '')) / 100\n            )\n        else:\n            raise ColorParseError('Invalid HSL color')\n    else:\n        raise ColorParseError('Invalid color format')\n```", "```python\nfrom colorsys import rgb_to_hls, hls_to_rgb, rgb_to_hsv, hsv_to_rgb\nfrom typing import Union\n\nclass Color:\n    def __init__(self, r: int, g: int, b: int, a: float = 1.0):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.a = a\n\nclass ColorParseError(Exception):\n    pass\n\ndef parse(cls, color_text: Union[str, 'Color']) -> 'Color':\n    \"\"\"\n    Parse a string containing a named color or CSS-style color.\n\n    Colors may be parsed from the following formats:\n\n    - Text beginning with a `#` is parsed as a hexadecimal color code,\n      where R, G, B, and A must be hexadecimal digits (0-9A-F):\n\n        - `#RGB`\n        - `#RGBA`\n        - `#RRGGBB`\n        - `#RRGGBBAA`\n\n    - Alternatively, RGB colors can also be specified in the format\n      that follows, where R, G, and B must be numbers between 0 and 255\n      and A must be a value between 0 and 1:\n\n        - `rgb(R,G,B)`\n        - `rgb(R,G,B,A)`\n\n    - The HSL model can also be used, with a syntax similar to the above,\n      if H is a value between 0 and 360, S and L are percentages, and A\n      is a value between 0 and 1:\n\n        - `hsl(H,S,L)`\n        - `hsla(H,S,L,A)`\n\n    Any other formats will raise a `ColorParseError`.\n\n    Args:\n        color_text: Text with a valid color format. Color objects will\n            be returned unmodified.\n\n    Raises:\n        ColorParseError: If the color is not encoded correctly.\n\n    Returns:\n        Instance encoding the color specified by the argument.\n    \"\"\"\n\n    if isinstance(color_text, Color):\n        return color_text\n\n    if color_text.startswith('#'):\n        color = color_text.lstrip('#')\n        if len(color) == 3:\n            r, g, b, a = int(color[0]*2, 16), int(color[1]*2, 16), int(color[2]*2, 16), 1.0\n        elif len(color) == 4:\n            r, g, b, a = int(color[:2], 16), int(color[2:4], 16), int(color[4:], 16), 1.0\n        elif len(color) == 6:\n            r, g, b = int(color[:2], 16), int(color[2:4], 16), int(color[4:], 16)\n            a = 1.0\n        elif len(color) == 8:\n            r, g, b, a = int(color[:2], 16), int(color[2:4], 16), int(color[4:6], 16), int(color[6:], 16) / 255.0\n        else:\n            raise ColorParseError(\"Invalid color format\")\n        return Color(r, g, b, a)\n\n    elif color_text.startswith('rgb'):\n        parts = color_text[4:-1].split(',')\n        if len(parts) == 3:\n            r, g, b = map(int, parts)\n            a = 1.0\n        elif len(parts) == 4:\n            r, g, b, a = map(float, parts)\n        else:\n            raise ColorParseError(\"Invalid color format\")\n        return Color(r, g, b, a)\n\n    elif color_text.startswith('hsl'):\n        parts = color_text[4:-1].split(',')\n        if len(parts) == 3:\n            h, s, l = map(float, parts)\n            a = 1.0\n        elif len(parts) == 4:\n            h, s, l, a = map(float, parts)\n        else:\n            raise ColorParseError(\"Invalid color format\")\n        r, g, b = hls_to_rgb(h/360.0, s/100.0, l/100.0)\n        return Color(int(r*255), int(g*255), int(b*255), a)\n\n    else:\n        raise ColorParseError(\"Invalid color format\")\n```"]}, "textual-src/textual/_slug.py-slug": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def slug(self, text: str) -> str:\n# Natural Language Annotations: \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n        Args:\n            text: The text to generate a slug from.\n\n        Returns:\n            A slug for the given text.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef slug(self, text: str) -> str:\n    \"\"\"\n    Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    import re\n    text = text.strip().lower()\n    text = re.sub(r'[^\\w\\s-]', '', text)\n    text = re.sub(r'\\s+', '-', text)\n    text = re.sub(r'^-+|-+$', '', text)\n    return text\n```", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"\n    Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    import re\n    text = re.sub(r'[^\\w\\s-]', '', text).lower()\n    return re.sub(r'[-\\s]+', '-', text).strip('-')\n```", "```python\ndef slug(self, text: str) -> str:\n    \"\"\"\n    Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    import re\n    import unicodedata\n    text = unicodedata.normalize('NFKD', text).encode('ascii', 'ignore').decode('utf-8')\n    text = re.sub(r'[^\\w\\s-]', '', text).lower()\n    text = re.sub(r'\\s+', '-', text)\n    text = re.sub(r'-+', '-', text)\n    text = text.strip('-')\n    return text\n```"]}, "textual-src/textual/_styles_cache.py-render": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def render(\n# Natural Language Annotations: \"\"\"Render a widget content plus CSS styles.\n\n        Args:\n            styles: CSS Styles object.\n            size: Size of widget.\n            base_background: Background color beneath widget.\n            background: Background color of widget.\n            render_content_line: Callback to render content line.\n            console: The console in use by the app.\n            border_title: Optional tuple of (title, color, background, style).\n            border_subtitle: Optional tuple of (subtitle, color, background, style).\n            content_size: Size of content or None to assume full size.\n            padding: Override padding from Styles, or None to use styles.padding.\n            crop: Region to crop to.\n            filters: Additional post-processing for the segments.\n            opacity: Widget opacity.\n\n        Returns:\n            Rendered lines.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef render(\n    styles,\n    size,\n    base_background,\n    background,\n    render_content_line,\n    console,\n    border_title=None,\n    border_subtitle=None,\n    content_size=None,\n    padding=None,\n    crop=None,\n    filters=None,\n    opacity=1.0\n):\n    \"\"\"\n    Render a widget content plus CSS styles.\n\n    Args:\n        styles: CSS Styles object.\n        size: Size of widget.\n        base_background: Background color beneath widget.\n        background: Background color of widget.\n        render_content_line: Callback to render content line.\n        console: The console in use by the app.\n        border_title: Optional tuple of (title, color, background, style).\n        border_subtitle: Optional tuple of (subtitle, color, background, style).\n        content_size: Size of content or None to assume full size.\n        padding: Override padding from Styles, or None to use styles.padding.\n        crop: Region to crop to.\n        filters: Additional post-processing for the segments.\n        opacity: Widget opacity.\n\n    Returns:\n        Rendered lines.\n    \"\"\"\n\n    # Create a new image with the base background\n    img = Image.new('RGB', size, base_background)\n\n    # Get the styles and padding\n    if padding is None:\n        padding = styles.padding\n    else:\n        padding = padding\n\n    # Render the content\n    lines = []\n    for y in range(size[1]):\n        for x in range(size[0]):\n            # Check if the point is in the content area\n            if content_size is None or (x, y) in content_size:\n                # Render the content line\n                lines.append(render_content_line(x, y, styles, console))\n\n    # Apply filters\n    if filters:\n        lines = filters(lines)\n\n    # Crop the image to the specified region\n    if crop:\n        lines = lines[crop[0]:crop[1], crop[2]:crop[3]]\n\n    # Add border title and subtitle\n    if border_title:\n        title, color, background, style = border_title\n        lines.append((title, color, background, style, padding))\n\n    if border_subtitle:\n        subtitle, color, background, style = border_subtitle\n        lines.append((subtitle, color, background, style, padding))\n\n    # Apply styles\n    lines = styles.apply(lines, size, padding, opacity)\n\n    return lines\n```", "```python\ndef render(\n    styles,\n    size,\n    base_background,\n    background,\n    render_content_line,\n    console,\n    border_title=None,\n    border_subtitle=None,\n    content_size=None,\n    padding=None,\n    crop=None,\n    filters=None,\n    opacity=1.0\n):\n    \"\"\"\n    Render a widget content plus CSS styles.\n\n    Args:\n        styles: CSS Styles object.\n        size: Size of widget.\n        base_background: Background color beneath widget.\n        background: Background color of widget.\n        render_content_line: Callback to render content line.\n        console: The console in use by the app.\n        border_title: Optional tuple of (title, color, background, style).\n        border_subtitle: Optional tuple of (subtitle, color, background, style).\n        content_size: Size of content or None to assume full size.\n        padding: Override padding from Styles, or None to use styles.padding.\n        crop: Region to crop to.\n        filters: Additional post-processing for the segments.\n        opacity: Widget opacity.\n\n    Returns:\n        Rendered lines.\n    \"\"\"\n\n    # Initialize rendered lines\n    rendered_lines = []\n\n    # Render title\n    if border_title:\n        title, title_color, title_background, title_style = border_title\n        rendered_lines.append(render_content_line(title, title_color, title_background, title_style, styles, size, opacity))\n\n    # Render subtitle\n    if border_subtitle:\n        subtitle, subtitle_color, subtitle_background, subtitle_style = border_subtitle\n        rendered_lines.append(render_content_line(subtitle, subtitle_color, subtitle_background, subtitle_style, styles, size, opacity))\n\n    # Render content\n    if content_size:\n        content_size = (content_size[0], content_size[1])\n    else:\n        content_size = size\n    content_lines = render_content_line(render_content_line, background, base_background, styles, content_size, opacity, crop, filters)\n\n    # Add content lines to rendered lines\n    rendered_lines.extend(content_lines)\n\n    # Apply padding\n    if padding is not None:\n        styles.padding = padding\n    else:\n        styles.padding = styles.padding\n\n    # Return rendered lines\n    return rendered_lines\n```", "```python\nfrom typing import Callable, Tuple, Optional, List\n\ndef render(\n    styles: object,\n    size: Tuple[int, int],\n    base_background: str,\n    background: str,\n    render_content_line: Callable,\n    console: object,\n    border_title: Optional[Tuple[str, str, str, str]] = None,\n    border_subtitle: Optional[Tuple[str, str, str, str]] = None,\n    content_size: Optional[Tuple[int, int]] = None,\n    padding: Optional[Tuple[int, int, int, int]] = None,\n    crop: Optional[Tuple[int, int, int, int]] = None,\n    filters: Optional[List[str]] = None,\n    opacity: float = 1.0\n) -> List[str]:\n    rendered_lines = []\n\n    # render title\n    if border_title:\n        title, title_color, title_background, title_style = border_title\n        rendered_lines.append(render_content_line(title, title_color, title_background, title_style, styles, size, opacity))\n\n    # render subtitle\n    if border_subtitle:\n        subtitle, subtitle_color, subtitle_background, subtitle_style = border_subtitle\n        rendered_lines.append(render_content_line(subtitle, subtitle_color, subtitle_background, subtitle_style, styles, size, opacity))\n\n    # render content\n    content_size = content_size or size\n    rendered_lines.append(render_content_line(\"\", \"\", background, \"\", styles, content_size, opacity))\n\n    # apply padding\n    if padding:\n        rendered_lines = [(padding[0], padding[1]) + line for line in rendered_lines]\n    elif styles.padding:\n        rendered_lines = [(styles.padding[0], styles.padding[1]) + line for line in rendered_lines]\n\n    # crop\n    if crop:\n        rendered_lines = [line[crop[0]:crop[1], crop[2]:crop[3]] for line in rendered_lines]\n\n    # apply filters\n    if filters:\n        for filter in filters:\n            rendered_lines = [filter(line) for line in rendered_lines]\n\n    return rendered_lines\n```"]}, "textual-src/textual/document/_document.py-replace_range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n# Natural Language Annotations: \"\"\"Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Document:\n    # ... other methods and class variables ...\n\n    def replace_range(self, start: tuple, end: tuple, text: str) -> 'EditResult':\n        \"\"\"\n        Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\n        # Implement the replace_range method here\n        # For example:\n        result = EditResult()\n        # Update the document's content with the new text\n        self.content = self.content[:start[0]] + text + self.content[end[0]:]\n        return result\n```", "```python\nclass EditResult:\n    def __init__(self, replaced: bool, lines: list):\n        \"\"\"\n        The result of an edit operation.\n        \n        Args:\n            replaced (bool): Whether the operation replaced text.\n            lines (list): The lines of the document after the operation.\n        \"\"\"\n        self.replaced = replaced\n        self.lines = lines\n\nclass Location:\n    def __init__(self, row: int, column: int):\n        \"\"\"\n        A location in the document.\n        \n        Args:\n            row (int): The row of the location.\n            column (int): The column of the location.\n        \"\"\"\n        self.row = row\n        self.column = column\n\nclass Document:\n    def __init__(self, lines: list):\n        \"\"\"\n        A document.\n        \n        Args:\n            lines (list): The lines of the document.\n        \"\"\"\n        self.lines = lines\n\n    def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n        \"\"\"\n        Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\n        # Split the document into two parts at the start location\n        start_row, start_col = start.row, start.column\n        end_row, end_col = end.row, end.column\n\n        # Extract the part before the start location\n        before = self.lines[:start_row] + self.lines[start_row][:start_col]\n\n        # Extract the part after the end location\n        after = self.lines[end_row][end_col:] + self.lines[end_row + 1:]\n\n        # Insert the new text\n        new_lines = before + [text] + after\n\n        # Check if the operation replaced text\n        replaced = len(before) != len(new_lines)\n\n        return EditResult(replaced, new_lines)\n```", "```python\nclass EditResult:\n    def __init__(self, start: tuple, end: tuple, text: str):\n        \"\"\"\n        Initialize an EditResult object.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n        \"\"\"\n        self.start = start\n        self.end = end\n        self.text = text\n\nclass Location:\n    def __init__(self, row: int, col: int):\n        \"\"\"\n        Initialize a Location object.\n\n        Args:\n            row: The row number of the location.\n            col: The column number of the location.\n        \"\"\"\n        self.row = row\n        self.col = col\n\nclass Document:\n    def __init__(self, text: str):\n        \"\"\"\n        Initialize a Document object.\n\n        Args:\n            text: The initial text of the document.\n        \"\"\"\n        self.text = text\n\n    def replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n        \"\"\"\n        Replace text at the given range.\n\n        This is the only method by which a document may be updated.\n\n        Args:\n            start: A tuple (row, column) where the edit starts.\n            end: A tuple (row, column) where the edit ends.\n            text: The text to insert between start and end.\n\n        Returns:\n            The EditResult containing information about the completed\n                replace operation.\n        \"\"\"\n        # Check if start and end are valid locations\n        if start.row < 0 or start.col < 0 or end.row < 0 or end.col < 0:\n            raise ValueError(\"Invalid location\")\n\n        # Check if start is before end\n        if start.row > end.row or (start.row == end.row and start.col > end.col):\n            raise ValueError(\"Invalid range\")\n\n        # Replace the text in the document\n        self.text = self.text[:start.row * (max(len(self.text.split('\\n')) + 1) if '\\n' in self.text else 1) + start.col] + text + self.text[end.row * (max(len(self.text.split('\\n')) + 1) if '\\n' in self.text else 1) + end.col:]\n\n        # Return the EditResult\n        return EditResult(start, end, text)\n```"]}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def wrap_range(\n# Natural Language Annotations: \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n        This must be called *after* the source document has been edited.\n\n        Args:\n            start: The start location of the edit that was performed in document-space.\n            old_end: The old end location of the edit in document-space.\n            new_end: The new end location of the edit in document-space.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef wrap_range(start, old_end, new_end):\n    \"\"\"\n    Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n    if start > old_end or start > new_end or old_end < new_end:\n        raise ValueError(\"Invalid edit range\")\n    if start == old_end:\n        return start\n    return min(start + 1, new_end)\n```", "```\ndef wrap_range(start, old_end, new_end):\n    \"\"\"\n    Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n    if start > old_end or new_end < start:\n        raise ValueError(\"Invalid edit range\")\n    if new_end <= old_end:\n        return start, new_end\n    return start, old_end\n```", "```python\ndef wrap_range(start, old_end, new_end):\n    \"\"\"\n    Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n\n    Returns:\n        A list of locations where the cursor should be moved to.\n    \"\"\"\n    # Calculate the number of lines that were added or removed\n    num_lines_added = new_end.line - old_end.line\n    num_lines_removed = old_end.line - start.line\n\n    # Calculate the number of lines that were moved\n    num_lines_moved = max(0, new_end.line - start.line - num_lines_added)\n\n    # Calculate the new end location of the edit in line-space\n    new_end_line = new_end.line\n\n    # Calculate the start location of the edit in line-space\n    start_line = start.line + num_lines_removed\n\n    # If lines were added, the cursor should be moved to the end of the new lines\n    if num_lines_added > 0:\n        return [new_end_line + i for i in range(num_lines_added)]\n\n    # If lines were moved, the cursor should be moved to the end of the moved lines\n    elif num_lines_moved > 0:\n        return [start_line + i for i in range(num_lines_moved)]\n\n    # If no lines were added or moved, the cursor should be moved to the old end location\n    else:\n        return [old_end.line]\n```"]}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def offset_to_location(self, offset: Offset) -> Location:\n# Natural Language Annotations: \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nclass Document:\n    def __init__(self, content):\n        self.content = content\n        self.lines = content.split('\\n')\n\n    class Location:\n        def __init__(self, line_number, char_offset):\n            self.line_number = line_number\n            self.char_offset = char_offset\n\n    def offset_to_location(self, offset: int) -> 'Document.Location':\n        \"\"\"\n        Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\n        for i, line in enumerate(self.lines):\n            if offset <= len(line):\n                return self.Location(i + 1, offset)\n            offset -= len(line) + 1\n        raise ValueError(\"Offset does not correspond to a line in the document\")\n```", "```python\nclass Document:\n    def offset_to_location(self, offset: int) -> 'Location':\n        \"\"\"Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\n        # Assuming the document is represented as a list of lines\n        lines = self.lines\n        \n        # Calculate the line number and character offset\n        line_number = 0\n        char_offset = 0\n        for i, line in enumerate(lines):\n            if offset < len(line):\n                line_number = i + 1\n                char_offset = offset\n                break\n            offset -= len(line) + 1  # +1 for the newline character\n        \n        # Check if the offset corresponds to a line\n        if line_number == 0:\n            raise ValueError(\"Offset does not correspond to a line in the document\")\n        \n        # Return the location\n        return Location(line_number, char_offset)\n```", "```python\nclass Document:\n    def __init__(self, lines):\n        self.lines = lines\n\n    def offset_to_location(self, offset: int) -> 'Location':\n        \"\"\"\n        Given an offset within the wrapped/visual display of the document,\n        return the corresponding location in the document.\n\n        Args:\n            offset: The y-offset within the document.\n\n        Raises:\n            ValueError: When the given offset does not correspond to a line\n                in the document.\n\n        Returns:\n            The Location in the document corresponding to the given offset.\n        \"\"\"\n        if offset < 0:\n            raise ValueError(\"Offset cannot be negative\")\n        for i, line in enumerate(self.lines):\n            if offset < len(line):\n                return Location(i, offset)\n            offset -= len(line) + 1\n        raise ValueError(\"Offset does not correspond to a line in the document\")\n\nclass Location:\n    def __init__(self, line_number, char_number):\n        self.line_number = line_number\n        self.char_number = char_number\n\n    def __str__(self):\n        return f\"Line {self.line_number+1}, Character {self.char_number+1}\"\n```"]}, "textual-src/textual/css/parse.py-substitute_references": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def substitute_references(\n# Natural Language Annotations: \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom collections import defaultdict\nfrom dataclasses import dataclass\nfrom typing import Iterator\n\n@dataclass\nclass Token:\n    name: str\n    value: str\n    referenced_by: list = None\n\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    variable_values = defaultdict(str)\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            variable_values[token.value] = yield token\n        else:\n            yield token\n\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            value = variable_values[token.value]\n            value.referenced_by = [token]\n            yield value\n        else:\n            yield token\n\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            value = variable_values[token.value]\n            if value.referenced_by:\n                yield from value.referenced_by\n            else:\n                yield value\n```", "```python\ndef substitute_references(tokens):\n    \"\"\"\n    Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\n    # Create a dictionary to store the mapping of variable names to their values\n    variable_values = {}\n    \n    # Iterate over the tokens to populate the variable_values dictionary\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            variable_values[token.value] = token\n    \n    # Iterate over the tokens again to substitute variable references with values\n    for token in tokens:\n        # Check if the token is a variable reference\n        if token.name == \"variable_ref\":\n            # Get the value of the variable from the dictionary\n            value_token = variable_values.get(token.value)\n            # If the value is found, yield it instead of the variable reference\n            if value_token:\n                token.value = value_token.value\n                token.referenced_by = [token]\n                yield value_token\n            else:\n                # If the value is not found, yield the original token\n                yield token\n        else:\n            # If the token is not a variable reference, yield it as is\n            yield token\n```", "```python\nfrom collections import defaultdict\nfrom typing import Iterator, Dict\n\nclass Token:\n    def __init__(self, name: str, value: str, referenced_by: list = None):\n        self.name = name\n        self.value = value\n        self.referenced_by = referenced_by\n\n    def __eq__(self, other):\n        return self.name == other.name and self.value == other.value\n\ndef substitute_references(tokens: Iterator[Token]) -> Iterator[Token]:\n    \"\"\"\n    Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\n    # Create a dictionary to store variable references and their values\n    variable_values: Dict[str, Token] = defaultdict(lambda: None)\n    \n    # First pass: Store variable references and their values\n    for i, token in enumerate(tokens):\n        if token.name == \"variable_ref\":\n            variable_values[token.value] = token\n        yield token\n    \n    # Second pass: Replace variable references with their values\n    for i, token in enumerate(tokens):\n        if token.name == \"variable_ref\":\n            value = variable_values[token.value]\n            if value:\n                token.value = value.value\n                token.referenced_by = [i]  # Store the index where the token was substituted\n                yield value\n            else:\n                yield token\n        else:\n            yield token\n```"]}, "textual-src/textual/css/parse.py-parse": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(\n# Natural Language Annotations: \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom css_parser import CSSParser\n\ndef parse(scope, css, read_from, variables, is_default_rules):\n    \"\"\"\n    Parse CSS by tokenizing it, performing variable substitution, and generating rule sets from it.\n\n    Args:\n        scope (str): CSS type name.\n        css (str): The input CSS.\n        read_from (str): The source location of the CSS.\n        variables (dict): Substitution variables to substitute tokens for.\n        is_default_rules (bool): True if the rules we're extracting are default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n    # Create a CSSParser object\n    parser = CSSParser()\n\n    # Tokenize the CSS\n    tokens = parser.tokenize(css)\n\n    # Perform variable substitution\n    substituted_tokens = []\n    for token in tokens:\n        if token in variables:\n            substituted_tokens.append(variables[token])\n        else:\n            substituted_tokens.append(token)\n\n    # Generate rule sets from the substituted tokens\n    rule_sets = parser.generate_rule_sets(substituted_tokens, scope, read_from, is_default_rules)\n\n    return rule_sets\n```", "```python\ndef parse(scope, css, read_from, variables, is_default_rules):\n    \"\"\"\n    Parse CSS by tokenizing it, performing variable substitution, and generating rule sets from it.\n\n    Args:\n        scope (str): CSS type name.\n        css (str): The input CSS.\n        read_from (str): The source location of the CSS.\n        variables (dict): Substitution variables to substitute tokens for.\n        is_default_rules (bool): True if the rules we're extracting are default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n\n    Returns:\n        dict: A dictionary containing the parsed CSS rules.\n    \"\"\"\n    # Tokenize the CSS\n    tokens = css.splitlines()\n    \n    # Perform variable substitution\n    substituted_tokens = []\n    for token in tokens:\n        for var, value in variables.items():\n            token = token.replace(f'${var}', value)\n        substituted_tokens.append(token)\n    \n    # Generate rule sets\n    rules = {}\n    for token in substituted_tokens:\n        # Split the token into selector and style\n        selector, style = token.split('{')\n        selector = selector.strip()\n        style = style.strip().rstrip('}')\n        \n        # Add the rule to the rules dictionary\n        if selector not in rules:\n            rules[selector] = []\n        rules[selector].append(style)\n    \n    # Return the parsed CSS rules\n    return rules\n```", "```python\nimport re\nfrom collections import defaultdict\n\ndef parse(scope, css, read_from, variables, is_default_rules):\n    \"\"\"\n    Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n\n    Returns:\n        A dictionary of rule sets.\n    \"\"\"\n\n    # Split the CSS into individual rules\n    rules = re.split(r'}\\s*\\n', css)\n\n    # Remove empty rules\n    rules = [rule for rule in rules if rule]\n\n    # Initialize a dictionary to store the rule sets\n    rule_sets = defaultdict(dict)\n\n    # Iterate over each rule\n    for rule in rules:\n        # Extract the selector and properties\n        match = re.match(r'([^{]+)\\s*\\{\\s*([^}]+)\\s*\\}', rule)\n        if match:\n            selector, properties = match.groups()\n\n            # Perform variable substitution on the selector and properties\n            for variable, value in variables.items():\n                selector = selector.replace(f'${variable}', value)\n                properties = properties.replace(f'${variable}', value)\n\n            # Add the rule to the rule sets\n            rule_sets[selector] = properties\n\n    return dict(rule_sets)\n```"]}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def _parse_rules(\n# Natural Language Annotations: \"\"\"Parse CSS and return rules.\n\n        Args:\n            css: String containing Textual CSS.\n            read_from: Original CSS location.\n            is_default_rules: True if the rules we're extracting are\n                default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n            scope: Scope of rules, or empty string for global scope.\n\n        Raises:\n            StylesheetError: If the CSS is invalid.\n\n        Returns:\n            List of RuleSets.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom cssutils import parseString\n\nclass StylesheetError(Exception):\n    pass\n\nclass RuleSet:\n    def __init__(self, selector, rules):\n        self.selector = selector\n        self.rules = rules\n\ndef _parse_rules(css, read_from, is_default_rules, scope):\n    \"\"\"\n    Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    try:\n        sheet = parseString(css)\n    except Exception as e:\n        raise StylesheetError(f\"Invalid CSS at {read_from}: {str(e)}\")\n\n    rules = []\n    for rule in sheet:\n        if isinstance(rule, cssutils.css.CSSStyleRule):\n            selector = rule.selectorText.strip()\n            styles = {}\n            for style in rule.style:\n                styles[style.name] = style.property.replace(';', '')\n            rules.append(RuleSet(selector, styles))\n\n    return rules\n```", "```python\nfrom cssutils import parseString\nfrom stylesheet import StylesheetError, RuleSet\n\ndef _parse_rules(css, read_from, is_default_rules, scope):\n    \"\"\"\n    Parse CSS and return rules.\n\n    Args:\n        css (str): String containing Textual CSS.\n        read_from (str): Original CSS location.\n        is_default_rules (bool): True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope (str): Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    try:\n        stylesheet = parseString(css)\n    except Exception as e:\n        raise StylesheetError(f\"Invalid CSS: {e}\")\n\n    rules = []\n    for rule in stylesheet:\n        if isinstance(rule, stylesheet.CSSStyleRule):\n            rules.append(RuleSet(rule, is_default_rules, scope))\n\n    return rules\n```", "```python\nimport re\nfrom cssutils import parseString\n\nclass StylesheetError(Exception):\n    pass\n\nclass RuleSet:\n    def __init__(self, selector, styles):\n        self.selector = selector\n        self.styles = styles\n\ndef _parse_rules(css, read_from, is_default_rules, scope):\n    try:\n        parsed_css = parseString(css)\n    except Exception as e:\n        raise StylesheetError(f\"Invalid CSS: {e}\")\n\n    rules = []\n    for rule in parsed_css.cssRules:\n        if rule.type == rule.STYLE_RULE:\n            selector = rule.selectorText\n            styles = {}\n            for style in rule.style:\n                styles[style.property.name] = style.property.value\n            rules.append(RuleSet(selector, styles))\n    return rules\n```"]}, "textual-src/textual/css/stylesheet.py-parse": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse(self) -> None:\n# Natural Language Annotations: \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom abc import ABC, abstractmethod\nfrom typing import List\n\nclass StylesheetParseError(Exception):\n    pass\n\nclass CSSParser(ABC):\n    @abstractmethod\n    def parse(self) -> None:\n        \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\n        pass\n\nclass CSSParserImpl(CSSParser):\n    def __init__(self, stylesheet: str):\n        self.stylesheet = stylesheet\n\n    def parse(self) -> None:\n        try:\n            # Parse the stylesheet\n            # For simplicity, let's assume we're parsing CSS rules\n            rules = self.stylesheet.split('}')\n            for rule in rules:\n                if rule:\n                    selector, properties = rule.split('{')\n                    # Validate selector and properties\n                    if not selector or not properties:\n                        raise StylesheetParseError(\"Invalid CSS rule\")\n                    # Parse properties\n                    property_list = properties.split(';')\n                    for prop in property_list:\n                        if not prop:\n                            raise StylesheetParseError(\"Invalid CSS property\")\n        except Exception as e:\n            raise StylesheetParseError(f\"Error parsing stylesheet: {str(e)}\")\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom css_parser.exceptions import StylesheetParseError\n\nclass StyleParser(ABC):\n    @abstractmethod\n    def parse(self) -> None:\n        \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\n        pass\n```", "```python\nfrom abc import ABC, abstractmethod\nfrom typing import Any\n\nclass StylesheetParseError(Exception):\n    pass\n\nclass Parser(ABC):\n    @abstractmethod\n    def parse(self) -> None:\n        \"\"\"Parse the source in the stylesheet.\n\n        Raises:\n            StylesheetParseError: If there are any CSS related errors.\n        \"\"\"\n        pass\n\nclass CSSParser(Parser):\n    def parse(self) -> None:\n        # Simulating the parsing process\n        try:\n            # Assuming self.stylesheet is the CSS source\n            # Replace this with actual parsing logic\n            self.stylesheet = self.parse_css(self.stylesheet)\n            if not self.stylesheet:\n                raise StylesheetParseError(\"CSS parsing failed\")\n        except Exception as e:\n            raise StylesheetParseError(f\"CSS parsing error: {e}\")\n\n# Example usage:\nparser = CSSParser()\nparser.parse()\n```"]}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def parse_diffs(diff_string: str) -> dict:\n# Natural Language Annotations: \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom dataclasses import dataclass\n\n@dataclass\nclass Diff:\n    filename: str\n    lines: list\n\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diffs = {}\n    lines = diff_string.splitlines()\n    current_filename = None\n    current_diff = []\n\n    for line in lines:\n        if line.startswith('@@'):\n            if current_filename:\n                diffs[current_filename] = Diff(filename=current_filename, lines=current_diff)\n                current_diff = []\n            current_filename = line[2:].strip()\n        elif line.startswith(' '):\n            current_diff.append(line[2:].strip())\n        elif line.startswith('- '):\n            current_diff.append(line[2:].strip())\n        elif line.startswith('+ '):\n            current_diff.append(line[2:].strip())\n        elif line.startswith('? '):\n            current_diff.append(line[2:].strip())\n        elif line == '':\n            if current_filename:\n                diffs[current_filename] = Diff(filename=current_filename, lines=current_diff)\n                current_diff = []\n        else:\n            continue\n\n    if current_filename:\n        diffs[current_filename] = Diff(filename=current_filename, lines=current_diff)\n\n    return diffs\n```", "```python\nfrom dataclasses import dataclass\nfrom typing import Dict\n\n@dataclass\nclass Diff:\n    filename: str\n    changes: Dict[str, str]\n\ndef parse_diffs(diff_string: str) -> Dict[str, Diff]:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    lines = diff_string.splitlines()\n    diffs = {}\n    current_filename = None\n    current_changes = {}\n\n    for line in lines:\n        if line.startswith('---'):\n            current_filename = line[4:].strip()\n            diffs[current_filename] = Diff(current_filename, {})\n        elif line.startswith('+++'):\n            pass  # Ignore the '+++'\n        elif line.startswith('@@'):\n            pass  # Ignore the '@@'\n        elif line.startswith(' '):\n            change = line[2:].strip()\n            current_changes[change] = line[2:].strip()\n        elif line.startswith('- '):\n            change = line[2:].strip()\n            current_changes[change] = '- ' + change\n        elif line.startswith('+ '):\n            change = line[2:].strip()\n            current_changes[change] = '+ ' + change\n        elif line == '':\n            if current_filename and current_changes:\n                diffs[current_filename] = Diff(current_filename, current_changes)\n                current_changes = {}\n        else:\n            print(f\"Unknown line: {line}\")\n\n    if current_filename and current_changes:\n        diffs[current_filename] = Diff(current_filename, current_changes)\n\n    return diffs\n```", "```python\nimport re\n\nclass Diff:\n    def __init__(self, filename, lines):\n        self.filename = filename\n        self.lines = lines\n\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    result = {}\n    lines = diff_string.split('\\n')\n    filename = None\n    diffs = []\n    \n    for line in lines:\n        if line.startswith('---') or line.startswith('+++') or line.startswith('@@'):\n            if filename:\n                result[filename] = Diff(filename, diffs)\n                diffs = []\n            if line.startswith('---'):\n                filename = line[4:].strip()\n            else:\n                filename = line[4:].strip()\n        elif line.startswith('@@'):\n            continue\n        else:\n            diffs.append(line.strip())\n    \n    if filename:\n        result[filename] = Diff(filename, diffs)\n    \n    return result\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n# Natural Language Annotations: \"\"\"\n        Start the conversation with a system message and a user message.\n\n        Parameters\n        ----------\n        system : str\n            The content of the system message.\n        user : str\n            The content of the user message.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom typing import Any, List\n\nclass Message:\n    def __init__(self, content: str, sender: str):\n        self.content = content\n        self.sender = sender\n\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    messages = [Message(system, 'system'), Message(user, 'user')]\n    return messages\n```", "```\nfrom typing import List, Any\n\nclass Message:\n    def __init__(self, sender: str, content: str):\n        self.sender = sender\n        self.content = content\n\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    messages = [\n        Message('system', system),\n        Message('user', user)\n    ]\n    return messages\n```", "```python\nfrom typing import Any, List\n\nclass Message:\n    def __init__(self, content: str, sender: str):\n        \"\"\"\n        Initialize a message.\n\n        Parameters\n        ----------\n        content : str\n            The content of the message.\n        sender : str\n            The sender of the message.\n        \"\"\"\n        self.content = content\n        self.sender = sender\n\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : Any\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    return [Message(system, 'System'), Message(user, 'User')]\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def next(\n# Natural Language Annotations: \"\"\"\n        Advances the conversation by sending message history\n        to LLM and updating with the response.\n\n        Parameters\n        ----------\n        messages : List[Message]\n            The list of messages in the conversation.\n        prompt : Optional[str], optional\n            The prompt to use, by default None.\n        step_name : str\n            The name of the step.\n\n        Returns\n        -------\n        List[Message]\n            The updated list of messages in the conversation.\n        \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\ndef next(messages, prompt=None, step_name=None):\n    # Send message history to LLM\n    response = send_to_llm(messages)\n    \n    # Update conversation with response\n    updated_messages = messages + [Message(response, step_name)]\n    \n    return updated_messages\n```", "```python\ndef next(messages: list, prompt: str = None, step_name: str = 'default_step'):\n    \"\"\"\n    Advances the conversation by sending message history\n    to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    # Simulating a language model response here\n    response = f\"Response to step {step_name}\"\n    messages.append(Message(text=response))\n    return messages\n```", "```python\ndef next(messages, prompt=None, step_name=''):\n    \"\"\"\n    Advances the conversation by sending message history\n    to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    # Simulate sending message history to LLM and getting the response\n    # For simplicity, we will just append a response to the messages list\n    # In a real application, you would replace this with actual LLM interaction\n    response = \"LLM Response\"\n\n    # Append the response to the messages list\n    messages.append(Message(step_name, response))\n\n    return messages\n```"]}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def to_toml(self, config_file: Path | str, save=True) -> str:\n# Natural Language Annotations: \"\"\"Write the configuration to a TOML file.\"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nimport toml\nfrom pathlib import Path\n\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"\n    Write the configuration to a TOML file.\n\n    Args:\n        config_file (Path | str): The path to the TOML file to write to.\n        save (bool, optional): Whether to save the configuration to the file. Defaults to True.\n\n    Returns:\n        str: The TOML configuration as a string.\n    \"\"\"\n    config = self.config  # Assuming self.config is a dictionary containing the configuration\n    toml_config = toml.dumps(config)\n    if save:\n        Path(config_file).parent.mkdir(parents=True, exist_ok=True)  # Create the parent directory if it doesn't exist\n        with open(config_file, 'w') as f:\n            f.write(toml_config)\n    return toml_config\n```", "```python\nfrom pathlib import Path\nimport toml\n\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"\n    Write the configuration to a TOML file.\n\n    Args:\n        config_file (Path | str): The path to the TOML file to write to.\n        save (bool, optional): If True, save the TOML file. Defaults to True.\n\n    Returns:\n        str: The TOML configuration as a string.\n    \"\"\"\n    config = self.get_config()  # Assuming self.get_config() is a method that returns the configuration\n    toml_config = toml.dumps(config)\n    if save:\n        with open(config_file, 'w') as f:\n            f.write(toml_config)\n    return toml_config\n```", "```python\nfrom typing import Path\nimport toml\n\nclass ConfigWriter:\n    def to_toml(self, config_file: Path | str, save=True) -> str:\n        \"\"\"\n        Write the configuration to a TOML file.\n        \n        Args:\n            config_file (Path | str): The path to the TOML file to write to.\n            save (bool, optional): Whether to save the configuration to the file. Defaults to True.\n        \n        Returns:\n            str: The TOML string representation of the configuration.\n        \"\"\"\n        # Check if config_file is a string and convert it to a Path object if necessary\n        from pathlib import Path\n        if isinstance(config_file, str):\n            config_file = Path(config_file)\n        \n        # Get the configuration from the object (this would depend on the class this method is a part of)\n        # For this example, we'll assume it's a dictionary\n        config = self.get_config()  # Replace with actual method to get the configuration\n        \n        # Write the configuration to the TOML file\n        toml_string = toml.dumps(config)\n        \n        if save:\n            with open(config_file, 'w') as f:\n                f.write(toml_string)\n        \n        return toml_string\n```"]}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"final_query": "# You are a professional programmer, please create a function based on the function signature and natural language annotations# Function Signature: def is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n# Natural Language Annotations: \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\nPlease only return the code surrounded by ```, do not reply any explanation\n", "response": ["```python\nfrom difflib import SequenceMatcher\n\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    # Remove spaces and convert to lower case\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n\n    # Calculate the similarity ratio\n    ratio = SequenceMatcher(None, str1, str2).ratio()\n\n    # Return True if the ratio is greater than or equal to the threshold\n    return ratio >= similarity_threshold\n```", "```python\nfrom difflib import SequenceMatcher\n\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    # Remove spaces and convert to lower case\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n    \n    # Use SequenceMatcher to calculate the similarity ratio\n    similarity = SequenceMatcher(None, str1, str2).ratio()\n    \n    # Return True if the similarity ratio is above the threshold\n    return similarity >= similarity_threshold\n```", "```python\nfrom difflib import SequenceMatcher\n\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n    return SequenceMatcher(None, str1, str2).ratio() >= similarity_threshold\n```"]}}