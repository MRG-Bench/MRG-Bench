{"langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": {"response": ["```java\n/**\n * Loads {@link Document}s from the specified directory. Does not use recursion.\n * <br>\n * The files are parsed using the specified {@link DocumentParser}.\n * <br>\n * Skips any {@code Document}s that fail to load.\n *\n * @param directoryPath  The path to the directory with files.\n * @param documentParser The parser to be used for parsing text from each file.\n * @return list of documents\n * @throws IllegalArgumentException If specified path is not a directory.\n */\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.list(directoryPath)) {\n        return loadDocuments(pathStream, path -> true, directoryPath, documentParser);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": {"response": ["```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n        return loadDocuments(pathStream, path -> true, directoryPath, documentParser);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": {"response": ["```java\npublic boolean hasSpaceFor(String text) {\n    int textSize = sizeOf(text);\n    int totalSize = textSize;\n    if (isNotEmpty()) {\n        totalSize += segmentSize + joinSeparatorSize;\n    }\n    return totalSize <= maxSegmentSize;\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": {"response": ["```java\npublic void append(String text) {\n    if (isNotEmpty()) {\n        segment += joinSeparator;\n        segmentSize += joinSeparatorSize;\n    }\n    segment += text;\n    segmentSize += sizeOf(text);\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": {"response": ["```java\n/**\n * Prepends the provided text to the current segment.\n * @param text The text to prepend.\n */\npublic void prepend(String text) {\n    if (isNotEmpty()) {\n        segment = text + joinDelimiter + segment;\n    } else {\n        segment = text;\n    }\n    segmentSize = sizeOf(segment);\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": {"response": ["```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    // Deprecated method, use contentRetriever instead\n    return this;\n}\n```"]}, "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": {"response": ["```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    if (retrieverSet || retrievalAugmentorSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    contentRetrieverSet = true;\n    context.retrievalAugmentor = new DefaultRetrievalAugmentor(ensureNotNull(contentRetriever, \"contentRetriever\"));\n    return this;\n}\n```"]}, "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": {"response": ["```java\n@Override\npublic String add(Embedding embedding) {\n    String id = randomUUID();\n    addInternal(id, embedding, null);\n    return id;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": {"response": ["```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n\n    for (Method method : classWithTools.getDeclaredMethods()) {\n        if (method.isAnnotationPresent(Tool.class)) {\n            ToolSpecification toolSpecification = createToolSpecification(method);\n            toolSpecifications.add(toolSpecification);\n        }\n    }\n\n    validateSpecifications(toolSpecifications);\n    return toolSpecifications;\n}\n\nprivate static ToolSpecification createToolSpecification(Method method) {\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    String toolName = isNullOrBlank(toolAnnotation.name()) ? method.getName() : toolAnnotation.name();\n    String toolDescription = String.join(\" \", toolAnnotation.value());\n\n    ToolSpecification.Builder builder = ToolSpecification.builder()\n            .name(toolName)\n            .description(toolDescription);\n\n    for (Parameter parameter : method.getParameters()) {\n        if (parameter.isAnnotationPresent(P.class)) {\n            P pAnnotation = parameter.getAnnotation(P.class);\n            String parameterName = parameter.getName();\n            String parameterDescription = pAnnotation.value();\n            boolean isRequired = pAnnotation.required();\n\n            JsonSchemaProperty parameterSchema = schema(parameter.getType());\n            if (parameterSchema != null) {\n                if (isRequired) {\n                    builder.addParameter(parameterName, parameterSchema);\n                } else {\n                    builder.addOptionalParameter(parameterName, parameterSchema);\n                }\n            }\n        }\n    }\n\n    return builder.build();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": {"response": ["```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    // Check if the method is annotated with @Tool\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n    if (toolAnnotation == null) {\n        throw new IllegalArgumentException(\"Method \" + method.getName() + \" is not annotated with @Tool\");\n    }\n\n    // Get the name of the tool, defaulting to the method name if not provided\n    String toolName = isNullOrBlank(toolAnnotation.name()) ? method.getName() : toolAnnotation.name();\n\n    // Get the description of the tool, defaulting to an empty string if not provided\n    String toolDescription = isNullOrBlank(toolAnnotation.value()[0]) ? \"\" : String.join(\" \", toolAnnotation.value());\n\n    // Create a builder for ToolSpecification\n    ToolSpecification.Builder toolSpecBuilder = ToolSpecification.builder()\n            .name(toolName)\n            .description(toolDescription);\n\n    // Process each parameter of the method\n    for (Parameter parameter : method.getParameters()) {\n        // Get the parameter name\n        String parameterName = parameter.getName();\n\n        // Get the @P annotation if present\n        P pAnnotation = parameter.getAnnotation(P.class);\n        String parameterDescription = pAnnotation != null ? pAnnotation.value() : \"\";\n        boolean isRequired = pAnnotation != null ? pAnnotation.required() : true;\n\n        // Convert the parameter type to JsonSchemaProperty\n        JsonSchemaProperty parameterSchema = parameterToJsonSchemaProperty(parameter);\n\n        // Add the parameter to the ToolSpecification\n        if (isRequired) {\n            toolSpecBuilder.addParameter(parameterName, parameterSchema, description(parameterDescription));\n        } else {\n            toolSpecBuilder.addOptionalParameter(parameterName, parameterSchema, description(parameterDescription));\n        }\n    }\n\n    // Build and return the ToolSpecification\n    return toolSpecBuilder.build();\n}\n\nprivate static JsonSchemaProperty parameterToJsonSchemaProperty(Parameter parameter) {\n    Class<?> parameterType = parameter.getType();\n    JsonSchemaProperty description = parameter.getAnnotation(Description.class) != null\n            ? description(String.join(\" \", parameter.getAnnotation(Description.class).value()))\n            : null;\n\n    // Convert the parameter type to JsonSchemaProperty\n    Iterable<JsonSchemaProperty> schemaProperties = toJsonSchemaProperties(parameterType, description);\n\n    // Combine the schema properties into a single JsonSchemaProperty\n    Map<String, Object> propertiesMap = new HashMap<>();\n    for (JsonSchemaProperty schemaProperty : schemaProperties) {\n        propertiesMap.put(schemaProperty.key(), schemaProperty.value());\n    }\n\n    return from(\"properties\", propertiesMap);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": {"response": ["```java\n/**\n * Convert a {@link Parameter} to a {@link JsonSchemaProperty}.\n *\n * @param parameter the parameter.\n * @return the {@link JsonSchemaProperty}.\n */\npublic static Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    Class<?> type = parameter.getType();\n    P annotation = parameter.getAnnotation(P.class);\n    JsonSchemaProperty description = annotation == null ? null : description(annotation.value());\n\n    Iterable<JsonSchemaProperty> simpleType = toJsonSchemaProperties(type, description);\n\n    if (simpleType != null) {\n        return simpleType;\n    }\n\n    if (Collection.class.isAssignableFrom(type)) {\n        return removeNulls(ARRAY, arrayTypeFrom((Class<?>) ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments()[0]), description);\n    }\n\n    return removeNulls(OBJECT, schema(type), description);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": {"response": ["```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    // Ensure that both embeddings are not null\n    ensureNotNull(embeddingA, \"embeddingA\");\n    ensureNotNull(embeddingB, \"embeddingB\");\n\n    // Get the vectors from the embeddings\n    List<Float> vectorA = embeddingA.vector();\n    List<Float> vectorB = embeddingB.vector();\n\n    // Ensure that both vectors have the same length\n    if (vectorA.size() != vectorB.size()) {\n        throw illegalArgument(\"The dimensions of the two embeddings must be the same.\");\n    }\n\n    // Calculate the dot product of the two vectors\n    double dotProduct = 0.0;\n    for (int i = 0; i < vectorA.size(); i++) {\n        dotProduct += vectorA.get(i) * vectorB.get(i);\n    }\n\n    // Calculate the magnitude (norm) of each vector\n    double magnitudeA = 0.0;\n    double magnitudeB = 0.0;\n    for (int i = 0; i < vectorA.size(); i++) {\n        magnitudeA += Math.pow(vectorA.get(i), 2);\n        magnitudeB += Math.pow(vectorB.get(i), 2);\n    }\n    magnitudeA = Math.sqrt(magnitudeA);\n    magnitudeB = Math.sqrt(magnitudeB);\n\n    // Avoid division by zero\n    if (magnitudeA == 0 || magnitudeB == 0) {\n        return 0.0; // Orthogonal vectors\n    }\n\n    // Calculate the cosine similarity\n    double cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n\n    return cosineSimilarity;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": {"response": ["```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> stringMap = new HashMap<>();\n    for (Map.Entry<String, Object> entry : metadata.entrySet()) {\n        stringMap.put(entry.getKey(), entry.getValue().toString());\n    }\n    return stringMap;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": {"response": ["```java\npackage dev.langchain4j.data.document;\n\nimport java.io.IOException;\n\n/**\n * Utility class for loading documents.\n */\npublic class DocumentLoader {\n\n    private DocumentLoader() {\n    }\n\n    /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\n    public static Document load(DocumentSource source, DocumentParser parser) {\n        try (InputStream inputStream = source.inputStream()) {\n            Document document = parser.parse(inputStream);\n            Metadata sourceMetadata = source.metadata();\n            return new Document(document.text(), sourceMetadata);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to load document from source\", e);\n        }\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": {"response": ["```java\npublic String singleText() {\n    if (contents.size() != 1 || !(contents.get(0) instanceof TextContent)) {\n        throw new RuntimeException(\"The message does not contain a single TextContent.\");\n    }\n    return ((TextContent) contents.get(0)).text();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": {"response": ["```java\ndefault AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Extract the chat message and metadata from the augmentation request\n    ChatMessage chatMessage = augmentationRequest.chatMessage();\n    Metadata metadata = augmentationRequest.metadata();\n\n    // Create an original query from the chat message text and metadata\n    Query originalQuery = Query.from(chatMessage.text(), metadata);\n\n    // Transform the original query into one or multiple queries\n    Collection<Query> queries = queryTransformer.transform(originalQuery);\n    logQueries(originalQuery, queries);\n\n    // Process the queries to retrieve contents\n    Map<Query, Collection<List<Content>>> queryToContents = process(queries);\n\n    // Aggregate the retrieved contents into a final list\n    List<Content> contents = contentAggregator.aggregate(queryToContents);\n    log(queryToContents, contents);\n\n    // Inject the final list of contents into the original chat message\n    ChatMessage augmentedChatMessage = contentInjector.inject(contents, chatMessage);\n    log(augmentedChatMessage);\n\n    // Return the result containing the augmented chat message and the used contents\n    return AugmentationResult.builder()\n            .chatMessage(augmentedChatMessage)\n            .contents(contents)\n            .build();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": {"response": ["```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    // Create an AugmentationRequest from the provided UserMessage and Metadata\n    AugmentationRequest augmentationRequest = new AugmentationRequest(userMessage, metadata);\n    \n    // Call the new augment method that takes an AugmentationRequest\n    AugmentationResult augmentationResult = augment(augmentationRequest);\n    \n    // Return the augmented UserMessage from the AugmentationResult\n    return (UserMessage) augmentationResult.chatMessage();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": {"response": ["```java\ndefault ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    if (contents.isEmpty()) {\n        return chatMessage;\n    }\n\n    Prompt prompt = createPrompt(chatMessage, contents);\n    if (chatMessage instanceof UserMessage && isNotNullOrBlank(((UserMessage) chatMessage).name())) {\n        return prompt.toUserMessage(((UserMessage) chatMessage).name());\n    }\n\n    return prompt.toUserMessage();\n}\n\nprotected Prompt createPrompt(ChatMessage chatMessage, List<Content> contents) {\n    if (chatMessage instanceof UserMessage) {\n        return createPrompt((UserMessage) chatMessage, contents);\n    } else {\n        throw runtime(\"Unsupported ChatMessage type: \" + chatMessage.getClass().getName());\n    }\n}\n\n@Deprecated\nprotected Prompt createPrompt(UserMessage userMessage, List<Content> contents) {\n    Map<String, Object> variables = new HashMap<>();\n    variables.put(\"userMessage\", userMessage.text());\n    variables.put(\"contents\", format(contents));\n    return promptTemplate.apply(variables);\n}\n\nprotected String format(List<Content> contents) {\n    return contents.stream()\n            .map(this::format)\n            .collect(joining(\"\\n\\n\"));\n}\n\nprotected String format(Content content) {\n    TextSegment segment = content.textSegment();\n\n    if (isNullOrEmpty(metadataKeysToInclude)) {\n        return segment.text();\n    }\n\n    String segmentContent = segment.text();\n    String segmentMetadata = format(segment.metadata());\n\n    return format(segmentContent, segmentMetadata);\n}\n\nprotected String format(Metadata metadata) {\n    StringBuilder formattedMetadata = new StringBuilder();\n    for (String metadataKey : metadataKeysToInclude) {\n        String metadataValue = metadata.get(metadataKey);\n        if (metadataValue != null) {\n            if (formattedMetadata.length() > 0) {\n                formattedMetadata.append(\"\\n\");\n            }\n            formattedMetadata.append(metadataKey).append(\": \").append(metadataValue);\n        }\n    }\n    return formattedMetadata.toString();\n}\n\nprotected String format(String segmentContent, String segmentMetadata) {\n    return segmentMetadata.isEmpty()\n            ? segmentContent\n            : String.format(\"content: %s\\n%s\", segmentContent, segmentMetadata);\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": {"response": ["```java\n/**\n * Are all the given strings not {@code null} and not blank?\n * @param strings The strings to check.\n * @return {@code true} if every string is non-{@code null} and non-empty.\n */\npublic static boolean areNotNullOrBlank(String... strings) {\n    for (String string : strings) {\n        if (isNullOrBlank(string)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": {"response": ["```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest digest = getSha256Instance();\n    byte[] hash = digest.digest(input.getBytes(UTF_8));\n    return UUID.nameUUIDFromBytes(hash).toString();\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": {"response": ["```java\npublic static byte[] readBytes(String url) {\n    try {\n        URL urlObj = new URL(url);\n        if (urlObj.getProtocol().equals(\"http\") || urlObj.getProtocol().equals(\"https\")) {\n            HttpURLConnection connection = (HttpURLConnection) urlObj.openConnection();\n            connection.setRequestMethod(\"GET\");\n            int responseCode = connection.getResponseCode();\n            if (responseCode == HTTP_OK) {\n                try (InputStream inputStream = connection.getInputStream();\n                     ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n                    byte[] buffer = new byte[1024];\n                    int bytesRead;\n                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n                        byteArrayOutputStream.write(buffer, 0, bytesRead);\n                    }\n                    return byteArrayOutputStream.toByteArray();\n                }\n            } else {\n                throw new RuntimeException(\"HTTP request failed with response code: \" + responseCode);\n            }\n        } else if (urlObj.getProtocol().equals(\"file\")) {\n            return Files.readAllBytes(Paths.get(urlObj.toURI()));\n        } else {\n            throw new IllegalArgumentException(\"Unsupported protocol: \" + urlObj.getProtocol());\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to read bytes from URL: \" + url, e);\n    }\n}\n```"]}, "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": {"response": ["```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelayMs = rawDelayMs(attempt);\n    Random rand = new Random();\n    return (int) (rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale)));\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": {"response": ["```java\n/**\n * \u83b7\u53d6 \u4e3b\u952e\u751f\u6210\u5668\n *\n * @param name\n * @return \u4e3b\u952e\u751f\u6210\u5668\n */\npublic static IKeyGenerator getKeyGenerator(String name) {\n    if (StringUtil.isBlank(name)) {\n        throw FlexExceptions.wrap(LocalizedFormats.KEY_GENERATOR_NAME_IS_BLANK);\n    }\n    IKeyGenerator keyGenerator = KEY_GENERATOR_MAP.get(name.trim());\n    if (keyGenerator == null) {\n        throw FlexExceptions.wrap(LocalizedFormats.KEY_GENERATOR_NOT_FOUND, name);\n    }\n    return keyGenerator;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": {"response": ["```java\npublic QueryCondition when(boolean effective) {\n    if (notEmpty()) {\n        this.effective = effective;\n    }\n    return this;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": {"response": ["```java\npublic static String methodToProperty(String name) {\n    if (name.startsWith(\"is\")) {\n        name = name.substring(2);\n    } else if (name.startsWith(\"get\") || name.startsWith(\"set\")) {\n        name = name.substring(3);\n    } else {\n        throw new IllegalArgumentException(\"Error parsing property name '\" + name + \"'.  Didn't start with 'is', 'get' or 'set'.\");\n    }\n\n    if (name.length() == 1 || (name.length() > 1 && !Character.isUpperCase(name.charAt(1)))) {\n        name = name.substring(0, 1).toLowerCase() + name.substring(1);\n    }\n\n    return name;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": {"response": ["```java\npublic static String camelToUnderline(String string) {\n    if (StringUtil.isBlank(string)) {\n        return string;\n    }\n\n    StringBuilder result = new StringBuilder();\n    char[] chars = string.toCharArray();\n    for (char ch : chars) {\n        if (Character.isUpperCase(ch)) {\n            result.append('_').append(Character.toLowerCase(ch));\n        } else {\n            result.append(ch);\n        }\n    }\n\n    return result.toString();\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": {"response": ["```java\npublic static String underlineToCamel(String string) {\n    if (StringUtil.isBlank(string)) {\n        return string;\n    }\n\n    StringBuilder sb = new StringBuilder();\n    boolean toUpperCase = false;\n\n    for (char ch : string.toCharArray()) {\n        if (ch == '_') {\n            toUpperCase = true;\n        } else {\n            if (toUpperCase) {\n                sb.append(Character.toUpperCase(ch));\n                toUpperCase = false;\n            } else {\n                sb.append(ch);\n            }\n        }\n    }\n\n    return sb.toString();\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": {"response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        synchronized (concurrentHashMap) {\n            value = concurrentHashMap.get(key);\n            if (value == null) {\n                value = mappingFunction.apply(key);\n                concurrentHashMap.put(key, value);\n            }\n        }\n    }\n    return value;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": {"response": ["```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    V value = map.get(key);\n    if (value == null) {\n        value = mappingFunction.apply(key);\n        map.put(key, value);\n    }\n    return value;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": {"response": ["```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    // \u83b7\u53d6\u5b9e\u4f53\u7c7b\u5bf9\u5e94\u7684 BaseMapper \u63a5\u53e3\u5b9e\u73b0\u7c7b\n    Class<?> mapperClass = ENTITY_MAPPER_MAP.get(entityClass);\n    if (mapperClass == null) {\n        throw new IllegalArgumentException(\"No BaseMapper found for entity class: \" + entityClass.getName());\n    }\n\n    // \u4ece\u7f13\u5b58\u4e2d\u83b7\u53d6 BaseMapper \u5bf9\u8c61\n    @SuppressWarnings(\"unchecked\")\n    BaseMapper<E> mapper = (BaseMapper<E>) MAPPER_OBJECTS.get(mapperClass);\n    if (mapper != null) {\n        return mapper;\n    }\n\n    // \u521b\u5efa BaseMapper \u4ee3\u7406\u5bf9\u8c61\n    MapperHandler mapperHandler = new MapperHandler(mapperClass);\n    mapper = (BaseMapper<E>) Proxy.newProxyInstance(\n            mapperClass.getClassLoader(),\n            new Class<?>[]{mapperClass},\n            mapperHandler\n    );\n\n    // \u5c06\u521b\u5efa\u7684 BaseMapper \u5bf9\u8c61\u653e\u5165\u7f13\u5b58\n    MAPPER_OBJECTS.put(mapperClass, mapper);\n\n    return mapper;\n}\n```"]}, "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": {"response": ["```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return (M) MAPPER_OBJECTS.computeIfAbsent(mapperClass, clazz -> {\n        MapperHandler mapperHandler = new MapperHandler(clazz);\n        return Proxy.newProxyInstance(\n            clazz.getClassLoader(),\n            new Class<?>[]{clazz},\n            mapperHandler\n        );\n    });\n}\n```"]}, "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": {"response": ["```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    return Flux.defer(() -> {\n        OpenAiAudioApi.SpeechRequest speechRequest = createRequest(speechPrompt);\n\n        Flux<byte[]> speechStream = this.audioApi.createSpeechStream(speechRequest);\n\n        return speechStream.map(audioChunk -> {\n            RateLimit rateLimits = OpenAiResponseHeaderExtractor.extractAiResponseHeaders(null); // Assuming headers extraction logic is needed\n            return new SpeechResponse(new Speech(audioChunk), new OpenAiAudioSpeechResponseMetadata(rateLimits));\n        });\n    });\n}\n```"]}, "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": {"response": ["```java\n/**\n * Merge the default and request options.\n * @param requestOptions request options to merge.\n * @return the merged options.\n */\npublic PostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    PostgresMlEmbeddingOptions mergedOptions = new PostgresMlEmbeddingOptions();\n\n    if (requestOptions instanceof PostgresMlEmbeddingOptions) {\n        PostgresMlEmbeddingOptions requestPostgresOptions = (PostgresMlEmbeddingOptions) requestOptions;\n\n        // Merge transformer\n        if (StringUtils.hasText(requestPostgresOptions.getTransformer())) {\n            mergedOptions.setTransformer(requestPostgresOptions.getTransformer());\n        } else {\n            mergedOptions.setTransformer(this.defaultOptions.getTransformer());\n        }\n\n        // Merge vectorType\n        if (requestPostgresOptions.getVectorType() != null) {\n            mergedOptions.setVectorType(requestPostgresOptions.getVectorType());\n        } else {\n            mergedOptions.setVectorType(this.defaultOptions.getVectorType());\n        }\n\n        // Merge kwargs\n        if (!CollectionUtils.isEmpty(requestPostgresOptions.getKwargs())) {\n            mergedOptions.setKwargs(requestPostgresOptions.getKwargs());\n        } else {\n            mergedOptions.setKwargs(this.defaultOptions.getKwargs());\n        }\n\n        // Merge metadataMode\n        if (requestPostgresOptions.getMetadataMode() != null) {\n            mergedOptions.setMetadataMode(requestPostgresOptions.getMetadataMode());\n        } else {\n            mergedOptions.setMetadataMode(this.defaultOptions.getMetadataMode());\n        }\n    } else {\n        // If requestOptions is not an instance of PostgresMlEmbeddingOptions, use default options\n        mergedOptions.setTransformer(this.defaultOptions.getTransformer());\n        mergedOptions.setVectorType(this.defaultOptions.getVectorType());\n        mergedOptions.setKwargs(this.defaultOptions.getKwargs());\n        mergedOptions.setMetadataMode(this.defaultOptions.getMetadataMode());\n    }\n\n    return mergedOptions;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": {"response": ["```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    // Check if the dimensions for the modelName are known\n    if (KNOWN_EMBEDDING_DIMENSIONS.containsKey(modelName)) {\n        return KNOWN_EMBEDDING_DIMENSIONS.get(modelName);\n    }\n\n    // If the modelName is unknown, perform a dummy embedding to determine the dimensions\n    float[] dummyEmbedding = embeddingModel.embed(dummyContent);\n    int dimensions = dummyEmbedding.length;\n\n    // Cache the dimensions for future use\n    KNOWN_EMBEDDING_DIMENSIONS.put(modelName, dimensions);\n\n    return dimensions;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": {"response": ["```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"Prompt index must not be less than 0\");\n    }\n\n    return StreamSupport.stream(this.spliterator(), false)\n            .filter(metadata -> metadata.getPromptIndex() == promptIndex)\n            .findFirst();\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": {"response": ["```java\ndefault Long getTotalTokens() {\n\treturn getPromptTokens() + getGenerationTokens();\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": {"response": ["```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Expression exp) {\n        if (exp.type() == ExpressionType.NOT) {\n            // NOT(NOT(a)) = a\n            return exp.left();\n        } else {\n            // Apply negation rules based on the expression type\n            ExpressionType negatedType = TYPE_NEGATION_MAP.get(exp.type());\n            if (negatedType == null) {\n                throw new IllegalArgumentException(\"Unsupported expression type for negation: \" + exp.type());\n            }\n\n            if (negatedType == ExpressionType.AND || negatedType == ExpressionType.OR) {\n                // NOT(a AND b) = NOT(a) OR NOT(b)\n                // NOT(a OR b) = NOT(a) AND NOT(b)\n                return new Filter.Expression(negatedType, negate(exp.left()), negate(exp.right()));\n            } else {\n                // NOT(a EQ b) = a NE b\n                // NOT(a NE b) = a EQ b\n                // NOT(a GT b) = a LTE b\n                // NOT(a GTE b) = a LT b\n                // NOT(a LT b) = a GTE b\n                // NOT(a LTE b) = a GT b\n                // NOT(a IN [...]) = a NIN [...]\n                // NOT(a NIN [...]) = a IN [...]\n                return new Filter.Expression(negatedType, exp.left(), exp.right());\n            }\n        }\n    } else if (operand instanceof Filter.Group group) {\n        // Negate the content of the group\n        return new Filter.Group((Filter.Expression) negate(group.content()));\n    } else {\n        throw new IllegalArgumentException(\"Unsupported operand type for negation: \" + operand.getClass());\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": {"response": ["```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    // Convert source and target objects to maps\n    Map<String, Object> sourceMap = ModelOptionsUtils.jsonToMap(ModelOptionsUtils.toJsonString(source));\n    Map<String, Object> targetMap = ModelOptionsUtils.jsonToMap(ModelOptionsUtils.toJsonString(target));\n\n    // Determine the field names to use for merging\n    List<String> fieldNamesToMerge;\n    if (CollectionUtils.isEmpty(acceptedFieldNames)) {\n        fieldNamesToMerge = ModelOptionsUtils.getJsonPropertyValues(clazz);\n    } else {\n        fieldNamesToMerge = acceptedFieldNames;\n    }\n\n    // Merge the source map into the target map based on the field names\n    for (String fieldName : fieldNamesToMerge) {\n        if (sourceMap.containsKey(fieldName) && sourceMap.get(fieldName) != null) {\n            targetMap.put(fieldName, sourceMap.get(fieldName));\n        }\n    }\n\n    // Convert the merged map back to the target class\n    return ModelOptionsUtils.mapToClass(targetMap, clazz);\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": {"response": ["```java\npublic static Map<String, Object> objectToMap(Object source) {\n    try {\n        return OBJECT_MAPPER.convertValue(source, Map.class);\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to convert object to map\", e);\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": {"response": ["```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    try {\n        T targetBean = targetBeanClazz.getDeclaredConstructor().newInstance();\n        BeanWrapper sourceWrapper = new BeanWrapperImpl(sourceBean);\n        BeanWrapper targetWrapper = new BeanWrapperImpl(targetBean);\n\n        for (PropertyDescriptor propertyDescriptor : sourceWrapper.getPropertyDescriptors()) {\n            String propertyName = propertyDescriptor.getName();\n            if (sourceInterfaceClazz.getMethod(toGetName(propertyName)) != null) {\n                Object propertyValue = sourceWrapper.getPropertyValue(propertyName);\n                if (propertyValue != null) {\n                    targetWrapper.setPropertyValue(propertyName, propertyValue);\n                }\n            }\n        }\n\n        return targetBean;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to copy bean values from source to target\", e);\n    }\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": {"response": ["```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    BeanWrapper sourceWrapper = new BeanWrapperImpl(source);\n    BeanWrapper targetWrapper = new BeanWrapperImpl(target);\n\n    PropertyDescriptor[] propertyDescriptors = sourceWrapper.getPropertyDescriptors();\n    for (PropertyDescriptor propertyDescriptor : propertyDescriptors) {\n        String propertyName = propertyDescriptor.getName();\n        if (propertyName.equals(\"class\")) {\n            continue; // Skip the class property\n        }\n\n        // Check if the property is part of the source interface\n        try {\n            sourceInterfaceClazz.getMethod(\"get\" + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1));\n        } catch (NoSuchMethodException e) {\n            continue; // Skip properties not part of the source interface\n        }\n\n        Object sourceValue = sourceWrapper.getPropertyValue(propertyName);\n        if (sourceValue != null || overrideNonNullTargetValues) {\n            targetWrapper.setPropertyValue(propertyName, sourceValue);\n        }\n    }\n\n    return target;\n}\n```"]}, "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": {"response": ["```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    var classPathScanningCandidateComponentProvider = new ClassPathScanningCandidateComponentProvider(false);\n    classPathScanningCandidateComponentProvider.addIncludeFilter(new AnnotationTypeFilter(JsonInclude.class));\n    classPathScanningCandidateComponentProvider.addIncludeFilter(new AnnotationTypeFilter(JsonProperty.class));\n\n    return classPathScanningCandidateComponentProvider//\n        .findCandidateComponents(packageName)//\n        .stream()//\n        .map(bd -> TypeReference.of(Objects.requireNonNull(bd.getBeanClassName())))//\n        .peek(tr -> {\n            if (log.isDebugEnabled())\n                log.debug(\"registering [\" + tr.getName() + ']');\n        })\n        .collect(Collectors.toUnmodifiableSet());\n}\n```"]}, "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": {"response": ["```java\n@Override\npublic List<Document> get() {\n    List<Document> readDocuments = new ArrayList<>();\n    try {\n        List<Paragraph> paragraphs = this.paragraphTextExtractor.getParagraphs();\n        if (CollectionUtils.isEmpty(paragraphs)) {\n            return readDocuments;\n        }\n\n        for (int i = 0; i < paragraphs.size() - 1; i++) {\n            Paragraph from = paragraphs.get(i);\n            Paragraph to = paragraphs.get(i + 1);\n            Document document = toDocument(from, to);\n            if (document != null) {\n                readDocuments.add(document);\n            }\n        }\n\n        // Handle the last paragraph\n        Paragraph lastParagraph = paragraphs.get(paragraphs.size() - 1);\n        Document lastDocument = toDocument(lastParagraph, lastParagraph);\n        if (lastDocument != null) {\n            readDocuments.add(lastDocument);\n        }\n\n        return readDocuments;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": {"response": ["```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    if (bits.length() >= numBits + 1) {\n        return bits;\n    } else {\n        int numWords = FixedBitSet.bits2words(numBits + 1);\n        long[] arr = bits.getBits();\n        if (numWords >= arr.length) {\n            arr = ArrayUtil.growExact(arr, numWords);\n        }\n        return new FixedBitSet(arr, numBits + 1);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": {"response": ["```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    for (int i = 0; i < objects.length(); i++) {\n        T value = objects.get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": {"response": ["```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"The LongHeap is empty.\");\n    }\n    long result = heap[1]; // retrieve the top element\n    heap[1] = heap[size]; // move the last element to the top\n    heap[size] = 0; // clear the last element\n    size--;\n    downHeap(1); // adjust the heap to maintain the heap property\n    return result;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": {"response": ["```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size == 0) {\n        // If the heap is empty, simply add the new value\n        add(value);\n        return value;\n    }\n    // Replace the top element with the new value\n    heap[1] = value;\n    // Restore the heap invariant by moving the new top element down if necessary\n    downHeap(1);\n    // Return the new top element\n    return heap[1];\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": {"response": ["```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public float similarityTo(int node2) {\n            long[] encoded1 = encode(q);\n            long[] encoded2 = get(node2);\n            return similarityBetween(encoded1, encoded2);\n        }\n    };\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": {"response": ["```java\npublic static ProductQuantization compute(\n        RandomAccessVectorValues ravv, \n        int M, \n        int clusterCount, \n        boolean globallyCenter, \n        float anisotropicThreshold, \n        ForkJoinPool simdExecutor, \n        ForkJoinPool parallelExecutor) {\n    \n    // Extract training vectors from the input data\n    List<VectorFloat<?>> trainingVectors = extractTrainingVectors(ravv, parallelExecutor);\n\n    // Determine the subvector sizes and offsets\n    int[][] subvectorSizesAndOffsets = getSubvectorSizesAndOffsets(ravv.dimension(), M);\n\n    // Create the codebooks by clustering the training vectors\n    VectorFloat<?>[] codebooks = createCodebooks(trainingVectors, subvectorSizesAndOffsets, clusterCount, anisotropicThreshold, simdExecutor);\n\n    // Optionally center the vectors globally\n    VectorFloat<?> globalCentroid = null;\n    if (globallyCenter) {\n        globalCentroid = KMeansPlusPlusClusterer.centroidOf(trainingVectors);\n    }\n\n    // Create and return the ProductQuantization object\n    return new ProductQuantization(codebooks, clusterCount, subvectorSizesAndOffsets, globalCentroid, anisotropicThreshold);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": {"response": ["```java\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds) {\n    return refine(ravv, lloydsRounds, UNWEIGHTED, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n}\n\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds, float anisotropicThreshold) {\n    return refine(ravv, lloydsRounds, anisotropicThreshold, PhysicalCoreExecutor.pool(), ForkJoinPool.commonPool());\n}\n\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds, float anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    // Extract training vectors from the new data\n    List<VectorFloat<?>> trainingVectors = extractTrainingVectors(ravv, parallelExecutor);\n\n    // Create new codebooks by clustering the training vectors\n    VectorFloat<?>[] newCodebooks = createCodebooks(trainingVectors, subvectorSizesAndOffsets, clusterCount, anisotropicThreshold, simdExecutor);\n\n    // Create a new ProductQuantization instance with the new codebooks\n    return new ProductQuantization(newCodebooks, clusterCount, subvectorSizesAndOffsets, globalCentroid, anisotropicThreshold);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": {"response": ["```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    // Create a ByteSequence to store the encoded vector\n    var encoded = vectorTypeSupport.createByteSequence(M);\n\n    // Compute the residuals for each subspace and cluster\n    Residual[][] residuals = computeResiduals(vector);\n\n    // Initialize the encoded vector to the centroids with the minimum residual norm\n    ByteSequence<?> initialEncoding = initializeToMinResidualNorms(residuals);\n\n    // Optimize the encoded vector by minimizing the parallel loss\n    float parallelResidualSum = 0;\n    for (int m = 0; m < M; m++) {\n        int oldIdx = Byte.toUnsignedInt(initialEncoding.get(m));\n        parallelResidualSum += residuals[m][oldIdx].parallelResidualComponent;\n    }\n\n    for (int m = 0; m < M; m++) {\n        int oldIdx = Byte.toUnsignedInt(initialEncoding.get(m));\n        CoordinateDescentResult result = optimizeSingleSubspace(residuals[m], oldIdx, parallelResidualSum);\n        encoded.set(m, (byte) result.newCenterIdx);\n        parallelResidualSum = result.newParallelResidualComponent;\n    }\n\n    return encoded;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": {"response": ["```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    var encoded = vectorTypeSupport.createByteSequence(M);\n    for (int m = 0; m < M; m++) {\n        encoded.set(m, (byte) closestCentroidIndex(vector, m, codebooks[m]));\n    }\n    return encoded;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": {"response": ["```java\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Decodes the quantized representation (ByteSequence) to its approximate original vector.\n    for (int m = 0; m < M; m++) {\n        int centroidIndex = Byte.toUnsignedInt(encoded.get(m));\n        int centroidLength = subvectorSizesAndOffsets[m][0];\n        int centroidOffset = subvectorSizesAndOffsets[m][1];\n        target.copyFrom(codebooks[m], centroidIndex * centroidLength, centroidOffset, centroidLength);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": {"response": ["```java\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Ensure the target vector is properly sized\n    if (target.length() != originalDimension) {\n        throw new IllegalArgumentException(\"Target vector length must match the original dimension\");\n    }\n\n    // Initialize the target vector to the global centroid\n    if (globalCentroid != null) {\n        target.copyFrom(globalCentroid, 0, 0, globalCentroid.length());\n    } else {\n        target.zero();\n    }\n\n    // Decode the encoded vector by adding the corresponding codebook centroids\n    for (int m = 0; m < M; m++) {\n        int centroidIndex = Byte.toUnsignedInt(encoded.get(m));\n        int centroidLength = subvectorSizesAndOffsets[m][0];\n        int centroidOffset = subvectorSizesAndOffsets[m][1];\n        target.addInPlace(codebooks[m], centroidIndex * centroidLength, centroidOffset, centroidLength);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": {"response": ["```java\npublic Matrix invert() {\n    if (data.length != data[0].length()) {\n        throw new IllegalArgumentException(\"Matrix must be square to be inverted\");\n    }\n\n    int n = data.length;\n    Matrix augmentedMatrix = new Matrix(n, 2 * n);\n    Matrix inverse = new Matrix(n, n);\n\n    // Create an augmented matrix [A | I]\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            augmentedMatrix.set(i, j, data[i].get(j));\n            if (i == j) {\n                augmentedMatrix.set(i, j + n, 1);\n            } else {\n                augmentedMatrix.set(i, j + n, 0);\n            }\n        }\n    }\n\n    // Perform Gaussian elimination\n    for (int i = 0; i < n; i++) {\n        // Find the pivot row\n        if (augmentedMatrix.get(i, i) == 0) {\n            int pivotRow = -1;\n            for (int k = i + 1; k < n; k++) {\n                if (augmentedMatrix.get(k, i) != 0) {\n                    pivotRow = k;\n                    break;\n                }\n            }\n            if (pivotRow == -1) {\n                throw new ArithmeticException(\"Matrix is singular and cannot be inverted\");\n            }\n            // Swap rows\n            for (int j = 0; j < 2 * n; j++) {\n                float temp = augmentedMatrix.get(i, j);\n                augmentedMatrix.set(i, j, augmentedMatrix.get(pivotRow, j));\n                augmentedMatrix.set(pivotRow, j, temp);\n            }\n        }\n\n        // Normalize the pivot row\n        float pivot = augmentedMatrix.get(i, i);\n        for (int j = 0; j < 2 * n; j++) {\n            augmentedMatrix.set(i, j, augmentedMatrix.get(i, j) / pivot);\n        }\n\n        // Eliminate other rows\n        for (int k = 0; k < n; k++) {\n            if (k != i) {\n                float factor = augmentedMatrix.get(k, i);\n                for (int j = 0; j < 2 * n; j++) {\n                    augmentedMatrix.set(k, j, augmentedMatrix.get(k, j) - factor * augmentedMatrix.get(i, j));\n                }\n            }\n        }\n    }\n\n    // Extract the inverse matrix from the augmented matrix\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            inverse.set(i, j, augmentedMatrix.get(i, j + n));\n        }\n    }\n\n    return inverse;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": {"response": ["```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n        throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n    float r = impl.cosine(a, b);\n    assert Float.isFinite(r) : String.format(\"cosine(%s, %s) = %s\", a, b, r);\n    return r;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": {"response": ["```java\n/**\n * Convenience function for simple one-off searches.  It is caller's responsibility to make sure that it\n * is the unique owner of the vectors instance passed in here.\n */\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    try (var searcher = new GraphSearcher(graph)) {\n        var scoreProvider = new SearchScoreProvider() {\n            @Override\n            public ScoreFunction.ExactScoreFunction rerankerFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n                return new ScoreFunction.ExactScoreFunction() {\n                    @Override\n                    public float similarityTo(int node) {\n                        return vsf.compare(queryVector, vectors.getVector(node));\n                    }\n                };\n            }\n\n            @Override\n            public ScoreFunction.ApproximateScoreFunction approximateScoreFunctionFor(VectorFloat<?> queryVector, VectorSimilarityFunction vsf) {\n                return new ScoreFunction.ApproximateScoreFunction() {\n                    @Override\n                    public float similarityTo(int node) {\n                        return vsf.compare(queryVector, vectors.getVector(node));\n                    }\n                };\n            }\n        };\n\n        return searcher.search(scoreProvider, topK, acceptOrds);\n    } catch (IOException e) {\n        throw new RuntimeException(\"Failed to close searcher\", e);\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": {"response": ["```java\npublic int[] nodesCopy() {\n    int[] copy = new int[size];\n    System.arraycopy(nodes, 0, copy, 0, size);\n    return copy;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": {"response": ["```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    float worstApproximateScoreInTopK = Float.POSITIVE_INFINITY;\n    for (int i = 0; i < size(); i++) {\n        long heapValue = heap.get(i + 1);\n        int node = decodeNodeId(heapValue);\n        float approximateScore = decodeScore(heapValue);\n\n        if (approximateScore >= rerankFloor) {\n            float exactScore = reranker.similarityTo(node);\n            if (exactScore < worstApproximateScoreInTopK) {\n                worstApproximateScoreInTopK = exactScore;\n            }\n            reranked.push(node, exactScore);\n        } else {\n            unused.add(node, approximateScore);\n        }\n    }\n\n    // Ensure reranked queue only contains the topK results\n    while (reranked.size() > topK) {\n        int evictedNode = reranked.pop();\n        float evictedScore = reranked.topScore();\n        unused.add(evictedNode, evictedScore);\n    }\n\n    return worstApproximateScoreInTopK;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": {"response": ["```java\n/**\n * Always creates a new NodeArray to return, even when a1 or a2 is empty.\n *\n * @param a1 the first NodeArray to merge\n * @param a2 the second NodeArray to merge\n * @return a new NodeArray containing the merged elements from a1 and a2\n */\npublic static NodeArray merge(NodeArray a1, NodeArray a2) {\n    // Create a new NodeArray with enough capacity to hold the merged elements\n    NodeArray merged = new NodeArray(a1.size() + a2.size());\n\n    // Merge elements from a1\n    for (int i = 0; i < a1.size(); i++) {\n        merged.addInOrder(a1.getNode(i), a1.getScore(i));\n    }\n\n    // Merge elements from a2\n    for (int i = 0; i < a2.size(); i++) {\n        merged.addInOrder(a2.getNode(i), a2.getScore(i));\n    }\n\n    return merged;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": {"response": ["```java\npublic void addInOrder(int newNode, float newScore) {\n    // Ensure the new node is worse than all previously stored nodes\n    if (size > 0 && newScore > scores[size - 1]) {\n        throw new IllegalArgumentException(\"New node must be worse than all previously stored nodes\");\n    }\n\n    // Grow the arrays if necessary\n    if (size == nodes.length) {\n        growArrays();\n    }\n\n    // Add the new node and score to the end of the arrays\n    nodes[size] = newNode;\n    scores[size] = newScore;\n    size++;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": {"response": ["```java\npublic int insertSorted(int newNode, float newScore) {\n    // Find the insertion point using binary search\n    int insertionPoint = descSortFindRightMostInsertionPoint(newScore);\n\n    // Check if the new node already exists near the insertion point\n    if (duplicateExistsNear(insertionPoint, newNode, newScore)) {\n        return -1; // Node already exists\n    }\n\n    // Ensure there is enough space in the arrays\n    if (size == nodes.length) {\n        growArrays();\n    }\n\n    // Shift elements to the right to make space for the new node\n    System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n    System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n\n    // Insert the new node and score\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    size++;\n\n    return insertionPoint;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": {"response": ["```java\npublic void retain(Bits selected) {\n    int writeIndex = 0;\n    for (int readIndex = 0; readIndex < size; readIndex++) {\n        if (selected.get(readIndex)) {\n            if (readIndex != writeIndex) {\n                nodes[writeIndex] = nodes[readIndex];\n                scores[writeIndex] = scores[readIndex];\n            }\n            writeIndex++;\n        }\n    }\n    size = writeIndex;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": {"response": ["```java\npublic void add(int newNode, float newScore) {\n    // Ensure the new node is worse than all previously stored nodes\n    if (size > 0 && newScore > scores[size - 1]) {\n        throw new IllegalArgumentException(\"New node must be worse than all previously stored nodes\");\n    }\n\n    // Grow the arrays if necessary\n    if (size == nodes.length) {\n        growArrays();\n    }\n\n    // Add the new node and score to the arrays\n    nodes[size] = newNode;\n    scores[size] = newScore;\n    size++;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": {"response": ["```java\n/**\n * Only for internal use and by Builder loading a saved graph\n */\nvoid addNode(int nodeId, NodeArray nodes) {\n    assert nodes != null;\n    this.nodes.addNode(nodeId, nodes);\n    maxNodeId.accumulateAndGet(nodeId, Math::max);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": {"response": ["```java\npublic synchronized long removeDeletedNodes() {\n    long memoryFreed = 0;\n    var deletedNodes = graph.getDeletedNodes();\n    var deletedNodesIterator = deletedNodes.iterator();\n\n    while (deletedNodesIterator.hasNext()) {\n        int nodeToDelete = deletedNodesIterator.nextInt();\n        if (graph.containsNode(nodeToDelete)) {\n            var neighbors = graph.getNeighbors(nodeToDelete);\n            var candidates = new NodeArray(neighbors.size());\n            for (var it = neighbors.iterator(); it.hasNext(); ) {\n                int neighbor = it.nextInt();\n                if (graph.containsNode(neighbor)) {\n                    candidates.addInOrder(neighbor, scoreProvider.searchProviderFor(neighbor).exactScoreFunction().similarityTo(nodeToDelete));\n                }\n            }\n            graph.nodes.replaceDeletedNeighbors(nodeToDelete, deletedNodes, candidates);\n            memoryFreed += graph.ramBytesUsedOneNode();\n            graph.removeNode(nodeToDelete);\n        }\n    }\n\n    reconnectOrphanedNodes();\n    updateEntryPoint();\n    averageShortEdges = graph.getAverageDegree();\n    return memoryFreed;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": {"response": ["```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    long offset = featureOffsetForOrdinal(ordinal);\n    out.seek(offset);\n    out.writeInt(ordinal); // Write the ordinal of the node\n\n    for (Map.Entry<FeatureId, Feature> entry : featureMap.entrySet()) {\n        FeatureId featureId = entry.getKey();\n        Feature feature = entry.getValue();\n        Feature.State state = stateMap.get(featureId);\n        if (state != null) {\n            feature.writeInline(out, state);\n        } else {\n            // If the state is not provided, we write zeros to maintain the correct offset\n            int inlineSize = feature.inlineSize();\n            for (int i = 0; i < inlineSize; i++) {\n                out.writeByte(0);\n            }\n        }\n    }\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": {"response": ["```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Map<Integer, Integer> oldToNew = new HashMap<>();\n    int newOrdinal = 0;\n\n    for (int oldOrdinal = 0; oldOrdinal < graph.size(); oldOrdinal++) {\n        if (graph.getView().liveNodes().get(oldOrdinal)) {\n            oldToNew.put(oldOrdinal, newOrdinal++);\n        }\n    }\n\n    return oldToNew;\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": {"response": ["```java\n/** Convenience function for writing a vanilla DiskANN-style index with no extra Features. */\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    write(graph, vectors, OnDiskGraphIndexWriter.sequentialRenumbering(graph), path);\n}\n```"]}, "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": {"response": ["```java\n/**\n * Returns a BSP that performs exact score comparisons using the given RandomAccessVectorValues and VectorSimilarityFunction.\n */\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public boolean isExact() {\n            return true;\n        }\n\n        @Override\n        public VectorFloat<?> approximateCentroid() {\n            // Calculate the centroid by averaging all vectors in the RandomAccessVectorValues\n            int size = ravv.size();\n            int dimension = ravv.dimension();\n            VectorFloat<?> centroid = vts.createFloatVector(dimension);\n            VectorFloat<?> tempVector = vts.createFloatVector(dimension);\n\n            for (int i = 0; i < size; i++) {\n                VectorFloat<?> vector = ravv.getVector(i);\n                VectorUtil.add(centroid, vector, centroid);\n            }\n\n            VectorUtil.scale(centroid, 1.0f / size, centroid);\n            return centroid;\n        }\n\n        @Override\n        public SearchScoreProvider searchProviderFor(VectorFloat<?> vector) {\n            return new SearchScoreProvider(new ScoreFunction.ExactScoreFunction() {\n                @Override\n                public float similarityTo(int node2) {\n                    return similarityFunction.compare(vector, ravv.getVector(node2));\n                }\n            });\n        }\n\n        @Override\n        public SearchScoreProvider searchProviderFor(int node1) {\n            return searchProviderFor(ravv.getVector(node1));\n        }\n\n        @Override\n        public SearchScoreProvider diversityProviderFor(int node1) {\n            return searchProviderFor(node1);\n        }\n    };\n}\n```"]}, "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": {"response": ["```java\npublic static double[] determineStandardDeviationDoubles(double[] averageScore) {\n    if (averageScore == null || averageScore.length == 0) {\n        return null;\n    }\n\n    int n = averageScore.length;\n    double[] standardDeviationDoubles = new double[n];\n\n    for (int i = 0; i < n; i++) {\n        double sum = 0.0;\n        for (int j = 0; j < n; j++) {\n            sum += Math.pow(averageScore[j] - averageScore[i], 2);\n        }\n        standardDeviationDoubles[i] = Math.sqrt(sum / n);\n    }\n\n    return standardDeviationDoubles;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": {"response": ["```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = new StackMetadata(localVariableHelper);\n    out.stackValueSources.clear();\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": {"response": ["```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableValueSources.size()) {\n        throw new IllegalArgumentException(\"types.length != localVariableValueSources.size()\");\n    }\n    StackMetadata out = copy();\n    for (int i = 0; i < types.length; i++) {\n        out.localVariableValueSources.set(i, types[i]);\n    }\n    return out;\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": {"response": ["```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    String className = functionMetadata.className;\n    PythonCompiledFunction function = functionMetadata.pythonCompiledFunction;\n\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n            \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n            true);\n    methodVisitor.visitLdcInsn(function.co_names.get(nameIndex));\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PythonLikeType.class),\n            \"loadMethod\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(String.class)),\n            false);\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n    Label blockEnd = new Label();\n\n    methodVisitor.visitJumpInsn(Opcodes.IF_ACMPNE, blockEnd);\n\n    // TOS is null; type does not have attribute; do normal attribute lookup\n    // Stack is object, null\n    methodVisitor.visitInsn(Opcodes.POP);\n    ObjectImplementor.getAttribute(functionMetadata, stackMetadata, nameIndex);\n\n    // Stack is method\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n    if (functionMetadata.pythonCompiledFunction.pythonVersion.isBefore(PythonVersion.PYTHON_3_11)) {\n        // Python 3.11+ swap these\n        methodVisitor.visitInsn(Opcodes.SWAP);\n    }\n\n    methodVisitor.visitLabel(blockEnd);\n\n    // Stack is either:\n    // object, method if it was in type\n    // null, method if it was not in type (Or method, null if Python 3.11+)\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Stack is now:\n    // method, object if it was in type\n    // method, null if it was not in type (and prior to Python 3.11+)\n    // null, method if it was not in type (if Python 3.11+)\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": {"response": ["```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argumentCount) {\n    // Stack is method, (obj or null), arg0, ..., arg(argc - 1)\n    CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, argumentCount);\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Stack is method, argList, (obj or null)\n    Label ifNullStart = new Label();\n    Label blockEnd = new Label();\n\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n    methodVisitor.visitJumpInsn(Opcodes.IF_ACMPEQ, ifNullStart);\n\n    // Stack is method, argList, obj\n    StackManipulationImplementor.duplicateToTOS(functionMetadata, stackMetadata, 1);\n    StackManipulationImplementor.swap(methodVisitor);\n\n    // Stack is method, argList, argList, obj\n    methodVisitor.visitInsn(Opcodes.ICONST_0);\n\n    // Stack is method, argList, argList, obj, index\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Stack is method, argList, argList, index, obj\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(List.class),\n            \"add\",\n            Type.getMethodDescriptor(Type.VOID_TYPE, Type.INT_TYPE, Type.getType(Object.class)),\n            true);\n\n    // Stack is method, argList\n    methodVisitor.visitJumpInsn(Opcodes.GOTO, blockEnd);\n\n    methodVisitor.visitLabel(ifNullStart);\n    // Stack is method, argList, null\n    methodVisitor.visitInsn(Opcodes.POP);\n\n    // Stack is method, argList\n    methodVisitor.visitLabel(blockEnd);\n\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n            Type.getMethodDescriptor(Type.getType(Map.class)),\n            false);\n\n    // Stack is method, argList\n    getCallerInstance(functionMetadata, stackMetadata);\n\n    // Stack is callable, argument_list, null\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": {"response": ["```java\npublic static void callFunction(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int argumentCount) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    // Stack is function, arg0, arg1, ..., arg(argc - 1)\n    CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, argumentCount);\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n            Type.getMethodDescriptor(Type.getType(Map.class)),\n            false);\n    getCallerInstance(functionMetadata, stackMetadata);\n\n    // Stack is function, argument_list, null\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": {"response": ["```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n                                            MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n    // stack is callable, arg0, arg1, ..., arg(argc - len(keys)), ..., arg(argc - 1), keys\n    // We know the total number of arguments, but not the number of individual positional/keyword arguments\n    // Since Java Bytecode require consistent stack frames  (i.e. the body of a loop must start with\n    // the same number of elements in the stack), we need to add the tuple/map in the same object\n    // which will delegate it to either the tuple or the map depending on position and the first item size\n    CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, instruction.arg() + 1);\n\n    // stack is callable, tupleMapPair\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"tuple\",\n            Type.getDescriptor(PythonLikeTuple.class));\n\n    // stack is callable, tupleMapPair, positionalArgs\n    methodVisitor.visitInsn(Opcodes.SWAP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"map\",\n            Type.getDescriptor(PythonLikeDict.class));\n\n    getCallerInstance(functionMetadata, stackMetadata);\n\n    // Stack is callable, positionalArgs, keywordArgs\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": {"response": ["```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n                                      MethodVisitor methodVisitor) {\n    // Check if the lowest bit of instruction.arg is set\n    if ((instruction.arg() & 1) == 1) {\n        // TOS is a mapping object containing keyword arguments\n        // TOS[1] is an iterable containing positional arguments\n        // TOS[2] is callable\n        methodVisitor.visitInsn(Opcodes.DUP2_X1); // Duplicate TOS and TOS[1]\n        methodVisitor.visitInsn(Opcodes.POP); // Remove TOS[1]\n        methodVisitor.visitInsn(Opcodes.DUP_X2); // Duplicate TOS[2]\n        methodVisitor.visitInsn(Opcodes.POP); // Remove TOS[2]\n        // Now stack is: TOS[2], TOS, TOS[1]\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n                Type.getMethodDescriptor(Type.getType(Map.class)), false);\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    } else {\n        // TOS is an iterable containing positional arguments\n        // TOS[1] is callable\n        methodVisitor.visitInsn(Opcodes.DUP_X1); // Duplicate TOS\n        methodVisitor.visitInsn(Opcodes.SWAP); // Swap TOS and TOS[1]\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n                Type.getMethodDescriptor(Type.getType(Map.class)), false);\n        methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n        methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n                \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                        Type.getType(List.class),\n                        Type.getType(Map.class),\n                        Type.getType(PythonLikeObject.class)),\n                true);\n    }\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": {"response": ["```java\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    String className = functionMetadata.className;\n    PythonCompiledFunction pythonCompiledFunction = functionMetadata.pythonCompiledFunction;\n\n    String globalName = pythonCompiledFunction.co_names.get(globalIndex);\n\n    methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, className);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, className,\n            PythonBytecodeToJavaBytecodeTranslator.INTERPRETER_INSTANCE_FIELD_NAME,\n            Type.getDescriptor(PythonInterpreter.class));\n    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, className,\n            PythonBytecodeToJavaBytecodeTranslator.GLOBALS_MAP_STATIC_FIELD_NAME,\n            Type.getDescriptor(Map.class));\n    methodVisitor.visitLdcInsn(globalName);\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonInterpreter.class),\n            \"getGlobal\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(Map.class),\n                    Type.getType(String.class)),\n            true);\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": {"response": ["```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    // Load the cell variable from the local variable helper\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n\n    // Check if the cell variable is an instance of PythonCell\n    methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, Type.getInternalName(PythonCell.class));\n\n    // Get the value from the PythonCell\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(PythonCell.class), \"cellValue\", Type.getDescriptor(PythonLikeObject.class));\n}\n```"]}, "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": {"response": ["```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    String className = functionMetadata.className;\n    PythonCompiledFunction pythonCompiledFunction = functionMetadata.pythonCompiledFunction;\n\n    // Duplicate TOS to keep it on the stack after the attribute lookup\n    methodVisitor.visitInsn(Opcodes.DUP);\n\n    // Get the type of TOS\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n            \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)),\n            true);\n\n    // Load the attribute name from co_names\n    methodVisitor.visitLdcInsn(pythonCompiledFunction.co_names.get(nameIndex));\n\n    // Perform the attribute lookup\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n            \"$getAttributeOrError\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(String.class)),\n            true);\n\n    // Swap the result with the original TOS\n    methodVisitor.visitInsn(Opcodes.SWAP);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": {"response": ["```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    ProblemScaleTracker problemScaleTracker = new ProblemScaleTracker(10); // Using base 10 for the log scale\n\n    // Visit all entities to calculate the problem scale\n    visitAllEntities(solution, entity -> {\n        EntityDescriptor<Solution_> entityDescriptor = findEntityDescriptorOrFail(entity.getClass());\n        if (entityDescriptor.isGenuine()) {\n            problemScaleTracker.incrementListEntityCount(entityDescriptor.isMovable(scoreDirector, entity));\n            for (GenuineVariableDescriptor<Solution_> variableDescriptor : entityDescriptor.getGenuineVariableDescriptorList()) {\n                long valueRangeSize = variableDescriptor.getValueRangeDescriptor().extractValueRangeSize(solution, entity);\n                problemScaleTracker.addBasicProblemScale(valueRangeSize);\n            }\n        }\n    });\n\n    // Visit all problem facts to calculate the problem scale\n    visitAllProblemFacts(solution, fact -> {\n        problemScaleTracker.addBasicProblemScale(1); // Each problem fact contributes a scale of 1\n    });\n\n    // Return the calculated problem scale\n    return problemScaleTracker.getBasicProblemScaleLog();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": {"response": ["```java\npublic static void defineClonerFor(ClassCreator classCreator, SolutionDescriptor<?> solutionDescriptor) {\n    // Generate the constructor\n    MethodCreator constructorCreator = classCreator.getMethodCreator(\n            MethodDescriptor.ofConstructor(classCreator.getClassName()));\n    ResultHandle thisObj = constructorCreator.getThis();\n\n    // Invoke Object's constructor\n    constructorCreator.invokeSpecialMethod(MethodDescriptor.ofConstructor(Object.class), thisObj);\n\n    // Return this (it's a constructor)\n    constructorCreator.returnValue(thisObj);\n\n    // Generate the setSolutionDescriptor method\n    MethodCreator setSolutionDescriptorCreator = classCreator.getMethodCreator(\n            MethodDescriptor.ofMethod(GizmoSolutionCloner.class, \"setSolutionDescriptor\", void.class,\n                    SolutionDescriptor.class));\n    setSolutionDescriptorCreator.writeStaticField(FieldDescriptor.of(\n            GizmoSolutionClonerFactory.getGeneratedClassName(solutionDescriptor),\n            FALLBACK_CLONER, FieldAccessingSolutionCloner.class),\n            setSolutionDescriptorCreator.newInstance(\n                    MethodDescriptor.ofConstructor(FieldAccessingSolutionCloner.class, SolutionDescriptor.class),\n                    setSolutionDescriptorCreator.getMethodParam(0)));\n    setSolutionDescriptorCreator.returnValue(null);\n\n    // Generate the cloneSolution method\n    MethodCreator cloneSolutionCreator = classCreator.getMethodCreator(\n            MethodDescriptor.ofMethod(SolutionCloner.class, \"cloneSolution\", Object.class, Object.class));\n    ResultHandle clone = cloneSolutionCreator.invokeStaticMethod(\n            MethodDescriptor.ofMethod(\n                    GizmoSolutionClonerFactory.getGeneratedClassName(solutionDescriptor),\n                    \"cloneSolutionRun\", solutionDescriptor.getSolutionClass(), solutionDescriptor.getSolutionClass(), Map.class),\n            cloneSolutionCreator.getMethodParam(0),\n            cloneSolutionCreator.newInstance(MethodDescriptor.ofConstructor(IdentityHashMap.class)));\n    cloneSolutionCreator.returnValue(clone);\n\n    // Generate the cloneSolutionRun method\n    MethodCreator cloneSolutionRunCreator = classCreator.getMethodCreator(\n            \"cloneSolutionRun\", solutionDescriptor.getSolutionClass(), solutionDescriptor.getSolutionClass(), Map.class);\n    cloneSolutionRunCreator.setModifiers(Modifier.STATIC | Modifier.PRIVATE);\n    ResultHandle thisObjRun = cloneSolutionRunCreator.getMethodParam(0);\n    BranchResult solutionNullBranchResult = cloneSolutionRunCreator.ifNull(thisObjRun);\n    BytecodeCreator solutionIsNullBranch = solutionNullBranchResult.trueBranch();\n    solutionIsNullBranch.returnValue(thisObjRun); // thisObjRun is null\n\n    BytecodeCreator solutionIsNotNullBranch = solutionNullBranchResult.falseBranch();\n    ResultHandle createdCloneMap = cloneSolutionRunCreator.getMethodParam(1);\n    ResultHandle maybeClone = solutionIsNotNullBranch.invokeInterfaceMethod(\n            GET_METHOD, createdCloneMap, thisObjRun);\n    BranchResult hasCloneBranchResult = solutionIsNotNullBranch.ifNotNull(maybeClone);\n    BytecodeCreator hasCloneBranch = hasCloneBranchResult.trueBranch();\n    hasCloneBranch.returnValue(maybeClone);\n\n    BytecodeCreator noCloneBranch = hasCloneBranchResult.falseBranch();\n    ResultHandle cloneObj = noCloneBranch.newInstance(MethodDescriptor.ofConstructor(solutionDescriptor.getSolutionClass()));\n    noCloneBranch.invokeInterfaceMethod(\n            MethodDescriptor.ofMethod(Map.class, \"put\", Object.class, Object.class, Object.class),\n            createdCloneMap, thisObjRun, cloneObj);\n\n    // Implement the deep cloning logic for each field\n    for (Field field : solutionDescriptor.getSolutionClass().getDeclaredFields()) {\n        if (!Modifier.isStatic(field.getModifiers())) {\n            ResultHandle fieldValue = noCloneBranch.readInstanceField(FieldDescriptor.of(field), thisObjRun);\n            AssignableResultHandle cloneValue = noCloneBranch.createVariable(field.getType());\n            writeDeepCloneInstructions(noCloneBranch, solutionDescriptor, field, fieldValue, cloneValue, createdCloneMap);\n            noCloneBranch.writeInstanceField(FieldDescriptor.of(field), cloneObj, cloneValue);\n        }\n    }\n\n    noCloneBranch.returnValue(cloneObj);\n}\n\nprivate static void writeDeepCloneInstructions(BytecodeCreator bytecodeCreator, SolutionDescriptor<?> solutionDescriptor,\n        Field field, ResultHandle fieldValue, AssignableResultHandle cloneValue, ResultHandle createdCloneMap) {\n    BranchResult isNull = bytecodeCreator.ifNull(fieldValue"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": {"response": ["```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    Map<ShadowVariableDescriptor<?>, List<String>> violationListMap = collectViolations();\n    if (violationListMap.isEmpty()) {\n        return null;\n    }\n    return format(violationListMap, violationDisplayLimit);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": {"response": ["```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n                                                  Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    String generatedClassName = GizmoMemberAccessorFactory.getGeneratedClassName(member);\n    return memberAccessorCache.computeIfAbsent(generatedClassName,\n            k -> MemberAccessorFactory.buildMemberAccessor(member, memberAccessorType, annotationClass, domainAccessType, gizmoClassLoader));\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": {"response": ["```java\npublic static String getGeneratedClassName(Member member) {\n    String memberName = member.getName();\n    String declaringClassName = member.getDeclaringClass().getName().replace('.', '/');\n    return \"ai/timefold/solver/core/impl/domain/common/accessor/gizmo/\" + declaringClassName + \"_\" + memberName + \"_MemberAccessor\";\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": {"response": ["```java\npackage ai.timefold.solver.core.impl.domain.common.accessor.gizmo;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Member;\n\nimport ai.timefold.solver.core.impl.domain.common.accessor.MemberAccessor;\n\npublic final class GizmoMemberAccessorImplementor {\n\n    /**\n     * Creates a MemberAccessor for a given member, generating\n     * the MemberAccessor bytecode if required\n     *\n     * @param member The member to generate a MemberAccessor for\n     * @param annotationClass The annotation it was annotated with (used for\n     *        error reporting)\n     * @param returnTypeRequired A flag that indicates if the return type is required or optional\n     * @param gizmoClassLoader never null\n     * @return A new MemberAccessor that uses Gizmo generated bytecode.\n     *         Will generate the bytecode the first type it is called\n     *         for a member, unless a classloader has been set,\n     *         in which case no Gizmo code will be generated.\n     */\n    public static MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass,\n            boolean returnTypeRequired, GizmoClassLoader gizmoClassLoader) {\n        // Generate the class name for the MemberAccessor\n        String className = generateClassName(member);\n\n        // Check if the class already exists in the GizmoClassLoader\n        if (!gizmoClassLoader.hasBytecodeFor(className)) {\n            // Create the GizmoMemberDescriptor for the member\n            GizmoMemberDescriptor descriptor = new GizmoMemberDescriptor(member);\n\n            // Create the GizmoMemberInfo for the descriptor\n            GizmoMemberInfo memberInfo = new GizmoMemberInfo(descriptor, returnTypeRequired, annotationClass);\n\n            // Define the accessor for the member\n            defineAccessorFor(className, gizmoClassLoader, memberInfo);\n        }\n\n        // Create an instance of the generated MemberAccessor\n        return createInstance(className, gizmoClassLoader);\n    }\n\n    private static String generateClassName(Member member) {\n        // Generate a unique class name based on the member's declaring class and member name\n        return member.getDeclaringClass().getName() + \"_\" + member.getName() + \"_MemberAccessor\";\n    }\n\n    private static void defineAccessorFor(String className, GizmoClassLoader gizmoClassLoader, GizmoMemberInfo memberInfo) {\n        // Define the accessor for the member and store the bytecode in the GizmoClassLoader\n        ClassOutput classOutput = new ClassOutput() {\n            @Override\n            public void write(String name, byte[] data) {\n                gizmoClassLoader.storeBytecode(name, data);\n            }\n        };\n        GizmoMemberAccessorImplementor.defineAccessorFor(className, classOutput, memberInfo);\n    }\n\n    private static MemberAccessor createInstance(String className, GizmoClassLoader gizmoClassLoader) {\n        try {\n            return (MemberAccessor) gizmoClassLoader.loadClass(className)\n                    .getConstructor().newInstance();\n        } catch (Exception e) {\n            throw new IllegalStateException(\"Failed to create instance of MemberAccessor for class: \" + className, e);\n        }\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": {"response": ["```java\nvoid set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    problemChangesLock.lock();\n    try {\n        if (isEveryProblemChangeProcessed.getAsBoolean()) {\n            currentVersion = currentVersion.add(BigInteger.ONE);\n            versionedBestSolutionRef.set(new VersionedBestSolution<>(bestSolution, currentVersion));\n        } else {\n            // If not all problem changes have been processed, we don't update the best solution.\n            // This ensures that the best solution always contains all processed problem changes.\n            return;\n        }\n    } finally {\n        problemChangesLock.unlock();\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": {"response": ["```java\nimport java.math.BigInteger;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\nfinal class BestSolutionHolder<Solution_> {\n\n    private final Lock problemChangesLock = new ReentrantLock();\n    private BigInteger currentVersion = BigInteger.ZERO;\n\n    /**\n     * Adds a new problem change to a solver and registers the problem change to be later retrieved together with\n     * a relevant best solution by the {@link #take()} method.\n     *\n     * @return CompletableFuture that will be completed after the best solution containing this change is passed to\n     *         a user-defined Consumer.\n     */\n    public CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n        CompletableFuture<Void> problemChangeFuture = new CompletableFuture<>();\n        problemChangesLock.lock();\n        try {\n            BigInteger newVersion = currentVersion.add(BigInteger.ONE);\n            currentVersion = newVersion;\n            problemChangesPerVersion.computeIfAbsent(newVersion, k -> new ArrayList<>()).add(problemChangeFuture);\n            solver.addProblemChange(problemChange);\n        } finally {\n            problemChangesLock.unlock();\n        }\n        return problemChangeFuture;\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": {"response": ["```java\npublic static long nextLong(Random random, long n) {\n    // Mimics Random#nextInt(int) for longs\n    if (n <= 0L) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n\n    long bits, val;\n    do {\n        bits = random.nextLong() & Long.MAX_VALUE; // Mask to ensure non-negative value\n        val = bits % n;\n    } while (bits - val + (n - 1) < 0); // Ensure uniform distribution\n\n    return val;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": {"response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    boolean hasSupportedTimeGradient = false;\n\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n            hasSupportedTimeGradient = true;\n        }\n    }\n\n    return hasSupportedTimeGradient ? minTimeGradient : -1.0;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": {"response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    boolean hasSupportedTimeGradient = false;\n\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n            hasSupportedTimeGradient = true;\n        }\n    }\n\n    return hasSupportedTimeGradient ? minTimeGradient : -1.0;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": {"response": ["```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": {"response": ["```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": {"response": ["```java\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    int[] removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    int[] indexToCycleIdentifier = new int[removedEdgeIndexToTourOrder.length];\n    int cycleCount = 0;\n    boolean[] visited = new boolean[removedEdgeIndexToTourOrder.length];\n\n    for (int i = 1; i < removedEdgeIndexToTourOrder.length; i++) {\n        if (!visited[i]) {\n            cycleCount++;\n            int currentIndex = i;\n            do {\n                visited[currentIndex] = true;\n                indexToCycleIdentifier[currentIndex] = cycleCount;\n                currentIndex = removedEdgeIndexToTourOrder[currentIndex];\n            } while (currentIndex != i);\n        }\n    }\n\n    return new KOptCycle(cycleCount, indexToCycleIdentifier);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": {"response": ["```java\npackage ai.timefold.solver.core.impl.heuristic.selector.list;\n\nimport java.util.Random;\n\nfinal class TriangleElementFactory {\n\n    private final int minimumSubListSize;\n    private final int maximumSubListSize;\n    private final Random workingRandom;\n\n    TriangleElementFactory(int minimumSubListSize, int maximumSubListSize, Random workingRandom) {\n        if (minimumSubListSize > maximumSubListSize) {\n            throw new IllegalArgumentException(\"The minimumSubListSize (\" + minimumSubListSize\n                    + \") must be less than or equal to the maximumSubListSize (\" + maximumSubListSize + \").\");\n        }\n        if (minimumSubListSize < 1) {\n            throw new IllegalArgumentException(\n                    \"The minimumSubListSize (\" + minimumSubListSize + \") must be greater than 0.\");\n        }\n        this.minimumSubListSize = minimumSubListSize;\n        this.maximumSubListSize = maximumSubListSize;\n        this.workingRandom = workingRandom;\n    }\n\n    /**\n     * Produce next random element of Triangle(listSize) observing the given minimum and maximum subList size.\n     *\n     * @param listSize determines the Triangle to select an element from\n     * @return next random triangle element\n     * @throws IllegalArgumentException if {@code listSize} is less than {@code minimumSubListSize}\n     */\n    TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n        if (listSize < minimumSubListSize) {\n            throw new IllegalArgumentException(\"The listSize (\" + listSize + \") must be at least the minimumSubListSize (\"\n                    + minimumSubListSize + \").\");\n        }\n\n        int effectiveListSize = Math.min(listSize, maximumSubListSize);\n        int triangleSize = TriangularNumbers.nthTriangle(effectiveListSize - minimumSubListSize + 1);\n        int randomIndex = workingRandom.nextInt(triangleSize);\n\n        return TriangleElement.valueOf(randomIndex);\n    }\n\n    record TriangleElement(int index, int level, int indexOnLevel) {\n\n        static TriangleElement valueOf(int index) {\n            int level = (int) Math.ceil(TriangularNumbers.triangularRoot(index));\n            return new TriangleElement(index, level, index - TriangularNumbers.nthTriangle(level - 1));\n        }\n\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": {"response": ["```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    if (justification instanceof DefaultConstraintJustification) {\n        return ((DefaultConstraintJustification) justification).getFacts();\n    } else {\n        throw new UnsupportedOperationException(\"Custom justification mapping was provided. \" +\n                \"Please use getJustification() or getIndictedObjectList() instead.\");\n    }\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": {"response": ["```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n        UniConstraintCollector<A, ?, Result_> compose(\n                UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n                UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n                BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    return InnerUniConstraintCollectors.compose(subCollector1, subCollector2, composeFunction);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": {"response": ["```java\npublic static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>>\n        UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>>\n        toConnectedRanges(Function<A, PointType_> startInclusiveMap, Function<A, PointType_> endExclusiveMap,\n                          BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n    return InnerUniConstraintCollectors.toConnectedRanges(startInclusiveMap, endExclusiveMap, differenceFunction);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": {"response": ["```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    Objects.requireNonNull(other, \"other\");\n\n    // Compute the score difference\n    Score_ scoreDifference = this.score().subtract(other.score());\n\n    // Compute the constraint map difference\n    Map<ConstraintRef, ConstraintAnalysis<Score_>> constraintMapDifference = new HashMap<>();\n\n    // Iterate over all constraints in this ScoreAnalysis\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> entry : this.constraintMap().entrySet()) {\n        ConstraintRef constraintRef = entry.getKey();\n        ConstraintAnalysis<Score_> thisConstraintAnalysis = entry.getValue();\n        ConstraintAnalysis<Score_> otherConstraintAnalysis = other.constraintMap().get(constraintRef);\n\n        // Compute the difference for each constraint\n        ConstraintAnalysis<Score_> diffConstraintAnalysis = ConstraintAnalysis.diff(constraintRef, thisConstraintAnalysis, otherConstraintAnalysis);\n        if (diffConstraintAnalysis != null) {\n            constraintMapDifference.put(constraintRef, diffConstraintAnalysis);\n        }\n    }\n\n    // Handle constraints present in other but not in this\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> entry : other.constraintMap().entrySet()) {\n        ConstraintRef constraintRef = entry.getKey();\n        if (!this.constraintMap().containsKey(constraintRef)) {\n            ConstraintAnalysis<Score_> otherConstraintAnalysis = entry.getValue();\n            constraintMapDifference.put(constraintRef, otherConstraintAnalysis.negate());\n        }\n    }\n\n    // Create and return the new ScoreAnalysis with the differences\n    return new ScoreAnalysis<>(scoreDifference, constraintMapDifference);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": {"response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n    summary.append(\"Score Analysis Summary:\\n\");\n    summary.append(\"Score: \").append(score).append(\"\\n\");\n    summary.append(\"Constraints:\\n\");\n\n    for (ConstraintAnalysis<Score_> constraintAnalysis : constraintMap.values()) {\n        summary.append(\"  - Constraint: \").append(constraintAnalysis.constraintName()).append(\"\\n\");\n        summary.append(\"    Weight: \").append(constraintAnalysis.weight()).append(\"\\n\");\n        summary.append(\"    Score: \").append(constraintAnalysis.score()).append(\"\\n\");\n        if (constraintAnalysis.matches() != null) {\n            summary.append(\"    Matches: \").append(constraintAnalysis.matchCount()).append(\"\\n\");\n        } else {\n            summary.append(\"    Matches: Not available\\n\");\n        }\n    }\n\n    return summary.toString();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": {"response": ["```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n    summary.append(\"Constraint Analysis Summary:\\n\");\n    summary.append(\"Constraint: \").append(constraintRef).append(\"\\n\");\n    summary.append(\"Weight: \").append(weight).append(\"\\n\");\n    summary.append(\"Score: \").append(score).append(\"\\n\");\n    if (matches != null) {\n        summary.append(\"Matches: \").append(matches.size()).append(\"\\n\");\n        for (MatchAnalysis<Score_> match : matches) {\n            summary.append(\"  - Match: \").append(match.score()).append(\" (\").append(match.justification()).append(\")\\n\");\n        }\n    } else {\n        summary.append(\"Matches: Not available\\n\");\n    }\n    return summary.toString();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": {"response": ["```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    // Temporarily set the locale for the DecimalFormat instance\n    DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);\n    decimalFormat.setDecimalFormatSymbols(symbols);\n\n    // Format the number using the DecimalFormat instance with the overridden locale\n    return decimalFormat.format(number);\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": {"response": ["```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n        Function<? super ProblemId_, ? extends Solution_> problemFinder,\n        Consumer<? super Solution_> bestSolutionConsumer) {\n    return solveBuilder()\n            .withProblemId(problemId)\n            .withProblemFinder(problemFinder)\n            .withBestSolutionConsumer(bestSolutionConsumer)\n            .run();\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": {"response": ["```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (terminationConfig == null) {\n        terminationConfig = new TerminationConfig();\n    }\n    terminationConfig.withSpentLimit(spentLimit);\n    return this;\n}\n```"]}, "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": {"response": ["```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b == null) {\n        return a;\n    } else if (a == null && b != null) {\n        return b;\n    } else {\n        return mergeProperty(a, b);\n    }\n}\n```"]}}