{"litestar-litestar/file_system.py-info": {"response": ["```python\nasync def info(self, path: PathType, **kwargs: Any) -> FileInfo:\n    \"\"\"Retrieve information about a given file path.\n\n    Args:\n        path: A file path.\n        **kwargs: Any additional kwargs.\n\n    Returns:\n        A dictionary of file info.\n    \"\"\"\n    try:\n        awaitable = (\n            self.file_system.info(str(path))\n            if is_async_callable(self.file_system.info)\n            else sync_to_thread(self.file_system.info, str(path))\n        )\n        return cast(\"FileInfo\", await awaitable)\n    except FileNotFoundError as e:\n        raise e\n    except PermissionError as e:\n        raise NotAuthorizedException(f\"failed to read {path} due to missing permissions\") from e\n    except OSError as e:  # pragma: no cover\n        raise InternalServerException from e\n```"]}, "litestar-litestar/typing.py-has_inner_subclass_of": {"response": ["```python\ndef has_inner_subclass_of(self, cl: type[Any] | tuple[type[Any], ...]) -> bool:\n    \"\"\"Whether any generic args are a subclass of the given type.\n\n    Args:\n        cl: The type to check, or tuple of types. Passed as 2nd argument to ``issubclass()``.\n\n    Returns:\n        Whether any of the type's generic args are a subclass of the given type.\n    \"\"\"\n    return any(t.is_subclass_of(cl) for t in self.inner_types)\n```"]}, "litestar-litestar/typing.py-get_type_hints": {"response": ["```python\ndef get_type_hints(self, *, include_extras: bool = False, resolve_generics: bool = False) -> dict[str, Any]:\n    \"\"\"Get the type hints for the annotation.\n\n    Args:\n        include_extras: Flag to indicate whether to include ``Annotated[T, ...]`` or not.\n        resolve_generics: Flag to indicate whether to resolve the generic types in the type hints or not.\n\n    Returns:\n        The type hints.\n    \"\"\"\n    if resolve_generics:\n        return get_type_hints_with_generics_resolved(self.annotation, include_extras=include_extras)\n    return get_type_hints(self.annotation, include_extras=include_extras)\n```"]}, "litestar-litestar/typing.py-from_kwarg": {"response": ["```python\ndef from_kwarg(\n    annotation: Any,\n    name: str,\n    default: Any = Empty,\n    inner_types: tuple[FieldDefinition, ...] | None = None,\n    kwarg_definition: KwargDefinition | DependencyKwarg | None = None,\n    extra: dict[str, Any] | None = None,\n) -> FieldDefinition:\n    \"\"\"Create a new FieldDefinition instance.\n\n    Args:\n        annotation: The type of the kwarg.\n        name: Field name.\n        default: A default value.\n        inner_types: A tuple of FieldDefinition instances representing the inner types, if any.\n        kwarg_definition: Kwarg Parameter.\n        extra: A mapping of extra values.\n\n    Returns:\n        FieldDefinition instance.\n    \"\"\"\n    return FieldDefinition.from_annotation(\n        annotation=annotation,\n        name=name,\n        default=default,\n        inner_types=inner_types or (),\n        kwarg_definition=kwarg_definition,\n        extra=extra or {},\n    )\n```"]}, "litestar-litestar/typing.py-from_parameter": {"response": ["```python\ndef from_parameter(cls, parameter: Parameter, fn_type_hints: dict[str, Any]) -> FieldDefinition:\n    \"\"\"Initialize ParsedSignatureParameter.\n\n    Args:\n        parameter: inspect.Parameter\n        fn_type_hints: mapping of names to types. Should be result of ``get_type_hints()``, preferably via the\n            :attr:``get_fn_type_hints() <.utils.signature_parsing.get_fn_type_hints>`` helper.\n\n    Returns:\n        ParsedSignatureParameter.\n    \"\"\"\n    annotation = fn_type_hints.get(parameter.name, parameter.annotation)\n    return cls.from_annotation(\n        annotation=annotation,\n        default=parameter.default,\n        name=parameter.name,\n    )\n```"]}, "litestar-litestar/_openapi/responses.py-create_success_response": {"response": ["```python\ndef create_success_response(self) -> OpenAPIResponse:\n    \"\"\"Create the schema for a success response.\"\"\"\n    response = OpenAPIResponse(\n        content=None,\n        description=self.create_description(),\n    )\n    self.set_success_response_headers(response)\n    return response\n```"]}, "litestar-litestar/_openapi/responses.py-create_additional_responses": {"response": ["```python\ndef create_additional_responses(self) -> Iterator[tuple[str, OpenAPIResponse]]:\n    \"\"\"Create the schema for additional responses, if any.\"\"\"\n    for status_code, response_handler in self.route_handler.additional_responses.items():\n        schema = self.schema_creator.for_field_definition(\n            FieldDefinition.from_annotation(response_handler.annotation)\n        )\n        yield (\n            str(status_code),\n            OpenAPIResponse(\n                description=response_handler.description or HTTPStatus(status_code).description,\n                content={\n                    response_handler.media_type: OpenAPIMediaType(schema=schema)\n                },\n            ),\n        )\n```"]}, "litestar-litestar/_openapi/path_item.py-create_path_item": {"response": ["```python\ndef create_path_item(self) -> PathItem:\n    \"\"\"Create a PathItem for the given route parsing all http_methods into Operation Models.\n\n    Returns:\n        A PathItem instance.\n    \"\"\"\n    for http_method, route_handlers in self.route.route_handler_map.items():\n        for route_handler in route_handlers:\n            operation = self.create_operation_for_handler_method(route_handler, http_method)\n            setattr(self._path_item, http_method.lower(), operation)\n    return self._path_item\n```"]}, "litestar-litestar/_openapi/schema_generation/schema.py-for_field_definition": {"response": ["```python\ndef for_field_definition(self, field_definition: FieldDefinition) -> Schema | Reference:\n    \"\"\"Create a Schema for a given FieldDefinition.\n\n    Args:\n        field_definition: A signature field instance.\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    if field_definition.is_optional:\n        return self.for_optional_field(field_definition)\n\n    if field_definition.is_union:\n        return self.for_union_field(field_definition)\n\n    if field_definition.is_literal:\n        return create_literal_schema(field_definition.annotation, include_null=field_definition.is_optional)\n\n    if field_definition.is_enum:\n        return create_enum_schema(field_definition.annotation, include_null=field_definition.is_optional)\n\n    if field_definition.is_new_type:\n        return self.for_new_type(field_definition)\n\n    if field_definition.is_typevar:\n        return self.for_typevar()\n\n    if self.is_constrained_field(field_definition):\n        return self.for_constrained_field(field_definition)\n\n    if plugin := self.get_plugin_for(field_definition):\n        return self.for_plugin(field_definition, plugin)\n\n    if field_definition.is_object:\n        return self.for_object_type(field_definition)\n\n    schema = create_schema_for_annotation(field_definition.annotation)\n    return self.process_schema_result(field_definition, schema)\n```"]}, "litestar-litestar/_openapi/typescript_converter/converter.py-convert_openapi_to_typescript": {"response": ["```python\nfrom __future__ import annotations\n\nfrom litestar._openapi.typescript_converter.types import TypeScriptNamespace\nfrom litestar.openapi.spec import OpenAPI\n\nfrom .converter import parse_params, parse_request_body, parse_responses\n\n\ndef convert_openapi_to_typescript(openapi_schema: OpenAPI, namespace: str = \"API\") -> TypeScriptNamespace:\n    \"\"\"Convert an OpenAPI Schema instance to a TypeScript namespace. This function is the main entry point for the\n    TypeScript converter.\n\n    Args:\n        openapi_schema: An OpenAPI Schema instance.\n        namespace: The namespace to use.\n\n    Returns:\n        A TypeScriptNamespace representing the generated types.\n    \"\"\"\n    components = openapi_schema.components\n    operations = []\n\n    for path, path_item in openapi_schema.paths.items():\n        for method, operation in path_item.operations.items():\n            operation_name = f\"{method.upper()}_{path.replace('/', '_')}\"\n            params = parse_params(operation.parameters, components)\n            request_body = parse_request_body(operation.request_body, components) if operation.request_body else None\n            responses = parse_responses(operation.responses, components)\n\n            operation_types = [*params, request_body, *responses] if request_body else [*params, *responses]\n            operations.append(TypeScriptNamespace(operation_name, tuple(operation_types)))\n\n    return TypeScriptNamespace(namespace, tuple(operations))\n```"]}, "litestar-litestar/_openapi/typescript_converter/types.py-write": {"response": ["```python\ndef write(self) -> str:\n    \"\"\"Write a typescript intersection value.\n\n    Example:\n        { prop: string } & { another: number }\n\n    Returns:\n        A typescript string\n    \"\"\"\n    return \" & \".join(sorted(t.write() for t in self.types))\n```"]}, "litestar-litestar/testing/helpers.py-create_test_client": {"response": ["```python\nfrom litestar import Litestar\nfrom litestar.testing.client import TestClient\nfrom litestar.utils.predicates import is_class_and_subclass\nfrom typing import TYPE_CHECKING, Any, Callable, Literal, Mapping, Sequence\n\nif TYPE_CHECKING:\n    from contextlib import AbstractAsyncContextManager\n\n    from litestar import Request, Response, WebSocket\n    from litestar.config.allowed_hosts import AllowedHostsConfig\n    from litestar.config.compression import CompressionConfig\n    from litestar.config.cors import CORSConfig\n    from litestar.config.csrf import CSRFConfig\n    from litestar.config.response_cache import ResponseCacheConfig\n    from litestar.datastructures import CacheControlHeader, ETag, State\n    from litestar.dto import AbstractDTO\n    from litestar.events import BaseEventEmitterBackend, EventListener\n    from litestar.logging.config import BaseLoggingConfig\n    from litestar.middleware.session.base import BaseBackendConfig\n    from litestar.openapi.config import OpenAPIConfig\n    from litestar.openapi.spec import SecurityRequirement\n    from litestar.plugins import PluginProtocol\n    from litestar.static_files.config import StaticFilesConfig\n    from litestar.stores.base import Store\n    from litestar.stores.registry import StoreRegistry\n    from litestar.template.config import TemplateConfig\n    from litestar.types import (\n        AfterExceptionHookHandler,\n        AfterRequestHookHandler,\n        AfterResponseHookHandler,\n        BeforeMessageSendHookHandler,\n        BeforeRequestHookHandler,\n        ControllerRouterHandler,\n        Dependencies,\n        EmptyType,\n        ExceptionHandlersMap,\n        Guard,\n        LifespanHook,\n        Middleware,\n        OnAppInitHandler,\n        ParametersMap,\n        ResponseCookies,\n        ResponseHeaders,\n        TypeEncodersMap,\n    )\n\ndef create_test_client(\n    route_handlers: ControllerRouterHandler | Sequence[ControllerRouterHandler] | None = None,\n    *,\n    after_exception: Sequence[AfterExceptionHookHandler] | None = None,\n    after_request: AfterRequestHookHandler | None = None,\n    after_response: AfterResponseHookHandler | None = None,\n    allowed_hosts: Sequence[str] | AllowedHostsConfig | None = None,\n    backend: Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n    backend_options: Mapping[str, Any] | None = None,\n    base_url: str = \"http://testserver.local\",\n    before_request: BeforeRequestHookHandler | None = None,\n    before_send: Sequence[BeforeMessageSendHookHandler] | None = None,\n    cache_control: CacheControlHeader | None = None,\n    compression_config: CompressionConfig | None = None,\n    cors_config: CORSConfig | None = None,\n    csrf_config: CSRFConfig | None = None,\n    debug: bool = True,\n    dependencies: Dependencies | None = None,\n    dto: type[AbstractDTO] | None | EmptyType = Empty,\n    etag: ETag | None = None,\n    event_emitter_backend: type[BaseEventEmitterBackend] = SimpleEventEmitter,\n    exception_handlers: ExceptionHandlersMap | None = None,\n    guards: Sequence[Guard] | None = None,\n    include_in_schema: bool | EmptyType = Empty,\n    lifespan: list[Callable[[Litestar], AbstractAsyncContextManager] | AbstractAsyncContextManager] | None = None,\n    listeners: Sequence[EventListener] | None = None,\n    logging_config: BaseLoggingConfig | EmptyType | None = Empty,\n    middleware: Sequence[Middleware] | None = None,\n    multipart_form_part_limit: int = 1000,\n    on_app_init: Sequence[OnAppInitHandler] | None = None,\n    on_shutdown: Sequence[LifespanHook] | None = None,\n    on_startup: Sequence[LifespanHook] | None = None,\n    openapi_config: OpenAPIConfig | None = DEFAULT_OPENAPI_CONFIG,\n    opt: Mapping[str, Any] | None = None,\n    parameters: ParametersMap | None = None,\n    pdb_on_exception: bool | None = None,\n    path: str | None = None,\n    plugins: Sequence[PluginProtocol] | None = None,\n    raise_server_exceptions: bool = True,\n    request"]}, "litestar-litestar/testing/client/sync_client.py-websocket_connect": {"response": ["```python\ndef websocket_connect(\n    self,\n    url: str,\n    subprotocols: Sequence[str] | None = None,\n    params: QueryParamTypes | None = None,\n    headers: HeaderTypes | None = None,\n    cookies: CookieTypes | None = None,\n    auth: AuthTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n    follow_redirects: bool | UseClientDefault = USE_CLIENT_DEFAULT,\n    timeout: TimeoutTypes | UseClientDefault = USE_CLIENT_DEFAULT,\n    extensions: Mapping[str, Any] | None = None,\n) -> WebSocketTestSession:\n    \"\"\"Sends a GET request to establish a websocket connection.\n\n    Args:\n        url: Request URL.\n        subprotocols: Websocket subprotocols.\n        params: Query parameters.\n        headers: Request headers.\n        cookies: Request cookies.\n        auth: Auth headers.\n        follow_redirects: Whether to follow redirects.\n        timeout: Request timeout.\n        extensions: Dictionary of ASGI extensions.\n\n    Returns:\n        A `WebSocketTestSession <litestar.testing.WebSocketTestSession>` instance.\n    \"\"\"\n    try:\n        self.send(\n            self._prepare_ws_connect_request(\n                url=url,\n                subprotocols=subprotocols,\n                params=params,\n                headers=headers,\n                cookies=cookies,\n                extensions=extensions,\n                timeout=timeout,\n            ),\n            auth=auth,\n            follow_redirects=follow_redirects,\n        )\n    except ConnectionUpgradeExceptionError as exc:\n        return exc.session\n\n    raise RuntimeError(\"Expected WebSocket upgrade\")  # pragma: no cover\n```"]}, "litestar-litestar/contrib/pydantic/pydantic_schema_plugin.py-for_pydantic_model": {"response": ["```python\ndef for_pydantic_model(cls, field_definition: FieldDefinition, schema_creator: SchemaCreator) -> Schema:  # pyright: ignore\n    \"\"\"Create a schema object for a given pydantic model class.\n\n    Args:\n        field_definition: FieldDefinition instance.\n        schema_creator: An instance of the schema creator class\n\n    Returns:\n        A schema instance.\n    \"\"\"\n    model_class = field_definition.annotation\n    model_name = model_class.__name__\n    schema_creator.prefer_alias = cls.prefer_alias\n\n    # Get the type hints for the model\n    type_hints = pydantic_get_type_hints_with_generics_resolved(model_class)\n\n    # Create field definitions for computed fields\n    computed_fields = create_field_definitions_for_computed_fields(model_class, cls.prefer_alias)\n\n    # Combine type hints with computed fields\n    all_fields = {**type_hints, **computed_fields}\n\n    # Create the schema for each field\n    properties = {\n        field_name: schema_creator.for_field_definition(FieldDefinition.from_kwarg(annotation=field_type, name=field_name))\n        for field_name, field_type in all_fields.items()\n    }\n\n    # Determine required fields\n    required_fields = [\n        field_name\n        for field_name, field_type in all_fields.items()\n        if not is_pydantic_undefined(getattr(model_class.__fields__[field_name].field_info, \"default\", Empty))\n    ]\n\n    # Create the schema\n    schema = Schema(\n        type=OpenAPIType.OBJECT,\n        properties=properties,\n        required=required_fields if required_fields else None,\n        title=model_name,\n    )\n\n    return schema\n```"]}, "litestar-litestar/_kwargs/cleanup.py-cleanup": {"response": ["```python\nasync def cleanup(self) -> None:\n    \"\"\"Execute cleanup by calling :func:`next` / :func:`anext` on all generators.\n\n    If there are multiple generators to be called, they will be executed in a :class:`anyio.TaskGroup`.\n\n    Returns:\n        None\n    \"\"\"\n    if not self._generators:\n        return\n\n    async with create_task_group() as task_group:\n        for generator in self._generators:\n            wrapped_next = self._wrap_next(generator)\n            task_group.start_soon(wrapped_next)\n```"]}, "litestar-litestar/_asgi/routing_trie/mapping.py-build_route_middleware_stack": {"response": ["```python\nfrom litestar._asgi.utils import wrap_in_exception_handler\nfrom litestar.types import ASGIApp\n\ndef build_route_middleware_stack(\n    app: \"Litestar\",\n    route: \"HTTPRoute | WebSocketRoute | ASGIRoute\",\n    route_handler: \"RouteHandlerType\",\n) -> ASGIApp:\n    \"\"\"Construct a middleware stack that serves as the point of entry for each route.\n\n    Args:\n        app: The Litestar app instance.\n        route: The route that is being added.\n        route_handler: The route handler that is being wrapped.\n\n    Returns:\n        An ASGIApp that is composed of a \"stack\" of middlewares.\n    \"\"\"\n    # Assuming `wrap_in_exception_handler` is a utility function that wraps the route handler in exception handling middleware\n    return wrap_in_exception_handler(app, route_handler)\n```"]}, "litestar-litestar/utils/signature.py-from_fn": {"response": ["```python\ndef from_fn(cls, fn: AnyCallable, signature_namespace: dict[str, Any]) -> Self:\n    \"\"\"Parse a function signature.\n\n    Args:\n        fn: Any callable.\n        signature_namespace: mapping of names to types for forward reference resolution\n\n    Returns:\n        ParsedSignature\n    \"\"\"\n    from inspect import signature\n\n    fn_signature = signature(fn)\n    fn_type_hints = get_fn_type_hints(fn, namespace=signature_namespace)\n    return cls.from_signature(signature=fn_signature, fn_type_hints=fn_type_hints)\n```"]}, "litestar-litestar/utils/deprecation.py-deprecated": {"response": ["```python\nfrom __future__ import annotations\n\nimport inspect\nfrom functools import wraps\nfrom typing import Callable, Literal, TypeVar\nfrom warnings import warn\n\nfrom typing_extensions import ParamSpec\n\n__all__ = (\"deprecated\", \"warn_deprecation\")\n\n\nT = TypeVar(\"T\")\nP = ParamSpec(\"P\")\nDeprecatedKind = Literal[\"function\", \"method\", \"classmethod\", \"attribute\", \"property\", \"class\", \"parameter\", \"import\"]\n\n\ndef warn_deprecation(\n    version: str,\n    deprecated_name: str,\n    kind: DeprecatedKind,\n    *,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n) -> None:\n    \"\"\"Warn about a call to a (soon to be) deprecated function.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        deprecated_name: Name of the deprecated function\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated thing\n    \"\"\"\n    parts = []\n\n    if kind == \"import\":\n        access_type = \"Import of\"\n    elif kind in {\"function\", \"method\"}:\n        access_type = \"Call to\"\n    else:\n        access_type = \"Use of\"\n\n    if pending:\n        parts.append(f\"{access_type} {kind} awaiting deprecation {deprecated_name!r}\")\n    else:\n        parts.append(f\"{access_type} deprecated {kind} {deprecated_name!r}\")\n\n    parts.extend(\n        (\n            f\"Deprecated in litestar {version}\",\n            f\"This {kind} will be removed in {removal_in or 'the next major version'}\",\n        )\n    )\n    if alternative:\n        parts.append(f\"Use {alternative!r} instead\")\n\n    if info:\n        parts.append(info)\n\n    text = \". \".join(parts)\n    warning_class = PendingDeprecationWarning if pending else DeprecationWarning\n\n    warn(text, warning_class, stacklevel=2)\n\n\ndef deprecated(\n    version: str,\n    removal_in: str | None = None,\n    alternative: str | None = None,\n    info: str | None = None,\n    pending: bool = False,\n    kind: DeprecatedKind | None = None,\n) -> Callable[[Callable[P, T]], Callable[P, T]]:\n    \"\"\"Create a decorator wrapping a function, method or property with a warning call about a (pending) deprecation.\n\n    Args:\n        version: Litestar version where the deprecation will occur\n        removal_in: Litestar version where the deprecated function will be removed\n        alternative: Name of a function that should be used instead\n        info: Additional information\n        pending: Use ``PendingDeprecationWarning`` instead of ``DeprecationWarning``\n        kind: Type of the deprecated callable. If ``None``, will use ``inspect`` to figure\n            out if it's a function or method\n\n    Returns:\n        A decorator wrapping the function call with a warning\n    \"\"\"\n    def decorator(fn: Callable[P, T]) -> Callable[P, T]:\n        if kind is None:\n            if inspect.isclass(fn):\n                kind = \"class\"\n            elif inspect.ismethod(fn) or inspect.ismethoddescriptor(fn):\n                kind = \"method\"\n            elif inspect.isfunction(fn) or inspect.isbuiltin(fn):\n                kind = \"function\"\n            elif isinstance(fn, property):\n                kind = \"property\"\n            else:\n                kind = \"attribute\"\n\n        @wraps(fn)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> T:\n            warn_deprecation(\n                version=version,\n                deprecated_name=f\"{fn.__module__}.{fn.__name__}\",\n                kind=kind,\n                removal_in=removal_in,\n                alternative=alternative,\n                info=info,\n                pending=pending,\n            )\n            return fn(*args, **kwargs)\n\n        return wrapper\n\n    return decorator"]}, "litestar-litestar/utils/sync.py-ensure_async_callable": {"response": ["```python\nfrom typing import Callable, Awaitable, TypeVar\nfrom typing_extensions import ParamSpec\n\nfrom litestar.utils.sync import AsyncCallable\nfrom litestar.utils.predicates import is_async_callable\n\nP = ParamSpec(\"P\")\nT = TypeVar(\"T\")\n\ndef ensure_async_callable(fn: Callable[P, T]) -> Callable[P, Awaitable[T]]:\n    \"\"\"Ensure that ``fn`` is an asynchronous callable.\n    If it is an asynchronous, return the original object, else wrap it in an\n    ``AsyncCallable``\n    \"\"\"\n    return fn if is_async_callable(fn) else AsyncCallable(fn)\n```"]}, "litestar-litestar/utils/typing.py-expand_type_var_in_type_hint": {"response": ["```python\ndef expand_type_var_in_type_hint(type_hint: dict[str, Any], namespace: dict[str, Any] | None) -> dict[str, Any]:\n    \"\"\"Expand TypeVar for any parameters in type_hint\n\n    Args:\n        type_hint: mapping of parameter to type obtained from calling `get_type_hints` or `get_fn_type_hints`\n        namespace: mapping of TypeVar to concrete type\n\n    Returns:\n        type_hint with any TypeVar parameter expanded\n    \"\"\"\n    from typing import TypeVar\n\n    if namespace is None:\n        return type_hint\n\n    def _expand_type_var(annotation: Any) -> Any:\n        if isinstance(annotation, TypeVar):\n            return namespace.get(annotation.__name__, annotation)\n        return annotation\n\n    return {param: _expand_type_var(annotation) for param, annotation in type_hint.items()}\n```"]}, "litestar-litestar/utils/dataclass.py-simple_asdict": {"response": ["```python\nfrom __future__ import annotations\n\nfrom dataclasses import is_dataclass\nfrom typing import TYPE_CHECKING, Any\n\nfrom litestar.types import Empty\nfrom litestar.utils.dataclass import extract_dataclass_items\n\nif TYPE_CHECKING:\n    from litestar.types.protocols import DataclassProtocol\n\n__all__ = (\"simple_asdict\",)\n\n\ndef simple_asdict(\n    obj: DataclassProtocol,\n    exclude_none: bool = False,\n    exclude_empty: bool = False,\n    convert_nested: bool = False,\n    exclude: set[str] | None = None,\n) -> dict[str, Any]:\n    \"\"\"Convert a dataclass to a dictionary.\n\n    This method has important differences to the standard library version:\n    - it does not deepcopy values\n    - it does not recurse into collections\n\n    Args:\n        obj: A dataclass instance.\n        exclude_none: Whether to exclude None values.\n        exclude_empty: Whether to exclude Empty values.\n        convert_nested: Whether to recursively convert nested dataclasses.\n        exclude: An iterable of fields to exclude.\n\n    Returns:\n        A dictionary of key/value pairs.\n    \"\"\"\n    if not is_dataclass(obj):\n        raise ValueError(\"The provided object is not a dataclass instance.\")\n\n    items = extract_dataclass_items(obj, exclude_none, exclude_empty, exclude=exclude)\n\n    if convert_nested:\n        return {\n            key: simple_asdict(value, exclude_none, exclude_empty, convert_nested, exclude)\n            if is_dataclass(value) and isinstance(value, DataclassProtocol)\n            else value\n            for key, value in items\n        }\n\n    return dict(items)\n```"]}, "litestar-litestar/utils/path.py-join_paths": {"response": ["```python\ndef join_paths(paths: Iterable[str]) -> str:\n    \"\"\"Normalize and joins path fragments.\n\n    Args:\n        paths: An iterable of path fragments.\n\n    Returns:\n        A normalized joined path string.\n    \"\"\"\n    return normalize_path(\"/\".join(paths))\n```"]}, "litestar-litestar/utils/helpers.py-get_name": {"response": ["```python\ndef get_name(value: object) -> str:\n    \"\"\"Get the ``__name__`` of an object.\n\n    Args:\n        value: An arbitrary object.\n\n    Returns:\n        A name string.\n    \"\"\"\n    return value.__name__\n```"]}, "litestar-litestar/utils/predicates.py-is_dataclass_class": {"response": ["```python\nfrom typing import Any, TypeGuard\nfrom dataclasses import is_dataclass\nfrom litestar.types.protocols import DataclassProtocol\n\ndef is_dataclass_class(annotation: Any) -> TypeGuard[type[DataclassProtocol]]:\n    \"\"\"Wrap :func:`is_dataclass <dataclasses.is_dataclass>` in a :data:`typing.TypeGuard`.\n\n    Args:\n        annotation: tested to determine if instance or type of :class:`dataclasses.dataclass`.\n\n    Returns:\n        ``True`` if instance or type of ``dataclass``.\n    \"\"\"\n    return is_dataclass(annotation)\n```"]}, "litestar-litestar/utils/predicates.py-is_class_var": {"response": ["```python\ndef is_class_var(annotation: Any) -> bool:\n    \"\"\"Check if the given annotation is a ClassVar.\n\n    Args:\n        annotation: A type annotation\n\n    Returns:\n        A boolean.\n    \"\"\"\n    return get_origin_or_inner_type(annotation) is ClassVar\n```"]}, "litestar-litestar/utils/module_loader.py-import_string": {"response": ["```python\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"Dotted Path Import.\n\n    Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import failed.\n\n    Args:\n        dotted_path: The path of the module to import.\n\n    Raises:\n        ImportError: Could not import the module.\n\n    Returns:\n        object: The imported object.\n    \"\"\"\n    try:\n        module_path, class_name = dotted_path.rsplit('.', 1)\n    except ValueError as e:\n        raise ImportError(f\"{dotted_path} doesn't look like a module path\") from e\n\n    try:\n        module: ModuleType = import_module(module_path)\n    except ImportError as e:\n        raise ImportError(f\"Could not import module {module_path}\") from e\n\n    try:\n        return getattr(module, class_name)\n    except AttributeError as e:\n        raise ImportError(f\"Module '{module_path}' does not define a '{class_name}' attribute/class\") from e\n```"]}, "litestar-litestar/channels/backends/redis.py-unsubscribe": {"response": ["```python\nasync def unsubscribe(self, channels: Iterable[str]) -> None:\n    \"\"\"Unsubscribe from ``channels``\"\"\"\n    for channel in channels:\n        await self._listener_conn.execute(f\"UNLISTEN {_safe_quote(channel)};\")  # pyright: ignore\n    self._subscribed_channels = self._subscribed_channels - set(channels)\n```"]}, "litestar-litestar/channels/backends/redis.py-publish": {"response": ["```python\nasync def publish(self, data: bytes, channels: Iterable[str]) -> None:\n    \"\"\"Publish ``data`` to ``channels``.\n\n    .. note::\n        This operation is performed atomically, using a Lua script\n    \"\"\"\n    await self._publish_script(keys=list(set(channels)), args=[data])\n```"]}, "litestar-litestar/channels/backends/redis.py-stream_events": {"response": ["```python\nasync def stream_events(self) -> AsyncGenerator[tuple[str, Any], None]:\n    \"\"\"Return a generator, iterating over events of subscribed channels as they become available.\n\n    If no channels have been subscribed to yet via :meth:`subscribe`, sleep for ``stream_sleep_no_subscriptions``\n    milliseconds.\n    \"\"\"\n    while True:\n        await self._has_subscribed.wait()\n        message = await self._pub_sub.get_message(\n            ignore_subscribe_messages=True, timeout=self._stream_sleep_no_subscriptions\n        )\n        if message is None:\n            continue\n\n        channel: str = message[\"channel\"].decode()\n        data: bytes = message[\"data\"]\n        # redis handles the unsubscribes with a queue; Unsubscribing doesn't mean the\n        # unsubscribe will happen immediately after requesting it, so we could\n        # receive a message on a channel that, from a client's perspective, it's not\n        # subscribed to anymore\n        if channel.encode() in self._pub_sub.channels.keys() - self._pub_sub.pending_unsubscribe_channels:\n            yield channel, data\n```"]}, "litestar-litestar/channels/backends/redis.py-get_history": {"response": ["```python\nasync def get_history(self, channel: str, limit: int | None = None) -> list[bytes]:\n    \"\"\"Return the history of ``channels``, returning at most ``limit`` messages\"\"\"\n    history = list(self._history[channel])\n    if limit:\n        history = history[-limit:]\n    return history\n```"]}, "litestar-litestar/dto/_backend.py-create_transfer_model_type": {"response": ["```python\ndef create_transfer_model_type(\n    model_name: str,\n    field_definitions: tuple[TransferDTOFieldDefinition, ...],\n) -> type[Struct]:\n    \"\"\"Create a model for data transfer.\n\n    Args:\n        model_name: name for the type that should be unique across all transfer types.\n        field_definitions: field definitions for the container type.\n\n    Returns:\n        A ``BackendT`` class.\n    \"\"\"\n    return _create_struct_for_field_definitions(\n        model_name=model_name,\n        field_definitions=field_definitions,\n        rename_strategy=DTOBackend.dto_factory.config.rename_strategy,\n    )\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_builtins": {"response": ["```python\ndef populate_data_from_builtins(self, builtins: Any, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Populate model instance from builtin types.\n\n    Args:\n        builtins: Builtin type.\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    if self.dto_data_type:\n        return self.dto_data_type(\n            backend=self,\n            data_as_builtins=self._transfer_to_dict(self.parse_builtins(builtins, asgi_connection)),\n        )\n    return self.transfer_data_from_builtins(self.parse_builtins(builtins, asgi_connection))\n```"]}, "litestar-litestar/dto/_backend.py-populate_data_from_raw": {"response": ["```python\ndef populate_data_from_raw(self, raw: bytes, asgi_connection: ASGIConnection) -> Any:\n    \"\"\"Parse raw bytes into instance of `model_type`.\n\n    Args:\n        raw: bytes\n        asgi_connection: The current ASGI Connection\n\n    Returns:\n        Instance or collection of ``model_type`` instances.\n    \"\"\"\n    request_encoding = RequestEncodingType.JSON\n\n    if (content_type := getattr(asgi_connection, \"content_type\", None)) and (media_type := content_type[0]):\n        request_encoding = media_type\n\n    type_decoders = asgi_connection.route_handler.resolve_type_decoders()\n\n    if request_encoding == RequestEncodingType.MESSAGEPACK:\n        result = decode_msgpack(value=raw, target_type=self.annotation, type_decoders=type_decoders)\n    else:\n        result = decode_json(value=raw, target_type=self.annotation, type_decoders=type_decoders)\n\n    return cast(\"Struct | Collection[Struct]\", result)\n```"]}, "litestar-litestar/dto/_backend.py-encode_data": {"response": ["```python\ndef encode_data(self, data: Any) -> LitestarEncodableType:\n    \"\"\"Encode data into a ``LitestarEncodableType``.\n\n    Args:\n        data: Data to encode.\n\n    Returns:\n        Encoded data.\n    \"\"\"\n    if self.wrapper_attribute_name:\n        wrapped_transfer = self._encode_data(getattr(data, self.wrapper_attribute_name))\n        setattr(data, self.wrapper_attribute_name, wrapped_transfer)\n        return cast(\"LitestarEncodableType\", data)\n\n    return cast(\"LitestarEncodableType\", self._encode_data(data))\n```"]}, "litestar-litestar/dto/_backend.py-_create_transfer_model_type_annotation": {"response": ["```python\ndef _create_transfer_model_type_annotation(transfer_type: TransferType) -> Any:\n    \"\"\"Create a type annotation for a transfer model.\n\n    Uses the parsed type that originates from the data model and the transfer model generated to represent a nested\n    type to reconstruct the type annotation for the transfer model.\n    \"\"\"\n    if isinstance(transfer_type, SimpleType):\n        if transfer_type.nested_field_info:\n            return transfer_type.nested_field_info.model\n        return transfer_type.field_definition.annotation\n\n    if isinstance(transfer_type, CollectionType):\n        return _create_transfer_model_collection_type(transfer_type)\n\n    if isinstance(transfer_type, TupleType):\n        return _create_transfer_model_tuple_type(transfer_type)\n\n    if isinstance(transfer_type, UnionType):\n        return _create_transfer_model_union_type(transfer_type)\n\n    if isinstance(transfer_type, MappingType):\n        return _create_transfer_model_mapping_type(transfer_type)\n\n    raise ValueError(f\"Unsupported transfer type: {transfer_type}\")\n```"]}, "litestar-litestar/response/file.py-start_response": {"response": ["```python\nasync def start_response(self, send: Send) -> None:\n    \"\"\"Emit the start event of the response. This event includes the headers and status codes.\n\n    Args:\n        send: The ASGI send function.\n\n    Returns:\n        None\n    \"\"\"\n    event: HTTPResponseStartEvent = {\n        \"type\": \"http.response.start\",\n        \"status\": self.status_code,\n        \"headers\": self.encode_headers(),\n    }\n    await send(event)\n```"]}, "litestar-litestar/connection/request.py-json": {"response": ["```python\nasync def json(self) -> Any:\n    \"\"\"Retrieve the json request body from the request.\n\n    Returns:\n        An arbitrary value\n    \"\"\"\n    if self._json is Empty:\n        if (json_data := self._connection_state.json) is not Empty:\n            self._json = json_data\n        else:\n            body = await self.body()\n            self._json = self._connection_state.json = decode_json(\n                body or b\"\", type_decoders=self.route_handler.resolve_type_decoders()\n            )\n    return self._json\n```"]}, "litestar-litestar/datastructures/multi_dicts.py-close": {"response": ["```python\nasync def close(self) -> None:\n    \"\"\"Close all files in the multi-dict.\n\n    Returns:\n        None\n    \"\"\"\n    for value in self.values():\n        if isinstance(value, UploadFile):\n            await value.close()\n```"]}, "litestar-litestar/datastructures/url.py-from_scope": {"response": ["```python\ndef from_scope(cls, scope: Scope) -> Self:\n    \"\"\"Construct a URL from a :class:`Scope <.types.Scope>`\n\n    Args:\n        scope: A scope\n\n    Returns:\n        A URL\n    \"\"\"\n    # Extract the necessary components from the scope to construct the URL\n    scheme = scope.get(\"scheme\", \"http\")\n    server = scope.get(\"server\", (\"localhost\", 80))\n    path = scope.get(\"path\", \"/\")\n    query_string = scope.get(\"query_string\", b\"\")\n    fragment = scope.get(\"fragment\", \"\")\n\n    # Construct the netloc from the server information\n    host, port = server\n    netloc = f\"{host}:{port}\" if port else host\n\n    # Construct the query string from the query_string bytes\n    query = query_string.decode(\"latin-1\") if query_string else \"\"\n\n    # Create and return the URL instance\n    return cls.from_components(scheme=scheme, netloc=netloc, path=path, query=query, fragment=fragment)\n```"]}, "litestar-litestar/datastructures/headers.py-to_header": {"response": ["```python\ndef to_header(self, include_header_name: bool = False) -> str:\n    \"\"\"Get the header as string.\n\n    Args:\n        include_header_name: should include the header name in the return value. If set to false\n            the return value will only include the header value. if set to true the return value\n            will be: ``<header name>: <header value>``. Defaults to false.\n    \"\"\"\n    header_value = self.simple_cookie.output(header=\"\").strip()\n    if include_header_name:\n        return f\"Set-Cookie: {header_value}\"\n    return header_value\n```"]}, "litestar-litestar/middleware/session/server_side.py-delete": {"response": ["```python\nasync def delete(self, session_id: str, store: Store) -> None:\n    \"\"\"Delete the data associated with ``session_id``. Fails silently if no such session-ID exists.\n\n    Args:\n        session_id: The session-ID\n        store: Store to delete the session data from\n\n    Returns:\n        None\n    \"\"\"\n    await store.delete(session_id)\n```"]}, "marimo-marimo/_islands/island_generator.py-add_code": {"response": ["```python\ndef add_code(\n    self,\n    code: str,\n    display_code: bool = False,\n    display_output: bool = True,\n    is_raw: bool = False,\n    is_reactive: bool = True,\n) -> MarimoIslandStub:\n    \"\"\"\n    Add a code cell to the app.\n\n    *Args:*\n\n    - code (str): The code to add to the app.\n    - display_code (bool): Whether to display the code in the HTML.\n    - display_output (bool): Whether to display the output in the HTML.\n    - is_raw (bool): Whether to handle the code without formatting.\n    - is_reactive (bool): Whether this code block will run with pyodide.\n\n    *Returns:*\n\n    - MarimoIslandStub: The stub representing the added code cell.\n    \"\"\"\n    cell_id = self._app.cell_manager.create_cell_id()\n    stub = MarimoIslandStub(\n        display_code=display_code,\n        display_output=display_output,\n        is_reactive=is_reactive,\n        cell_id=cell_id,\n        app_id=self._app_id,\n        code=code,\n    )\n    self._stubs.append(stub)\n    return stub\n```"]}, "marimo-marimo/_islands/island_generator.py-build": {"response": ["```python\nasync def build(self) -> App:\n    \"\"\"\n    Build the app. This should be called after adding all the code cells.\n\n    *Returns:*\n\n    - App: The built app.\n    \"\"\"\n    if self.has_run:\n        raise RuntimeError(\"App has already been built.\")\n\n    self.has_run = True\n\n    # Create cells from the stubs\n    for stub in self._stubs:\n        cell = Cell(\n            cell_id=stub._cell_id,\n            code=stub._code,\n            config=CellConfig(\n                display_code=stub._display_code,\n                display_output=stub._display_output,\n                is_reactive=stub._is_reactive,\n            ),\n        )\n        self._app.cell_manager.add_cell(cell)\n\n    # Run the app until completion\n    await run_app_until_completion(self._app)\n\n    # Attach the session view to each stub\n    session_view = self._app.session_view\n    for stub in self._stubs:\n        stub._session_view = session_view\n\n    return self._app\n```"]}, "marimo-marimo/_utils/parse_dataclass.py-build_dataclass": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport dataclasses\nimport json\nfrom enum import Enum\nfrom typing import (\n    Any,\n    Literal,\n    Optional,\n    Type,\n    TypeVar,\n    Union,\n    get_args,\n    get_origin,\n    get_type_hints,\n)\n\nT = TypeVar(\"T\")\n\n\ndef to_snake(string: str) -> str:\n    # basic conversion of javascript camel case to snake\n    # does not handle contiguous caps\n    return \"\".join(\n        [\"_\" + i.lower() if i.isupper() else i for i in string]\n    ).lstrip(\"_\")\n\n\ndef _build_value(value: Any, cls: Type[T]) -> T:\n    # origin_cls is not None if cls is a container (such as list, tuple, set,\n    # ...)\n    origin_cls = get_origin(cls)\n    if origin_cls is Optional:\n        (arg_type,) = get_args(cls)\n        if value is None:\n            return None  # type: ignore[return-value]\n        else:\n            return _build_value(value, arg_type)  # type: ignore # noqa: E501\n    elif origin_cls in (list, set):\n        (arg_type,) = get_args(cls)\n        return origin_cls(_build_value(v, arg_type) for v in value)  # type: ignore # noqa: E501\n    elif origin_cls is tuple:\n        arg_types = get_args(cls)\n        if len(arg_types) == 2 and isinstance(arg_types[1], type(Ellipsis)):\n            return origin_cls(_build_value(v, arg_types[0]) for v in value)  # type: ignore # noqa: E501\n        else:\n            return origin_cls(  # type: ignore # noqa: E501\n                _build_value(v, t) for v, t in zip(value, arg_types)\n            )\n    elif origin_cls is dict:\n        key_type, value_type = get_args(cls)\n        return origin_cls(  # type: ignore[no-any-return]\n            **{\n                _build_value(k, key_type): _build_value(v, value_type)\n                for k, v in value.items()\n            }\n        )\n    elif origin_cls == Union:\n        arg_types = get_args(cls)\n        for arg_type in arg_types:\n            try:\n                return _build_value(value, arg_type)  # type: ignore # noqa: E501\n            # catch expected exceptions when conversion fails\n            except (TypeError, ValueError):\n                continue\n            except:\n                raise\n        raise ValueError(f\"Value '{value}' does not fit any type of the union\")\n    elif origin_cls is Literal:\n        # if its a single Literal of an enum, we can just return the enum\n        arg_types = get_args(cls)\n        first_arg_type = arg_types[0]\n        if (\n            len(arg_types) == 1\n            and isinstance(first_arg_type, Enum)\n            and first_arg_type.value == value\n        ):\n            return first_arg_type  # type: ignore[return-value]\n        if value not in arg_types:\n            raise ValueError(\n                f\"Value '{value}' does not fit any type of the literal\"\n            )\n        return value  # type: ignore[no-any-return]\n    elif type(cls) == type(Enum) and issubclass(cls, Enum):\n        return cls(value)  # type: ignore[return-value]\n    elif dataclasses.is_dataclass(cls):\n        return build_dataclass(value, cls)  # type: ignore[return-value]\n    else:\n        return value  # type: ignore[no-any-return]\n\n\ndef build_dataclass(values: dict[Any, Any], cls: Type[T]) -> T:\n    \"\"\"Returns instance of dataclass [cls] instantiated from [values].\"\"\"\n    if not dataclasses.is_dataclass(cls):\n       "]}, "marimo-marimo/_utils/parse_dataclass.py-parse_raw": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport json\nfrom typing import Any, Type, TypeVar, Union, get_args, get_origin\n\nfrom marimo._utils.parse_dataclass import build_dataclass, to_snake\n\nT = TypeVar(\"T\")\n\n\ndef parse_raw(message: Union[bytes, dict[Any, Any]], cls: Type[T]) -> T:\n    \"\"\"Utility to parse a message as JSON, and instantiate into supplied type.\n\n    `cls` must be a dataclass.\n\n    Supported collection types in the dataclass:\n    - List, Tuple, Set, Dict\n    - for Python 3.8 compatibility, must use collection types from\n      the typing module (e.g., typing.List[int] instead of list[int])\n\n    Transforms all fields in the parsed JSON from camel case to snake case.\n\n    Args:\n    ----\n    message: the message to parse\n    cls: the type to instantiate\n    \"\"\"\n    if isinstance(message, bytes):\n        message = json.loads(message)\n\n    # Transform keys from camel case to snake case\n    transformed_message = {to_snake(k): v for k, v in message.items()}\n\n    return build_dataclass(transformed_message, cls)\n```"]}, "marimo-marimo/_plugins/stateless/icon.py-icon": {"response": ["```python\nfrom __future__ import annotations\n\nfrom typing import Literal, Optional, Union\n\nfrom marimo._output.builder import h\nfrom marimo._output.hypertext import Html\nfrom marimo._output.rich_help import mddoc\nfrom marimo._output.utils import create_style\n\n\n@mddoc\ndef icon(\n    icon_name: str,\n    size: Optional[Union[int, str]] = None,\n    color: Optional[str] = None,\n    inline: bool = True,\n    flip: Optional[Literal[\"horizontal\", \"vertical\", \"both\"]] = None,\n    rotate: Optional[Literal[90, 180, 270]] = None,\n    style: Optional[dict[str, Any]] = None,\n) -> Html:\n    \"\"\"\n    Displays an icon. These icons are referenced by name from the\n    [Iconify](https://iconify.design/) library.\n\n    They are named in the format `icon-set:icon-name`, e.g.\n    `lucide:leaf`.\n\n    Icons are lazily loaded from a CDN, so they will not be loaded when\n    not connected to the internet.\n\n    These can be used in buttons, tabs, and other UI elements.\n\n    **Examples.**\n\n    ```python\n    mo.md(f\"# {mo.icon('lucide:leaf')} Leaf\")\n\n    mo.ui.button(\n        label=f\"{mo.icon('lucide:rocket')} Submit\",\n    )\n    ```\n\n    **Args.**\n\n    - `icon_name`: the name of the icon to display\n    - `size`: the size of the icon in pixels\n    - `color`: the color of the icon\n    - `inline`: whether to display the icon inline or as a block element\n    - `flip`: whether to flip the icon horizontally, vertically, or both\n    - `rotate`: whether to rotate the icon 90, 180, or 270 degrees\n    - `style`: a dictionary of CSS styles to apply to the icon\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    icon_style = {\n        \"display\": \"inline-block\" if inline else \"block\",\n        \"width\": _space_to_string(size),\n        \"height\": _space_to_string(size),\n        \"color\": color,\n        **(style or {}),\n    }\n    icon_attributes = {\n        \"data-icon\": icon_name,\n        \"data-flip\": flip,\n        \"data-rotate\": rotate,\n    }\n    return Html(h.span(style=create_style(icon_style), **icon_attributes))\n\n\ndef _space_to_string(value: Union[str, int, float, None]) -> Optional[str]:\n    if value is None:\n        return None\n    if isinstance(value, str):\n        return value\n    else:\n        return f\"{value}px\"\n```"]}, "marimo-marimo/_plugins/stateless/image.py-image": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport io\nimport os\nfrom typing import Any, Optional, Union\n\nimport marimo._output.data.data as mo_data\nfrom marimo._dependencies.dependencies import DependencyManager\nfrom marimo._output.builder import h\nfrom marimo._output.hypertext import Html\nfrom marimo._output.rich_help import mddoc\nfrom marimo._output.utils import create_style\nfrom marimo._plugins.core.media import io_to_data_url\n\nImage = Union[str, bytes, io.BytesIO, io.BufferedReader]\n# Union[list, torch.Tensor, jax.numpy.ndarray,\n#             np.ndarray, scipy.sparse.spmatrix]\nTensor = Any\nImageLike = Union[Image, Tensor]\n\n\ndef _normalize_image(src: ImageLike) -> Image:\n    \"\"\"\n    Normalize an image-like object to a standard format.\n\n    This function handles a variety of input types, including lists, arrays,\n    and tensors, and converts them to a BytesIO object representing a PNG\n    image.\n\n    Typical convention for handling images is to use `PIL`, which is exactly\n    what `matplotlib` does behind the scenes. `PIL` requires a `ndarray`\n    (validated with the numpy specific `__array_interface__` attribute). In\n    turn, numpy can cast lists, and objects with the `__array__` method (like\n    jax, torch tensors). `scipy.sparse` breaks this convention but does have a\n    `toarray` method, which is general enough that a specific check is\n    performed here.\n\n    **Args.**\n\n    - `src`: An image-like object. This can be a list, array, tensor, or a\n        file-like object.\n\n    **Returns.**\n\n    A BytesIO object or other Image type.\n\n    **Raises.**\n\n    - `ModuleNotFoundError`: If the required `PIL` or `numpy` packages are not\n        available.\n    - `ValueError`: If the input is not a valid image-like object.\n    \"\"\"\n    if (\n        isinstance(src, list)\n        or hasattr(src, \"__array__\")\n        or hasattr(src, \"toarray\")\n    ):\n        DependencyManager.require_pillow(\n            \"to render images from arrays in `mo.image`\"\n        )\n        from PIL import Image as _Image\n\n        if not hasattr(src, \"__array_interface__\"):\n            DependencyManager.require_numpy(\n                \"to render images from generic arrays in `mo.image`\"\n            )\n            import numpy\n\n            # Capture those sparse cases\n            if hasattr(src, \"toarray\"):\n                src = src.toarray()\n            src = numpy.array(src)\n        src = (src - src.min()) / (src.max() - src.min()) * 255.0\n        img = _Image.fromarray(src.astype(\"uint8\"))\n        # io.BytesIO is one of the Image types.\n        normalized_src: Image = io.BytesIO()\n        img.save(normalized_src, format=\"PNG\")\n        return normalized_src\n    # Verify that this is a image object\n    if not isinstance(src, (str, bytes, io.BytesIO, io.BufferedReader)):\n        raise ValueError(\n            f\"Expected an image object, but got {type(src)} instead.\"\n        )\n    return src\n\n\n@mddoc\ndef image(\n    src: ImageLike,\n    alt: Optional[str] = None,\n    width: Optional[int] = None,\n    height: Optional[int] = None,\n    rounded: bool = False,\n    style: Optional[dict[str, Any]] = None,\n) -> Html:\n    \"\"\"Render an image as HTML.\n\n    **Examples.**\n\n    ```python3\n    # Render an image from a local file\n    mo.image(src=\"path/to/image.png\")\n    ```\n\n    ```python3\n    # Render an image from a URL\n    mo.image(\n        src=\"https://marimo.io/logo.png\",\n        alt=\"Marimo logo\",\n        width=100,\n        height=100,\n        rounded=True,\n    )\n   "]}, "marimo-marimo/_plugins/stateless/flex.py-hstack": {"response": ["```python\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Literal, Optional\n\nfrom marimo._output.builder import h\nfrom marimo._output.formatting import as_html\nfrom marimo._output.hypertext import Html\nfrom marimo._output.rich_help import mddoc\nfrom marimo._output.utils import create_style\n\nif TYPE_CHECKING:\n    from collections.abc import Sequence\n\n\n@mddoc\ndef hstack(\n    items: Sequence[object],\n    *,\n    justify: Literal[\n        \"start\", \"center\", \"end\", \"space-between\", \"space-around\"\n    ] = \"start\",\n    align: Optional[Literal[\"start\", \"end\", \"center\", \"stretch\"]] = None,\n    wrap: bool = False,\n    gap: float = 0.5,\n    widths: Optional[Literal[\"equal\"] | Sequence[float]] = None,\n) -> Html:\n    \"\"\"Stack items horizontally, in a row.\n\n    Combine with `vstack` to build a grid.\n\n    **Example.**\n\n    ```python3\n    # Build a row of items\n    mo.hstack([mo.md(\"...\"), mo.ui.text_area()])\n    ```\n\n    ```python3\n    # Build a grid.\n    mo.hstack(\n        [\n            mo.vstack([mo.md(\"...\"), mo.ui.text_area()]),\n            mo.vstack([mo.ui.checkbox(), mo.ui.text(), mo.ui.date()]),\n        ]\n    )\n    ```\n\n    **Args.**\n\n    - `items`: A list of items.\n    - `justify`: Justify items horizontally: start, center, end,\n        space-between, or space-around.\n    - `align`: Align items vertically: start, end, center, or stretch.\n    - `wrap`: Wrap items or not.\n    - `gap`: Gap between items as a float in rem. 1rem is 16px by default.\n    - `widths`: \"equal\" to give items equal width; or a list of relative widths\n      with same length as `items`, eg, [1, 2] means the second item is twice as\n      wide as the first; or `None` for a sensible default\n\n    **Returns.**\n\n    - An `Html` object.\n    \"\"\"\n    return _flex(\n        items,\n        direction=\"row\",\n        justify=justify,\n        align=align,\n        wrap=wrap,\n        gap=gap,\n        child_flexes=[1 for _ in range(len(items))]\n        if widths == \"equal\"\n        else widths,\n    )\n```"]}, "marimo-marimo/_plugins/stateless/status/_progress.py-update_progress": {"response": ["```python\ndef update_progress(\n    self,\n    increment: int = 1,\n    title: str | None = None,\n    subtitle: str | None = None,\n) -> None:\n    \"\"\"Update the progress indicator.\n\n    **Example.**\n\n    ```python\n    # Increment by 1\n    progress.update()\n\n    # Increment by 10 and update title and subtitle\n    progress.update(10, title=\"Loading\", subtitle=\"Still going...\")\n    ```\n\n    **Args.**\n\n    - increment: amount to increment by. Defaults to 1.\n    - title: new title. Defaults to None.\n    - subtitle: new subtitle. Defaults to None.\n    \"\"\"\n    if self.closed:\n        raise RuntimeError(\n            \"Progress indicators cannot be updated after exiting \"\n            \"the context manager that created them. \"\n        )\n\n    self.current += increment\n\n    if title is not None:\n        self.title = title\n    if subtitle is not None:\n        self.subtitle = subtitle\n\n    self._update_text()\n    self.debounced_flush()\n\ndef _update_text(self) -> None:\n    self._text = self._get_text()\n    output.update(self)\n```"]}, "marimo-marimo/_plugins/core/web_component.py-build_ui_plugin": {"response": ["```python\ndef build_ui_plugin(\n    component_name: str,\n    initial_value: JSONType,\n    label: str,\n    args: dict[str, JSONType],\n    slotted_html: str = \"\",\n) -> str:\n    \"\"\"\n    Build HTML for a UI (stateful) plugin.\n\n    Args:\n    ----\n    component_name: tag name of the component\n    initial_value: JSON-serializable initial value of the component\n    label: markdown string that component may use as a text label\n    args: mapping from arg names to JSON-serializable value\n    slotted_html: HTML to slot in the component\n\n    Returns:\n    -------\n    HTML text for the component\n    \"\"\"\n    # Add the initial value to the args dictionary\n    args[\"initial_value\"] = initial_value\n    \n    # Convert the label to HTML\n    label_html = md(label)\n    \n    # Build the attributes for the component\n    attrs = [_build_attr(name, value) for name, value in args.items()]\n    \n    # Construct the final HTML string\n    return (\n        f\"<{component_name} {' '.join(attrs)}>\"\n        f\"{label_html}\"\n        f\"{slotted_html}\"\n        f\"</{component_name}>\"\n    )\n```"]}, "marimo-marimo/_output/formatting.py-as_html": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom marimo._output.formatting import try_format\nfrom marimo._output.hypertext import Html\nfrom marimo._output.rich_help import mddoc\n\n@mddoc\ndef as_html(value: object) -> Html:\n    \"\"\"Convert a value to HTML that can be embedded into markdown\n\n    This function returns an `Html` object representing `value`. Use it to\n    embed values into Markdown or other HTML strings.\n\n    **Example.**\n\n    ```python3\n    import matplotlib.pyplot as plt\n    plt.plot([1, 2])\n    axis = plt.gca()\n    mo.md(\n        f\\\"\\\"\\\"\n        Here is a plot:\n\n        {mo.as_html(axis)}\n        \\\"\\\"\\\"\n    )\n    ```\n\n    **Args.**\n\n    - `value`: An object\n\n    **Returns.**\n\n    - An `Html` object\n    \"\"\"\n    formatted_output = try_format(value)\n    return Html(formatted_output.data)\n```"]}, "marimo-marimo/_output/md.py-md": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nfrom inspect import cleandoc\n\nimport markdown  # type: ignore\n\nfrom marimo._output.hypertext import Html\nfrom marimo._output.md_extensions.external_links import ExternalLinksExtension\nfrom marimo._output.rich_help import mddoc\n\nextension_configs = {\n    \"pymdownx.arithmatex\": {\n        # Use \"generic\" mode, no preview, since we don't use MathJax\n        \"preview\": False,\n        \"generic\": True,\n        # The default \"\\\\(\" causes problems when passing\n        # html-escaped `md` output back into `md`\n        \"tex_inline_wrap\": [\"||(\", \"||)\"],\n        \"tex_block_wrap\": [\"||[\", \"||]\"],\n        # Wrap latex in a custom element\n        \"block_tag\": \"marimo-tex\",\n        \"inline_tag\": \"marimo-tex\",\n    },\n    \"pymdownx.superfences\": {\n        \"disable_indented_code_blocks\": True,\n        \"css_class\": \"codehilite\",\n    },\n    \"footnotes\": {\n        \"UNIQUE_IDS\": True,\n    },\n}\n\n\ndef _md(text: str, apply_markdown_class: bool = True) -> Html:\n    # cleandoc uniformly strips leading whitespace; useful for\n    # indented multiline strings\n    text = cleandoc(text)\n    # markdown.markdown appends a newline, hence strip\n    html_text = markdown.markdown(\n        text,\n        extensions=[\n            # Syntax highlighting\n            \"codehilite\",\n            # Markdown tables\n            \"tables\",\n            # LaTeX\n            \"pymdownx.arithmatex\",\n            # Subscripts and strikethrough\n            \"pymdownx.tilde\",\n            # Better code blocks\n            \"pymdownx.superfences\",\n            # Table of contents\n            # This adds ids to the HTML headers\n            \"toc\",\n            # Footnotes\n            \"footnotes\",\n            # Admonitions\n            \"admonition\",\n            # Links\n            ExternalLinksExtension(),\n        ],\n        extension_configs=extension_configs,  # type: ignore[arg-type]\n    ).strip()\n    # replace <p> tags with <span> as HTML doesn't allow nested <div>s in <p>s\n    html_text = html_text.replace(\"<p>\", '<span class=\"paragraph\">').replace(\n        \"</p>\", \"</span>\"\n    )\n\n    if apply_markdown_class:\n        return Html('<span class=\"markdown\">' + html_text + \"</span>\")\n    else:\n        return Html(html_text)\n\n\n@mddoc\ndef md(text: str) -> Html:\n    r\"\"\"Write markdown\n\n    This function takes a string of markdown as input and returns an Html\n    object. Output the object as the last expression of a cell to render\n    the markdown in your app.\n\n    **Interpolation.**\n\n    You can interpolate Python values into your markdown strings, for example\n    using f-strings. Html objects and UI elements can be directly interpolated.\n    For example:\n\n    ```python3\n    text_input = mo.ui.text()\n    md(f\"Enter some text: {text_input}\")\n    ```\n\n    For other objects, like plots, use marimo's `as_html` method to embed\n    them in markdown:\n\n    ```python3\n    import matplotlib.pyplot as plt\n\n    plt.plot([1, 2])\n    axis = plt.gca()\n    md(f\"Here's a plot: {mo.as_html(axis)}\")\n    ```\n\n    **LaTeX.**\n\n    Enclose LaTeX in single '\\$' signs for inline math, and double '\\$\\$' for\n    display math or square brackets for display math. (Use raw strings,\n    prefixed with an \"r\", to use single backslashes.) For example:\n\n    ```python3\n    mo.md(\n        r'''\n        The exponential function $f(x) = e^x$ can be represented as\n\n        \\[\n            f(x) = 1 + x + \\frac{x^2}{2!} + \\frac{x^3}{3!} + \\ldots.\n        \\]\n        '''\n    )\n   "]}, "marimo-marimo/_output/formatters/formatters.py-register_formatters": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nimport sys\nfrom typing import Any, Callable\n\nfrom marimo._output.formatters.formatter_factory import FormatterFactory\nfrom marimo._output.formatters.formatters import (\n    NATIVE_FACTORIES,\n    THIRD_PARTY_FACTORIES,\n)\n\ndef register_formatters() -> None:\n    \"\"\"Register formatters with marimo.\n\n    marimo comes packaged with rich formatters for a number of third-party\n    libraries. This function hooks into Python's import system to register\n    these formatters with the kernel if and when a supported third-party\n    library is imported into a marimo notebook.\n\n    Hooking into the import system is more complicated than the alternative\n    of checking whether a package is installed (by importing it) and then\n    registering its formatters at kernel start-up. However, because some\n    packages imports take a long time, this alternative would add considerable\n    delay at program start-up, as the kernel would block as it registered\n    all formatters before running the notebook. Hooking into the import\n    system makes formatter registration completely lazy, improving\n    UX at the cost of increased complexity that we have to maintain. In this\n    case, the trade-off is worth it.\n    \"\"\"\n    # Register native formatters that don't require third-party libraries\n    for factory in NATIVE_FACTORIES:\n        factory.register()\n\n    # Register third-party formatters lazily\n    def register_third_party_formatter(module_name: str) -> None:\n        if module_name in sys.modules:\n            formatter_factory = THIRD_PARTY_FACTORIES.get(module_name)\n            if formatter_factory:\n                formatter_factory.register()\n\n    # Hook into the import system to register formatters lazily\n    original_import = __import__\n\n    def lazy_import(name: str, *args: Any, **kwargs: Any) -> Any:\n        module = original_import(name, *args, **kwargs)\n        register_third_party_formatter(name)\n        return module\n\n    sys.meta_path.append(type('LazyImportHook', (), {'find_module': lambda self, fullname, path=None: self if fullname in THIRD_PARTY_FACTORIES else None, 'load_module': lambda self, fullname: lazy_import(fullname)})())\n\n    # Register formatters for already imported modules\n    for module_name in THIRD_PARTY_FACTORIES:\n        if module_name in sys.modules:\n            register_third_party_formatter(module_name)\n```"]}, "marimo-marimo/_data/series.py-get_category_series_info": {"response": ["```python\ndef get_category_series_info(series: Any) -> CategorySeriesInfo:\n    \"\"\"\n    Get the summary of a categorical series.\n    \"\"\"\n\n    def validate_category(value: Any) -> list[str]:\n        if not isinstance(value, list):\n            raise ValueError(\"Expected a list of categories. Got: \" + str(type(value)))\n        return value\n\n    if DependencyManager.has_pandas():\n        import pandas as pd\n\n        if isinstance(series, pd.Series):\n            return CategorySeriesInfo(\n                categories=validate_category(series.unique().tolist()),\n                label=_get_name(series),\n            )\n\n    if DependencyManager.has_polars():\n        import polars as pl\n\n        if isinstance(series, pl.Series):\n            return CategorySeriesInfo(\n                categories=validate_category(series.unique().to_list()),\n                label=_get_name(series),\n            )\n\n    raise ValueError(\"Unsupported series type. Expected pandas or polars.\")\n```"]}, "marimo-marimo/_data/preview_column.py-get_column_preview": {"response": ["```python\n# Copyright 2024 Marimo. All rights reserved.\nfrom __future__ import annotations\n\nfrom typing import Any, Optional\n\nfrom marimo import _loggers\nfrom marimo._data.charts import get_chart_builder\nfrom marimo._data.models import ColumnSummary\nfrom marimo._dependencies.dependencies import DependencyManager\nfrom marimo._messaging.ops import DataColumnPreview\nfrom marimo._plugins.ui._impl.tables.table_manager import TableManager\nfrom marimo._plugins.ui._impl.tables.utils import get_table_manager_or_none\nfrom marimo._runtime.requests import PreviewDatasetColumnRequest\n\nLOGGER = _loggers.marimo_logger()\n\n\ndef get_column_preview(\n    request: PreviewDatasetColumnRequest,\n) -> DataColumnPreview:\n    \"\"\"\n    Get a preview of the column in the dataset.\n\n    This may return a chart and an aggregation summary of the column.\n    \"\"\"\n    table = get_table_manager_or_none(request.table_name)\n    if table is None:\n        LOGGER.error(\n            \"Failed to get table manager for table %s\",\n            request.table_name,\n        )\n        return DataColumnPreview(\n            column_name=request.column_name,\n            summary=None,\n            chart_json=None,\n            chart_code=None,\n            chart_max_rows_errors=False,\n        )\n\n    summary = _get_column_summary(table, request.column_name)\n    chart_json, chart_code, chart_max_rows_errors = _get_altair_chart(\n        request, table, summary\n    )\n\n    return DataColumnPreview(\n        column_name=request.column_name,\n        summary=summary,\n        chart_json=chart_json,\n        chart_code=chart_code,\n        chart_max_rows_errors=chart_max_rows_errors,\n    )\n\n\ndef _get_column_summary(\n    table: TableManager[Any], column_name: str\n) -> ColumnSummary:\n    column_data = table.select_columns([column_name]).data\n    summary = ColumnSummary()\n\n    if column_data is not None:\n        summary.total = len(column_data)\n        summary.nulls = column_data.isnull().sum()\n        summary.unique = column_data.nunique()\n\n        if table.get_field_types()[column_name][0] in [\"number\", \"integer\"]:\n            summary.min = column_data.min()\n            summary.max = column_data.max()\n            summary.mean = column_data.mean()\n            summary.median = column_data.median()\n            summary.std = column_data.std()\n            summary.p5 = column_data.quantile(0.05)\n            summary.p25 = column_data.quantile(0.25)\n            summary.p75 = column_data.quantile(0.75)\n            summary.p95 = column_data.quantile(0.95)\n        elif table.get_field_types()[column_name][0] == \"boolean\":\n            summary.true = column_data.sum()\n            summary.false = summary.total - summary.true\n\n    return summary\n\n\ndef _get_altair_chart(\n    request: PreviewDatasetColumnRequest,\n    table: TableManager[Any],\n    summary: ColumnSummary,\n) -> tuple[Optional[str], Optional[str], bool]:\n    # We require altair to render the chart\n    if not DependencyManager.has_altair() or not table.supports_altair():\n        return None, None, False\n\n    import altair as alt  # type: ignore[import-not-found,import-untyped,unused-ignore] # noqa: E501\n    from altair import (  # type: ignore[import-not-found,import-untyped,unused-ignore] # noqa: E501\n        MaxRowsError,\n    )\n\n    (column_type, _external_type) = table.get_field_types()[\n        request.column_name\n    ]\n\n    # For categorical columns with more than 10 unique values,\n    # we limit the chart to 10 items\n    should_limit_to_10_items = False"]}, "marimo-marimo/_server/sessions.py-start_file_watcher": {"response": ["```python\ndef start_file_watcher(self) -> Disposable:\n    \"\"\"Starts the file watcher if it is not already started\"\"\"\n    if self.watcher is None:\n        self.watcher = FileWatcher(self.file_router.directory)\n        self.watcher.start()\n    return Disposable(self.watcher.stop)\n```"]}, "marimo-marimo/_server/file_manager.py-save_app_config": {"response": ["```python\ndef save_app_config(self, config: Dict[str, Any]) -> str:\n    \"\"\"Save the app configuration.\"\"\"\n    self.app.update_config(config)\n    return self._save_file(\n        self.filename,\n        list(self.app.cell_manager.codes()),\n        list(self.app.cell_manager.names()),\n        list(self.app.cell_manager.configs()),\n        self.app.config,\n        persist=True,\n    )\n```"]}, "marimo-marimo/_server/session/session_view.py-add_stdin": {"response": ["```python\ndef add_stdin(self, stdin: str) -> None:\n    \"\"\"Add a stdin request to the session view.\"\"\"\n    # Assuming we need to store the stdin request somewhere in the session view.\n    # For now, let's store it in a new attribute called `stdin_requests`.\n    if not hasattr(self, 'stdin_requests'):\n        self.stdin_requests = []\n    self.stdin_requests.append(stdin)\n```"]}, "marimo-marimo/_server/session/session_view.py-add_operation": {"response": ["```python\ndef add_operation(self, operation: MessageOperation) -> None:\n    \"\"\"Add an operation to the session view.\"\"\"\n    if isinstance(operation, CellOp):\n        cell_id = operation.cell_id\n        previous_op = self.cell_operations.get(cell_id)\n        merged_op = merge_cell_operation(previous_op, operation)\n        self.cell_operations[cell_id] = merged_op\n        self.save_execution_time(operation, \"start\")\n        self.save_execution_time(operation, \"end\")\n    elif isinstance(operation, Datasets):\n        self.datasets = operation\n    elif isinstance(operation, Variables):\n        self.variable_operations = operation\n    elif isinstance(operation, VariableValues):\n        self.variable_values = {var.name: var for var in operation.variables}\n```"]}, "marimo-marimo/_server/session/session_view.py-get_cell_console_outputs": {"response": ["```python\ndef get_cell_console_outputs(\n    self, ids: list[CellId_t]\n) -> dict[CellId_t, list[CellOutput]]:\n    \"\"\"Get the console outputs for the given cell ids.\"\"\"\n    console_outputs: dict[CellId_t, list[CellOutput]] = {}\n    for cell_id in ids:\n        cell_op = self.cell_operations.get(cell_id)\n        if cell_op is not None and cell_op.console is not None:\n            console_outputs[cell_id] = cell_op.console\n    return console_outputs\n```"]}, "marimo-marimo/_runtime/dataflow.py-register_cell": {"response": ["```python\ndef register_cell(self, cell_id: CellId_t, cell: CellImpl) -> None:\n    \"\"\"Add a cell to the graph.\n\n    Mutates the graph, acquiring `self.lock`.\n\n    Requires that `cell_id` is not already in the graph.\n    \"\"\"\n    with self.lock:\n        if cell_id in self.cells:\n            raise ValueError(f\"Cell {cell_id} is already in the graph.\")\n\n        self.cells[cell_id] = cell\n        self.children[cell_id] = set()\n        self.parents[cell_id] = set()\n        self.siblings[cell_id] = set()\n\n        for name in cell.defs:\n            if name in self.definitions:\n                self.siblings[cell_id].update(self.definitions[name])\n                for sibling in self.definitions[name]:\n                    self.siblings[sibling].add(cell_id)\n            self.definitions[name] = self.definitions.get(name, set()) | {cell_id}\n\n        for name in cell.refs:\n            if name in self.definitions:\n                for definer in self.definitions[name]:\n                    self.children[definer].add(cell_id)\n                    self.parents[cell_id].add(definer)\n\n        self._detect_cycles()\n\n    def _detect_cycles(self) -> None:\n        \"\"\"Detect cycles in the graph and update the `cycles` attribute.\"\"\"\n        visited = set()\n        stack = []\n        cycles = []\n\n        def visit(node: CellId_t) -> None:\n            if node in visited:\n                return\n            visited.add(node)\n            stack.append(node)\n            for child in self.children[node]:\n                if child in stack:\n                    cycle = stack[stack.index(child):] + [child]\n                    cycles.append(tuple(zip(cycle[:-1], cycle[1:])))\n                else:\n                    visit(child)\n            stack.pop()\n\n        for node in self.cells:\n            visit(node)\n\n        self.cycles = set(cycles)\n```"]}, "marimo-marimo/_runtime/validate_graph.py-check_for_errors": {"response": ["```python\ndef check_for_errors(graph: dataflow.DirectedGraph) -> dict[CellId_t, list[Error]]:\n    \"\"\"\n    Check graph for violations of marimo semantics.\n\n    Return a dict of errors in the graph, with an entry for each cell\n    that is involved in an error.\n    \"\"\"\n    multiple_definition_errors = check_for_multiple_definitions(graph)\n    delete_nonlocal_errors = check_for_delete_nonlocal(graph)\n    cycle_errors = check_for_cycles(graph)\n\n    all_errors: dict[CellId_t, list[Error]] = {}\n    for errors in [multiple_definition_errors, delete_nonlocal_errors, cycle_errors]:\n        for cell_id, cell_errors in errors.items():\n            if cell_id not in all_errors:\n                all_errors[cell_id] = []\n            all_errors[cell_id].extend(cell_errors)\n\n    return all_errors\n```"]}, "marimo-marimo/_runtime/runtime.py-_maybe_register_cell": {"response": ["```python\ndef _maybe_register_cell(\n    self,\n    cell_id: CellId_t,\n    code: str,\n) -> tuple[set[CellId_t], Optional[Error]]:\n    \"\"\"Register a cell (given by id, code) if not already registered.\n\n    If a cell with id `cell_id` is already registered but with different\n    code, that cell is deleted from the graph and a new cell with the\n    same id but different code is registered.\n\n    Returns:\n    - a set of ids for cells that were previously children of `cell_id`;\n      only non-empty when `cell-id` was already registered but with\n      different code.\n    - an `Error` if the cell couldn't be registered, `None` otherwise\n    \"\"\"\n    old_children: set[CellId_t] = set()\n    error: Optional[Error] = None\n\n    if self.graph.is_cell_cached(cell_id, code):\n        # Cell is already registered with the same code\n        return old_children, error\n\n    if cell_id in self.graph.cells:\n        # Cell is already registered with different code, delete it\n        old_children = self.graph.delete_cell(cell_id)\n\n    # Try to register the cell\n    error = self._try_registering_cell(cell_id, code)\n\n    return old_children, error\n```"]}, "marimo-marimo/_runtime/runtime.py-run": {"response": ["```python\nasync def run(self, execution_requests: Sequence[ExecutionRequest]) -> None:\n    \"\"\"Run cells and their descendants.\n\n    The cells may be cells already existing in the graph or new cells.\n    Adds the cells in `execution_requests` to the graph before running\n    them.\n\n    Cells may use top-level await, which is why this function is async.\n    \"\"\"\n    cells_to_run = self.mutate_graph(\n        execution_requests=execution_requests, deletion_requests=[]\n    )\n    await self._run_cells(cells_to_run)\n```"]}, "marimo-marimo/_runtime/packages/utils.py-is_python_isolated": {"response": ["```python\ndef is_python_isolated() -> bool:\n    \"\"\"Returns True if not using system Python\"\"\"\n    return in_virtual_environment() or in_conda_env()\n```"]}, "marimo-marimo/_runtime/packages/module_registry.py-missing_modules": {"response": ["```python\ndef missing_modules(self) -> set[str]:\n    \"\"\"Modules that will fail to import.\"\"\"\n    installed_modules = {\n        module_name\n        for module_name in self.modules()\n        if _is_module_installed(module_name)\n    }\n    return self.modules() - installed_modules - self.excluded_modules\n```"]}, "TaskWeaver-taskweaver/misc/example.py-load_examples": {"response": ["```python\ndef load_examples(folder: str, role_set: Optional[Set[str]] = None) -> List[Conversation]:\n    \"\"\"\n    Load all the examples from a folder.\n\n    Args:\n        folder: the folder path.\n        role_set: the roles should be included in the examples.\n    \"\"\"\n    examples = []\n    for file_path in glob.glob(path.join(folder, \"*.json\")):\n        try:\n            conversation = Conversation.from_json(file_path)\n            if role_set is None or all(role in role_set for role in conversation.roles):\n                examples.append(conversation)\n        except Exception as e:\n            print(f\"Failed to load example from {file_path}: {e}\")\n    return examples\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-add_selected_plugins": {"response": ["```python\ndef add_selected_plugins(self, external_plugin_pool: List[PluginEntry]):\n    \"\"\"\n    Add selected plugins to the pool\n    \"\"\"\n    self.selected_plugin_pool = self.merge_plugin_pool(self.selected_plugin_pool, external_plugin_pool)\n```"]}, "TaskWeaver-taskweaver/code_interpreter/plugin_selection.py-filter_unused_plugins": {"response": ["```python\ndef filter_unused_plugins(self, code: str):\n    \"\"\"\n    Filter out plugins that are not used in the code generated by LLM\n    \"\"\"\n    used_plugins = set()\n    for plugin in self.plugin_registry.get_list():\n        if f\"import {plugin.name}\" in code or f\"from {plugin.name}\" in code:\n            used_plugins.add(plugin.name)\n    \n    self.selected_plugin_pool = [plugin for plugin in self.selected_plugin_pool if plugin.name in used_plugins]\n```"]}, "TaskWeaver-taskweaver/module/prompt_util.py-remove_all_delimiters": {"response": ["```python\ndef remove_all_delimiters(text: str) -> str:\n    \"\"\"Remove all the delimiters from the text.\"\"\"\n    delimiters = PromptUtil.get_all_delimiters()\n    for delimiter in delimiters:\n        text = PromptUtil.remove_delimiter(text, delimiter)\n    return text\n```"]}, "reflex-reflex/app.py-_enable_state": {"response": ["```python\ndef _enable_state(self) -> None:\n    \"\"\"Enable state for the app.\"\"\"\n    pass\n```"]}, "reflex-reflex/app.py-_add_optional_endpoints": {"response": ["```python\n    def _add_optional_endpoints(self):\n        \"\"\"Add optional api endpoints (_upload).\"\"\"\n        from reflex.app import upload\n\n        self.api.post(str(constants.Endpoint.UPLOAD))(upload(self))\n```"]}, "reflex-reflex/app.py-add_page": {"response": ["```python\ndef add_page(\n    self,\n    component: Union[Component, ComponentCallable],\n    route: Optional[str] = None,\n    title: str = constants.DefaultPage.TITLE,\n    description: str = constants.DefaultPage.DESCRIPTION,\n    image: str = constants.DefaultPage.IMAGE,\n    on_load: Optional[Union[EventHandler, EventSpec, List[Union[EventHandler, EventSpec]]]] = None,\n    meta: List[Dict[str, str]] = constants.DefaultPage.META_LIST,\n):\n    \"\"\"Add a page to the app.\n\n    If the component is a callable, by default the route is the name of the\n    function. Otherwise, a route must be provided.\n\n    Args:\n        component: The component to display at the page.\n        route: The route to display the component at.\n        title: The title of the page.\n        description: The description of the page.\n        image: The image to display on the page.\n        on_load: The event handler(s) that will be called each time the page load.\n        meta: The metadata of the page.\n\n    Raises:\n        ValueError: When the specified route name already exists.\n    \"\"\"\n    # If the component is a callable, use the function name as the route.\n    if callable(component) and route is None:\n        route = component.__name__\n\n    # Ensure the route is provided.\n    if route is None:\n        raise ValueError(\"A route must be provided if the component is not a callable.\")\n\n    # Verify if the route already exists.\n    if route in self.pages:\n        raise ValueError(f\"The route '{route}' already exists.\")\n\n    # Generate the component if it's a callable.\n    component = self._generate_component(component)\n\n    # Add the page to the app.\n    self.pages[route] = component\n\n    # Add the load events for the page.\n    if on_load:\n        if not isinstance(on_load, list):\n            on_load = [on_load]\n        self.load_events[route] = on_load\n\n    # Add the page metadata.\n    self.pages[route].title = title\n    self.pages[route].description = description\n    self.pages[route].image = image\n    self.pages[route].meta = meta\n```"]}, "reflex-reflex/app.py-_setup_overlay_component": {"response": ["```python\ndef _setup_overlay_component(self):\n    \"\"\"If a State is not used and no overlay_component is specified, do not render the connection modal.\"\"\"\n    if not self.state and not self.overlay_component:\n        self.overlay_component = None\n```"]}, "reflex-reflex/app.py-_compile": {"response": ["```python\ndef _compile(self, export: bool = False):\n    \"\"\"Compile the app and output it to the pages folder.\n\n    Args:\n        export: Whether to compile the app for export.\n\n    Raises:\n        ReflexRuntimeError: When any page uses state, but no rx.State subclass is defined.\n    \"\"\"\n    # Implementation of the compile method goes here\n    pass\n```"]}, "reflex-reflex/app.py-modify_state": {"response": ["```python\nasync def modify_state(self, token: str) -> AsyncIterator[BaseState]:\n    \"\"\"Modify the state out of band.\n\n    Args:\n        token: The token to modify the state for.\n\n    Yields:\n        The state to modify.\n\n    Raises:\n        RuntimeError: If the app has not been initialized yet.\n    \"\"\"\n    if self.event_namespace is None:\n        raise RuntimeError(\"App has not been initialized yet.\")\n\n    async with self.state_manager.modify_state(token) as state:\n        yield state\n```"]}, "reflex-reflex/vars.py-create": {"response": ["```python\ndef create(\n    value: Any,\n    _var_is_local: bool = False,\n    _var_is_string: bool = False,\n    _var_data: Optional[VarData] = None,\n) -> Var:\n    \"\"\"Create a var from a value.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n\n    Raises:\n        VarTypeError: If the value is JSON-unserializable.\n    \"\"\"\n    from reflex.utils.exceptions import VarTypeError\n\n    try:\n        if isinstance(value, Var):\n            return value._replace(\n                _var_is_local=_var_is_local,\n                _var_is_string=_var_is_string,\n                merge_var_data=_var_data,\n            )\n        if isinstance(value, Base):\n            value = value.json()\n        if isinstance(value, str):\n            _var_is_string = True\n        if isinstance(value, (int, float, bool, type(None))):\n            value = json.dumps(value)\n        if isinstance(value, list):\n            value = json.dumps(value)\n        if isinstance(value, dict):\n            value = json.dumps(value)\n        return BaseVar(\n            _var_name=value,\n            _var_type=type(value),\n            _var_is_local=_var_is_local,\n            _var_is_string=_var_is_string,\n            _var_data=_var_data,\n        )\n    except TypeError as e:\n        raise VarTypeError(f\"Value {value} is not JSON-serializable.\") from e\n```"]}, "reflex-reflex/vars.py-create_safe": {"response": ["```python\ndef create_safe(\n    value: Any,\n    _var_is_local: bool = False,\n    _var_is_string: bool = False,\n    _var_data: Optional[VarData] = None,\n) -> Var:\n    \"\"\"Create a var from a value, asserting that it is not None.\n\n    Args:\n        value: The value to create the var from.\n        _var_is_local: Whether the var is local.\n        _var_is_string: Whether the var is a string literal.\n        _var_data: Additional hooks and imports associated with the Var.\n\n    Returns:\n        The var.\n    \"\"\"\n    if value is None:\n        raise ValueError(\"Value cannot be None\")\n    return Var.create(value, _var_is_local=_var_is_local, _var_is_string=_var_is_string, _var_data=_var_data)\n```"]}, "reflex-reflex/vars.py-foreach": {"response": ["```python\ndef foreach(self, fn: Callable) -> Var:\n    \"\"\"Return a list of components after doing a foreach on this var.\n\n    Args:\n        fn: The function to call on each component.\n\n    Returns:\n        A var representing foreach operation.\n\n    Raises:\n        VarTypeError: If the var is not a list.\n    \"\"\"\n    from reflex.utils.exceptions import VarTypeError\n\n    if not types._issubclass(self._var_type, List):\n        raise VarTypeError(f\"Cannot perform foreach on non-list var {self}.\")\n\n    return self._replace(\n        _var_name=f\"{self._var_name}.map({fn.__name__})\",\n        _var_type=List[fn.__annotations__[\"return\"]],\n        _var_is_string=False,\n        _var_full_name_needs_state_prefix=False,\n    )\n```"]}, "reflex-reflex/vars.py-get_default_value": {"response": ["```python\n    def get_default_value(self) -> Any:\n        \"\"\"Get the default value of the var.\n\n        Returns:\n            The default value of the var.\n\n        Raises:\n            ImportError: If the var is a dataframe and pandas is not installed.\n        \"\"\"\n        try:\n            import pandas as pd\n            if isinstance(self, pd.DataFrame):\n                return pd.DataFrame()\n        except ImportError:\n            raise ImportError(\"Pandas is required to use DataFrames in Reflex.\")\n        return None\n```"]}, "reflex-reflex/state.py-get_skip_vars": {"response": ["```python\n    @classmethod\n    def get_skip_vars(cls) -> set[str]:\n        \"\"\"Get the vars to skip when serializing.\n\n        Returns:\n            The vars to skip when serializing.\n        \"\"\"\n        return {\"_non_default_attributes\"}\n```"]}, "reflex-reflex/state.py-add_var": {"response": ["```python\ndef add_var(cls, name: str, type_: Any, default_value: Any = None):\n    \"\"\"Add dynamically a variable to the State.\n\n    The variable added this way can be used in the same way as a variable\n    defined statically in the model.\n\n    Args:\n        name: The name of the variable\n        type_: The type of the variable\n        default_value: The default value of the variable\n\n    Raises:\n        NameError: if a variable of this name already exists\n    \"\"\"\n    if name in cls.vars:\n        raise NameError(f\"A variable with the name {name} already exists.\")\n\n    # Create a new BaseVar instance\n    new_var = BaseVar(_var_name=name, _var_type=type_)._var_set_state(cls)\n\n    # Add the new variable to the class's vars dictionary\n    cls.vars[name] = new_var\n\n    # Add the new variable to the class's base_vars dictionary\n    cls.base_vars[name] = new_var\n\n    # Add the new variable to the class's __annotations__\n    cls.__annotations__[name] = type_\n\n    # Add the new variable to the class's __fields__\n    cls.__fields__[name] = pydantic.fields.ModelField.infer(\n        name=name,\n        value=default_value,\n        annotation=type_,\n        class_validators=None,\n        config=cls.__config__,\n    )\n\n    # Set the default value for the variable\n    if default_value is not None:\n        cls.__fields__[name].default = default_value\n\n    # Create a setter for the new variable\n    cls._create_setter(new_var)\n\n    # Set the default value for the new variable\n    cls._set_default_value(new_var)\n```"]}, "reflex-reflex/state.py-reset": {"response": ["```python\ndef reset(self):\n    \"\"\"Reset all the base vars to their default values.\"\"\"\n    for key, value in self.__fields__.items():\n        if key in self._non_default_attributes:\n            setattr(self, key, value.default)\n    self._non_default_attributes.clear()\n```"]}, "reflex-reflex/state.py-get_state": {"response": ["```python\nasync def get_state(self, state_cls: Type[BaseState]) -> BaseState:\n    \"\"\"Get an instance of the state associated with this token.\n\n    Allows for arbitrary access to sibling states from within an event handler.\n\n    Args:\n        state_cls: The class of the state.\n\n    Returns:\n        The instance of state_cls associated with this state's client_token.\n    \"\"\"\n    # Check if the state is already cached in the current instance.\n    if state_cls.get_full_name() in self.substates:\n        return self.substates[state_cls.get_full_name()]\n\n    # If the state is not cached, fetch it from the state manager.\n    state_manager = get_state_manager()\n    token = self.router.session.client_token\n    state = await state_manager.get_state(token=_substate_key(token, state_cls))\n\n    # Cache the fetched state in the current instance.\n    self.substates[state_cls.get_full_name()] = state\n\n    return state\n```"]}, "reflex-reflex/state.py-_process": {"response": ["```python\nasync def _process(self, event: Event) -> AsyncIterator[StateUpdate]:\n    \"\"\"Obtain event info and process event.\n\n    Args:\n        event: The event to process.\n\n    Yields:\n        The state update after processing the event.\n    \"\"\"\n    # Obtain event info and process event logic here\n    # This is a placeholder implementation\n    yield StateUpdate(delta={}, events=[], final=True)\n```"]}, "reflex-reflex/state.py-_dirty_computed_vars": {"response": ["```python\n    def _dirty_computed_vars(\n        self,\n        from_vars: Optional[Set[str]] = None,\n        include_backend: bool = False,\n    ) -> Set[str]:\n        \"\"\"Determine ComputedVars that need to be recalculated based on the given vars.\n\n        Args:\n            from_vars: find ComputedVar that depend on this set of vars. If unspecified, will use the dirty_vars.\n            include_backend: whether to include backend vars in the calculation.\n\n        Returns:\n            Set of computed vars to include in the delta.\n        \"\"\"\n        dirty_vars = from_vars or self.dirty_vars\n        computed_vars = set()\n\n        for var in dirty_vars:\n            if var in self._computed_var_dependencies:\n                computed_vars.update(self._computed_var_dependencies[var])\n\n        if include_backend:\n            computed_vars.update(self._always_dirty_computed_vars)\n\n        return computed_vars\n```"]}, "reflex-reflex/state.py-_potentially_dirty_substates": {"response": ["```python\n@classmethod\ndef _potentially_dirty_substates(cls) -> set[Type[BaseState]]:\n    \"\"\"Determine substates which could be affected by dirty vars in this state.\n\n    Returns:\n        Set of State classes that may need to be fetched to recalc computed vars.\n    \"\"\"\n    potentially_dirty_substates = set()\n    for var, substates in cls._substate_var_dependencies.items():\n        potentially_dirty_substates.update(substates)\n    return potentially_dirty_substates\n```"]}, "reflex-reflex/state.py-get_delta": {"response": ["```python\ndef get_delta(self) -> Delta:\n    \"\"\"Get the delta for the state.\n\n    Returns:\n        The delta for the state.\n    \"\"\"\n    delta = {}\n    for var_name in self.dirty_vars:\n        if var_name in self.vars:\n            delta[var_name] = self.get_value(getattr(self, var_name))\n    return delta\n```"]}, "reflex-reflex/model.py-get_db_engine": {"response": ["```python\ndef get_db_engine():\n    \"\"\"Get the database engine.\n\n    Returns:\n        The database engine.\n    \"\"\"\n    config = get_config()\n    if config.db_url is None:\n        raise ValueError(\"db_url is not configured, cannot get database engine.\")\n    return create_engine(config.db_url)\n```"]}, "reflex-reflex/model.py-alembic_autogenerate": {"response": ["```python\ndef alembic_autogenerate(\n    connection: Any,\n    message: str,\n    write_migration_scripts: bool = True,\n) -> bool:\n    \"\"\"Generate migration scripts for alembic-detectable changes.\n\n    Args:\n        connection: SQLAlchemy connection to use when detecting changes.\n        message: Human readable identifier describing the generated revision.\n        write_migration_scripts: If True, write autogenerated revisions to script directory.\n\n    Returns:\n        True when changes have been detected.\n    \"\"\"\n    from alembic.command import revision\n    from alembic.config import Config\n    from alembic.script import ScriptDirectory\n    from alembic.autogenerate import compare_metadata\n    from alembic.runtime.environment import EnvironmentContext\n\n    # Initialize the Alembic configuration\n    config = Config()\n    config.set_main_option(\"script_location\", \"migrations\")\n    config.set_main_option(\"sqlalchemy.url\", str(connection.engine.url))\n\n    # Get the script directory\n    script = ScriptDirectory.from_config(config)\n\n    # Get the current head revision\n    head_revision = script.get_current_head()\n\n    # Create a new revision\n    with EnvironmentContext(\n        config,\n        script,\n        fn=lambda rev, context: compare_metadata(context.opts['target_metadata'], rev),\n        as_sql=False,\n        template_args={},\n        revision_context=None,\n        starting_rev=None,\n        destination_rev=head_revision,\n        tag=None,\n        sqlalchemy_module_prefix='sa.',\n        alembic_module_prefix='op.',\n        user_log_fn=None\n    ):\n        # Compare the metadata and generate the revision script\n        if write_migration_scripts:\n            revision(config, message, autogenerate=True)\n\n    # Return True if changes were detected\n    return True\n```"]}, "reflex-reflex/model.py-migrate": {"response": ["```python\n@classmethod\ndef migrate(cls, autogenerate: bool = False) -> bool | None:\n    \"\"\"Execute alembic migrations for all sqlmodel Model classes.\n\n    If alembic is not installed or has not been initialized for the project,\n    then no action is performed.\n\n    If there are no revisions currently tracked by alembic, then\n    an initial revision will be created based on sqlmodel metadata.\n\n    If models in the app have changed in incompatible ways that alembic\n    cannot automatically generate revisions for, the app may not be able to\n    start up until migration scripts have been corrected by hand.\n\n    Args:\n        autogenerate: If True, generate migration script and use it to upgrade schema\n            (otherwise, just bring the schema to current \"head\" revision).\n\n    Returns:\n        True - indicating the process was successful.\n        None - indicating the process was skipped.\n    \"\"\"\n    try:\n        from alembic import command\n        from alembic.config import Config as AlembicConfig\n    except ImportError:\n        console.warn(\"Alembic is not installed. Skipping migrations.\")\n        return None\n\n    alembic_cfg = AlembicConfig(constants.ALEMBIC_CONFIG)\n    if autogenerate:\n        command.revision(alembic_cfg, autogenerate=True, message=\"Auto-generated migration\")\n    command.upgrade(alembic_cfg, \"head\")\n    return True\n```"]}, "reflex-reflex/model.py-select": {"response": ["```python\ndef select(cls):\n    \"\"\"Select rows from the table.\n\n    Returns:\n        The select statement.\n    \"\"\"\n    pass\n```"]}, "reflex-reflex/compiler/compiler.py-compile_components": {"response": ["```python\ndef compile_components(\n    components: set[CustomComponent],\n) -> tuple[str, str]:\n    \"\"\"Compile the custom components.\n\n    Args:\n        components: The custom components to compile.\n\n    Returns:\n        The path and code of the compiled components.\n    \"\"\"\n    # Get the path for the output file.\n    output_path = utils.get_components_path()\n\n    # Compile the components.\n    code, _ = _compile_components(components)\n    return output_path, code\n```"]}, "reflex-reflex/utils/prerequisites.py-get_or_set_last_reflex_version_check_datetime": {"response": ["```python\nimport datetime\n\ndef get_or_set_last_reflex_version_check_datetime():\n    \"\"\"Get the last time a check was made for the latest reflex version.\n    This is typically useful for cases where the host reflex version is\n    less than that on Pypi.\n\n    Returns:\n        The last version check datetime.\n    \"\"\"\n    # Define the file path for storing the last check datetime\n    version_check_file = Path(constants.Reflex.DIR) / \"last_version_check.txt\"\n\n    # Check if the file exists\n    if version_check_file.exists():\n        # Read the last check datetime from the file\n        with open(version_check_file, \"r\") as f:\n            last_check_datetime = datetime.datetime.fromisoformat(f.read().strip())\n    else:\n        # If the file doesn't exist, set the current datetime as the last check datetime\n        last_check_datetime = datetime.datetime.now()\n        # Write the current datetime to the file\n        with open(version_check_file, \"w\") as f:\n            f.write(last_check_datetime.isoformat())\n\n    return last_check_datetime\n```"]}, "reflex-reflex/middleware/hydrate_middleware.py-preprocess": {"response": ["```python\nasync def preprocess(\n    self, app: App, state: BaseState, event: Event\n) -> Optional[StateUpdate]:\n    \"\"\"Preprocess the event.\n\n    Args:\n        app: The app to apply the middleware to.\n        state: The client state.\n        event: The event to preprocess.\n\n    Returns:\n        An optional delta or list of state updates to return.\n    \"\"\"\n    # Check if the event is a hydration event\n    if event == get_hydrate_event():\n        # Perform hydration logic here\n        # For example, initialize some state variables\n        state.initialize_hydration_state()\n        return StateUpdate(state)\n    return None\n```"]}, "reflex-reflex/components/component.py-get_event_triggers": {"response": ["```python\ndef get_event_triggers(self) -> Dict[str, Any]:\n    \"\"\"Get the event triggers for the component.\n\n    Returns:\n        The event triggers.\n\n    \"\"\"\n    return self.event_triggers\n```"]}, "reflex-reflex/components/component.py-get_props": {"response": ["```python\ndef get_props(cls) -> Set[str]:\n    \"\"\"Get the unique fields for the component.\n\n    Returns:\n        The unique fields.\n    \"\"\"\n    return set(cls.get_fields().keys())\n```"]}, "reflex-reflex/components/component.py-create": {"response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create the component.\n\n    Args:\n        *children: The children of the component.\n        **props: The props of the component.\n\n    Returns:\n        The component.\n    \"\"\"\n    # Initialize the component with the given children and props\n    component = cls(*children, **props)\n    \n    # Return the created component\n    return component\n```"]}, "reflex-reflex/components/component.py-_add_style_recursive": {"response": ["```python\ndef _add_style_recursive(\n    self,\n    style: dict,\n    theme: Optional[Component] = None,\n) -> Component:\n    \"\"\"Add additional style to the component and its children.\n\n    Apply order is as follows (with the latest overriding the earliest):\n    1. Default style from `_add_style`/`add_style`.\n    2. User-defined style from `App.style`.\n    3. User-defined style from `Component.style`.\n    4. style dict and css props passed to the component instance.\n\n    Args:\n        style: A dict from component to styling.\n        theme: The theme to apply. (for retro-compatibility with deprecated _apply_theme API)\n\n    Raises:\n        UserWarning: If `_add_style` has been overridden.\n\n    Returns:\n        The component with the additional style.\n    \"\"\"\n    # Check if _add_style has been overridden\n    if self._add_style.__func__ is not Component._add_style:\n        warnings.warn(\n            \"Overriding `_add_style` is deprecated. Use `add_style` instead.\",\n            UserWarning,\n        )\n\n    # Apply default style from _add_style/add_style\n    default_style = self._add_style()\n    if default_style is not None:\n        self.style.update(default_style)\n\n    # Apply user-defined style from App.style\n    component_style = self._get_component_style(style)\n    if component_style is not None:\n        self.style.update(component_style)\n\n    # Apply user-defined style from Component.style\n    if self.style:\n        self.style.update(self.style)\n\n    # Apply style dict and css props passed to the component instance\n    if hasattr(self, \"style\") and isinstance(self.style, dict):\n        self.style.update(self.style)\n\n    # Apply theme for retro-compatibility\n    if theme is not None:\n        self._apply_theme(theme)\n\n    # Recursively apply style to children\n    for child in self.children:\n        if isinstance(child, Component):\n            child._add_style_recursive(style, theme)\n\n    return self\n```"]}, "reflex-reflex/components/component.py-render": {"response": ["```python\ndef render(self) -> Dict:\n    \"\"\"Render the component.\n\n    Returns:\n        The dictionary for template of component.\n    \"\"\"\n    return {\n        \"tag\": self.tag,\n        \"props\": {\n            \"id\": self.id,\n            \"class_name\": self.class_name,\n            \"style\": self.style,\n            **self.custom_attrs,\n            **{\n                trigger: handler\n                for trigger, handler in self.event_triggers.items()\n                if trigger not in {EventTriggers.ON_MOUNT, EventTriggers.ON_UNMOUNT}\n            },\n        },\n        \"children\": [child.render() for child in self.children],\n    }\n```"]}, "reflex-reflex/components/component.py-_get_vars": {"response": ["```python\ndef _get_vars(self, include_children: bool = False) -> list[Var]:\n    \"\"\"Walk all Vars used in this component.\n\n    Args:\n        include_children: Whether to include Vars from children.\n\n    Returns:\n        Each var referenced by the component (props, styles, event handlers).\n    \"\"\"\n    vars_list = []\n\n    # Include Vars from props\n    for prop in self.props.values():\n        if isinstance(prop, Var):\n            vars_list.append(prop)\n\n    # Include Vars from style\n    if isinstance(self.style, Var):\n        vars_list.append(self.style)\n\n    # Include Vars from event triggers\n    for event_trigger in self.event_triggers.values():\n        if isinstance(event_trigger, Var):\n            vars_list.append(event_trigger)\n        elif isinstance(event_trigger, EventChain):\n            for event in event_trigger.events:\n                for arg in event.args:\n                    if isinstance(arg, Var):\n                        vars_list.append(arg)\n\n    # Include Vars from children if specified\n    if include_children:\n        for child in self.children:\n            if isinstance(child, Component):\n                vars_list.extend(child._get_vars(include_children=True))\n\n    return vars_list\n```"]}, "reflex-reflex/components/component.py-_has_stateful_event_triggers": {"response": ["```python\ndef _has_stateful_event_triggers(self):\n    \"\"\"Check if component or children have any event triggers that use state.\n\n    Returns:\n        True if the component or children have any event triggers that uses state.\n    \"\"\"\n    # Check if the current component has any event triggers that use state.\n    if self._event_trigger_values_use_state():\n        return True\n\n    # Recursively check children components for stateful event triggers.\n    for child in self.children:\n        if isinstance(child, Component) and child._has_stateful_event_triggers():\n            return True\n\n    return False\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_code": {"response": ["```python\ndef _get_all_custom_code(self) -> set[str]:\n    \"\"\"Get custom code for the component and its children.\n\n    Returns:\n        The custom code.\n    \"\"\"\n    # Initialize a set to store custom code snippets.\n    custom_code_set = set()\n\n    # Add custom code for the current component.\n    custom_code = self._get_custom_code()\n    if custom_code:\n        custom_code_set.add(custom_code)\n\n    # Recursively add custom code from children components.\n    for child in self.children:\n        custom_code_set.update(child._get_all_custom_code())\n\n    # Return the set of custom code snippets.\n    return custom_code_set\n```"]}, "reflex-reflex/components/component.py-_get_all_imports": {"response": ["```python\ndef _get_all_imports(self, collapse: bool = False) -> ParsedImportDict:\n    \"\"\"Get all the libraries and fields that are used by the component and its children.\n\n    Args:\n        collapse: Whether to collapse the imports by removing duplicates.\n\n    Returns:\n        The import dict with the required imports.\n    \"\"\"\n    # Get the imports for the current component\n    current_imports = self._get_imports()\n\n    # Initialize a set to store all imports\n    all_imports = current_imports.copy()\n\n    # Recursively get imports from children\n    for child in self.children:\n        if isinstance(child, Component):\n            child_imports = child._get_all_imports(collapse=collapse)\n            all_imports = imports.merge_imports(all_imports, child_imports)\n\n    # Collapse imports if requested\n    if collapse:\n        all_imports = imports.collapse_imports(all_imports)\n\n    return all_imports\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks_internal": {"response": ["```python\ndef _get_all_hooks_internal(self) -> dict[str, None]:\n    \"\"\"Get the reflex internal hooks for the component and its children.\n\n    Returns:\n        The code that should appear just before user-defined hooks.\n    \"\"\"\n    hooks = {}\n\n    # Get the internal hooks for this component.\n    hooks.update(self._get_hooks_internal())\n\n    # Get the internal hooks for the children.\n    for child in self.children:\n        if isinstance(child, Component):\n            hooks.update(child._get_all_hooks_internal())\n\n    return hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_hooks": {"response": ["```python\ndef _get_all_hooks(self) -> dict[str, None]:\n    \"\"\"Get the React hooks for this component and its children.\n\n    Returns:\n        The code that should appear just before returning the rendered component.\n    \"\"\"\n    # Initialize an empty dictionary to store the hooks\n    hooks = {}\n\n    # Get the hooks for the current component\n    component_hooks = self._get_hooks_internal()\n    hooks.update(component_hooks)\n\n    # Get the hooks added via `add_hooks` method\n    added_hooks = self._get_added_hooks()\n    hooks.update(added_hooks)\n\n    # Recursively get hooks from children\n    for child in self.children:\n        if isinstance(child, Component):\n            child_hooks = child._get_all_hooks()\n            hooks.update(child_hooks)\n\n    return hooks\n```"]}, "reflex-reflex/components/component.py-_get_all_custom_components": {"response": ["```python\ndef _get_all_custom_components(self, seen: set[str] | None = None) -> Set[CustomComponent]:\n    \"\"\"Get all the custom components used by the component.\n\n    Args:\n        seen: The tags of the components that have already been seen.\n\n    Returns:\n        The set of custom components.\n    \"\"\"\n    assert self.tag is not None, \"The tag must be set.\"\n\n    # Store the seen components in a set to avoid infinite recursion.\n    if seen is None:\n        seen = set()\n    custom_components = {self} | super()._get_all_custom_components(seen=seen)\n\n    # Avoid adding the same component twice.\n    if self.tag not in seen:\n        seen.add(self.tag)\n        custom_components |= self.get_component(self)._get_all_custom_components(\n            seen=seen\n        )\n\n    # Fetch custom components from props as well.\n    for child_component in self.component_props.values():\n        if child_component.tag is None:\n            continue\n        if child_component.tag not in seen:\n            seen.add(child_component.tag)\n            if isinstance(child_component, CustomComponent):\n                custom_components |= {child_component}\n            custom_components |= child_component._get_all_custom_components(\n                seen=seen\n            )\n    return custom_components\n```"]}, "reflex-reflex/components/core/upload.py-create": {"response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Create an upload component.\n\n    Args:\n        *children: The children of the component.\n        **props: The properties of the component.\n\n    Returns:\n        The upload component.\n    \"\"\"\n    # Set default props.\n    props.setdefault(\"border\", \"1px dashed var(--accent-12)\")\n    props.setdefault(\"padding\", \"5em\")\n    props.setdefault(\"textAlign\", \"center\")\n\n    # Mark the Upload component as used in the app.\n    Upload.is_used = True\n\n    return super().create(\n        *children,\n        **props,\n    )\n```"]}, "reflex-reflex/components/next/image.py-create": {"response": ["```python\ndef create(\n    *children,\n    width: Var[Any],\n    height: Var[Any],\n    **props\n) -> Image:\n    \"\"\"Create an Image component from next/image.\n\n    Args:\n        *children: The children of the component.\n        width: The width of the image.\n        height: The height of the image.\n        **props: The props of the component.\n\n    Returns:\n        Image: The created Image component.\n    \"\"\"\n    return Image.create(*children, width=width, height=height, **props)\n```"]}, "reflex-reflex/components/lucide/icon.py-create": {"response": ["```python\ndef create(cls, *children, **props) -> Component:\n    \"\"\"Initialize the Icon component.\n\n    Run some additional checks on Icon component.\n\n    Args:\n        *children: The positional arguments\n        **props: The keyword arguments\n\n    Raises:\n        AttributeError: The errors tied to bad usage of the Icon component.\n        ValueError: If the icon tag is invalid.\n\n    Returns:\n        The created component.\n    \"\"\"\n    # Extract the icon tag from the props\n    icon_tag = props.get(\"tag\", None)\n\n    # Check if the icon tag is provided\n    if icon_tag is None:\n        raise AttributeError(\"Icon tag is required but not provided.\")\n\n    # Normalize the icon tag by replacing underscores with hyphens\n    normalized_icon_tag = icon_tag.replace(\"_\", \"-\")\n\n    # Check if the normalized icon tag is in the list of valid Lucide icons\n    if normalized_icon_tag not in LUCIDE_ICON_LIST:\n        raise ValueError(f\"Invalid icon tag: {icon_tag}. Please use a valid Lucide icon name.\")\n\n    # Update the props with the normalized icon tag\n    props[\"tag\"] = normalized_icon_tag\n\n    # Create and return the Icon component\n    return super(cls, cls).__new__(cls, *children, **props)\n```"]}, "reflex-reflex/components/tags/tag.py-format_props": {"response": ["```python\ndef format_props(self) -> List:\n    \"\"\"Format the tag's props.\n\n    Returns:\n        The formatted props list.\n    \"\"\"\n    formatted_props = []\n    for name, prop in self.props.items():\n        if isinstance(prop, Var):\n            formatted_props.append(f\"{name}={prop.format()}\")\n        else:\n            formatted_props.append(f\"{name}={prop}\")\n    return formatted_props\n```"]}, "textual-src/textual/screen.py-focus_next": {"response": ["```python\ndef focus_next(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the next widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    return self._move_focus(1, selector)\n```"]}, "textual-src/textual/screen.py-focus_previous": {"response": ["```python\ndef focus_previous(self, selector: str | type[QueryType] = \"*\") -> Widget | None:\n    \"\"\"Focus the previous widget, optionally filtered by a CSS selector.\n\n    If no widget is currently focused, this will focus the first focusable widget.\n    If no focusable widget matches the given CSS selector, focus is set to `None`.\n\n    Args:\n        selector: CSS selector to filter\n            what nodes can be focused.\n\n    Returns:\n        Newly focused widget, or None for no focus. If the return\n            is not `None`, then it is guaranteed that the widget returned matches\n            the CSS selectors given in the argument.\n    \"\"\"\n    return self._move_focus(direction=-1, selector=selector)\n```"]}, "textual-src/textual/screen.py-set_focus": {"response": ["```python\ndef set_focus(self, widget: Widget | None, scroll_visible: bool = True) -> None:\n    \"\"\"Focus (or un-focus) a widget. A focused widget will receive key events first.\n\n    Args:\n        widget: Widget to focus, or None to un-focus.\n        scroll_visible: Scroll widget in to view.\n    \"\"\"\n    if widget is not None and not widget.can_focus:\n        raise errors.NoWidget(f\"Widget {widget!r} is not focusable\")\n    if self.focused is widget:\n        return\n    if self.focused is not None:\n        self.focused.post_message(events.Blur(self.focused))\n    self.focused = widget\n    if widget is not None:\n        widget.post_message(events.Focus(widget))\n        if scroll_visible:\n            self.scroll_to_widget(widget)\n    self._update_focus_styles(focused=widget, blurred=self.focused)\n```"]}, "textual-src/textual/strip.py-index_to_cell_position": {"response": ["```python\ndef index_to_cell_position(self, index: int) -> int:\n    \"\"\"Given a character index, return the cell position of that character.\n    This is the sum of the cell lengths of all the characters *before* the character\n    at `index`.\n\n    Args:\n        index: The index to convert.\n\n    Returns:\n        The cell position of the character at `index`.\n    \"\"\"\n    return sum(cell_len(text) for text, _, _ in islice(self._segments, index))\n```"]}, "textual-src/textual/strip.py-render": {"response": ["```python\ndef render(self, console: Console) -> str:\n    \"\"\"Render the strip into terminal sequences.\n\n    Args:\n        console: Console instance.\n\n    Returns:\n        Rendered sequences.\n    \"\"\"\n    segments = console.render(self.renderable, console.options)\n    if self.style is not None:\n        segments = Segment.apply_style(segments, self.style)\n    if self.link_style is not None:\n        segments = Segment.apply_style(segments, self.link_style)\n    return console.render_lines(segments, console.options, style=self.style)\n```"]}, "textual-src/textual/app.py-batch_update": {"response": ["```python\n@contextmanager\ndef batch_update(self) -> Generator[None, None, None]:\n    \"\"\"A context manager to suspend all repaints until the end of the batch.\"\"\"\n    self._begin_batch()\n    try:\n        yield\n    finally:\n        self._end_batch()\n```"]}, "textual-src/textual/app.py-call_from_thread": {"response": ["```python\ndef call_from_thread(\n    self,\n    callback: Callable[..., ReturnType],\n    *args: Any,\n    **kwargs: Any\n) -> Future[ReturnType]:\n    \"\"\"Run a callable from another thread, and return the result.\n\n    Like asyncio apps in general, Textual apps are not thread-safe. If you call methods\n    or set attributes on Textual objects from a thread, you may get unpredictable results.\n\n    This method will ensure that your code runs within the correct context.\n\n    !!! tip\n\n        Consider using [post_message][textual.message_pump.MessagePump.post_message] which is also thread-safe.\n\n    Args:\n        callback: A callable to run.\n        *args: Arguments to the callback.\n        **kwargs: Keyword arguments for the callback.\n\n    Raises:\n        RuntimeError: If the app isn't running or if this method is called from the same\n            thread where the app is running.\n\n    Returns:\n        The result of the callback.\n    \"\"\"\n    app = active_app.get()\n    if app._thread_id == threading.get_ident():\n        raise RuntimeError(\n            \"Cannot call `call_from_thread` from the same thread as the app.\"\n        )\n    if not app._running:\n        raise RuntimeError(\"App is not running.\")\n    loop = app._loop\n    if loop is None:\n        raise RuntimeError(\"App is not running.\")\n    future: Future[ReturnType] = Future()\n\n    def run_callback() -> None:\n        try:\n            result = callback(*args, **kwargs)\n        except Exception as error:\n            future.set_exception(error)\n        else:\n            if isawaitable(result):\n\n                async def set_result() -> None:\n                    try:\n                        future.set_result(await result)\n                    except Exception as error:\n                        future.set_exception(error)\n\n                create_task(set_result(), name=\"call_from_thread set_result\")\n            else:\n                future.set_result(result)\n\n    loop.call_soon_threadsafe(run_callback)\n    return future\n```"]}, "textual-src/textual/app.py-run_test": {"response": ["```python\nasync def run_test(\n    self,\n    *,\n    headless: bool = True,\n    size: tuple[int, int] | None = None,\n    tooltips: bool = False,\n    notifications: bool = False,\n    message_hook: Callable[[Message], None] | None = None,\n) -> AsyncGenerator[Pilot, None]:\n    \"\"\"An asynchronous context manager for testing apps.\n\n    !!! tip\n\n        See the guide for [testing](/guide/testing) Textual apps.\n\n    Use this to run your app in \"headless\" mode (no output) and drive the app via a [Pilot][textual.pilot.Pilot] object.\n\n    Example:\n\n        ```python\n        async with app.run_test() as pilot:\n            await pilot.click(\"#Button.ok\")\n            assert ...\n        ```\n\n    Args:\n        headless: Run in headless mode (no output or input).\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        tooltips: Enable tooltips when testing.\n        notifications: Enable notifications when testing.\n        message_hook: An optional callback that will be called each time any message arrives at any\n            message pump in the app.\n    \"\"\"\n    from .pilot import Pilot\n\n    app = self\n    app._disable_tooltips = not tooltips\n    app._disable_notifications = not notifications\n\n    async with app._process_messages(\n        headless=headless,\n        terminal_size=size,\n        message_hook=message_hook,\n    ):\n        pilot = Pilot(app)\n        yield pilot\n```"]}, "textual-src/textual/app.py-run": {"response": ["```python\ndef run(\n    self,\n    *,\n    headless: bool = False,\n    inline: bool = False,\n    inline_no_clear: bool = False,\n    mouse: bool = True,\n    size: tuple[int, int] | None = None,\n    auto_pilot: AutopilotCallbackType | None = None,\n) -> ReturnType | None:\n    \"\"\"Run the app.\n\n    Args:\n        headless: Run in headless mode (no output).\n        inline: Run the app inline (under the prompt).\n        inline_no_clear: Don't clear the app output when exiting an inline app.\n        mouse: Enable mouse support.\n        size: Force terminal size to `(WIDTH, HEIGHT)`,\n            or None to auto-detect.\n        auto_pilot: An auto pilot coroutine.\n\n    Returns:\n        App return value.\n    \"\"\"\n    return asyncio.run(\n        self.run_async(\n            headless=headless,\n            inline=inline,\n            inline_no_clear=inline_no_clear,\n            mouse=mouse,\n            size=size,\n            auto_pilot=auto_pilot,\n        )\n    )\n```"]}, "textual-src/textual/app.py-switch_mode": {"response": ["```python\ndef switch_mode(self, mode: str) -> AwaitMount:\n    \"\"\"Switch to a given mode.\n\n    Args:\n        mode: The mode to switch to.\n\n    Returns:\n        An optionally awaitable object which waits for the screen associated\n            with the mode to be mounted.\n\n    Raises:\n        UnknownModeError: If trying to switch to an unknown mode.\n    \"\"\"\n    if mode not in self.MODES:\n        raise UnknownModeError(f\"Unknown mode {mode!r}\")\n\n    if mode == self._current_mode:\n        return AwaitMount(self.screen, [])\n\n    await_mount = self._init_mode(mode)\n    self._current_mode = mode\n    self.screen.post_message(events.ScreenResume())\n    self.log.system(f\"SWITCH MODE {mode!r}\")\n    return await_mount\n```"]}, "textual-src/textual/app.py-push_screen": {"response": ["```python\ndef push_screen(\n    self,\n    screen: Screen[ScreenResultType] | str,\n    callback: ScreenResultCallbackType[ScreenResultType] | None = None,\n    wait_for_dismiss: bool = False,\n) -> AwaitMount | asyncio.Future[ScreenResultType]:\n    \"\"\"Push a new [screen](/guide/screens) on the screen stack, making it the current screen.\n\n    Args:\n        screen: A Screen instance or the name of an installed screen.\n        callback: An optional callback function that will be called if the screen is [dismissed][textual.screen.Screen.dismiss] with a result.\n        wait_for_dismiss: If `True`, awaiting this method will return the dismiss value from the screen. When set to `False`, awaiting\n            this method will wait for the screen to be mounted. Note that `wait_for_dismiss` should only be set to `True` when running in a worker.\n\n    Raises:\n        NoActiveWorker: If using `wait_for_dismiss` outside of a worker.\n\n    Returns:\n        An optional awaitable that awaits the mounting of the screen and its children, or an asyncio Future\n            to await the result of the screen.\n    \"\"\"\n    from .worker import NoActiveWorker\n\n    if wait_for_dismiss:\n        if not get_current_worker(self.app):\n            raise NoActiveWorker(\"Can't wait for dismiss outside of a worker\")\n\n    await_mount = self._push_screen(screen, callback)\n    if wait_for_dismiss:\n        future: asyncio.Future[ScreenResultType] = asyncio.Future()\n        await_mount.add_done_callback(lambda _: self._screen_result_future(future))\n        return future\n    else:\n        return await_mount\n```"]}, "textual-src/textual/app.py-switch_screen": {"response": ["```python\ndef switch_screen(self, screen: Screen | str) -> AwaitComplete:\n    \"\"\"Switch to another [screen](/guide/screens) by replacing the top of the screen stack with a new screen.\n\n    Args:\n        screen: Either a Screen object or screen name (the `name` argument when installed).\n    \"\"\"\n    try:\n        current_screen = self.screen\n    except ScreenStackError:\n        current_screen = None\n\n    if isinstance(screen, str):\n        next_screen = self.get_screen(screen)\n    else:\n        next_screen = screen\n\n    if current_screen is next_screen:\n        return AwaitComplete.nothing()\n\n    async def switch() -> None:\n        \"\"\"Switch to the new screen.\"\"\"\n        if current_screen is not None:\n            await self._replace_screen(current_screen)\n        self._screen_stack.append(next_screen)\n        self._load_screen_css(next_screen)\n        await self._register(self, next_screen)\n        next_screen.post_message(events.ScreenResume())\n        self.log.system(f\"{next_screen} RESUMED\")\n        self.refresh()\n\n    return AwaitComplete(switch()).call_next(self)\n```"]}, "textual-src/textual/app.py-pop_screen": {"response": ["```python\ndef pop_screen(self) -> AwaitComplete:\n    \"\"\"Pop the current [screen](/guide/screens) from the stack, and switch to the previous screen.\n\n    Returns:\n        The screen that was replaced.\n    \"\"\"\n    if not self._screen_stack:\n        raise ScreenStackError(\"No screens to pop\")\n    screen = self._screen_stack.pop()\n    if self._screen_stack:\n        self.screen.post_message(events.ScreenResume())\n        self.log.system(f\"{self.screen} RESUMED\")\n        self.screen.refresh()\n    else:\n        self.exit()\n    await_pop = AwaitComplete(self._replace_screen(screen)).call_next(self)\n    return await_pop\n```"]}, "textual-src/textual/app.py-run_action": {"response": ["```python\nasync def run_action(\n    self,\n    action: str | ActionParseResult,\n    default_namespace: DOMNode | None = None,\n) -> bool:\n    \"\"\"Perform an [action](/guide/actions).\n\n    Actions are typically associated with key bindings, where you wouldn't need to call this method manually.\n\n    Args:\n        action: Action encoded in a string.\n        default_namespace: Namespace to use if not provided in the action,\n            or None to use app.\n\n    Returns:\n        True if the event has been handled.\n    \"\"\"\n    if default_namespace is None:\n        default_namespace = self\n    action_target, action_name, params = self._parse_action(action, default_namespace)\n    return await self._dispatch_action(action_target, action_name, params)\n```"]}, "textual-src/textual/file_monitor.py-check": {"response": ["```python\ndef check(self) -> bool:\n    \"\"\"Check the monitored files. Return True if any were changed since the last modification time.\"\"\"\n    current_modified_time = self._get_last_modified_time()\n    if current_modified_time > self._modified:\n        self._modified = current_modified_time\n        return True\n    return False\n```"]}, "textual-src/textual/expand_tabs.py-expand_tabs_inline": {"response": ["```python\ndef expand_tabs_inline(line: str, tab_size: int = 4) -> str:\n    \"\"\"Expands tabs, taking into account double cell characters.\n\n    Args:\n        line: The text to expand tabs in.\n        tab_size: Number of cells in a tab.\n    Returns:\n        New string with tabs replaced with spaces.\n    \"\"\"\n    parts = []\n    cell_position = 0\n    for part in line.split(\"\\t\"):\n        cell_position += len(part)\n        parts.append(part)\n        if cell_position % tab_size != 0:\n            parts.append(\" \" * (tab_size - (cell_position % tab_size)))\n            cell_position += tab_size - (cell_position % tab_size)\n    return \"\".join(parts)\n```"]}, "textual-src/textual/_resolve.py-resolve": {"response": ["```python\ndef resolve(\n    dimensions: list[Scalar | None],\n    total: int,\n    gutter: int,\n    size: Size,\n    viewport: Size,\n) -> list[tuple[int, int]]:\n    \"\"\"Resolve a list of dimensions.\n\n    Args:\n        dimensions: Scalars for column / row sizes.\n        total: Total space to divide.\n        gutter: Gutter between rows / columns.\n        size: Size of container.\n        viewport: Size of viewport.\n\n    Returns:\n        List of (<OFFSET>, <LENGTH>)\n    \"\"\"\n    from .css.scalar import Scalar\n\n    if not dimensions:\n        return []\n\n    resolved: list[tuple[int, int]] = []\n    add_resolved = resolved.append\n    remaining_space = total\n    remaining_dimensions = len(dimensions)\n    offset = 0\n\n    for index, dimension in enumerate(dimensions):\n        if dimension is None:\n            continue\n        if dimension.is_fraction:\n            continue\n        resolved_dimension = dimension.resolve(size, viewport)\n        if resolved_dimension is None:\n            continue\n        resolved_dimension = int(resolved_dimension)\n        add_resolved((offset, resolved_dimension))\n        offset += resolved_dimension + gutter\n        remaining_space -= resolved_dimension\n        remaining_dimensions -= 1\n\n    if remaining_dimensions and remaining_space > 0:\n        fraction_unit = remaining_space / sum(\n            dimension.value for dimension in dimensions if dimension is not None\n        )\n        for dimension in dimensions:\n            if dimension is None or not dimension.is_fraction:\n                continue\n            resolved_dimension = int(dimension.value * fraction_unit)\n            add_resolved((offset, resolved_dimension))\n            offset += resolved_dimension + gutter\n\n    return resolved\n```"]}, "textual-src/textual/widget.py-mount": {"response": ["```python\ndef mount(\n    self,\n    *widgets: Widget,\n    before: int | str | Widget | None = None,\n    after: int | str | Widget | None = None,\n) -> AwaitMount:\n    \"\"\"Mount widgets below this widget (making this widget a container).\n\n    Args:\n        *widgets: The widget(s) to mount.\n        before: Optional location to mount before. An `int` is the index\n            of the child to mount before, a `str` is a `query_one` query to\n            find the widget to mount before.\n        after: Optional location to mount after. An `int` is the index\n            of the child to mount after, a `str` is a `query_one` query to\n            find the widget to mount after.\n\n    Returns:\n        An awaitable object that waits for widgets to be mounted.\n\n    Raises:\n        MountError: If there is a problem with the mount request.\n\n    Note:\n        Only one of ``before`` or ``after`` can be provided. If both are\n        provided a ``MountError`` will be raised.\n    \"\"\"\n    if before is not None and after is not None:\n        raise MountError(\"Only one of 'before' or 'after' may be specified.\")\n\n    if before is not None:\n        if isinstance(before, int):\n            index = before\n        elif isinstance(before, str):\n            try:\n                before_widget = self.query_one(before)\n            except NoMatches:\n                raise MountError(f\"No widget found with selector {before!r}\") from None\n            index = self._nodes.index(before_widget)\n        elif isinstance(before, Widget):\n            try:\n                index = self._nodes.index(before)\n            except ValueError:\n                raise MountError(f\"Widget {before!r} not found in children\") from None\n        else:\n            raise MountError(f\"Invalid type for 'before': {type(before)}\")\n        self._nodes[index:index] = widgets\n    elif after is not None:\n        if isinstance(after, int):\n            index = after + 1\n        elif isinstance(after, str):\n            try:\n                after_widget = self.query_one(after)\n            except NoMatches:\n                raise MountError(f\"No widget found with selector {after!r}\") from None\n            index = self._nodes.index(after_widget) + 1\n        elif isinstance(after, Widget):\n            try:\n                index = self._nodes.index(after) + 1\n            except ValueError:\n                raise MountError(f\"Widget {after!r} not found in children\") from None\n        else:\n            raise MountError(f\"Invalid type for 'after': {type(after)}\")\n        self._nodes[index:index] = widgets\n    else:\n        self._nodes.extend(widgets)\n\n    for widget in widgets:\n        self.app._register_child(self, widget, before, after)\n\n    await_mount = AwaitMount(self, widgets)\n    self.app.call_next(await_mount)\n    return await_mount\n```"]}, "textual-src/textual/widget.py-move_child": {"response": ["```python\ndef move_child(\n    self,\n    child: Widget,\n    before: int | str | Widget | None = None,\n    after: int | str | Widget | None = None,\n) -> None:\n    \"\"\"Move a child widget within its parent's list of children.\n\n    Args:\n        child: The child widget to move.\n        before: Child widget or location index to move before.\n        after: Child widget or location index to move after.\n\n    Raises:\n        WidgetError: If there is a problem with the child or target.\n\n    Note:\n        Only one of `before` or `after` can be provided. If neither\n        or both are provided a `WidgetError` will be raised.\n    \"\"\"\n    if before is not None and after is not None:\n        raise WidgetError(\"Only one of 'before' or 'after' can be provided.\")\n    if before is None and after is None:\n        raise WidgetError(\"One of 'before' or 'after' must be provided.\")\n\n    if before is not None:\n        if isinstance(before, int):\n            self._nodes.move_before(child, before)\n        elif isinstance(before, Widget):\n            self._nodes.move_before(child, before)\n        elif isinstance(before, str):\n            try:\n                target = self.query_one(before)\n            except NoMatches:\n                raise WidgetError(f\"No widget found with ID {before!r}\") from None\n            self._nodes.move_before(child, target)\n        else:\n            raise WidgetError(f\"Invalid 'before' target: {before!r}\")\n    elif after is not None:\n        if isinstance(after, int):\n            self._nodes.move_after(child, after)\n        elif isinstance(after, Widget):\n            self._nodes.move_after(child, after)\n        elif isinstance(after, str):\n            try:\n                target = self.query_one(after)\n            except NoMatches:\n                raise WidgetError(f\"No widget found with ID {after!r}\") from None\n            self._nodes.move_after(child, target)\n        else:\n            raise WidgetError(f\"Invalid 'after' target: {after!r}\")\n```"]}, "textual-src/textual/widget.py-_get_box_model": {"response": ["```python\ndef _get_box_model(\n    self,\n    container: Size,\n    viewport: Size,\n    width_fraction: Fraction,\n    height_fraction: Fraction,\n) -> BoxModel:\n    \"\"\"Process the box model for this widget.\n\n    Args:\n        container: The size of the container widget (with a layout)\n        viewport: The viewport size.\n        width_fraction: A fraction used for 1 `fr` unit on the width dimension.\n        height_fraction: A fraction used for 1 `fr` unit on the height dimension.\n\n    Returns:\n        The size and margin for this widget.\n    \"\"\"\n    styles = self.styles\n    width = styles.width\n    height = styles.height\n    margin = styles.margin\n    padding = styles.padding\n    border = styles.border\n\n    if width is None:\n        width_scalar = None\n    elif width.is_fraction:\n        width_scalar = width.value * width_fraction\n    else:\n        width_scalar = width.resolve(container, viewport, width_fraction)\n\n    if height is None:\n        height_scalar = None\n    elif height.is_fraction:\n        height_scalar = height.value * height_fraction\n    else:\n        height_scalar = height.resolve(container, viewport, height_fraction)\n\n    margin_top = margin.top.resolve(container, viewport, height_fraction)\n    margin_right = margin.right.resolve(container, viewport, width_fraction)\n    margin_bottom = margin.bottom.resolve(container, viewport, height_fraction)\n    margin_left = margin.left.resolve(container, viewport, width_fraction)\n\n    padding_top = padding.top.resolve(container, viewport, height_fraction)\n    padding_right = padding.right.resolve(container, viewport, width_fraction)\n    padding_bottom = padding.bottom.resolve(container, viewport, height_fraction)\n    padding_left = padding.left.resolve(container, viewport, width_fraction)\n\n    border_top = border.top.resolve(container, viewport, height_fraction)\n    border_right = border.right.resolve(container, viewport, width_fraction)\n    border_bottom = border.bottom.resolve(container, viewport, height_fraction)\n    border_left = border.left.resolve(container, viewport, width_fraction)\n\n    margin_width = margin_left + margin_right\n    margin_height = margin_top + margin_bottom\n\n    padding_width = padding_left + padding_right\n    padding_height = padding_top + padding_bottom\n\n    border_width = border_left + border_right\n    border_height = border_top + border_bottom\n\n    if width_scalar is None:\n        width_scalar = Fraction(container.width - margin_width - padding_width - border_width)\n    if height_scalar is None:\n        height_scalar = Fraction(container.height - margin_height - padding_height - border_height)\n\n    return BoxModel(\n        width_scalar,\n        height_scalar,\n        Spacing(margin_top, margin_right, margin_bottom, margin_left),\n    )\n```"]}, "textual-src/textual/widget.py-get_content_width": {"response": ["```python\ndef get_content_width(self, container: Size, viewport: Size) -> int:\n    \"\"\"Called by textual to get the width of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n\n    Returns:\n        The optimal width of the content.\n    \"\"\"\n    return 0\n```"]}, "textual-src/textual/widget.py-get_content_height": {"response": ["```python\ndef get_content_height(self, container: Size, viewport: Size, width: int) -> int:\n    \"\"\"Called by Textual to get the height of the content area. May be overridden in a subclass.\n\n    Args:\n        container: Size of the container (immediate parent) widget.\n        viewport: Size of the viewport.\n        width: Width of renderable.\n\n    Returns:\n        The height of the content.\n    \"\"\"\n    return self.renderable.__rich_measure__(Console(), viewport).maximum\n```"]}, "textual-src/textual/suggester.py-_get_suggestion": {"response": ["```python\nasync def _get_suggestion(self, requester: DOMNode, value: str) -> None:\n    \"\"\"Used by widgets to get completion suggestions.\n\n    Note:\n        When implementing custom suggesters, this method does not need to be\n        overridden.\n\n    Args:\n        requester: The message target that requested a suggestion.\n        value: The current value to complete.\n    \"\"\"\n    pass\n```"]}, "textual-src/textual/dom.py-add_class": {"response": ["```python\ndef add_class(self, *class_names: str, update: bool = True) -> Self:\n    \"\"\"Add class names to this Node.\n\n    Args:\n        *class_names: CSS class names to add.\n        update: Also update styles.\n\n    Returns:\n        Self.\n    \"\"\"\n    self._classes.update(class_names)\n    if update:\n        self.update_styles()\n    return self\n```"]}, "textual-src/textual/reactive.py-_initialize_object": {"response": ["```python\ndef _initialize_object(cls, obj: Reactable) -> None:\n    \"\"\"Set defaults and call any watchers / computes for the first time.\n\n    Args:\n        obj: An object with Reactive descriptors\n    \"\"\"\n    for attr, descriptor in cls._reactives.items():\n        if descriptor.compute:\n            # Call the compute function to set the initial value\n            setattr(obj, attr, descriptor.compute(obj))\n        if descriptor.watch:\n            # Call the watch function to set up any side effects\n            descriptor.watch(obj, getattr(obj, attr))\n```"]}, "textual-src/textual/message_pump.py-call_after_refresh": {"response": ["```python\ndef call_after_refresh(self, callback: CallbackType, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed and the screen\n    has been refreshed. Positional and keyword arguments are passed to the callable.\n\n    Args:\n        callback: A callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    try:\n        app = active_app.get()\n    except NoActiveAppError:\n        return False\n    app._invoke_later(partial(callback, *args, **kwargs), self)\n    return True\n```"]}, "textual-src/textual/message_pump.py-call_later": {"response": ["```python\ndef call_later(self, callback: Callback, *args: Any, **kwargs: Any) -> bool:\n    \"\"\"Schedule a callback to run after all messages are processed in this object.\n    Positional and keywords arguments are passed to the callable.\n\n    Args:\n        callback: Callable to call next.\n        *args: Positional arguments to pass to the callable.\n        **kwargs: Keyword arguments to pass to the callable.\n\n    Returns:\n        `True` if the callback was scheduled, or `False` if the callback could not be\n            scheduled (may occur if the message pump was closed or closing).\n\n    \"\"\"\n    return self._call_later(callback, *args, **kwargs)\n```"]}, "textual-src/textual/message_pump.py-post_message": {"response": ["```python\ndef post_message(self, message: Message) -> bool:\n    \"\"\"Posts a message on to this widget's queue.\n\n    Args:\n        message: A message (including Event).\n\n    Returns:\n        `True` if the messages was processed, `False` if it wasn't.\n    \"\"\"\n    return self._post_message(message)\n```"]}, "textual-src/textual/_spatial_map.py-get_values_in_region": {"response": ["```python\ndef get_values_in_region(self, region: Region) -> list[ValueType]:\n    \"\"\"Get a superset of all the values that intersect with a given region.\n\n    Note that this may return false positives.\n\n    Args:\n        region: A region.\n\n    Returns:\n        Values under the region.\n    \"\"\"\n    values_in_region = []\n    for value, value_region in self._regions.items():\n        if region.intersects(value_region):\n            values_in_region.append(value)\n    return values_in_region\n```"]}, "textual-src/textual/validation.py-validate": {"response": ["```python\ndef validate(self, value: str) -> ValidationResult:\n    \"\"\"Validates that `value` is a valid URL (contains a scheme).\n\n    Args:\n        value: The value to validate.\n\n    Returns:\n        The result of the validation.\n    \"\"\"\n    if not value.startswith((\"http://\", \"https://\")):\n        return ValidationResult(False, \"URL must start with http:// or https://\")\n    return ValidationResult(True, \"Valid URL\")\n```"]}, "textual-src/textual/geometry.py-clamp": {"response": ["```python\ndef clamp(self, width: int, height: int) -> Offset:\n    \"\"\"Clamp the offset to fit within a rectangle of width x height.\n\n    Args:\n        width: Width to clamp.\n        height: Height to clamp.\n\n    Returns:\n        A new offset.\n    \"\"\"\n    return Offset(\n        min(max(self.x, 0), width),\n        min(max(self.y, 0), height),\n    )\n```"]}, "textual-src/textual/constants.py-_get_textual_animations": {"response": ["```python\ndef _get_textual_animations() -> AnimationLevel:\n    \"\"\"Get the value of the environment variable that controls textual animations.\n\n    The variable can be in any of the values defined by [`AnimationLevel`][textual.constants.AnimationLevel].\n\n    Returns:\n        The value that the variable was set to. If the environment variable is set to an\n            invalid value, we default to showing all animations.\n    \"\"\"\n    from textual.constants import AnimationLevel\n    import os\n\n    env_value = os.getenv(\"TEXTUAL_ANIMATIONS\", \"full\").lower()\n    if env_value in AnimationLevel.__members__:\n        return AnimationLevel[env_value]\n    else:\n        return AnimationLevel.FULL\n```"]}, "textual-src/textual/color.py-parse": {"response": ["```python\nclass _Styled:\n    \"\"\"Apply a style to a renderable.\n\n    Args:\n        renderable: Any renderable.\n        style: A style to apply across the entire renderable.\n    \"\"\"\n\n    def __init__(\n        self, renderable: \"ConsoleRenderable\", style: Style, link_style: Style | None\n    ) -> None:\n        self.renderable = renderable\n        self.style = style\n        self.link_style = link_style\n\n    def __rich_console__(\n        self, console: Console, options: ConsoleOptions\n    ) -> RichRenderResult:\n        style = self.style\n        link_style = self.link_style\n        segments = console.render(self.renderable, options)\n        if link_style is not None:\n            segments = Segment.apply_style(segments, link_style)\n        yield from Segment.apply_style(segments, style)\n\n    def __rich_measure__(\n        self, console: Console, options: ConsoleOptions\n    ) -> Measurement:\n        return Measurement.get(console, options, self.renderable)\n\n\nclass MountError(Exception):\n    \"\"\"Raised when there is an error mounting a widget.\"\"\"\n\n\nclass WidgetError(Exception):\n    \"\"\"Base class for widget related errors.\"\"\"\n\n\nclass Widget(DOMNode, can_focus=True):\n    \"\"\"The base class for all widgets.\n\n    A widget is a unit of user interface that displays information or provides a specific way for a user to interact with an application.\n    \"\"\"\n\n    DEFAULT_CSS = \"\"\"\n    Widget {\n        width: 100%;\n        height: 100%;\n        background: $surface;\n        color: $text;\n    }\n    \"\"\"\n\n    BINDINGS: ClassVar[list[BindingType]] = []\n    \"\"\"Default bindings for all widgets. These are overridden by bindings defined in CSS.\"\"\"\n\n    COMPONENT_CLASSES: ClassVar[set[str]] = set()\n    \"\"\"A set of identifiers that map to CSS classes that can be used to style components of this widget.\n\n    For example, if a widget has a `error-message` component class, you could create a CSS rule to style it:\n\n    ```sass\n    .error-message {\n        color: red;\n    }\n    ```\n\n    You can then set the component class on the widget with:\n\n    ```python\n    self.set_class(True, \"-error-message\")\n    ```\n\n    Component classes are prefixed with a `-` to avoid conflicts with other class names.\n    \"\"\"\n\n    COMPONENT_SCOPE: ClassVar[str] = \"\"\n    \"\"\"A string that is used to scope component classes.\n\n    For example, if a widget has a `COMPONENT_SCOPE` of `foo`, then the component class `error-message` would be scoped to `foo--error-message`.\n\n    This is useful for avoiding conflicts with other widgets that may have the same component class names.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str | None = None,\n        id: str | None = None,\n        classes: str | None = None,\n    ) -> None:\n        \"\"\"Initialize a widget.\n\n        Args:\n            name: The name of the widget.\n            id: The ID of the widget in the DOM.\n            classes: A space-separated list of classes.\n        \"\"\"\n        super().__init__(name=name, id=id, classes=classes)\n        self._nodes: NodeList[Widget] = NodeList()\n        self._layout: Layout = VerticalLayout()\n        self._layout_required = False\n        self._repaint_required = False\n        self._recompose_required = False\n        self._scroll_required = False\n        self._virtual_size: Size = NULL_SIZE\n        self._container_size: Size = NULL_SIZE\n        self._region: Region = NULL_REGION\n        self._visible_content_region: Region = NULL_REGION\n        self._visible_content_region_dirty = True\n        self._scroll_x = 0\n        self._scroll_y = 0\n        self._scroll_target_x = 0\n        self._scroll_target_y = 0\n        self._scroll_animation_task: Task | None = None\n        self._vertical_scrollbar: ScrollBar | None = None\n        self._horizontal_scrollbar: ScrollBar | None = None"]}, "textual-src/textual/_slug.py-slug": {"response": ["```python\ndef slug(self, text: str) -> str:\n    \"\"\"Create a Markdown-friendly unique slug from the given text.\n\n    Args:\n        text: The text to generate a slug from.\n\n    Returns:\n        A slug for the given text.\n    \"\"\"\n    import re\n    from collections import defaultdict\n\n    # Convert text to lowercase\n    text = text.lower()\n\n    # Remove special characters and replace spaces with hyphens\n    slug = re.sub(r'[^a-z0-9 ]', '', text)\n    slug = re.sub(r'\\s+', '-', slug).strip('-')\n\n    # Ensure the slug is unique by appending a counter if necessary\n    if not hasattr(self, '_slug_counter'):\n        self._slug_counter = defaultdict(int)\n\n    self._slug_counter[slug] += 1\n    if self._slug_counter[slug] > 1:\n        slug += f'-{self._slug_counter[slug]}'\n\n    return slug\n```"]}, "textual-src/textual/_styles_cache.py-render": {"response": ["```python\ndef render(\n    self,\n    styles: RenderStyles,\n    size: Size,\n    base_background: Color,\n    background: Color,\n    render_content_line: Callable[[int, Style], Strip],\n    console: Console,\n    border_title: tuple[Text, Style] | None = None,\n    border_subtitle: tuple[Text, Style] | None = None,\n    content_size: Size | None = None,\n    padding: Spacing | None = None,\n    crop: Region | None = None,\n    filters: list[LineFilter] | None = None,\n    opacity: float = 1.0,\n) -> list[Strip]:\n    \"\"\"Render a widget content plus CSS styles.\n\n    Args:\n        styles: CSS Styles object.\n        size: Size of widget.\n        base_background: Background color beneath widget.\n        background: Background color of widget.\n        render_content_line: Callback to render content line.\n        console: The console in use by the app.\n        border_title: Optional tuple of (title, color, background, style).\n        border_subtitle: Optional tuple of (subtitle, color, background, style).\n        content_size: Size of content or None to assume full size.\n        padding: Override padding from Styles, or None to use styles.padding.\n        crop: Region to crop to.\n        filters: Additional post-processing for the segments.\n        opacity: Widget opacity.\n\n    Returns:\n        Rendered lines.\n    \"\"\"\n    # Implementation of the render function goes here\n    pass\n```"]}, "textual-src/textual/document/_document.py-replace_range": {"response": ["```python\ndef replace_range(self, start: Location, end: Location, text: str) -> EditResult:\n    \"\"\"Replace text at the given range.\n\n    This is the only method by which a document may be updated.\n\n    Args:\n        start: A tuple (row, column) where the edit starts.\n        end: A tuple (row, column) where the edit ends.\n        text: The text to insert between start and end.\n\n    Returns:\n        The EditResult containing information about the completed\n            replace operation.\n    \"\"\"\n    top, bottom = sorted((start, end))\n\n    # An optimization would be finding the byte offsets as a single operation rather\n    # than doing two passes over the document content.\n    start_byte = self._location_to_byte_offset(top)\n    start_point = self._location_to_point(top)\n    old_end_byte = self._location_to_byte_offset(bottom)\n    old_end_point = self._location_to_point(bottom)\n\n    replace_result = super().replace_range(start, end, text)\n\n    text_byte_length = len(_utf8_encode(text))\n    end_location = replace_result.end_location\n    assert self._syntax_tree is not None\n    assert self._parser is not None\n    self._syntax_tree.edit(\n        start_byte=start_byte,\n        old_end_byte=old_end_byte,\n        new_end_byte=start_byte + text_byte_length,\n        start_point=start_point,\n        old_end_point=old_end_point,\n        new_end_point=self._location_to_point(end_location),\n    )\n    # Incrementally parse the document.\n    self._syntax_tree = self._parser.parse(\n        self._read_callable, self._syntax_tree  # type: ignore[arg-type]\n    )\n\n    return replace_result\n```"]}, "textual-src/textual/document/_wrapped_document.py-wrap_range": {"response": ["```python\ndef wrap_range(\n    self,\n    start: Location,\n    old_end: Location,\n    new_end: Location,\n) -> None:\n    \"\"\"Incrementally recompute wrapping based on a performed edit.\n\n    This must be called *after* the source document has been edited.\n\n    Args:\n        start: The start location of the edit that was performed in document-space.\n        old_end: The old end location of the edit in document-space.\n        new_end: The new end location of the edit in document-space.\n    \"\"\"\n    # Extract the row indices from the locations\n    start_row, _ = start\n    old_end_row, _ = old_end\n    new_end_row, _ = new_end\n\n    # Determine the range of rows affected by the edit\n    affected_rows = range(start_row, max(old_end_row, new_end_row) + 1)\n\n    # Recompute the wrapping for the affected rows\n    for row in affected_rows:\n        line = self.document[row]\n        tab_sections = get_tab_widths(line, self._tab_width)\n        wrap_offsets = (\n            compute_wrap_offsets(\n                line,\n                self._width,\n                tab_size=self._tab_width,\n                precomputed_tab_sections=tab_sections,\n            )\n            if self._width\n            else []\n        )\n        self._wrap_offsets[row] = wrap_offsets\n        self._tab_width_cache[row] = [width for _, width in tab_sections]\n\n    # Recompute the offset-to-line info and line-index-to-offsets mappings\n    offset_to_line_info = []\n    line_index_to_offsets = []\n    current_offset = 0\n\n    for line_index, line in enumerate(self.document.lines):\n        wrap_offsets = self._wrap_offsets[line_index]\n        line_index_to_offsets.append([])\n        for section_y_offset in range(len(wrap_offsets) + 1):\n            offset_to_line_info.append((line_index, section_y_offset))\n            line_index_to_offsets[line_index].append(current_offset)\n            current_offset += 1\n\n    self._offset_to_line_info = offset_to_line_info\n    self._line_index_to_offsets = line_index_to_offsets\n```"]}, "textual-src/textual/document/_wrapped_document.py-offset_to_location": {"response": ["```python\ndef offset_to_location(self, offset: Offset) -> Location:\n    \"\"\"Given an offset within the wrapped/visual display of the document,\n    return the corresponding location in the document.\n\n    Args:\n        offset: The y-offset within the document.\n\n    Raises:\n        ValueError: When the given offset does not correspond to a line\n            in the document.\n\n    Returns:\n        The Location in the document corresponding to the given offset.\n    \"\"\"\n    y_offset = offset.y\n    offset_to_line_info = self._offset_to_line_info\n\n    if y_offset < 0 or y_offset >= len(offset_to_line_info):\n        raise ValueError(\n            f\"The offset {y_offset!r} is out of bounds. \"\n            f\"The document contains {len(offset_to_line_info)!r} lines.\"\n        )\n\n    line_index, section_index = offset_to_line_info[y_offset]\n    wrap_offsets = self.get_offsets(line_index)\n    section_start_columns = [0, *wrap_offsets]\n    section_start_column = section_start_columns[section_index]\n\n    sections = self.get_sections(line_index)\n    target_section = sections[section_index]\n\n    x_offset = offset.x\n    target_column_index = section_start_column + cell_width_to_column_index(\n        target_section, x_offset, self._tab_width\n    )\n\n    return (line_index, target_column_index)\n```"]}, "textual-src/textual/css/parse.py-substitute_references": {"response": ["```python\ndef substitute_references(tokens: Iterable[Token]) -> Iterable[Token]:\n    \"\"\"Replace variable references with values by substituting variable reference\n    tokens with the tokens representing their values.\n\n    Args:\n        tokens: Iterator of Tokens which may contain tokens\n            with the name \"variable_ref\".\n\n    Returns:\n        Yields Tokens such that any variable references (tokens where\n            token.name == \"variable_ref\") have been replaced with the tokens representing\n            the value. In other words, an Iterable of Tokens similar to the original input,\n            but with variables resolved. Substituted tokens will have their referenced_by\n            attribute populated with information about where the tokens are being substituted to.\n    \"\"\"\n    from .tokenize import Token, ReferencedBy\n    from .tokenizer import TokenError\n\n    for token in tokens:\n        if token.name == \"variable_ref\":\n            variable_name = token.value[1:]  # Remove the leading '$'\n            variable_tokens = tokenize_values({variable_name: self._variables.get(variable_name, \"\")})\n            if variable_name not in variable_tokens:\n                raise TokenError(\n                    token.read_from,\n                    token.code,\n                    token.start,\n                    f\"reference to undefined variable '${variable_name}'\",\n                    end=token.end,\n                )\n            for value_token in variable_tokens[variable_name]:\n                yield value_token.with_reference(ReferencedBy(\n                    name=token.value,\n                    location=token.location,\n                    length=len(token.value),\n                    code=token.code,\n                ))\n        else:\n            yield token\n```"]}, "textual-src/textual/css/parse.py-parse": {"response": ["```python\ndef parse(\n    scope: str,\n    css: str,\n    read_from: CSSLocation,\n    variables: dict[str, str] | None = None,\n    is_default_rules: bool = False,\n) -> Iterable[RuleSet]:\n    \"\"\"Parse CSS by tokenizing it, performing variable substitution,\n    and generating rule sets from it.\n\n    Args:\n        scope: CSS type name.\n        css: The input CSS.\n        read_from: The source location of the CSS.\n        variables: Substitution variables to substitute tokens for.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n    \"\"\"\n    from .tokenize import TokenizerState, tokenize_values\n    from .tokenizer import Token, TokenError\n    from .types import CSSLocation\n\n    if variables is None:\n        variables = {}\n\n    variable_tokens = tokenize_values(variables)\n\n    tokenizer_state = TokenizerState()\n    tokens = iter(tokenizer_state(css, read_from))\n    styles_builder = StylesBuilder()\n\n    declaration: Declaration | None = None\n    errors: list[tuple[Token, str | HelpText]] = []\n    nested_rules: list[RuleSet] = []\n\n    while True:\n        try:\n            token = next(tokens)\n        except TokenError as error:\n            errors.append((error.token, str(error)))\n            break\n        except StopIteration:\n            break\n\n        token_name = token.name\n        if token_name in (\"whitespace\", \"declaration_end\", \"eof\"):\n            continue\n        if token_name == \"declaration_name\":\n            if declaration:\n                try:\n                    styles_builder.add_declaration(declaration)\n                except DeclarationError as error:\n                    errors.append((error.token, error.message))\n            declaration = Declaration(token, \"\")\n            declaration.name = token.value.rstrip(\":\")\n        elif token_name == \"declaration_set_end\":\n            break\n        else:\n            if declaration:\n                declaration.tokens.append(token)\n\n    if declaration:\n        try:\n            styles_builder.add_declaration(declaration)\n        except DeclarationError as error:\n            errors.append((error.token, error.message))\n\n    rule_set = RuleSet(\n        list(SelectorSet.from_selectors([[]])),\n        styles_builder.styles,\n        errors,\n        is_default_rules=is_default_rules,\n    )\n\n    rule_set._post_parse()\n    yield rule_set\n\n    for nested_rule_set in nested_rules:\n        nested_rule_set._post_parse()\n        yield nested_rule_set\n```"]}, "textual-src/textual/css/stylesheet.py-_parse_rules": {"response": ["```python\ndef _parse_rules(\n    css: str,\n    read_from: CSSLocation,\n    is_default_rules: bool = False,\n    scope: str = \"\",\n) -> list[RuleSet]:\n    \"\"\"Parse CSS and return rules.\n\n    Args:\n        css: String containing Textual CSS.\n        read_from: Original CSS location.\n        is_default_rules: True if the rules we're extracting are\n            default (i.e. in Widget.DEFAULT_CSS) rules. False if they're from user defined CSS.\n        scope: Scope of rules, or empty string for global scope.\n\n    Raises:\n        StylesheetError: If the CSS is invalid.\n\n    Returns:\n        List of RuleSets.\n    \"\"\"\n    from .parse import parse_rule_set\n    from .tokenize import Token, tokenize\n\n    tokens = iter(tokenize(css, read_from))\n    rule_sets: list[RuleSet] = []\n    errors: list[tuple[Token, str | HelpText]] = []\n\n    try:\n        while True:\n            token = next(tokens)\n            if token.name in (\"whitespace\", \"comment_line\", \"comment_start\"):\n                continue\n            if token.name in {\n                \"selector_start_id\",\n                \"selector_start_class\",\n                \"selector_start_universal\",\n                \"selector_start\",\n                \"nested\",\n            }:\n                rule_set = list(\n                    parse_rule_set(\n                        scope,\n                        tokens,\n                        token,\n                        is_default_rules=is_default_rules,\n                        tie_breaker=0,\n                    )\n                )\n                rule_sets.extend(rule_set)\n            elif token.name == \"eof\":\n                break\n            else:\n                errors.append((token, f\"unexpected token {token.value!r}\"))\n    except TokenError as error:\n        errors.append((error.token, str(error)))\n\n    if errors:\n        raise StylesheetError(f\"Invalid CSS: {errors}\")\n\n    return rule_sets\n```"]}, "textual-src/textual/css/stylesheet.py-parse": {"response": ["```python\ndef parse(self) -> None:\n    \"\"\"Parse the source in the stylesheet.\n\n    Raises:\n        StylesheetParseError: If there are any CSS related errors.\n    \"\"\"\n    from .parse import parse_rule_set\n    from .tokenize import Token, tokenize\n    from .tokenizer import EOFError, ReferencedBy\n\n    rules: list[RuleSet] = []\n    errors: list[tuple[Token, str | HelpText]] = []\n    append_error = errors.append\n\n    for read_from, (css, is_default_css, tie_breaker, scope) in self.source.items():\n        tokens = iter(tokenize(css, read_from))\n        while True:\n            try:\n                token = next(tokens)\n            except EOFError:\n                break\n            if token.name in (\"whitespace\", \"comment_line\"):\n                continue\n            elif token.name == \"comment_start\":\n                try:\n                    next(tokens)\n                except EOFError:\n                    break\n                continue\n            elif token.name in {\n                \"selector_start_id\",\n                \"selector_start_class\",\n                \"selector_start_universal\",\n                \"selector_start\",\n                \"nested\",\n            }:\n                try:\n                    rule_set = list(\n                        parse_rule_set(\n                            scope,\n                            tokens,\n                            token,\n                            is_default_rules=is_default_css,\n                            tie_breaker=tie_breaker,\n                        )\n                    )\n                except EOFError:\n                    break\n                rules.extend(rule_set)\n            elif token.name == \"variable_name\":\n                variable_name = token.value.rstrip(\":\")\n                variable_tokens: list[Token] = []\n                while True:\n                    try:\n                        token = next(tokens)\n                    except EOFError:\n                        break\n                    if token.name == \"variable_value_end\":\n                        break\n                    elif token.name == \"whitespace\":\n                        continue\n                    elif token.name == \"comment_start\":\n                        try:\n                            next(tokens)\n                        except EOFError:\n                            break\n                        continue\n                    variable_tokens.append(token)\n                self._variable_tokens[variable_name] = variable_tokens\n            else:\n                append_error((token, f\"unexpected token {token.value!r}\"))\n\n    if errors:\n        raise StylesheetParseError(StylesheetErrors(rules))\n\n    self._rules = rules\n```"]}, "gpt-engineer-gpt_engineer/core/chat_to_files.py-parse_diffs": {"response": ["```python\ndef parse_diffs(diff_string: str) -> dict:\n    \"\"\"\n    Parses a diff string in the unified git diff format.\n\n    Args:\n    - diff_string (str): The diff string to parse.\n\n    Returns:\n    - dict: A dictionary of Diff objects keyed by filename.\n    \"\"\"\n    diffs = {}\n    current_diff = None\n    hunk_lines = []\n    filename_pre = None\n    filename_post = None\n    hunk_header = None\n\n    lines = diff_string.strip().split(\"\\n\")\n    for line in lines:\n        if line.startswith(\"--- \"):\n            # Pre-edit filename\n            filename_pre = line[4:]\n        elif line.startswith(\"+++ \"):\n            # Post-edit filename and initiation of a new Diff object\n            if filename_post is not None and current_diff is not None and hunk_header is not None:\n                current_diff.hunks.append(Hunk(*hunk_header, hunk_lines))\n                hunk_lines = []\n            filename_post = line[4:]\n            current_diff = Diff(filename_pre, filename_post)\n            diffs[filename_post] = current_diff\n        elif line.startswith(\"@@ \"):\n            # Start of a new hunk in the diff\n            if hunk_lines and current_diff is not None and hunk_header is not None:\n                current_diff.hunks.append(Hunk(*hunk_header, hunk_lines))\n                hunk_lines = []\n            hunk_header = parse_hunk_header(line)\n        elif line.startswith(\"+\"):\n            # Added line\n            hunk_lines.append((ADD, line[1:]))\n        elif line.startswith(\"-\"):\n            # Removed line\n            hunk_lines.append((REMOVE, line[1:]))\n        else:\n            # Retained line\n            hunk_lines.append((RETAIN, line[1:]))\n\n    # Append the last hunk if any\n    if current_diff is not None and hunk_lines and hunk_header is not None:\n        current_diff.hunks.append(Hunk(*hunk_header, hunk_lines))\n\n    return diffs\n\ndef parse_hunk_header(header_line) -> Tuple[int, int, int, int]:\n    \"\"\"\n    Parses the header of a hunk from a diff.\n\n    Args:\n    - header_line (str): The header line of a hunk.\n\n    Returns:\n    - tuple: A tuple containing start and length information for pre- and post-edit.\n    \"\"\"\n    pattern = re.compile(r\"^@@ -\\d{1,},\\d{1,} \\+\\d{1,},\\d{1,} @@$\")\n\n    if not pattern.match(header_line):\n        # Return a default value if the header does not match the expected format\n        return 0, 0, 0, 0\n\n    pre, post = header_line.split(\" \")[1:3]\n    start_line_pre_edit, hunk_len_pre_edit = map(int, pre[1:].split(\",\"))\n    start_line_post_edit, hunk_len_post_edit = map(int, post[1:].split(\",\"))\n    return (\n        start_line_pre_edit,\n        hunk_len_pre_edit,\n        start_line_post_edit,\n        hunk_len_post_edit,\n    )\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-start": {"response": ["```python\ndef start(self, system: str, user: Any, *, step_name: str) -> List[Message]:\n    \"\"\"\n    Start the conversation with a system message and a user message.\n\n    Parameters\n    ----------\n    system : str\n        The content of the system message.\n    user : str\n        The content of the user message.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The list of messages in the conversation.\n    \"\"\"\n    messages = [SystemMessage(content=system), HumanMessage(content=user)]\n    response = self.backoff_inference(messages)\n    messages.append(AIMessage(content=response))\n    self.token_usage_log.update_log(messages, response, step_name)\n    return messages\n```"]}, "gpt-engineer-gpt_engineer/core/ai.py-next": {"response": ["```python\ndef next(\n    self,\n    messages: List[Message],\n    prompt: Optional[str] = None,\n    *,\n    step_name: str,\n) -> List[Message]:\n    \"\"\"\n    Advances the conversation by sending message history\n    to LLM and updating with the response.\n\n    Parameters\n    ----------\n    messages : List[Message]\n        The list of messages in the conversation.\n    prompt : Optional[str], optional\n        The prompt to use, by default None.\n    step_name : str\n        The name of the step.\n\n    Returns\n    -------\n    List[Message]\n        The updated list of messages in the conversation.\n    \"\"\"\n    if prompt:\n        messages.append(HumanMessage(content=prompt))\n\n    logger.debug(f\"Creating a new chat completion: {messages}\")\n\n    response = self.backoff_inference(messages)\n\n    messages.append(AIMessage(content=response))\n    logger.debug(f\"Chat completion finished: {messages}\")\n\n    self.token_usage_log.update_log(messages, response, step_name)\n\n    return messages\n```"]}, "gpt-engineer-gpt_engineer/core/project_config.py-to_toml": {"response": ["```python\ndef to_toml(self, config_file: Path | str, save=True) -> str:\n    \"\"\"Write the configuration to a TOML file.\"\"\"\n    config_dict = self.to_dict()\n    toml_content = tomlkit.dumps(config_dict)\n    \n    if save:\n        if isinstance(config_file, str):\n            config_file = Path(config_file)\n        with open(config_file, \"w\") as f:\n            f.write(toml_content)\n    \n    return toml_content\n```"]}, "gpt-engineer-gpt_engineer/core/diff.py-is_similar": {"response": ["```python\ndef is_similar(str1, str2, similarity_threshold=0.9) -> bool:\n    \"\"\"\n    Compares two strings for similarity, ignoring spaces and case.\n\n    Parameters\n    ----------\n    str1, str2 : str\n        The strings to compare.\n    similarity_threshold: float\n        How similar must the strings be\n\n    Returns\n    -------\n    bool\n        True if the strings are similar, False otherwise.\n    \"\"\"\n    # Remove spaces and convert to lower case for both strings\n    str1 = str1.replace(\" \", \"\").lower()\n    str2 = str2.replace(\" \", \"\").lower()\n\n    # Calculate the ratio of common characters to the length of the longer string\n    ratio = count_ratio(str1, str2)\n\n    # Return True if the ratio is greater than or equal to the similarity threshold\n    return ratio >= similarity_threshold\n```"]}}