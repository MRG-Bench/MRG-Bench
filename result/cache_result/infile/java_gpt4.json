{"langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocuments": "```java\npublic static List<Document> loadDocuments(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    try (Stream<Path> pathStream = Files.list(directoryPath)) {\n        return loadDocuments(pathStream, path -> true, directoryPath, documentParser);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```", "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/loader/FileSystemDocumentLoader.java-loadDocumentsRecursively": "```java\npublic static List<Document> loadDocumentsRecursively(Path directoryPath, DocumentParser documentParser) {\n    if (!isDirectory(directoryPath)) {\n        throw illegalArgument(\"'%s' is not a directory\", directoryPath);\n    }\n\n    List<Document> documents = new ArrayList<>();\n\n    try (Stream<Path> pathStream = Files.walk(directoryPath)) {\n        documents = pathStream\n                .filter(Files::isRegularFile) // Only consider regular files\n                .map(file -> {\n                    try {\n                        return loadDocument(file, documentParser);\n                    } catch (BlankDocumentException ignored) {\n                        // Blank documents are ignored\n                        return null;\n                    } catch (Exception e) {\n                        String message = e.getCause() != null ? e.getCause().getMessage() : e.getMessage();\n                        log.warn(\"Failed to load '{}': {}\", file, message);\n                        return null;\n                    }\n                })\n                .filter(doc -> doc != null) // Filter out null documents\n                .collect(Collectors.toList());\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n\n    return documents;\n}\n```", "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-hasSpaceFor": "```java\npublic boolean hasSpaceFor(String text) {\n    int textSize = sizeOf(text);\n    return hasSpaceFor(textSize);\n}\n```", "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-append": "```java\npublic void append(String text) {\n    ensureNotNull(text, \"text\");\n    int textSize = sizeOf(text);\n    if (hasSpaceFor(textSize)) {\n        if (isNotEmpty()) {\n            segment += joinSeparator;\n            segmentSize += joinSeparatorSize;\n        }\n        segment += text;\n        segmentSize += textSize;\n    } else {\n        throw new IllegalArgumentException(\"Text size exceeds the maximum segment size\");\n    }\n}\n```", "langchain4j-langchain4j/src/main/java/dev/langchain4j/data/document/splitter/SegmentBuilder.java-prepend": "```java\npublic void prepend(String text) {\n    ensureNotNull(text, \"text\");\n    int textSize = sizeOf(text);\n\n    if (textSize + (isNotEmpty() ? joinSeparatorSize : 0) + segmentSize <= maxSegmentSize) {\n        if (isNotEmpty()) {\n            segment = text + joinSeparator + segment;\n            segmentSize += joinSeparatorSize + textSize;\n        } else {\n            segment = text;\n            segmentSize = textSize;\n        }\n    } else {\n        throw new IllegalArgumentException(\"The text is too large to prepend without exceeding the max segment size.\");\n    }\n}\n```", "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-retriever": "```java\n@Deprecated\npublic AiServices<T> retriever(Retriever<TextSegment> retriever) {\n    if (contentRetrieverSet || retrievalAugmentorSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    retrieverSet = true;\n    context.retriever = ensureNotNull(retriever, \"retriever\");\n    return this;\n}\n```", "langchain4j-langchain4j/src/main/java/dev/langchain4j/service/AiServices.java-contentRetriever": "```java\npublic AiServices<T> contentRetriever(ContentRetriever contentRetriever) {\n    if (retrieverSet || retrievalAugmentorSet) {\n        throw illegalConfiguration(\"Only one out of [retriever, contentRetriever, retrievalAugmentor] can be set\");\n    }\n    contentRetrieverSet = true;\n    context.retrievalAugmentor = new DefaultRetrievalAugmentor(ensureNotNull(contentRetriever, \"contentRetriever\"));\n    return this;\n}\n```", "langchain4j-langchain4j-pgvector/src/main/java/dev/langchain4j/store/embedding/pgvector/PgVectorEmbeddingStore.java-add": "The method you're looking for is intended to add a given embedding to the store and return the auto-generated ID associated with the added embedding. Here's what the implementation could look like based on the context provided:\n\n```java\n@Override\npublic String add(Embedding embedding) {\n    String id = randomUUID(); // Generate a unique ID for the embedding\n    addInternal(id, embedding, null); // Utilize the existing internal method to add the embedding\n    return id; // Return the generated ID\n}\n```\n\nThis implementation generates a unique identifier for the embedding and uses an internal method (`addInternal`) to actually add the embedding to the store, while returning the generated ID as expected.", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationsFrom": "To create the `toolSpecificationsFrom` function, we need to retrieve all methods from the specified class that are annotated with `@Tool`, and return a list of `ToolSpecification` objects for those methods. Here is a possible implementation in Java:\n\n```java\npublic static List<ToolSpecification> toolSpecificationsFrom(Class<?> classWithTools) {\n    List<ToolSpecification> toolSpecifications = new ArrayList<>();\n    \n    // Get all declared methods from the class\n    Method[] methods = classWithTools.getDeclaredMethods();\n    \n    // Iterate through each method\n    for (Method method : methods) {\n        // Check if the method is annotated with @Tool\n        if (method.isAnnotationPresent(Tool.class)) {\n            // Create a ToolSpecification from the method and add it to the list\n            ToolSpecification toolSpecification = createToolSpecificationForMethod(method);\n            toolSpecifications.add(toolSpecification);\n        }\n    }\n    \n    return toolSpecifications;\n}\n\nprivate static ToolSpecification createToolSpecificationForMethod(Method method) {\n    // Assume a constructor exists for ToolSpecification that takes a Method\n    // The implementation might vary based on the actual structure of ToolSpecification\n    return new ToolSpecification(method);\n}\n```\n\nThis implementation assumes that there is a `ToolSpecification` constructor or a method that can create a specification from a `Method` object. The `createToolSpecificationForMethod` function is a placeholder that needs to be implemented according to the specifics of the `ToolSpecification` construction.", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toolSpecificationFrom": "```java\npublic static ToolSpecification toolSpecificationFrom(Method method) {\n    // Check if the method is annotated with @Tool\n    if (!method.isAnnotationPresent(Tool.class)) {\n        throw new IllegalArgumentException(\"Method is not annotated with @Tool\");\n    }\n\n    // Extract the Tool annotation from the method\n    Tool toolAnnotation = method.getAnnotation(Tool.class);\n\n    // Create a ToolSpecification builder or use an appropriate constructor\n    ToolSpecification.Builder builder = ToolSpecification.builder();\n\n    // Set the name of the tool (assuming the Tool annotation has a name attribute)\n    builder.name(toolAnnotation.name());\n\n    // Set the description if available in the annotation or elsewhere\n    Description methodDescription = method.getAnnotation(Description.class);\n    if (methodDescription != null) {\n        builder.description(methodDescription.value());\n    }\n\n    // Handle parameters - converting them to JsonSchemaProperties\n    for (Parameter parameter : method.getParameters()) {\n        JsonSchemaProperty schemaProperty = toJsonSchemaProperties(parameter);\n        builder.addParameter(schemaProperty);\n    }\n\n    // Configure other necessary attributes, handling return types, exceptions etc. as required\n\n    // Build the ToolSpecification and return it\n    return builder.build();\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/agent/tool/ToolSpecifications.java-toJsonSchemaProperties": "```java\nstatic Iterable<JsonSchemaProperty> toJsonSchemaProperties(Parameter parameter) {\n    // Get the type of the parameter\n    Class<?> type = parameter.getType();\n\n    // Retrieve the description annotation if present\n    Description annotation = parameter.getAnnotation(Description.class);\n    JsonSchemaProperty description = annotation == null ? null : description(String.join(\" \", annotation.value()));\n\n    // Handle simple types\n    Iterable<JsonSchemaProperty> simpleType = toJsonSchemaProperties(type, description);\n    if (simpleType != null) {\n        return simpleType;\n    }\n\n    // Handle Collection types (e.g., List, Set)\n    if (Collection.class.isAssignableFrom(type)) {\n        // Get the generic type of the collection\n        Type genericType = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments()[0];\n        return removeNulls(ARRAY, arrayTypeFrom((Class<?>) genericType), description);\n    }\n\n    // Handle array types\n    if (type.isArray()) {\n        return removeNulls(ARRAY, arrayTypeFrom(type.getComponentType()), description);\n    }\n\n    // Handle Enum types\n    if (type.isEnum()) {\n        return removeNulls(STRING, enums((Class<?>) type), description);\n    }\n\n    // Handle complex/structured objects\n    return removeNulls(OBJECT, schema(type, new HashSet<>()), description);\n}\n```\n", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/store/embedding/CosineSimilarity.java-between": "```java\npublic static double between(Embedding embeddingA, Embedding embeddingB) {\n    ensureNotNull(embeddingA, \"embeddingA\");\n    ensureNotNull(embeddingB, \"embeddingB\");\n\n    double[] vectorA = embeddingA.getVector();\n    double[] vectorB = embeddingB.getVector();\n\n    if (vectorA.length != vectorB.length) {\n        throw illegalArgument(\"The vectors must be of the same length\");\n    }\n\n    double dotProduct = 0.0;\n    double magnitudeA = 0.0;\n    double magnitudeB = 0.0;\n\n    for (int i = 0; i < vectorA.length; i++) {\n        dotProduct += vectorA[i] * vectorB[i];\n        magnitudeA += Math.pow(vectorA[i], 2);\n        magnitudeB += Math.pow(vectorB[i], 2);\n    }\n\n    magnitudeA = Math.sqrt(magnitudeA);\n    magnitudeB = Math.sqrt(magnitudeB);\n\n    if (magnitudeA < EPSILON || magnitudeB < EPSILON) {\n        return 0.0; // Considered orthogonal to all other vectors\n    }\n\n    return dotProduct / (magnitudeA * magnitudeB);\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/Metadata.java-asMap": "```java\n@Deprecated\npublic Map<String, String> asMap() {\n    Map<String, String> stringMap = new HashMap<>();\n    for (Map.Entry<String, Object> entry : metadata.entrySet()) {\n        stringMap.put(entry.getKey(), entry.getValue().toString());\n    }\n    return stringMap;\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/document/DocumentLoader.java-load": "```java\npackage dev.langchain4j.data.document;\n\npublic class DocumentLoader {\n\n    private DocumentLoader() {\n    }\n\n    /**\n     * Loads a document from the given source using the given parser.\n     *\n     * <p>Forwards the source Metadata to the parsed Document.\n     *\n     * @param source The source from which the document will be loaded.\n     * @param parser The parser that will be used to parse the document.\n     * @return The loaded document.\n     * @throws BlankDocumentException when the parsed {@link Document} is blank/empty.\n     */\n    public static Document load(DocumentSource source, DocumentParser parser) {\n        // Parse the document from the provided source using the parser\n        Document document = parser.parse(source);\n        \n        // Check if the document is blank or empty\n        if (document == null || document.isEmpty()) {\n            throw new BlankDocumentException(\"The parsed document is blank/empty.\");\n        }\n\n        // Forward the source metadata to the document\n        document.setMetadata(source.getMetadata());\n\n        // Return the loaded document\n        return document;\n    }\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/data/message/UserMessage.java-singleText": "```java\npublic String singleText() {\n    if (!hasSingleText()) {\n        throw new RuntimeException(\"The message does not contain a single TextContent.\");\n    }\n    return ((TextContent) contents.get(0)).getText();\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/RetrievalAugmentor.java-augment": "```java\npublic default AugmentationResult augment(AugmentationRequest augmentationRequest) {\n    // Extract the ChatMessage from the AugmentationRequest\n    ChatMessage chatMessage = augmentationRequest.getChatMessage();\n\n    // Retrieve relevant Content for the ChatMessage based on some retrieval logic\n    // This could involve querying a database, calling an API, or any other content retrieval mechanism\n    List<Content> retrievedContents = retrieveContentForChatMessage(chatMessage);\n\n    // Augment the ChatMessage with the retrieved Content\n    ChatMessage augmentedChatMessage = augmentChatMessageWithContent(chatMessage, retrievedContents);\n\n    // Create and return an AugmentationResult containing the augmented ChatMessage\n    return new AugmentationResult(augmentedChatMessage);\n}\n\nprivate List<Content> retrieveContentForChatMessage(ChatMessage chatMessage) {\n    // Implement retrieval logic here\n    // For now, return an empty list or mock data to simulate content retrieval\n    return new ArrayList<>();\n}\n\nprivate ChatMessage augmentChatMessageWithContent(ChatMessage chatMessage, List<Content> contents) {\n    // Implement logic to incorporate the retrieved Content into the ChatMessage\n    // This might involve appending, merging, or otherwise enhancing the original ChatMessage\n    // For simplicity, assume it creates a new ChatMessage with combined contents\n\n    // Example: Simply add contents as metadata or additional information\n    chatMessage.setAdditionalContents(contents);\n\n    return chatMessage;\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/DefaultRetrievalAugmentor.java-augment": "```java\n@Override\n@Deprecated\npublic UserMessage augment(UserMessage userMessage, Metadata metadata) {\n    AugmentationRequest augmentationRequest = AugmentationRequest.builder()\n            .chatMessage(userMessage)\n            .metadata(metadata)\n            .build();\n\n    AugmentationResult augmentationResult = augment(augmentationRequest);\n\n    return (UserMessage) augmentationResult.chatMessage();\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/rag/content/injector/ContentInjector.java-inject": "```java\ndefault ChatMessage inject(List<Content> contents, ChatMessage chatMessage) {\n    for (Content content : contents) {\n        if (chatMessage instanceof UserMessage) {\n            // Assuming UserMessage has some method to add content, this is a placeholder\n            ((UserMessage) chatMessage).addContent(content);\n        } else if (chatMessage instanceof SystemMessage) {\n            // Assuming SystemMessage has some method to add content, this is also a placeholder\n            ((SystemMessage) chatMessage).addContent(content);\n        }\n    }\n    return chatMessage;\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-areNotNullOrBlank": "```java\npublic static boolean areNotNullOrBlank(String... strings) {\n    if (strings == null) {\n        return false;\n    }\n\n    for (String s : strings) {\n        if (isNullOrBlank(s)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-generateUUIDFrom": "```java\npublic static String generateUUIDFrom(String input) {\n    MessageDigest digest = getSha256Instance();\n    byte[] hashBytes = digest.digest(input.getBytes(UTF_8));\n    return UUID.nameUUIDFromBytes(hashBytes).toString();\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/Utils.java-readBytes": "```java\npublic static byte[] readBytes(String url) {\n    try {\n        URI uri = new URI(url);\n        if (\"http\".equalsIgnoreCase(uri.getScheme()) || \"https\".equalsIgnoreCase(uri.getScheme())) {\n            HttpURLConnection connection = (HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestMethod(\"GET\");\n            \n            if (connection.getResponseCode() == HTTP_OK) {\n                try (InputStream inputStream = connection.getInputStream();\n                     ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream()) {\n                     \n                    byte[] buffer = new byte[1024];\n                    int bytesRead;\n                    while ((bytesRead = inputStream.read(buffer)) != -1) {\n                        byteArrayOutputStream.write(buffer, 0, bytesRead);\n                    }\n                    return byteArrayOutputStream.toByteArray();\n                }\n            } else {\n                throw new RuntimeException(\"Failed to get content from URL. HTTP code: \" + connection.getResponseCode());\n            }\n        } else {\n            return Files.readAllBytes(Paths.get(uri));\n        }\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to get content from URL\", e);\n    }\n}\n```", "langchain4j-langchain4j-core/src/main/java/dev/langchain4j/internal/RetryUtils.java-jitterDelayMillis": "```java\npublic int jitterDelayMillis(int attempt) {\n    double rawDelayMs = rawDelayMs(attempt);\n    Random rand = new Random();\n    return (int) (rawDelayMs + rand.nextInt((int) (rawDelayMs * jitterScale)));\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/keygen/KeyGeneratorFactory.java-getKeyGenerator": "```java\npublic static IKeyGenerator getKeyGenerator(String name) {\n    if (StringUtil.isEmpty(name)) {\n        throw new FlexExceptions(LocalizedFormats.KEY_GENERATOR_NAME_CANNOT_BE_EMPTY);\n    }\n\n    IKeyGenerator keyGenerator = KEY_GENERATOR_MAP.get(name.trim());\n\n    if (keyGenerator == null) {\n        throw new FlexExceptions(LocalizedFormats.KEY_GENERATOR_NOT_FOUND, name);\n    }\n\n    return keyGenerator;\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/query/QueryCondition.java-when": "```java\npublic QueryCondition when(boolean effective) {\n    if (notEmpty()) {\n        this.effective = effective;\n    }\n    return this;\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-methodToProperty": "The function signature `public static String methodToProperty(String name)` appears to convert a method name to a property name following some conventions, likely those defined in the JavaBeans specification. \n\nBased on the provided context and the typical behavior of such a method, here is an implementation:\n\n```java\npublic static String methodToProperty(String name) {\n    if (name == null || name.isEmpty()) {\n        throw new IllegalArgumentException(\"Method name must not be empty\");\n    }\n\n    if (name.startsWith(\"is\") && name.length() > 2) {\n        return StringUtil.firstCharToLowerCase(name.substring(2));\n    } else if ((name.startsWith(\"get\") || name.startsWith(\"set\")) && name.length() > 3) {\n        return StringUtil.firstCharToLowerCase(name.substring(3));\n    } else {\n        throw new IllegalArgumentException(\"Method name does not follow getter/setter convention: \" + name);\n    }\n}\n```\n\nExplanation:\n- The function handles method names starting with \"is\", \"get\", or \"set\" as typical in JavaBeans naming conventions.\n- `firstCharToLowerCase` is used to convert the first character of the remainder of the string to lower case, converting it into a property name according to standard conventions.\n- It throws an `IllegalArgumentException` if the input doesn't meet the expected patterns, ensuring robust input validation.", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-camelToUnderline": "```java\npublic static String camelToUnderline(String string) {\n    if (string == null || string.isEmpty()) {\n        return string;\n    }\n    \n    StringBuilder result = new StringBuilder();\n    char[] chars = string.toCharArray();\n\n    for (char c : chars) {\n        if (Character.isUpperCase(c)) {\n            result.append('_');\n            result.append(Character.toLowerCase(c));\n        } else {\n            result.append(c);\n        }\n    }\n\n    return result.toString();\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/StringUtil.java-underlineToCamel": "```java\npublic static String underlineToCamel(String string) {\n    if (isBlank(string)) {\n        return \"\";\n    }\n\n    StringBuilder result = new StringBuilder();\n    boolean nextUpperCase = false;\n\n    for (int i = 0; i < string.length(); i++) {\n        char currentChar = string.charAt(i);\n\n        if (currentChar == '_') {\n            nextUpperCase = true;\n        } else {\n            if (nextUpperCase) {\n                result.append(Character.toUpperCase(currentChar));\n                nextUpperCase = false;\n            } else {\n                result.append(currentChar);\n            }\n        }\n    }\n\n    return result.toString();\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/CollectionUtil.java-computeIfAbsent": "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> concurrentHashMap, K key, Function<? super K, ? extends V> mappingFunction) {\n    Objects.requireNonNull(mappingFunction, \"Mapping function must not be null\");\n\n    V value = concurrentHashMap.get(key);\n    if (value == null) {\n        // Avoids the deadlock in JDK 1.8 by not relying solely on the atomic computeIfAbsent method.\n        value = mappingFunction.apply(key);\n        if (value != null) {\n            // We only put the value in the map if it hasn't been inserted in the meantime.\n            V previousValue = concurrentHashMap.putIfAbsent(key, value);\n            if (previousValue != null) {\n                value = previousValue;\n            }\n        }\n    }\n    \n    return value;\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/util/MapUtil.java-computeIfAbsent": "```java\npublic static <K, V> V computeIfAbsent(Map<K, V> map, K key, Function<K, V> mappingFunction) {\n    if (!map.containsKey(key)) {\n        V value = mappingFunction.apply(key);\n        if (value != null) {\n            map.put(key, value);\n        }\n        return value;\n    }\n    return map.get(key);\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofEntityClass": "```java\npublic static <E> BaseMapper<E> ofEntityClass(Class<E> entityClass) {\n    Class<?> mapperClass = ENTITY_MAPPER_MAP.get(entityClass);\n\n    if (mapperClass == null) {\n        throw new FlexExceptions(\"No mapper found for entity class: \" + entityClass.getName());\n    }\n\n    return (BaseMapper<E>) ofMapperClass(mapperClass);\n}\n```", "mybatis-flex-mybatis-flex-core/src/main/java/com/mybatisflex/core/mybatis/Mappers.java-ofMapperClass": "```java\npublic static <M> M ofMapperClass(Class<M> mapperClass) {\n    return (M) MAPPER_OBJECTS.computeIfAbsent(mapperClass, cls -> {\n        if (!BaseMapper.class.isAssignableFrom(mapperClass)) {\n            throw new FlexExceptions(\"The class must be a subclass of BaseMapper\");\n        }\n        return Proxy.newProxyInstance(\n            mapperClass.getClassLoader(),\n            new Class[]{mapperClass},\n            new MapperHandler(mapperClass)\n        );\n    });\n}\n```", "spring-ai-models/spring-ai-openai/src/main/java/org/springframework/ai/openai/OpenAiAudioSpeechModel.java-stream": "```java\n@Override\npublic Flux<SpeechResponse> stream(SpeechPrompt speechPrompt) {\n    OpenAiAudioApi.SpeechRequest speechRequest = createRequest(speechPrompt);\n\n    // Use the audioApi to initiate a streaming request for the audio response\n    Flux<byte[]> speechStream = this.audioApi.streamSpeech(speechRequest);\n\n    // Convert the stream of byte arrays to a stream of SpeechResponse objects\n    return speechStream.map(speechChunk -> {\n        if (speechChunk == null || speechChunk.length == 0) {\n            logger.warn(\"No speech chunk returned for speechRequest: {}\", speechRequest);\n            return new SpeechResponse(new Speech(new byte[0]));\n        }\n\n        // Assuming metadata can be extracted for each chunk, but typically metadata might\n        // be available through some initial or final request headers.\n        RateLimit rateLimits = new RateLimit();  // Initialize rateLimit as needed.\n        \n        OpenAiAudioSpeechResponseMetadata metadata = new OpenAiAudioSpeechResponseMetadata(rateLimits);\n        \n        return new SpeechResponse(new Speech(speechChunk), metadata);\n    });\n}\n```", "spring-ai-models/spring-ai-postgresml/src/main/java/org/springframework/ai/postgresml/PostgresMlEmbeddingModel.java-mergeOptions": "```java\nPostgresMlEmbeddingOptions mergeOptions(EmbeddingOptions requestOptions) {\n    // Create a builder for PostgresMlEmbeddingOptions using defaultOptions\n    PostgresMlEmbeddingOptions.PostgresMlEmbeddingOptionsBuilder optionsBuilder = PostgresMlEmbeddingOptions.builder()\n        .withTransformer(requestOptions.getTransformer() != null ? requestOptions.getTransformer() : this.defaultOptions.getTransformer())\n        .withVectorType(requestOptions.getVectorType() != null ? requestOptions.getVectorType() : this.defaultOptions.getVectorType())\n        .withMetadataMode(requestOptions.getMetadataMode() != null ? requestOptions.getMetadataMode() : this.defaultOptions.getMetadataMode());\n\n    // Merge kwargs from requestOptions and defaultOptions\n    Map<String, Object> mergedKwargs = new HashMap<>(ModelOptionsUtils.toMap(this.defaultOptions.getKwargs()));\n    if (requestOptions.getKwargs() != null && !requestOptions.getKwargs().isEmpty()) {\n        mergedKwargs.putAll(ModelOptionsUtils.toMap(requestOptions.getKwargs()));\n    }\n    optionsBuilder.withKwargs(ModelOptionsUtils.toJsonString(mergedKwargs));\n\n    // Build and return the merged options\n    return optionsBuilder.build();\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/embedding/AbstractEmbeddingModel.java-dimensions": "```java\npublic static int dimensions(EmbeddingModel embeddingModel, String modelName, String dummyContent) {\n    // Check if the model name is in the known dimensions map\n    Integer knownDimension = KNOWN_EMBEDDING_DIMENSIONS.get(modelName);\n    \n    // If the dimensions are known, return them directly\n    if (knownDimension != null) {\n        return knownDimension;\n    }\n\n    // If the model name is unknown, use the EmbeddingModel to perform a dummy embed\n    // to determine the dimensions empirically\n    try {\n        // Perform a dummy embed operation\n        double[] dummyEmbedding = embeddingModel.embed(dummyContent);\n\n        // Get the dimensions of the embedding\n        int dimensionCount = dummyEmbedding.length;\n\n        // Optionally, you could cache this result by adding it to the known dimensions map\n        KNOWN_EMBEDDING_DIMENSIONS.put(modelName, dimensionCount);\n\n        return dimensionCount;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to determine embedding dimensions for model: \" + modelName, e);\n    }\n}\n```\nThis function checks if the dimensions for a given model name are already known and stored in a map. If yes, it returns those dimensions. If not, it performs a dummy embed using the `EmbeddingModel` to empirically determine the dimensions and returns that value. Optionally, the result can be cached for future use.", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/PromptMetadata.java-findByPromptIndex": "```java\ndefault Optional<PromptFilterMetadata> findByPromptIndex(int promptIndex) {\n    // Validate that the given prompt index is not less than 0\n    if (promptIndex < 0) {\n        throw new IllegalArgumentException(\"The prompt index must not be less than 0.\");\n    }\n\n    // Iterate through the PromptMetadata to find the PromptFilterMetadata with the specified index\n    return StreamSupport.stream(this.spliterator(), false)\n        .filter(promptFilterMetadata -> promptFilterMetadata.getPromptIndex() == promptIndex)\n        .findFirst();\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/chat/metadata/Usage.java-getTotalTokens": "```java\ndefault Long getTotalTokens() {\n    return getPromptTokens() + getGenerationTokens();\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/vectorstore/filter/FilterHelper.java-negate": "```java\npublic static Filter.Operand negate(Filter.Operand operand) {\n    if (operand instanceof Filter.Expression expression) {\n        // Apply double negation: NOT(NOT(a)) = a\n        if (expression.type() == ExpressionType.NOT && expression.left() instanceof Filter.Expression innerExpression\n                && innerExpression.type() == ExpressionType.NOT) {\n            return innerExpression.left();\n        }\n\n        // Handle negation rules\n        ExpressionType negatedType = TYPE_NEGATION_MAP.get(expression.type());\n        if (negatedType != null) {\n            return new Filter.Expression(negatedType, expression.left(), expression.right());\n        }\n        \n        // For AND and OR, distribute NOT\n        if (expression.type() == ExpressionType.AND || expression.type() == ExpressionType.OR) {\n            Expression negatedLeft = new Filter.Expression(ExpressionType.NOT, expression.left(), null);\n            Expression negatedRight = new Filter.Expression(ExpressionType.NOT, expression.right(), null);\n            return new Filter.Expression(negatedType == ExpressionType.AND ? ExpressionType.OR : ExpressionType.AND,\n                                            negate(negatedLeft), negate(negatedRight));\n        }\n    }\n\n    // If operand is not an expression or not a type we can negate, return as is\n    return operand;\n}\n```\n", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-merge": "```java\npublic static <T> T merge(Object source, Object target, Class<T> clazz, List<String> acceptedFieldNames) {\n    BeanWrapper sourceWrapper = new BeanWrapperImpl(source);\n    BeanWrapper targetWrapper = new BeanWrapperImpl(target);\n\n    List<String> fieldNamesToMerge;\n\n    if (!CollectionUtils.isEmpty(acceptedFieldNames)) {\n        fieldNamesToMerge = acceptedFieldNames;\n    } else {\n        fieldNamesToMerge = getJsonPropertyValues(clazz);\n    }\n\n    for (String fieldName : fieldNamesToMerge) {\n        if (BEAN_MERGE_FIELD_EXCISIONS.contains(fieldName)) {\n            continue;\n        }\n        try {\n            Object value = sourceWrapper.getPropertyValue(fieldName);\n            // Only set the value in the target if the source value is not null\n            if (value != null) {\n                targetWrapper.setPropertyValue(fieldName, value);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to merge field: \" + fieldName, e);\n        }\n    }\n\n    try {\n        return clazz.cast(target);\n    } catch (ClassCastException e) {\n        throw new RuntimeException(\"Failed to cast target object to class: \" + clazz.getName(), e);\n    }\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-objectToMap": "```java\npublic static Map<String, Object> objectToMap(Object source) {\n    if (source == null) {\n        return new HashMap<>();\n    }\n\n    BeanWrapper srcWrapper = new BeanWrapperImpl(source);\n    PropertyDescriptor[] propertyDescriptors = srcWrapper.getPropertyDescriptors();\n\n    Map<String, Object> resultMap = new HashMap<>();\n\n    for (PropertyDescriptor pd : propertyDescriptors) {\n        String propertyName = pd.getName();\n        if (srcWrapper.isReadableProperty(propertyName) && srcWrapper.getPropertyValue(propertyName) != null) {\n            resultMap.put(propertyName, srcWrapper.getPropertyValue(propertyName));\n        }\n    }\n\n    return resultMap;\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-copyToTarget": "```java\npublic static <I, S extends I, T extends S> T copyToTarget(S sourceBean, Class<I> sourceInterfaceClazz, Class<T> targetBeanClazz) {\n    try {\n        // Create an instance of the target bean class\n        T targetBean = targetBeanClazz.getDeclaredConstructor().newInstance();\n\n        // Use BeanWrapper to copy properties\n        BeanWrapper sourceWrapper = new BeanWrapperImpl(sourceBean);\n        BeanWrapper targetWrapper = new BeanWrapperImpl(targetBean);\n\n        // Get all readable property names\n        PropertyDescriptor[] propertyDescriptors = sourceWrapper.getPropertyDescriptors();\n\n        // Iterate over all property names\n        for (PropertyDescriptor descriptor : propertyDescriptors) {\n            String propertyName = descriptor.getName();\n\n            // Try to copy value if the method is also present in the interface class\n            try {\n                if (sourceInterfaceClazz.getMethod(toGetName(propertyName)) != null) {\n                    Object value = sourceWrapper.getPropertyValue(propertyName);\n                    if (!ObjectUtils.isEmpty(value)) {\n                        targetWrapper.setPropertyValue(propertyName, value);\n                    }\n                }\n            } catch (NoSuchMethodException ignored) {\n                // If no such method, ignore this property as it doesn't exist in the interface\n            }\n        }\n\n        return targetBean;\n    } catch (Exception e) {\n        throw new RuntimeException(\"Failed to copy properties from source bean to target bean\", e);\n    }\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/model/ModelOptionsUtils.java-mergeBeans": "```java\npublic static <I, S extends I, T extends S> T mergeBeans(S source, T target, Class<I> sourceInterfaceClazz, boolean overrideNonNullTargetValues) {\n    Assert.notNull(source, \"Source must not be null\");\n    Assert.notNull(target, \"Target must not be null\");\n    Assert.notNull(sourceInterfaceClazz, \"Source interface class must not be null\");\n\n    BeanWrapper sourceWrapper = new BeanWrapperImpl(source);\n    BeanWrapper targetWrapper = new BeanWrapperImpl(target);\n\n    for (java.beans.PropertyDescriptor propertyDescriptor : sourceWrapper.getPropertyDescriptors()) {\n        String propertyName = propertyDescriptor.getName();\n\n        if (sourceInterfaceClazz != null) {\n            try {\n                sourceInterfaceClazz.getMethod(toGetName(propertyName));\n            } catch (NoSuchMethodException e) {\n                // Skip properties that don't exist in the source interface\n                continue;\n            }\n        }\n\n        Object sourceValue = sourceWrapper.getPropertyValue(propertyName);\n        Object targetValue = targetWrapper.getPropertyValue(propertyName);\n\n        if (sourceValue != null && (overrideNonNullTargetValues || targetValue == null)) {\n            targetWrapper.setPropertyValue(propertyName, sourceValue);\n        }\n    }\n    return target;\n}\n```", "spring-ai-spring-ai-core/src/main/java/org/springframework/ai/aot/AiRuntimeHints.java-findJsonAnnotatedClassesInPackage": "```java\npublic static Set<TypeReference> findJsonAnnotatedClassesInPackage(String packageName) {\n    // Initiate a class path scanner for the specified package\n    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);\n\n    // Create a type filter for classes that have Jackson annotations\n    TypeFilter jacksonAnnotationFilter = (metadataReader, metadataReaderFactory) -> {\n        try {\n            // Find the class and check if it has Jackson annotations\n            Class<?> clazz = Class.forName(metadataReader.getClassMetadata().getClassName());\n            return hasJacksonAnnotations(clazz);\n        } catch (ClassNotFoundException e) {\n            log.error(\"Failed to load class while scanning for Jackson annotations\", e);\n            return false;\n        }\n    };\n\n    // Add the filter to the scanner\n    scanner.addIncludeFilter(jacksonAnnotationFilter);\n\n    // Collect the classes matching the filter\n    return scanner.findCandidateComponents(packageName)\n                  .stream()\n                  .map(beanDefinition -> TypeReference.of(Objects.requireNonNull(beanDefinition.getBeanClassName())))\n                  .peek(typeReference -> {\n                      if (log.isDebugEnabled()) {\n                          log.debug(\"Registering [\" + typeReference.getName() + ']');\n                      }\n                  })\n                  .collect(Collectors.toUnmodifiableSet());\n}\n```", "spring-ai-document-readers/pdf-reader/src/main/java/org/springframework/ai/reader/pdf/ParagraphPdfDocumentReader.java-get": "```java\n@Override\npublic List<Document> get() {\n    List<Paragraph> paragraphs = paragraphTextExtractor.extractParagraphs(); // Extract paragraphs using paragraphTextExtractor\n    List<Document> documents = new ArrayList<>(); // Create a list to store documents\n    \n    if (!CollectionUtils.isEmpty(paragraphs)) { // Check if paragraphs list is not empty\n        Iterator<Paragraph> iterator = paragraphs.iterator(); // Get an iterator for the paragraphs list\n        \n        Paragraph current = iterator.next(); // Get the first paragraph\n        \n        while (iterator.hasNext()) { // Iterate while there are more paragraphs\n            Paragraph next = iterator.next(); // Get the next paragraph\n            \n            Document document = toDocument(current, next); // Convert paragraphs to Document\n            \n            if (document != null) { // Check if document is not null\n                documents.add(document); // Add document to the list\n            }\n            \n            current = next; // Move to the next paragraph\n        }\n        \n        // Handle the last paragraph with a null ending\n        Document document = toDocument(current, new Paragraph(\"\", Integer.MAX_VALUE, Integer.MAX_VALUE, 0)); // Convert last paragraph\n        if (document != null) { // Check if document is not null\n            documents.add(document); // Add document to the list\n        }\n    }\n    \n    return documents; // Return the list of documents\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/FixedBitSet.java-ensureCapacity": "```java\npublic static FixedBitSet ensureCapacity(FixedBitSet bits, int numBits) {\n    // Determine the number of words needed to hold numBits+1\n    int requiredWords = bits2words(numBits + 1);\n    \n    // Check if the existing FixedBitSet can accommodate the additional bits\n    if (bits.getBits().length >= requiredWords) {\n        // If it can, return the existing FixedBitSet\n        return bits;\n    } else {\n        // If it cannot, create a new FixedBitSet with the necessary capacity\n        long[] newBits = new long[requiredWords];\n        System.arraycopy(bits.getBits(), 0, newBits, 0, bits.getBits().length);\n        // Create a new FixedBitSet with the new bits array and return it\n        return new FixedBitSet(newBits, numBits);\n    }\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/DenseIntMap.java-forEach": "```java\npublic void forEach(IntBiConsumer<T> consumer) {\n    var ref = objects;\n    for (int i = 0; i < ref.length(); i++) {\n        T value = ref.get(i);\n        if (value != null) {\n            consumer.consume(i, value);\n        }\n    }\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/AbstractLongHeap.java-pop": "```java\npublic final long pop() {\n    if (size == 0) {\n        throw new IllegalStateException(\"The LongHeap is empty.\");\n    }\n\n    // The least element is at the top of the heap\n    long result = heap[1];\n\n    // Move the last element to the top and reduce the size\n    heap[1] = heap[size];\n    size--;\n\n    // Fix the heap property by pushing the top element down\n    downHeap(1);\n\n    return result;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/util/BoundedLongHeap.java-updateTop": "```java\n@VisibleForTesting\nlong updateTop(long value) {\n    if (size == 0) {\n        return Long.MIN_VALUE; // Return a suitable value when the heap is empty\n    }\n\n    heap[1] = value; // Replace the top of the heap with the new value\n    heapifyDown(1);  // Restore the heap property by sifting down the new top\n\n    return heap[1]; // Return the new top element after reordering the heap\n}\n\nprivate void heapifyDown(int index) {\n    while (true) {\n        int leftChild = 2 * index;\n        int rightChild = 2 * index + 1;\n        int largest = index;\n\n        if (leftChild <= size && heap[leftChild] > heap[largest]) {\n            largest = leftChild;\n        }\n\n        if (rightChild <= size && heap[rightChild] > heap[largest]) {\n            largest = rightChild;\n        }\n\n        if (largest != index) {\n            swap(index, largest);\n            index = largest;\n        } else {\n            break;\n        }\n    }\n}\n\nprivate void swap(int i, int j) {\n    long temp = heap[i];\n    heap[i] = heap[j];\n    heap[j] = temp;\n}\n```\n", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/BQVectors.java-scoreFunctionFor": "```java\n@Override\npublic ScoreFunction.ApproximateScoreFunction scoreFunctionFor(VectorFloat<?> q, VectorSimilarityFunction similarityFunction) {\n    // Note: similarityFunction is ignored as you always get Hamming distance similarity with BQ\n    long[] queryEncoded = bq.encode(q);\n\n    return new ScoreFunction.ApproximateScoreFunction() {\n        @Override\n        public float score(int vectorIndex) {\n            long[] vectorEncoded = compressedVectors[vectorIndex];\n            return similarityBetween(queryEncoded, vectorEncoded);\n        }\n    };\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-compute": "```java\npublic static ProductQuantization compute(\n        RandomAccessVectorValues ravv, int M, int clusterCount, boolean globallyCenter, \n        float anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    \n    // Extract training vectors, where the number of vectors is limited to a maximum\n    List<VectorFloat<?>> trainingVectors = extractTrainingVectors(ravv, parallelExecutor);\n    \n    // Globally center the vectors if specified\n    VectorFloat<?> globalCentroid = null;\n    if (globallyCenter) {\n        globalCentroid = VectorUtil.center(trainingVectors);\n    }\n    \n    // Define subvector sizes and offsets\n    int[][] subvectorSizesAndOffsets = getSubvectorSizesAndOffsets(ravv.dimension(), M);\n    \n    // Create the codebooks by clustering the input data\n    VectorFloat<?>[] codebooks = createCodebooks(trainingVectors, subvectorSizesAndOffsets, clusterCount, anisotropicThreshold, simdExecutor);\n    \n    // Create a new instance of ProductQuantization with the computed values\n    return new ProductQuantization(codebooks, clusterCount, subvectorSizesAndOffsets, globalCentroid, anisotropicThreshold);\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-refine": "```java\n/**\n * Create a new PQ by fine-tuning this one with the data in `ravv`\n *\n * @param ravv the vectors to use for refinement\n * @param lloydsRounds number of Lloyd's iterations to run against\n *                     the new data. Suggested values are 1 or 2.\n * @param anisotropicThreshold the threshold for anisotropic shaping\n * @param simdExecutor ForkJoinPool instance for SIMD operations\n * @param parallelExecutor ForkJoinPool instance for parallel processing\n * @return a new ProductQuantization instance fine-tuned with the provided data\n */\npublic ProductQuantization refine(RandomAccessVectorValues ravv, int lloydsRounds, float anisotropicThreshold, ForkJoinPool simdExecutor, ForkJoinPool parallelExecutor) {\n    List<VectorFloat<?>> trainingVectors = extractTrainingVectors(ravv, parallelExecutor);\n\n    VectorFloat<?>[] newCodebooks = createCodebooks(trainingVectors, subvectorSizesAndOffsets, clusterCount, anisotropicThreshold, simdExecutor);\n    var newGlobalCentroid = globallyCenter ? computeGlobalCentroid(trainingVectors) : null;\n\n    return new ProductQuantization(newCodebooks, clusterCount, subvectorSizesAndOffsets, newGlobalCentroid, anisotropicThreshold);\n}\n```\n\nIn this implementation, the `refine` method extracts training vectors from the provided `RandomAccessVectorValues` object. It then creates new codebooks using clustering and potentially a new global centroid based on whether global centering is required. Finally, it returns a new `ProductQuantization` instance with the refined parameters.", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encodeAnisotropic": "```java\nprivate ByteSequence<?> encodeAnisotropic(VectorFloat<?> vector) {\n    Residual[][] residuals = computeResiduals(vector);\n    ByteSequence<?> encoded = initializeToMinResidualNorms(residuals);\n\n    float parallelResidualSum = 0.0f;\n    for (int m = 0; m < M; m++) {\n        int cluster = encoded.get(m);\n        parallelResidualSum += residuals[m][cluster].parallelResidualComponent;\n    }\n\n    for (int iteration = 0; iteration < K_MEANS_ITERATIONS; iteration++) {\n        for (int m = 0; m < M; m++) {\n            int oldIdx = encoded.get(m);\n            CoordinateDescentResult result = optimizeSingleSubspace(residuals[m], oldIdx, parallelResidualSum);\n            encoded.set(m, (byte) result.newCenterIdx);\n            parallelResidualSum = result.newParallelResidualComponent;\n        }\n    }\n    return encoded;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-encode": "```java\n@Override\npublic ByteSequence<?> encode(VectorFloat<?> vector) {\n    // Get the number of subspaces\n    int subspaceCount = getSubspaceCount();\n    \n    // Create a new ByteSequence to hold the encoded result\n    ByteSequence<?> encoded = vectorTypeSupport.createByteSequence(subspaceCount);\n    \n    // Iterate over each subspace\n    for (int m = 0; m < subspaceCount; m++) {\n        // Find the closest centroid index for the current subvector\n        int closestCentroid = closestCentroidIndex(vector, m, codebooks[m]);\n        \n        // Set the byte value for this subspace in the resulting encoded sequence\n        encoded.set(m, (byte) closestCentroid);\n    }\n    \n    // Return the encoded byte sequence\n    return encoded;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decode": "```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector.\n *\n * @param encoded the encoded byte sequence representing the quantized vector\n * @param target the vector to hold the decoded approximate original vector\n */\npublic void decode(ByteSequence<?> encoded, VectorFloat<?> target) {\n    // Ensure the target vector is of the proper length\n    assert target.length() == originalDimension : \"Target vector length does not match original dimension\";\n\n    // Iterate over each subspace to reconstruct the original vector approximation\n    for (int m = 0; m < M; m++) {\n        int subvectorSize = subvectorSizesAndOffsets[m][0];\n        int subvectorOffset = subvectorSizesAndOffsets[m][1];\n        \n        // Get the index of the centroid for the given subspace from the encoded ByteSequence\n        int centroidIndex = encoded.get(m) & 0xFF; // Ensure unsigned byte conversion\n        \n        // Retrieve relevant centroid from the codebook\n        VectorFloat<?> centroid = codebooks[m];\n        \n        // Copy the relevant part of the centroid into the target vector\n        target.copyFrom(centroid, centroidIndex * subvectorSize, subvectorOffset, subvectorSize);\n    }\n    \n    // If there is a global centroid, add it back to the decoded vector (reversing the global centering if applied)\n    if (globalCentroid != null) {\n        target.add(globalCentroid, 0, 0, originalDimension);\n    }\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/pq/ProductQuantization.java-decodeCentered": "```java\n/**\n * Decodes the quantized representation (ByteSequence) to its approximate original vector, relative to the global centroid.\n *\n * @param encoded a ByteSequence representing the quantized data\n * @param target the VectorFloat object where the decoded vector will be stored\n */\nvoid decodeCentered(ByteSequence<?> encoded, VectorFloat<?> target) {\n    Objects.requireNonNull(encoded, \"Encoded ByteSequence must not be null\");\n    Objects.requireNonNull(target, \"Target VectorFloat cannot be null\");\n\n    int subspaceCount = getSubspaceCount();\n    if (encoded.length() != subspaceCount) {\n        throw new IllegalArgumentException(\"Encoded ByteSequence length must match the number of subspaces\");\n    }\n\n    for (int m = 0; m < subspaceCount; m++) {\n        int centroidIndex = encoded.get(m) & 0xFF; // Get the unsigned byte value\n        VectorFloat<?> codebook = codebooks[m];\n        int subvectorSize = subvectorSizesAndOffsets[m][0];\n        int subvectorOffset = subvectorSizesAndOffsets[m][1];\n\n        // Sum up the corresponding centroid subvector into the target\n        target.add(codebook, centroidIndex * subvectorSize, subvectorOffset, subvectorSize);\n    }\n\n    if (globalCentroid != null) {\n        // Add the global centroid to each component of the decoded vector\n        target.add(globalCentroid, 0, 0, globalCentroid.length());\n    }\n}\n```\n\nThis method decodes the quantized representation held in a `ByteSequence` object and reconstructs the approximate original vector, applying the global centroid transformation if it is available. Make sure to validate the parameters and ensure the dimension matching between the encoded structure and the proposed vector space (target).", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/Matrix.java-invert": "```java\npublic Matrix invert() {\n    int n = data.length;\n    if (n != data[0].length()) {\n        throw new IllegalArgumentException(\"Matrix must be square.\");\n    }\n    \n    // Create an augmented matrix with the identity matrix\n    Matrix augmented = new Matrix(n, 2 * n, false);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            augmented.set(i, j, this.get(i, j));\n        }\n        augmented.set(i, n + i, 1.0f); // Set up the identity matrix\n    }\n    \n    // Apply Gaussian Elimination\n    for (int i = 0; i < n; i++) {\n        // Find the pivot row\n        int pivot = i;\n        for (int j = i + 1; j < n; j++) {\n            if (abs(augmented.get(j, i)) > abs(augmented.get(pivot, i))) {\n                pivot = j;\n            }\n        }\n        \n        // Swap the current row with the pivot row\n        if (pivot != i) {\n            for (int j = 0; j < 2 * n; j++) {\n                float temp = augmented.get(i, j);\n                augmented.set(i, j, augmented.get(pivot, j));\n                augmented.set(pivot, j, temp);\n            }\n        }\n        \n        // Scale the pivot row\n        float scale = augmented.get(i, i);\n        if (scale == 0) {\n            throw new ArithmeticException(\"Matrix is singular and cannot be inverted.\");\n        }\n        for (int j = 0; j < 2 * n; j++) {\n            augmented.set(i, j, augmented.get(i, j) / scale);\n        }\n        \n        // Eliminate the column entries above and below the pivot\n        for (int k = 0; k < n; k++) {\n            if (k != i) {\n                float factor = augmented.get(k, i);\n                for (int j = 0; j < 2 * n; j++) {\n                    augmented.set(k, j, augmented.get(k, j) - factor * augmented.get(i, j));\n                }\n            }\n        }\n    }\n    \n    // Extract the inverted matrix from the augmented matrix\n    Matrix inverse = new Matrix(n, n, false);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            inverse.set(i, j, augmented.get(i, n + j));\n        }\n    }\n    \n    return inverse;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/vector/VectorUtil.java-cosine": "```java\npublic static float cosine(VectorFloat<?> a, VectorFloat<?> b) {\n    if (a.length() != b.length()) {\n        throw new IllegalArgumentException(\"vector dimensions differ: \" + a.length() + \"!=\" + b.length());\n    }\n    float dotProduct = impl.dotProduct(a, 0, b, 0, a.length());\n    float magnitudeA = (float) Math.sqrt(impl.dotProduct(a, 0, a, 0, a.length()));\n    float magnitudeB = (float) Math.sqrt(impl.dotProduct(b, 0, b, 0, b.length()));\n    \n    float cosineSimilarity = dotProduct / (magnitudeA * magnitudeB);\n    assert Float.isFinite(cosineSimilarity) : String.format(\"cosine(%s, %s) = %s\", a, b, cosineSimilarity);\n    \n    return cosineSimilarity;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphSearcher.java-search": "```java\n/**\n * Convenience function for simple one-off searches. It is caller's responsibility to make sure that it\n * is the unique owner of the vectors instance passed in here.\n */\npublic static SearchResult search(VectorFloat<?> queryVector, int topK, RandomAccessVectorValues vectors, VectorSimilarityFunction similarityFunction, GraphIndex graph, Bits acceptOrds) {\n    SearchScoreProvider scoreProvider = new SearchScoreProvider(vectors, queryVector, similarityFunction);\n    GraphSearcher searcher = new GraphSearcher(graph);\n    return searcher.search(scoreProvider, topK, acceptOrds);\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-nodesCopy": "```\npublic int[] nodesCopy() {\n    int size = heap.size();\n    int[] nodes = new int[size];\n    for (int i = 0; i < size; i++) {\n        long heapValue = heap.get(i + 1);\n        nodes[i] = decodeNodeId(heapValue);\n    }\n    return nodes;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeQueue.java-rerank": "```java\npublic float rerank(int topK, ScoreFunction.ExactScoreFunction reranker, float rerankFloor, NodeQueue reranked, NodesUnsorted unused) {\n    // Temporary structure to hold nodes until reranked into NodeQueue.\n    List<Node> candidates = new ArrayList<>();\n    int size = this.size();\n\n    // Extract all nodes from current queue into candidates list\n    for (int i = 0; i < size; i++) {\n        long heapValue = this.heap.get(i + 1);\n        int nodeId = decodeNodeId(heapValue);\n        float score = decodeScore(heapValue);\n        candidates.add(new Node(nodeId, score));\n    }\n\n    // Sort candidates by approximate score\n    candidates.sort(Comparator.comparingDouble(Node::getScore).reversed());\n\n    // Rerank top candidates\n    float worstScoreInTopK = Float.NEGATIVE_INFINITY;\n    for (int i = 0; i < min(topK, candidates.size()); i++) {\n        Node candidate = candidates.get(i);\n        float exactScore = reranker.compute(candidate.nodeId);\n        if (i == 0 || exactScore >= rerankFloor) {\n            reranked.push(candidate.nodeId, exactScore);\n            if (i == min(topK, candidates.size()) - 1) {\n                worstScoreInTopK = exactScore;\n            }\n        } else {\n            unused.add(candidate.nodeId, candidate.score);\n        }\n    }\n\n    // Move unused candidates that are not in topK into the unused structure\n    for (int i = topK; i < candidates.size(); i++) {\n        Node candidate = candidates.get(i);\n        unused.add(candidate.nodeId, candidate.score);\n    }\n\n    return worstScoreInTopK;\n}\n\nprivate static class Node {\n    final int nodeId;\n    final float score;\n\n    Node(int nodeId, float score) {\n        this.nodeId = nodeId;\n        this.score = score;\n    }\n\n    public int getNodeId() {\n        return nodeId;\n    }\n\n    public float getScore() {\n        return score;\n    }\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-merge": "```java\nstatic NodeArray merge(NodeArray a1, NodeArray a2) {\n    // Determine the new node array size\n    int newSize = a1.size() + a2.size();\n    \n    // Create a new NodeArray with the calculated size\n    NodeArray mergedArray = new NodeArray(newSize);\n\n    int index1 = 0, index2 = 0, mergedIndex = 0;\n    // Merge a1 and a2 into mergedArray, preserving sort order by scores\n    while (index1 < a1.size() && index2 < a2.size()) {\n        if (a1.getScore(index1) >= a2.getScore(index2)) {\n            mergedArray.nodes[mergedIndex] = a1.getNode(index1);\n            mergedArray.scores[mergedIndex] = a1.getScore(index1);\n            index1++;\n        } else {\n            mergedArray.nodes[mergedIndex] = a2.getNode(index2);\n            mergedArray.scores[mergedIndex] = a2.getScore(index2);\n            index2++;\n        }\n        mergedIndex++;\n    }\n\n    // If there are remaining elements in a1, add them\n    while (index1 < a1.size()) {\n        mergedArray.nodes[mergedIndex] = a1.getNode(index1);\n        mergedArray.scores[mergedIndex] = a1.getScore(index1);\n        mergedIndex++;\n        index1++;\n    }\n\n    // If there are remaining elements in a2, add them\n    while (index2 < a2.size()) {\n        mergedArray.nodes[mergedIndex] = a2.getNode(index2);\n        mergedArray.scores[mergedIndex] = a2.getScore(index2);\n        mergedIndex++;\n        index2++;\n    }\n\n    // Set the size of the new mergedArray\n    mergedArray.size = mergedIndex;\n\n    return mergedArray;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-addInOrder": "```java\npublic void addInOrder(int newNode, float newScore) {\n    if (size == nodes.length) {\n        growArrays();\n    }\n\n    // Find the insertion point, which in this case should be at the end due to the constraint\n    int insertionPoint = size;\n\n    // Insert the new node and score at the end\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    \n    // Increase the size to account for the newly added node\n    size++;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-insertSorted": "```java\npublic int insertSorted(int newNode, float newScore) {\n    int insertionPoint = descSortFindRightMostInsertionPoint(newScore);\n\n    // Check if a duplicate node+score pair exists near the insertion point\n    if (duplicateExistsNear(insertionPoint, newNode, newScore)) {\n        return -1; // return -1 if it already existed\n    }\n\n    // Ensure there is enough space to insert the new node\n    if (size == nodes.length) {\n        growArrays();\n    }\n\n    // Move elements to make space for the new node\n    if (insertionPoint < size) {\n        System.arraycopy(nodes, insertionPoint, nodes, insertionPoint + 1, size - insertionPoint);\n        System.arraycopy(scores, insertionPoint, scores, insertionPoint + 1, size - insertionPoint);\n    }\n\n    // Insert new node and score\n    nodes[insertionPoint] = newNode;\n    scores[insertionPoint] = newScore;\n    size++;\n\n    return insertionPoint; // return the insertion point of the new node\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodeArray.java-retain": "```java\npublic void retain(Bits selected) {\n    int retainedCount = 0;\n\n    for (int i = 0; i < size; i++) {\n        if (selected.get(i)) {\n            nodes[retainedCount] = nodes[i];\n            scores[retainedCount] = scores[i];\n            retainedCount++;\n        }\n    }\n\n    size = retainedCount;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/NodesUnsorted.java-add": "```java\n/**\n * Add a new node to the NodeArray. The new node must be worse than all previously stored\n * nodes.\n */\npublic void add(int newNode, float newScore) {\n    // Check if the size of current nodes array has reached its limit, grow the arrays if necessary\n    if (size == node.length) {\n        growArrays();\n    }\n\n    // Since newNode is worse than all existing nodes, simply add it at the end\n    node[size] = newNode;\n    score[size] = newScore;\n    \n    // Increment the size to reflect addition of the new node\n    size++;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/ConcurrentNeighborMap.java-addNode": "```java\nvoid addNode(int nodeId, NodeArray nodes) {\n    // Add the new node with the given nodeId and its neighbors represented by 'nodes' to the neighbors map.\n    // Initialize a Neighbors object with the nodeId and the supplied NodeArray.\n    Neighbors newNodeNeighbors = new Neighbors(nodeId, nodes);\n\n    // Insert this new Neighbors object into the DenseIntMap 'neighbors', using nodeId as the key.\n    // This is done to keep track of the node's neighbors in the ConcurrentNeighborMap.\n    neighbors.put(nodeId, newNodeNeighbors);\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/GraphIndexBuilder.java-removeDeletedNodes": "```java\npublic synchronized long removeDeletedNodes() {\n    // Initialize the amount of memory freed counter\n    long memoryFreed = 0L;\n\n    // Create a set to hold nodes that were deleted during this operation\n    Set<Integer> deletedNodes = ConcurrentHashMap.newKeySet();\n\n    // Iterate over all nodes in the graph\n    for (int node = 0; node < graph.getIdUpperBound(); node++) {\n        // Skip nodes that are not marked for deletion\n        if (!graph.getDeletedNodes().get(node)) {\n            continue;\n        }\n\n        // Remove the node from the graph\n        graph.removeNode(node);\n        deletedNodes.add(node);\n\n        // Update the memory freed counter with the size of the node and its edges\n        memoryFreed += graph.ramBytesUsedOneNode();\n    }\n\n    // Remove references to deleted nodes in neighbors' lists\n    for (int node = 0; node < graph.getIdUpperBound(); node++) {\n        if (!graph.containsNode(node)) {\n            continue;\n        }\n\n        NodeArray neighbors = graph.getNeighbors(node);\n        for (int i = 0; i < neighbors.size(); i++) {\n            int neighbor = neighbors.getNode(i);\n            if (deletedNodes.contains(neighbor)) {\n                neighbors.removeNode(i);\n                i--; // adjust the index because of the removal\n            }\n        }\n    }\n\n    // Return the total memory freed\n    return memoryFreed;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-writeInline": "```java\npublic synchronized void writeInline(int ordinal, Map<FeatureId, Feature.State> stateMap) throws IOException {\n    // Calculate the offset for the given ordinal\n    long offset = featureOffsetForOrdinal(ordinal);\n    \n    // Seek to the calculated offset in the output writer\n    out.seek(offset);\n\n    // Write the ordinal to the output\n    out.writeInt(ordinal);\n\n    // Iterate over the featureMap to get features and their corresponding states from the stateMap\n    for (Map.Entry<FeatureId, Feature> entry : featureMap.entrySet()) {\n        FeatureId featureId = entry.getKey();\n        Feature feature = entry.getValue();\n\n        // Get the feature state from the stateMap\n        Feature.State featureState = stateMap.get(featureId);\n\n        // If a featureState is provided, write it inline\n        if (featureState != null) {\n            feature.writeInline(out, featureState);\n        }\n    }\n\n    // Update the maxOrdinalWritten\n    maxOrdinalWritten = Math.max(maxOrdinalWritten, ordinal);\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndexWriter.java-sequentialRenumbering": "```java\npublic static Map<Integer, Integer> sequentialRenumbering(GraphIndex graph) {\n    Int2IntHashMap oldToNewOrdinals = new Int2IntHashMap(-1);\n    int nextOrdinal = 0;\n\n    for (int ordinal : graph.getOrdinals()) {\n        oldToNewOrdinals.put(ordinal, nextOrdinal++);\n    }\n\n    return oldToNewOrdinals;\n}\n```", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/disk/OnDiskGraphIndex.java-write": "Based on the provided Java snippet and the natural language annotations, here's how the `write` function can be implemented. This function is intended to write a \"vanilla DiskANN-style index\" without extra features:\n\n```java\npublic static void write(GraphIndex graph, RandomAccessVectorValues vectors, Path path) throws IOException {\n    try (OnDiskGraphIndexWriter writer = new OnDiskGraphIndexWriter(path)) {\n        // Start writing the basic structure\n        writer.writeHeader(graph.size(), graph.maxDegree(), graph.dimension(), graph.entryNode());\n\n        // Iterate through each node to write its vector and other properties\n        for (int node = 0; node < graph.size(); node++) {\n            // Write the vector for the current node\n            VectorFloat<?> vector = vectors.getVector(node);\n            writer.writeVector(vector);\n\n            // Write neighbor details\n            NodesIterator neighborsIterator = graph.getView().getNeighborsIterator(node);\n            writer.writeNeighbors(neighborsIterator);\n        }\n    } catch (IOException e) {\n        throw new IOException(\"Failed to write the DiskANN-style index to the specified path.\", e);\n    }\n}\n```\n\n### Explanation:\n- **Header Writing**: The method starts by writing the header using the `OnDiskGraphIndexWriter` instance. The graph's size, maximum degree, dimension, and entry node are written first.\n- **Vector and Neighbors Writing**: It iterates over each node, retrieves its vector, and writes the vector to disk. Subsequently, it handles the neighbors of the node using `getNeighborsIterator`.\n- **Error Handling**: It captures `IOException` and rethrows it with an explanatory message, ensuring clarity if an error occurs during writing.", "jvector-jvector-base/src/main/java/io/github/jbellis/jvector/graph/similarity/BuildScoreProvider.java-randomAccessScoreProvider": "```java\nstatic BuildScoreProvider randomAccessScoreProvider(RandomAccessVectorValues ravv, VectorSimilarityFunction similarityFunction) {\n    return new BuildScoreProvider() {\n        @Override\n        public boolean isExact() {\n            return true;\n        }\n\n        @Override\n        public SearchScoreProvider diversityProviderFor(int node1) {\n            VectorFloat<?> vector = ravv.getVector(node1);\n            return new SearchScoreProvider(similarityFunction.similarityProvider(vector));\n        }\n\n        @Override\n        public SearchScoreProvider searchProviderFor(int node1) {\n            VectorFloat<?> vector = ravv.getVector(node1);\n            return searchProviderFor(vector);\n        }\n\n        @Override\n        public SearchScoreProvider searchProviderFor(VectorFloat<?> vector) {\n            return new SearchScoreProvider(similarityFunction.similarityProvider(vector));\n        }\n\n        @Override\n        public VectorFloat<?> approximateCentroid() {\n            // This is a stub method. You would implement the logic to compute\n            // the exact centroid based on RandomAccessVectorValues.\n            return VectorUtil.computeExactCentroid(ravv);\n        }\n    };\n}\n```", "timefold-solver-benchmark/src/main/java/ai/timefold/solver/benchmark/impl/statistic/StatisticUtils.java-determineStandardDeviationDoubles": "```java\npublic static double[] determineStandardDeviationDoubles(List<BenchmarkResult> benchmarkResults, double averageScore) {\n    if (benchmarkResults == null || benchmarkResults.isEmpty()) {\n        throw new IllegalArgumentException(\"Benchmark results cannot be null or empty.\");\n    }\n\n    int n = benchmarkResults.size();\n    double sumOfSquaredDifferences = 0.0;\n\n    for (BenchmarkResult result : benchmarkResults) {\n        double score = result.getAverageScore().getScoreValue();  // Assuming getScoreValue() returns a double representation, otherwise adjust accordingly\n        double difference = score - averageScore;\n        sumOfSquaredDifferences += difference * difference;\n    }\n\n    double variance = sumOfSquaredDifferences / n;\n    double standardDeviation = Math.sqrt(variance);\n\n    return new double[] { standardDeviation };\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-stack": "```java\npublic StackMetadata stack(ValueSourceInfo... types) {\n    StackMetadata out = copy();\n    // Clear the existing stackValueSources\n    out.stackValueSources.clear();\n    // Add the given types as the new stack\n    out.stackValueSources.addAll(Arrays.asList(types));\n    return out;\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/StackMetadata.java-locals": "```java\npublic StackMetadata locals(ValueSourceInfo... types) {\n    if (types.length != localVariableValueSources.size()) {\n        throw new IllegalArgumentException(\"Number of provided types does not match the size of local variables.\");\n    }\n    StackMetadata out = copy();\n    for (int i = 0; i < types.length; i++) {\n        out.localVariableValueSources.set(i, types[i]);\n    }\n    return out;\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-loadMethod": "```java\npublic static void loadMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, \n        MethodVisitor methodVisitor, int nameIndex) {\n    // Duplicate top of stack to prepare for type checking\n    methodVisitor.visitInsn(Opcodes.DUP);\n    \n    // Get the type of the object on top of the stack\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeObject.class),\n            \"$getType\", Type.getMethodDescriptor(Type.getType(PythonLikeType.class)), true);\n    \n    // Load method name from the co_names list using the provided nameIndex\n    methodVisitor.visitLdcInsn(functionMetadata.pythonCompiledFunction.co_names.get(nameIndex));\n    \n    // Attempt to load the method from the type\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEVIRTUAL, Type.getInternalName(PythonLikeType.class),\n            \"loadMethod\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class), Type.getType(String.class)),\n            false);\n    \n    // Duplicate the result to check if it's not null\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n    // Create a label for jump instruction\n    Label blockEnd = new Label();\n    \n    // If the method is not null, jump to blockEnd\n    methodVisitor.visitJumpInsn(Opcodes.IF_ACMPNE, blockEnd);\n\n    // TOS is null; type does not have attribute; do normal attribute lookup\n    // Pop the DUP-ed result that was null\n    methodVisitor.visitInsn(Opcodes.POP);\n    \n    // Perform attribute lookup (loads the method or attribute if available)\n    ObjectImplementor.getAttribute(functionMetadata, stackMetadata, nameIndex);\n    \n    // Push null if the method was not in type (to indicate unbound method)\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n    if (functionMetadata.pythonCompiledFunction.pythonVersion.isBefore(PythonVersion.PYTHON_3_11)) {\n        methodVisitor.visitInsn(Opcodes.SWAP);\n    }\n    \n    // Mark end of the null checking block\n    methodVisitor.visitLabel(blockEnd);\n\n    // Swap stack to place the object below the method or null\n    methodVisitor.visitInsn(Opcodes.SWAP);\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callMethod": "```java\npublic static void callMethod(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor) {\n    // Stack is: method, (obj or null), arg0, ..., arg(argc - 1)\n    CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, stackMetadata.getArgumentCount());\n    methodVisitor.visitInsn(Opcodes.SWAP);\n    \n    // Stack is: method, argList, (obj or null)\n    Label ifNullStart = new Label();\n    Label blockEnd = new Label();\n\n    methodVisitor.visitInsn(Opcodes.DUP);\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n    methodVisitor.visitJumpInsn(Opcodes.IF_ACMPEQ, ifNullStart);\n\n    // Stack is method, argList, obj\n    StackManipulationImplementor.swap(methodVisitor);\n\n    // Stack is: method, obj, argList\n    methodVisitor.visitInsn(Opcodes.ICONST_0);\n\n    // Stack is: method, obj, argList, index, obj\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Stack is method, obj, argList, obj, index\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Stack is method, obj, index, argList, obj\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(List.class),\n            \"add\",\n            Type.getMethodDescriptor(Type.VOID_TYPE, Type.INT_TYPE, Type.getType(Object.class)),\n            true);\n\n    // Stack is method, argList\n    methodVisitor.visitJumpInsn(Opcodes.GOTO, blockEnd);\n\n    methodVisitor.visitLabel(ifNullStart);\n    // Stack is: method, argList, null\n    methodVisitor.visitInsn(Opcodes.POP);\n\n    // Stack is: method, argList\n    methodVisitor.visitLabel(blockEnd);\n\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n            Type.getMethodDescriptor(Type.getType(Map.class)),\n            false);\n\n    // Stack is: method, argList, emptyMap\n    methodVisitor.visitInsn(Opcodes.ACONST_NULL);\n\n    // Stack is: callable, argument_list, emptyMap, null\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunction": "```java\npublic static void callFunction(FunctionMetadata functionMetadata, StackMetadata stackMetadata, MethodVisitor methodVisitor, int argCount) {\n    // stack is callable, arg0, arg1, ..., arg(argc - 1)\n    \n    // Create a collection from the arguments on the stack\n    CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, argCount);\n    \n    // Generate a call to Collections.emptyMap() to push an empty map (for keyword arguments) onto the stack\n    methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n            Type.getMethodDescriptor(Type.getType(Map.class)),\n            false);\n\n    // Get the caller instance\n    getCallerInstance(functionMetadata, stackMetadata);\n\n    // Call the function represented by the callable on top of the stack\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionWithKeywords": "```java\npublic static void callFunctionWithKeywords(FunctionMetadata functionMetadata, StackMetadata stackMetadata,\n        MethodVisitor methodVisitor, PythonBytecodeInstruction instruction) {\n    // stack is tuple of keyword names, kwargs, arg(argc), ..., arg1, callable\n\n    // Exchange the callable and keyword names tuple\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Prepare for constructing the TupleMapPair\n    int keywordNamesIndex = stackMetadata.getStackSize() - instruction.arg() - 3;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    // Store keyword names in a local variable\n    localVariableHelper.writeTemp(methodVisitor, Type.getType(PythonLikeTuple.class), keywordNamesIndex);\n\n    // Build tuple from positional arguments\n    CollectionImplementor.buildCollection(PythonLikeTuple.class, methodVisitor, instruction.arg());\n\n    // Retrieve keyword names and add to tuple\n    localVariableHelper.readTemp(methodVisitor, Type.getType(PythonLikeTuple.class), keywordNamesIndex);\n\n    // Exchange the tuple of positional arguments and tuple of keyword names\n    methodVisitor.visitInsn(Opcodes.SWAP);\n\n    // Build the TupleMapPair\n    CollectionImplementor.buildCollection(TupleMapPair.class, methodVisitor, 2);\n\n    // Retrieve keyword arguments map\n    methodVisitor.visitInsn(Opcodes.SWAP);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, Type.getInternalName(TupleMapPair.class), \"map\",\n            Type.getDescriptor(PythonLikeDict.class));\n\n    getCallerInstance(functionMetadata, stackMetadata);\n\n    // Call the function\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n    \n    // Cleanup\n    localVariableHelper.freeLocal();\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/FunctionImplementor.java-callFunctionUnpack": "```java\npublic static void callFunctionUnpack(FunctionMetadata functionMetadata, \n                                      StackMetadata stackMetadata,\n                                      MethodVisitor methodVisitor,\n                                      PythonBytecodeInstruction instruction) {\n\n    boolean hasKeywordArguments = (instruction.arg() & 1) == 1;\n\n    if (hasKeywordArguments) {\n        // Stack is TOS: mapping (keywords), TOS[1]: iterable (positional), TOS[2]: callable\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        // Stack is TOS: iterable (positional), TOS[1]: mapping (keywords), TOS[2]: callable\n        methodVisitor.visitInsn(Opcodes.DUP_X1);\n        // Stack is TOS: mapping (keywords), TOS[1]: iterable (positional), TOS[2]: mapping (keywords), TOS[3]: callable\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        // Stack is TOS: iterable (positional), TOS[1]: mapping (keywords), TOS[2]: callable, TOS[3]: iterable (positional)\n        getCallerInstance(functionMetadata, stackMetadata);\n        // Stack is callable, iterable (positional), mapping (keywords), null\n    } else {\n        // Stack is TOS: iterable (positional), TOS[1]: callable\n        methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(Collections.class), \"emptyMap\",\n                Type.getMethodDescriptor(Type.getType(Map.class)), false);\n        // Stack is TOS: iterable (positional), callable, emptyMap\n        getCallerInstance(functionMetadata, stackMetadata);\n        // Stack is callable, iterable (positional), emptyMap, null\n    }\n\n    // Call the function\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonLikeFunction.class),\n            \"$call\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class),\n                    Type.getType(List.class),\n                    Type.getType(Map.class),\n                    Type.getType(PythonLikeObject.class)),\n            true);\n\n    // Handling for Python 3.11+\n    if (functionMetadata.pythonCompiledFunction.pythonVersion.isAtLeast(PythonVersion.PYTHON_3_11)) {\n        methodVisitor.visitInsn(Opcodes.SWAP);\n        methodVisitor.visitInsn(Opcodes.POP);\n    }\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadGlobalVariable": "```\npublic static void loadGlobalVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int globalIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    PythonCompiledFunction pythonCompiledFunction = functionMetadata.pythonCompiledFunction;\n    String globalName = pythonCompiledFunction.co_names.get(globalIndex);\n\n    // Load interpreter instance onto the stack\n    methodVisitor.visitVarInsn(Opcodes.ALOAD, 0);\n    methodVisitor.visitFieldInsn(Opcodes.GETFIELD, pythonCompiledFunction.className,\n            PythonBytecodeToJavaBytecodeTranslator.INTERPRETER_INSTANCE_FIELD_NAME,\n            Type.getDescriptor(PythonInterpreter.class));\n\n    // Load globals map onto the stack\n    methodVisitor.visitFieldInsn(Opcodes.GETSTATIC, pythonCompiledFunction.className,\n            PythonBytecodeToJavaBytecodeTranslator.GLOBALS_MAP_STATIC_FIELD_NAME,\n            Type.getDescriptor(Map.class));\n\n    // Load the global variable name onto the stack\n    methodVisitor.visitLdcInsn(globalName);\n\n    // Call interpreter's getGlobal method to load the global variable\n    methodVisitor.visitMethodInsn(Opcodes.INVOKEINTERFACE, Type.getInternalName(PythonInterpreter.class),\n            \"getGlobal\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class), Type.getType(Map.class),\n                    Type.getType(String.class)),\n            true);\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/VariableImplementor.java-loadCellVariable": "```java\npublic static void loadCellVariable(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int cellIndex) {\n    MethodVisitor methodVisitor = functionMetadata.methodVisitor;\n    LocalVariableHelper localVariableHelper = stackMetadata.localVariableHelper;\n\n    // Load the cell variable indicated by the cellIndex onto the stack\n    localVariableHelper.readCell(methodVisitor, cellIndex);\n}\n```", "timefold-solver-python/jpyinterpreter/src/main/java/ai/timefold/jpyinterpreter/implementors/ObjectImplementor.java-getAttribute": "```java\npublic static void getAttribute(FunctionMetadata functionMetadata, StackMetadata stackMetadata, int nameIndex) {\n    var methodVisitor = functionMetadata.methodVisitor;\n    String name = functionMetadata.pythonCompiledFunction.co_names.get(nameIndex);\n    PythonLikeType tosType = stackMetadata.getTOSType();\n    Optional<FieldDescriptor> maybeFieldDescriptor = tosType.getInstanceFieldDescriptor(name);\n\n    if (maybeFieldDescriptor.isPresent()) {\n        FieldDescriptor fieldDescriptor = maybeFieldDescriptor.get();\n        methodVisitor.visitTypeInsn(Opcodes.CHECKCAST, fieldDescriptor.declaringClassInternalName());\n        methodVisitor.visitFieldInsn(Opcodes.GETFIELD, fieldDescriptor.declaringClassInternalName(), \n                                     fieldDescriptor.javaFieldName(), \n                                     fieldDescriptor.javaFieldTypeDescriptor());\n        if (fieldDescriptor.isJavaType()) {\n            // Wrap the Java object to a PythonLikeObject if needed\n            methodVisitor.visitMethodInsn(Opcodes.INVOKESTATIC, Type.getInternalName(JavaObjectWrapper.class),\n                                          \"wrap\", Type.getMethodDescriptor(Type.getType(PythonLikeObject.class), \n                                                                           Type.getType(Object.class)),\n                                          false);\n        }\n    } else {\n        PythonConstantsImplementor.loadName(methodVisitor, functionMetadata.pythonCompiledFunction.co_names, nameIndex);\n        DunderOperatorImplementor.binaryOperator(methodVisitor,\n                                                 stackMetadata.pushTemp(BuiltinTypes.STRING_TYPE),\n                                                 PythonBinaryOperator.GET_ATTRIBUTE);\n    }\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/descriptor/SolutionDescriptor.java-getProblemScale": "```java\npublic double getProblemScale(ScoreDirector<Solution_> scoreDirector, Solution_ solution) {\n    Objects.requireNonNull(solution, \"Solution must not be null\");\n\n    // Initialize problem scale based on problem facts and entities\n    double problemScale = 0.0;\n\n    // Calculate the contribution of the planning entities to the problem scale\n    for (EntityDescriptor<Solution_> entityDescriptor : entityDescriptorMap.values()) {\n        Collection<?> planningEntities = entityDescriptor.extractEntities(solution);\n        for (Object entity : planningEntities) {\n            problemScale += entityDescriptor.getVariableDescriptors().stream()\n                    .filter(variableDescriptor -> variableDescriptor instanceof GenuineVariableDescriptor)\n                    .mapToDouble(variableDescriptor -> {\n                        if (variableDescriptor instanceof ListVariableDescriptor) {\n                            return MathUtils.factorial(((ListVariableDescriptor<Solution_>) variableDescriptor)\n                                    .getValueCount(solution, entity));\n                        } else {\n                            return Math.log10(((GenuineVariableDescriptor<Solution_>) variableDescriptor)\n                                    .getValueCount(solution, entity));\n                        }\n                    }).sum();\n        }\n    }\n    \n    // Calculate the contribution of the problem facts\n    problemScale += problemFactOrEntityClassSet.stream()\n            .mapToDouble(problemFactClass -> {\n                Collection<?> problemFacts = ReflectionHelper.extractMemberValue(solution, problemFactClass);\n                return Math.log10(problemFacts.size());\n            }).sum();\n    \n    return Math.max(0.0, problemScale);\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/solution/cloner/gizmo/GizmoSolutionClonerImplementor.java-defineClonerFor": "```java\npublic static void defineClonerFor(\n    Supplier<GizmoSolutionClonerImplementor> implementorSupplier,\n    ClassCreator classCreator,\n    SolutionDescriptor<?> solutionDescriptor,\n    Set<Class<?>> solutionClassSet,\n    Map<Class<?>, GizmoSolutionOrEntityDescriptor> memoizedSolutionOrEntityDescriptorMap,\n    Set<Class<?>> deepClonedClassSet\n) {\n    GizmoSolutionClonerImplementor implementor = implementorSupplier.get();\n    // Classes that are not instances of any other class in the collection have a subclass level of 0.\n    // Other classes subclass level is the maximum of the subclass level of the classes it is a subclass of + 1\n    Set<Class<?>> deepCloneClassesThatAreNotSolutionSet =\n        deepClonedClassSet.stream()\n            .filter(clazz -> !solutionClassSet.contains(clazz) && !clazz.isArray())\n            .filter(clazz -> !clazz.isInterface() && !Modifier.isAbstract(clazz.getModifiers()))\n            .collect(Collectors.toSet());\n\n    Comparator<Class<?>> instanceOfComparator = getInstanceOfComparator(deepClonedClassSet);\n    SortedSet<Class<?>> deepCloneClassesThatAreNotSolutionSortedSet = new TreeSet<>(instanceOfComparator);\n    deepCloneClassesThatAreNotSolutionSortedSet.addAll(deepCloneClassesThatAreNotSolutionSet);\n\n    implementor.createFields(classCreator);\n    implementor.createConstructor(classCreator);\n    implementor.createSetSolutionDescriptor(classCreator, solutionDescriptor);\n    implementor.createCloneSolution(classCreator, solutionDescriptor);\n    implementor.createCloneSolutionRun(classCreator, solutionDescriptor, solutionClassSet,\n        memoizedSolutionOrEntityDescriptorMap,\n        deepCloneClassesThatAreNotSolutionSortedSet, instanceOfComparator);\n\n    for (Class<?> deepClonedClass : deepCloneClassesThatAreNotSolutionSortedSet) {\n        implementor.createDeepCloneHelperMethod(classCreator, deepClonedClass, solutionDescriptor,\n            memoizedSolutionOrEntityDescriptorMap,\n            deepCloneClassesThatAreNotSolutionSortedSet);\n    }\n\n    Set<Class<?>> abstractDeepCloneClassSet =\n        deepClonedClassSet.stream()\n            .filter(clazz -> !solutionClassSet.contains(clazz) && !clazz.isArray())\n            .filter(clazz -> clazz.isInterface() || Modifier.isAbstract(clazz.getModifiers()))\n            .collect(Collectors.toSet());\n\n    for (Class<?> abstractDeepClonedClass : abstractDeepCloneClassSet) {\n        implementor.createAbstractDeepCloneHelperMethod(classCreator, abstractDeepClonedClass, solutionDescriptor,\n            memoizedSolutionOrEntityDescriptorMap,\n            deepCloneClassesThatAreNotSolutionSortedSet);\n    }\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/variable/listener/support/violation/ShadowVariablesAssert.java-createShadowVariablesViolationMessage": "```java\npublic String createShadowVariablesViolationMessage(long violationDisplayLimit) {\n    // Collect the violations based on previously taken snapshots of shadow variables.\n    Map<ShadowVariableDescriptor<?>, List<String>> violationListMap = collectViolations();\n    \n    // If there are no violations, return null as per the documentation.\n    if (violationListMap.isEmpty()) {\n        return null;\n    }\n    \n    // Format the collected violations into a readable message string.\n    return format(violationListMap, violationDisplayLimit);\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/MemberAccessorFactory.java-buildAndCacheMemberAccessor": "```java\npublic MemberAccessor buildAndCacheMemberAccessor(Member member, MemberAccessorType memberAccessorType,\n        Class<? extends Annotation> annotationClass, DomainAccessType domainAccessType) {\n    String generatedClassName = GizmoMemberAccessorFactory.getGeneratedClassName(member);\n\n    return memberAccessorCache.computeIfAbsent(generatedClassName,\n            k -> MemberAccessorFactory.buildMemberAccessor(member, memberAccessorType, annotationClass, domainAccessType, gizmoClassLoader));\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorFactory.java-getGeneratedClassName": "```java\npublic static String getGeneratedClassName(Member member) {\n    Objects.requireNonNull(member, \"The member must not be null.\");\n    \n    // Assuming that the generated class name would be based on member's declaring class and name\n    String declaringClassName = member.getDeclaringClass().getName();\n    String memberName = member.getName();\n    \n    // Construct the generated class name using a naming convention\n    // This is a placeholder convention\n    String generatedClassName = declaringClassName + \"$Generated$\" + memberName + \"Accessor\";\n    \n    return generatedClassName;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/domain/common/accessor/gizmo/GizmoMemberAccessorImplementor.java-createAccessorFor": "```java\nstatic MemberAccessor createAccessorFor(Member member, Class<? extends Annotation> annotationClass, boolean returnTypeRequired, GizmoClassLoader gizmoClassLoader) {\n    // Retrieve information about the member to create the accessor for.\n    GizmoMemberInfo memberInfo = GizmoMemberInfo.of(member, annotationClass, returnTypeRequired);\n\n    // Determine the correct class name for the accessor\n    String className = memberInfo.generateClassName();\n\n    // Check if the class has already been loaded; if not, generate the bytecode\n    if (!gizmoClassLoader.isClassAlreadyLoaded(className)) {\n        // Use Gizmo API to generate bytecode for the MemberAccessor\n        ClassOutput classOutput = gizmoClassLoader.getClassOutput();\n        \n        // Invoke the defineAccessorFor method to generate the accessor class\n        GizmoMemberAccessorImplementor.defineAccessorFor(className, classOutput, memberInfo);\n        \n        // Make sure the class is registered with the class loader\n        gizmoClassLoader.registerClass(className);\n    }\n\n    // Create an instance of the newly generated MemberAccessor class\n    return GizmoMemberAccessorImplementor.createInstance(className, gizmoClassLoader);\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-set": "```java\nvoid set(Solution_ bestSolution, BooleanSupplier isEveryProblemChangeProcessed) {\n    problemChangesLock.lock();\n    try {\n        // Check if all problem changes are processed.\n        if (isEveryProblemChangeProcessed.getAsBoolean()) {\n            // Increment the version.\n            currentVersion = currentVersion.add(BigInteger.ONE);\n            // Set the new versioned best solution.\n            versionedBestSolutionRef.set(new VersionedBestSolution<>(bestSolution, currentVersion));\n        }\n    } finally {\n        problemChangesLock.unlock();\n    }\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/BestSolutionHolder.java-addProblemChange": "```java\npublic CompletableFuture<Void> addProblemChange(Solver<Solution_> solver, ProblemChange<Solution_> problemChange) {\n    // Lock to ensure thread safety while modifying shared resources\n    problemChangesLock.lock();\n    try {\n        // Increment the version for the new problem change\n        BigInteger newVersion = currentVersion.add(BigInteger.ONE);\n        currentVersion = newVersion;\n\n        // Create a CompletableFuture to be completed when the problem change is processed\n        CompletableFuture<Void> problemChangeFuture = new CompletableFuture<>();\n\n        // Register the problem change with the solver\n        solver.addProblemChange(problemChange);\n\n        // Add the CompletableFuture to the map to associate it with the current version\n        problemChangesPerVersion.computeIfAbsent(newVersion, k -> new ArrayList<>()).add(problemChangeFuture);\n\n        // Return the Future that will be completed once the best solution with the change is available\n        return problemChangeFuture;\n    } finally {\n        // Unlock the lock in a finally block to ensure it's always released\n        problemChangesLock.unlock();\n    }\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/random/RandomUtils.java-nextLong": "```java\npublic static long nextLong(Random random, long n) {\n    if (n <= 0) {\n        throw new IllegalArgumentException(\"n must be positive\");\n    }\n\n    long bits, val;\n    do {\n        bits = (random.nextLong() & Long.MAX_VALUE);\n        val = bits % n;\n    } while (bits - val + (n - 1) < 0);\n\n    return val;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculateSolverTimeGradient": "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double minTimeGradient = Double.MAX_VALUE;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient != -1.0) {\n            minTimeGradient = Math.min(minTimeGradient, timeGradient);\n        }\n    }\n    return minTimeGradient == Double.MAX_VALUE ? -1.0 : minTimeGradient;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/AndCompositeTermination.java-calculatePhaseTimeGradient": "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double minimumTimeGradient = Double.POSITIVE_INFINITY;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0) { // Ignore unsupported timeGradients\n            minimumTimeGradient = Math.min(minimumTimeGradient, timeGradient);\n        }\n    }\n    return (minimumTimeGradient == Double.POSITIVE_INFINITY) ? -1.0 : minimumTimeGradient;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculateSolverTimeGradient": "```java\n@Override\npublic double calculateSolverTimeGradient(SolverScope<Solution_> solverScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculateSolverTimeGradient(solverScope);\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/solver/termination/OrCompositeTermination.java-calculatePhaseTimeGradient": "```java\n@Override\npublic double calculatePhaseTimeGradient(AbstractPhaseScope<Solution_> phaseScope) {\n    double maxTimeGradient = -1.0;\n    for (Termination<Solution_> termination : terminationList) {\n        double timeGradient = termination.calculatePhaseTimeGradient(phaseScope);\n        if (timeGradient != -1.0) {\n            maxTimeGradient = Math.max(maxTimeGradient, timeGradient);\n        }\n    }\n    return maxTimeGradient;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/move/generic/list/kopt/KOptUtils.java-getCyclesForPermutation": "```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.BitSet;\n\nstatic KOptCycle getCyclesForPermutation(KOptDescriptor<?> kOptDescriptor) {\n    // Retrieve the permutation array from the KOptDescriptor\n    int[] removedEdgeIndexToTourOrder = kOptDescriptor.removedEdgeIndexToTourOrder();\n    int n = removedEdgeIndexToTourOrder.length;\n    \n    // BitSet to keep track of visited nodes\n    BitSet visited = new BitSet(n);\n    List<List<Integer>> cycles = new ArrayList<>();\n\n    // Traverse each node in the permutation\n    for (int start = 0; start < n; start++) {\n        if (!visited.get(start)) {\n            List<Integer> cycle = new ArrayList<>();\n            int current = start;\n            \n            // Follow the cycle until we return to the start\n            do {\n                cycle.add(current);\n                visited.set(current); \n                current = removedEdgeIndexToTourOrder[current];\n            } while (current != start);\n            \n            // If a valid cycle is found, add it to cycles\n            if (cycle.size() > 1) {\n                cycles.add(cycle);\n            }\n        }\n    }\n\n    // Construct KOptCycle from extracted cycles\n    return new KOptCycle(cycles);\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/impl/heuristic/selector/list/TriangleElementFactory.java-nextElement": "```java\nimport static ai.timefold.solver.core.impl.heuristic.selector.list.TriangularNumbers.nthTriangle;\nimport static ai.timefold.solver.core.impl.heuristic.selector.list.TriangularNumbers.triangularRoot;\n\npublic class TriangleElementFactory {\n\n    private final int minimumSubListSize;\n    private final int maximumSubListSize;\n    private final Random workingRandom;\n\n    TriangleElementFactory(int minimumSubListSize, int maximumSubListSize, Random workingRandom) {\n        if (minimumSubListSize > maximumSubListSize) {\n            throw new IllegalArgumentException(\"The minimumSubListSize (\" + minimumSubListSize\n                    + \") must be less than or equal to the maximumSubListSize (\" + maximumSubListSize + \").\");\n        }\n        if (minimumSubListSize < 1) {\n            throw new IllegalArgumentException(\n                    \"The minimumSubListSize (\" + minimumSubListSize + \") must be greater than 0.\");\n        }\n        this.minimumSubListSize = minimumSubListSize;\n        this.maximumSubListSize = maximumSubListSize;\n        this.workingRandom = workingRandom;\n    }\n\n    TriangleElement nextElement(int listSize) throws IllegalArgumentException {\n        if (listSize < minimumSubListSize) {\n            throw new IllegalArgumentException(\"The listSize (\" + listSize\n                    + \") must be equal to or greater than the minimumSubListSize (\" + minimumSubListSize + \").\");\n        }\n        \n        // Calculate the triangular number constraints to determine the valid range for random generation\n        int minTriangularLevel = triangularRoot(minimumSubListSize - 1); // Floor is handled by int division\n        int maxTriangularIndex = Math.min(nthTriangle(maximumSubListSize) - 1, nthTriangle(listSize) - 1);\n        \n        int randomIndex = workingRandom.nextInt(minTriangularLevel * (minTriangularLevel + 1) / 2, maxTriangularIndex + 1);\n        \n        return TriangleElement.valueOf(randomIndex);\n    }\n\n    record TriangleElement(int index, int level, int indexOnLevel) {\n        static TriangleElement valueOf(int index) {\n            int level = (int) Math.ceil(triangularRoot(index));\n            return new TriangleElement(index, level, index - nthTriangle(level - 1));\n        }\n    }\n}\n```\n", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/constraint/ConstraintMatch.java-getJustificationList": "```java\n@Deprecated(forRemoval = true)\npublic List<Object> getJustificationList() {\n    // Check the type of the justification.\n    if (justification instanceof DefaultConstraintJustification) {\n        // Return the facts (justification list) from the matching tuple for backwards compatibility.\n        return ((DefaultConstraintJustification) justification).getFacts();\n    } else {\n        // Throw an exception as custom justification mapping was provided.\n        throw new UnsupportedOperationException(\"Custom justification mapping provided. Use getJustification() instead.\");\n    }\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-compose": "```java\npublic static <A, Result_, SubResultContainer1_, SubResultContainer2_, SubResult1_, SubResult2_>\n    UniConstraintCollector<A, ?, Result_> compose(\n        UniConstraintCollector<A, SubResultContainer1_, SubResult1_> subCollector1,\n        UniConstraintCollector<A, SubResultContainer2_, SubResult2_> subCollector2,\n        BiFunction<SubResult1_, SubResult2_, Result_> composeFunction) {\n    \n    return new UniConstraintCollector<A, Object[], Result_>() {\n\n        @Override\n        public Supplier<Object[]> supplier() {\n            return () -> new Object[]{\n                subCollector1.supplier().get(),\n                subCollector2.supplier().get()\n            };\n        }\n\n        @Override\n        public BiConsumer<Object[], A> accumulator() {\n            BiConsumer<SubResultContainer1_, A> accumulator1 = subCollector1.accumulator();\n            BiConsumer<SubResultContainer2_, A> accumulator2 = subCollector2.accumulator();\n            return (resultContainer, a) -> {\n                accumulator1.accept((SubResultContainer1_) resultContainer[0], a);\n                accumulator2.accept((SubResultContainer2_) resultContainer[1], a);\n            };\n        }\n\n        @Override\n        public Function<Object[], Result_> finisher() {\n            Function<SubResultContainer1_, SubResult1_> finisher1 = subCollector1.finisher();\n            Function<SubResultContainer2_, SubResult2_> finisher2 = subCollector2.finisher();\n            return resultContainer -> composeFunction.apply(\n                finisher1.apply((SubResultContainer1_) resultContainer[0]),\n                finisher2.apply((SubResultContainer2_) resultContainer[1])\n            );\n        }\n\n        @Override\n        public Set<Characteristics> characteristics() {\n            Set<Characteristics> characteristics = new HashSet<>(subCollector1.characteristics());\n            characteristics.retainAll(subCollector2.characteristics());\n            return characteristics;\n        }\n    };\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/stream/ConstraintCollectors.java-toConnectedRanges": "```java\nimport ai.timefold.solver.core.api.score.stream.UniConstraintCollector;\nimport ai.timefold.solver.core.api.score.stream.common.ConnectedRangeChain;\nimport ai.timefold.solver.core.impl.score.stream.collector.uni.InnerUniConstraintCollectors;\n\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic final class ConstraintCollectors {\n\n    // ... other code ...\n\n    /**\n     * Creates a constraint collector that returns {@link ConnectedRangeChain} about the first fact.\n     *\n     * For instance, {@code [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]\n     *                      [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]}\n     * returns the following information:\n     *\n     * <pre>\n     * {@code\n     * ConnectedRanges: [minOverlap: 1, maxOverlap: 2,\n     *                  [Equipment fromInclusive=2, toExclusive=4] [Equipment fromInclusive=3, toExclusive=5]],\n     *                  [minConcurrentUsage: 1, maxConcurrentUsage: 1,\n     *                  [Equipment fromInclusive=6, toExclusive=7] [Equipment fromInclusive=7, toExclusive=8]]\n     * Breaks: [[Break from=5, to=6, length=1]]\n     * }\n     * </pre>\n     *\n     * This can be used to ensure a limited resource is not over-assigned.\n     *\n     * @param startInclusiveMap Maps the fact to its start\n     * @param endExclusiveMap Maps the fact to its end\n     * @param differenceFunction Computes the difference between two points. The second argument is always\n     *        larger than the first (ex: {@link Duration#between}\n     *        or {@code (a,b) -> b - a}).\n     * @param <A> type of the first mapped fact\n     * @param <PointType_> type of the fact endpoints\n     * @param <DifferenceType_> type of difference between points\n     * @return never null\n     */\n    public static <A, PointType_ extends Comparable<PointType_>, DifferenceType_ extends Comparable<DifferenceType_>> \n            UniConstraintCollector<A, ?, ConnectedRangeChain<A, PointType_, DifferenceType_>> \n            toConnectedRanges(Function<A, PointType_> startInclusiveMap,\n                              Function<A, PointType_> endExclusiveMap,\n                              BiFunction<PointType_, PointType_, DifferenceType_> differenceFunction) {\n        return InnerUniConstraintCollectors.toConnectedRanges(startInclusiveMap, endExclusiveMap, differenceFunction);\n    }\n\n    // ... other code ...\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-diff": "```java\npublic ScoreAnalysis<Score_> diff(ScoreAnalysis<Score_> other) {\n    Objects.requireNonNull(other, \"other must not be null\");\n\n    // Calculate the difference in scores\n    Score_ diffScore = this.score.subtract(other.score);\n\n    // Compare this constraint map to other's constraint map\n    Map<ConstraintRef, ConstraintAnalysis<Score_>> diffConstraintMap = new LinkedHashMap<>();\n\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> entry : this.constraintMap.entrySet()) {\n        ConstraintRef constraintRef = entry.getKey();\n        ConstraintAnalysis<Score_> thisAnalysis = entry.getValue();\n        ConstraintAnalysis<Score_> otherAnalysis = other.getConstraintAnalysis(constraintRef);\n\n        if (otherAnalysis == null) {\n            // If the other does not have a matching constraint, use this one\n            diffConstraintMap.put(constraintRef, thisAnalysis);\n        } else {\n            // Calculate the difference in constraint analysis\n            ConstraintAnalysis<Score_> diffAnalysis = thisAnalysis.diff(otherAnalysis);\n            if (!diffAnalysis.isZero()) {\n                diffConstraintMap.put(constraintRef, diffAnalysis);\n            }\n        }\n    }\n\n    // Check for constraints present in the `other` that are not in `this` and add their negative values\n    for (Map.Entry<ConstraintRef, ConstraintAnalysis<Score_>> entry : other.constraintMap.entrySet()) {\n        ConstraintRef constraintRef = entry.getKey();\n        if (!this.constraintMap.containsKey(constraintRef)) {\n            ConstraintAnalysis<Score_> negativeAnalysis = entry.getValue().negate();\n            diffConstraintMap.put(constraintRef, negativeAnalysis);\n        }\n    }\n\n    // Construct and return the new ScoreAnalysis with diff score and constraint map\n    return new ScoreAnalysis<>(diffScore, diffConstraintMap);\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ScoreAnalysis.java-summarize": "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n    summary.append(\"Score Analysis Summary:\\n\");\n    summary.append(\"Overall Score: \").append(score).append(\"\\n\");\n\n    if (!score.isFeasible()) {\n        summary.append(\"The solution is infeasible.\\n\");\n    }\n\n    summary.append(\"Constraints contributing to the score:\\n\");\n    int count = 0;\n    for (ConstraintAnalysis<Score_> constraintAnalysis : constraintAnalyses()) {\n        if (count >= DEFAULT_SUMMARY_CONSTRAINT_MATCH_LIMIT) {\n            summary.append(\"... and more constraints are present.\\n\");\n            break;\n        }\n        summary.append(\"- Constraint: \").append(constraintAnalysis.constraintRef()).append(\"\\n\");\n        summary.append(\"  Weight: \").append(constraintAnalysis.weight()).append(\"\\n\");\n        summary.append(\"  Impacts: \").append(constraintAnalysis.matchCount()).append(\" matches\\n\");\n        count++;\n    }\n\n    return summary.toString();\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/score/analysis/ConstraintAnalysis.java-summarize": "```java\n@SuppressWarnings(\"java:S3457\")\npublic String summarize() {\n    StringBuilder summary = new StringBuilder();\n\n    summary.append(\"Constraint Analysis Summary\\n\");\n    summary.append(\"----------------------------\\n\");\n    summary.append(\"Constraint: \").append(constraintName()).append(\"\\n\");\n    summary.append(\"Package: \").append(constraintPackage()).append(\"\\n\");\n    summary.append(\"Score: \").append(score).append(\"\\n\");\n    summary.append(\"Weight: \").append(weight).append(\"\\n\");\n\n    if (matches == null) {\n        summary.append(\"Matches: No score analysis available\\n\");\n    } else if (matches.isEmpty()) {\n        summary.append(\"Matches: No matches, but non-zero constraint weight\\n\");\n    } else {\n        summary.append(\"Number of Matches: \").append(matches.size()).append(\"\\n\");\n        summary.append(\"Matches:\\n\");\n\n        matches.forEach(match -> {\n            summary.append(\"  - Justification: \").append(match.justification()).append(\"\\n\");\n            summary.append(\"    Score: \").append(match.score()).append(\"\\n\");\n        });\n    }\n\n    return summary.toString();\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/ProblemSizeStatistics.java-format": "```java\nprivate static String format(double number, DecimalFormat decimalFormat, Locale locale) {\n    DecimalFormatSymbols symbols = new DecimalFormatSymbols(locale);\n    decimalFormat.setDecimalFormatSymbols(symbols);\n    return decimalFormat.format(number);\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/api/solver/SolverManager.java-solveAndListen": "```java\n@Deprecated(forRemoval = true, since = \"1.6.0\")\ndefault SolverJob<Solution_, ProblemId_> solveAndListen(ProblemId_ problemId,\n                                                        Function<? super ProblemId_, ? extends Solution_> problemFinder,\n                                                        Consumer<? super Solution_> bestSolutionConsumer) {\n    // Create a SolverJobBuilder using the solveBuilder method.\n    SolverJobBuilder<Solution_, ProblemId_> builder = solveBuilder()\n            .withProblemId(problemId)  // Set the unique problem identifier.\n            .withProblemFinder(problemFinder)  // Set the problemFinder function.\n            .withBestSolutionConsumer(bestSolutionConsumer);  // Set the consumer to handle best solutions.\n    \n    // Execute the builder to start the solver and return the SolverJob.\n    return builder.run();\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/solver/SolverConfig.java-withTerminationSpentLimit": "```java\npublic SolverConfig withTerminationSpentLimit(Duration spentLimit) {\n    if (terminationConfig == null) {\n        terminationConfig = new TerminationConfig();\n    }\n    terminationConfig.withSpentLimit(spentLimit);\n    return this;\n}\n```", "timefold-solver-core/src/main/java/ai/timefold/solver/core/config/util/ConfigUtils.java-meldProperty": "```java\npublic static <T> T meldProperty(T a, T b) {\n    if (a == null && b == null) {\n        return null;\n    } else if (a != null && b != null) {\n        return mergeProperty(a, b);\n    } else {\n        return a != null ? a : b;\n    }\n}\n```"}